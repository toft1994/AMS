
RobotSorter.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000000cc  00800200  000025e6  0000267a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000025e6  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000061f  008002cc  008002cc  00002746  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00002746  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00002778  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000568  00000000  00000000  000027b8  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00007519  00000000  00000000  00002d20  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00003097  00000000  00000000  0000a239  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00002faa  00000000  00000000  0000d2d0  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000f84  00000000  00000000  0001027c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00001c9c  00000000  00000000  00011200  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000036ef  00000000  00000000  00012e9c  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000478  00000000  00000000  0001658b  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	71 c0       	rjmp	.+226    	; 0xe4 <__ctors_end>
       2:	00 00       	nop
       4:	8f c0       	rjmp	.+286    	; 0x124 <__bad_interrupt>
       6:	00 00       	nop
       8:	8d c0       	rjmp	.+282    	; 0x124 <__bad_interrupt>
       a:	00 00       	nop
       c:	8b c0       	rjmp	.+278    	; 0x124 <__bad_interrupt>
       e:	00 00       	nop
      10:	89 c0       	rjmp	.+274    	; 0x124 <__bad_interrupt>
      12:	00 00       	nop
      14:	87 c0       	rjmp	.+270    	; 0x124 <__bad_interrupt>
      16:	00 00       	nop
      18:	85 c0       	rjmp	.+266    	; 0x124 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	83 c0       	rjmp	.+262    	; 0x124 <__bad_interrupt>
      1e:	00 00       	nop
      20:	81 c0       	rjmp	.+258    	; 0x124 <__bad_interrupt>
      22:	00 00       	nop
      24:	7f c0       	rjmp	.+254    	; 0x124 <__bad_interrupt>
      26:	00 00       	nop
      28:	7d c0       	rjmp	.+250    	; 0x124 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	7b c0       	rjmp	.+246    	; 0x124 <__bad_interrupt>
      2e:	00 00       	nop
      30:	79 c0       	rjmp	.+242    	; 0x124 <__bad_interrupt>
      32:	00 00       	nop
      34:	77 c0       	rjmp	.+238    	; 0x124 <__bad_interrupt>
      36:	00 00       	nop
      38:	75 c0       	rjmp	.+234    	; 0x124 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	73 c0       	rjmp	.+230    	; 0x124 <__bad_interrupt>
      3e:	00 00       	nop
      40:	71 c0       	rjmp	.+226    	; 0x124 <__bad_interrupt>
      42:	00 00       	nop
      44:	6f c0       	rjmp	.+222    	; 0x124 <__bad_interrupt>
      46:	00 00       	nop
      48:	6d c0       	rjmp	.+218    	; 0x124 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	6b c0       	rjmp	.+214    	; 0x124 <__bad_interrupt>
      4e:	00 00       	nop
      50:	69 c0       	rjmp	.+210    	; 0x124 <__bad_interrupt>
      52:	00 00       	nop
      54:	0c 94 27 0c 	jmp	0x184e	; 0x184e <__vector_21>
      58:	65 c0       	rjmp	.+202    	; 0x124 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	63 c0       	rjmp	.+198    	; 0x124 <__bad_interrupt>
      5e:	00 00       	nop
      60:	61 c0       	rjmp	.+194    	; 0x124 <__bad_interrupt>
      62:	00 00       	nop
      64:	5f c0       	rjmp	.+190    	; 0x124 <__bad_interrupt>
      66:	00 00       	nop
      68:	5d c0       	rjmp	.+186    	; 0x124 <__bad_interrupt>
      6a:	00 00       	nop
      6c:	5b c0       	rjmp	.+182    	; 0x124 <__bad_interrupt>
      6e:	00 00       	nop
      70:	59 c0       	rjmp	.+178    	; 0x124 <__bad_interrupt>
      72:	00 00       	nop
      74:	57 c0       	rjmp	.+174    	; 0x124 <__bad_interrupt>
      76:	00 00       	nop
      78:	55 c0       	rjmp	.+170    	; 0x124 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	53 c0       	rjmp	.+166    	; 0x124 <__bad_interrupt>
      7e:	00 00       	nop
      80:	51 c0       	rjmp	.+162    	; 0x124 <__bad_interrupt>
      82:	00 00       	nop
      84:	4f c0       	rjmp	.+158    	; 0x124 <__bad_interrupt>
      86:	00 00       	nop
      88:	4d c0       	rjmp	.+154    	; 0x124 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	4b c0       	rjmp	.+150    	; 0x124 <__bad_interrupt>
      8e:	00 00       	nop
      90:	49 c0       	rjmp	.+146    	; 0x124 <__bad_interrupt>
      92:	00 00       	nop
      94:	47 c0       	rjmp	.+142    	; 0x124 <__bad_interrupt>
      96:	00 00       	nop
      98:	45 c0       	rjmp	.+138    	; 0x124 <__bad_interrupt>
      9a:	00 00       	nop
      9c:	43 c0       	rjmp	.+134    	; 0x124 <__bad_interrupt>
      9e:	00 00       	nop
      a0:	41 c0       	rjmp	.+130    	; 0x124 <__bad_interrupt>
      a2:	00 00       	nop
      a4:	f6 c1       	rjmp	.+1004   	; 0x492 <__vector_41>
      a6:	00 00       	nop
      a8:	3d c0       	rjmp	.+122    	; 0x124 <__bad_interrupt>
      aa:	00 00       	nop
      ac:	3b c0       	rjmp	.+118    	; 0x124 <__bad_interrupt>
      ae:	00 00       	nop
      b0:	39 c0       	rjmp	.+114    	; 0x124 <__bad_interrupt>
      b2:	00 00       	nop
      b4:	c9 c1       	rjmp	.+914    	; 0x448 <__vector_45>
      b6:	00 00       	nop
      b8:	35 c0       	rjmp	.+106    	; 0x124 <__bad_interrupt>
      ba:	00 00       	nop
      bc:	33 c0       	rjmp	.+102    	; 0x124 <__bad_interrupt>
      be:	00 00       	nop
      c0:	31 c0       	rjmp	.+98     	; 0x124 <__bad_interrupt>
      c2:	00 00       	nop
      c4:	2f c0       	rjmp	.+94     	; 0x124 <__bad_interrupt>
      c6:	00 00       	nop
      c8:	2d c0       	rjmp	.+90     	; 0x124 <__bad_interrupt>
      ca:	00 00       	nop
      cc:	2b c0       	rjmp	.+86     	; 0x124 <__bad_interrupt>
      ce:	00 00       	nop
      d0:	29 c0       	rjmp	.+82     	; 0x124 <__bad_interrupt>
      d2:	00 00       	nop
      d4:	27 c0       	rjmp	.+78     	; 0x124 <__bad_interrupt>
      d6:	00 00       	nop
      d8:	25 c0       	rjmp	.+74     	; 0x124 <__bad_interrupt>
      da:	00 00       	nop
      dc:	23 c0       	rjmp	.+70     	; 0x124 <__bad_interrupt>
      de:	00 00       	nop
      e0:	21 c0       	rjmp	.+66     	; 0x124 <__bad_interrupt>
	...

000000e4 <__ctors_end>:
      e4:	11 24       	eor	r1, r1
      e6:	1f be       	out	0x3f, r1	; 63
      e8:	cf ef       	ldi	r28, 0xFF	; 255
      ea:	d1 e2       	ldi	r29, 0x21	; 33
      ec:	de bf       	out	0x3e, r29	; 62
      ee:	cd bf       	out	0x3d, r28	; 61
      f0:	00 e0       	ldi	r16, 0x00	; 0
      f2:	0c bf       	out	0x3c, r16	; 60

000000f4 <__do_copy_data>:
      f4:	12 e0       	ldi	r17, 0x02	; 2
      f6:	a0 e0       	ldi	r26, 0x00	; 0
      f8:	b2 e0       	ldi	r27, 0x02	; 2
      fa:	e6 ee       	ldi	r30, 0xE6	; 230
      fc:	f5 e2       	ldi	r31, 0x25	; 37
      fe:	00 e0       	ldi	r16, 0x00	; 0
     100:	0b bf       	out	0x3b, r16	; 59
     102:	02 c0       	rjmp	.+4      	; 0x108 <__do_copy_data+0x14>
     104:	07 90       	elpm	r0, Z+
     106:	0d 92       	st	X+, r0
     108:	ac 3c       	cpi	r26, 0xCC	; 204
     10a:	b1 07       	cpc	r27, r17
     10c:	d9 f7       	brne	.-10     	; 0x104 <__do_copy_data+0x10>

0000010e <__do_clear_bss>:
     10e:	28 e0       	ldi	r18, 0x08	; 8
     110:	ac ec       	ldi	r26, 0xCC	; 204
     112:	b2 e0       	ldi	r27, 0x02	; 2
     114:	01 c0       	rjmp	.+2      	; 0x118 <.do_clear_bss_start>

00000116 <.do_clear_bss_loop>:
     116:	1d 92       	st	X+, r1

00000118 <.do_clear_bss_start>:
     118:	ab 3e       	cpi	r26, 0xEB	; 235
     11a:	b2 07       	cpc	r27, r18
     11c:	e1 f7       	brne	.-8      	; 0x116 <.do_clear_bss_loop>
     11e:	fe d2       	rcall	.+1532   	; 0x71c <main>
     120:	0c 94 f1 12 	jmp	0x25e2	; 0x25e2 <_exit>

00000124 <__bad_interrupt>:
     124:	6d cf       	rjmp	.-294    	; 0x0 <__vectors>

00000126 <_ZN5ColorC1Ev>:
	_greenPeriod = greenPeriod;
}

void Color::setWhitePeriod( uint16_t whitePeriod )
{
	_whitePeriod = whitePeriod;
     126:	08 95       	ret

00000128 <_ZN5Color12getRedPeriodEv>:
     128:	fc 01       	movw	r30, r24
     12a:	80 81       	ld	r24, Z
     12c:	91 81       	ldd	r25, Z+1	; 0x01
     12e:	08 95       	ret

00000130 <_ZN5Color13getBluePeriodEv>:
     130:	fc 01       	movw	r30, r24
     132:	82 81       	ldd	r24, Z+2	; 0x02
     134:	93 81       	ldd	r25, Z+3	; 0x03
     136:	08 95       	ret

00000138 <_ZN5Color14getGreenPeriodEv>:
     138:	fc 01       	movw	r30, r24
     13a:	84 81       	ldd	r24, Z+4	; 0x04
     13c:	95 81       	ldd	r25, Z+5	; 0x05
     13e:	08 95       	ret

00000140 <_ZN5Color12setRedPeriodEj>:
     140:	fc 01       	movw	r30, r24
     142:	71 83       	std	Z+1, r23	; 0x01
     144:	60 83       	st	Z, r22
     146:	08 95       	ret

00000148 <_ZN5Color13setBluePeriodEj>:
     148:	fc 01       	movw	r30, r24
     14a:	73 83       	std	Z+3, r23	; 0x03
     14c:	62 83       	std	Z+2, r22	; 0x02
     14e:	08 95       	ret

00000150 <_ZN5Color14setGreenPeriodEj>:
     150:	fc 01       	movw	r30, r24
     152:	75 83       	std	Z+5, r23	; 0x05
     154:	64 83       	std	Z+4, r22	; 0x04
     156:	08 95       	ret

00000158 <_ZN5Color13setColorIndexEh>:
}

void Color::setColorIndex( uint8_t index )
{
	_colorIndex = index;
     158:	fc 01       	movw	r30, r24
     15a:	60 87       	std	Z+8, r22	; 0x08
     15c:	08 95       	ret

0000015e <_ZN11ColorSensor9setFilterE6Filter>:
	}
}

void ColorSensor::setFilter( Filter filter_ )
{
	switch ( filter_ )
     15e:	61 30       	cpi	r22, 0x01	; 1
     160:	31 f0       	breq	.+12     	; 0x16e <_ZN11ColorSensor9setFilterE6Filter+0x10>
     162:	d0 f0       	brcs	.+52     	; 0x198 <_ZN11ColorSensor9setFilterE6Filter+0x3a>
     164:	62 30       	cpi	r22, 0x02	; 2
     166:	89 f0       	breq	.+34     	; 0x18a <_ZN11ColorSensor9setFilterE6Filter+0x2c>
     168:	63 30       	cpi	r22, 0x03	; 3
     16a:	41 f0       	breq	.+16     	; 0x17c <_ZN11ColorSensor9setFilterE6Filter+0x1e>
     16c:	08 95       	ret
	{
	case redFilter:
		COLORSENSOR_S2_PORT &= ~( COLORSENSOR_S2_PIN );
     16e:	88 b1       	in	r24, 0x08	; 8
     170:	8b 7f       	andi	r24, 0xFB	; 251
     172:	88 b9       	out	0x08, r24	; 8
		COLORSENSOR_S3_PORT &= ~( COLORSENSOR_S3_PIN );
     174:	88 b1       	in	r24, 0x08	; 8
     176:	87 7f       	andi	r24, 0xF7	; 247
     178:	88 b9       	out	0x08, r24	; 8
		break;
     17a:	08 95       	ret

	case blueFilter:
		COLORSENSOR_S2_PORT &= ~( COLORSENSOR_S2_PIN );
     17c:	88 b1       	in	r24, 0x08	; 8
     17e:	8b 7f       	andi	r24, 0xFB	; 251
     180:	88 b9       	out	0x08, r24	; 8
		COLORSENSOR_S3_PORT |= COLORSENSOR_S3_PIN;
     182:	88 b1       	in	r24, 0x08	; 8
     184:	88 60       	ori	r24, 0x08	; 8
     186:	88 b9       	out	0x08, r24	; 8
		break;
     188:	08 95       	ret

	case greenFilter:
		COLORSENSOR_S2_PORT |= COLORSENSOR_S2_PIN;
     18a:	88 b1       	in	r24, 0x08	; 8
     18c:	84 60       	ori	r24, 0x04	; 4
     18e:	88 b9       	out	0x08, r24	; 8
		COLORSENSOR_S3_PORT |= COLORSENSOR_S3_PIN;
     190:	88 b1       	in	r24, 0x08	; 8
     192:	88 60       	ori	r24, 0x08	; 8
     194:	88 b9       	out	0x08, r24	; 8
		break;
     196:	08 95       	ret

	case noFilter:
		COLORSENSOR_S2_PORT |= COLORSENSOR_S2_PIN;
     198:	88 b1       	in	r24, 0x08	; 8
     19a:	84 60       	ori	r24, 0x04	; 4
     19c:	88 b9       	out	0x08, r24	; 8
		COLORSENSOR_S3_PORT &= ~( COLORSENSOR_S3_PIN );
     19e:	88 b1       	in	r24, 0x08	; 8
     1a0:	87 7f       	andi	r24, 0xF7	; 247
     1a2:	88 b9       	out	0x08, r24	; 8
     1a4:	08 95       	ret

000001a6 <_ZN11ColorSensor8getColorEv>:
ColorSensor::~ColorSensor()
{	
}

uint8_t ColorSensor::getColor()
{
     1a6:	8f 92       	push	r8
     1a8:	9f 92       	push	r9
     1aa:	af 92       	push	r10
     1ac:	bf 92       	push	r11
     1ae:	cf 92       	push	r12
     1b0:	df 92       	push	r13
     1b2:	ef 92       	push	r14
     1b4:	ff 92       	push	r15
     1b6:	0f 93       	push	r16
     1b8:	1f 93       	push	r17
     1ba:	cf 93       	push	r28
     1bc:	df 93       	push	r29
     1be:	ec 01       	movw	r28, r24
	// Get period values from all filters
	setFilter( redFilter );
     1c0:	61 e0       	ldi	r22, 0x01	; 1
     1c2:	cd df       	rcall	.-102    	; 0x15e <_ZN11ColorSensor9setFilterE6Filter>
	uint16_t redPeriod = frequency_.getPeriod();
     1c4:	ce 01       	movw	r24, r28
     1c6:	0e d1       	rcall	.+540    	; 0x3e4 <_ZN6Timer49getPeriodEv>
     1c8:	8c 01       	movw	r16, r24

	setFilter( blueFilter );
     1ca:	63 e0       	ldi	r22, 0x03	; 3
     1cc:	ce 01       	movw	r24, r28
	uint16_t bluePeriod = frequency_.getPeriod();  
     1ce:	c7 df       	rcall	.-114    	; 0x15e <_ZN11ColorSensor9setFilterE6Filter>
     1d0:	ce 01       	movw	r24, r28
     1d2:	08 d1       	rcall	.+528    	; 0x3e4 <_ZN6Timer49getPeriodEv>

	setFilter( greenFilter );
     1d4:	7c 01       	movw	r14, r24
     1d6:	62 e0       	ldi	r22, 0x02	; 2
     1d8:	ce 01       	movw	r24, r28
	uint16_t greenPeriod = frequency_.getPeriod();
     1da:	c1 df       	rcall	.-126    	; 0x15e <_ZN11ColorSensor9setFilterE6Filter>
     1dc:	ce 01       	movw	r24, r28
     1de:	02 d1       	rcall	.+516    	; 0x3e4 <_ZN6Timer49getPeriodEv>
     1e0:	6c 01       	movw	r12, r24
	
	// Check all stored colors against read values	
	for ( uint8_t index = 0U; index < 10; index++)
     1e2:	91 2c       	mov	r9, r1
     1e4:	89 e0       	ldi	r24, 0x09	; 9
     1e6:	89 15       	cp	r24, r9
     1e8:	08 f4       	brcc	.+2      	; 0x1ec <_ZN11ColorSensor8getColorEv+0x46>
     1ea:	4a c0       	rjmp	.+148    	; 0x280 <_ZN11ColorSensor8getColorEv+0xda>
	{
		//uint16_t storedRed = _colors[index].getRedPeriod();
		//uint16_t storedBlue = _colors[index].getBluePeriod();
		//uint16_t storedGreen = _colors[index].getGreenPeriod();		
		
		if ( _colors[index].getRedPeriod() + 10 > redPeriod && _colors[index].getRedPeriod() - 10 < redPeriod )
     1ec:	29 2d       	mov	r18, r9
     1ee:	30 e0       	ldi	r19, 0x00	; 0
     1f0:	59 01       	movw	r10, r18
     1f2:	aa 0c       	add	r10, r10
     1f4:	bb 1c       	adc	r11, r11
     1f6:	aa 0c       	add	r10, r10
     1f8:	bb 1c       	adc	r11, r11
     1fa:	aa 0c       	add	r10, r10
     1fc:	bb 1c       	adc	r11, r11
     1fe:	a2 0e       	add	r10, r18
     200:	b3 1e       	adc	r11, r19
     202:	8f ef       	ldi	r24, 0xFF	; 255
     204:	a8 1a       	sub	r10, r24
     206:	b8 0a       	sbc	r11, r24
     208:	ac 0e       	add	r10, r28
     20a:	bd 1e       	adc	r11, r29
     20c:	c5 01       	movw	r24, r10
     20e:	8c df       	rcall	.-232    	; 0x128 <_ZN5Color12getRedPeriodEv>
     210:	0a 96       	adiw	r24, 0x0a	; 10
     212:	08 17       	cp	r16, r24
     214:	19 07       	cpc	r17, r25
     216:	48 f4       	brcc	.+18     	; 0x22a <_ZN11ColorSensor8getColorEv+0x84>
     218:	c5 01       	movw	r24, r10
     21a:	86 df       	rcall	.-244    	; 0x128 <_ZN5Color12getRedPeriodEv>
     21c:	0a 97       	sbiw	r24, 0x0a	; 10
     21e:	80 17       	cp	r24, r16
     220:	91 07       	cpc	r25, r17
     222:	28 f4       	brcc	.+10     	; 0x22e <_ZN11ColorSensor8getColorEv+0x88>
     224:	88 24       	eor	r8, r8
     226:	83 94       	inc	r8
     228:	03 c0       	rjmp	.+6      	; 0x230 <_ZN11ColorSensor8getColorEv+0x8a>
     22a:	81 2c       	mov	r8, r1
     22c:	01 c0       	rjmp	.+2      	; 0x230 <_ZN11ColorSensor8getColorEv+0x8a>
     22e:	81 2c       	mov	r8, r1
		{
			if ( _colors[index].getBluePeriod() + 10 > bluePeriod && _colors[index].getBluePeriod() - 10 < bluePeriod )
     230:	88 20       	and	r8, r8
     232:	21 f1       	breq	.+72     	; 0x27c <_ZN11ColorSensor8getColorEv+0xd6>
     234:	c5 01       	movw	r24, r10
     236:	7c df       	rcall	.-264    	; 0x130 <_ZN5Color13getBluePeriodEv>
     238:	0a 96       	adiw	r24, 0x0a	; 10
     23a:	e8 16       	cp	r14, r24
     23c:	f9 06       	cpc	r15, r25
     23e:	38 f4       	brcc	.+14     	; 0x24e <_ZN11ColorSensor8getColorEv+0xa8>
     240:	c5 01       	movw	r24, r10
     242:	76 df       	rcall	.-276    	; 0x130 <_ZN5Color13getBluePeriodEv>
     244:	0a 97       	sbiw	r24, 0x0a	; 10
     246:	8e 15       	cp	r24, r14
     248:	9f 05       	cpc	r25, r15
     24a:	18 f4       	brcc	.+6      	; 0x252 <_ZN11ColorSensor8getColorEv+0xac>
     24c:	03 c0       	rjmp	.+6      	; 0x254 <_ZN11ColorSensor8getColorEv+0xae>
     24e:	81 2c       	mov	r8, r1
     250:	01 c0       	rjmp	.+2      	; 0x254 <_ZN11ColorSensor8getColorEv+0xae>
     252:	81 2c       	mov	r8, r1
			{
				if ( _colors[index].getGreenPeriod() + 10 > greenPeriod && _colors[index].getGreenPeriod() - 10 < greenPeriod )
     254:	88 20       	and	r8, r8
     256:	91 f0       	breq	.+36     	; 0x27c <_ZN11ColorSensor8getColorEv+0xd6>
     258:	c5 01       	movw	r24, r10
     25a:	6e df       	rcall	.-292    	; 0x138 <_ZN5Color14getGreenPeriodEv>
     25c:	0a 96       	adiw	r24, 0x0a	; 10
     25e:	c8 16       	cp	r12, r24
     260:	d9 06       	cpc	r13, r25
     262:	38 f4       	brcc	.+14     	; 0x272 <_ZN11ColorSensor8getColorEv+0xcc>
     264:	c5 01       	movw	r24, r10
     266:	68 df       	rcall	.-304    	; 0x138 <_ZN5Color14getGreenPeriodEv>
     268:	0a 97       	sbiw	r24, 0x0a	; 10
     26a:	8c 15       	cp	r24, r12
     26c:	9d 05       	cpc	r25, r13
     26e:	18 f4       	brcc	.+6      	; 0x276 <_ZN11ColorSensor8getColorEv+0xd0>
     270:	03 c0       	rjmp	.+6      	; 0x278 <_ZN11ColorSensor8getColorEv+0xd2>
     272:	81 2c       	mov	r8, r1
     274:	01 c0       	rjmp	.+2      	; 0x278 <_ZN11ColorSensor8getColorEv+0xd2>
     276:	81 2c       	mov	r8, r1
     278:	81 10       	cpse	r8, r1
     27a:	04 c0       	rjmp	.+8      	; 0x284 <_ZN11ColorSensor8getColorEv+0xde>

	setFilter( greenFilter );
	uint16_t greenPeriod = frequency_.getPeriod();
	
	// Check all stored colors against read values	
	for ( uint8_t index = 0U; index < 10; index++)
     27c:	93 94       	inc	r9
     27e:	b2 cf       	rjmp	.-156    	; 0x1e4 <_ZN11ColorSensor8getColorEv+0x3e>
			}
		}
	}
	
	// Return default value
	return 255;
     280:	8f ef       	ldi	r24, 0xFF	; 255
     282:	01 c0       	rjmp	.+2      	; 0x286 <_ZN11ColorSensor8getColorEv+0xe0>
		{
			if ( _colors[index].getBluePeriod() + 10 > bluePeriod && _colors[index].getBluePeriod() - 10 < bluePeriod )
			{
				if ( _colors[index].getGreenPeriod() + 10 > greenPeriod && _colors[index].getGreenPeriod() - 10 < greenPeriod )
				{
					return index;
     284:	89 2d       	mov	r24, r9
		}
	}
	
	// Return default value
	return 255;
}
     286:	df 91       	pop	r29
     288:	cf 91       	pop	r28
     28a:	1f 91       	pop	r17
     28c:	0f 91       	pop	r16
     28e:	ff 90       	pop	r15
     290:	ef 90       	pop	r14
     292:	df 90       	pop	r13
     294:	cf 90       	pop	r12
     296:	bf 90       	pop	r11
     298:	af 90       	pop	r10
     29a:	9f 90       	pop	r9
     29c:	8f 90       	pop	r8
     29e:	08 95       	ret

000002a0 <_ZN11ColorSensor17addCalibrateColorEh>:

void ColorSensor::addCalibrateColor( uint8_t colorIndex )
{
     2a0:	ff 92       	push	r15
     2a2:	0f 93       	push	r16
     2a4:	1f 93       	push	r17
     2a6:	cf 93       	push	r28
     2a8:	df 93       	push	r29
	if ( colorIndex < 10U )
     2aa:	6a 30       	cpi	r22, 0x0A	; 10
     2ac:	50 f5       	brcc	.+84     	; 0x302 <_ZN11ColorSensor17addCalibrateColorEh+0x62>
     2ae:	f6 2e       	mov	r15, r22
     2b0:	8c 01       	movw	r16, r24
	{	
		// Set all colors
		setFilter( redFilter );
     2b2:	61 e0       	ldi	r22, 0x01	; 1
     2b4:	54 df       	rcall	.-344    	; 0x15e <_ZN11ColorSensor9setFilterE6Filter>
		_colors[colorIndex].setRedPeriod( frequency_.getPeriod() );
     2b6:	c8 01       	movw	r24, r16
     2b8:	95 d0       	rcall	.+298    	; 0x3e4 <_ZN6Timer49getPeriodEv>
     2ba:	2f 2d       	mov	r18, r15
     2bc:	30 e0       	ldi	r19, 0x00	; 0
     2be:	e9 01       	movw	r28, r18
     2c0:	cc 0f       	add	r28, r28
     2c2:	dd 1f       	adc	r29, r29
     2c4:	cc 0f       	add	r28, r28
     2c6:	dd 1f       	adc	r29, r29
     2c8:	cc 0f       	add	r28, r28
     2ca:	dd 1f       	adc	r29, r29
     2cc:	c2 0f       	add	r28, r18
     2ce:	d3 1f       	adc	r29, r19
     2d0:	21 96       	adiw	r28, 0x01	; 1
     2d2:	c0 0f       	add	r28, r16
     2d4:	d1 1f       	adc	r29, r17
     2d6:	bc 01       	movw	r22, r24
     2d8:	ce 01       	movw	r24, r28
     2da:	32 df       	rcall	.-412    	; 0x140 <_ZN5Color12setRedPeriodEj>

		setFilter( blueFilter );
     2dc:	63 e0       	ldi	r22, 0x03	; 3
     2de:	c8 01       	movw	r24, r16
     2e0:	3e df       	rcall	.-388    	; 0x15e <_ZN11ColorSensor9setFilterE6Filter>
		_colors[colorIndex].setBluePeriod( frequency_.getPeriod() );
     2e2:	c8 01       	movw	r24, r16
     2e4:	7f d0       	rcall	.+254    	; 0x3e4 <_ZN6Timer49getPeriodEv>
     2e6:	bc 01       	movw	r22, r24
     2e8:	ce 01       	movw	r24, r28
     2ea:	2e df       	rcall	.-420    	; 0x148 <_ZN5Color13setBluePeriodEj>
		
		setFilter( greenFilter );
     2ec:	62 e0       	ldi	r22, 0x02	; 2
     2ee:	c8 01       	movw	r24, r16
     2f0:	36 df       	rcall	.-404    	; 0x15e <_ZN11ColorSensor9setFilterE6Filter>
		_colors[colorIndex].setGreenPeriod( frequency_.getPeriod() );
     2f2:	c8 01       	movw	r24, r16
     2f4:	77 d0       	rcall	.+238    	; 0x3e4 <_ZN6Timer49getPeriodEv>
     2f6:	bc 01       	movw	r22, r24
     2f8:	ce 01       	movw	r24, r28
     2fa:	2a df       	rcall	.-428    	; 0x150 <_ZN5Color14setGreenPeriodEj>
     2fc:	6f 2d       	mov	r22, r15
				
		// Set index
		_colors[colorIndex].setColorIndex( colorIndex );
     2fe:	ce 01       	movw	r24, r28
     300:	2b df       	rcall	.-426    	; 0x158 <_ZN5Color13setColorIndexEh>
     302:	df 91       	pop	r29
     304:	cf 91       	pop	r28
	}
	else
	{
		/* Cant add more colors. Increase size of array. */
	}
}
     306:	1f 91       	pop	r17
     308:	0f 91       	pop	r16
     30a:	ff 90       	pop	r15
     30c:	08 95       	ret

0000030e <_ZN11ColorSensor19setFrequencyscalingE16FrequencyScaling>:
     30e:	61 30       	cpi	r22, 0x01	; 1
     310:	69 f0       	breq	.+26     	; 0x32c <_ZN11ColorSensor19setFrequencyscalingE16FrequencyScaling+0x1e>
	}	
}

void ColorSensor::setFrequencyscaling( FrequencyScaling scaling )
{
	switch (scaling)
     312:	28 f0       	brcs	.+10     	; 0x31e <_ZN11ColorSensor19setFrequencyscalingE16FrequencyScaling+0x10>
     314:	62 30       	cpi	r22, 0x02	; 2
     316:	89 f0       	breq	.+34     	; 0x33a <_ZN11ColorSensor19setFrequencyscalingE16FrequencyScaling+0x2c>
     318:	63 30       	cpi	r22, 0x03	; 3
     31a:	b1 f0       	breq	.+44     	; 0x348 <_ZN11ColorSensor19setFrequencyscalingE16FrequencyScaling+0x3a>
     31c:	08 95       	ret
	{
	case powerDown:
		COLORSENSOR_S0_PORT &= ~( COLORSENSOR_S0_PIN );
     31e:	88 b1       	in	r24, 0x08	; 8
     320:	8e 7f       	andi	r24, 0xFE	; 254
     322:	88 b9       	out	0x08, r24	; 8
		COLORSENSOR_S1_PORT &= ~( COLORSENSOR_S1_PIN );
     324:	88 b1       	in	r24, 0x08	; 8
     326:	8d 7f       	andi	r24, 0xFD	; 253
     328:	88 b9       	out	0x08, r24	; 8
		break;
     32a:	08 95       	ret

	case twoPercent:
		COLORSENSOR_S0_PORT &= ~( COLORSENSOR_S0_PIN );
     32c:	88 b1       	in	r24, 0x08	; 8
     32e:	8e 7f       	andi	r24, 0xFE	; 254
     330:	88 b9       	out	0x08, r24	; 8
		COLORSENSOR_S1_PORT |= COLORSENSOR_S1_PIN;
     332:	88 b1       	in	r24, 0x08	; 8
     334:	82 60       	ori	r24, 0x02	; 2
     336:	88 b9       	out	0x08, r24	; 8
		break;
     338:	08 95       	ret

	case twentyPercent:
		COLORSENSOR_S0_PORT |= COLORSENSOR_S0_PIN;
     33a:	88 b1       	in	r24, 0x08	; 8
     33c:	81 60       	ori	r24, 0x01	; 1
     33e:	88 b9       	out	0x08, r24	; 8
		COLORSENSOR_S1_PORT &= ~( COLORSENSOR_S1_PIN );
     340:	88 b1       	in	r24, 0x08	; 8
     342:	8d 7f       	andi	r24, 0xFD	; 253
     344:	88 b9       	out	0x08, r24	; 8
		break;
     346:	08 95       	ret

	case hundredPercent:
		COLORSENSOR_S0_PORT |= COLORSENSOR_S0_PIN;
     348:	88 b1       	in	r24, 0x08	; 8
     34a:	81 60       	ori	r24, 0x01	; 1
     34c:	88 b9       	out	0x08, r24	; 8
		COLORSENSOR_S1_PORT |= COLORSENSOR_S1_PIN;
     34e:	88 b1       	in	r24, 0x08	; 8
     350:	82 60       	ori	r24, 0x02	; 2
     352:	88 b9       	out	0x08, r24	; 8
     354:	08 95       	ret

00000356 <_ZN11ColorSensorC1E16FrequencyScaling>:
#include "FreeRTOS.h"
#include "task.h"
#include "portmacro.h"

// default constructor
ColorSensor::ColorSensor( FrequencyScaling scaling )
     356:	bf 92       	push	r11
     358:	cf 92       	push	r12
     35a:	df 92       	push	r13
     35c:	ef 92       	push	r14
     35e:	ff 92       	push	r15
     360:	0f 93       	push	r16
     362:	1f 93       	push	r17
     364:	cf 93       	push	r28
     366:	df 93       	push	r29
     368:	1f 92       	push	r1
     36a:	cd b7       	in	r28, 0x3d	; 61
     36c:	de b7       	in	r29, 0x3e	; 62
     36e:	6c 01       	movw	r12, r24
     370:	b6 2e       	mov	r11, r22
     372:	29 d0       	rcall	.+82     	; 0x3c6 <_ZN6Timer4C1Ev>
     374:	76 01       	movw	r14, r12
     376:	8f ef       	ldi	r24, 0xFF	; 255
     378:	e8 1a       	sub	r14, r24
     37a:	f8 0a       	sbc	r15, r24
     37c:	09 e0       	ldi	r16, 0x09	; 9
     37e:	10 e0       	ldi	r17, 0x00	; 0
     380:	0f 3f       	cpi	r16, 0xFF	; 255
     382:	8f ef       	ldi	r24, 0xFF	; 255
     384:	18 07       	cpc	r17, r24
     386:	41 f0       	breq	.+16     	; 0x398 <_ZN11ColorSensorC1E16FrequencyScaling+0x42>
     388:	c7 01       	movw	r24, r14
     38a:	cd de       	rcall	.-614    	; 0x126 <_ZN5ColorC1Ev>
     38c:	89 e0       	ldi	r24, 0x09	; 9
     38e:	e8 0e       	add	r14, r24
     390:	f1 1c       	adc	r15, r1
     392:	01 50       	subi	r16, 0x01	; 1
     394:	11 09       	sbc	r17, r1
     396:	f4 cf       	rjmp	.-24     	; 0x380 <_ZN11ColorSensorC1E16FrequencyScaling+0x2a>
{
	// DE HER SKAL ÆNDRES!!!
	// Set ports to the right values.
	DDRC = 0xFF;
     398:	8f ef       	ldi	r24, 0xFF	; 255
     39a:	87 b9       	out	0x07, r24	; 7
	DDRD = 0x00;
     39c:	1a b8       	out	0x0a, r1	; 10
	frequency_ = Timer4();
     39e:	ce 01       	movw	r24, r28
     3a0:	01 96       	adiw	r24, 0x01	; 1
     3a2:	11 d0       	rcall	.+34     	; 0x3c6 <_ZN6Timer4C1Ev>

	// Set default filter and scaling
	setFilter( noFilter );
     3a4:	60 e0       	ldi	r22, 0x00	; 0
     3a6:	c6 01       	movw	r24, r12
     3a8:	da de       	rcall	.-588    	; 0x15e <_ZN11ColorSensor9setFilterE6Filter>
	setFrequencyscaling( scaling );
     3aa:	6b 2d       	mov	r22, r11
     3ac:	c6 01       	movw	r24, r12
     3ae:	af df       	rcall	.-162    	; 0x30e <_ZN11ColorSensor19setFrequencyscalingE16FrequencyScaling>
     3b0:	0f 90       	pop	r0
}
     3b2:	df 91       	pop	r29
     3b4:	cf 91       	pop	r28
     3b6:	1f 91       	pop	r17
     3b8:	0f 91       	pop	r16
     3ba:	ff 90       	pop	r15
     3bc:	ef 90       	pop	r14
     3be:	df 90       	pop	r13
     3c0:	cf 90       	pop	r12
     3c2:	bf 90       	pop	r11
     3c4:	08 95       	ret

000003c6 <_ZN6Timer4C1Ev>:
//volatile float tick = 0.000064;

Timer4::Timer4()
{
	// Setup timer to normal mode and pre scaler to 1
	TCCR4A = 0U;
     3c6:	10 92 a0 00 	sts	0x00A0, r1	; 0x8000a0 <__TEXT_REGION_LENGTH__+0x7000a0>
	TCCR4B = ( 1 << ICNC4 ) | ( 1 << ICES4 ) | ( 1 << CS40 );
     3ca:	81 ec       	ldi	r24, 0xC1	; 193
     3cc:	80 93 a1 00 	sts	0x00A1, r24	; 0x8000a1 <__TEXT_REGION_LENGTH__+0x7000a1>
	TCCR4C = 0U;
     3d0:	10 92 a2 00 	sts	0x00A2, r1	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
	
	// Clear flags and set counter to zero
	TIFR4 = ( 1 << ICF4 ) | ( 1 << TOV4 );
     3d4:	81 e2       	ldi	r24, 0x21	; 33
     3d6:	89 bb       	out	0x19, r24	; 25
	TCNT4 = 0;        
     3d8:	10 92 a5 00 	sts	0x00A5, r1	; 0x8000a5 <__TEXT_REGION_LENGTH__+0x7000a5>
     3dc:	10 92 a4 00 	sts	0x00A4, r1	; 0x8000a4 <__TEXT_REGION_LENGTH__+0x7000a4>

	// Enable global interrupts
    sei();
     3e0:	78 94       	sei
     3e2:	08 95       	ret

000003e4 <_ZN6Timer49getPeriodEv>:
}

uint16_t Timer4::getPeriod( void )
{
	// Reset all needed values
	first = true;
     3e4:	81 e0       	ldi	r24, 0x01	; 1
     3e6:	80 93 0a 02 	sts	0x020A, r24	; 0x80020a <first>
	oldValue = 0U;
     3ea:	10 92 d3 02 	sts	0x02D3, r1	; 0x8002d3 <oldValue+0x1>
     3ee:	10 92 d2 02 	sts	0x02D2, r1	; 0x8002d2 <oldValue>
	period = 0U;
     3f2:	10 92 cd 02 	sts	0x02CD, r1	; 0x8002cd <__data_end+0x1>
     3f6:	10 92 cc 02 	sts	0x02CC, r1	; 0x8002cc <__data_end>
	timeroverflow = 0;
     3fa:	10 92 ce 02 	sts	0x02CE, r1	; 0x8002ce <timeroverflow>
     3fe:	10 92 cf 02 	sts	0x02CF, r1	; 0x8002cf <timeroverflow+0x1>
     402:	10 92 d0 02 	sts	0x02D0, r1	; 0x8002d0 <timeroverflow+0x2>
     406:	10 92 d1 02 	sts	0x02D1, r1	; 0x8002d1 <timeroverflow+0x3>
	
	// Enable interrupt and clear pending
	TIFR4 = ( 1 << ICF4 ) | ( 1 << TOV4 );
     40a:	81 e2       	ldi	r24, 0x21	; 33
     40c:	89 bb       	out	0x19, r24	; 25
	TIMSK4 = ( 1 << ICIE4 ) | ( 1 << TOIE4 );	
     40e:	80 93 72 00 	sts	0x0072, r24	; 0x800072 <__TEXT_REGION_LENGTH__+0x700072>
	
	// Wait until measurement has been taken
	while ( period == 0U )
     412:	80 91 cc 02 	lds	r24, 0x02CC	; 0x8002cc <__data_end>
     416:	90 91 cd 02 	lds	r25, 0x02CD	; 0x8002cd <__data_end+0x1>
     41a:	89 2b       	or	r24, r25
     41c:	81 f4       	brne	.+32     	; 0x43e <__LOCK_REGION_LENGTH__+0x3e>
	{
		if ( timeroverflow > 10U )
     41e:	80 91 ce 02 	lds	r24, 0x02CE	; 0x8002ce <timeroverflow>
     422:	90 91 cf 02 	lds	r25, 0x02CF	; 0x8002cf <timeroverflow+0x1>
     426:	a0 91 d0 02 	lds	r26, 0x02D0	; 0x8002d0 <timeroverflow+0x2>
     42a:	b0 91 d1 02 	lds	r27, 0x02D1	; 0x8002d1 <timeroverflow+0x3>
     42e:	0b 97       	sbiw	r24, 0x0b	; 11
     430:	a1 05       	cpc	r26, r1
     432:	b1 05       	cpc	r27, r1
     434:	70 f3       	brcs	.-36     	; 0x412 <__LOCK_REGION_LENGTH__+0x12>
		{
			// Error - Disable interrupt and clear pending
			TIMSK4 = 0U;
     436:	10 92 72 00 	sts	0x0072, r1	; 0x800072 <__TEXT_REGION_LENGTH__+0x700072>
			TIFR4 = ( 1 << ICF4 ) | ( 1 << TOV4 );
     43a:	81 e2       	ldi	r24, 0x21	; 33
     43c:	89 bb       	out	0x19, r24	; 25
			break;
		}
	}
	
	return period;
     43e:	80 91 cc 02 	lds	r24, 0x02CC	; 0x8002cc <__data_end>
     442:	90 91 cd 02 	lds	r25, 0x02CD	; 0x8002cd <__data_end+0x1>
}
     446:	08 95       	ret

00000448 <__vector_45>:

ISR(TIMER4_OVF_vect)
{
     448:	1f 92       	push	r1
     44a:	0f 92       	push	r0
     44c:	0f b6       	in	r0, 0x3f	; 63
     44e:	0f 92       	push	r0
     450:	11 24       	eor	r1, r1
     452:	8f 93       	push	r24
     454:	9f 93       	push	r25
     456:	af 93       	push	r26
     458:	bf 93       	push	r27
	timeroverflow++;
     45a:	80 91 ce 02 	lds	r24, 0x02CE	; 0x8002ce <timeroverflow>
     45e:	90 91 cf 02 	lds	r25, 0x02CF	; 0x8002cf <timeroverflow+0x1>
     462:	a0 91 d0 02 	lds	r26, 0x02D0	; 0x8002d0 <timeroverflow+0x2>
     466:	b0 91 d1 02 	lds	r27, 0x02D1	; 0x8002d1 <timeroverflow+0x3>
     46a:	01 96       	adiw	r24, 0x01	; 1
     46c:	a1 1d       	adc	r26, r1
     46e:	b1 1d       	adc	r27, r1
     470:	80 93 ce 02 	sts	0x02CE, r24	; 0x8002ce <timeroverflow>
     474:	90 93 cf 02 	sts	0x02CF, r25	; 0x8002cf <timeroverflow+0x1>
     478:	a0 93 d0 02 	sts	0x02D0, r26	; 0x8002d0 <timeroverflow+0x2>
     47c:	b0 93 d1 02 	sts	0x02D1, r27	; 0x8002d1 <timeroverflow+0x3>
}
     480:	bf 91       	pop	r27
     482:	af 91       	pop	r26
     484:	9f 91       	pop	r25
     486:	8f 91       	pop	r24
     488:	0f 90       	pop	r0
     48a:	0f be       	out	0x3f, r0	; 63
     48c:	0f 90       	pop	r0
     48e:	1f 90       	pop	r1
     490:	18 95       	reti

00000492 <__vector_41>:

ISR(TIMER4_CAPT_vect)
{
     492:	1f 92       	push	r1
     494:	0f 92       	push	r0
     496:	0f b6       	in	r0, 0x3f	; 63
     498:	0f 92       	push	r0
     49a:	11 24       	eor	r1, r1
     49c:	0b b6       	in	r0, 0x3b	; 59
     49e:	0f 92       	push	r0
     4a0:	cf 92       	push	r12
     4a2:	df 92       	push	r13
     4a4:	ef 92       	push	r14
     4a6:	ff 92       	push	r15
     4a8:	0f 93       	push	r16
     4aa:	1f 93       	push	r17
     4ac:	2f 93       	push	r18
     4ae:	3f 93       	push	r19
     4b0:	4f 93       	push	r20
     4b2:	5f 93       	push	r21
     4b4:	6f 93       	push	r22
     4b6:	7f 93       	push	r23
     4b8:	8f 93       	push	r24
     4ba:	9f 93       	push	r25
     4bc:	af 93       	push	r26
     4be:	bf 93       	push	r27
     4c0:	ef 93       	push	r30
     4c2:	ff 93       	push	r31
	// Read value of timer
	uint16_t readValue = ICR4;
     4c4:	60 91 a6 00 	lds	r22, 0x00A6	; 0x8000a6 <__TEXT_REGION_LENGTH__+0x7000a6>
     4c8:	70 91 a7 00 	lds	r23, 0x00A7	; 0x8000a7 <__TEXT_REGION_LENGTH__+0x7000a7>

	if ( first == true )
     4cc:	80 91 0a 02 	lds	r24, 0x020A	; 0x80020a <first>
     4d0:	88 23       	and	r24, r24
     4d2:	79 f0       	breq	.+30     	; 0x4f2 <__vector_41+0x60>
	{
		timeroverflow = 0U;
     4d4:	10 92 ce 02 	sts	0x02CE, r1	; 0x8002ce <timeroverflow>
     4d8:	10 92 cf 02 	sts	0x02CF, r1	; 0x8002cf <timeroverflow+0x1>
     4dc:	10 92 d0 02 	sts	0x02D0, r1	; 0x8002d0 <timeroverflow+0x2>
     4e0:	10 92 d1 02 	sts	0x02D1, r1	; 0x8002d1 <timeroverflow+0x3>
		oldValue = readValue;
     4e4:	70 93 d3 02 	sts	0x02D3, r23	; 0x8002d3 <oldValue+0x1>
     4e8:	60 93 d2 02 	sts	0x02D2, r22	; 0x8002d2 <oldValue>
		first = false;
     4ec:	10 92 0a 02 	sts	0x020A, r1	; 0x80020a <first>
		return;
     4f0:	81 c0       	rjmp	.+258    	; 0x5f4 <__vector_41+0x162>
	}
	
	// Check if overflow is pending
	if ( TIFR4 & ( 1 << TOV4 ))
     4f2:	c8 9b       	sbis	0x19, 0	; 25
     4f4:	13 c0       	rjmp	.+38     	; 0x51c <__vector_41+0x8a>
	{
		timeroverflow++;
     4f6:	80 91 ce 02 	lds	r24, 0x02CE	; 0x8002ce <timeroverflow>
     4fa:	90 91 cf 02 	lds	r25, 0x02CF	; 0x8002cf <timeroverflow+0x1>
     4fe:	a0 91 d0 02 	lds	r26, 0x02D0	; 0x8002d0 <timeroverflow+0x2>
     502:	b0 91 d1 02 	lds	r27, 0x02D1	; 0x8002d1 <timeroverflow+0x3>
     506:	01 96       	adiw	r24, 0x01	; 1
     508:	a1 1d       	adc	r26, r1
     50a:	b1 1d       	adc	r27, r1
     50c:	80 93 ce 02 	sts	0x02CE, r24	; 0x8002ce <timeroverflow>
     510:	90 93 cf 02 	sts	0x02CF, r25	; 0x8002cf <timeroverflow+0x1>
     514:	a0 93 d0 02 	sts	0x02D0, r26	; 0x8002d0 <timeroverflow+0x2>
     518:	b0 93 d1 02 	sts	0x02D1, r27	; 0x8002d1 <timeroverflow+0x3>
	}
		
	// Disable interrupt and clear pending
	TIMSK4 = 0U;	
     51c:	10 92 72 00 	sts	0x0072, r1	; 0x800072 <__TEXT_REGION_LENGTH__+0x700072>
	TIFR4 = ( 1 << ICF4 ) | ( 1 << TOV4 );		
     520:	81 e2       	ldi	r24, 0x21	; 33
     522:	89 bb       	out	0x19, r24	; 25
			
	// Calculate difference
	uint32_t diff = 0U;

	if ( readValue < oldValue )
     524:	80 91 d2 02 	lds	r24, 0x02D2	; 0x8002d2 <oldValue>
     528:	90 91 d3 02 	lds	r25, 0x02D3	; 0x8002d3 <oldValue+0x1>
     52c:	68 17       	cp	r22, r24
     52e:	79 07       	cpc	r23, r25
     530:	58 f5       	brcc	.+86     	; 0x588 <__vector_41+0xf6>
	{
		if ( timeroverflow != 0 )
     532:	80 91 ce 02 	lds	r24, 0x02CE	; 0x8002ce <timeroverflow>
     536:	90 91 cf 02 	lds	r25, 0x02CF	; 0x8002cf <timeroverflow+0x1>
     53a:	a0 91 d0 02 	lds	r26, 0x02D0	; 0x8002d0 <timeroverflow+0x2>
     53e:	b0 91 d1 02 	lds	r27, 0x02D1	; 0x8002d1 <timeroverflow+0x3>
     542:	89 2b       	or	r24, r25
     544:	8a 2b       	or	r24, r26
     546:	8b 2b       	or	r24, r27
     548:	99 f0       	breq	.+38     	; 0x570 <__vector_41+0xde>
		{
			timeroverflow--;
     54a:	80 91 ce 02 	lds	r24, 0x02CE	; 0x8002ce <timeroverflow>
     54e:	90 91 cf 02 	lds	r25, 0x02CF	; 0x8002cf <timeroverflow+0x1>
     552:	a0 91 d0 02 	lds	r26, 0x02D0	; 0x8002d0 <timeroverflow+0x2>
     556:	b0 91 d1 02 	lds	r27, 0x02D1	; 0x8002d1 <timeroverflow+0x3>
     55a:	01 97       	sbiw	r24, 0x01	; 1
     55c:	a1 09       	sbc	r26, r1
     55e:	b1 09       	sbc	r27, r1
     560:	80 93 ce 02 	sts	0x02CE, r24	; 0x8002ce <timeroverflow>
     564:	90 93 cf 02 	sts	0x02CF, r25	; 0x8002cf <timeroverflow+0x1>
     568:	a0 93 d0 02 	sts	0x02D0, r26	; 0x8002d0 <timeroverflow+0x2>
     56c:	b0 93 d1 02 	sts	0x02D1, r27	; 0x8002d1 <timeroverflow+0x3>
		}
		diff = ( 0xFFFF - oldValue ) + readValue;
     570:	80 91 d2 02 	lds	r24, 0x02D2	; 0x8002d2 <oldValue>
     574:	90 91 d3 02 	lds	r25, 0x02D3	; 0x8002d3 <oldValue+0x1>
     578:	68 1b       	sub	r22, r24
     57a:	79 0b       	sbc	r23, r25
     57c:	61 50       	subi	r22, 0x01	; 1
     57e:	71 09       	sbc	r23, r1
     580:	cb 01       	movw	r24, r22
     582:	a0 e0       	ldi	r26, 0x00	; 0
     584:	b0 e0       	ldi	r27, 0x00	; 0
     586:	09 c0       	rjmp	.+18     	; 0x59a <__vector_41+0x108>
	}
	else
	{
		diff = readValue - oldValue;
     588:	80 91 d2 02 	lds	r24, 0x02D2	; 0x8002d2 <oldValue>
     58c:	90 91 d3 02 	lds	r25, 0x02D3	; 0x8002d3 <oldValue+0x1>
     590:	68 1b       	sub	r22, r24
     592:	79 0b       	sbc	r23, r25
     594:	cb 01       	movw	r24, r22
     596:	a0 e0       	ldi	r26, 0x00	; 0
     598:	b0 e0       	ldi	r27, 0x00	; 0
	}
	
	// Add timeroverflow to total diff
	diff += timeroverflow << 16U;
     59a:	40 91 ce 02 	lds	r20, 0x02CE	; 0x8002ce <timeroverflow>
     59e:	50 91 cf 02 	lds	r21, 0x02CF	; 0x8002cf <timeroverflow+0x1>
     5a2:	60 91 d0 02 	lds	r22, 0x02D0	; 0x8002d0 <timeroverflow+0x2>
     5a6:	70 91 d1 02 	lds	r23, 0x02D1	; 0x8002d1 <timeroverflow+0x3>
     5aa:	ba 01       	movw	r22, r20
     5ac:	55 27       	eor	r21, r21
     5ae:	44 27       	eor	r20, r20
     5b0:	8a 01       	movw	r16, r20
     5b2:	9b 01       	movw	r18, r22
     5b4:	08 0f       	add	r16, r24
     5b6:	19 1f       	adc	r17, r25
     5b8:	2a 1f       	adc	r18, r26
     5ba:	3b 1f       	adc	r19, r27
     5bc:	c9 01       	movw	r24, r18
     5be:	b8 01       	movw	r22, r16
	
	// Calculate period
	period = diff * tick * 1000000;
     5c0:	c0 90 06 02 	lds	r12, 0x0206	; 0x800206 <tick>
     5c4:	d0 90 07 02 	lds	r13, 0x0207	; 0x800207 <tick+0x1>
     5c8:	e0 90 08 02 	lds	r14, 0x0208	; 0x800208 <tick+0x2>
     5cc:	f0 90 09 02 	lds	r15, 0x0209	; 0x800209 <tick+0x3>
     5d0:	0e 94 70 10 	call	0x20e0	; 0x20e0 <__floatunsisf>
     5d4:	a7 01       	movw	r20, r14
     5d6:	96 01       	movw	r18, r12
     5d8:	0e 94 26 11 	call	0x224c	; 0x224c <__mulsf3>
     5dc:	20 e0       	ldi	r18, 0x00	; 0
     5de:	34 e2       	ldi	r19, 0x24	; 36
     5e0:	44 e7       	ldi	r20, 0x74	; 116
     5e2:	59 e4       	ldi	r21, 0x49	; 73
     5e4:	0e 94 26 11 	call	0x224c	; 0x224c <__mulsf3>
     5e8:	0e 94 44 10 	call	0x2088	; 0x2088 <__fixunssfsi>
     5ec:	70 93 cd 02 	sts	0x02CD, r23	; 0x8002cd <__data_end+0x1>
     5f0:	60 93 cc 02 	sts	0x02CC, r22	; 0x8002cc <__data_end>
     5f4:	ff 91       	pop	r31
     5f6:	ef 91       	pop	r30
     5f8:	bf 91       	pop	r27
     5fa:	af 91       	pop	r26
     5fc:	9f 91       	pop	r25
     5fe:	8f 91       	pop	r24
     600:	7f 91       	pop	r23
     602:	6f 91       	pop	r22
     604:	5f 91       	pop	r21
     606:	4f 91       	pop	r20
     608:	3f 91       	pop	r19
     60a:	2f 91       	pop	r18
     60c:	1f 91       	pop	r17
     60e:	0f 91       	pop	r16
     610:	ff 90       	pop	r15
     612:	ef 90       	pop	r14
     614:	df 90       	pop	r13
     616:	cf 90       	pop	r12
     618:	0f 90       	pop	r0
     61a:	0b be       	out	0x3b, r0	; 59
     61c:	0f 90       	pop	r0
     61e:	0f be       	out	0x3f, r0	; 63
     620:	0f 90       	pop	r0
     622:	1f 90       	pop	r1
     624:	18 95       	reti

00000626 <_Z9FirstTaskPv>:
void * operator new(size_t size);
void operator delete(void * ptr);

int __cxa_guard_acquire(__guard *g) {return !*(char *)(g);};
void __cxa_guard_release (__guard *g) {*(char *)g = 1;};
void __cxa_guard_abort (__guard *) {};
     626:	cf 93       	push	r28
     628:	df 93       	push	r29
     62a:	cd b7       	in	r28, 0x3d	; 61
     62c:	de b7       	in	r29, 0x3e	; 62
     62e:	cb 55       	subi	r28, 0x5B	; 91
     630:	d1 09       	sbc	r29, r1
     632:	0f b6       	in	r0, 0x3f	; 63
     634:	f8 94       	cli
     636:	de bf       	out	0x3e, r29	; 62
     638:	0f be       	out	0x3f, r0	; 63
     63a:	cd bf       	out	0x3d, r28	; 61
     63c:	8c 01       	movw	r16, r24
     63e:	2e e4       	ldi	r18, 0x4E	; 78
     640:	48 e0       	ldi	r20, 0x08	; 8
     642:	60 e8       	ldi	r22, 0x80	; 128
     644:	75 e2       	ldi	r23, 0x25	; 37
     646:	80 e0       	ldi	r24, 0x00	; 0
     648:	90 e0       	ldi	r25, 0x00	; 0
     64a:	0e 94 74 0f 	call	0x1ee8	; 0x1ee8 <_Z8InitUARTmhc>
     64e:	8d e0       	ldi	r24, 0x0D	; 13
     650:	92 e0       	ldi	r25, 0x02	; 2
     652:	0e 94 cf 0f 	call	0x1f9e	; 0x1f9e <_Z10SendStringPc>
     656:	62 e0       	ldi	r22, 0x02	; 2
     658:	ce 01       	movw	r24, r28
     65a:	01 96       	adiw	r24, 0x01	; 1
     65c:	7c de       	rcall	.-776    	; 0x356 <_ZN11ColorSensorC1E16FrequencyScaling>
     65e:	80 e3       	ldi	r24, 0x30	; 48
     660:	8f 36       	cpi	r24, 0x6F	; 111
     662:	19 f0       	breq	.+6      	; 0x66a <_Z9FirstTaskPv+0x44>
     664:	0e 94 c1 0f 	call	0x1f82	; 0x1f82 <_Z8ReadCharv>
     668:	fb cf       	rjmp	.-10     	; 0x660 <_Z9FirstTaskPv+0x3a>
     66a:	8b e2       	ldi	r24, 0x2B	; 43
     66c:	92 e0       	ldi	r25, 0x02	; 2
     66e:	0e 94 cf 0f 	call	0x1f9e	; 0x1f9e <_Z10SendStringPc>
     672:	60 e0       	ldi	r22, 0x00	; 0
     674:	ce 01       	movw	r24, r28
     676:	01 96       	adiw	r24, 0x01	; 1
     678:	13 de       	rcall	.-986    	; 0x2a0 <_ZN11ColorSensor17addCalibrateColorEh>
     67a:	80 e3       	ldi	r24, 0x30	; 48
     67c:	8f 36       	cpi	r24, 0x6F	; 111
     67e:	19 f0       	breq	.+6      	; 0x686 <_Z9FirstTaskPv+0x60>
     680:	0e 94 c1 0f 	call	0x1f82	; 0x1f82 <_Z8ReadCharv>
     684:	fb cf       	rjmp	.-10     	; 0x67c <_Z9FirstTaskPv+0x56>
     686:	8a e3       	ldi	r24, 0x3A	; 58
     688:	92 e0       	ldi	r25, 0x02	; 2
     68a:	0e 94 cf 0f 	call	0x1f9e	; 0x1f9e <_Z10SendStringPc>
     68e:	61 e0       	ldi	r22, 0x01	; 1
     690:	ce 01       	movw	r24, r28
     692:	01 96       	adiw	r24, 0x01	; 1
     694:	05 de       	rcall	.-1014   	; 0x2a0 <_ZN11ColorSensor17addCalibrateColorEh>
     696:	80 e3       	ldi	r24, 0x30	; 48
     698:	8f 36       	cpi	r24, 0x6F	; 111
     69a:	19 f0       	breq	.+6      	; 0x6a2 <_Z9FirstTaskPv+0x7c>
     69c:	0e 94 c1 0f 	call	0x1f82	; 0x1f82 <_Z8ReadCharv>
     6a0:	fb cf       	rjmp	.-10     	; 0x698 <_Z9FirstTaskPv+0x72>
     6a2:	89 e4       	ldi	r24, 0x49	; 73
     6a4:	92 e0       	ldi	r25, 0x02	; 2
     6a6:	0e 94 cf 0f 	call	0x1f9e	; 0x1f9e <_Z10SendStringPc>
     6aa:	80 e3       	ldi	r24, 0x30	; 48
     6ac:	8f 36       	cpi	r24, 0x6F	; 111
     6ae:	19 f0       	breq	.+6      	; 0x6b6 <_Z9FirstTaskPv+0x90>
     6b0:	0e 94 c1 0f 	call	0x1f82	; 0x1f82 <_Z8ReadCharv>
     6b4:	fb cf       	rjmp	.-10     	; 0x6ac <_Z9FirstTaskPv+0x86>
     6b6:	88 e5       	ldi	r24, 0x58	; 88
     6b8:	92 e0       	ldi	r25, 0x02	; 2
     6ba:	0e 94 cf 0f 	call	0x1f9e	; 0x1f9e <_Z10SendStringPc>
     6be:	ce 01       	movw	r24, r28
     6c0:	01 96       	adiw	r24, 0x01	; 1
     6c2:	71 dd       	rcall	.-1310   	; 0x1a6 <_ZN11ColorSensor8getColorEv>
     6c4:	88 23       	and	r24, r24
     6c6:	19 f0       	breq	.+6      	; 0x6ce <_Z9FirstTaskPv+0xa8>
     6c8:	81 30       	cpi	r24, 0x01	; 1
     6ca:	71 f0       	breq	.+28     	; 0x6e8 <_Z9FirstTaskPv+0xc2>
     6cc:	19 c0       	rjmp	.+50     	; 0x700 <_Z9FirstTaskPv+0xda>
     6ce:	c8 01       	movw	r24, r16
     6d0:	b9 d0       	rcall	.+370    	; 0x844 <_ZN8Robotarm9grabBlockEv>
     6d2:	88 e8       	ldi	r24, 0x88	; 136
     6d4:	93 e1       	ldi	r25, 0x13	; 19
     6d6:	0e 94 fe 0e 	call	0x1dfc	; 0x1dfc <vTaskDelay>
     6da:	c8 01       	movw	r24, r16
     6dc:	71 d1       	rcall	.+738    	; 0x9c0 <_ZN8Robotarm18moveBlockToZoneOneEv>
     6de:	88 e8       	ldi	r24, 0x88	; 136
     6e0:	93 e1       	ldi	r25, 0x13	; 19
     6e2:	0e 94 fe 0e 	call	0x1dfc	; 0x1dfc <vTaskDelay>
     6e6:	0c c0       	rjmp	.+24     	; 0x700 <_Z9FirstTaskPv+0xda>
     6e8:	c8 01       	movw	r24, r16
     6ea:	ac d0       	rcall	.+344    	; 0x844 <_ZN8Robotarm9grabBlockEv>
     6ec:	88 e8       	ldi	r24, 0x88	; 136
     6ee:	93 e1       	ldi	r25, 0x13	; 19
     6f0:	0e 94 fe 0e 	call	0x1dfc	; 0x1dfc <vTaskDelay>
     6f4:	c8 01       	movw	r24, r16
     6f6:	76 d1       	rcall	.+748    	; 0x9e4 <_ZN8Robotarm18moveBlockToZoneTwoEv>
     6f8:	88 e8       	ldi	r24, 0x88	; 136
     6fa:	93 e1       	ldi	r25, 0x13	; 19
     6fc:	0e 94 fe 0e 	call	0x1dfc	; 0x1dfc <vTaskDelay>
     700:	84 e6       	ldi	r24, 0x64	; 100
     702:	90 e0       	ldi	r25, 0x00	; 0
     704:	0e 94 fe 0e 	call	0x1dfc	; 0x1dfc <vTaskDelay>
     708:	da cf       	rjmp	.-76     	; 0x6be <_Z9FirstTaskPv+0x98>

0000070a <__cxa_pure_virtual>:
     70a:	ff cf       	rjmp	.-2      	; 0x70a <__cxa_pure_virtual>

0000070c <_Znwj>:

void * operator new(size_t size)
{
	return malloc(size);
     70c:	0c 94 ba 11 	jmp	0x2374	; 0x2374 <malloc>
}
     710:	08 95       	ret

00000712 <_ZdlPv>:

void operator delete(void * ptr)
{
	ptr != NULL ? free(ptr) : void(0);
     712:	00 97       	sbiw	r24, 0x00	; 0
     714:	11 f0       	breq	.+4      	; 0x71a <_ZdlPv+0x8>
     716:	0c 94 52 12 	jmp	0x24a4	; 0x24a4 <free>
     71a:	08 95       	ret

0000071c <main>:
		vTaskDelay(100/portTICK_RATE_MS);
	}
}

int main(void)
{
     71c:	cf 93       	push	r28
     71e:	df 93       	push	r29
     720:	cd b7       	in	r28, 0x3d	; 61
     722:	de b7       	in	r29, 0x3e	; 62
     724:	2e 97       	sbiw	r28, 0x0e	; 14
     726:	0f b6       	in	r0, 0x3f	; 63
     728:	f8 94       	cli
     72a:	de bf       	out	0x3e, r29	; 62
     72c:	0f be       	out	0x3f, r0	; 63
     72e:	cd bf       	out	0x3d, r28	; 61
	Robotarm arm = Robotarm();
     730:	ce 01       	movw	r24, r28
     732:	01 96       	adiw	r24, 0x01	; 1
     734:	2b d0       	rcall	.+86     	; 0x78c <_ZN8RobotarmC1Ev>
	xTaskCreate(FirstTask,  ( signed char * ) "Task", configMAIN_STACK_SIZE, &arm, tskIDLE_PRIORITY, NULL);
     736:	a1 2c       	mov	r10, r1
     738:	b1 2c       	mov	r11, r1
     73a:	c1 2c       	mov	r12, r1
     73c:	d1 2c       	mov	r13, r1
     73e:	e1 2c       	mov	r14, r1
     740:	f1 2c       	mov	r15, r1
     742:	00 e0       	ldi	r16, 0x00	; 0
     744:	9e 01       	movw	r18, r28
     746:	2f 5f       	subi	r18, 0xFF	; 255
     748:	3f 4f       	sbci	r19, 0xFF	; 255
     74a:	48 ec       	ldi	r20, 0xC8	; 200
     74c:	50 e0       	ldi	r21, 0x00	; 0
     74e:	67 e6       	ldi	r22, 0x67	; 103
     750:	72 e0       	ldi	r23, 0x02	; 2
     752:	83 e1       	ldi	r24, 0x13	; 19
     754:	93 e0       	ldi	r25, 0x03	; 3
     756:	0e 94 ff 0c 	call	0x19fe	; 0x19fe <xTaskGenericCreate>
	vTaskStartScheduler();
     75a:	0e 94 b7 0d 	call	0x1b6e	; 0x1b6e <vTaskStartScheduler>
     75e:	ff cf       	rjmp	.-2      	; 0x75e <main+0x42>

00000760 <_ZN8Robotarm14startMotorImplEPv>:
	motors_[3]->SetDegrees(90);
	vTaskDelay( 250 / portTICK_RATE_MS );
}

void Robotarm::startMotorImpl( void *_this )
{
     760:	8c 01       	movw	r16, r24
void Robotarm::MotorSpeedController()
{
	while(1)
	{
		/* Move all motors one step. */
		for ( uint8_t i = 0U; i < 6U; i++ )
     762:	c0 e0       	ldi	r28, 0x00	; 0
     764:	c6 30       	cpi	r28, 0x06	; 6
     766:	e8 f7       	brcc	.-6      	; 0x762 <_ZN8Robotarm14startMotorImplEPv+0x2>
		{
			motors_[i]->TurnMotor();
     768:	ec 2f       	mov	r30, r28
     76a:	f0 e0       	ldi	r31, 0x00	; 0
     76c:	31 96       	adiw	r30, 0x01	; 1
     76e:	ee 0f       	add	r30, r30
     770:	ff 1f       	adc	r31, r31
     772:	e0 0f       	add	r30, r16
     774:	f1 1f       	adc	r31, r17
     776:	80 81       	ld	r24, Z
     778:	91 81       	ldd	r25, Z+1	; 0x01
     77a:	dc 01       	movw	r26, r24
     77c:	ed 91       	ld	r30, X+
     77e:	fc 91       	ld	r31, X
     780:	04 80       	ldd	r0, Z+4	; 0x04
     782:	f5 81       	ldd	r31, Z+5	; 0x05
     784:	e0 2d       	mov	r30, r0
     786:	19 95       	eicall
void Robotarm::MotorSpeedController()
{
	while(1)
	{
		/* Move all motors one step. */
		for ( uint8_t i = 0U; i < 6U; i++ )
     788:	cf 5f       	subi	r28, 0xFF	; 255
     78a:	ec cf       	rjmp	.-40     	; 0x764 <_ZN8Robotarm14startMotorImplEPv+0x4>

0000078c <_ZN8RobotarmC1Ev>:
/* RTOS include */
#include "FreeRTOS.h"
#include "task.h"
#include "portmacro.h"

Robotarm::Robotarm() : tmr1_(), tmr3_()
     78c:	af 92       	push	r10
     78e:	bf 92       	push	r11
     790:	cf 92       	push	r12
     792:	df 92       	push	r13
     794:	ef 92       	push	r14
     796:	ff 92       	push	r15
     798:	0f 93       	push	r16
     79a:	1f 93       	push	r17
     79c:	cf 93       	push	r28
     79e:	df 93       	push	r29
     7a0:	ec 01       	movw	r28, r24
     7a2:	2c d5       	rcall	.+2648   	; 0x11fc <_ZN6Timer1C1Ev>
     7a4:	8e 01       	movw	r16, r28
     7a6:	0f 5f       	subi	r16, 0xFF	; 255
     7a8:	1f 4f       	sbci	r17, 0xFF	; 255
     7aa:	c8 01       	movw	r24, r16
     7ac:	bd d5       	rcall	.+2938   	; 0x1328 <_ZN6Timer5C1Ev>
{
	/* Create all motor objects */
	motors_[0] = new M1( &tmr1_ );
     7ae:	89 e1       	ldi	r24, 0x19	; 25
     7b0:	90 e0       	ldi	r25, 0x00	; 0
     7b2:	ac df       	rcall	.-168    	; 0x70c <_Znwj>
     7b4:	7c 01       	movw	r14, r24
     7b6:	be 01       	movw	r22, r28
     7b8:	c2 d1       	rcall	.+900    	; 0xb3e <_ZN2M1C1EP6Timer1>
     7ba:	fb 82       	std	Y+3, r15	; 0x03
     7bc:	ea 82       	std	Y+2, r14	; 0x02
	motors_[1] = new M2( &tmr1_ );
     7be:	89 e1       	ldi	r24, 0x19	; 25
     7c0:	90 e0       	ldi	r25, 0x00	; 0
     7c2:	a4 df       	rcall	.-184    	; 0x70c <_Znwj>
     7c4:	7c 01       	movw	r14, r24
     7c6:	be 01       	movw	r22, r28
     7c8:	60 d2       	rcall	.+1216   	; 0xc8a <_ZN2M2C1EP6Timer1>
     7ca:	fd 82       	std	Y+5, r15	; 0x05
     7cc:	ec 82       	std	Y+4, r14	; 0x04
	motors_[2] = new M3( &tmr1_ );
     7ce:	89 e1       	ldi	r24, 0x19	; 25
     7d0:	90 e0       	ldi	r25, 0x00	; 0
     7d2:	9c df       	rcall	.-200    	; 0x70c <_Znwj>
     7d4:	7c 01       	movw	r14, r24
     7d6:	be 01       	movw	r22, r28
     7d8:	fe d2       	rcall	.+1532   	; 0xdd6 <_ZN2M3C1EP6Timer1>
     7da:	ff 82       	std	Y+7, r15	; 0x07
     7dc:	ee 82       	std	Y+6, r14	; 0x06
	motors_[3] = new M4( &tmr3_ );
     7de:	89 e1       	ldi	r24, 0x19	; 25
     7e0:	90 e0       	ldi	r25, 0x00	; 0
     7e2:	94 df       	rcall	.-216    	; 0x70c <_Znwj>
     7e4:	7c 01       	movw	r14, r24
     7e6:	b8 01       	movw	r22, r16
     7e8:	9a d3       	rcall	.+1844   	; 0xf1e <_ZN2M4C1EP6Timer5>
     7ea:	f9 86       	std	Y+9, r15	; 0x09
     7ec:	e8 86       	std	Y+8, r14	; 0x08
	motors_[4] = new M5( &tmr3_ );
     7ee:	89 e1       	ldi	r24, 0x19	; 25
     7f0:	90 e0       	ldi	r25, 0x00	; 0
     7f2:	8c df       	rcall	.-232    	; 0x70c <_Znwj>
     7f4:	7c 01       	movw	r14, r24
     7f6:	b8 01       	movw	r22, r16
     7f8:	34 d4       	rcall	.+2152   	; 0x1062 <_ZN2M5C1EP6Timer5>
     7fa:	fb 86       	std	Y+11, r15	; 0x0b
     7fc:	ea 86       	std	Y+10, r14	; 0x0a
	motors_[5] = new M6( &tmr3_ );
     7fe:	89 e1       	ldi	r24, 0x19	; 25
     800:	90 e0       	ldi	r25, 0x00	; 0
     802:	84 df       	rcall	.-248    	; 0x70c <_Znwj>
     804:	7c 01       	movw	r14, r24
     806:	b8 01       	movw	r22, r16
     808:	c9 d4       	rcall	.+2450   	; 0x119c <_ZN2M6C1EP6Timer5>
     80a:	fd 86       	std	Y+13, r15	; 0x0d
     80c:	ec 86       	std	Y+12, r14	; 0x0c
     80e:	a1 2c       	mov	r10, r1
     810:	b1 2c       	mov	r11, r1
	
	/* Create task to control motors */
	xTaskCreate(this->startMotorImpl,  ( signed char * ) "Motors", configMAIN_STACK_SIZE, this, tskIDLE_PRIORITY, NULL);
     812:	c1 2c       	mov	r12, r1
     814:	d1 2c       	mov	r13, r1
     816:	e1 2c       	mov	r14, r1
     818:	f1 2c       	mov	r15, r1
     81a:	00 e0       	ldi	r16, 0x00	; 0
     81c:	9e 01       	movw	r18, r28
     81e:	48 ec       	ldi	r20, 0xC8	; 200
     820:	50 e0       	ldi	r21, 0x00	; 0
     822:	6c e6       	ldi	r22, 0x6C	; 108
     824:	72 e0       	ldi	r23, 0x02	; 2
     826:	80 eb       	ldi	r24, 0xB0	; 176
     828:	93 e0       	ldi	r25, 0x03	; 3
     82a:	0e 94 ff 0c 	call	0x19fe	; 0x19fe <xTaskGenericCreate>
     82e:	df 91       	pop	r29
     830:	cf 91       	pop	r28
}
     832:	1f 91       	pop	r17
     834:	0f 91       	pop	r16
     836:	ff 90       	pop	r15
     838:	ef 90       	pop	r14
     83a:	df 90       	pop	r13
     83c:	cf 90       	pop	r12
     83e:	bf 90       	pop	r11
     840:	af 90       	pop	r10
     842:	08 95       	ret

00000844 <_ZN8Robotarm9grabBlockEv>:
     844:	cf 93       	push	r28
     846:	df 93       	push	r29

void Robotarm::grabBlock()
{
     848:	ec 01       	movw	r28, r24
	motors_[3]->SetDegrees(40);
     84a:	88 85       	ldd	r24, Y+8	; 0x08
     84c:	99 85       	ldd	r25, Y+9	; 0x09
     84e:	dc 01       	movw	r26, r24
     850:	ed 91       	ld	r30, X+
     852:	fc 91       	ld	r31, X
     854:	06 80       	ldd	r0, Z+6	; 0x06
     856:	f7 81       	ldd	r31, Z+7	; 0x07
     858:	e0 2d       	mov	r30, r0
     85a:	68 e2       	ldi	r22, 0x28	; 40
     85c:	19 95       	eicall
	motors_[4]->SetDegrees(90);
     85e:	8a 85       	ldd	r24, Y+10	; 0x0a
     860:	9b 85       	ldd	r25, Y+11	; 0x0b
     862:	dc 01       	movw	r26, r24
     864:	ed 91       	ld	r30, X+
     866:	fc 91       	ld	r31, X
     868:	06 80       	ldd	r0, Z+6	; 0x06
     86a:	f7 81       	ldd	r31, Z+7	; 0x07
     86c:	e0 2d       	mov	r30, r0
     86e:	6a e5       	ldi	r22, 0x5A	; 90
     870:	19 95       	eicall
	motors_[0]->SetDegrees(0);
     872:	8a 81       	ldd	r24, Y+2	; 0x02
     874:	9b 81       	ldd	r25, Y+3	; 0x03
     876:	dc 01       	movw	r26, r24
     878:	ed 91       	ld	r30, X+
     87a:	fc 91       	ld	r31, X
     87c:	06 80       	ldd	r0, Z+6	; 0x06
     87e:	f7 81       	ldd	r31, Z+7	; 0x07
     880:	e0 2d       	mov	r30, r0
     882:	60 e0       	ldi	r22, 0x00	; 0
     884:	19 95       	eicall
	vTaskDelay( 1500 / portTICK_RATE_MS );
     886:	8c ed       	ldi	r24, 0xDC	; 220
     888:	95 e0       	ldi	r25, 0x05	; 5
     88a:	0e 94 fe 0e 	call	0x1dfc	; 0x1dfc <vTaskDelay>
	motors_[1]->SetDegrees(35);
     88e:	8c 81       	ldd	r24, Y+4	; 0x04
     890:	9d 81       	ldd	r25, Y+5	; 0x05
     892:	dc 01       	movw	r26, r24
     894:	ed 91       	ld	r30, X+
     896:	fc 91       	ld	r31, X
     898:	06 80       	ldd	r0, Z+6	; 0x06
     89a:	f7 81       	ldd	r31, Z+7	; 0x07
     89c:	e0 2d       	mov	r30, r0
     89e:	63 e2       	ldi	r22, 0x23	; 35
     8a0:	19 95       	eicall
	motors_[2]->SetDegrees(63);
     8a2:	8e 81       	ldd	r24, Y+6	; 0x06
     8a4:	9f 81       	ldd	r25, Y+7	; 0x07
     8a6:	dc 01       	movw	r26, r24
     8a8:	ed 91       	ld	r30, X+
     8aa:	fc 91       	ld	r31, X
     8ac:	06 80       	ldd	r0, Z+6	; 0x06
     8ae:	f7 81       	ldd	r31, Z+7	; 0x07
     8b0:	e0 2d       	mov	r30, r0
     8b2:	6f e3       	ldi	r22, 0x3F	; 63
     8b4:	19 95       	eicall
	vTaskDelay( 1500 / portTICK_RATE_MS );
     8b6:	8c ed       	ldi	r24, 0xDC	; 220
     8b8:	95 e0       	ldi	r25, 0x05	; 5
     8ba:	0e 94 fe 0e 	call	0x1dfc	; 0x1dfc <vTaskDelay>
	motors_[5]->SetDegrees(63);
     8be:	8c 85       	ldd	r24, Y+12	; 0x0c
     8c0:	9d 85       	ldd	r25, Y+13	; 0x0d
     8c2:	dc 01       	movw	r26, r24
     8c4:	ed 91       	ld	r30, X+
     8c6:	fc 91       	ld	r31, X
     8c8:	06 80       	ldd	r0, Z+6	; 0x06
     8ca:	f7 81       	ldd	r31, Z+7	; 0x07
     8cc:	e0 2d       	mov	r30, r0
     8ce:	6f e3       	ldi	r22, 0x3F	; 63
     8d0:	19 95       	eicall
	vTaskDelay( 250 / portTICK_RATE_MS );
     8d2:	8a ef       	ldi	r24, 0xFA	; 250
     8d4:	90 e0       	ldi	r25, 0x00	; 0
     8d6:	0e 94 fe 0e 	call	0x1dfc	; 0x1dfc <vTaskDelay>
	motors_[1]->SetDegrees(70);
     8da:	8c 81       	ldd	r24, Y+4	; 0x04
     8dc:	9d 81       	ldd	r25, Y+5	; 0x05
     8de:	dc 01       	movw	r26, r24
     8e0:	ed 91       	ld	r30, X+
     8e2:	fc 91       	ld	r31, X
     8e4:	06 80       	ldd	r0, Z+6	; 0x06
     8e6:	f7 81       	ldd	r31, Z+7	; 0x07
     8e8:	e0 2d       	mov	r30, r0
     8ea:	66 e4       	ldi	r22, 0x46	; 70
     8ec:	19 95       	eicall
	motors_[2]->SetDegrees(70);
     8ee:	8e 81       	ldd	r24, Y+6	; 0x06
     8f0:	9f 81       	ldd	r25, Y+7	; 0x07
     8f2:	dc 01       	movw	r26, r24
     8f4:	ed 91       	ld	r30, X+
     8f6:	fc 91       	ld	r31, X
     8f8:	06 80       	ldd	r0, Z+6	; 0x06
     8fa:	f7 81       	ldd	r31, Z+7	; 0x07
     8fc:	e0 2d       	mov	r30, r0
     8fe:	66 e4       	ldi	r22, 0x46	; 70
     900:	19 95       	eicall
	motors_[3]->SetDegrees(70);
     902:	88 85       	ldd	r24, Y+8	; 0x08
     904:	99 85       	ldd	r25, Y+9	; 0x09
     906:	dc 01       	movw	r26, r24
     908:	ed 91       	ld	r30, X+
     90a:	fc 91       	ld	r31, X
     90c:	06 80       	ldd	r0, Z+6	; 0x06
     90e:	f7 81       	ldd	r31, Z+7	; 0x07
     910:	e0 2d       	mov	r30, r0
     912:	66 e4       	ldi	r22, 0x46	; 70
     914:	19 95       	eicall
}
     916:	df 91       	pop	r29
     918:	cf 91       	pop	r28
     91a:	08 95       	ret

0000091c <_ZN8Robotarm18ArmDownReleaseItemEv>:
	motors_[0]->SetDegrees(180);
	ArmDownReleaseItem();
}

void Robotarm::ArmDownReleaseItem()
{
     91c:	cf 93       	push	r28
     91e:	df 93       	push	r29
     920:	ec 01       	movw	r28, r24
	vTaskDelay( 1500 / portTICK_RATE_MS );
     922:	8c ed       	ldi	r24, 0xDC	; 220
     924:	95 e0       	ldi	r25, 0x05	; 5
     926:	0e 94 fe 0e 	call	0x1dfc	; 0x1dfc <vTaskDelay>
	motors_[1]->SetDegrees(35);
     92a:	8c 81       	ldd	r24, Y+4	; 0x04
     92c:	9d 81       	ldd	r25, Y+5	; 0x05
     92e:	dc 01       	movw	r26, r24
     930:	ed 91       	ld	r30, X+
     932:	fc 91       	ld	r31, X
     934:	06 80       	ldd	r0, Z+6	; 0x06
     936:	f7 81       	ldd	r31, Z+7	; 0x07
     938:	e0 2d       	mov	r30, r0
     93a:	63 e2       	ldi	r22, 0x23	; 35
     93c:	19 95       	eicall
	motors_[2]->SetDegrees(40);
     93e:	8e 81       	ldd	r24, Y+6	; 0x06
     940:	9f 81       	ldd	r25, Y+7	; 0x07
     942:	dc 01       	movw	r26, r24
     944:	ed 91       	ld	r30, X+
     946:	fc 91       	ld	r31, X
     948:	06 80       	ldd	r0, Z+6	; 0x06
     94a:	f7 81       	ldd	r31, Z+7	; 0x07
     94c:	e0 2d       	mov	r30, r0
     94e:	68 e2       	ldi	r22, 0x28	; 40
     950:	19 95       	eicall
	vTaskDelay( 1500 / portTICK_RATE_MS );
     952:	8c ed       	ldi	r24, 0xDC	; 220
     954:	95 e0       	ldi	r25, 0x05	; 5
     956:	0e 94 fe 0e 	call	0x1dfc	; 0x1dfc <vTaskDelay>
	motors_[5]->SetDegrees(0);
     95a:	8c 85       	ldd	r24, Y+12	; 0x0c
     95c:	9d 85       	ldd	r25, Y+13	; 0x0d
     95e:	dc 01       	movw	r26, r24
     960:	ed 91       	ld	r30, X+
     962:	fc 91       	ld	r31, X
     964:	06 80       	ldd	r0, Z+6	; 0x06
     966:	f7 81       	ldd	r31, Z+7	; 0x07
     968:	e0 2d       	mov	r30, r0
     96a:	60 e0       	ldi	r22, 0x00	; 0
     96c:	19 95       	eicall
	vTaskDelay( 250 / portTICK_RATE_MS );
     96e:	8a ef       	ldi	r24, 0xFA	; 250
     970:	90 e0       	ldi	r25, 0x00	; 0
     972:	0e 94 fe 0e 	call	0x1dfc	; 0x1dfc <vTaskDelay>
	motors_[1]->SetDegrees(90);
     976:	8c 81       	ldd	r24, Y+4	; 0x04
     978:	9d 81       	ldd	r25, Y+5	; 0x05
     97a:	dc 01       	movw	r26, r24
     97c:	ed 91       	ld	r30, X+
     97e:	fc 91       	ld	r31, X
     980:	06 80       	ldd	r0, Z+6	; 0x06
     982:	f7 81       	ldd	r31, Z+7	; 0x07
     984:	e0 2d       	mov	r30, r0
     986:	6a e5       	ldi	r22, 0x5A	; 90
     988:	19 95       	eicall
	motors_[2]->SetDegrees(90);
     98a:	8e 81       	ldd	r24, Y+6	; 0x06
     98c:	9f 81       	ldd	r25, Y+7	; 0x07
     98e:	dc 01       	movw	r26, r24
     990:	ed 91       	ld	r30, X+
     992:	fc 91       	ld	r31, X
     994:	06 80       	ldd	r0, Z+6	; 0x06
     996:	f7 81       	ldd	r31, Z+7	; 0x07
     998:	e0 2d       	mov	r30, r0
     99a:	6a e5       	ldi	r22, 0x5A	; 90
     99c:	19 95       	eicall
	motors_[3]->SetDegrees(90);
     99e:	88 85       	ldd	r24, Y+8	; 0x08
     9a0:	99 85       	ldd	r25, Y+9	; 0x09
     9a2:	dc 01       	movw	r26, r24
     9a4:	ed 91       	ld	r30, X+
     9a6:	fc 91       	ld	r31, X
     9a8:	06 80       	ldd	r0, Z+6	; 0x06
     9aa:	f7 81       	ldd	r31, Z+7	; 0x07
     9ac:	e0 2d       	mov	r30, r0
     9ae:	6a e5       	ldi	r22, 0x5A	; 90
     9b0:	19 95       	eicall
	vTaskDelay( 250 / portTICK_RATE_MS );
     9b2:	8a ef       	ldi	r24, 0xFA	; 250
     9b4:	90 e0       	ldi	r25, 0x00	; 0
     9b6:	0e 94 fe 0e 	call	0x1dfc	; 0x1dfc <vTaskDelay>
}
     9ba:	df 91       	pop	r29
     9bc:	cf 91       	pop	r28
     9be:	08 95       	ret

000009c0 <_ZN8Robotarm18moveBlockToZoneOneEv>:
	motors_[2]->SetDegrees(70);
	motors_[3]->SetDegrees(70);
}

void Robotarm::moveBlockToZoneOne()
{
     9c0:	cf 93       	push	r28
     9c2:	df 93       	push	r29
     9c4:	ec 01       	movw	r28, r24
	motors_[0]->SetDegrees(90);
     9c6:	8a 81       	ldd	r24, Y+2	; 0x02
     9c8:	9b 81       	ldd	r25, Y+3	; 0x03
     9ca:	dc 01       	movw	r26, r24
     9cc:	ed 91       	ld	r30, X+
     9ce:	fc 91       	ld	r31, X
     9d0:	06 80       	ldd	r0, Z+6	; 0x06
     9d2:	f7 81       	ldd	r31, Z+7	; 0x07
     9d4:	e0 2d       	mov	r30, r0
     9d6:	6a e5       	ldi	r22, 0x5A	; 90
     9d8:	19 95       	eicall
	ArmDownReleaseItem();
     9da:	ce 01       	movw	r24, r28
     9dc:	9f df       	rcall	.-194    	; 0x91c <_ZN8Robotarm18ArmDownReleaseItemEv>
}
     9de:	df 91       	pop	r29
     9e0:	cf 91       	pop	r28
     9e2:	08 95       	ret

000009e4 <_ZN8Robotarm18moveBlockToZoneTwoEv>:

void Robotarm::moveBlockToZoneTwo()
{
     9e4:	cf 93       	push	r28
     9e6:	df 93       	push	r29
     9e8:	ec 01       	movw	r28, r24
	motors_[0]->SetDegrees(135);
     9ea:	8a 81       	ldd	r24, Y+2	; 0x02
     9ec:	9b 81       	ldd	r25, Y+3	; 0x03
     9ee:	dc 01       	movw	r26, r24
     9f0:	ed 91       	ld	r30, X+
     9f2:	fc 91       	ld	r31, X
     9f4:	06 80       	ldd	r0, Z+6	; 0x06
     9f6:	f7 81       	ldd	r31, Z+7	; 0x07
     9f8:	e0 2d       	mov	r30, r0
     9fa:	67 e8       	ldi	r22, 0x87	; 135
     9fc:	19 95       	eicall
	ArmDownReleaseItem();
     9fe:	ce 01       	movw	r24, r28
     a00:	8d df       	rcall	.-230    	; 0x91c <_ZN8Robotarm18ArmDownReleaseItemEv>
}
     a02:	df 91       	pop	r29
     a04:	cf 91       	pop	r28
     a06:	08 95       	ret

00000a08 <_ZN5Motor10SetDegreesEh>:
	*	 can be used to turn motor at a specific speed set by \ref delay. C
	*	 Note that this function needs to run multiple times to work as intended.
	*    @param uint8_t	degrees to turn
	*    @return void Nothing
	*/
	virtual void SetDegrees( uint8_t degrees )
     a08:	cf 92       	push	r12
     a0a:	df 92       	push	r13
     a0c:	ef 92       	push	r14
     a0e:	ff 92       	push	r15
     a10:	cf 93       	push	r28
     a12:	df 93       	push	r29
	{
		if ( maxDegrees_ >= degrees )
     a14:	fc 01       	movw	r30, r24
     a16:	26 89       	ldd	r18, Z+22	; 0x16
     a18:	26 17       	cp	r18, r22
     a1a:	c0 f0       	brcs	.+48     	; 0xa4c <_ZN5Motor10SetDegreesEh+0x44>
     a1c:	ec 01       	movw	r28, r24
		{
			percent_ = percentPrDeg * degrees + startpercent_;
     a1e:	c6 80       	ldd	r12, Z+6	; 0x06
     a20:	d7 80       	ldd	r13, Z+7	; 0x07
     a22:	e0 84       	ldd	r14, Z+8	; 0x08
     a24:	f1 84       	ldd	r15, Z+9	; 0x09
     a26:	70 e0       	ldi	r23, 0x00	; 0
     a28:	80 e0       	ldi	r24, 0x00	; 0
     a2a:	90 e0       	ldi	r25, 0x00	; 0
     a2c:	0e 94 72 10 	call	0x20e4	; 0x20e4 <__floatsisf>
     a30:	a7 01       	movw	r20, r14
     a32:	96 01       	movw	r18, r12
     a34:	0e 94 26 11 	call	0x224c	; 0x224c <__mulsf3>
     a38:	2a 89       	ldd	r18, Y+18	; 0x12
     a3a:	3b 89       	ldd	r19, Y+19	; 0x13
     a3c:	4c 89       	ldd	r20, Y+20	; 0x14
     a3e:	5d 89       	ldd	r21, Y+21	; 0x15
     a40:	0e 94 dc 0f 	call	0x1fb8	; 0x1fb8 <__addsf3>
     a44:	6a 87       	std	Y+10, r22	; 0x0a
     a46:	7b 87       	std	Y+11, r23	; 0x0b
     a48:	8c 87       	std	Y+12, r24	; 0x0c
     a4a:	9d 87       	std	Y+13, r25	; 0x0d
		}
	}
     a4c:	df 91       	pop	r29
     a4e:	cf 91       	pop	r28
     a50:	ff 90       	pop	r15
     a52:	ef 90       	pop	r14
     a54:	df 90       	pop	r13
     a56:	cf 90       	pop	r12
     a58:	08 95       	ret

00000a5a <_ZN2M1D1Ev>:

class Motor
{
//functions
public:
	virtual ~Motor() {};
     a5a:	27 e7       	ldi	r18, 0x77	; 119
     a5c:	32 e0       	ldi	r19, 0x02	; 2
     a5e:	fc 01       	movw	r30, r24
     a60:	31 83       	std	Z+1, r19	; 0x01
     a62:	20 83       	st	Z, r18
     a64:	08 95       	ret

00000a66 <_ZN2M1D0Ev>:
	SetDegrees( 90 );
	tmr1Ptr_->setDutyCycleComA( percent_ );
	oldPercent_ = percent_;
} 

M1::~M1()
     a66:	cf 93       	push	r28
     a68:	df 93       	push	r29
     a6a:	ec 01       	movw	r28, r24
{
}
     a6c:	f6 df       	rcall	.-20     	; 0xa5a <_ZN2M1D1Ev>
     a6e:	ce 01       	movw	r24, r28
     a70:	50 de       	rcall	.-864    	; 0x712 <_ZdlPv>
     a72:	df 91       	pop	r29
     a74:	cf 91       	pop	r28
     a76:	08 95       	ret

00000a78 <_ZN2M19TurnMotorEv>:

void M1::TurnMotor()
{
     a78:	4f 92       	push	r4
     a7a:	5f 92       	push	r5
     a7c:	6f 92       	push	r6
     a7e:	7f 92       	push	r7
     a80:	8f 92       	push	r8
     a82:	9f 92       	push	r9
     a84:	af 92       	push	r10
     a86:	bf 92       	push	r11
     a88:	cf 92       	push	r12
     a8a:	df 92       	push	r13
     a8c:	ef 92       	push	r14
     a8e:	ff 92       	push	r15
     a90:	cf 93       	push	r28
     a92:	df 93       	push	r29
     a94:	ec 01       	movw	r28, r24
	if ( percent_ > oldPercent_ + PERCENT_PR_TICK )
     a96:	8a 84       	ldd	r8, Y+10	; 0x0a
     a98:	9b 84       	ldd	r9, Y+11	; 0x0b
     a9a:	ac 84       	ldd	r10, Y+12	; 0x0c
     a9c:	bd 84       	ldd	r11, Y+13	; 0x0d
     a9e:	ce 84       	ldd	r12, Y+14	; 0x0e
     aa0:	df 84       	ldd	r13, Y+15	; 0x0f
     aa2:	e8 88       	ldd	r14, Y+16	; 0x10
     aa4:	f9 88       	ldd	r15, Y+17	; 0x11
     aa6:	20 e0       	ldi	r18, 0x00	; 0
     aa8:	30 e0       	ldi	r19, 0x00	; 0
     aaa:	40 e8       	ldi	r20, 0x80	; 128
     aac:	5d e3       	ldi	r21, 0x3D	; 61
     aae:	c7 01       	movw	r24, r14
     ab0:	b6 01       	movw	r22, r12
     ab2:	0e 94 dc 0f 	call	0x1fb8	; 0x1fb8 <__addsf3>
     ab6:	2b 01       	movw	r4, r22
     ab8:	3c 01       	movw	r6, r24
     aba:	9b 01       	movw	r18, r22
     abc:	ac 01       	movw	r20, r24
     abe:	c5 01       	movw	r24, r10
     ac0:	b4 01       	movw	r22, r8
     ac2:	0e 94 22 11 	call	0x2244	; 0x2244 <__gesf2>
     ac6:	18 16       	cp	r1, r24
     ac8:	74 f4       	brge	.+28     	; 0xae6 <_ZN2M19TurnMotorEv+0x6e>
	{
		oldPercent_ += PERCENT_PR_TICK;
     aca:	4e 86       	std	Y+14, r4	; 0x0e
     acc:	5f 86       	std	Y+15, r5	; 0x0f
     ace:	68 8a       	std	Y+16, r6	; 0x10
     ad0:	79 8a       	std	Y+17, r7	; 0x11
		tmr1Ptr_->setDutyCycleComA( oldPercent_ );
     ad2:	b3 01       	movw	r22, r6
     ad4:	a2 01       	movw	r20, r4
     ad6:	8a 81       	ldd	r24, Y+2	; 0x02
     ad8:	9b 81       	ldd	r25, Y+3	; 0x03
     ada:	ae d3       	rcall	.+1884   	; 0x1238 <_ZN6Timer116setDutyCycleComAEf>
		vTaskDelay( delay_ / portTICK_RATE_MS );
     adc:	8f 89       	ldd	r24, Y+23	; 0x17
     ade:	98 8d       	ldd	r25, Y+24	; 0x18
     ae0:	0e 94 fe 0e 	call	0x1dfc	; 0x1dfc <vTaskDelay>
     ae4:	1d c0       	rjmp	.+58     	; 0xb20 <_ZN2M19TurnMotorEv+0xa8>
	}
	else if ( percent_ < oldPercent_ )
     ae6:	a7 01       	movw	r20, r14
     ae8:	96 01       	movw	r18, r12
     aea:	c5 01       	movw	r24, r10
     aec:	b4 01       	movw	r22, r8
     aee:	0e 94 40 10 	call	0x2080	; 0x2080 <__cmpsf2>
     af2:	88 23       	and	r24, r24
     af4:	ac f4       	brge	.+42     	; 0xb20 <_ZN2M19TurnMotorEv+0xa8>
	{
		oldPercent_ -= PERCENT_PR_TICK;
     af6:	20 e0       	ldi	r18, 0x00	; 0
     af8:	30 e0       	ldi	r19, 0x00	; 0
     afa:	40 e8       	ldi	r20, 0x80	; 128
     afc:	5d e3       	ldi	r21, 0x3D	; 61
     afe:	c7 01       	movw	r24, r14
     b00:	b6 01       	movw	r22, r12
     b02:	0e 94 db 0f 	call	0x1fb6	; 0x1fb6 <__subsf3>
     b06:	ab 01       	movw	r20, r22
     b08:	bc 01       	movw	r22, r24
     b0a:	4e 87       	std	Y+14, r20	; 0x0e
     b0c:	5f 87       	std	Y+15, r21	; 0x0f
     b0e:	68 8b       	std	Y+16, r22	; 0x10
     b10:	79 8b       	std	Y+17, r23	; 0x11
		tmr1Ptr_->setDutyCycleComA( oldPercent_ );
     b12:	8a 81       	ldd	r24, Y+2	; 0x02
     b14:	9b 81       	ldd	r25, Y+3	; 0x03
     b16:	90 d3       	rcall	.+1824   	; 0x1238 <_ZN6Timer116setDutyCycleComAEf>
		vTaskDelay( delay_ / portTICK_RATE_MS );
     b18:	8f 89       	ldd	r24, Y+23	; 0x17
     b1a:	98 8d       	ldd	r25, Y+24	; 0x18
     b1c:	0e 94 fe 0e 	call	0x1dfc	; 0x1dfc <vTaskDelay>
	}
}
     b20:	df 91       	pop	r29
     b22:	cf 91       	pop	r28
     b24:	ff 90       	pop	r15
     b26:	ef 90       	pop	r14
     b28:	df 90       	pop	r13
     b2a:	cf 90       	pop	r12
     b2c:	bf 90       	pop	r11
     b2e:	af 90       	pop	r10
     b30:	9f 90       	pop	r9
     b32:	8f 90       	pop	r8
     b34:	7f 90       	pop	r7
     b36:	6f 90       	pop	r6
     b38:	5f 90       	pop	r5
     b3a:	4f 90       	pop	r4
     b3c:	08 95       	ret

00000b3e <_ZN2M1C1EP6Timer1>:
* Author: jespe
*/

#include "M1.h"

M1::M1( Timer1* tmr )
     b3e:	cf 93       	push	r28
     b40:	df 93       	push	r29
     b42:	ec 01       	movw	r28, r24
     b44:	cb 01       	movw	r24, r22
     b46:	23 e8       	ldi	r18, 0x83	; 131
     b48:	32 e0       	ldi	r19, 0x02	; 2
     b4a:	39 83       	std	Y+1, r19	; 0x01
     b4c:	28 83       	st	Y, r18
{
	/* Store timer pointer */
	tmr1Ptr_ = tmr;
     b4e:	7b 83       	std	Y+3, r23	; 0x03
     b50:	6a 83       	std	Y+2, r22	; 0x02
	
	/* This value is number of percent to add or subtract pr degree. */
	percentPrDeg = 0.0555555555555556;
     b52:	49 e3       	ldi	r20, 0x39	; 57
     b54:	5e e8       	ldi	r21, 0x8E	; 142
     b56:	63 e6       	ldi	r22, 0x63	; 99
     b58:	7d e3       	ldi	r23, 0x3D	; 61
     b5a:	4e 83       	std	Y+6, r20	; 0x06
     b5c:	5f 83       	std	Y+7, r21	; 0x07
     b5e:	68 87       	std	Y+8, r22	; 0x08
     b60:	79 87       	std	Y+9, r23	; 0x09
	
	/* This value is the lowest duty cycle percentage needed to make motor turn. */
	startpercent_ = 2.5;
     b62:	40 e0       	ldi	r20, 0x00	; 0
     b64:	50 e0       	ldi	r21, 0x00	; 0
     b66:	60 e2       	ldi	r22, 0x20	; 32
     b68:	70 e4       	ldi	r23, 0x40	; 64
     b6a:	4a 8b       	std	Y+18, r20	; 0x12
     b6c:	5b 8b       	std	Y+19, r21	; 0x13
     b6e:	6c 8b       	std	Y+20, r22	; 0x14
     b70:	7d 8b       	std	Y+21, r23	; 0x15
	
	/* This value is the delay on motor. A lower value makes motors go faster and higher value makes motors go slower. */
	delay_ = 10;
     b72:	2a e0       	ldi	r18, 0x0A	; 10
     b74:	30 e0       	ldi	r19, 0x00	; 0
     b76:	38 8f       	std	Y+24, r19	; 0x18
     b78:	2f 8b       	std	Y+23, r18	; 0x17
	
	/* This value is the maximum number of degrees the motor can turn */
	maxDegrees_ = 180;
     b7a:	24 eb       	ldi	r18, 0xB4	; 180
     b7c:	2e 8b       	std	Y+22, r18	; 0x16
	*/
	virtual void SetDegrees( uint8_t degrees )
	{
		if ( maxDegrees_ >= degrees )
		{
			percent_ = percentPrDeg * degrees + startpercent_;
     b7e:	40 e0       	ldi	r20, 0x00	; 0
     b80:	50 e0       	ldi	r21, 0x00	; 0
     b82:	60 ef       	ldi	r22, 0xF0	; 240
     b84:	70 e4       	ldi	r23, 0x40	; 64
     b86:	4a 87       	std	Y+10, r20	; 0x0a
     b88:	5b 87       	std	Y+11, r21	; 0x0b
     b8a:	6c 87       	std	Y+12, r22	; 0x0c
     b8c:	7d 87       	std	Y+13, r23	; 0x0d
	
	/* Set motor to default startup value */
	SetDegrees( 90 );
	tmr1Ptr_->setDutyCycleComA( percent_ );
     b8e:	54 d3       	rcall	.+1704   	; 0x1238 <_ZN6Timer116setDutyCycleComAEf>
	oldPercent_ = percent_;
     b90:	8a 85       	ldd	r24, Y+10	; 0x0a
     b92:	9b 85       	ldd	r25, Y+11	; 0x0b
     b94:	ac 85       	ldd	r26, Y+12	; 0x0c
     b96:	bd 85       	ldd	r27, Y+13	; 0x0d
     b98:	8e 87       	std	Y+14, r24	; 0x0e
     b9a:	9f 87       	std	Y+15, r25	; 0x0f
     b9c:	a8 8b       	std	Y+16, r26	; 0x10
     b9e:	b9 8b       	std	Y+17, r27	; 0x11
} 
     ba0:	df 91       	pop	r29
     ba2:	cf 91       	pop	r28
     ba4:	08 95       	ret

00000ba6 <_ZN2M2D1Ev>:

class Motor
{
//functions
public:
	virtual ~Motor() {};
     ba6:	27 e7       	ldi	r18, 0x77	; 119
     ba8:	32 e0       	ldi	r19, 0x02	; 2
     baa:	fc 01       	movw	r30, r24
     bac:	31 83       	std	Z+1, r19	; 0x01
     bae:	20 83       	st	Z, r18
     bb0:	08 95       	ret

00000bb2 <_ZN2M2D0Ev>:
	SetDegrees( 90 );
	tmr1Ptr_->setDutyCycleComB( percent_ );
	oldPercent_ = percent_;
}

M2::~M2()
     bb2:	cf 93       	push	r28
     bb4:	df 93       	push	r29
     bb6:	ec 01       	movw	r28, r24
{
}
     bb8:	f6 df       	rcall	.-20     	; 0xba6 <_ZN2M2D1Ev>
     bba:	ce 01       	movw	r24, r28
     bbc:	aa dd       	rcall	.-1196   	; 0x712 <_ZdlPv>
     bbe:	df 91       	pop	r29
     bc0:	cf 91       	pop	r28
     bc2:	08 95       	ret

00000bc4 <_ZN2M29TurnMotorEv>:

void M2::TurnMotor()
{
     bc4:	4f 92       	push	r4
     bc6:	5f 92       	push	r5
     bc8:	6f 92       	push	r6
     bca:	7f 92       	push	r7
     bcc:	8f 92       	push	r8
     bce:	9f 92       	push	r9
     bd0:	af 92       	push	r10
     bd2:	bf 92       	push	r11
     bd4:	cf 92       	push	r12
     bd6:	df 92       	push	r13
     bd8:	ef 92       	push	r14
     bda:	ff 92       	push	r15
     bdc:	cf 93       	push	r28
     bde:	df 93       	push	r29
     be0:	ec 01       	movw	r28, r24
	if ( percent_ > oldPercent_ + PERCENT_PR_TICK )
     be2:	8a 84       	ldd	r8, Y+10	; 0x0a
     be4:	9b 84       	ldd	r9, Y+11	; 0x0b
     be6:	ac 84       	ldd	r10, Y+12	; 0x0c
     be8:	bd 84       	ldd	r11, Y+13	; 0x0d
     bea:	ce 84       	ldd	r12, Y+14	; 0x0e
     bec:	df 84       	ldd	r13, Y+15	; 0x0f
     bee:	e8 88       	ldd	r14, Y+16	; 0x10
     bf0:	f9 88       	ldd	r15, Y+17	; 0x11
     bf2:	20 e0       	ldi	r18, 0x00	; 0
     bf4:	30 e0       	ldi	r19, 0x00	; 0
     bf6:	40 e8       	ldi	r20, 0x80	; 128
     bf8:	5d e3       	ldi	r21, 0x3D	; 61
     bfa:	c7 01       	movw	r24, r14
     bfc:	b6 01       	movw	r22, r12
     bfe:	0e 94 dc 0f 	call	0x1fb8	; 0x1fb8 <__addsf3>
     c02:	2b 01       	movw	r4, r22
     c04:	3c 01       	movw	r6, r24
     c06:	9b 01       	movw	r18, r22
     c08:	ac 01       	movw	r20, r24
     c0a:	c5 01       	movw	r24, r10
     c0c:	b4 01       	movw	r22, r8
     c0e:	0e 94 22 11 	call	0x2244	; 0x2244 <__gesf2>
     c12:	18 16       	cp	r1, r24
     c14:	74 f4       	brge	.+28     	; 0xc32 <_ZN2M29TurnMotorEv+0x6e>
	{
		oldPercent_ += PERCENT_PR_TICK;
     c16:	4e 86       	std	Y+14, r4	; 0x0e
     c18:	5f 86       	std	Y+15, r5	; 0x0f
     c1a:	68 8a       	std	Y+16, r6	; 0x10
     c1c:	79 8a       	std	Y+17, r7	; 0x11
		tmr1Ptr_->setDutyCycleComB( oldPercent_ );
     c1e:	b3 01       	movw	r22, r6
     c20:	a2 01       	movw	r20, r4
     c22:	8a 81       	ldd	r24, Y+2	; 0x02
     c24:	9b 81       	ldd	r25, Y+3	; 0x03
     c26:	30 d3       	rcall	.+1632   	; 0x1288 <_ZN6Timer116setDutyCycleComBEf>
		vTaskDelay( delay_ / portTICK_RATE_MS );
     c28:	8f 89       	ldd	r24, Y+23	; 0x17
     c2a:	98 8d       	ldd	r25, Y+24	; 0x18
     c2c:	0e 94 fe 0e 	call	0x1dfc	; 0x1dfc <vTaskDelay>
     c30:	1d c0       	rjmp	.+58     	; 0xc6c <_ZN2M29TurnMotorEv+0xa8>
	}
	else if ( percent_ < oldPercent_ )
     c32:	a7 01       	movw	r20, r14
     c34:	96 01       	movw	r18, r12
     c36:	c5 01       	movw	r24, r10
     c38:	b4 01       	movw	r22, r8
     c3a:	0e 94 40 10 	call	0x2080	; 0x2080 <__cmpsf2>
     c3e:	88 23       	and	r24, r24
     c40:	ac f4       	brge	.+42     	; 0xc6c <_ZN2M29TurnMotorEv+0xa8>
	{
		oldPercent_ -= PERCENT_PR_TICK;
     c42:	20 e0       	ldi	r18, 0x00	; 0
     c44:	30 e0       	ldi	r19, 0x00	; 0
     c46:	40 e8       	ldi	r20, 0x80	; 128
     c48:	5d e3       	ldi	r21, 0x3D	; 61
     c4a:	c7 01       	movw	r24, r14
     c4c:	b6 01       	movw	r22, r12
     c4e:	0e 94 db 0f 	call	0x1fb6	; 0x1fb6 <__subsf3>
     c52:	ab 01       	movw	r20, r22
     c54:	bc 01       	movw	r22, r24
     c56:	4e 87       	std	Y+14, r20	; 0x0e
     c58:	5f 87       	std	Y+15, r21	; 0x0f
     c5a:	68 8b       	std	Y+16, r22	; 0x10
     c5c:	79 8b       	std	Y+17, r23	; 0x11
		tmr1Ptr_->setDutyCycleComB( oldPercent_ );
     c5e:	8a 81       	ldd	r24, Y+2	; 0x02
     c60:	9b 81       	ldd	r25, Y+3	; 0x03
     c62:	12 d3       	rcall	.+1572   	; 0x1288 <_ZN6Timer116setDutyCycleComBEf>
		vTaskDelay( delay_ / portTICK_RATE_MS );
     c64:	8f 89       	ldd	r24, Y+23	; 0x17
     c66:	98 8d       	ldd	r25, Y+24	; 0x18
     c68:	0e 94 fe 0e 	call	0x1dfc	; 0x1dfc <vTaskDelay>
	}
}
     c6c:	df 91       	pop	r29
     c6e:	cf 91       	pop	r28
     c70:	ff 90       	pop	r15
     c72:	ef 90       	pop	r14
     c74:	df 90       	pop	r13
     c76:	cf 90       	pop	r12
     c78:	bf 90       	pop	r11
     c7a:	af 90       	pop	r10
     c7c:	9f 90       	pop	r9
     c7e:	8f 90       	pop	r8
     c80:	7f 90       	pop	r7
     c82:	6f 90       	pop	r6
     c84:	5f 90       	pop	r5
     c86:	4f 90       	pop	r4
     c88:	08 95       	ret

00000c8a <_ZN2M2C1EP6Timer1>:
* Author: jespe
*/

#include "M2.h"

M2::M2( Timer1* tmr )
     c8a:	cf 93       	push	r28
     c8c:	df 93       	push	r29
     c8e:	ec 01       	movw	r28, r24
     c90:	cb 01       	movw	r24, r22
     c92:	2f e8       	ldi	r18, 0x8F	; 143
     c94:	32 e0       	ldi	r19, 0x02	; 2
     c96:	39 83       	std	Y+1, r19	; 0x01
     c98:	28 83       	st	Y, r18
{
	/* Store timer pointer */
	tmr1Ptr_ = tmr;
     c9a:	7b 83       	std	Y+3, r23	; 0x03
     c9c:	6a 83       	std	Y+2, r22	; 0x02
	
	/* This value is number of percent to add or subtract pr degree. */
	percentPrDeg = 0.06;
     c9e:	4f e8       	ldi	r20, 0x8F	; 143
     ca0:	52 ec       	ldi	r21, 0xC2	; 194
     ca2:	65 e7       	ldi	r22, 0x75	; 117
     ca4:	7d e3       	ldi	r23, 0x3D	; 61
     ca6:	4e 83       	std	Y+6, r20	; 0x06
     ca8:	5f 83       	std	Y+7, r21	; 0x07
     caa:	68 87       	std	Y+8, r22	; 0x08
     cac:	79 87       	std	Y+9, r23	; 0x09

	/* This value is the lowest duty cycle percentage needed to make motor turn. */
	startpercent_ = 3;
     cae:	40 e0       	ldi	r20, 0x00	; 0
     cb0:	50 e0       	ldi	r21, 0x00	; 0
     cb2:	60 e4       	ldi	r22, 0x40	; 64
     cb4:	70 e4       	ldi	r23, 0x40	; 64
     cb6:	4a 8b       	std	Y+18, r20	; 0x12
     cb8:	5b 8b       	std	Y+19, r21	; 0x13
     cba:	6c 8b       	std	Y+20, r22	; 0x14
     cbc:	7d 8b       	std	Y+21, r23	; 0x15

	/* This value is the delay on motor. A lower value makes motors go faster and higher value makes motors go slower. Value is in MS */
	delay_ = 10;
     cbe:	2a e0       	ldi	r18, 0x0A	; 10
     cc0:	30 e0       	ldi	r19, 0x00	; 0
     cc2:	38 8f       	std	Y+24, r19	; 0x18
     cc4:	2f 8b       	std	Y+23, r18	; 0x17

	/* This value is the maximum number of degrees the motor can turn */
	maxDegrees_ = 150;
     cc6:	26 e9       	ldi	r18, 0x96	; 150
     cc8:	2e 8b       	std	Y+22, r18	; 0x16
	*/
	virtual void SetDegrees( uint8_t degrees )
	{
		if ( maxDegrees_ >= degrees )
		{
			percent_ = percentPrDeg * degrees + startpercent_;
     cca:	46 e6       	ldi	r20, 0x66	; 102
     ccc:	56 e6       	ldi	r21, 0x66	; 102
     cce:	66 e0       	ldi	r22, 0x06	; 6
     cd0:	71 e4       	ldi	r23, 0x41	; 65
     cd2:	4a 87       	std	Y+10, r20	; 0x0a
     cd4:	5b 87       	std	Y+11, r21	; 0x0b
     cd6:	6c 87       	std	Y+12, r22	; 0x0c
     cd8:	7d 87       	std	Y+13, r23	; 0x0d

	/* Set motor to default startup value */
	SetDegrees( 90 );
	tmr1Ptr_->setDutyCycleComB( percent_ );
     cda:	d6 d2       	rcall	.+1452   	; 0x1288 <_ZN6Timer116setDutyCycleComBEf>
	oldPercent_ = percent_;
     cdc:	8a 85       	ldd	r24, Y+10	; 0x0a
     cde:	9b 85       	ldd	r25, Y+11	; 0x0b
     ce0:	ac 85       	ldd	r26, Y+12	; 0x0c
     ce2:	bd 85       	ldd	r27, Y+13	; 0x0d
     ce4:	8e 87       	std	Y+14, r24	; 0x0e
     ce6:	9f 87       	std	Y+15, r25	; 0x0f
     ce8:	a8 8b       	std	Y+16, r26	; 0x10
     cea:	b9 8b       	std	Y+17, r27	; 0x11
}
     cec:	df 91       	pop	r29
     cee:	cf 91       	pop	r28
     cf0:	08 95       	ret

00000cf2 <_ZN2M3D1Ev>:

class Motor
{
//functions
public:
	virtual ~Motor() {};
     cf2:	27 e7       	ldi	r18, 0x77	; 119
     cf4:	32 e0       	ldi	r19, 0x02	; 2
     cf6:	fc 01       	movw	r30, r24
     cf8:	31 83       	std	Z+1, r19	; 0x01
     cfa:	20 83       	st	Z, r18
     cfc:	08 95       	ret

00000cfe <_ZN2M3D0Ev>:
	SetDegrees( 90 );
	tmr1Ptr_->setDutyCycleComC( percent_ );
	oldPercent_ = percent_;	
}

M3::~M3()
     cfe:	cf 93       	push	r28
     d00:	df 93       	push	r29
     d02:	ec 01       	movw	r28, r24
{
}
     d04:	f6 df       	rcall	.-20     	; 0xcf2 <_ZN2M3D1Ev>
     d06:	ce 01       	movw	r24, r28
     d08:	04 dd       	rcall	.-1528   	; 0x712 <_ZdlPv>
     d0a:	df 91       	pop	r29
     d0c:	cf 91       	pop	r28
     d0e:	08 95       	ret

00000d10 <_ZN2M39TurnMotorEv>:

void M3::TurnMotor()
{
     d10:	4f 92       	push	r4
     d12:	5f 92       	push	r5
     d14:	6f 92       	push	r6
     d16:	7f 92       	push	r7
     d18:	8f 92       	push	r8
     d1a:	9f 92       	push	r9
     d1c:	af 92       	push	r10
     d1e:	bf 92       	push	r11
     d20:	cf 92       	push	r12
     d22:	df 92       	push	r13
     d24:	ef 92       	push	r14
     d26:	ff 92       	push	r15
     d28:	cf 93       	push	r28
     d2a:	df 93       	push	r29
     d2c:	ec 01       	movw	r28, r24
	if ( percent_ > oldPercent_ + PERCENT_PR_TICK )
     d2e:	8a 84       	ldd	r8, Y+10	; 0x0a
     d30:	9b 84       	ldd	r9, Y+11	; 0x0b
     d32:	ac 84       	ldd	r10, Y+12	; 0x0c
     d34:	bd 84       	ldd	r11, Y+13	; 0x0d
     d36:	ce 84       	ldd	r12, Y+14	; 0x0e
     d38:	df 84       	ldd	r13, Y+15	; 0x0f
     d3a:	e8 88       	ldd	r14, Y+16	; 0x10
     d3c:	f9 88       	ldd	r15, Y+17	; 0x11
     d3e:	20 e0       	ldi	r18, 0x00	; 0
     d40:	30 e0       	ldi	r19, 0x00	; 0
     d42:	40 e8       	ldi	r20, 0x80	; 128
     d44:	5d e3       	ldi	r21, 0x3D	; 61
     d46:	c7 01       	movw	r24, r14
     d48:	b6 01       	movw	r22, r12
     d4a:	0e 94 dc 0f 	call	0x1fb8	; 0x1fb8 <__addsf3>
     d4e:	2b 01       	movw	r4, r22
     d50:	3c 01       	movw	r6, r24
     d52:	9b 01       	movw	r18, r22
     d54:	ac 01       	movw	r20, r24
     d56:	c5 01       	movw	r24, r10
     d58:	b4 01       	movw	r22, r8
     d5a:	0e 94 22 11 	call	0x2244	; 0x2244 <__gesf2>
     d5e:	18 16       	cp	r1, r24
     d60:	74 f4       	brge	.+28     	; 0xd7e <_ZN2M39TurnMotorEv+0x6e>
	{
		oldPercent_ += PERCENT_PR_TICK;
     d62:	4e 86       	std	Y+14, r4	; 0x0e
     d64:	5f 86       	std	Y+15, r5	; 0x0f
     d66:	68 8a       	std	Y+16, r6	; 0x10
     d68:	79 8a       	std	Y+17, r7	; 0x11
		tmr1Ptr_->setDutyCycleComC( oldPercent_ );
     d6a:	b3 01       	movw	r22, r6
     d6c:	a2 01       	movw	r20, r4
     d6e:	8a 81       	ldd	r24, Y+2	; 0x02
     d70:	9b 81       	ldd	r25, Y+3	; 0x03
     d72:	b2 d2       	rcall	.+1380   	; 0x12d8 <_ZN6Timer116setDutyCycleComCEf>
		vTaskDelay( delay_ / portTICK_RATE_MS );
     d74:	8f 89       	ldd	r24, Y+23	; 0x17
     d76:	98 8d       	ldd	r25, Y+24	; 0x18
     d78:	0e 94 fe 0e 	call	0x1dfc	; 0x1dfc <vTaskDelay>
     d7c:	1d c0       	rjmp	.+58     	; 0xdb8 <_ZN2M39TurnMotorEv+0xa8>
	}
	else if ( percent_ < oldPercent_ )
     d7e:	a7 01       	movw	r20, r14
     d80:	96 01       	movw	r18, r12
     d82:	c5 01       	movw	r24, r10
     d84:	b4 01       	movw	r22, r8
     d86:	0e 94 40 10 	call	0x2080	; 0x2080 <__cmpsf2>
     d8a:	88 23       	and	r24, r24
     d8c:	ac f4       	brge	.+42     	; 0xdb8 <_ZN2M39TurnMotorEv+0xa8>
	{
		oldPercent_ -= PERCENT_PR_TICK;
     d8e:	20 e0       	ldi	r18, 0x00	; 0
     d90:	30 e0       	ldi	r19, 0x00	; 0
     d92:	40 e8       	ldi	r20, 0x80	; 128
     d94:	5d e3       	ldi	r21, 0x3D	; 61
     d96:	c7 01       	movw	r24, r14
     d98:	b6 01       	movw	r22, r12
     d9a:	0e 94 db 0f 	call	0x1fb6	; 0x1fb6 <__subsf3>
     d9e:	ab 01       	movw	r20, r22
     da0:	bc 01       	movw	r22, r24
     da2:	4e 87       	std	Y+14, r20	; 0x0e
     da4:	5f 87       	std	Y+15, r21	; 0x0f
     da6:	68 8b       	std	Y+16, r22	; 0x10
     da8:	79 8b       	std	Y+17, r23	; 0x11
		tmr1Ptr_->setDutyCycleComC( oldPercent_ );
     daa:	8a 81       	ldd	r24, Y+2	; 0x02
     dac:	9b 81       	ldd	r25, Y+3	; 0x03
     dae:	94 d2       	rcall	.+1320   	; 0x12d8 <_ZN6Timer116setDutyCycleComCEf>
		vTaskDelay( delay_ / portTICK_RATE_MS );
     db0:	8f 89       	ldd	r24, Y+23	; 0x17
     db2:	98 8d       	ldd	r25, Y+24	; 0x18
     db4:	0e 94 fe 0e 	call	0x1dfc	; 0x1dfc <vTaskDelay>
	}
}
     db8:	df 91       	pop	r29
     dba:	cf 91       	pop	r28
     dbc:	ff 90       	pop	r15
     dbe:	ef 90       	pop	r14
     dc0:	df 90       	pop	r13
     dc2:	cf 90       	pop	r12
     dc4:	bf 90       	pop	r11
     dc6:	af 90       	pop	r10
     dc8:	9f 90       	pop	r9
     dca:	8f 90       	pop	r8
     dcc:	7f 90       	pop	r7
     dce:	6f 90       	pop	r6
     dd0:	5f 90       	pop	r5
     dd2:	4f 90       	pop	r4
     dd4:	08 95       	ret

00000dd6 <_ZN2M3C1EP6Timer1>:
*/

#include "M3.h"


M3::M3( Timer1* tmr )
     dd6:	cf 93       	push	r28
     dd8:	df 93       	push	r29
     dda:	ec 01       	movw	r28, r24
     ddc:	cb 01       	movw	r24, r22
     dde:	2b e9       	ldi	r18, 0x9B	; 155
     de0:	32 e0       	ldi	r19, 0x02	; 2
     de2:	39 83       	std	Y+1, r19	; 0x01
     de4:	28 83       	st	Y, r18
{
	/* Store timer pointer */
	tmr1Ptr_ = tmr;
     de6:	7b 83       	std	Y+3, r23	; 0x03
     de8:	6a 83       	std	Y+2, r22	; 0x02
		
	/* This value is number of percent to add or subtract pr degree. */
	percentPrDeg = 0.0555555555555556;
     dea:	49 e3       	ldi	r20, 0x39	; 57
     dec:	5e e8       	ldi	r21, 0x8E	; 142
     dee:	63 e6       	ldi	r22, 0x63	; 99
     df0:	7d e3       	ldi	r23, 0x3D	; 61
     df2:	4e 83       	std	Y+6, r20	; 0x06
     df4:	5f 83       	std	Y+7, r21	; 0x07
     df6:	68 87       	std	Y+8, r22	; 0x08
     df8:	79 87       	std	Y+9, r23	; 0x09
	
	/* This value is the lowest duty cycle percentage needed to make motor turn. */
	startpercent_ = 2.5;
     dfa:	40 e0       	ldi	r20, 0x00	; 0
     dfc:	50 e0       	ldi	r21, 0x00	; 0
     dfe:	60 e2       	ldi	r22, 0x20	; 32
     e00:	70 e4       	ldi	r23, 0x40	; 64
     e02:	4a 8b       	std	Y+18, r20	; 0x12
     e04:	5b 8b       	std	Y+19, r21	; 0x13
     e06:	6c 8b       	std	Y+20, r22	; 0x14
     e08:	7d 8b       	std	Y+21, r23	; 0x15

	/* This value is the delay on motor. A lower value makes motors go faster and higher value makes motors go slower. Value is in MS */
	delay_ = 10;
     e0a:	2a e0       	ldi	r18, 0x0A	; 10
     e0c:	30 e0       	ldi	r19, 0x00	; 0
     e0e:	38 8f       	std	Y+24, r19	; 0x18
     e10:	2f 8b       	std	Y+23, r18	; 0x17
	
	/* This value is the maximum number of degrees the motor can turn */
	maxDegrees_ = 180;
     e12:	24 eb       	ldi	r18, 0xB4	; 180
     e14:	2e 8b       	std	Y+22, r18	; 0x16
	*/
	virtual void SetDegrees( uint8_t degrees )
	{
		if ( maxDegrees_ >= degrees )
		{
			percent_ = percentPrDeg * degrees + startpercent_;
     e16:	40 e0       	ldi	r20, 0x00	; 0
     e18:	50 e0       	ldi	r21, 0x00	; 0
     e1a:	60 ef       	ldi	r22, 0xF0	; 240
     e1c:	70 e4       	ldi	r23, 0x40	; 64
     e1e:	4a 87       	std	Y+10, r20	; 0x0a
     e20:	5b 87       	std	Y+11, r21	; 0x0b
     e22:	6c 87       	std	Y+12, r22	; 0x0c
     e24:	7d 87       	std	Y+13, r23	; 0x0d
	
	/* Set motor to default startup value */
	SetDegrees( 90 );
	tmr1Ptr_->setDutyCycleComC( percent_ );
     e26:	58 d2       	rcall	.+1200   	; 0x12d8 <_ZN6Timer116setDutyCycleComCEf>
	oldPercent_ = percent_;	
     e28:	8a 85       	ldd	r24, Y+10	; 0x0a
     e2a:	9b 85       	ldd	r25, Y+11	; 0x0b
     e2c:	ac 85       	ldd	r26, Y+12	; 0x0c
     e2e:	bd 85       	ldd	r27, Y+13	; 0x0d
     e30:	8e 87       	std	Y+14, r24	; 0x0e
     e32:	9f 87       	std	Y+15, r25	; 0x0f
     e34:	a8 8b       	std	Y+16, r26	; 0x10
     e36:	b9 8b       	std	Y+17, r27	; 0x11
}
     e38:	df 91       	pop	r29
     e3a:	cf 91       	pop	r28
     e3c:	08 95       	ret

00000e3e <_ZN2M4D1Ev>:

class Motor
{
//functions
public:
	virtual ~Motor() {};
     e3e:	27 e7       	ldi	r18, 0x77	; 119
     e40:	32 e0       	ldi	r19, 0x02	; 2
     e42:	fc 01       	movw	r30, r24
     e44:	31 83       	std	Z+1, r19	; 0x01
     e46:	20 83       	st	Z, r18
     e48:	08 95       	ret

00000e4a <_ZN2M4D0Ev>:
	SetDegrees( 90 );
	tmr3Ptr_->setDutyCycleComA( percent_ );
	oldPercent_ = percent_;
}

M4::~M4()
     e4a:	cf 93       	push	r28
     e4c:	df 93       	push	r29
     e4e:	ec 01       	movw	r28, r24
{
} 
     e50:	f6 df       	rcall	.-20     	; 0xe3e <_ZN2M4D1Ev>
     e52:	ce 01       	movw	r24, r28
     e54:	5e dc       	rcall	.-1860   	; 0x712 <_ZdlPv>
     e56:	df 91       	pop	r29
     e58:	cf 91       	pop	r28
     e5a:	08 95       	ret

00000e5c <_ZN2M49TurnMotorEv>:

void M4::TurnMotor()
{
     e5c:	4f 92       	push	r4
     e5e:	5f 92       	push	r5
     e60:	6f 92       	push	r6
     e62:	7f 92       	push	r7
     e64:	8f 92       	push	r8
     e66:	9f 92       	push	r9
     e68:	af 92       	push	r10
     e6a:	bf 92       	push	r11
     e6c:	cf 92       	push	r12
     e6e:	df 92       	push	r13
     e70:	ef 92       	push	r14
     e72:	ff 92       	push	r15
     e74:	cf 93       	push	r28
     e76:	df 93       	push	r29
     e78:	ec 01       	movw	r28, r24
	if ( percent_ > oldPercent_ + PERCENT_PR_TICK )
     e7a:	8a 84       	ldd	r8, Y+10	; 0x0a
     e7c:	9b 84       	ldd	r9, Y+11	; 0x0b
     e7e:	ac 84       	ldd	r10, Y+12	; 0x0c
     e80:	bd 84       	ldd	r11, Y+13	; 0x0d
     e82:	ce 84       	ldd	r12, Y+14	; 0x0e
     e84:	df 84       	ldd	r13, Y+15	; 0x0f
     e86:	e8 88       	ldd	r14, Y+16	; 0x10
     e88:	f9 88       	ldd	r15, Y+17	; 0x11
     e8a:	20 e0       	ldi	r18, 0x00	; 0
     e8c:	30 e0       	ldi	r19, 0x00	; 0
     e8e:	40 e8       	ldi	r20, 0x80	; 128
     e90:	5d e3       	ldi	r21, 0x3D	; 61
     e92:	c7 01       	movw	r24, r14
     e94:	b6 01       	movw	r22, r12
     e96:	0e 94 dc 0f 	call	0x1fb8	; 0x1fb8 <__addsf3>
     e9a:	2b 01       	movw	r4, r22
     e9c:	3c 01       	movw	r6, r24
     e9e:	9b 01       	movw	r18, r22
     ea0:	ac 01       	movw	r20, r24
     ea2:	c5 01       	movw	r24, r10
     ea4:	b4 01       	movw	r22, r8
     ea6:	0e 94 22 11 	call	0x2244	; 0x2244 <__gesf2>
     eaa:	18 16       	cp	r1, r24
     eac:	6c f4       	brge	.+26     	; 0xec8 <_ZN2M49TurnMotorEv+0x6c>
	{
		oldPercent_ += PERCENT_PR_TICK;
     eae:	4e 86       	std	Y+14, r4	; 0x0e
     eb0:	5f 86       	std	Y+15, r5	; 0x0f
     eb2:	68 8a       	std	Y+16, r6	; 0x10
     eb4:	79 8a       	std	Y+17, r7	; 0x11
		tmr3Ptr_->setDutyCycleComA( oldPercent_ );
     eb6:	b3 01       	movw	r22, r6
     eb8:	a2 01       	movw	r20, r4
     eba:	8c 81       	ldd	r24, Y+4	; 0x04
     ebc:	9d 81       	ldd	r25, Y+5	; 0x05
     ebe:	54 d2       	rcall	.+1192   	; 0x1368 <_ZN6Timer516setDutyCycleComAEf>
		vTaskDelay( 10 / portTICK_RATE_MS );
     ec0:	8a e0       	ldi	r24, 0x0A	; 10
     ec2:	90 e0       	ldi	r25, 0x00	; 0
     ec4:	9b d7       	rcall	.+3894   	; 0x1dfc <vTaskDelay>
     ec6:	1c c0       	rjmp	.+56     	; 0xf00 <_ZN2M49TurnMotorEv+0xa4>
	}
	else if ( percent_ < oldPercent_ )
     ec8:	a7 01       	movw	r20, r14
     eca:	96 01       	movw	r18, r12
     ecc:	c5 01       	movw	r24, r10
     ece:	b4 01       	movw	r22, r8
     ed0:	0e 94 40 10 	call	0x2080	; 0x2080 <__cmpsf2>
     ed4:	88 23       	and	r24, r24
     ed6:	a4 f4       	brge	.+40     	; 0xf00 <_ZN2M49TurnMotorEv+0xa4>
	{
		oldPercent_ -= PERCENT_PR_TICK;
     ed8:	20 e0       	ldi	r18, 0x00	; 0
     eda:	30 e0       	ldi	r19, 0x00	; 0
     edc:	40 e8       	ldi	r20, 0x80	; 128
     ede:	5d e3       	ldi	r21, 0x3D	; 61
     ee0:	c7 01       	movw	r24, r14
     ee2:	b6 01       	movw	r22, r12
     ee4:	0e 94 db 0f 	call	0x1fb6	; 0x1fb6 <__subsf3>
     ee8:	ab 01       	movw	r20, r22
     eea:	bc 01       	movw	r22, r24
     eec:	4e 87       	std	Y+14, r20	; 0x0e
     eee:	5f 87       	std	Y+15, r21	; 0x0f
     ef0:	68 8b       	std	Y+16, r22	; 0x10
     ef2:	79 8b       	std	Y+17, r23	; 0x11
		tmr3Ptr_->setDutyCycleComA( oldPercent_ );
     ef4:	8c 81       	ldd	r24, Y+4	; 0x04
     ef6:	9d 81       	ldd	r25, Y+5	; 0x05
     ef8:	37 d2       	rcall	.+1134   	; 0x1368 <_ZN6Timer516setDutyCycleComAEf>
		vTaskDelay( 10 / portTICK_RATE_MS );
     efa:	8a e0       	ldi	r24, 0x0A	; 10
     efc:	90 e0       	ldi	r25, 0x00	; 0
     efe:	7e d7       	rcall	.+3836   	; 0x1dfc <vTaskDelay>
     f00:	df 91       	pop	r29
	}
}
     f02:	cf 91       	pop	r28
     f04:	ff 90       	pop	r15
     f06:	ef 90       	pop	r14
     f08:	df 90       	pop	r13
     f0a:	cf 90       	pop	r12
     f0c:	bf 90       	pop	r11
     f0e:	af 90       	pop	r10
     f10:	9f 90       	pop	r9
     f12:	8f 90       	pop	r8
     f14:	7f 90       	pop	r7
     f16:	6f 90       	pop	r6
     f18:	5f 90       	pop	r5
     f1a:	4f 90       	pop	r4
     f1c:	08 95       	ret

00000f1e <_ZN2M4C1EP6Timer5>:
     f1e:	cf 93       	push	r28
* Author: jespe
*/

#include "M4.h"

M4::M4( Timer5* tmr )
     f20:	df 93       	push	r29
     f22:	ec 01       	movw	r28, r24
     f24:	cb 01       	movw	r24, r22
     f26:	27 ea       	ldi	r18, 0xA7	; 167
     f28:	32 e0       	ldi	r19, 0x02	; 2
     f2a:	39 83       	std	Y+1, r19	; 0x01
     f2c:	28 83       	st	Y, r18
{
	/* Store timer pointer */
	tmr3Ptr_ = tmr;
     f2e:	7d 83       	std	Y+5, r23	; 0x05
     f30:	6c 83       	std	Y+4, r22	; 0x04
	
	/* This value is number of percent to add or subtract pr degree. */
	percentPrDeg = 0.0555555555555556;
     f32:	49 e3       	ldi	r20, 0x39	; 57
     f34:	5e e8       	ldi	r21, 0x8E	; 142
     f36:	63 e6       	ldi	r22, 0x63	; 99
     f38:	7d e3       	ldi	r23, 0x3D	; 61
     f3a:	4e 83       	std	Y+6, r20	; 0x06
     f3c:	5f 83       	std	Y+7, r21	; 0x07
     f3e:	68 87       	std	Y+8, r22	; 0x08
     f40:	79 87       	std	Y+9, r23	; 0x09
	
	/* This value is the lowest duty cycle percentage needed to make motor turn. */
	startpercent_ = 2.5;
     f42:	40 e0       	ldi	r20, 0x00	; 0
     f44:	50 e0       	ldi	r21, 0x00	; 0
     f46:	60 e2       	ldi	r22, 0x20	; 32
     f48:	70 e4       	ldi	r23, 0x40	; 64
     f4a:	4a 8b       	std	Y+18, r20	; 0x12
     f4c:	5b 8b       	std	Y+19, r21	; 0x13
     f4e:	6c 8b       	std	Y+20, r22	; 0x14
     f50:	7d 8b       	std	Y+21, r23	; 0x15
		
	/* This value is the delay on motor. A lower value makes motors go faster and higher value makes motors go slower. Value is in MS */
	delay_ = 5;
     f52:	25 e0       	ldi	r18, 0x05	; 5
     f54:	30 e0       	ldi	r19, 0x00	; 0
     f56:	38 8f       	std	Y+24, r19	; 0x18
     f58:	2f 8b       	std	Y+23, r18	; 0x17
	
	/* This value is the maximum number of degrees the motor can turn */
	maxDegrees_ = 180;
     f5a:	24 eb       	ldi	r18, 0xB4	; 180
     f5c:	2e 8b       	std	Y+22, r18	; 0x16
	*/
	virtual void SetDegrees( uint8_t degrees )
	{
		if ( maxDegrees_ >= degrees )
		{
			percent_ = percentPrDeg * degrees + startpercent_;
     f5e:	40 e0       	ldi	r20, 0x00	; 0
     f60:	50 e0       	ldi	r21, 0x00	; 0
     f62:	60 ef       	ldi	r22, 0xF0	; 240
     f64:	70 e4       	ldi	r23, 0x40	; 64
     f66:	4a 87       	std	Y+10, r20	; 0x0a
     f68:	5b 87       	std	Y+11, r21	; 0x0b
     f6a:	6c 87       	std	Y+12, r22	; 0x0c
     f6c:	7d 87       	std	Y+13, r23	; 0x0d
	
	/* Set motor to default startup value */
	SetDegrees( 90 );
	tmr3Ptr_->setDutyCycleComA( percent_ );
     f6e:	fc d1       	rcall	.+1016   	; 0x1368 <_ZN6Timer516setDutyCycleComAEf>
	oldPercent_ = percent_;
     f70:	8a 85       	ldd	r24, Y+10	; 0x0a
     f72:	9b 85       	ldd	r25, Y+11	; 0x0b
     f74:	ac 85       	ldd	r26, Y+12	; 0x0c
     f76:	bd 85       	ldd	r27, Y+13	; 0x0d
     f78:	8e 87       	std	Y+14, r24	; 0x0e
     f7a:	9f 87       	std	Y+15, r25	; 0x0f
     f7c:	a8 8b       	std	Y+16, r26	; 0x10
     f7e:	b9 8b       	std	Y+17, r27	; 0x11
}
     f80:	df 91       	pop	r29
     f82:	cf 91       	pop	r28
     f84:	08 95       	ret

00000f86 <_ZN2M5D1Ev>:

class Motor
{
//functions
public:
	virtual ~Motor() {};
     f86:	27 e7       	ldi	r18, 0x77	; 119
     f88:	32 e0       	ldi	r19, 0x02	; 2
     f8a:	fc 01       	movw	r30, r24
     f8c:	31 83       	std	Z+1, r19	; 0x01
     f8e:	20 83       	st	Z, r18
     f90:	08 95       	ret

00000f92 <_ZN2M5D0Ev>:
	SetDegrees( 0 );
	tmr3Ptr_->setDutyCycleComB( percent_ );
	oldPercent_ = percent_;
}

M5::~M5()
     f92:	cf 93       	push	r28
     f94:	df 93       	push	r29
     f96:	ec 01       	movw	r28, r24
{
}
     f98:	f6 df       	rcall	.-20     	; 0xf86 <_ZN2M5D1Ev>
     f9a:	ce 01       	movw	r24, r28
     f9c:	ba db       	rcall	.-2188   	; 0x712 <_ZdlPv>
     f9e:	df 91       	pop	r29
     fa0:	cf 91       	pop	r28
     fa2:	08 95       	ret

00000fa4 <_ZN2M59TurnMotorEv>:

void M5::TurnMotor()
{
     fa4:	4f 92       	push	r4
     fa6:	5f 92       	push	r5
     fa8:	6f 92       	push	r6
     faa:	7f 92       	push	r7
     fac:	8f 92       	push	r8
     fae:	9f 92       	push	r9
     fb0:	af 92       	push	r10
     fb2:	bf 92       	push	r11
     fb4:	cf 92       	push	r12
     fb6:	df 92       	push	r13
     fb8:	ef 92       	push	r14
     fba:	ff 92       	push	r15
     fbc:	cf 93       	push	r28
     fbe:	df 93       	push	r29
     fc0:	ec 01       	movw	r28, r24
	if ( percent_ > oldPercent_ + PERCENT_PR_TICK )
     fc2:	8a 84       	ldd	r8, Y+10	; 0x0a
     fc4:	9b 84       	ldd	r9, Y+11	; 0x0b
     fc6:	ac 84       	ldd	r10, Y+12	; 0x0c
     fc8:	bd 84       	ldd	r11, Y+13	; 0x0d
     fca:	ce 84       	ldd	r12, Y+14	; 0x0e
     fcc:	df 84       	ldd	r13, Y+15	; 0x0f
     fce:	e8 88       	ldd	r14, Y+16	; 0x10
     fd0:	f9 88       	ldd	r15, Y+17	; 0x11
     fd2:	20 e0       	ldi	r18, 0x00	; 0
     fd4:	30 e0       	ldi	r19, 0x00	; 0
     fd6:	40 e8       	ldi	r20, 0x80	; 128
     fd8:	5d e3       	ldi	r21, 0x3D	; 61
     fda:	c7 01       	movw	r24, r14
     fdc:	b6 01       	movw	r22, r12
     fde:	ec d7       	rcall	.+4056   	; 0x1fb8 <__addsf3>
     fe0:	2b 01       	movw	r4, r22
     fe2:	3c 01       	movw	r6, r24
     fe4:	9b 01       	movw	r18, r22
     fe6:	ac 01       	movw	r20, r24
     fe8:	c5 01       	movw	r24, r10
     fea:	b4 01       	movw	r22, r8
     fec:	0e 94 22 11 	call	0x2244	; 0x2244 <__gesf2>
     ff0:	18 16       	cp	r1, r24
     ff2:	6c f4       	brge	.+26     	; 0x100e <_ZN2M59TurnMotorEv+0x6a>
	{
		oldPercent_ += PERCENT_PR_TICK;
     ff4:	4e 86       	std	Y+14, r4	; 0x0e
     ff6:	5f 86       	std	Y+15, r5	; 0x0f
     ff8:	68 8a       	std	Y+16, r6	; 0x10
     ffa:	79 8a       	std	Y+17, r7	; 0x11
		tmr3Ptr_->setDutyCycleComB( oldPercent_ );
     ffc:	b3 01       	movw	r22, r6
     ffe:	a2 01       	movw	r20, r4
    1000:	8c 81       	ldd	r24, Y+4	; 0x04
    1002:	9d 81       	ldd	r25, Y+5	; 0x05
    1004:	d8 d1       	rcall	.+944    	; 0x13b6 <_ZN6Timer516setDutyCycleComBEf>
		vTaskDelay( delay_ / portTICK_RATE_MS );
    1006:	8f 89       	ldd	r24, Y+23	; 0x17
    1008:	98 8d       	ldd	r25, Y+24	; 0x18
    100a:	f8 d6       	rcall	.+3568   	; 0x1dfc <vTaskDelay>
    100c:	1b c0       	rjmp	.+54     	; 0x1044 <_ZN2M59TurnMotorEv+0xa0>
	}
	else if ( percent_ < oldPercent_ )
    100e:	a7 01       	movw	r20, r14
    1010:	96 01       	movw	r18, r12
    1012:	c5 01       	movw	r24, r10
    1014:	b4 01       	movw	r22, r8
    1016:	0e 94 40 10 	call	0x2080	; 0x2080 <__cmpsf2>
    101a:	88 23       	and	r24, r24
    101c:	9c f4       	brge	.+38     	; 0x1044 <_ZN2M59TurnMotorEv+0xa0>
	{
		oldPercent_ -= PERCENT_PR_TICK;
    101e:	20 e0       	ldi	r18, 0x00	; 0
    1020:	30 e0       	ldi	r19, 0x00	; 0
    1022:	40 e8       	ldi	r20, 0x80	; 128
    1024:	5d e3       	ldi	r21, 0x3D	; 61
    1026:	c7 01       	movw	r24, r14
    1028:	b6 01       	movw	r22, r12
    102a:	c5 d7       	rcall	.+3978   	; 0x1fb6 <__subsf3>
    102c:	ab 01       	movw	r20, r22
    102e:	bc 01       	movw	r22, r24
    1030:	4e 87       	std	Y+14, r20	; 0x0e
    1032:	5f 87       	std	Y+15, r21	; 0x0f
    1034:	68 8b       	std	Y+16, r22	; 0x10
    1036:	79 8b       	std	Y+17, r23	; 0x11
		tmr3Ptr_->setDutyCycleComB( oldPercent_ );
    1038:	8c 81       	ldd	r24, Y+4	; 0x04
    103a:	9d 81       	ldd	r25, Y+5	; 0x05
    103c:	bc d1       	rcall	.+888    	; 0x13b6 <_ZN6Timer516setDutyCycleComBEf>
		vTaskDelay( delay_ / portTICK_RATE_MS );
    103e:	8f 89       	ldd	r24, Y+23	; 0x17
    1040:	98 8d       	ldd	r25, Y+24	; 0x18
    1042:	dc d6       	rcall	.+3512   	; 0x1dfc <vTaskDelay>
    1044:	df 91       	pop	r29
	}
}
    1046:	cf 91       	pop	r28
    1048:	ff 90       	pop	r15
    104a:	ef 90       	pop	r14
    104c:	df 90       	pop	r13
    104e:	cf 90       	pop	r12
    1050:	bf 90       	pop	r11
    1052:	af 90       	pop	r10
    1054:	9f 90       	pop	r9
    1056:	8f 90       	pop	r8
    1058:	7f 90       	pop	r7
    105a:	6f 90       	pop	r6
    105c:	5f 90       	pop	r5
    105e:	4f 90       	pop	r4
    1060:	08 95       	ret

00001062 <_ZN2M5C1EP6Timer5>:
    1062:	cf 93       	push	r28
* Author: jespe
*/

#include "M5.h"

M5::M5( Timer5* tmr )
    1064:	df 93       	push	r29
    1066:	ec 01       	movw	r28, r24
    1068:	cb 01       	movw	r24, r22
    106a:	23 eb       	ldi	r18, 0xB3	; 179
    106c:	32 e0       	ldi	r19, 0x02	; 2
    106e:	39 83       	std	Y+1, r19	; 0x01
    1070:	28 83       	st	Y, r18
{
	/* Store timer pointer */
	tmr3Ptr_ = tmr;
    1072:	7d 83       	std	Y+5, r23	; 0x05
    1074:	6c 83       	std	Y+4, r22	; 0x04
	
	/* This value is number of percent to add or subtract pr degree. */
	percentPrDeg = 0.0555555555555556;
    1076:	49 e3       	ldi	r20, 0x39	; 57
    1078:	5e e8       	ldi	r21, 0x8E	; 142
    107a:	63 e6       	ldi	r22, 0x63	; 99
    107c:	7d e3       	ldi	r23, 0x3D	; 61
    107e:	4e 83       	std	Y+6, r20	; 0x06
    1080:	5f 83       	std	Y+7, r21	; 0x07
    1082:	68 87       	std	Y+8, r22	; 0x08
    1084:	79 87       	std	Y+9, r23	; 0x09
	
	/* This value is the lowest duty cycle percentage needed to make motor turn. */
	startpercent_ = 2.5;
    1086:	40 e0       	ldi	r20, 0x00	; 0
    1088:	50 e0       	ldi	r21, 0x00	; 0
    108a:	60 e2       	ldi	r22, 0x20	; 32
    108c:	70 e4       	ldi	r23, 0x40	; 64
    108e:	4a 8b       	std	Y+18, r20	; 0x12
    1090:	5b 8b       	std	Y+19, r21	; 0x13
    1092:	6c 8b       	std	Y+20, r22	; 0x14
    1094:	7d 8b       	std	Y+21, r23	; 0x15
	
	/* This value is the delay on motor. A lower value makes motors go faster and higher value makes motors go slower. Value is in MS */
	delay_ = 1;
    1096:	21 e0       	ldi	r18, 0x01	; 1
    1098:	30 e0       	ldi	r19, 0x00	; 0
    109a:	38 8f       	std	Y+24, r19	; 0x18
    109c:	2f 8b       	std	Y+23, r18	; 0x17
	
	/* This value is the maximum number of degrees the motor can turn */
	maxDegrees_ = 180;
    109e:	24 eb       	ldi	r18, 0xB4	; 180
    10a0:	2e 8b       	std	Y+22, r18	; 0x16
	*/
	virtual void SetDegrees( uint8_t degrees )
	{
		if ( maxDegrees_ >= degrees )
		{
			percent_ = percentPrDeg * degrees + startpercent_;
    10a2:	4a 87       	std	Y+10, r20	; 0x0a
    10a4:	5b 87       	std	Y+11, r21	; 0x0b
    10a6:	6c 87       	std	Y+12, r22	; 0x0c
    10a8:	7d 87       	std	Y+13, r23	; 0x0d
	
	/* Set motor to default startup value */
	SetDegrees( 0 );
	tmr3Ptr_->setDutyCycleComB( percent_ );
    10aa:	85 d1       	rcall	.+778    	; 0x13b6 <_ZN6Timer516setDutyCycleComBEf>
	oldPercent_ = percent_;
    10ac:	8a 85       	ldd	r24, Y+10	; 0x0a
    10ae:	9b 85       	ldd	r25, Y+11	; 0x0b
    10b0:	ac 85       	ldd	r26, Y+12	; 0x0c
    10b2:	bd 85       	ldd	r27, Y+13	; 0x0d
    10b4:	8e 87       	std	Y+14, r24	; 0x0e
    10b6:	9f 87       	std	Y+15, r25	; 0x0f
    10b8:	a8 8b       	std	Y+16, r26	; 0x10
    10ba:	b9 8b       	std	Y+17, r27	; 0x11
}
    10bc:	df 91       	pop	r29
    10be:	cf 91       	pop	r28
    10c0:	08 95       	ret

000010c2 <_ZN2M6D1Ev>:

class Motor
{
//functions
public:
	virtual ~Motor() {};
    10c2:	27 e7       	ldi	r18, 0x77	; 119
    10c4:	32 e0       	ldi	r19, 0x02	; 2
    10c6:	fc 01       	movw	r30, r24
    10c8:	31 83       	std	Z+1, r19	; 0x01
    10ca:	20 83       	st	Z, r18
    10cc:	08 95       	ret

000010ce <_ZN2M6D0Ev>:
	SetDegrees( 0 );
	tmr3Ptr_->setDutyCycleComC( percent_ );
	oldPercent_ = percent_;
}

M6::~M6()
    10ce:	cf 93       	push	r28
    10d0:	df 93       	push	r29
    10d2:	ec 01       	movw	r28, r24
{
}
    10d4:	f6 df       	rcall	.-20     	; 0x10c2 <_ZN2M6D1Ev>
    10d6:	ce 01       	movw	r24, r28
    10d8:	1c db       	rcall	.-2504   	; 0x712 <_ZdlPv>
    10da:	df 91       	pop	r29
    10dc:	cf 91       	pop	r28
    10de:	08 95       	ret

000010e0 <_ZN2M69TurnMotorEv>:

void M6::TurnMotor()
{
    10e0:	4f 92       	push	r4
    10e2:	5f 92       	push	r5
    10e4:	6f 92       	push	r6
    10e6:	7f 92       	push	r7
    10e8:	8f 92       	push	r8
    10ea:	9f 92       	push	r9
    10ec:	af 92       	push	r10
    10ee:	bf 92       	push	r11
    10f0:	cf 92       	push	r12
    10f2:	df 92       	push	r13
    10f4:	ef 92       	push	r14
    10f6:	ff 92       	push	r15
    10f8:	cf 93       	push	r28
    10fa:	df 93       	push	r29
    10fc:	ec 01       	movw	r28, r24
	if ( percent_ > oldPercent_ + PERCENT_PR_TICK )
    10fe:	8a 84       	ldd	r8, Y+10	; 0x0a
    1100:	9b 84       	ldd	r9, Y+11	; 0x0b
    1102:	ac 84       	ldd	r10, Y+12	; 0x0c
    1104:	bd 84       	ldd	r11, Y+13	; 0x0d
    1106:	ce 84       	ldd	r12, Y+14	; 0x0e
    1108:	df 84       	ldd	r13, Y+15	; 0x0f
    110a:	e8 88       	ldd	r14, Y+16	; 0x10
    110c:	f9 88       	ldd	r15, Y+17	; 0x11
    110e:	20 e0       	ldi	r18, 0x00	; 0
    1110:	30 e0       	ldi	r19, 0x00	; 0
    1112:	40 e8       	ldi	r20, 0x80	; 128
    1114:	5d e3       	ldi	r21, 0x3D	; 61
    1116:	c7 01       	movw	r24, r14
    1118:	b6 01       	movw	r22, r12
    111a:	4e d7       	rcall	.+3740   	; 0x1fb8 <__addsf3>
    111c:	2b 01       	movw	r4, r22
    111e:	3c 01       	movw	r6, r24
    1120:	9b 01       	movw	r18, r22
    1122:	ac 01       	movw	r20, r24
    1124:	c5 01       	movw	r24, r10
    1126:	b4 01       	movw	r22, r8
    1128:	0e 94 22 11 	call	0x2244	; 0x2244 <__gesf2>
    112c:	18 16       	cp	r1, r24
    112e:	6c f4       	brge	.+26     	; 0x114a <_ZN2M69TurnMotorEv+0x6a>
	{
		oldPercent_ += 0.0625;
    1130:	4e 86       	std	Y+14, r4	; 0x0e
    1132:	5f 86       	std	Y+15, r5	; 0x0f
    1134:	68 8a       	std	Y+16, r6	; 0x10
    1136:	79 8a       	std	Y+17, r7	; 0x11
		tmr3Ptr_->setDutyCycleComC( oldPercent_ );
    1138:	b3 01       	movw	r22, r6
    113a:	a2 01       	movw	r20, r4
    113c:	8c 81       	ldd	r24, Y+4	; 0x04
    113e:	9d 81       	ldd	r25, Y+5	; 0x05
    1140:	61 d1       	rcall	.+706    	; 0x1404 <_ZN6Timer516setDutyCycleComCEf>
		vTaskDelay( delay_ / portTICK_RATE_MS );
    1142:	8f 89       	ldd	r24, Y+23	; 0x17
    1144:	98 8d       	ldd	r25, Y+24	; 0x18
    1146:	5a d6       	rcall	.+3252   	; 0x1dfc <vTaskDelay>
    1148:	1a c0       	rjmp	.+52     	; 0x117e <_ZN2M69TurnMotorEv+0x9e>
	}
	else if ( percent_ < oldPercent_ )
    114a:	a7 01       	movw	r20, r14
    114c:	96 01       	movw	r18, r12
    114e:	c5 01       	movw	r24, r10
    1150:	b4 01       	movw	r22, r8
    1152:	96 d7       	rcall	.+3884   	; 0x2080 <__cmpsf2>
    1154:	88 23       	and	r24, r24
    1156:	9c f4       	brge	.+38     	; 0x117e <_ZN2M69TurnMotorEv+0x9e>
	{
		oldPercent_ -= 0.0625;
    1158:	20 e0       	ldi	r18, 0x00	; 0
    115a:	30 e0       	ldi	r19, 0x00	; 0
    115c:	40 e8       	ldi	r20, 0x80	; 128
    115e:	5d e3       	ldi	r21, 0x3D	; 61
    1160:	c7 01       	movw	r24, r14
    1162:	b6 01       	movw	r22, r12
    1164:	28 d7       	rcall	.+3664   	; 0x1fb6 <__subsf3>
    1166:	ab 01       	movw	r20, r22
    1168:	bc 01       	movw	r22, r24
    116a:	4e 87       	std	Y+14, r20	; 0x0e
    116c:	5f 87       	std	Y+15, r21	; 0x0f
    116e:	68 8b       	std	Y+16, r22	; 0x10
		tmr3Ptr_->setDutyCycleComC( oldPercent_ );
    1170:	79 8b       	std	Y+17, r23	; 0x11
    1172:	8c 81       	ldd	r24, Y+4	; 0x04
    1174:	9d 81       	ldd	r25, Y+5	; 0x05
		vTaskDelay( delay_ / portTICK_RATE_MS );
    1176:	46 d1       	rcall	.+652    	; 0x1404 <_ZN6Timer516setDutyCycleComCEf>
    1178:	8f 89       	ldd	r24, Y+23	; 0x17
    117a:	98 8d       	ldd	r25, Y+24	; 0x18
    117c:	3f d6       	rcall	.+3198   	; 0x1dfc <vTaskDelay>
	}
}
    117e:	df 91       	pop	r29
    1180:	cf 91       	pop	r28
    1182:	ff 90       	pop	r15
    1184:	ef 90       	pop	r14
    1186:	df 90       	pop	r13
    1188:	cf 90       	pop	r12
    118a:	bf 90       	pop	r11
    118c:	af 90       	pop	r10
    118e:	9f 90       	pop	r9
    1190:	8f 90       	pop	r8
    1192:	7f 90       	pop	r7
    1194:	6f 90       	pop	r6
    1196:	5f 90       	pop	r5
    1198:	4f 90       	pop	r4
    119a:	08 95       	ret

0000119c <_ZN2M6C1EP6Timer5>:
* Author: jespe
*/

#include "M6.h"

M6::M6( Timer5* tmr )
    119c:	cf 93       	push	r28
    119e:	df 93       	push	r29
    11a0:	ec 01       	movw	r28, r24
    11a2:	cb 01       	movw	r24, r22
    11a4:	2f eb       	ldi	r18, 0xBF	; 191
    11a6:	32 e0       	ldi	r19, 0x02	; 2
    11a8:	39 83       	std	Y+1, r19	; 0x01
    11aa:	28 83       	st	Y, r18
{
	/* Store timer pointer */
	tmr3Ptr_ = tmr;
    11ac:	7d 83       	std	Y+5, r23	; 0x05
    11ae:	6c 83       	std	Y+4, r22	; 0x04
	
	/* This value is number of percent to add or subtract pr degree. */
	percentPrDeg = 0.07936507936507;
    11b0:	49 e2       	ldi	r20, 0x29	; 41
    11b2:	5a e8       	ldi	r21, 0x8A	; 138
    11b4:	62 ea       	ldi	r22, 0xA2	; 162
    11b6:	7d e3       	ldi	r23, 0x3D	; 61
    11b8:	4e 83       	std	Y+6, r20	; 0x06
    11ba:	5f 83       	std	Y+7, r21	; 0x07
    11bc:	68 87       	std	Y+8, r22	; 0x08
    11be:	79 87       	std	Y+9, r23	; 0x09
	
	/* This value is the lowest duty cycle percentage needed to make motor turn. */
	startpercent_ = 2.5;
    11c0:	40 e0       	ldi	r20, 0x00	; 0
    11c2:	50 e0       	ldi	r21, 0x00	; 0
    11c4:	60 e2       	ldi	r22, 0x20	; 32
    11c6:	70 e4       	ldi	r23, 0x40	; 64
    11c8:	4a 8b       	std	Y+18, r20	; 0x12
    11ca:	5b 8b       	std	Y+19, r21	; 0x13
    11cc:	6c 8b       	std	Y+20, r22	; 0x14
    11ce:	7d 8b       	std	Y+21, r23	; 0x15
	
	/* This value is the delay on motor. A lower value makes motors go faster and higher value makes motors go slower. Value is in MS */
	delay_ = 1;
    11d0:	21 e0       	ldi	r18, 0x01	; 1
    11d2:	30 e0       	ldi	r19, 0x00	; 0
    11d4:	38 8f       	std	Y+24, r19	; 0x18
    11d6:	2f 8b       	std	Y+23, r18	; 0x17
	
	/* This value is the maximum number of degrees the motor can turn */
	maxDegrees_ = 63;
    11d8:	2f e3       	ldi	r18, 0x3F	; 63
    11da:	2e 8b       	std	Y+22, r18	; 0x16
	*/
	virtual void SetDegrees( uint8_t degrees )
	{
		if ( maxDegrees_ >= degrees )
		{
			percent_ = percentPrDeg * degrees + startpercent_;
    11dc:	4a 87       	std	Y+10, r20	; 0x0a
    11de:	5b 87       	std	Y+11, r21	; 0x0b
    11e0:	6c 87       	std	Y+12, r22	; 0x0c
    11e2:	7d 87       	std	Y+13, r23	; 0x0d
	
	/* Set motor to default startup value */
	SetDegrees( 0 );
	tmr3Ptr_->setDutyCycleComC( percent_ );
    11e4:	0f d1       	rcall	.+542    	; 0x1404 <_ZN6Timer516setDutyCycleComCEf>
	oldPercent_ = percent_;
    11e6:	8a 85       	ldd	r24, Y+10	; 0x0a
    11e8:	9b 85       	ldd	r25, Y+11	; 0x0b
    11ea:	ac 85       	ldd	r26, Y+12	; 0x0c
    11ec:	bd 85       	ldd	r27, Y+13	; 0x0d
    11ee:	8e 87       	std	Y+14, r24	; 0x0e
    11f0:	9f 87       	std	Y+15, r25	; 0x0f
    11f2:	a8 8b       	std	Y+16, r26	; 0x10
    11f4:	b9 8b       	std	Y+17, r27	; 0x11
}
    11f6:	df 91       	pop	r29
    11f8:	cf 91       	pop	r28
    11fa:	08 95       	ret

000011fc <_ZN6Timer1C1Ev>:
#include <avr/io.h>

Timer1::Timer1()
{
	// Set B5 to output
	DDRB = DDRB | ( 1 << 5 ) | ( 1 << 6 ) | ( 1 << 7 );
    11fc:	84 b1       	in	r24, 0x04	; 4
    11fe:	80 6e       	ori	r24, 0xE0	; 224
    1200:	84 b9       	out	0x04, r24	; 4
	
	// Set timer to run in PWM, Phase Correct mode with 50 Hz freq. 
	TCCR1A = ( 1 << COM1A1 ) | ( 1 << COM1B1 ) | ( 1 << COM1C1 ) | ( 0 << WGM10 ) | ( 0 << WGM11 );
    1202:	88 ea       	ldi	r24, 0xA8	; 168
    1204:	80 93 80 00 	sts	0x0080, r24	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
	TCCR1B = ( 1 << WGM13 ) | ( 0 << CS10 )  | ( 1 << CS12 );
    1208:	84 e1       	ldi	r24, 0x14	; 20
    120a:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x700081>
	TCCR1C = 0;
    120e:	10 92 82 00 	sts	0x0082, r1	; 0x800082 <__TEXT_REGION_LENGTH__+0x700082>
	ICR1 = 622;
    1212:	8e e6       	ldi	r24, 0x6E	; 110
    1214:	92 e0       	ldi	r25, 0x02	; 2
    1216:	90 93 87 00 	sts	0x0087, r25	; 0x800087 <__TEXT_REGION_LENGTH__+0x700087>
    121a:	80 93 86 00 	sts	0x0086, r24	; 0x800086 <__TEXT_REGION_LENGTH__+0x700086>
	
	OCR1A = 0;
    121e:	10 92 89 00 	sts	0x0089, r1	; 0x800089 <__TEXT_REGION_LENGTH__+0x700089>
    1222:	10 92 88 00 	sts	0x0088, r1	; 0x800088 <__TEXT_REGION_LENGTH__+0x700088>
	OCR1B = 0;
    1226:	10 92 8b 00 	sts	0x008B, r1	; 0x80008b <__TEXT_REGION_LENGTH__+0x70008b>
    122a:	10 92 8a 00 	sts	0x008A, r1	; 0x80008a <__TEXT_REGION_LENGTH__+0x70008a>
	OCR1C = 0;
    122e:	10 92 8d 00 	sts	0x008D, r1	; 0x80008d <__TEXT_REGION_LENGTH__+0x70008d>
    1232:	10 92 8c 00 	sts	0x008C, r1	; 0x80008c <__TEXT_REGION_LENGTH__+0x70008c>
    1236:	08 95       	ret

00001238 <_ZN6Timer116setDutyCycleComAEf>:
}

void Timer1::setDutyCycleComA( float dutyCycle )
{
    1238:	cf 92       	push	r12
    123a:	df 92       	push	r13
    123c:	ef 92       	push	r14
    123e:	ff 92       	push	r15
    1240:	6a 01       	movw	r12, r20
    1242:	7b 01       	movw	r14, r22
	float percent = ICR1/100;
    1244:	20 91 86 00 	lds	r18, 0x0086	; 0x800086 <__TEXT_REGION_LENGTH__+0x700086>
    1248:	30 91 87 00 	lds	r19, 0x0087	; 0x800087 <__TEXT_REGION_LENGTH__+0x700087>
    124c:	36 95       	lsr	r19
    124e:	27 95       	ror	r18
    1250:	36 95       	lsr	r19
    1252:	27 95       	ror	r18
    1254:	ab e7       	ldi	r26, 0x7B	; 123
    1256:	b4 e1       	ldi	r27, 0x14	; 20
    1258:	0e 94 ab 11 	call	0x2356	; 0x2356 <__umulhisi3>
    125c:	96 95       	lsr	r25
    125e:	87 95       	ror	r24
	OCR1A = (uint8_t)percent*dutyCycle;
    1260:	bc 01       	movw	r22, r24
    1262:	77 27       	eor	r23, r23
    1264:	07 2e       	mov	r0, r23
    1266:	00 0c       	add	r0, r0
    1268:	88 0b       	sbc	r24, r24
    126a:	99 0b       	sbc	r25, r25
    126c:	3b d7       	rcall	.+3702   	; 0x20e4 <__floatsisf>
    126e:	a7 01       	movw	r20, r14
    1270:	96 01       	movw	r18, r12
    1272:	ec d7       	rcall	.+4056   	; 0x224c <__mulsf3>
    1274:	09 d7       	rcall	.+3602   	; 0x2088 <__fixunssfsi>
    1276:	70 93 89 00 	sts	0x0089, r23	; 0x800089 <__TEXT_REGION_LENGTH__+0x700089>
    127a:	60 93 88 00 	sts	0x0088, r22	; 0x800088 <__TEXT_REGION_LENGTH__+0x700088>
}
    127e:	ff 90       	pop	r15
    1280:	ef 90       	pop	r14
    1282:	df 90       	pop	r13
    1284:	cf 90       	pop	r12
    1286:	08 95       	ret

00001288 <_ZN6Timer116setDutyCycleComBEf>:

void Timer1::setDutyCycleComB( float dutyCycle )
{
    1288:	cf 92       	push	r12
    128a:	df 92       	push	r13
    128c:	ef 92       	push	r14
    128e:	ff 92       	push	r15
    1290:	6a 01       	movw	r12, r20
    1292:	7b 01       	movw	r14, r22
	float percent = ICR1/100;
    1294:	20 91 86 00 	lds	r18, 0x0086	; 0x800086 <__TEXT_REGION_LENGTH__+0x700086>
    1298:	30 91 87 00 	lds	r19, 0x0087	; 0x800087 <__TEXT_REGION_LENGTH__+0x700087>
    129c:	36 95       	lsr	r19
    129e:	27 95       	ror	r18
    12a0:	36 95       	lsr	r19
    12a2:	27 95       	ror	r18
    12a4:	ab e7       	ldi	r26, 0x7B	; 123
    12a6:	b4 e1       	ldi	r27, 0x14	; 20
    12a8:	0e 94 ab 11 	call	0x2356	; 0x2356 <__umulhisi3>
    12ac:	96 95       	lsr	r25
    12ae:	87 95       	ror	r24
	OCR1B = (uint8_t)percent*dutyCycle;
    12b0:	bc 01       	movw	r22, r24
    12b2:	77 27       	eor	r23, r23
    12b4:	07 2e       	mov	r0, r23
    12b6:	00 0c       	add	r0, r0
    12b8:	88 0b       	sbc	r24, r24
    12ba:	99 0b       	sbc	r25, r25
    12bc:	13 d7       	rcall	.+3622   	; 0x20e4 <__floatsisf>
    12be:	a7 01       	movw	r20, r14
    12c0:	96 01       	movw	r18, r12
    12c2:	c4 d7       	rcall	.+3976   	; 0x224c <__mulsf3>
    12c4:	e1 d6       	rcall	.+3522   	; 0x2088 <__fixunssfsi>
    12c6:	70 93 8b 00 	sts	0x008B, r23	; 0x80008b <__TEXT_REGION_LENGTH__+0x70008b>
    12ca:	60 93 8a 00 	sts	0x008A, r22	; 0x80008a <__TEXT_REGION_LENGTH__+0x70008a>
}
    12ce:	ff 90       	pop	r15
    12d0:	ef 90       	pop	r14
    12d2:	df 90       	pop	r13
    12d4:	cf 90       	pop	r12
    12d6:	08 95       	ret

000012d8 <_ZN6Timer116setDutyCycleComCEf>:

void Timer1::setDutyCycleComC( float dutyCycle )
{
    12d8:	cf 92       	push	r12
    12da:	df 92       	push	r13
    12dc:	ef 92       	push	r14
    12de:	ff 92       	push	r15
    12e0:	6a 01       	movw	r12, r20
    12e2:	7b 01       	movw	r14, r22
	float percent = ICR1/100;
    12e4:	20 91 86 00 	lds	r18, 0x0086	; 0x800086 <__TEXT_REGION_LENGTH__+0x700086>
    12e8:	30 91 87 00 	lds	r19, 0x0087	; 0x800087 <__TEXT_REGION_LENGTH__+0x700087>
    12ec:	36 95       	lsr	r19
    12ee:	27 95       	ror	r18
    12f0:	36 95       	lsr	r19
    12f2:	27 95       	ror	r18
    12f4:	ab e7       	ldi	r26, 0x7B	; 123
    12f6:	b4 e1       	ldi	r27, 0x14	; 20
    12f8:	0e 94 ab 11 	call	0x2356	; 0x2356 <__umulhisi3>
    12fc:	96 95       	lsr	r25
    12fe:	87 95       	ror	r24
	OCR1C = (uint8_t)percent*dutyCycle;
    1300:	bc 01       	movw	r22, r24
    1302:	77 27       	eor	r23, r23
    1304:	07 2e       	mov	r0, r23
    1306:	00 0c       	add	r0, r0
    1308:	88 0b       	sbc	r24, r24
    130a:	99 0b       	sbc	r25, r25
    130c:	eb d6       	rcall	.+3542   	; 0x20e4 <__floatsisf>
    130e:	a7 01       	movw	r20, r14
    1310:	96 01       	movw	r18, r12
    1312:	9c d7       	rcall	.+3896   	; 0x224c <__mulsf3>
    1314:	b9 d6       	rcall	.+3442   	; 0x2088 <__fixunssfsi>
    1316:	70 93 8d 00 	sts	0x008D, r23	; 0x80008d <__TEXT_REGION_LENGTH__+0x70008d>
    131a:	60 93 8c 00 	sts	0x008C, r22	; 0x80008c <__TEXT_REGION_LENGTH__+0x70008c>
    131e:	ff 90       	pop	r15
    1320:	ef 90       	pop	r14
    1322:	df 90       	pop	r13
    1324:	cf 90       	pop	r12
    1326:	08 95       	ret

00001328 <_ZN6Timer5C1Ev>:
#include <avr/io.h>

Timer5::Timer5()
{
	// Set B5 to output
	DDRL = DDRL | ( 1 << 3 ) | ( 1 << 4 ) | ( 1 << 5 );
    1328:	ea e0       	ldi	r30, 0x0A	; 10
    132a:	f1 e0       	ldi	r31, 0x01	; 1
    132c:	80 81       	ld	r24, Z
    132e:	88 63       	ori	r24, 0x38	; 56
    1330:	80 83       	st	Z, r24
	
	// Set timer to run in PWM, Phase Correct mode with 50 Hz freq.
	TCCR5A = ( 1 << COM3A1 ) | ( 1 << COM3B1 ) | ( 1 << COM3C1 ) | ( 0 << WGM30 ) | ( 0 << WGM31 );
    1332:	88 ea       	ldi	r24, 0xA8	; 168
    1334:	80 93 20 01 	sts	0x0120, r24	; 0x800120 <__TEXT_REGION_LENGTH__+0x700120>
	TCCR5B = ( 1 << WGM33 ) | ( 0 << CS30 )  | ( 1 << CS32 );
    1338:	84 e1       	ldi	r24, 0x14	; 20
    133a:	80 93 21 01 	sts	0x0121, r24	; 0x800121 <__TEXT_REGION_LENGTH__+0x700121>
	TCCR5C = 0;
    133e:	10 92 22 01 	sts	0x0122, r1	; 0x800122 <__TEXT_REGION_LENGTH__+0x700122>
	ICR5 = 622;
    1342:	8e e6       	ldi	r24, 0x6E	; 110
    1344:	92 e0       	ldi	r25, 0x02	; 2
    1346:	90 93 27 01 	sts	0x0127, r25	; 0x800127 <__TEXT_REGION_LENGTH__+0x700127>
    134a:	80 93 26 01 	sts	0x0126, r24	; 0x800126 <__TEXT_REGION_LENGTH__+0x700126>
	
	OCR5A = 0;
    134e:	10 92 29 01 	sts	0x0129, r1	; 0x800129 <__TEXT_REGION_LENGTH__+0x700129>
    1352:	10 92 28 01 	sts	0x0128, r1	; 0x800128 <__TEXT_REGION_LENGTH__+0x700128>
	OCR5B = 0;
    1356:	10 92 2b 01 	sts	0x012B, r1	; 0x80012b <__TEXT_REGION_LENGTH__+0x70012b>
    135a:	10 92 2a 01 	sts	0x012A, r1	; 0x80012a <__TEXT_REGION_LENGTH__+0x70012a>
	OCR5C = 0;
    135e:	10 92 2d 01 	sts	0x012D, r1	; 0x80012d <__TEXT_REGION_LENGTH__+0x70012d>
    1362:	10 92 2c 01 	sts	0x012C, r1	; 0x80012c <__TEXT_REGION_LENGTH__+0x70012c>
    1366:	08 95       	ret

00001368 <_ZN6Timer516setDutyCycleComAEf>:
}

void Timer5::setDutyCycleComA( float dutyCycle )
{
    1368:	cf 92       	push	r12
    136a:	df 92       	push	r13
    136c:	ef 92       	push	r14
    136e:	ff 92       	push	r15
    1370:	6a 01       	movw	r12, r20
    1372:	7b 01       	movw	r14, r22
	float percent = ICR5/100;
    1374:	20 91 26 01 	lds	r18, 0x0126	; 0x800126 <__TEXT_REGION_LENGTH__+0x700126>
    1378:	30 91 27 01 	lds	r19, 0x0127	; 0x800127 <__TEXT_REGION_LENGTH__+0x700127>
    137c:	36 95       	lsr	r19
    137e:	27 95       	ror	r18
    1380:	36 95       	lsr	r19
    1382:	27 95       	ror	r18
    1384:	ab e7       	ldi	r26, 0x7B	; 123
    1386:	b4 e1       	ldi	r27, 0x14	; 20
    1388:	e6 d7       	rcall	.+4044   	; 0x2356 <__umulhisi3>
    138a:	96 95       	lsr	r25
    138c:	87 95       	ror	r24
	OCR5A = (uint8_t)percent*dutyCycle;
    138e:	bc 01       	movw	r22, r24
    1390:	77 27       	eor	r23, r23
    1392:	07 2e       	mov	r0, r23
    1394:	00 0c       	add	r0, r0
    1396:	88 0b       	sbc	r24, r24
    1398:	99 0b       	sbc	r25, r25
    139a:	a4 d6       	rcall	.+3400   	; 0x20e4 <__floatsisf>
    139c:	a7 01       	movw	r20, r14
    139e:	96 01       	movw	r18, r12
    13a0:	55 d7       	rcall	.+3754   	; 0x224c <__mulsf3>
    13a2:	72 d6       	rcall	.+3300   	; 0x2088 <__fixunssfsi>
    13a4:	70 93 29 01 	sts	0x0129, r23	; 0x800129 <__TEXT_REGION_LENGTH__+0x700129>
    13a8:	60 93 28 01 	sts	0x0128, r22	; 0x800128 <__TEXT_REGION_LENGTH__+0x700128>
}
    13ac:	ff 90       	pop	r15
    13ae:	ef 90       	pop	r14
    13b0:	df 90       	pop	r13
    13b2:	cf 90       	pop	r12
    13b4:	08 95       	ret

000013b6 <_ZN6Timer516setDutyCycleComBEf>:

void Timer5::setDutyCycleComB( float dutyCycle )
{
    13b6:	cf 92       	push	r12
    13b8:	df 92       	push	r13
    13ba:	ef 92       	push	r14
    13bc:	ff 92       	push	r15
    13be:	6a 01       	movw	r12, r20
    13c0:	7b 01       	movw	r14, r22
	float percent = ICR5/100;
    13c2:	20 91 26 01 	lds	r18, 0x0126	; 0x800126 <__TEXT_REGION_LENGTH__+0x700126>
    13c6:	30 91 27 01 	lds	r19, 0x0127	; 0x800127 <__TEXT_REGION_LENGTH__+0x700127>
    13ca:	36 95       	lsr	r19
    13cc:	27 95       	ror	r18
    13ce:	36 95       	lsr	r19
    13d0:	27 95       	ror	r18
    13d2:	ab e7       	ldi	r26, 0x7B	; 123
    13d4:	b4 e1       	ldi	r27, 0x14	; 20
    13d6:	bf d7       	rcall	.+3966   	; 0x2356 <__umulhisi3>
    13d8:	96 95       	lsr	r25
    13da:	87 95       	ror	r24
	OCR5B = (uint8_t)percent*dutyCycle;
    13dc:	bc 01       	movw	r22, r24
    13de:	77 27       	eor	r23, r23
    13e0:	07 2e       	mov	r0, r23
    13e2:	00 0c       	add	r0, r0
    13e4:	88 0b       	sbc	r24, r24
    13e6:	99 0b       	sbc	r25, r25
    13e8:	7d d6       	rcall	.+3322   	; 0x20e4 <__floatsisf>
    13ea:	a7 01       	movw	r20, r14
    13ec:	96 01       	movw	r18, r12
    13ee:	2e d7       	rcall	.+3676   	; 0x224c <__mulsf3>
    13f0:	4b d6       	rcall	.+3222   	; 0x2088 <__fixunssfsi>
    13f2:	70 93 2b 01 	sts	0x012B, r23	; 0x80012b <__TEXT_REGION_LENGTH__+0x70012b>
    13f6:	60 93 2a 01 	sts	0x012A, r22	; 0x80012a <__TEXT_REGION_LENGTH__+0x70012a>
}
    13fa:	ff 90       	pop	r15
    13fc:	ef 90       	pop	r14
    13fe:	df 90       	pop	r13
    1400:	cf 90       	pop	r12
    1402:	08 95       	ret

00001404 <_ZN6Timer516setDutyCycleComCEf>:

void Timer5::setDutyCycleComC( float dutyCycle )
{
    1404:	cf 92       	push	r12
    1406:	df 92       	push	r13
    1408:	ef 92       	push	r14
    140a:	ff 92       	push	r15
    140c:	6a 01       	movw	r12, r20
    140e:	7b 01       	movw	r14, r22
	float percent = ICR5/100;
    1410:	20 91 26 01 	lds	r18, 0x0126	; 0x800126 <__TEXT_REGION_LENGTH__+0x700126>
    1414:	30 91 27 01 	lds	r19, 0x0127	; 0x800127 <__TEXT_REGION_LENGTH__+0x700127>
    1418:	36 95       	lsr	r19
    141a:	27 95       	ror	r18
    141c:	36 95       	lsr	r19
    141e:	27 95       	ror	r18
    1420:	ab e7       	ldi	r26, 0x7B	; 123
    1422:	b4 e1       	ldi	r27, 0x14	; 20
    1424:	98 d7       	rcall	.+3888   	; 0x2356 <__umulhisi3>
    1426:	96 95       	lsr	r25
    1428:	87 95       	ror	r24
	OCR5C = (uint8_t)percent*dutyCycle;
    142a:	bc 01       	movw	r22, r24
    142c:	77 27       	eor	r23, r23
    142e:	07 2e       	mov	r0, r23
    1430:	00 0c       	add	r0, r0
    1432:	88 0b       	sbc	r24, r24
    1434:	99 0b       	sbc	r25, r25
    1436:	56 d6       	rcall	.+3244   	; 0x20e4 <__floatsisf>
    1438:	a7 01       	movw	r20, r14
    143a:	96 01       	movw	r18, r12
    143c:	07 d7       	rcall	.+3598   	; 0x224c <__mulsf3>
    143e:	24 d6       	rcall	.+3144   	; 0x2088 <__fixunssfsi>
    1440:	70 93 2d 01 	sts	0x012D, r23	; 0x80012d <__TEXT_REGION_LENGTH__+0x70012d>
    1444:	60 93 2c 01 	sts	0x012C, r22	; 0x80012c <__TEXT_REGION_LENGTH__+0x70012c>
    1448:	ff 90       	pop	r15
    144a:	ef 90       	pop	r14
    144c:	df 90       	pop	r13
    144e:	cf 90       	pop	r12
    1450:	08 95       	ret

00001452 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
    1452:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
    1454:	03 96       	adiw	r24, 0x03	; 3
    1456:	92 83       	std	Z+2, r25	; 0x02
    1458:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    145a:	2f ef       	ldi	r18, 0xFF	; 255
    145c:	3f ef       	ldi	r19, 0xFF	; 255
    145e:	34 83       	std	Z+4, r19	; 0x04
    1460:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
    1462:	96 83       	std	Z+6, r25	; 0x06
    1464:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
    1466:	90 87       	std	Z+8, r25	; 0x08
    1468:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
    146a:	10 82       	st	Z, r1
    146c:	08 95       	ret

0000146e <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    146e:	fc 01       	movw	r30, r24
    1470:	11 86       	std	Z+9, r1	; 0x09
    1472:	10 86       	std	Z+8, r1	; 0x08
    1474:	08 95       	ret

00001476 <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
    1476:	cf 93       	push	r28
    1478:	df 93       	push	r29
    147a:	fc 01       	movw	r30, r24
    147c:	db 01       	movw	r26, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
    147e:	21 81       	ldd	r18, Z+1	; 0x01
    1480:	32 81       	ldd	r19, Z+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
    1482:	e9 01       	movw	r28, r18
    1484:	8a 81       	ldd	r24, Y+2	; 0x02
    1486:	9b 81       	ldd	r25, Y+3	; 0x03
    1488:	13 96       	adiw	r26, 0x03	; 3
    148a:	9c 93       	st	X, r25
    148c:	8e 93       	st	-X, r24
    148e:	12 97       	sbiw	r26, 0x02	; 2
	pxNewListItem->pxPrevious = pxList->pxIndex;
    1490:	81 81       	ldd	r24, Z+1	; 0x01
    1492:	92 81       	ldd	r25, Z+2	; 0x02
    1494:	15 96       	adiw	r26, 0x05	; 5
    1496:	9c 93       	st	X, r25
    1498:	8e 93       	st	-X, r24
    149a:	14 97       	sbiw	r26, 0x04	; 4
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    149c:	8a 81       	ldd	r24, Y+2	; 0x02
    149e:	9b 81       	ldd	r25, Y+3	; 0x03
    14a0:	ec 01       	movw	r28, r24
    14a2:	7d 83       	std	Y+5, r23	; 0x05
    14a4:	6c 83       	std	Y+4, r22	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
    14a6:	e9 01       	movw	r28, r18
    14a8:	7b 83       	std	Y+3, r23	; 0x03
    14aa:	6a 83       	std	Y+2, r22	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
    14ac:	72 83       	std	Z+2, r23	; 0x02
    14ae:	61 83       	std	Z+1, r22	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    14b0:	19 96       	adiw	r26, 0x09	; 9
    14b2:	fc 93       	st	X, r31
    14b4:	ee 93       	st	-X, r30
    14b6:	18 97       	sbiw	r26, 0x08	; 8

	( pxList->uxNumberOfItems )++;
    14b8:	80 81       	ld	r24, Z
    14ba:	8f 5f       	subi	r24, 0xFF	; 255
    14bc:	80 83       	st	Z, r24
}
    14be:	df 91       	pop	r29
    14c0:	cf 91       	pop	r28
    14c2:	08 95       	ret

000014c4 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
    14c4:	cf 93       	push	r28
    14c6:	df 93       	push	r29
    14c8:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
    14ca:	48 81       	ld	r20, Y
    14cc:	59 81       	ldd	r21, Y+1	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    14ce:	4f 3f       	cpi	r20, 0xFF	; 255
    14d0:	2f ef       	ldi	r18, 0xFF	; 255
    14d2:	52 07       	cpc	r21, r18
    14d4:	31 f4       	brne	.+12     	; 0x14e2 <vListInsert+0x1e>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    14d6:	dc 01       	movw	r26, r24
    14d8:	17 96       	adiw	r26, 0x07	; 7
    14da:	ed 91       	ld	r30, X+
    14dc:	fc 91       	ld	r31, X
    14de:	18 97       	sbiw	r26, 0x08	; 8
    14e0:	0d c0       	rjmp	.+26     	; 0x14fc <vListInsert+0x38>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    14e2:	fc 01       	movw	r30, r24
    14e4:	33 96       	adiw	r30, 0x03	; 3
    14e6:	03 c0       	rjmp	.+6      	; 0x14ee <vListInsert+0x2a>
    14e8:	02 80       	ldd	r0, Z+2	; 0x02
    14ea:	f3 81       	ldd	r31, Z+3	; 0x03
    14ec:	e0 2d       	mov	r30, r0
    14ee:	a2 81       	ldd	r26, Z+2	; 0x02
    14f0:	b3 81       	ldd	r27, Z+3	; 0x03
    14f2:	2d 91       	ld	r18, X+
    14f4:	3c 91       	ld	r19, X
    14f6:	42 17       	cp	r20, r18
    14f8:	53 07       	cpc	r21, r19
    14fa:	b0 f7       	brcc	.-20     	; 0x14e8 <vListInsert+0x24>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    14fc:	a2 81       	ldd	r26, Z+2	; 0x02
    14fe:	b3 81       	ldd	r27, Z+3	; 0x03
    1500:	bb 83       	std	Y+3, r27	; 0x03
    1502:	aa 83       	std	Y+2, r26	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    1504:	15 96       	adiw	r26, 0x05	; 5
    1506:	dc 93       	st	X, r29
    1508:	ce 93       	st	-X, r28
    150a:	14 97       	sbiw	r26, 0x04	; 4
	pxNewListItem->pxPrevious = pxIterator;
    150c:	fd 83       	std	Y+5, r31	; 0x05
    150e:	ec 83       	std	Y+4, r30	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    1510:	d3 83       	std	Z+3, r29	; 0x03
    1512:	c2 83       	std	Z+2, r28	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1514:	99 87       	std	Y+9, r25	; 0x09
    1516:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    1518:	fc 01       	movw	r30, r24
    151a:	20 81       	ld	r18, Z
    151c:	2f 5f       	subi	r18, 0xFF	; 255
    151e:	20 83       	st	Z, r18
}
    1520:	df 91       	pop	r29
    1522:	cf 91       	pop	r28
    1524:	08 95       	ret

00001526 <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
    1526:	fc 01       	movw	r30, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    1528:	a2 81       	ldd	r26, Z+2	; 0x02
    152a:	b3 81       	ldd	r27, Z+3	; 0x03
    152c:	84 81       	ldd	r24, Z+4	; 0x04
    152e:	95 81       	ldd	r25, Z+5	; 0x05
    1530:	15 96       	adiw	r26, 0x05	; 5
    1532:	9c 93       	st	X, r25
    1534:	8e 93       	st	-X, r24
    1536:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    1538:	a4 81       	ldd	r26, Z+4	; 0x04
    153a:	b5 81       	ldd	r27, Z+5	; 0x05
    153c:	82 81       	ldd	r24, Z+2	; 0x02
    153e:	93 81       	ldd	r25, Z+3	; 0x03
    1540:	13 96       	adiw	r26, 0x03	; 3
    1542:	9c 93       	st	X, r25
    1544:	8e 93       	st	-X, r24
    1546:	12 97       	sbiw	r26, 0x02	; 2
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    1548:	a0 85       	ldd	r26, Z+8	; 0x08
    154a:	b1 85       	ldd	r27, Z+9	; 0x09

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    154c:	11 96       	adiw	r26, 0x01	; 1
    154e:	8d 91       	ld	r24, X+
    1550:	9c 91       	ld	r25, X
    1552:	12 97       	sbiw	r26, 0x02	; 2
    1554:	e8 17       	cp	r30, r24
    1556:	f9 07       	cpc	r31, r25
    1558:	31 f4       	brne	.+12     	; 0x1566 <vListRemove+0x40>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    155a:	84 81       	ldd	r24, Z+4	; 0x04
    155c:	95 81       	ldd	r25, Z+5	; 0x05
    155e:	12 96       	adiw	r26, 0x02	; 2
    1560:	9c 93       	st	X, r25
    1562:	8e 93       	st	-X, r24
    1564:	11 97       	sbiw	r26, 0x01	; 1
	}

	pxItemToRemove->pvContainer = NULL;
    1566:	11 86       	std	Z+9, r1	; 0x09
    1568:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    156a:	8c 91       	ld	r24, X
    156c:	81 50       	subi	r24, 0x01	; 1
    156e:	8c 93       	st	X, r24
    1570:	08 95       	ret

00001572 <prvSetupTimerInterrupt>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    1572:	8a ef       	ldi	r24, 0xFA	; 250
    1574:	87 bd       	out	0x27, r24	; 39
    1576:	82 e0       	ldi	r24, 0x02	; 2
    1578:	84 bd       	out	0x24, r24	; 36
    157a:	93 e0       	ldi	r25, 0x03	; 3
    157c:	95 bd       	out	0x25, r25	; 37
    157e:	80 93 6e 00 	sts	0x006E, r24	; 0x80006e <__TEXT_REGION_LENGTH__+0x70006e>
    1582:	08 95       	ret

00001584 <pxPortInitialiseStack>:
    1584:	31 e1       	ldi	r19, 0x11	; 17
    1586:	fc 01       	movw	r30, r24
    1588:	30 83       	st	Z, r19
    158a:	31 97       	sbiw	r30, 0x01	; 1
    158c:	22 e2       	ldi	r18, 0x22	; 34
    158e:	20 83       	st	Z, r18
    1590:	31 97       	sbiw	r30, 0x01	; 1
    1592:	a3 e3       	ldi	r26, 0x33	; 51
    1594:	a0 83       	st	Z, r26
    1596:	31 97       	sbiw	r30, 0x01	; 1
    1598:	60 83       	st	Z, r22
    159a:	31 97       	sbiw	r30, 0x01	; 1
    159c:	70 83       	st	Z, r23
    159e:	31 97       	sbiw	r30, 0x01	; 1
    15a0:	10 82       	st	Z, r1
    15a2:	31 97       	sbiw	r30, 0x01	; 1
    15a4:	10 82       	st	Z, r1
    15a6:	31 97       	sbiw	r30, 0x01	; 1
    15a8:	60 e8       	ldi	r22, 0x80	; 128
    15aa:	60 83       	st	Z, r22
    15ac:	31 97       	sbiw	r30, 0x01	; 1
    15ae:	10 82       	st	Z, r1
    15b0:	31 97       	sbiw	r30, 0x01	; 1
    15b2:	10 82       	st	Z, r1
    15b4:	31 97       	sbiw	r30, 0x01	; 1
    15b6:	10 82       	st	Z, r1
    15b8:	31 97       	sbiw	r30, 0x01	; 1
    15ba:	62 e0       	ldi	r22, 0x02	; 2
    15bc:	60 83       	st	Z, r22
    15be:	31 97       	sbiw	r30, 0x01	; 1
    15c0:	63 e0       	ldi	r22, 0x03	; 3
    15c2:	60 83       	st	Z, r22
    15c4:	31 97       	sbiw	r30, 0x01	; 1
    15c6:	64 e0       	ldi	r22, 0x04	; 4
    15c8:	60 83       	st	Z, r22
    15ca:	31 97       	sbiw	r30, 0x01	; 1
    15cc:	65 e0       	ldi	r22, 0x05	; 5
    15ce:	60 83       	st	Z, r22
    15d0:	31 97       	sbiw	r30, 0x01	; 1
    15d2:	66 e0       	ldi	r22, 0x06	; 6
    15d4:	60 83       	st	Z, r22
    15d6:	31 97       	sbiw	r30, 0x01	; 1
    15d8:	67 e0       	ldi	r22, 0x07	; 7
    15da:	60 83       	st	Z, r22
    15dc:	31 97       	sbiw	r30, 0x01	; 1
    15de:	68 e0       	ldi	r22, 0x08	; 8
    15e0:	60 83       	st	Z, r22
    15e2:	31 97       	sbiw	r30, 0x01	; 1
    15e4:	69 e0       	ldi	r22, 0x09	; 9
    15e6:	60 83       	st	Z, r22
    15e8:	31 97       	sbiw	r30, 0x01	; 1
    15ea:	60 e1       	ldi	r22, 0x10	; 16
    15ec:	60 83       	st	Z, r22
    15ee:	31 97       	sbiw	r30, 0x01	; 1
    15f0:	30 83       	st	Z, r19
    15f2:	31 97       	sbiw	r30, 0x01	; 1
    15f4:	32 e1       	ldi	r19, 0x12	; 18
    15f6:	30 83       	st	Z, r19
    15f8:	31 97       	sbiw	r30, 0x01	; 1
    15fa:	33 e1       	ldi	r19, 0x13	; 19
    15fc:	30 83       	st	Z, r19
    15fe:	31 97       	sbiw	r30, 0x01	; 1
    1600:	34 e1       	ldi	r19, 0x14	; 20
    1602:	30 83       	st	Z, r19
    1604:	31 97       	sbiw	r30, 0x01	; 1
    1606:	35 e1       	ldi	r19, 0x15	; 21
    1608:	30 83       	st	Z, r19
    160a:	31 97       	sbiw	r30, 0x01	; 1
    160c:	36 e1       	ldi	r19, 0x16	; 22
    160e:	30 83       	st	Z, r19
    1610:	31 97       	sbiw	r30, 0x01	; 1
    1612:	37 e1       	ldi	r19, 0x17	; 23
    1614:	30 83       	st	Z, r19
    1616:	31 97       	sbiw	r30, 0x01	; 1
    1618:	38 e1       	ldi	r19, 0x18	; 24
    161a:	30 83       	st	Z, r19
    161c:	31 97       	sbiw	r30, 0x01	; 1
    161e:	39 e1       	ldi	r19, 0x19	; 25
    1620:	30 83       	st	Z, r19
    1622:	31 97       	sbiw	r30, 0x01	; 1
    1624:	30 e2       	ldi	r19, 0x20	; 32
    1626:	30 83       	st	Z, r19
    1628:	31 97       	sbiw	r30, 0x01	; 1
    162a:	31 e2       	ldi	r19, 0x21	; 33
    162c:	30 83       	st	Z, r19
    162e:	31 97       	sbiw	r30, 0x01	; 1
    1630:	20 83       	st	Z, r18
    1632:	31 97       	sbiw	r30, 0x01	; 1
    1634:	23 e2       	ldi	r18, 0x23	; 35
    1636:	20 83       	st	Z, r18
    1638:	31 97       	sbiw	r30, 0x01	; 1
    163a:	40 83       	st	Z, r20
    163c:	31 97       	sbiw	r30, 0x01	; 1
    163e:	50 83       	st	Z, r21
    1640:	31 97       	sbiw	r30, 0x01	; 1
    1642:	26 e2       	ldi	r18, 0x26	; 38
    1644:	20 83       	st	Z, r18
    1646:	31 97       	sbiw	r30, 0x01	; 1
    1648:	27 e2       	ldi	r18, 0x27	; 39
    164a:	20 83       	st	Z, r18
    164c:	31 97       	sbiw	r30, 0x01	; 1
    164e:	28 e2       	ldi	r18, 0x28	; 40
    1650:	20 83       	st	Z, r18
    1652:	31 97       	sbiw	r30, 0x01	; 1
    1654:	29 e2       	ldi	r18, 0x29	; 41
    1656:	20 83       	st	Z, r18
    1658:	31 97       	sbiw	r30, 0x01	; 1
    165a:	20 e3       	ldi	r18, 0x30	; 48
    165c:	20 83       	st	Z, r18
    165e:	31 97       	sbiw	r30, 0x01	; 1
    1660:	21 e3       	ldi	r18, 0x31	; 49
    1662:	20 83       	st	Z, r18
    1664:	89 97       	sbiw	r24, 0x29	; 41
    1666:	08 95       	ret

00001668 <xPortStartScheduler>:
    1668:	84 df       	rcall	.-248    	; 0x1572 <prvSetupTimerInterrupt>
    166a:	a0 91 e5 08 	lds	r26, 0x08E5	; 0x8008e5 <pxCurrentTCB>
    166e:	b0 91 e6 08 	lds	r27, 0x08E6	; 0x8008e6 <pxCurrentTCB+0x1>
    1672:	cd 91       	ld	r28, X+
    1674:	cd bf       	out	0x3d, r28	; 61
    1676:	dd 91       	ld	r29, X+
    1678:	de bf       	out	0x3e, r29	; 62
    167a:	ff 91       	pop	r31
    167c:	ef 91       	pop	r30
    167e:	df 91       	pop	r29
    1680:	cf 91       	pop	r28
    1682:	bf 91       	pop	r27
    1684:	af 91       	pop	r26
    1686:	9f 91       	pop	r25
    1688:	8f 91       	pop	r24
    168a:	7f 91       	pop	r23
    168c:	6f 91       	pop	r22
    168e:	5f 91       	pop	r21
    1690:	4f 91       	pop	r20
    1692:	3f 91       	pop	r19
    1694:	2f 91       	pop	r18
    1696:	1f 91       	pop	r17
    1698:	0f 91       	pop	r16
    169a:	ff 90       	pop	r15
    169c:	ef 90       	pop	r14
    169e:	df 90       	pop	r13
    16a0:	cf 90       	pop	r12
    16a2:	bf 90       	pop	r11
    16a4:	af 90       	pop	r10
    16a6:	9f 90       	pop	r9
    16a8:	8f 90       	pop	r8
    16aa:	7f 90       	pop	r7
    16ac:	6f 90       	pop	r6
    16ae:	5f 90       	pop	r5
    16b0:	4f 90       	pop	r4
    16b2:	3f 90       	pop	r3
    16b4:	2f 90       	pop	r2
    16b6:	1f 90       	pop	r1
    16b8:	0f 90       	pop	r0
    16ba:	0c be       	out	0x3c, r0	; 60
    16bc:	0f 90       	pop	r0
    16be:	0b be       	out	0x3b, r0	; 59
    16c0:	0f 90       	pop	r0
    16c2:	0f be       	out	0x3f, r0	; 63
    16c4:	0f 90       	pop	r0
    16c6:	08 95       	ret
    16c8:	81 e0       	ldi	r24, 0x01	; 1
    16ca:	08 95       	ret

000016cc <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    16cc:	0f 92       	push	r0
    16ce:	0f b6       	in	r0, 0x3f	; 63
    16d0:	f8 94       	cli
    16d2:	0f 92       	push	r0
    16d4:	0b b6       	in	r0, 0x3b	; 59
    16d6:	0f 92       	push	r0
    16d8:	0c b6       	in	r0, 0x3c	; 60
    16da:	0f 92       	push	r0
    16dc:	1f 92       	push	r1
    16de:	11 24       	eor	r1, r1
    16e0:	2f 92       	push	r2
    16e2:	3f 92       	push	r3
    16e4:	4f 92       	push	r4
    16e6:	5f 92       	push	r5
    16e8:	6f 92       	push	r6
    16ea:	7f 92       	push	r7
    16ec:	8f 92       	push	r8
    16ee:	9f 92       	push	r9
    16f0:	af 92       	push	r10
    16f2:	bf 92       	push	r11
    16f4:	cf 92       	push	r12
    16f6:	df 92       	push	r13
    16f8:	ef 92       	push	r14
    16fa:	ff 92       	push	r15
    16fc:	0f 93       	push	r16
    16fe:	1f 93       	push	r17
    1700:	2f 93       	push	r18
    1702:	3f 93       	push	r19
    1704:	4f 93       	push	r20
    1706:	5f 93       	push	r21
    1708:	6f 93       	push	r22
    170a:	7f 93       	push	r23
    170c:	8f 93       	push	r24
    170e:	9f 93       	push	r25
    1710:	af 93       	push	r26
    1712:	bf 93       	push	r27
    1714:	cf 93       	push	r28
    1716:	df 93       	push	r29
    1718:	ef 93       	push	r30
    171a:	ff 93       	push	r31
    171c:	a0 91 e5 08 	lds	r26, 0x08E5	; 0x8008e5 <pxCurrentTCB>
    1720:	b0 91 e6 08 	lds	r27, 0x08E6	; 0x8008e6 <pxCurrentTCB+0x1>
    1724:	0d b6       	in	r0, 0x3d	; 61
    1726:	0d 92       	st	X+, r0
    1728:	0e b6       	in	r0, 0x3e	; 62
    172a:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    172c:	84 d3       	rcall	.+1800   	; 0x1e36 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    172e:	a0 91 e5 08 	lds	r26, 0x08E5	; 0x8008e5 <pxCurrentTCB>
    1732:	b0 91 e6 08 	lds	r27, 0x08E6	; 0x8008e6 <pxCurrentTCB+0x1>
    1736:	cd 91       	ld	r28, X+
    1738:	cd bf       	out	0x3d, r28	; 61
    173a:	dd 91       	ld	r29, X+
    173c:	de bf       	out	0x3e, r29	; 62
    173e:	ff 91       	pop	r31
    1740:	ef 91       	pop	r30
    1742:	df 91       	pop	r29
    1744:	cf 91       	pop	r28
    1746:	bf 91       	pop	r27
    1748:	af 91       	pop	r26
    174a:	9f 91       	pop	r25
    174c:	8f 91       	pop	r24
    174e:	7f 91       	pop	r23
    1750:	6f 91       	pop	r22
    1752:	5f 91       	pop	r21
    1754:	4f 91       	pop	r20
    1756:	3f 91       	pop	r19
    1758:	2f 91       	pop	r18
    175a:	1f 91       	pop	r17
    175c:	0f 91       	pop	r16
    175e:	ff 90       	pop	r15
    1760:	ef 90       	pop	r14
    1762:	df 90       	pop	r13
    1764:	cf 90       	pop	r12
    1766:	bf 90       	pop	r11
    1768:	af 90       	pop	r10
    176a:	9f 90       	pop	r9
    176c:	8f 90       	pop	r8
    176e:	7f 90       	pop	r7
    1770:	6f 90       	pop	r6
    1772:	5f 90       	pop	r5
    1774:	4f 90       	pop	r4
    1776:	3f 90       	pop	r3
    1778:	2f 90       	pop	r2
    177a:	1f 90       	pop	r1
    177c:	0f 90       	pop	r0
    177e:	0c be       	out	0x3c, r0	; 60
    1780:	0f 90       	pop	r0
    1782:	0b be       	out	0x3b, r0	; 59
    1784:	0f 90       	pop	r0
    1786:	0f be       	out	0x3f, r0	; 63
    1788:	0f 90       	pop	r0

	asm volatile ( "ret" );
    178a:	08 95       	ret

0000178c <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    178c:	0f 92       	push	r0
    178e:	0f b6       	in	r0, 0x3f	; 63
    1790:	f8 94       	cli
    1792:	0f 92       	push	r0
    1794:	0b b6       	in	r0, 0x3b	; 59
    1796:	0f 92       	push	r0
    1798:	0c b6       	in	r0, 0x3c	; 60
    179a:	0f 92       	push	r0
    179c:	1f 92       	push	r1
    179e:	11 24       	eor	r1, r1
    17a0:	2f 92       	push	r2
    17a2:	3f 92       	push	r3
    17a4:	4f 92       	push	r4
    17a6:	5f 92       	push	r5
    17a8:	6f 92       	push	r6
    17aa:	7f 92       	push	r7
    17ac:	8f 92       	push	r8
    17ae:	9f 92       	push	r9
    17b0:	af 92       	push	r10
    17b2:	bf 92       	push	r11
    17b4:	cf 92       	push	r12
    17b6:	df 92       	push	r13
    17b8:	ef 92       	push	r14
    17ba:	ff 92       	push	r15
    17bc:	0f 93       	push	r16
    17be:	1f 93       	push	r17
    17c0:	2f 93       	push	r18
    17c2:	3f 93       	push	r19
    17c4:	4f 93       	push	r20
    17c6:	5f 93       	push	r21
    17c8:	6f 93       	push	r22
    17ca:	7f 93       	push	r23
    17cc:	8f 93       	push	r24
    17ce:	9f 93       	push	r25
    17d0:	af 93       	push	r26
    17d2:	bf 93       	push	r27
    17d4:	cf 93       	push	r28
    17d6:	df 93       	push	r29
    17d8:	ef 93       	push	r30
    17da:	ff 93       	push	r31
    17dc:	a0 91 e5 08 	lds	r26, 0x08E5	; 0x8008e5 <pxCurrentTCB>
    17e0:	b0 91 e6 08 	lds	r27, 0x08E6	; 0x8008e6 <pxCurrentTCB+0x1>
    17e4:	0d b6       	in	r0, 0x3d	; 61
    17e6:	0d 92       	st	X+, r0
    17e8:	0e b6       	in	r0, 0x3e	; 62
    17ea:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    17ec:	ef d1       	rcall	.+990    	; 0x1bcc <vTaskIncrementTick>
	vTaskSwitchContext();
    17ee:	23 d3       	rcall	.+1606   	; 0x1e36 <vTaskSwitchContext>
    17f0:	a0 91 e5 08 	lds	r26, 0x08E5	; 0x8008e5 <pxCurrentTCB>
	portRESTORE_CONTEXT();
    17f4:	b0 91 e6 08 	lds	r27, 0x08E6	; 0x8008e6 <pxCurrentTCB+0x1>
    17f8:	cd 91       	ld	r28, X+
    17fa:	cd bf       	out	0x3d, r28	; 61
    17fc:	dd 91       	ld	r29, X+
    17fe:	de bf       	out	0x3e, r29	; 62
    1800:	ff 91       	pop	r31
    1802:	ef 91       	pop	r30
    1804:	df 91       	pop	r29
    1806:	cf 91       	pop	r28
    1808:	bf 91       	pop	r27
    180a:	af 91       	pop	r26
    180c:	9f 91       	pop	r25
    180e:	8f 91       	pop	r24
    1810:	7f 91       	pop	r23
    1812:	6f 91       	pop	r22
    1814:	5f 91       	pop	r21
    1816:	4f 91       	pop	r20
    1818:	3f 91       	pop	r19
    181a:	2f 91       	pop	r18
    181c:	1f 91       	pop	r17
    181e:	0f 91       	pop	r16
    1820:	ff 90       	pop	r15
    1822:	ef 90       	pop	r14
    1824:	df 90       	pop	r13
    1826:	cf 90       	pop	r12
    1828:	bf 90       	pop	r11
    182a:	af 90       	pop	r10
    182c:	9f 90       	pop	r9
    182e:	8f 90       	pop	r8
    1830:	7f 90       	pop	r7
    1832:	6f 90       	pop	r6
    1834:	5f 90       	pop	r5
    1836:	4f 90       	pop	r4
    1838:	3f 90       	pop	r3
    183a:	2f 90       	pop	r2
    183c:	1f 90       	pop	r1
    183e:	0f 90       	pop	r0
    1840:	0c be       	out	0x3c, r0	; 60
    1842:	0f 90       	pop	r0
    1844:	0b be       	out	0x3b, r0	; 59
    1846:	0f 90       	pop	r0
    1848:	0f be       	out	0x3f, r0	; 63
    184a:	0f 90       	pop	r0
    184c:	08 95       	ret

0000184e <__vector_21>:
	asm volatile ( "ret" );
    184e:	9e df       	rcall	.-196    	; 0x178c <vPortYieldFromTick>
//	void SIG_OUTPUT_COMPARE1A( void )
	void TIMER0_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER0_COMPA_vect( void )
	{
		vPortYieldFromTick();
		asm volatile ( "reti" );
    1850:	18 95       	reti

00001852 <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    1852:	cf 93       	push	r28
    1854:	df 93       	push	r29
    1856:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
    1858:	b3 d1       	rcall	.+870    	; 0x1bc0 <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
    185a:	20 91 d4 02 	lds	r18, 0x02D4	; 0x8002d4 <xNextFreeByte>
    185e:	30 91 d5 02 	lds	r19, 0x02D5	; 0x8002d5 <xNextFreeByte+0x1>
    1862:	c9 01       	movw	r24, r18
    1864:	8c 0f       	add	r24, r28
    1866:	9d 1f       	adc	r25, r29
    1868:	8c 3d       	cpi	r24, 0xDC	; 220
    186a:	45 e0       	ldi	r20, 0x05	; 5
    186c:	94 07       	cpc	r25, r20
    186e:	58 f4       	brcc	.+22     	; 0x1886 <pvPortMalloc+0x34>
    1870:	28 17       	cp	r18, r24
    1872:	39 07       	cpc	r19, r25
    1874:	58 f4       	brcc	.+22     	; 0x188c <pvPortMalloc+0x3a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
    1876:	e9 01       	movw	r28, r18
    1878:	ca 52       	subi	r28, 0x2A	; 42
    187a:	dd 4f       	sbci	r29, 0xFD	; 253
			xNextFreeByte += xWantedSize;			
    187c:	90 93 d5 02 	sts	0x02D5, r25	; 0x8002d5 <xNextFreeByte+0x1>
    1880:	80 93 d4 02 	sts	0x02D4, r24	; 0x8002d4 <xNextFreeByte>
    1884:	05 c0       	rjmp	.+10     	; 0x1890 <pvPortMalloc+0x3e>
static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL; 
    1886:	c0 e0       	ldi	r28, 0x00	; 0
    1888:	d0 e0       	ldi	r29, 0x00	; 0
    188a:	02 c0       	rjmp	.+4      	; 0x1890 <pvPortMalloc+0x3e>
    188c:	c0 e0       	ldi	r28, 0x00	; 0
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
			xNextFreeByte += xWantedSize;			
		}	
	}
	xTaskResumeAll();
    188e:	d0 e0       	ldi	r29, 0x00	; 0
    1890:	44 d2       	rcall	.+1160   	; 0x1d1a <xTaskResumeAll>
		}
	}
	#endif	

	return pvReturn;
}
    1892:	ce 01       	movw	r24, r28
    1894:	df 91       	pop	r29
    1896:	cf 91       	pop	r28
    1898:	08 95       	ret

0000189a <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    189a:	08 95       	ret

0000189c <prvIdleTask>:
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
		}
	}
    189c:	80 91 dc 08 	lds	r24, 0x08DC	; 0x8008dc <pxReadyTasksLists>
    18a0:	82 30       	cpi	r24, 0x02	; 2
    18a2:	e0 f3       	brcs	.-8      	; 0x189c <prvIdleTask>
    18a4:	13 df       	rcall	.-474    	; 0x16cc <vPortYield>
    18a6:	fa cf       	rjmp	.-12     	; 0x189c <prvIdleTask>

000018a8 <prvAllocateTCBAndStack>:
    18a8:	ef 92       	push	r14
    18aa:	ff 92       	push	r15
    18ac:	0f 93       	push	r16
    18ae:	1f 93       	push	r17
    18b0:	cf 93       	push	r28
    18b2:	df 93       	push	r29
    18b4:	7c 01       	movw	r14, r24
    18b6:	eb 01       	movw	r28, r22
    18b8:	81 e2       	ldi	r24, 0x21	; 33
    18ba:	90 e0       	ldi	r25, 0x00	; 0
    18bc:	ca df       	rcall	.-108    	; 0x1852 <pvPortMalloc>
    18be:	8c 01       	movw	r16, r24
    18c0:	89 2b       	or	r24, r25
    18c2:	a1 f0       	breq	.+40     	; 0x18ec <prvAllocateTCBAndStack+0x44>
    18c4:	20 97       	sbiw	r28, 0x00	; 0
    18c6:	19 f4       	brne	.+6      	; 0x18ce <prvAllocateTCBAndStack+0x26>
    18c8:	c7 01       	movw	r24, r14
    18ca:	c3 df       	rcall	.-122    	; 0x1852 <pvPortMalloc>
    18cc:	01 c0       	rjmp	.+2      	; 0x18d0 <prvAllocateTCBAndStack+0x28>
    18ce:	ce 01       	movw	r24, r28
    18d0:	f8 01       	movw	r30, r16
    18d2:	90 8f       	std	Z+24, r25	; 0x18
    18d4:	87 8b       	std	Z+23, r24	; 0x17
    18d6:	00 97       	sbiw	r24, 0x00	; 0
    18d8:	29 f4       	brne	.+10     	; 0x18e4 <prvAllocateTCBAndStack+0x3c>
    18da:	c8 01       	movw	r24, r16
    18dc:	de df       	rcall	.-68     	; 0x189a <vPortFree>
    18de:	00 e0       	ldi	r16, 0x00	; 0
    18e0:	10 e0       	ldi	r17, 0x00	; 0
    18e2:	04 c0       	rjmp	.+8      	; 0x18ec <prvAllocateTCBAndStack+0x44>
    18e4:	a7 01       	movw	r20, r14
    18e6:	65 ea       	ldi	r22, 0xA5	; 165
    18e8:	70 e0       	ldi	r23, 0x00	; 0
    18ea:	65 d6       	rcall	.+3274   	; 0x25b6 <memset>
    18ec:	c8 01       	movw	r24, r16
    18ee:	df 91       	pop	r29
    18f0:	cf 91       	pop	r28
    18f2:	1f 91       	pop	r17
    18f4:	0f 91       	pop	r16
    18f6:	ff 90       	pop	r15
    18f8:	ef 90       	pop	r14
    18fa:	08 95       	ret

000018fc <prvInitialiseTCBVariables>:
    18fc:	1f 93       	push	r17
    18fe:	cf 93       	push	r28
    1900:	df 93       	push	r29
    1902:	ec 01       	movw	r28, r24
    1904:	14 2f       	mov	r17, r20
    1906:	48 e0       	ldi	r20, 0x08	; 8
    1908:	50 e0       	ldi	r21, 0x00	; 0
    190a:	49 96       	adiw	r24, 0x19	; 25
    190c:	5b d6       	rcall	.+3254   	; 0x25c4 <strncpy>
    190e:	18 a2       	std	Y+32, r1	; 0x20
    1910:	11 11       	cpse	r17, r1
    1912:	10 e0       	ldi	r17, 0x00	; 0
    1914:	1e 8b       	std	Y+22, r17	; 0x16
    1916:	ce 01       	movw	r24, r28
    1918:	02 96       	adiw	r24, 0x02	; 2
    191a:	a9 dd       	rcall	.-1198   	; 0x146e <vListInitialiseItem>
    191c:	ce 01       	movw	r24, r28
    191e:	0c 96       	adiw	r24, 0x0c	; 12
    1920:	a6 dd       	rcall	.-1204   	; 0x146e <vListInitialiseItem>
    1922:	d9 87       	std	Y+9, r29	; 0x09
    1924:	c8 87       	std	Y+8, r28	; 0x08
    1926:	81 e0       	ldi	r24, 0x01	; 1
    1928:	90 e0       	ldi	r25, 0x00	; 0
    192a:	81 1b       	sub	r24, r17
    192c:	91 09       	sbc	r25, r1
    192e:	9d 87       	std	Y+13, r25	; 0x0d
    1930:	8c 87       	std	Y+12, r24	; 0x0c
    1932:	db 8b       	std	Y+19, r29	; 0x13
    1934:	ca 8b       	std	Y+18, r28	; 0x12
    1936:	df 91       	pop	r29
    1938:	cf 91       	pop	r28
    193a:	1f 91       	pop	r17
    193c:	08 95       	ret

0000193e <prvInitialiseTaskLists>:
    193e:	cf 93       	push	r28
    1940:	c0 e0       	ldi	r28, 0x00	; 0
    1942:	0f c0       	rjmp	.+30     	; 0x1962 <prvInitialiseTaskLists+0x24>
    1944:	8c 2f       	mov	r24, r28
    1946:	90 e0       	ldi	r25, 0x00	; 0
    1948:	9c 01       	movw	r18, r24
    194a:	22 0f       	add	r18, r18
    194c:	33 1f       	adc	r19, r19
    194e:	22 0f       	add	r18, r18
    1950:	33 1f       	adc	r19, r19
    1952:	22 0f       	add	r18, r18
    1954:	33 1f       	adc	r19, r19
    1956:	82 0f       	add	r24, r18
    1958:	93 1f       	adc	r25, r19
    195a:	84 52       	subi	r24, 0x24	; 36
    195c:	97 4f       	sbci	r25, 0xF7	; 247
    195e:	79 dd       	rcall	.-1294   	; 0x1452 <vListInitialise>
    1960:	cf 5f       	subi	r28, 0xFF	; 255
    1962:	cc 23       	and	r28, r28
    1964:	79 f3       	breq	.-34     	; 0x1944 <prvInitialiseTaskLists+0x6>
    1966:	83 ed       	ldi	r24, 0xD3	; 211
    1968:	98 e0       	ldi	r25, 0x08	; 8
    196a:	73 dd       	rcall	.-1306   	; 0x1452 <vListInitialise>
    196c:	8a ec       	ldi	r24, 0xCA	; 202
    196e:	98 e0       	ldi	r25, 0x08	; 8
    1970:	70 dd       	rcall	.-1312   	; 0x1452 <vListInitialise>
    1972:	8d eb       	ldi	r24, 0xBD	; 189
    1974:	98 e0       	ldi	r25, 0x08	; 8
    1976:	6d dd       	rcall	.-1318   	; 0x1452 <vListInitialise>
    1978:	83 ed       	ldi	r24, 0xD3	; 211
    197a:	98 e0       	ldi	r25, 0x08	; 8
    197c:	90 93 c9 08 	sts	0x08C9, r25	; 0x8008c9 <pxDelayedTaskList+0x1>
    1980:	80 93 c8 08 	sts	0x08C8, r24	; 0x8008c8 <pxDelayedTaskList>
    1984:	8a ec       	ldi	r24, 0xCA	; 202
    1986:	98 e0       	ldi	r25, 0x08	; 8
    1988:	90 93 c7 08 	sts	0x08C7, r25	; 0x8008c7 <pxOverflowDelayedTaskList+0x1>
    198c:	80 93 c6 08 	sts	0x08C6, r24	; 0x8008c6 <pxOverflowDelayedTaskList>
    1990:	cf 91       	pop	r28
    1992:	08 95       	ret

00001994 <prvAddCurrentTaskToDelayedList>:
    1994:	cf 93       	push	r28
    1996:	df 93       	push	r29
    1998:	ec 01       	movw	r28, r24
    199a:	e0 91 e5 08 	lds	r30, 0x08E5	; 0x8008e5 <pxCurrentTCB>
    199e:	f0 91 e6 08 	lds	r31, 0x08E6	; 0x8008e6 <pxCurrentTCB+0x1>
    19a2:	93 83       	std	Z+3, r25	; 0x03
    19a4:	82 83       	std	Z+2, r24	; 0x02
    19a6:	80 91 ba 08 	lds	r24, 0x08BA	; 0x8008ba <xTickCount>
    19aa:	90 91 bb 08 	lds	r25, 0x08BB	; 0x8008bb <xTickCount+0x1>
    19ae:	c8 17       	cp	r28, r24
    19b0:	d9 07       	cpc	r29, r25
    19b2:	60 f4       	brcc	.+24     	; 0x19cc <prvAddCurrentTaskToDelayedList+0x38>
    19b4:	60 91 e5 08 	lds	r22, 0x08E5	; 0x8008e5 <pxCurrentTCB>
    19b8:	70 91 e6 08 	lds	r23, 0x08E6	; 0x8008e6 <pxCurrentTCB+0x1>
    19bc:	80 91 c6 08 	lds	r24, 0x08C6	; 0x8008c6 <pxOverflowDelayedTaskList>
    19c0:	90 91 c7 08 	lds	r25, 0x08C7	; 0x8008c7 <pxOverflowDelayedTaskList+0x1>
    19c4:	6e 5f       	subi	r22, 0xFE	; 254
    19c6:	7f 4f       	sbci	r23, 0xFF	; 255
    19c8:	7d dd       	rcall	.-1286   	; 0x14c4 <vListInsert>
    19ca:	16 c0       	rjmp	.+44     	; 0x19f8 <prvAddCurrentTaskToDelayedList+0x64>
    19cc:	60 91 e5 08 	lds	r22, 0x08E5	; 0x8008e5 <pxCurrentTCB>
    19d0:	70 91 e6 08 	lds	r23, 0x08E6	; 0x8008e6 <pxCurrentTCB+0x1>
    19d4:	80 91 c8 08 	lds	r24, 0x08C8	; 0x8008c8 <pxDelayedTaskList>
    19d8:	90 91 c9 08 	lds	r25, 0x08C9	; 0x8008c9 <pxDelayedTaskList+0x1>
    19dc:	6e 5f       	subi	r22, 0xFE	; 254
    19de:	7f 4f       	sbci	r23, 0xFF	; 255
    19e0:	71 dd       	rcall	.-1310   	; 0x14c4 <vListInsert>
    19e2:	80 91 0b 02 	lds	r24, 0x020B	; 0x80020b <xNextTaskUnblockTime>
    19e6:	90 91 0c 02 	lds	r25, 0x020C	; 0x80020c <xNextTaskUnblockTime+0x1>
    19ea:	c8 17       	cp	r28, r24
    19ec:	d9 07       	cpc	r29, r25
    19ee:	20 f4       	brcc	.+8      	; 0x19f8 <prvAddCurrentTaskToDelayedList+0x64>
    19f0:	d0 93 0c 02 	sts	0x020C, r29	; 0x80020c <xNextTaskUnblockTime+0x1>
    19f4:	c0 93 0b 02 	sts	0x020B, r28	; 0x80020b <xNextTaskUnblockTime>
    19f8:	df 91       	pop	r29
    19fa:	cf 91       	pop	r28
    19fc:	08 95       	ret

000019fe <xTaskGenericCreate>:
    19fe:	2f 92       	push	r2
    1a00:	3f 92       	push	r3
    1a02:	4f 92       	push	r4
    1a04:	5f 92       	push	r5
    1a06:	7f 92       	push	r7
    1a08:	8f 92       	push	r8
    1a0a:	9f 92       	push	r9
    1a0c:	af 92       	push	r10
    1a0e:	bf 92       	push	r11
    1a10:	cf 92       	push	r12
    1a12:	df 92       	push	r13
    1a14:	ef 92       	push	r14
    1a16:	ff 92       	push	r15
    1a18:	0f 93       	push	r16
    1a1a:	1f 93       	push	r17
    1a1c:	cf 93       	push	r28
    1a1e:	df 93       	push	r29
    1a20:	00 d0       	rcall	.+0      	; 0x1a22 <xTaskGenericCreate+0x24>
    1a22:	1f 92       	push	r1
    1a24:	cd b7       	in	r28, 0x3d	; 61
    1a26:	de b7       	in	r29, 0x3e	; 62
    1a28:	9a 83       	std	Y+2, r25	; 0x02
    1a2a:	89 83       	std	Y+1, r24	; 0x01
    1a2c:	4b 01       	movw	r8, r22
    1a2e:	5c 83       	std	Y+4, r21	; 0x04
    1a30:	4b 83       	std	Y+3, r20	; 0x03
    1a32:	19 01       	movw	r2, r18
    1a34:	70 2e       	mov	r7, r16
    1a36:	b6 01       	movw	r22, r12
    1a38:	25 01       	movw	r4, r10
    1a3a:	ca 01       	movw	r24, r20
    1a3c:	35 df       	rcall	.-406    	; 0x18a8 <prvAllocateTCBAndStack>
    1a3e:	5c 01       	movw	r10, r24
    1a40:	00 97       	sbiw	r24, 0x00	; 0
    1a42:	09 f4       	brne	.+2      	; 0x1a46 <xTaskGenericCreate+0x48>
    1a44:	6c c0       	rjmp	.+216    	; 0x1b1e <xTaskGenericCreate+0x120>
    1a46:	fc 01       	movw	r30, r24
    1a48:	c7 88       	ldd	r12, Z+23	; 0x17
    1a4a:	d0 8c       	ldd	r13, Z+24	; 0x18
    1a4c:	8b 81       	ldd	r24, Y+3	; 0x03
    1a4e:	9c 81       	ldd	r25, Y+4	; 0x04
    1a50:	01 97       	sbiw	r24, 0x01	; 1
    1a52:	c8 0e       	add	r12, r24
    1a54:	d9 1e       	adc	r13, r25
    1a56:	0b 81       	ldd	r16, Y+3	; 0x03
    1a58:	1c 81       	ldd	r17, Y+4	; 0x04
    1a5a:	92 01       	movw	r18, r4
    1a5c:	47 2d       	mov	r20, r7
    1a5e:	b4 01       	movw	r22, r8
    1a60:	c5 01       	movw	r24, r10
    1a62:	4c df       	rcall	.-360    	; 0x18fc <prvInitialiseTCBVariables>
    1a64:	a1 01       	movw	r20, r2
    1a66:	69 81       	ldd	r22, Y+1	; 0x01
    1a68:	7a 81       	ldd	r23, Y+2	; 0x02
    1a6a:	c6 01       	movw	r24, r12
    1a6c:	8b dd       	rcall	.-1258   	; 0x1584 <pxPortInitialiseStack>
    1a6e:	f5 01       	movw	r30, r10
    1a70:	91 83       	std	Z+1, r25	; 0x01
    1a72:	80 83       	st	Z, r24
    1a74:	e1 14       	cp	r14, r1
    1a76:	f1 04       	cpc	r15, r1
    1a78:	19 f0       	breq	.+6      	; 0x1a80 <xTaskGenericCreate+0x82>
    1a7a:	f7 01       	movw	r30, r14
    1a7c:	b1 82       	std	Z+1, r11	; 0x01
    1a7e:	a0 82       	st	Z, r10
    1a80:	0f b6       	in	r0, 0x3f	; 63
    1a82:	f8 94       	cli
    1a84:	0f 92       	push	r0
    1a86:	80 91 bc 08 	lds	r24, 0x08BC	; 0x8008bc <uxCurrentNumberOfTasks>
    1a8a:	8f 5f       	subi	r24, 0xFF	; 255
    1a8c:	80 93 bc 08 	sts	0x08BC, r24	; 0x8008bc <uxCurrentNumberOfTasks>
    1a90:	80 91 e5 08 	lds	r24, 0x08E5	; 0x8008e5 <pxCurrentTCB>
    1a94:	90 91 e6 08 	lds	r25, 0x08E6	; 0x8008e6 <pxCurrentTCB+0x1>
    1a98:	89 2b       	or	r24, r25
    1a9a:	51 f4       	brne	.+20     	; 0x1ab0 <xTaskGenericCreate+0xb2>
    1a9c:	b0 92 e6 08 	sts	0x08E6, r11	; 0x8008e6 <pxCurrentTCB+0x1>
    1aa0:	a0 92 e5 08 	sts	0x08E5, r10	; 0x8008e5 <pxCurrentTCB>
    1aa4:	80 91 bc 08 	lds	r24, 0x08BC	; 0x8008bc <uxCurrentNumberOfTasks>
    1aa8:	81 30       	cpi	r24, 0x01	; 1
    1aaa:	89 f4       	brne	.+34     	; 0x1ace <xTaskGenericCreate+0xd0>
    1aac:	48 df       	rcall	.-368    	; 0x193e <prvInitialiseTaskLists>
    1aae:	0f c0       	rjmp	.+30     	; 0x1ace <xTaskGenericCreate+0xd0>
    1ab0:	80 91 b7 08 	lds	r24, 0x08B7	; 0x8008b7 <xSchedulerRunning>
    1ab4:	81 11       	cpse	r24, r1
    1ab6:	0b c0       	rjmp	.+22     	; 0x1ace <xTaskGenericCreate+0xd0>
    1ab8:	e0 91 e5 08 	lds	r30, 0x08E5	; 0x8008e5 <pxCurrentTCB>
    1abc:	f0 91 e6 08 	lds	r31, 0x08E6	; 0x8008e6 <pxCurrentTCB+0x1>
    1ac0:	86 89       	ldd	r24, Z+22	; 0x16
    1ac2:	78 16       	cp	r7, r24
    1ac4:	20 f0       	brcs	.+8      	; 0x1ace <xTaskGenericCreate+0xd0>
    1ac6:	b0 92 e6 08 	sts	0x08E6, r11	; 0x8008e6 <pxCurrentTCB+0x1>
    1aca:	a0 92 e5 08 	sts	0x08E5, r10	; 0x8008e5 <pxCurrentTCB>
    1ace:	f5 01       	movw	r30, r10
    1ad0:	86 89       	ldd	r24, Z+22	; 0x16
    1ad2:	90 91 b9 08 	lds	r25, 0x08B9	; 0x8008b9 <uxTopUsedPriority>
    1ad6:	98 17       	cp	r25, r24
    1ad8:	10 f4       	brcc	.+4      	; 0x1ade <xTaskGenericCreate+0xe0>
    1ada:	80 93 b9 08 	sts	0x08B9, r24	; 0x8008b9 <uxTopUsedPriority>
    1ade:	90 91 b2 08 	lds	r25, 0x08B2	; 0x8008b2 <uxTCBNumber>
    1ae2:	9f 5f       	subi	r25, 0xFF	; 255
    1ae4:	90 93 b2 08 	sts	0x08B2, r25	; 0x8008b2 <uxTCBNumber>
    1ae8:	90 91 b8 08 	lds	r25, 0x08B8	; 0x8008b8 <uxTopReadyPriority>
    1aec:	98 17       	cp	r25, r24
    1aee:	10 f4       	brcc	.+4      	; 0x1af4 <xTaskGenericCreate+0xf6>
    1af0:	80 93 b8 08 	sts	0x08B8, r24	; 0x8008b8 <uxTopReadyPriority>
    1af4:	90 e0       	ldi	r25, 0x00	; 0
    1af6:	b5 01       	movw	r22, r10
    1af8:	6e 5f       	subi	r22, 0xFE	; 254
    1afa:	7f 4f       	sbci	r23, 0xFF	; 255
    1afc:	9c 01       	movw	r18, r24
    1afe:	22 0f       	add	r18, r18
    1b00:	33 1f       	adc	r19, r19
    1b02:	22 0f       	add	r18, r18
    1b04:	33 1f       	adc	r19, r19
    1b06:	22 0f       	add	r18, r18
    1b08:	33 1f       	adc	r19, r19
    1b0a:	82 0f       	add	r24, r18
    1b0c:	93 1f       	adc	r25, r19
    1b0e:	84 52       	subi	r24, 0x24	; 36
    1b10:	97 4f       	sbci	r25, 0xF7	; 247
    1b12:	b1 dc       	rcall	.-1694   	; 0x1476 <vListInsertEnd>
    1b14:	0f 90       	pop	r0
    1b16:	0f be       	out	0x3f, r0	; 63
    1b18:	f1 e0       	ldi	r31, 0x01	; 1
    1b1a:	f9 83       	std	Y+1, r31	; 0x01
    1b1c:	02 c0       	rjmp	.+4      	; 0x1b22 <xTaskGenericCreate+0x124>
    1b1e:	8f ef       	ldi	r24, 0xFF	; 255
    1b20:	89 83       	std	Y+1, r24	; 0x01
    1b22:	e9 81       	ldd	r30, Y+1	; 0x01
    1b24:	e1 30       	cpi	r30, 0x01	; 1
    1b26:	61 f4       	brne	.+24     	; 0x1b40 <xTaskGenericCreate+0x142>
    1b28:	80 91 b7 08 	lds	r24, 0x08B7	; 0x8008b7 <xSchedulerRunning>
    1b2c:	88 23       	and	r24, r24
    1b2e:	41 f0       	breq	.+16     	; 0x1b40 <xTaskGenericCreate+0x142>
    1b30:	e0 91 e5 08 	lds	r30, 0x08E5	; 0x8008e5 <pxCurrentTCB>
    1b34:	f0 91 e6 08 	lds	r31, 0x08E6	; 0x8008e6 <pxCurrentTCB+0x1>
    1b38:	86 89       	ldd	r24, Z+22	; 0x16
    1b3a:	87 15       	cp	r24, r7
    1b3c:	08 f4       	brcc	.+2      	; 0x1b40 <xTaskGenericCreate+0x142>
    1b3e:	c6 dd       	rcall	.-1140   	; 0x16cc <vPortYield>
    1b40:	89 81       	ldd	r24, Y+1	; 0x01
    1b42:	0f 90       	pop	r0
    1b44:	0f 90       	pop	r0
    1b46:	0f 90       	pop	r0
    1b48:	0f 90       	pop	r0
    1b4a:	df 91       	pop	r29
    1b4c:	cf 91       	pop	r28
    1b4e:	1f 91       	pop	r17
    1b50:	0f 91       	pop	r16
    1b52:	ff 90       	pop	r15
    1b54:	ef 90       	pop	r14
    1b56:	df 90       	pop	r13
    1b58:	cf 90       	pop	r12
    1b5a:	bf 90       	pop	r11
    1b5c:	af 90       	pop	r10
    1b5e:	9f 90       	pop	r9
    1b60:	8f 90       	pop	r8
    1b62:	7f 90       	pop	r7
    1b64:	5f 90       	pop	r5
    1b66:	4f 90       	pop	r4
    1b68:	3f 90       	pop	r3
    1b6a:	2f 90       	pop	r2
    1b6c:	08 95       	ret

00001b6e <vTaskStartScheduler>:
    1b6e:	af 92       	push	r10
    1b70:	bf 92       	push	r11
    1b72:	cf 92       	push	r12
    1b74:	df 92       	push	r13
    1b76:	ef 92       	push	r14
    1b78:	ff 92       	push	r15
    1b7a:	0f 93       	push	r16
    1b7c:	a1 2c       	mov	r10, r1
    1b7e:	b1 2c       	mov	r11, r1
    1b80:	c1 2c       	mov	r12, r1
    1b82:	d1 2c       	mov	r13, r1
    1b84:	e1 2c       	mov	r14, r1
    1b86:	f1 2c       	mov	r15, r1
    1b88:	00 e0       	ldi	r16, 0x00	; 0
    1b8a:	20 e0       	ldi	r18, 0x00	; 0
    1b8c:	30 e0       	ldi	r19, 0x00	; 0
    1b8e:	45 e5       	ldi	r20, 0x55	; 85
    1b90:	50 e0       	ldi	r21, 0x00	; 0
    1b92:	67 ec       	ldi	r22, 0xC7	; 199
    1b94:	72 e0       	ldi	r23, 0x02	; 2
    1b96:	8e e4       	ldi	r24, 0x4E	; 78
    1b98:	9c e0       	ldi	r25, 0x0C	; 12
    1b9a:	31 df       	rcall	.-414    	; 0x19fe <xTaskGenericCreate>
    1b9c:	81 30       	cpi	r24, 0x01	; 1
    1b9e:	41 f4       	brne	.+16     	; 0x1bb0 <vTaskStartScheduler+0x42>
    1ba0:	f8 94       	cli
    1ba2:	80 93 b7 08 	sts	0x08B7, r24	; 0x8008b7 <xSchedulerRunning>
    1ba6:	10 92 bb 08 	sts	0x08BB, r1	; 0x8008bb <xTickCount+0x1>
    1baa:	10 92 ba 08 	sts	0x08BA, r1	; 0x8008ba <xTickCount>
    1bae:	5c dd       	rcall	.-1352   	; 0x1668 <xPortStartScheduler>
    1bb0:	0f 91       	pop	r16
    1bb2:	ff 90       	pop	r15
    1bb4:	ef 90       	pop	r14
    1bb6:	df 90       	pop	r13
    1bb8:	cf 90       	pop	r12
    1bba:	bf 90       	pop	r11
    1bbc:	af 90       	pop	r10
    1bbe:	08 95       	ret

00001bc0 <vTaskSuspendAll>:
    1bc0:	80 91 b6 08 	lds	r24, 0x08B6	; 0x8008b6 <uxSchedulerSuspended>
    1bc4:	8f 5f       	subi	r24, 0xFF	; 255
    1bc6:	80 93 b6 08 	sts	0x08B6, r24	; 0x8008b6 <uxSchedulerSuspended>
    1bca:	08 95       	ret

00001bcc <vTaskIncrementTick>:
    1bcc:	0f 93       	push	r16
    1bce:	1f 93       	push	r17
    1bd0:	cf 93       	push	r28
    1bd2:	df 93       	push	r29
    1bd4:	80 91 b6 08 	lds	r24, 0x08B6	; 0x8008b6 <uxSchedulerSuspended>
    1bd8:	81 11       	cpse	r24, r1
    1bda:	95 c0       	rjmp	.+298    	; 0x1d06 <vTaskIncrementTick+0x13a>
    1bdc:	80 91 ba 08 	lds	r24, 0x08BA	; 0x8008ba <xTickCount>
    1be0:	90 91 bb 08 	lds	r25, 0x08BB	; 0x8008bb <xTickCount+0x1>
    1be4:	01 96       	adiw	r24, 0x01	; 1
    1be6:	90 93 bb 08 	sts	0x08BB, r25	; 0x8008bb <xTickCount+0x1>
    1bea:	80 93 ba 08 	sts	0x08BA, r24	; 0x8008ba <xTickCount>
    1bee:	80 91 ba 08 	lds	r24, 0x08BA	; 0x8008ba <xTickCount>
    1bf2:	90 91 bb 08 	lds	r25, 0x08BB	; 0x8008bb <xTickCount+0x1>
    1bf6:	89 2b       	or	r24, r25
    1bf8:	99 f5       	brne	.+102    	; 0x1c60 <vTaskIncrementTick+0x94>
    1bfa:	80 91 c8 08 	lds	r24, 0x08C8	; 0x8008c8 <pxDelayedTaskList>
    1bfe:	90 91 c9 08 	lds	r25, 0x08C9	; 0x8008c9 <pxDelayedTaskList+0x1>
    1c02:	20 91 c6 08 	lds	r18, 0x08C6	; 0x8008c6 <pxOverflowDelayedTaskList>
    1c06:	30 91 c7 08 	lds	r19, 0x08C7	; 0x8008c7 <pxOverflowDelayedTaskList+0x1>
    1c0a:	30 93 c9 08 	sts	0x08C9, r19	; 0x8008c9 <pxDelayedTaskList+0x1>
    1c0e:	20 93 c8 08 	sts	0x08C8, r18	; 0x8008c8 <pxDelayedTaskList>
    1c12:	90 93 c7 08 	sts	0x08C7, r25	; 0x8008c7 <pxOverflowDelayedTaskList+0x1>
    1c16:	80 93 c6 08 	sts	0x08C6, r24	; 0x8008c6 <pxOverflowDelayedTaskList>
    1c1a:	80 91 b3 08 	lds	r24, 0x08B3	; 0x8008b3 <xNumOfOverflows>
    1c1e:	8f 5f       	subi	r24, 0xFF	; 255
    1c20:	80 93 b3 08 	sts	0x08B3, r24	; 0x8008b3 <xNumOfOverflows>
    1c24:	e0 91 c8 08 	lds	r30, 0x08C8	; 0x8008c8 <pxDelayedTaskList>
    1c28:	f0 91 c9 08 	lds	r31, 0x08C9	; 0x8008c9 <pxDelayedTaskList+0x1>
    1c2c:	80 81       	ld	r24, Z
    1c2e:	81 11       	cpse	r24, r1
    1c30:	07 c0       	rjmp	.+14     	; 0x1c40 <vTaskIncrementTick+0x74>
    1c32:	8f ef       	ldi	r24, 0xFF	; 255
    1c34:	9f ef       	ldi	r25, 0xFF	; 255
    1c36:	90 93 0c 02 	sts	0x020C, r25	; 0x80020c <xNextTaskUnblockTime+0x1>
    1c3a:	80 93 0b 02 	sts	0x020B, r24	; 0x80020b <xNextTaskUnblockTime>
    1c3e:	10 c0       	rjmp	.+32     	; 0x1c60 <vTaskIncrementTick+0x94>
    1c40:	e0 91 c8 08 	lds	r30, 0x08C8	; 0x8008c8 <pxDelayedTaskList>
    1c44:	f0 91 c9 08 	lds	r31, 0x08C9	; 0x8008c9 <pxDelayedTaskList+0x1>
    1c48:	05 80       	ldd	r0, Z+5	; 0x05
    1c4a:	f6 81       	ldd	r31, Z+6	; 0x06
    1c4c:	e0 2d       	mov	r30, r0
    1c4e:	06 80       	ldd	r0, Z+6	; 0x06
    1c50:	f7 81       	ldd	r31, Z+7	; 0x07
    1c52:	e0 2d       	mov	r30, r0
    1c54:	82 81       	ldd	r24, Z+2	; 0x02
    1c56:	93 81       	ldd	r25, Z+3	; 0x03
    1c58:	90 93 0c 02 	sts	0x020C, r25	; 0x80020c <xNextTaskUnblockTime+0x1>
    1c5c:	80 93 0b 02 	sts	0x020B, r24	; 0x80020b <xNextTaskUnblockTime>
    1c60:	20 91 ba 08 	lds	r18, 0x08BA	; 0x8008ba <xTickCount>
    1c64:	30 91 bb 08 	lds	r19, 0x08BB	; 0x8008bb <xTickCount+0x1>
    1c68:	80 91 0b 02 	lds	r24, 0x020B	; 0x80020b <xNextTaskUnblockTime>
    1c6c:	90 91 0c 02 	lds	r25, 0x020C	; 0x80020c <xNextTaskUnblockTime+0x1>
    1c70:	28 17       	cp	r18, r24
    1c72:	39 07       	cpc	r19, r25
    1c74:	08 f4       	brcc	.+2      	; 0x1c78 <vTaskIncrementTick+0xac>
    1c76:	4c c0       	rjmp	.+152    	; 0x1d10 <vTaskIncrementTick+0x144>
    1c78:	e0 91 c8 08 	lds	r30, 0x08C8	; 0x8008c8 <pxDelayedTaskList>
    1c7c:	f0 91 c9 08 	lds	r31, 0x08C9	; 0x8008c9 <pxDelayedTaskList+0x1>
    1c80:	80 81       	ld	r24, Z
    1c82:	81 11       	cpse	r24, r1
    1c84:	07 c0       	rjmp	.+14     	; 0x1c94 <vTaskIncrementTick+0xc8>
    1c86:	8f ef       	ldi	r24, 0xFF	; 255
    1c88:	9f ef       	ldi	r25, 0xFF	; 255
    1c8a:	90 93 0c 02 	sts	0x020C, r25	; 0x80020c <xNextTaskUnblockTime+0x1>
    1c8e:	80 93 0b 02 	sts	0x020B, r24	; 0x80020b <xNextTaskUnblockTime>
    1c92:	3e c0       	rjmp	.+124    	; 0x1d10 <vTaskIncrementTick+0x144>
    1c94:	e0 91 c8 08 	lds	r30, 0x08C8	; 0x8008c8 <pxDelayedTaskList>
    1c98:	f0 91 c9 08 	lds	r31, 0x08C9	; 0x8008c9 <pxDelayedTaskList+0x1>
    1c9c:	05 80       	ldd	r0, Z+5	; 0x05
    1c9e:	f6 81       	ldd	r31, Z+6	; 0x06
    1ca0:	e0 2d       	mov	r30, r0
    1ca2:	c6 81       	ldd	r28, Z+6	; 0x06
    1ca4:	d7 81       	ldd	r29, Z+7	; 0x07
    1ca6:	8a 81       	ldd	r24, Y+2	; 0x02
    1ca8:	9b 81       	ldd	r25, Y+3	; 0x03
    1caa:	20 91 ba 08 	lds	r18, 0x08BA	; 0x8008ba <xTickCount>
    1cae:	30 91 bb 08 	lds	r19, 0x08BB	; 0x8008bb <xTickCount+0x1>
    1cb2:	28 17       	cp	r18, r24
    1cb4:	39 07       	cpc	r19, r25
    1cb6:	28 f4       	brcc	.+10     	; 0x1cc2 <vTaskIncrementTick+0xf6>
    1cb8:	90 93 0c 02 	sts	0x020C, r25	; 0x80020c <xNextTaskUnblockTime+0x1>
    1cbc:	80 93 0b 02 	sts	0x020B, r24	; 0x80020b <xNextTaskUnblockTime>
    1cc0:	27 c0       	rjmp	.+78     	; 0x1d10 <vTaskIncrementTick+0x144>
    1cc2:	8e 01       	movw	r16, r28
    1cc4:	0e 5f       	subi	r16, 0xFE	; 254
    1cc6:	1f 4f       	sbci	r17, 0xFF	; 255
    1cc8:	c8 01       	movw	r24, r16
    1cca:	2d dc       	rcall	.-1958   	; 0x1526 <vListRemove>
    1ccc:	8c 89       	ldd	r24, Y+20	; 0x14
    1cce:	9d 89       	ldd	r25, Y+21	; 0x15
    1cd0:	89 2b       	or	r24, r25
    1cd2:	19 f0       	breq	.+6      	; 0x1cda <vTaskIncrementTick+0x10e>
    1cd4:	ce 01       	movw	r24, r28
    1cd6:	0c 96       	adiw	r24, 0x0c	; 12
    1cd8:	26 dc       	rcall	.-1972   	; 0x1526 <vListRemove>
    1cda:	8e 89       	ldd	r24, Y+22	; 0x16
    1cdc:	90 91 b8 08 	lds	r25, 0x08B8	; 0x8008b8 <uxTopReadyPriority>
    1ce0:	98 17       	cp	r25, r24
    1ce2:	10 f4       	brcc	.+4      	; 0x1ce8 <vTaskIncrementTick+0x11c>
    1ce4:	80 93 b8 08 	sts	0x08B8, r24	; 0x8008b8 <uxTopReadyPriority>
    1ce8:	90 e0       	ldi	r25, 0x00	; 0
    1cea:	9c 01       	movw	r18, r24
    1cec:	22 0f       	add	r18, r18
    1cee:	33 1f       	adc	r19, r19
    1cf0:	22 0f       	add	r18, r18
    1cf2:	33 1f       	adc	r19, r19
    1cf4:	22 0f       	add	r18, r18
    1cf6:	33 1f       	adc	r19, r19
    1cf8:	82 0f       	add	r24, r18
    1cfa:	93 1f       	adc	r25, r19
    1cfc:	b8 01       	movw	r22, r16
    1cfe:	84 52       	subi	r24, 0x24	; 36
    1d00:	97 4f       	sbci	r25, 0xF7	; 247
    1d02:	b9 db       	rcall	.-2190   	; 0x1476 <vListInsertEnd>
    1d04:	b9 cf       	rjmp	.-142    	; 0x1c78 <vTaskIncrementTick+0xac>
    1d06:	80 91 b5 08 	lds	r24, 0x08B5	; 0x8008b5 <uxMissedTicks>
    1d0a:	8f 5f       	subi	r24, 0xFF	; 255
    1d0c:	80 93 b5 08 	sts	0x08B5, r24	; 0x8008b5 <uxMissedTicks>
    1d10:	df 91       	pop	r29
    1d12:	cf 91       	pop	r28
    1d14:	1f 91       	pop	r17
    1d16:	0f 91       	pop	r16
    1d18:	08 95       	ret

00001d1a <xTaskResumeAll>:
    1d1a:	ff 92       	push	r15
    1d1c:	0f 93       	push	r16
    1d1e:	1f 93       	push	r17
    1d20:	cf 93       	push	r28
    1d22:	df 93       	push	r29
    1d24:	0f b6       	in	r0, 0x3f	; 63
    1d26:	f8 94       	cli
    1d28:	0f 92       	push	r0
    1d2a:	80 91 b6 08 	lds	r24, 0x08B6	; 0x8008b6 <uxSchedulerSuspended>
    1d2e:	81 50       	subi	r24, 0x01	; 1
    1d30:	80 93 b6 08 	sts	0x08B6, r24	; 0x8008b6 <uxSchedulerSuspended>
    1d34:	80 91 b6 08 	lds	r24, 0x08B6	; 0x8008b6 <uxSchedulerSuspended>
    1d38:	81 11       	cpse	r24, r1
    1d3a:	55 c0       	rjmp	.+170    	; 0x1de6 <xTaskResumeAll+0xcc>
    1d3c:	80 91 bc 08 	lds	r24, 0x08BC	; 0x8008bc <uxCurrentNumberOfTasks>
    1d40:	81 11       	cpse	r24, r1
    1d42:	2f c0       	rjmp	.+94     	; 0x1da2 <xTaskResumeAll+0x88>
    1d44:	53 c0       	rjmp	.+166    	; 0x1dec <xTaskResumeAll+0xd2>
    1d46:	e0 91 c2 08 	lds	r30, 0x08C2	; 0x8008c2 <xPendingReadyList+0x5>
    1d4a:	f0 91 c3 08 	lds	r31, 0x08C3	; 0x8008c3 <xPendingReadyList+0x6>
    1d4e:	c6 81       	ldd	r28, Z+6	; 0x06
    1d50:	d7 81       	ldd	r29, Z+7	; 0x07
    1d52:	ce 01       	movw	r24, r28
    1d54:	0c 96       	adiw	r24, 0x0c	; 12
    1d56:	e7 db       	rcall	.-2098   	; 0x1526 <vListRemove>
    1d58:	8e 01       	movw	r16, r28
    1d5a:	0e 5f       	subi	r16, 0xFE	; 254
    1d5c:	1f 4f       	sbci	r17, 0xFF	; 255
    1d5e:	c8 01       	movw	r24, r16
    1d60:	e2 db       	rcall	.-2108   	; 0x1526 <vListRemove>
    1d62:	8e 89       	ldd	r24, Y+22	; 0x16
    1d64:	90 91 b8 08 	lds	r25, 0x08B8	; 0x8008b8 <uxTopReadyPriority>
    1d68:	98 17       	cp	r25, r24
    1d6a:	10 f4       	brcc	.+4      	; 0x1d70 <xTaskResumeAll+0x56>
    1d6c:	80 93 b8 08 	sts	0x08B8, r24	; 0x8008b8 <uxTopReadyPriority>
    1d70:	90 e0       	ldi	r25, 0x00	; 0
    1d72:	9c 01       	movw	r18, r24
    1d74:	22 0f       	add	r18, r18
    1d76:	33 1f       	adc	r19, r19
    1d78:	22 0f       	add	r18, r18
    1d7a:	33 1f       	adc	r19, r19
    1d7c:	22 0f       	add	r18, r18
    1d7e:	33 1f       	adc	r19, r19
    1d80:	82 0f       	add	r24, r18
    1d82:	93 1f       	adc	r25, r19
    1d84:	b8 01       	movw	r22, r16
    1d86:	84 52       	subi	r24, 0x24	; 36
    1d88:	97 4f       	sbci	r25, 0xF7	; 247
    1d8a:	75 db       	rcall	.-2326   	; 0x1476 <vListInsertEnd>
    1d8c:	9e 89       	ldd	r25, Y+22	; 0x16
    1d8e:	e0 91 e5 08 	lds	r30, 0x08E5	; 0x8008e5 <pxCurrentTCB>
    1d92:	f0 91 e6 08 	lds	r31, 0x08E6	; 0x8008e6 <pxCurrentTCB+0x1>
    1d96:	86 89       	ldd	r24, Z+22	; 0x16
    1d98:	98 17       	cp	r25, r24
    1d9a:	20 f0       	brcs	.+8      	; 0x1da4 <xTaskResumeAll+0x8a>
    1d9c:	ff 24       	eor	r15, r15
    1d9e:	f3 94       	inc	r15
    1da0:	01 c0       	rjmp	.+2      	; 0x1da4 <xTaskResumeAll+0x8a>
    1da2:	f1 2c       	mov	r15, r1
    1da4:	80 91 bd 08 	lds	r24, 0x08BD	; 0x8008bd <xPendingReadyList>
    1da8:	81 11       	cpse	r24, r1
    1daa:	cd cf       	rjmp	.-102    	; 0x1d46 <xTaskResumeAll+0x2c>
    1dac:	80 91 b5 08 	lds	r24, 0x08B5	; 0x8008b5 <uxMissedTicks>
    1db0:	81 11       	cpse	r24, r1
    1db2:	07 c0       	rjmp	.+14     	; 0x1dc2 <xTaskResumeAll+0xa8>
    1db4:	0c c0       	rjmp	.+24     	; 0x1dce <xTaskResumeAll+0xb4>
    1db6:	0a df       	rcall	.-492    	; 0x1bcc <vTaskIncrementTick>
    1db8:	80 91 b5 08 	lds	r24, 0x08B5	; 0x8008b5 <uxMissedTicks>
    1dbc:	81 50       	subi	r24, 0x01	; 1
    1dbe:	80 93 b5 08 	sts	0x08B5, r24	; 0x8008b5 <uxMissedTicks>
    1dc2:	80 91 b5 08 	lds	r24, 0x08B5	; 0x8008b5 <uxMissedTicks>
    1dc6:	81 11       	cpse	r24, r1
    1dc8:	f6 cf       	rjmp	.-20     	; 0x1db6 <xTaskResumeAll+0x9c>
    1dca:	ff 24       	eor	r15, r15
    1dcc:	f3 94       	inc	r15
    1dce:	81 e0       	ldi	r24, 0x01	; 1
    1dd0:	f8 16       	cp	r15, r24
    1dd2:	21 f0       	breq	.+8      	; 0x1ddc <xTaskResumeAll+0xc2>
    1dd4:	80 91 b4 08 	lds	r24, 0x08B4	; 0x8008b4 <xMissedYield>
    1dd8:	81 30       	cpi	r24, 0x01	; 1
    1dda:	39 f4       	brne	.+14     	; 0x1dea <xTaskResumeAll+0xd0>
    1ddc:	10 92 b4 08 	sts	0x08B4, r1	; 0x8008b4 <xMissedYield>
    1de0:	75 dc       	rcall	.-1814   	; 0x16cc <vPortYield>
    1de2:	81 e0       	ldi	r24, 0x01	; 1
    1de4:	03 c0       	rjmp	.+6      	; 0x1dec <xTaskResumeAll+0xd2>
    1de6:	80 e0       	ldi	r24, 0x00	; 0
    1de8:	01 c0       	rjmp	.+2      	; 0x1dec <xTaskResumeAll+0xd2>
    1dea:	80 e0       	ldi	r24, 0x00	; 0
    1dec:	0f 90       	pop	r0
    1dee:	0f be       	out	0x3f, r0	; 63
    1df0:	df 91       	pop	r29
    1df2:	cf 91       	pop	r28
    1df4:	1f 91       	pop	r17
    1df6:	0f 91       	pop	r16
    1df8:	ff 90       	pop	r15
    1dfa:	08 95       	ret

00001dfc <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    1dfc:	cf 93       	push	r28
    1dfe:	df 93       	push	r29
    1e00:	ec 01       	movw	r28, r24
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    1e02:	89 2b       	or	r24, r25
    1e04:	89 f0       	breq	.+34     	; 0x1e28 <vTaskDelay+0x2c>
		{
			vTaskSuspendAll();
    1e06:	dc de       	rcall	.-584    	; 0x1bc0 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    1e08:	80 91 ba 08 	lds	r24, 0x08BA	; 0x8008ba <xTickCount>
    1e0c:	90 91 bb 08 	lds	r25, 0x08BB	; 0x8008bb <xTickCount+0x1>
    1e10:	c8 0f       	add	r28, r24
    1e12:	d9 1f       	adc	r29, r25

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1e14:	80 91 e5 08 	lds	r24, 0x08E5	; 0x8008e5 <pxCurrentTCB>
    1e18:	90 91 e6 08 	lds	r25, 0x08E6	; 0x8008e6 <pxCurrentTCB+0x1>
    1e1c:	02 96       	adiw	r24, 0x02	; 2
    1e1e:	83 db       	rcall	.-2298   	; 0x1526 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    1e20:	ce 01       	movw	r24, r28
    1e22:	b8 dd       	rcall	.-1168   	; 0x1994 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    1e24:	7a df       	rcall	.-268    	; 0x1d1a <xTaskResumeAll>
    1e26:	01 c0       	rjmp	.+2      	; 0x1e2a <vTaskDelay+0x2e>
#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    1e28:	80 e0       	ldi	r24, 0x00	; 0
			xAlreadyYielded = xTaskResumeAll();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    1e2a:	81 11       	cpse	r24, r1
    1e2c:	01 c0       	rjmp	.+2      	; 0x1e30 <vTaskDelay+0x34>
		{
			portYIELD_WITHIN_API();
    1e2e:	4e dc       	rcall	.-1892   	; 0x16cc <vPortYield>
    1e30:	df 91       	pop	r29
		}
	}
    1e32:	cf 91       	pop	r28
    1e34:	08 95       	ret

00001e36 <vTaskSwitchContext>:
    1e36:	80 91 b6 08 	lds	r24, 0x08B6	; 0x8008b6 <uxSchedulerSuspended>
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    1e3a:	88 23       	and	r24, r24
    1e3c:	49 f0       	breq	.+18     	; 0x1e50 <vTaskSwitchContext+0x1a>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    1e3e:	81 e0       	ldi	r24, 0x01	; 1
    1e40:	80 93 b4 08 	sts	0x08B4, r24	; 0x8008b4 <xMissedYield>
    1e44:	08 95       	ret
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    1e46:	80 91 b8 08 	lds	r24, 0x08B8	; 0x8008b8 <uxTopReadyPriority>
    1e4a:	81 50       	subi	r24, 0x01	; 1
    1e4c:	80 93 b8 08 	sts	0x08B8, r24	; 0x8008b8 <uxTopReadyPriority>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    1e50:	80 91 b8 08 	lds	r24, 0x08B8	; 0x8008b8 <uxTopReadyPriority>
    1e54:	90 e0       	ldi	r25, 0x00	; 0
    1e56:	fc 01       	movw	r30, r24
    1e58:	ee 0f       	add	r30, r30
    1e5a:	ff 1f       	adc	r31, r31
    1e5c:	ee 0f       	add	r30, r30
    1e5e:	ff 1f       	adc	r31, r31
    1e60:	ee 0f       	add	r30, r30
    1e62:	ff 1f       	adc	r31, r31
    1e64:	8e 0f       	add	r24, r30
    1e66:	9f 1f       	adc	r25, r31
    1e68:	fc 01       	movw	r30, r24
    1e6a:	e4 52       	subi	r30, 0x24	; 36
    1e6c:	f7 4f       	sbci	r31, 0xF7	; 247
    1e6e:	80 81       	ld	r24, Z
    1e70:	88 23       	and	r24, r24
    1e72:	49 f3       	breq	.-46     	; 0x1e46 <vTaskSwitchContext+0x10>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    1e74:	80 91 b8 08 	lds	r24, 0x08B8	; 0x8008b8 <uxTopReadyPriority>
    1e78:	90 e0       	ldi	r25, 0x00	; 0
    1e7a:	9c 01       	movw	r18, r24
    1e7c:	22 0f       	add	r18, r18
    1e7e:	33 1f       	adc	r19, r19
    1e80:	22 0f       	add	r18, r18
    1e82:	33 1f       	adc	r19, r19
    1e84:	22 0f       	add	r18, r18
    1e86:	33 1f       	adc	r19, r19
    1e88:	28 0f       	add	r18, r24
    1e8a:	39 1f       	adc	r19, r25
    1e8c:	d9 01       	movw	r26, r18
    1e8e:	a4 52       	subi	r26, 0x24	; 36
    1e90:	b7 4f       	sbci	r27, 0xF7	; 247
    1e92:	11 96       	adiw	r26, 0x01	; 1
    1e94:	ed 91       	ld	r30, X+
    1e96:	fc 91       	ld	r31, X
    1e98:	12 97       	sbiw	r26, 0x02	; 2
    1e9a:	02 80       	ldd	r0, Z+2	; 0x02
    1e9c:	f3 81       	ldd	r31, Z+3	; 0x03
    1e9e:	e0 2d       	mov	r30, r0
    1ea0:	12 96       	adiw	r26, 0x02	; 2
    1ea2:	fc 93       	st	X, r31
    1ea4:	ee 93       	st	-X, r30
    1ea6:	11 97       	sbiw	r26, 0x01	; 1
    1ea8:	21 52       	subi	r18, 0x21	; 33
    1eaa:	37 4f       	sbci	r19, 0xF7	; 247
    1eac:	e2 17       	cp	r30, r18
    1eae:	f3 07       	cpc	r31, r19
    1eb0:	29 f4       	brne	.+10     	; 0x1ebc <vTaskSwitchContext+0x86>
    1eb2:	22 81       	ldd	r18, Z+2	; 0x02
    1eb4:	33 81       	ldd	r19, Z+3	; 0x03
    1eb6:	fd 01       	movw	r30, r26
    1eb8:	32 83       	std	Z+2, r19	; 0x02
    1eba:	21 83       	std	Z+1, r18	; 0x01
    1ebc:	fc 01       	movw	r30, r24
    1ebe:	ee 0f       	add	r30, r30
    1ec0:	ff 1f       	adc	r31, r31
    1ec2:	ee 0f       	add	r30, r30
    1ec4:	ff 1f       	adc	r31, r31
    1ec6:	ee 0f       	add	r30, r30
    1ec8:	ff 1f       	adc	r31, r31
    1eca:	8e 0f       	add	r24, r30
    1ecc:	9f 1f       	adc	r25, r31
    1ece:	fc 01       	movw	r30, r24
    1ed0:	e4 52       	subi	r30, 0x24	; 36
    1ed2:	f7 4f       	sbci	r31, 0xF7	; 247
    1ed4:	01 80       	ldd	r0, Z+1	; 0x01
    1ed6:	f2 81       	ldd	r31, Z+2	; 0x02
    1ed8:	e0 2d       	mov	r30, r0
    1eda:	86 81       	ldd	r24, Z+6	; 0x06
    1edc:	97 81       	ldd	r25, Z+7	; 0x07
    1ede:	90 93 e6 08 	sts	0x08E6, r25	; 0x8008e6 <pxCurrentTCB+0x1>
    1ee2:	80 93 e5 08 	sts	0x08E5, r24	; 0x8008e5 <pxCurrentTCB>
    1ee6:	08 95       	ret

00001ee8 <_Z8InitUARTmhc>:
  Returns value <> 0 (TRUE), if the UART HAS received a new character.
*************************************************************************/
unsigned char CharReady()
{
   return UCSR0A & (1<<7);
}
    1ee8:	0f 93       	push	r16
    1eea:	1f 93       	push	r17
    1eec:	52 2f       	mov	r21, r18
    1eee:	8b 01       	movw	r16, r22
    1ef0:	9c 01       	movw	r18, r24
    1ef2:	0c 52       	subi	r16, 0x2C	; 44
    1ef4:	11 40       	sbci	r17, 0x01	; 1
    1ef6:	21 09       	sbc	r18, r1
    1ef8:	31 09       	sbc	r19, r1
    1efa:	05 3d       	cpi	r16, 0xD5	; 213
    1efc:	10 4c       	sbci	r17, 0xC0	; 192
    1efe:	21 40       	sbci	r18, 0x01	; 1
    1f00:	31 05       	cpc	r19, r1
    1f02:	e0 f5       	brcc	.+120    	; 0x1f7c <_Z8InitUARTmhc+0x94>
    1f04:	45 30       	cpi	r20, 0x05	; 5
    1f06:	d0 f1       	brcs	.+116    	; 0x1f7c <_Z8InitUARTmhc+0x94>
    1f08:	49 30       	cpi	r20, 0x09	; 9
    1f0a:	c0 f5       	brcc	.+112    	; 0x1f7c <_Z8InitUARTmhc+0x94>
    1f0c:	20 e2       	ldi	r18, 0x20	; 32
    1f0e:	20 93 c0 00 	sts	0x00C0, r18	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7000c0>
    1f12:	28 e1       	ldi	r18, 0x18	; 24
    1f14:	20 93 c1 00 	sts	0x00C1, r18	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7000c1>
    1f18:	45 50       	subi	r20, 0x05	; 5
    1f1a:	44 0f       	add	r20, r20
    1f1c:	40 93 c2 00 	sts	0x00C2, r20	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7000c2>
    1f20:	55 34       	cpi	r21, 0x45	; 69
    1f22:	31 f4       	brne	.+12     	; 0x1f30 <_Z8InitUARTmhc+0x48>
    1f24:	e2 ec       	ldi	r30, 0xC2	; 194
    1f26:	f0 e0       	ldi	r31, 0x00	; 0
    1f28:	20 81       	ld	r18, Z
    1f2a:	20 62       	ori	r18, 0x20	; 32
    1f2c:	20 83       	st	Z, r18
    1f2e:	07 c0       	rjmp	.+14     	; 0x1f3e <_Z8InitUARTmhc+0x56>
    1f30:	5f 34       	cpi	r21, 0x4F	; 79
    1f32:	29 f4       	brne	.+10     	; 0x1f3e <_Z8InitUARTmhc+0x56>
    1f34:	e2 ec       	ldi	r30, 0xC2	; 194
    1f36:	f0 e0       	ldi	r31, 0x00	; 0
    1f38:	20 81       	ld	r18, Z
    1f3a:	20 63       	ori	r18, 0x30	; 48
    1f3c:	20 83       	st	Z, r18
    1f3e:	dc 01       	movw	r26, r24
    1f40:	cb 01       	movw	r24, r22
    1f42:	88 0f       	add	r24, r24
    1f44:	99 1f       	adc	r25, r25
    1f46:	aa 1f       	adc	r26, r26
    1f48:	bb 1f       	adc	r27, r27
    1f4a:	88 0f       	add	r24, r24
    1f4c:	99 1f       	adc	r25, r25
    1f4e:	aa 1f       	adc	r26, r26
    1f50:	bb 1f       	adc	r27, r27
    1f52:	9c 01       	movw	r18, r24
    1f54:	ad 01       	movw	r20, r26
    1f56:	22 0f       	add	r18, r18
    1f58:	33 1f       	adc	r19, r19
    1f5a:	44 1f       	adc	r20, r20
    1f5c:	55 1f       	adc	r21, r21
    1f5e:	22 0f       	add	r18, r18
    1f60:	33 1f       	adc	r19, r19
    1f62:	44 1f       	adc	r20, r20
    1f64:	55 1f       	adc	r21, r21
    1f66:	60 e0       	ldi	r22, 0x00	; 0
    1f68:	74 e2       	ldi	r23, 0x24	; 36
    1f6a:	84 ef       	ldi	r24, 0xF4	; 244
    1f6c:	90 e0       	ldi	r25, 0x00	; 0
    1f6e:	d1 d1       	rcall	.+930    	; 0x2312 <__udivmodsi4>
    1f70:	21 50       	subi	r18, 0x01	; 1
    1f72:	31 09       	sbc	r19, r1
    1f74:	30 93 c5 00 	sts	0x00C5, r19	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7000c5>
    1f78:	20 93 c4 00 	sts	0x00C4, r18	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7000c4>
    1f7c:	1f 91       	pop	r17
    1f7e:	0f 91       	pop	r16
    1f80:	08 95       	ret

00001f82 <_Z8ReadCharv>:
Then this character is returned.
*************************************************************************/
char ReadChar()
{
  // Wait for new character received
  while ( (UCSR0A & (1<<7)) == 0 )
    1f82:	80 91 c0 00 	lds	r24, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7000c0>
    1f86:	88 23       	and	r24, r24
    1f88:	e4 f7       	brge	.-8      	; 0x1f82 <_Z8ReadCharv>
  {}                        
  // Then return it
  return UDR0;
    1f8a:	80 91 c6 00 	lds	r24, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7000c6>
}
    1f8e:	08 95       	ret

00001f90 <_Z8SendCharc>:
	Tegn : Character for sending. 
*************************************************************************/
void SendChar(char Tegn)
{
  // Wait for transmitter register empty (ready for new character)
  while ( (UCSR0A & (1<<5)) == 0 )
    1f90:	90 91 c0 00 	lds	r25, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7000c0>
    1f94:	95 ff       	sbrs	r25, 5
    1f96:	fc cf       	rjmp	.-8      	; 0x1f90 <_Z8SendCharc>
  {}
  // Then send the character
  UDR0 = Tegn;
    1f98:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7000c6>
    1f9c:	08 95       	ret

00001f9e <_Z10SendStringPc>:
Sends 0 terminated string.
Parameter:
   Streng: Pointer to the string. 
*************************************************************************/
void SendString(char* Streng)
{
    1f9e:	cf 93       	push	r28
    1fa0:	df 93       	push	r29
    1fa2:	ec 01       	movw	r28, r24
  // Repeat until zero-termination
  while (*Streng != 0)
    1fa4:	88 81       	ld	r24, Y
    1fa6:	88 23       	and	r24, r24
    1fa8:	19 f0       	breq	.+6      	; 0x1fb0 <_Z10SendStringPc+0x12>
  {
    // Send the character pointed to by "Streng"
    SendChar(*Streng);
    1faa:	f2 df       	rcall	.-28     	; 0x1f90 <_Z8SendCharc>
    // Advance the pointer one step
    Streng++;
    1fac:	21 96       	adiw	r28, 0x01	; 1
   Streng: Pointer to the string. 
*************************************************************************/
void SendString(char* Streng)
{
  // Repeat until zero-termination
  while (*Streng != 0)
    1fae:	fa cf       	rjmp	.-12     	; 0x1fa4 <_Z10SendStringPc+0x6>
    // Send the character pointed to by "Streng"
    SendChar(*Streng);
    // Advance the pointer one step
    Streng++;
  }
}
    1fb0:	df 91       	pop	r29
    1fb2:	cf 91       	pop	r28
    1fb4:	08 95       	ret

00001fb6 <__subsf3>:
    1fb6:	50 58       	subi	r21, 0x80	; 128

00001fb8 <__addsf3>:
    1fb8:	bb 27       	eor	r27, r27
    1fba:	aa 27       	eor	r26, r26
    1fbc:	0e d0       	rcall	.+28     	; 0x1fda <__addsf3x>
    1fbe:	08 c1       	rjmp	.+528    	; 0x21d0 <__fp_round>
    1fc0:	f9 d0       	rcall	.+498    	; 0x21b4 <__fp_pscA>
    1fc2:	30 f0       	brcs	.+12     	; 0x1fd0 <__addsf3+0x18>
    1fc4:	fe d0       	rcall	.+508    	; 0x21c2 <__fp_pscB>
    1fc6:	20 f0       	brcs	.+8      	; 0x1fd0 <__addsf3+0x18>
    1fc8:	31 f4       	brne	.+12     	; 0x1fd6 <__addsf3+0x1e>
    1fca:	9f 3f       	cpi	r25, 0xFF	; 255
    1fcc:	11 f4       	brne	.+4      	; 0x1fd2 <__addsf3+0x1a>
    1fce:	1e f4       	brtc	.+6      	; 0x1fd6 <__addsf3+0x1e>
    1fd0:	ee c0       	rjmp	.+476    	; 0x21ae <__fp_nan>
    1fd2:	0e f4       	brtc	.+2      	; 0x1fd6 <__addsf3+0x1e>
    1fd4:	e0 95       	com	r30
    1fd6:	e7 fb       	bst	r30, 7
    1fd8:	e4 c0       	rjmp	.+456    	; 0x21a2 <__fp_inf>

00001fda <__addsf3x>:
    1fda:	e9 2f       	mov	r30, r25
    1fdc:	0a d1       	rcall	.+532    	; 0x21f2 <__fp_split3>
    1fde:	80 f3       	brcs	.-32     	; 0x1fc0 <__addsf3+0x8>
    1fe0:	ba 17       	cp	r27, r26
    1fe2:	62 07       	cpc	r22, r18
    1fe4:	73 07       	cpc	r23, r19
    1fe6:	84 07       	cpc	r24, r20
    1fe8:	95 07       	cpc	r25, r21
    1fea:	18 f0       	brcs	.+6      	; 0x1ff2 <__addsf3x+0x18>
    1fec:	71 f4       	brne	.+28     	; 0x200a <__addsf3x+0x30>
    1fee:	9e f5       	brtc	.+102    	; 0x2056 <__addsf3x+0x7c>
    1ff0:	22 c1       	rjmp	.+580    	; 0x2236 <__fp_zero>
    1ff2:	0e f4       	brtc	.+2      	; 0x1ff6 <__addsf3x+0x1c>
    1ff4:	e0 95       	com	r30
    1ff6:	0b 2e       	mov	r0, r27
    1ff8:	ba 2f       	mov	r27, r26
    1ffa:	a0 2d       	mov	r26, r0
    1ffc:	0b 01       	movw	r0, r22
    1ffe:	b9 01       	movw	r22, r18
    2000:	90 01       	movw	r18, r0
    2002:	0c 01       	movw	r0, r24
    2004:	ca 01       	movw	r24, r20
    2006:	a0 01       	movw	r20, r0
    2008:	11 24       	eor	r1, r1
    200a:	ff 27       	eor	r31, r31
    200c:	59 1b       	sub	r21, r25
    200e:	99 f0       	breq	.+38     	; 0x2036 <__addsf3x+0x5c>
    2010:	59 3f       	cpi	r21, 0xF9	; 249
    2012:	50 f4       	brcc	.+20     	; 0x2028 <__addsf3x+0x4e>
    2014:	50 3e       	cpi	r21, 0xE0	; 224
    2016:	68 f1       	brcs	.+90     	; 0x2072 <__addsf3x+0x98>
    2018:	1a 16       	cp	r1, r26
    201a:	f0 40       	sbci	r31, 0x00	; 0
    201c:	a2 2f       	mov	r26, r18
    201e:	23 2f       	mov	r18, r19
    2020:	34 2f       	mov	r19, r20
    2022:	44 27       	eor	r20, r20
    2024:	58 5f       	subi	r21, 0xF8	; 248
    2026:	f3 cf       	rjmp	.-26     	; 0x200e <__addsf3x+0x34>
    2028:	46 95       	lsr	r20
    202a:	37 95       	ror	r19
    202c:	27 95       	ror	r18
    202e:	a7 95       	ror	r26
    2030:	f0 40       	sbci	r31, 0x00	; 0
    2032:	53 95       	inc	r21
    2034:	c9 f7       	brne	.-14     	; 0x2028 <__addsf3x+0x4e>
    2036:	7e f4       	brtc	.+30     	; 0x2056 <__addsf3x+0x7c>
    2038:	1f 16       	cp	r1, r31
    203a:	ba 0b       	sbc	r27, r26
    203c:	62 0b       	sbc	r22, r18
    203e:	73 0b       	sbc	r23, r19
    2040:	84 0b       	sbc	r24, r20
    2042:	ba f0       	brmi	.+46     	; 0x2072 <__addsf3x+0x98>
    2044:	91 50       	subi	r25, 0x01	; 1
    2046:	a1 f0       	breq	.+40     	; 0x2070 <__addsf3x+0x96>
    2048:	ff 0f       	add	r31, r31
    204a:	bb 1f       	adc	r27, r27
    204c:	66 1f       	adc	r22, r22
    204e:	77 1f       	adc	r23, r23
    2050:	88 1f       	adc	r24, r24
    2052:	c2 f7       	brpl	.-16     	; 0x2044 <__addsf3x+0x6a>
    2054:	0e c0       	rjmp	.+28     	; 0x2072 <__addsf3x+0x98>
    2056:	ba 0f       	add	r27, r26
    2058:	62 1f       	adc	r22, r18
    205a:	73 1f       	adc	r23, r19
    205c:	84 1f       	adc	r24, r20
    205e:	48 f4       	brcc	.+18     	; 0x2072 <__addsf3x+0x98>
    2060:	87 95       	ror	r24
    2062:	77 95       	ror	r23
    2064:	67 95       	ror	r22
    2066:	b7 95       	ror	r27
    2068:	f7 95       	ror	r31
    206a:	9e 3f       	cpi	r25, 0xFE	; 254
    206c:	08 f0       	brcs	.+2      	; 0x2070 <__addsf3x+0x96>
    206e:	b3 cf       	rjmp	.-154    	; 0x1fd6 <__addsf3+0x1e>
    2070:	93 95       	inc	r25
    2072:	88 0f       	add	r24, r24
    2074:	08 f0       	brcs	.+2      	; 0x2078 <__addsf3x+0x9e>
    2076:	99 27       	eor	r25, r25
    2078:	ee 0f       	add	r30, r30
    207a:	97 95       	ror	r25
    207c:	87 95       	ror	r24
    207e:	08 95       	ret

00002080 <__cmpsf2>:
    2080:	6c d0       	rcall	.+216    	; 0x215a <__fp_cmp>
    2082:	08 f4       	brcc	.+2      	; 0x2086 <__cmpsf2+0x6>
    2084:	81 e0       	ldi	r24, 0x01	; 1
    2086:	08 95       	ret

00002088 <__fixunssfsi>:
    2088:	bc d0       	rcall	.+376    	; 0x2202 <__fp_splitA>
    208a:	88 f0       	brcs	.+34     	; 0x20ae <__fixunssfsi+0x26>
    208c:	9f 57       	subi	r25, 0x7F	; 127
    208e:	90 f0       	brcs	.+36     	; 0x20b4 <__fixunssfsi+0x2c>
    2090:	b9 2f       	mov	r27, r25
    2092:	99 27       	eor	r25, r25
    2094:	b7 51       	subi	r27, 0x17	; 23
    2096:	a0 f0       	brcs	.+40     	; 0x20c0 <__fixunssfsi+0x38>
    2098:	d1 f0       	breq	.+52     	; 0x20ce <__fixunssfsi+0x46>
    209a:	66 0f       	add	r22, r22
    209c:	77 1f       	adc	r23, r23
    209e:	88 1f       	adc	r24, r24
    20a0:	99 1f       	adc	r25, r25
    20a2:	1a f0       	brmi	.+6      	; 0x20aa <__fixunssfsi+0x22>
    20a4:	ba 95       	dec	r27
    20a6:	c9 f7       	brne	.-14     	; 0x209a <__fixunssfsi+0x12>
    20a8:	12 c0       	rjmp	.+36     	; 0x20ce <__fixunssfsi+0x46>
    20aa:	b1 30       	cpi	r27, 0x01	; 1
    20ac:	81 f0       	breq	.+32     	; 0x20ce <__fixunssfsi+0x46>
    20ae:	c3 d0       	rcall	.+390    	; 0x2236 <__fp_zero>
    20b0:	b1 e0       	ldi	r27, 0x01	; 1
    20b2:	08 95       	ret
    20b4:	c0 c0       	rjmp	.+384    	; 0x2236 <__fp_zero>
    20b6:	67 2f       	mov	r22, r23
    20b8:	78 2f       	mov	r23, r24
    20ba:	88 27       	eor	r24, r24
    20bc:	b8 5f       	subi	r27, 0xF8	; 248
    20be:	39 f0       	breq	.+14     	; 0x20ce <__fixunssfsi+0x46>
    20c0:	b9 3f       	cpi	r27, 0xF9	; 249
    20c2:	cc f3       	brlt	.-14     	; 0x20b6 <__fixunssfsi+0x2e>
    20c4:	86 95       	lsr	r24
    20c6:	77 95       	ror	r23
    20c8:	67 95       	ror	r22
    20ca:	b3 95       	inc	r27
    20cc:	d9 f7       	brne	.-10     	; 0x20c4 <__fixunssfsi+0x3c>
    20ce:	3e f4       	brtc	.+14     	; 0x20de <__fixunssfsi+0x56>
    20d0:	90 95       	com	r25
    20d2:	80 95       	com	r24
    20d4:	70 95       	com	r23
    20d6:	61 95       	neg	r22
    20d8:	7f 4f       	sbci	r23, 0xFF	; 255
    20da:	8f 4f       	sbci	r24, 0xFF	; 255
    20dc:	9f 4f       	sbci	r25, 0xFF	; 255
    20de:	08 95       	ret

000020e0 <__floatunsisf>:
    20e0:	e8 94       	clt
    20e2:	09 c0       	rjmp	.+18     	; 0x20f6 <__floatsisf+0x12>

000020e4 <__floatsisf>:
    20e4:	97 fb       	bst	r25, 7
    20e6:	3e f4       	brtc	.+14     	; 0x20f6 <__floatsisf+0x12>
    20e8:	90 95       	com	r25
    20ea:	80 95       	com	r24
    20ec:	70 95       	com	r23
    20ee:	61 95       	neg	r22
    20f0:	7f 4f       	sbci	r23, 0xFF	; 255
    20f2:	8f 4f       	sbci	r24, 0xFF	; 255
    20f4:	9f 4f       	sbci	r25, 0xFF	; 255
    20f6:	99 23       	and	r25, r25
    20f8:	a9 f0       	breq	.+42     	; 0x2124 <__floatsisf+0x40>
    20fa:	f9 2f       	mov	r31, r25
    20fc:	96 e9       	ldi	r25, 0x96	; 150
    20fe:	bb 27       	eor	r27, r27
    2100:	93 95       	inc	r25
    2102:	f6 95       	lsr	r31
    2104:	87 95       	ror	r24
    2106:	77 95       	ror	r23
    2108:	67 95       	ror	r22
    210a:	b7 95       	ror	r27
    210c:	f1 11       	cpse	r31, r1
    210e:	f8 cf       	rjmp	.-16     	; 0x2100 <__floatsisf+0x1c>
    2110:	fa f4       	brpl	.+62     	; 0x2150 <__floatsisf+0x6c>
    2112:	bb 0f       	add	r27, r27
    2114:	11 f4       	brne	.+4      	; 0x211a <__floatsisf+0x36>
    2116:	60 ff       	sbrs	r22, 0
    2118:	1b c0       	rjmp	.+54     	; 0x2150 <__floatsisf+0x6c>
    211a:	6f 5f       	subi	r22, 0xFF	; 255
    211c:	7f 4f       	sbci	r23, 0xFF	; 255
    211e:	8f 4f       	sbci	r24, 0xFF	; 255
    2120:	9f 4f       	sbci	r25, 0xFF	; 255
    2122:	16 c0       	rjmp	.+44     	; 0x2150 <__floatsisf+0x6c>
    2124:	88 23       	and	r24, r24
    2126:	11 f0       	breq	.+4      	; 0x212c <__floatsisf+0x48>
    2128:	96 e9       	ldi	r25, 0x96	; 150
    212a:	11 c0       	rjmp	.+34     	; 0x214e <__floatsisf+0x6a>
    212c:	77 23       	and	r23, r23
    212e:	21 f0       	breq	.+8      	; 0x2138 <__floatsisf+0x54>
    2130:	9e e8       	ldi	r25, 0x8E	; 142
    2132:	87 2f       	mov	r24, r23
    2134:	76 2f       	mov	r23, r22
    2136:	05 c0       	rjmp	.+10     	; 0x2142 <__floatsisf+0x5e>
    2138:	66 23       	and	r22, r22
    213a:	71 f0       	breq	.+28     	; 0x2158 <__floatsisf+0x74>
    213c:	96 e8       	ldi	r25, 0x86	; 134
    213e:	86 2f       	mov	r24, r22
    2140:	70 e0       	ldi	r23, 0x00	; 0
    2142:	60 e0       	ldi	r22, 0x00	; 0
    2144:	2a f0       	brmi	.+10     	; 0x2150 <__floatsisf+0x6c>
    2146:	9a 95       	dec	r25
    2148:	66 0f       	add	r22, r22
    214a:	77 1f       	adc	r23, r23
    214c:	88 1f       	adc	r24, r24
    214e:	da f7       	brpl	.-10     	; 0x2146 <__floatsisf+0x62>
    2150:	88 0f       	add	r24, r24
    2152:	96 95       	lsr	r25
    2154:	87 95       	ror	r24
    2156:	97 f9       	bld	r25, 7
    2158:	08 95       	ret

0000215a <__fp_cmp>:
    215a:	99 0f       	add	r25, r25
    215c:	00 08       	sbc	r0, r0
    215e:	55 0f       	add	r21, r21
    2160:	aa 0b       	sbc	r26, r26
    2162:	e0 e8       	ldi	r30, 0x80	; 128
    2164:	fe ef       	ldi	r31, 0xFE	; 254
    2166:	16 16       	cp	r1, r22
    2168:	17 06       	cpc	r1, r23
    216a:	e8 07       	cpc	r30, r24
    216c:	f9 07       	cpc	r31, r25
    216e:	c0 f0       	brcs	.+48     	; 0x21a0 <__fp_cmp+0x46>
    2170:	12 16       	cp	r1, r18
    2172:	13 06       	cpc	r1, r19
    2174:	e4 07       	cpc	r30, r20
    2176:	f5 07       	cpc	r31, r21
    2178:	98 f0       	brcs	.+38     	; 0x21a0 <__fp_cmp+0x46>
    217a:	62 1b       	sub	r22, r18
    217c:	73 0b       	sbc	r23, r19
    217e:	84 0b       	sbc	r24, r20
    2180:	95 0b       	sbc	r25, r21
    2182:	39 f4       	brne	.+14     	; 0x2192 <__fp_cmp+0x38>
    2184:	0a 26       	eor	r0, r26
    2186:	61 f0       	breq	.+24     	; 0x21a0 <__fp_cmp+0x46>
    2188:	23 2b       	or	r18, r19
    218a:	24 2b       	or	r18, r20
    218c:	25 2b       	or	r18, r21
    218e:	21 f4       	brne	.+8      	; 0x2198 <__fp_cmp+0x3e>
    2190:	08 95       	ret
    2192:	0a 26       	eor	r0, r26
    2194:	09 f4       	brne	.+2      	; 0x2198 <__fp_cmp+0x3e>
    2196:	a1 40       	sbci	r26, 0x01	; 1
    2198:	a6 95       	lsr	r26
    219a:	8f ef       	ldi	r24, 0xFF	; 255
    219c:	81 1d       	adc	r24, r1
    219e:	81 1d       	adc	r24, r1
    21a0:	08 95       	ret

000021a2 <__fp_inf>:
    21a2:	97 f9       	bld	r25, 7
    21a4:	9f 67       	ori	r25, 0x7F	; 127
    21a6:	80 e8       	ldi	r24, 0x80	; 128
    21a8:	70 e0       	ldi	r23, 0x00	; 0
    21aa:	60 e0       	ldi	r22, 0x00	; 0
    21ac:	08 95       	ret

000021ae <__fp_nan>:
    21ae:	9f ef       	ldi	r25, 0xFF	; 255
    21b0:	80 ec       	ldi	r24, 0xC0	; 192
    21b2:	08 95       	ret

000021b4 <__fp_pscA>:
    21b4:	00 24       	eor	r0, r0
    21b6:	0a 94       	dec	r0
    21b8:	16 16       	cp	r1, r22
    21ba:	17 06       	cpc	r1, r23
    21bc:	18 06       	cpc	r1, r24
    21be:	09 06       	cpc	r0, r25
    21c0:	08 95       	ret

000021c2 <__fp_pscB>:
    21c2:	00 24       	eor	r0, r0
    21c4:	0a 94       	dec	r0
    21c6:	12 16       	cp	r1, r18
    21c8:	13 06       	cpc	r1, r19
    21ca:	14 06       	cpc	r1, r20
    21cc:	05 06       	cpc	r0, r21
    21ce:	08 95       	ret

000021d0 <__fp_round>:
    21d0:	09 2e       	mov	r0, r25
    21d2:	03 94       	inc	r0
    21d4:	00 0c       	add	r0, r0
    21d6:	11 f4       	brne	.+4      	; 0x21dc <__fp_round+0xc>
    21d8:	88 23       	and	r24, r24
    21da:	52 f0       	brmi	.+20     	; 0x21f0 <__fp_round+0x20>
    21dc:	bb 0f       	add	r27, r27
    21de:	40 f4       	brcc	.+16     	; 0x21f0 <__fp_round+0x20>
    21e0:	bf 2b       	or	r27, r31
    21e2:	11 f4       	brne	.+4      	; 0x21e8 <__fp_round+0x18>
    21e4:	60 ff       	sbrs	r22, 0
    21e6:	04 c0       	rjmp	.+8      	; 0x21f0 <__fp_round+0x20>
    21e8:	6f 5f       	subi	r22, 0xFF	; 255
    21ea:	7f 4f       	sbci	r23, 0xFF	; 255
    21ec:	8f 4f       	sbci	r24, 0xFF	; 255
    21ee:	9f 4f       	sbci	r25, 0xFF	; 255
    21f0:	08 95       	ret

000021f2 <__fp_split3>:
    21f2:	57 fd       	sbrc	r21, 7
    21f4:	90 58       	subi	r25, 0x80	; 128
    21f6:	44 0f       	add	r20, r20
    21f8:	55 1f       	adc	r21, r21
    21fa:	59 f0       	breq	.+22     	; 0x2212 <__fp_splitA+0x10>
    21fc:	5f 3f       	cpi	r21, 0xFF	; 255
    21fe:	71 f0       	breq	.+28     	; 0x221c <__fp_splitA+0x1a>
    2200:	47 95       	ror	r20

00002202 <__fp_splitA>:
    2202:	88 0f       	add	r24, r24
    2204:	97 fb       	bst	r25, 7
    2206:	99 1f       	adc	r25, r25
    2208:	61 f0       	breq	.+24     	; 0x2222 <__fp_splitA+0x20>
    220a:	9f 3f       	cpi	r25, 0xFF	; 255
    220c:	79 f0       	breq	.+30     	; 0x222c <__fp_splitA+0x2a>
    220e:	87 95       	ror	r24
    2210:	08 95       	ret
    2212:	12 16       	cp	r1, r18
    2214:	13 06       	cpc	r1, r19
    2216:	14 06       	cpc	r1, r20
    2218:	55 1f       	adc	r21, r21
    221a:	f2 cf       	rjmp	.-28     	; 0x2200 <__stack+0x1>
    221c:	46 95       	lsr	r20
    221e:	f1 df       	rcall	.-30     	; 0x2202 <__fp_splitA>
    2220:	08 c0       	rjmp	.+16     	; 0x2232 <__fp_splitA+0x30>
    2222:	16 16       	cp	r1, r22
    2224:	17 06       	cpc	r1, r23
    2226:	18 06       	cpc	r1, r24
    2228:	99 1f       	adc	r25, r25
    222a:	f1 cf       	rjmp	.-30     	; 0x220e <__fp_splitA+0xc>
    222c:	86 95       	lsr	r24
    222e:	71 05       	cpc	r23, r1
    2230:	61 05       	cpc	r22, r1
    2232:	08 94       	sec
    2234:	08 95       	ret

00002236 <__fp_zero>:
    2236:	e8 94       	clt

00002238 <__fp_szero>:
    2238:	bb 27       	eor	r27, r27
    223a:	66 27       	eor	r22, r22
    223c:	77 27       	eor	r23, r23
    223e:	cb 01       	movw	r24, r22
    2240:	97 f9       	bld	r25, 7
    2242:	08 95       	ret

00002244 <__gesf2>:
    2244:	8a df       	rcall	.-236    	; 0x215a <__fp_cmp>
    2246:	08 f4       	brcc	.+2      	; 0x224a <__gesf2+0x6>
    2248:	8f ef       	ldi	r24, 0xFF	; 255
    224a:	08 95       	ret

0000224c <__mulsf3>:
    224c:	0b d0       	rcall	.+22     	; 0x2264 <__mulsf3x>
    224e:	c0 cf       	rjmp	.-128    	; 0x21d0 <__fp_round>
    2250:	b1 df       	rcall	.-158    	; 0x21b4 <__fp_pscA>
    2252:	28 f0       	brcs	.+10     	; 0x225e <__mulsf3+0x12>
    2254:	b6 df       	rcall	.-148    	; 0x21c2 <__fp_pscB>
    2256:	18 f0       	brcs	.+6      	; 0x225e <__mulsf3+0x12>
    2258:	95 23       	and	r25, r21
    225a:	09 f0       	breq	.+2      	; 0x225e <__mulsf3+0x12>
    225c:	a2 cf       	rjmp	.-188    	; 0x21a2 <__fp_inf>
    225e:	a7 cf       	rjmp	.-178    	; 0x21ae <__fp_nan>
    2260:	11 24       	eor	r1, r1
    2262:	ea cf       	rjmp	.-44     	; 0x2238 <__fp_szero>

00002264 <__mulsf3x>:
    2264:	c6 df       	rcall	.-116    	; 0x21f2 <__fp_split3>
    2266:	a0 f3       	brcs	.-24     	; 0x2250 <__mulsf3+0x4>

00002268 <__mulsf3_pse>:
    2268:	95 9f       	mul	r25, r21
    226a:	d1 f3       	breq	.-12     	; 0x2260 <__mulsf3+0x14>
    226c:	95 0f       	add	r25, r21
    226e:	50 e0       	ldi	r21, 0x00	; 0
    2270:	55 1f       	adc	r21, r21
    2272:	62 9f       	mul	r22, r18
    2274:	f0 01       	movw	r30, r0
    2276:	72 9f       	mul	r23, r18
    2278:	bb 27       	eor	r27, r27
    227a:	f0 0d       	add	r31, r0
    227c:	b1 1d       	adc	r27, r1
    227e:	63 9f       	mul	r22, r19
    2280:	aa 27       	eor	r26, r26
    2282:	f0 0d       	add	r31, r0
    2284:	b1 1d       	adc	r27, r1
    2286:	aa 1f       	adc	r26, r26
    2288:	64 9f       	mul	r22, r20
    228a:	66 27       	eor	r22, r22
    228c:	b0 0d       	add	r27, r0
    228e:	a1 1d       	adc	r26, r1
    2290:	66 1f       	adc	r22, r22
    2292:	82 9f       	mul	r24, r18
    2294:	22 27       	eor	r18, r18
    2296:	b0 0d       	add	r27, r0
    2298:	a1 1d       	adc	r26, r1
    229a:	62 1f       	adc	r22, r18
    229c:	73 9f       	mul	r23, r19
    229e:	b0 0d       	add	r27, r0
    22a0:	a1 1d       	adc	r26, r1
    22a2:	62 1f       	adc	r22, r18
    22a4:	83 9f       	mul	r24, r19
    22a6:	a0 0d       	add	r26, r0
    22a8:	61 1d       	adc	r22, r1
    22aa:	22 1f       	adc	r18, r18
    22ac:	74 9f       	mul	r23, r20
    22ae:	33 27       	eor	r19, r19
    22b0:	a0 0d       	add	r26, r0
    22b2:	61 1d       	adc	r22, r1
    22b4:	23 1f       	adc	r18, r19
    22b6:	84 9f       	mul	r24, r20
    22b8:	60 0d       	add	r22, r0
    22ba:	21 1d       	adc	r18, r1
    22bc:	82 2f       	mov	r24, r18
    22be:	76 2f       	mov	r23, r22
    22c0:	6a 2f       	mov	r22, r26
    22c2:	11 24       	eor	r1, r1
    22c4:	9f 57       	subi	r25, 0x7F	; 127
    22c6:	50 40       	sbci	r21, 0x00	; 0
    22c8:	8a f0       	brmi	.+34     	; 0x22ec <__mulsf3_pse+0x84>
    22ca:	e1 f0       	breq	.+56     	; 0x2304 <__mulsf3_pse+0x9c>
    22cc:	88 23       	and	r24, r24
    22ce:	4a f0       	brmi	.+18     	; 0x22e2 <__mulsf3_pse+0x7a>
    22d0:	ee 0f       	add	r30, r30
    22d2:	ff 1f       	adc	r31, r31
    22d4:	bb 1f       	adc	r27, r27
    22d6:	66 1f       	adc	r22, r22
    22d8:	77 1f       	adc	r23, r23
    22da:	88 1f       	adc	r24, r24
    22dc:	91 50       	subi	r25, 0x01	; 1
    22de:	50 40       	sbci	r21, 0x00	; 0
    22e0:	a9 f7       	brne	.-22     	; 0x22cc <__mulsf3_pse+0x64>
    22e2:	9e 3f       	cpi	r25, 0xFE	; 254
    22e4:	51 05       	cpc	r21, r1
    22e6:	70 f0       	brcs	.+28     	; 0x2304 <__mulsf3_pse+0x9c>
    22e8:	5c cf       	rjmp	.-328    	; 0x21a2 <__fp_inf>
    22ea:	a6 cf       	rjmp	.-180    	; 0x2238 <__fp_szero>
    22ec:	5f 3f       	cpi	r21, 0xFF	; 255
    22ee:	ec f3       	brlt	.-6      	; 0x22ea <__mulsf3_pse+0x82>
    22f0:	98 3e       	cpi	r25, 0xE8	; 232
    22f2:	dc f3       	brlt	.-10     	; 0x22ea <__mulsf3_pse+0x82>
    22f4:	86 95       	lsr	r24
    22f6:	77 95       	ror	r23
    22f8:	67 95       	ror	r22
    22fa:	b7 95       	ror	r27
    22fc:	f7 95       	ror	r31
    22fe:	e7 95       	ror	r30
    2300:	9f 5f       	subi	r25, 0xFF	; 255
    2302:	c1 f7       	brne	.-16     	; 0x22f4 <__mulsf3_pse+0x8c>
    2304:	fe 2b       	or	r31, r30
    2306:	88 0f       	add	r24, r24
    2308:	91 1d       	adc	r25, r1
    230a:	96 95       	lsr	r25
    230c:	87 95       	ror	r24
    230e:	97 f9       	bld	r25, 7
    2310:	08 95       	ret

00002312 <__udivmodsi4>:
    2312:	a1 e2       	ldi	r26, 0x21	; 33
    2314:	1a 2e       	mov	r1, r26
    2316:	aa 1b       	sub	r26, r26
    2318:	bb 1b       	sub	r27, r27
    231a:	fd 01       	movw	r30, r26
    231c:	0d c0       	rjmp	.+26     	; 0x2338 <__udivmodsi4_ep>

0000231e <__udivmodsi4_loop>:
    231e:	aa 1f       	adc	r26, r26
    2320:	bb 1f       	adc	r27, r27
    2322:	ee 1f       	adc	r30, r30
    2324:	ff 1f       	adc	r31, r31
    2326:	a2 17       	cp	r26, r18
    2328:	b3 07       	cpc	r27, r19
    232a:	e4 07       	cpc	r30, r20
    232c:	f5 07       	cpc	r31, r21
    232e:	20 f0       	brcs	.+8      	; 0x2338 <__udivmodsi4_ep>
    2330:	a2 1b       	sub	r26, r18
    2332:	b3 0b       	sbc	r27, r19
    2334:	e4 0b       	sbc	r30, r20
    2336:	f5 0b       	sbc	r31, r21

00002338 <__udivmodsi4_ep>:
    2338:	66 1f       	adc	r22, r22
    233a:	77 1f       	adc	r23, r23
    233c:	88 1f       	adc	r24, r24
    233e:	99 1f       	adc	r25, r25
    2340:	1a 94       	dec	r1
    2342:	69 f7       	brne	.-38     	; 0x231e <__udivmodsi4_loop>
    2344:	60 95       	com	r22
    2346:	70 95       	com	r23
    2348:	80 95       	com	r24
    234a:	90 95       	com	r25
    234c:	9b 01       	movw	r18, r22
    234e:	ac 01       	movw	r20, r24
    2350:	bd 01       	movw	r22, r26
    2352:	cf 01       	movw	r24, r30
    2354:	08 95       	ret

00002356 <__umulhisi3>:
    2356:	a2 9f       	mul	r26, r18
    2358:	b0 01       	movw	r22, r0
    235a:	b3 9f       	mul	r27, r19
    235c:	c0 01       	movw	r24, r0
    235e:	a3 9f       	mul	r26, r19
    2360:	70 0d       	add	r23, r0
    2362:	81 1d       	adc	r24, r1
    2364:	11 24       	eor	r1, r1
    2366:	91 1d       	adc	r25, r1
    2368:	b2 9f       	mul	r27, r18
    236a:	70 0d       	add	r23, r0
    236c:	81 1d       	adc	r24, r1
    236e:	11 24       	eor	r1, r1
    2370:	91 1d       	adc	r25, r1
    2372:	08 95       	ret

00002374 <malloc>:
    2374:	0f 93       	push	r16
    2376:	1f 93       	push	r17
    2378:	cf 93       	push	r28
    237a:	df 93       	push	r29
    237c:	82 30       	cpi	r24, 0x02	; 2
    237e:	91 05       	cpc	r25, r1
    2380:	10 f4       	brcc	.+4      	; 0x2386 <malloc+0x12>
    2382:	82 e0       	ldi	r24, 0x02	; 2
    2384:	90 e0       	ldi	r25, 0x00	; 0
    2386:	e0 91 e9 08 	lds	r30, 0x08E9	; 0x8008e9 <__flp>
    238a:	f0 91 ea 08 	lds	r31, 0x08EA	; 0x8008ea <__flp+0x1>
    238e:	20 e0       	ldi	r18, 0x00	; 0
    2390:	30 e0       	ldi	r19, 0x00	; 0
    2392:	a0 e0       	ldi	r26, 0x00	; 0
    2394:	b0 e0       	ldi	r27, 0x00	; 0
    2396:	30 97       	sbiw	r30, 0x00	; 0
    2398:	19 f1       	breq	.+70     	; 0x23e0 <malloc+0x6c>
    239a:	40 81       	ld	r20, Z
    239c:	51 81       	ldd	r21, Z+1	; 0x01
    239e:	02 81       	ldd	r16, Z+2	; 0x02
    23a0:	13 81       	ldd	r17, Z+3	; 0x03
    23a2:	48 17       	cp	r20, r24
    23a4:	59 07       	cpc	r21, r25
    23a6:	c8 f0       	brcs	.+50     	; 0x23da <malloc+0x66>
    23a8:	84 17       	cp	r24, r20
    23aa:	95 07       	cpc	r25, r21
    23ac:	69 f4       	brne	.+26     	; 0x23c8 <malloc+0x54>
    23ae:	10 97       	sbiw	r26, 0x00	; 0
    23b0:	31 f0       	breq	.+12     	; 0x23be <malloc+0x4a>
    23b2:	12 96       	adiw	r26, 0x02	; 2
    23b4:	0c 93       	st	X, r16
    23b6:	12 97       	sbiw	r26, 0x02	; 2
    23b8:	13 96       	adiw	r26, 0x03	; 3
    23ba:	1c 93       	st	X, r17
    23bc:	27 c0       	rjmp	.+78     	; 0x240c <malloc+0x98>
    23be:	00 93 e9 08 	sts	0x08E9, r16	; 0x8008e9 <__flp>
    23c2:	10 93 ea 08 	sts	0x08EA, r17	; 0x8008ea <__flp+0x1>
    23c6:	22 c0       	rjmp	.+68     	; 0x240c <malloc+0x98>
    23c8:	21 15       	cp	r18, r1
    23ca:	31 05       	cpc	r19, r1
    23cc:	19 f0       	breq	.+6      	; 0x23d4 <malloc+0x60>
    23ce:	42 17       	cp	r20, r18
    23d0:	53 07       	cpc	r21, r19
    23d2:	18 f4       	brcc	.+6      	; 0x23da <malloc+0x66>
    23d4:	9a 01       	movw	r18, r20
    23d6:	bd 01       	movw	r22, r26
    23d8:	ef 01       	movw	r28, r30
    23da:	df 01       	movw	r26, r30
    23dc:	f8 01       	movw	r30, r16
    23de:	db cf       	rjmp	.-74     	; 0x2396 <malloc+0x22>
    23e0:	21 15       	cp	r18, r1
    23e2:	31 05       	cpc	r19, r1
    23e4:	f9 f0       	breq	.+62     	; 0x2424 <malloc+0xb0>
    23e6:	28 1b       	sub	r18, r24
    23e8:	39 0b       	sbc	r19, r25
    23ea:	24 30       	cpi	r18, 0x04	; 4
    23ec:	31 05       	cpc	r19, r1
    23ee:	80 f4       	brcc	.+32     	; 0x2410 <malloc+0x9c>
    23f0:	8a 81       	ldd	r24, Y+2	; 0x02
    23f2:	9b 81       	ldd	r25, Y+3	; 0x03
    23f4:	61 15       	cp	r22, r1
    23f6:	71 05       	cpc	r23, r1
    23f8:	21 f0       	breq	.+8      	; 0x2402 <malloc+0x8e>
    23fa:	fb 01       	movw	r30, r22
    23fc:	93 83       	std	Z+3, r25	; 0x03
    23fe:	82 83       	std	Z+2, r24	; 0x02
    2400:	04 c0       	rjmp	.+8      	; 0x240a <malloc+0x96>
    2402:	90 93 ea 08 	sts	0x08EA, r25	; 0x8008ea <__flp+0x1>
    2406:	80 93 e9 08 	sts	0x08E9, r24	; 0x8008e9 <__flp>
    240a:	fe 01       	movw	r30, r28
    240c:	32 96       	adiw	r30, 0x02	; 2
    240e:	44 c0       	rjmp	.+136    	; 0x2498 <malloc+0x124>
    2410:	fe 01       	movw	r30, r28
    2412:	e2 0f       	add	r30, r18
    2414:	f3 1f       	adc	r31, r19
    2416:	81 93       	st	Z+, r24
    2418:	91 93       	st	Z+, r25
    241a:	22 50       	subi	r18, 0x02	; 2
    241c:	31 09       	sbc	r19, r1
    241e:	39 83       	std	Y+1, r19	; 0x01
    2420:	28 83       	st	Y, r18
    2422:	3a c0       	rjmp	.+116    	; 0x2498 <malloc+0x124>
    2424:	20 91 e7 08 	lds	r18, 0x08E7	; 0x8008e7 <__brkval>
    2428:	30 91 e8 08 	lds	r19, 0x08E8	; 0x8008e8 <__brkval+0x1>
    242c:	23 2b       	or	r18, r19
    242e:	41 f4       	brne	.+16     	; 0x2440 <malloc+0xcc>
    2430:	20 91 02 02 	lds	r18, 0x0202	; 0x800202 <__malloc_heap_start>
    2434:	30 91 03 02 	lds	r19, 0x0203	; 0x800203 <__malloc_heap_start+0x1>
    2438:	30 93 e8 08 	sts	0x08E8, r19	; 0x8008e8 <__brkval+0x1>
    243c:	20 93 e7 08 	sts	0x08E7, r18	; 0x8008e7 <__brkval>
    2440:	20 91 00 02 	lds	r18, 0x0200	; 0x800200 <__data_start>
    2444:	30 91 01 02 	lds	r19, 0x0201	; 0x800201 <__data_start+0x1>
    2448:	21 15       	cp	r18, r1
    244a:	31 05       	cpc	r19, r1
    244c:	41 f4       	brne	.+16     	; 0x245e <malloc+0xea>
    244e:	2d b7       	in	r18, 0x3d	; 61
    2450:	3e b7       	in	r19, 0x3e	; 62
    2452:	40 91 04 02 	lds	r20, 0x0204	; 0x800204 <__malloc_margin>
    2456:	50 91 05 02 	lds	r21, 0x0205	; 0x800205 <__malloc_margin+0x1>
    245a:	24 1b       	sub	r18, r20
    245c:	35 0b       	sbc	r19, r21
    245e:	e0 91 e7 08 	lds	r30, 0x08E7	; 0x8008e7 <__brkval>
    2462:	f0 91 e8 08 	lds	r31, 0x08E8	; 0x8008e8 <__brkval+0x1>
    2466:	e2 17       	cp	r30, r18
    2468:	f3 07       	cpc	r31, r19
    246a:	a0 f4       	brcc	.+40     	; 0x2494 <malloc+0x120>
    246c:	2e 1b       	sub	r18, r30
    246e:	3f 0b       	sbc	r19, r31
    2470:	28 17       	cp	r18, r24
    2472:	39 07       	cpc	r19, r25
    2474:	78 f0       	brcs	.+30     	; 0x2494 <malloc+0x120>
    2476:	ac 01       	movw	r20, r24
    2478:	4e 5f       	subi	r20, 0xFE	; 254
    247a:	5f 4f       	sbci	r21, 0xFF	; 255
    247c:	24 17       	cp	r18, r20
    247e:	35 07       	cpc	r19, r21
    2480:	48 f0       	brcs	.+18     	; 0x2494 <malloc+0x120>
    2482:	4e 0f       	add	r20, r30
    2484:	5f 1f       	adc	r21, r31
    2486:	50 93 e8 08 	sts	0x08E8, r21	; 0x8008e8 <__brkval+0x1>
    248a:	40 93 e7 08 	sts	0x08E7, r20	; 0x8008e7 <__brkval>
    248e:	81 93       	st	Z+, r24
    2490:	91 93       	st	Z+, r25
    2492:	02 c0       	rjmp	.+4      	; 0x2498 <malloc+0x124>
    2494:	e0 e0       	ldi	r30, 0x00	; 0
    2496:	f0 e0       	ldi	r31, 0x00	; 0
    2498:	cf 01       	movw	r24, r30
    249a:	df 91       	pop	r29
    249c:	cf 91       	pop	r28
    249e:	1f 91       	pop	r17
    24a0:	0f 91       	pop	r16
    24a2:	08 95       	ret

000024a4 <free>:
    24a4:	cf 93       	push	r28
    24a6:	df 93       	push	r29
    24a8:	00 97       	sbiw	r24, 0x00	; 0
    24aa:	09 f4       	brne	.+2      	; 0x24ae <free+0xa>
    24ac:	81 c0       	rjmp	.+258    	; 0x25b0 <free+0x10c>
    24ae:	fc 01       	movw	r30, r24
    24b0:	32 97       	sbiw	r30, 0x02	; 2
    24b2:	13 82       	std	Z+3, r1	; 0x03
    24b4:	12 82       	std	Z+2, r1	; 0x02
    24b6:	a0 91 e9 08 	lds	r26, 0x08E9	; 0x8008e9 <__flp>
    24ba:	b0 91 ea 08 	lds	r27, 0x08EA	; 0x8008ea <__flp+0x1>
    24be:	10 97       	sbiw	r26, 0x00	; 0
    24c0:	81 f4       	brne	.+32     	; 0x24e2 <free+0x3e>
    24c2:	20 81       	ld	r18, Z
    24c4:	31 81       	ldd	r19, Z+1	; 0x01
    24c6:	82 0f       	add	r24, r18
    24c8:	93 1f       	adc	r25, r19
    24ca:	20 91 e7 08 	lds	r18, 0x08E7	; 0x8008e7 <__brkval>
    24ce:	30 91 e8 08 	lds	r19, 0x08E8	; 0x8008e8 <__brkval+0x1>
    24d2:	28 17       	cp	r18, r24
    24d4:	39 07       	cpc	r19, r25
    24d6:	51 f5       	brne	.+84     	; 0x252c <free+0x88>
    24d8:	f0 93 e8 08 	sts	0x08E8, r31	; 0x8008e8 <__brkval+0x1>
    24dc:	e0 93 e7 08 	sts	0x08E7, r30	; 0x8008e7 <__brkval>
    24e0:	67 c0       	rjmp	.+206    	; 0x25b0 <free+0x10c>
    24e2:	ed 01       	movw	r28, r26
    24e4:	20 e0       	ldi	r18, 0x00	; 0
    24e6:	30 e0       	ldi	r19, 0x00	; 0
    24e8:	ce 17       	cp	r28, r30
    24ea:	df 07       	cpc	r29, r31
    24ec:	40 f4       	brcc	.+16     	; 0x24fe <free+0x5a>
    24ee:	4a 81       	ldd	r20, Y+2	; 0x02
    24f0:	5b 81       	ldd	r21, Y+3	; 0x03
    24f2:	9e 01       	movw	r18, r28
    24f4:	41 15       	cp	r20, r1
    24f6:	51 05       	cpc	r21, r1
    24f8:	f1 f0       	breq	.+60     	; 0x2536 <free+0x92>
    24fa:	ea 01       	movw	r28, r20
    24fc:	f5 cf       	rjmp	.-22     	; 0x24e8 <free+0x44>
    24fe:	d3 83       	std	Z+3, r29	; 0x03
    2500:	c2 83       	std	Z+2, r28	; 0x02
    2502:	40 81       	ld	r20, Z
    2504:	51 81       	ldd	r21, Z+1	; 0x01
    2506:	84 0f       	add	r24, r20
    2508:	95 1f       	adc	r25, r21
    250a:	c8 17       	cp	r28, r24
    250c:	d9 07       	cpc	r29, r25
    250e:	59 f4       	brne	.+22     	; 0x2526 <free+0x82>
    2510:	88 81       	ld	r24, Y
    2512:	99 81       	ldd	r25, Y+1	; 0x01
    2514:	84 0f       	add	r24, r20
    2516:	95 1f       	adc	r25, r21
    2518:	02 96       	adiw	r24, 0x02	; 2
    251a:	91 83       	std	Z+1, r25	; 0x01
    251c:	80 83       	st	Z, r24
    251e:	8a 81       	ldd	r24, Y+2	; 0x02
    2520:	9b 81       	ldd	r25, Y+3	; 0x03
    2522:	93 83       	std	Z+3, r25	; 0x03
    2524:	82 83       	std	Z+2, r24	; 0x02
    2526:	21 15       	cp	r18, r1
    2528:	31 05       	cpc	r19, r1
    252a:	29 f4       	brne	.+10     	; 0x2536 <free+0x92>
    252c:	f0 93 ea 08 	sts	0x08EA, r31	; 0x8008ea <__flp+0x1>
    2530:	e0 93 e9 08 	sts	0x08E9, r30	; 0x8008e9 <__flp>
    2534:	3d c0       	rjmp	.+122    	; 0x25b0 <free+0x10c>
    2536:	e9 01       	movw	r28, r18
    2538:	fb 83       	std	Y+3, r31	; 0x03
    253a:	ea 83       	std	Y+2, r30	; 0x02
    253c:	49 91       	ld	r20, Y+
    253e:	59 91       	ld	r21, Y+
    2540:	c4 0f       	add	r28, r20
    2542:	d5 1f       	adc	r29, r21
    2544:	ec 17       	cp	r30, r28
    2546:	fd 07       	cpc	r31, r29
    2548:	61 f4       	brne	.+24     	; 0x2562 <free+0xbe>
    254a:	80 81       	ld	r24, Z
    254c:	91 81       	ldd	r25, Z+1	; 0x01
    254e:	84 0f       	add	r24, r20
    2550:	95 1f       	adc	r25, r21
    2552:	02 96       	adiw	r24, 0x02	; 2
    2554:	e9 01       	movw	r28, r18
    2556:	99 83       	std	Y+1, r25	; 0x01
    2558:	88 83       	st	Y, r24
    255a:	82 81       	ldd	r24, Z+2	; 0x02
    255c:	93 81       	ldd	r25, Z+3	; 0x03
    255e:	9b 83       	std	Y+3, r25	; 0x03
    2560:	8a 83       	std	Y+2, r24	; 0x02
    2562:	e0 e0       	ldi	r30, 0x00	; 0
    2564:	f0 e0       	ldi	r31, 0x00	; 0
    2566:	12 96       	adiw	r26, 0x02	; 2
    2568:	8d 91       	ld	r24, X+
    256a:	9c 91       	ld	r25, X
    256c:	13 97       	sbiw	r26, 0x03	; 3
    256e:	00 97       	sbiw	r24, 0x00	; 0
    2570:	19 f0       	breq	.+6      	; 0x2578 <free+0xd4>
    2572:	fd 01       	movw	r30, r26
    2574:	dc 01       	movw	r26, r24
    2576:	f7 cf       	rjmp	.-18     	; 0x2566 <free+0xc2>
    2578:	8d 91       	ld	r24, X+
    257a:	9c 91       	ld	r25, X
    257c:	11 97       	sbiw	r26, 0x01	; 1
    257e:	9d 01       	movw	r18, r26
    2580:	2e 5f       	subi	r18, 0xFE	; 254
    2582:	3f 4f       	sbci	r19, 0xFF	; 255
    2584:	82 0f       	add	r24, r18
    2586:	93 1f       	adc	r25, r19
    2588:	20 91 e7 08 	lds	r18, 0x08E7	; 0x8008e7 <__brkval>
    258c:	30 91 e8 08 	lds	r19, 0x08E8	; 0x8008e8 <__brkval+0x1>
    2590:	28 17       	cp	r18, r24
    2592:	39 07       	cpc	r19, r25
    2594:	69 f4       	brne	.+26     	; 0x25b0 <free+0x10c>
    2596:	30 97       	sbiw	r30, 0x00	; 0
    2598:	29 f4       	brne	.+10     	; 0x25a4 <free+0x100>
    259a:	10 92 ea 08 	sts	0x08EA, r1	; 0x8008ea <__flp+0x1>
    259e:	10 92 e9 08 	sts	0x08E9, r1	; 0x8008e9 <__flp>
    25a2:	02 c0       	rjmp	.+4      	; 0x25a8 <free+0x104>
    25a4:	13 82       	std	Z+3, r1	; 0x03
    25a6:	12 82       	std	Z+2, r1	; 0x02
    25a8:	b0 93 e8 08 	sts	0x08E8, r27	; 0x8008e8 <__brkval+0x1>
    25ac:	a0 93 e7 08 	sts	0x08E7, r26	; 0x8008e7 <__brkval>
    25b0:	df 91       	pop	r29
    25b2:	cf 91       	pop	r28
    25b4:	08 95       	ret

000025b6 <memset>:
    25b6:	dc 01       	movw	r26, r24
    25b8:	01 c0       	rjmp	.+2      	; 0x25bc <memset+0x6>
    25ba:	6d 93       	st	X+, r22
    25bc:	41 50       	subi	r20, 0x01	; 1
    25be:	50 40       	sbci	r21, 0x00	; 0
    25c0:	e0 f7       	brcc	.-8      	; 0x25ba <memset+0x4>
    25c2:	08 95       	ret

000025c4 <strncpy>:
    25c4:	fb 01       	movw	r30, r22
    25c6:	dc 01       	movw	r26, r24
    25c8:	41 50       	subi	r20, 0x01	; 1
    25ca:	50 40       	sbci	r21, 0x00	; 0
    25cc:	48 f0       	brcs	.+18     	; 0x25e0 <strncpy+0x1c>
    25ce:	01 90       	ld	r0, Z+
    25d0:	0d 92       	st	X+, r0
    25d2:	00 20       	and	r0, r0
    25d4:	c9 f7       	brne	.-14     	; 0x25c8 <strncpy+0x4>
    25d6:	01 c0       	rjmp	.+2      	; 0x25da <strncpy+0x16>
    25d8:	1d 92       	st	X+, r1
    25da:	41 50       	subi	r20, 0x01	; 1
    25dc:	50 40       	sbci	r21, 0x00	; 0
    25de:	e0 f7       	brcc	.-8      	; 0x25d8 <strncpy+0x14>
    25e0:	08 95       	ret

000025e2 <_exit>:
    25e2:	f8 94       	cli

000025e4 <__stop_program>:
    25e4:	ff cf       	rjmp	.-2      	; 0x25e4 <__stop_program>
