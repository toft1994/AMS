
RobotSorter.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000072  00800200  000020d8  0000216c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000020d8  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000061f  00800272  00800272  000021de  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000021de  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00002210  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000468  00000000  00000000  00002250  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00006312  00000000  00000000  000026b8  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00002b6f  00000000  00000000  000089ca  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000028a5  00000000  00000000  0000b539  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000d00  00000000  00000000  0000dde0  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00001b2a  00000000  00000000  0000eae0  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00002ef7  00000000  00000000  0001060a  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000390  00000000  00000000  00013501  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	71 c0       	rjmp	.+226    	; 0xe4 <__ctors_end>
       2:	00 00       	nop
       4:	8f c0       	rjmp	.+286    	; 0x124 <__bad_interrupt>
       6:	00 00       	nop
       8:	8d c0       	rjmp	.+282    	; 0x124 <__bad_interrupt>
       a:	00 00       	nop
       c:	8b c0       	rjmp	.+278    	; 0x124 <__bad_interrupt>
       e:	00 00       	nop
      10:	89 c0       	rjmp	.+274    	; 0x124 <__bad_interrupt>
      12:	00 00       	nop
      14:	87 c0       	rjmp	.+270    	; 0x124 <__bad_interrupt>
      16:	00 00       	nop
      18:	85 c0       	rjmp	.+266    	; 0x124 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	83 c0       	rjmp	.+262    	; 0x124 <__bad_interrupt>
      1e:	00 00       	nop
      20:	81 c0       	rjmp	.+258    	; 0x124 <__bad_interrupt>
      22:	00 00       	nop
      24:	7f c0       	rjmp	.+254    	; 0x124 <__bad_interrupt>
      26:	00 00       	nop
      28:	7d c0       	rjmp	.+250    	; 0x124 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	7b c0       	rjmp	.+246    	; 0x124 <__bad_interrupt>
      2e:	00 00       	nop
      30:	79 c0       	rjmp	.+242    	; 0x124 <__bad_interrupt>
      32:	00 00       	nop
      34:	77 c0       	rjmp	.+238    	; 0x124 <__bad_interrupt>
      36:	00 00       	nop
      38:	75 c0       	rjmp	.+234    	; 0x124 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	73 c0       	rjmp	.+230    	; 0x124 <__bad_interrupt>
      3e:	00 00       	nop
      40:	71 c0       	rjmp	.+226    	; 0x124 <__bad_interrupt>
      42:	00 00       	nop
      44:	6f c0       	rjmp	.+222    	; 0x124 <__bad_interrupt>
      46:	00 00       	nop
      48:	6d c0       	rjmp	.+218    	; 0x124 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	6b c0       	rjmp	.+214    	; 0x124 <__bad_interrupt>
      4e:	00 00       	nop
      50:	69 c0       	rjmp	.+210    	; 0x124 <__bad_interrupt>
      52:	00 00       	nop
      54:	0c 94 29 0a 	jmp	0x1452	; 0x1452 <__vector_21>
      58:	65 c0       	rjmp	.+202    	; 0x124 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	63 c0       	rjmp	.+198    	; 0x124 <__bad_interrupt>
      5e:	00 00       	nop
      60:	61 c0       	rjmp	.+194    	; 0x124 <__bad_interrupt>
      62:	00 00       	nop
      64:	5f c0       	rjmp	.+190    	; 0x124 <__bad_interrupt>
      66:	00 00       	nop
      68:	5d c0       	rjmp	.+186    	; 0x124 <__bad_interrupt>
      6a:	00 00       	nop
      6c:	5b c0       	rjmp	.+182    	; 0x124 <__bad_interrupt>
      6e:	00 00       	nop
      70:	59 c0       	rjmp	.+178    	; 0x124 <__bad_interrupt>
      72:	00 00       	nop
      74:	57 c0       	rjmp	.+174    	; 0x124 <__bad_interrupt>
      76:	00 00       	nop
      78:	55 c0       	rjmp	.+170    	; 0x124 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	53 c0       	rjmp	.+166    	; 0x124 <__bad_interrupt>
      7e:	00 00       	nop
      80:	51 c0       	rjmp	.+162    	; 0x124 <__bad_interrupt>
      82:	00 00       	nop
      84:	4f c0       	rjmp	.+158    	; 0x124 <__bad_interrupt>
      86:	00 00       	nop
      88:	4d c0       	rjmp	.+154    	; 0x124 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	4b c0       	rjmp	.+150    	; 0x124 <__bad_interrupt>
      8e:	00 00       	nop
      90:	49 c0       	rjmp	.+146    	; 0x124 <__bad_interrupt>
      92:	00 00       	nop
      94:	47 c0       	rjmp	.+142    	; 0x124 <__bad_interrupt>
      96:	00 00       	nop
      98:	45 c0       	rjmp	.+138    	; 0x124 <__bad_interrupt>
      9a:	00 00       	nop
      9c:	43 c0       	rjmp	.+134    	; 0x124 <__bad_interrupt>
      9e:	00 00       	nop
      a0:	41 c0       	rjmp	.+130    	; 0x124 <__bad_interrupt>
      a2:	00 00       	nop
      a4:	65 c0       	rjmp	.+202    	; 0x170 <__vector_41>
      a6:	00 00       	nop
      a8:	3d c0       	rjmp	.+122    	; 0x124 <__bad_interrupt>
      aa:	00 00       	nop
      ac:	3b c0       	rjmp	.+118    	; 0x124 <__bad_interrupt>
      ae:	00 00       	nop
      b0:	39 c0       	rjmp	.+114    	; 0x124 <__bad_interrupt>
      b2:	00 00       	nop
      b4:	38 c0       	rjmp	.+112    	; 0x126 <__vector_45>
      b6:	00 00       	nop
      b8:	35 c0       	rjmp	.+106    	; 0x124 <__bad_interrupt>
      ba:	00 00       	nop
      bc:	33 c0       	rjmp	.+102    	; 0x124 <__bad_interrupt>
      be:	00 00       	nop
      c0:	31 c0       	rjmp	.+98     	; 0x124 <__bad_interrupt>
      c2:	00 00       	nop
      c4:	2f c0       	rjmp	.+94     	; 0x124 <__bad_interrupt>
      c6:	00 00       	nop
      c8:	2d c0       	rjmp	.+90     	; 0x124 <__bad_interrupt>
      ca:	00 00       	nop
      cc:	2b c0       	rjmp	.+86     	; 0x124 <__bad_interrupt>
      ce:	00 00       	nop
      d0:	29 c0       	rjmp	.+82     	; 0x124 <__bad_interrupt>
      d2:	00 00       	nop
      d4:	27 c0       	rjmp	.+78     	; 0x124 <__bad_interrupt>
      d6:	00 00       	nop
      d8:	25 c0       	rjmp	.+74     	; 0x124 <__bad_interrupt>
      da:	00 00       	nop
      dc:	23 c0       	rjmp	.+70     	; 0x124 <__bad_interrupt>
      de:	00 00       	nop
      e0:	21 c0       	rjmp	.+66     	; 0x124 <__bad_interrupt>
	...

000000e4 <__ctors_end>:
      e4:	11 24       	eor	r1, r1
      e6:	1f be       	out	0x3f, r1	; 63
      e8:	cf ef       	ldi	r28, 0xFF	; 255
      ea:	d1 e2       	ldi	r29, 0x21	; 33
      ec:	de bf       	out	0x3e, r29	; 62
      ee:	cd bf       	out	0x3d, r28	; 61
      f0:	00 e0       	ldi	r16, 0x00	; 0
      f2:	0c bf       	out	0x3c, r16	; 60

000000f4 <__do_copy_data>:
      f4:	12 e0       	ldi	r17, 0x02	; 2
      f6:	a0 e0       	ldi	r26, 0x00	; 0
      f8:	b2 e0       	ldi	r27, 0x02	; 2
      fa:	e8 ed       	ldi	r30, 0xD8	; 216
      fc:	f0 e2       	ldi	r31, 0x20	; 32
      fe:	00 e0       	ldi	r16, 0x00	; 0
     100:	0b bf       	out	0x3b, r16	; 59
     102:	02 c0       	rjmp	.+4      	; 0x108 <__do_copy_data+0x14>
     104:	07 90       	elpm	r0, Z+
     106:	0d 92       	st	X+, r0
     108:	a2 37       	cpi	r26, 0x72	; 114
     10a:	b1 07       	cpc	r27, r17
     10c:	d9 f7       	brne	.-10     	; 0x104 <__do_copy_data+0x10>

0000010e <__do_clear_bss>:
     10e:	28 e0       	ldi	r18, 0x08	; 8
     110:	a2 e7       	ldi	r26, 0x72	; 114
     112:	b2 e0       	ldi	r27, 0x02	; 2
     114:	01 c0       	rjmp	.+2      	; 0x118 <.do_clear_bss_start>

00000116 <.do_clear_bss_loop>:
     116:	1d 92       	st	X+, r1

00000118 <.do_clear_bss_start>:
     118:	a1 39       	cpi	r26, 0x91	; 145
     11a:	b2 07       	cpc	r27, r18
     11c:	e1 f7       	brne	.-8      	; 0x116 <.do_clear_bss_loop>
     11e:	0a d1       	rcall	.+532    	; 0x334 <main>
     120:	0c 94 6a 10 	jmp	0x20d4	; 0x20d4 <_exit>

00000124 <__bad_interrupt>:
     124:	6d cf       	rjmp	.-294    	; 0x0 <__vectors>

00000126 <__vector_45>:
	
	return period;
}

ISR(TIMER4_OVF_vect)
{
     126:	1f 92       	push	r1
     128:	0f 92       	push	r0
     12a:	0f b6       	in	r0, 0x3f	; 63
     12c:	0f 92       	push	r0
     12e:	11 24       	eor	r1, r1
     130:	8f 93       	push	r24
     132:	9f 93       	push	r25
     134:	af 93       	push	r26
     136:	bf 93       	push	r27
	timeroverflow++;
     138:	80 91 74 02 	lds	r24, 0x0274	; 0x800274 <timeroverflow>
     13c:	90 91 75 02 	lds	r25, 0x0275	; 0x800275 <timeroverflow+0x1>
     140:	a0 91 76 02 	lds	r26, 0x0276	; 0x800276 <timeroverflow+0x2>
     144:	b0 91 77 02 	lds	r27, 0x0277	; 0x800277 <timeroverflow+0x3>
     148:	01 96       	adiw	r24, 0x01	; 1
     14a:	a1 1d       	adc	r26, r1
     14c:	b1 1d       	adc	r27, r1
     14e:	80 93 74 02 	sts	0x0274, r24	; 0x800274 <timeroverflow>
     152:	90 93 75 02 	sts	0x0275, r25	; 0x800275 <timeroverflow+0x1>
     156:	a0 93 76 02 	sts	0x0276, r26	; 0x800276 <timeroverflow+0x2>
     15a:	b0 93 77 02 	sts	0x0277, r27	; 0x800277 <timeroverflow+0x3>
}
     15e:	bf 91       	pop	r27
     160:	af 91       	pop	r26
     162:	9f 91       	pop	r25
     164:	8f 91       	pop	r24
     166:	0f 90       	pop	r0
     168:	0f be       	out	0x3f, r0	; 63
     16a:	0f 90       	pop	r0
     16c:	1f 90       	pop	r1
     16e:	18 95       	reti

00000170 <__vector_41>:

ISR(TIMER4_CAPT_vect)
{
     170:	1f 92       	push	r1
     172:	0f 92       	push	r0
     174:	0f b6       	in	r0, 0x3f	; 63
     176:	0f 92       	push	r0
     178:	11 24       	eor	r1, r1
     17a:	0b b6       	in	r0, 0x3b	; 59
     17c:	0f 92       	push	r0
     17e:	cf 92       	push	r12
     180:	df 92       	push	r13
     182:	ef 92       	push	r14
     184:	ff 92       	push	r15
     186:	0f 93       	push	r16
     188:	1f 93       	push	r17
     18a:	2f 93       	push	r18
     18c:	3f 93       	push	r19
     18e:	4f 93       	push	r20
     190:	5f 93       	push	r21
     192:	6f 93       	push	r22
     194:	7f 93       	push	r23
     196:	8f 93       	push	r24
     198:	9f 93       	push	r25
     19a:	af 93       	push	r26
     19c:	bf 93       	push	r27
     19e:	ef 93       	push	r30
     1a0:	ff 93       	push	r31
	// Read value of timer
	uint16_t readValue = ICR4;
     1a2:	60 91 a6 00 	lds	r22, 0x00A6	; 0x8000a6 <__TEXT_REGION_LENGTH__+0x7000a6>
     1a6:	70 91 a7 00 	lds	r23, 0x00A7	; 0x8000a7 <__TEXT_REGION_LENGTH__+0x7000a7>

	if ( first == true )
     1aa:	80 91 0a 02 	lds	r24, 0x020A	; 0x80020a <first>
     1ae:	88 23       	and	r24, r24
     1b0:	79 f0       	breq	.+30     	; 0x1d0 <__vector_41+0x60>
	{
		timeroverflow = 0U;
     1b2:	10 92 74 02 	sts	0x0274, r1	; 0x800274 <timeroverflow>
     1b6:	10 92 75 02 	sts	0x0275, r1	; 0x800275 <timeroverflow+0x1>
     1ba:	10 92 76 02 	sts	0x0276, r1	; 0x800276 <timeroverflow+0x2>
     1be:	10 92 77 02 	sts	0x0277, r1	; 0x800277 <timeroverflow+0x3>
		oldValue = readValue;
     1c2:	70 93 79 02 	sts	0x0279, r23	; 0x800279 <oldValue+0x1>
     1c6:	60 93 78 02 	sts	0x0278, r22	; 0x800278 <oldValue>
		first = false;
     1ca:	10 92 0a 02 	sts	0x020A, r1	; 0x80020a <first>
		return;
     1ce:	81 c0       	rjmp	.+258    	; 0x2d2 <__vector_41+0x162>
	}
	
	// Check if overflow is pending
	if ( TIFR4 & ( 1 << TOV4 ))
     1d0:	c8 9b       	sbis	0x19, 0	; 25
     1d2:	13 c0       	rjmp	.+38     	; 0x1fa <__vector_41+0x8a>
	{
		timeroverflow++;
     1d4:	80 91 74 02 	lds	r24, 0x0274	; 0x800274 <timeroverflow>
     1d8:	90 91 75 02 	lds	r25, 0x0275	; 0x800275 <timeroverflow+0x1>
     1dc:	a0 91 76 02 	lds	r26, 0x0276	; 0x800276 <timeroverflow+0x2>
     1e0:	b0 91 77 02 	lds	r27, 0x0277	; 0x800277 <timeroverflow+0x3>
     1e4:	01 96       	adiw	r24, 0x01	; 1
     1e6:	a1 1d       	adc	r26, r1
     1e8:	b1 1d       	adc	r27, r1
     1ea:	80 93 74 02 	sts	0x0274, r24	; 0x800274 <timeroverflow>
     1ee:	90 93 75 02 	sts	0x0275, r25	; 0x800275 <timeroverflow+0x1>
     1f2:	a0 93 76 02 	sts	0x0276, r26	; 0x800276 <timeroverflow+0x2>
     1f6:	b0 93 77 02 	sts	0x0277, r27	; 0x800277 <timeroverflow+0x3>
	}
		
	// Disable interrupt and clear pending
	TIMSK4 = 0U;	
     1fa:	10 92 72 00 	sts	0x0072, r1	; 0x800072 <__TEXT_REGION_LENGTH__+0x700072>
	TIFR4 = ( 1 << ICF4 ) | ( 1 << TOV4 );		
     1fe:	81 e2       	ldi	r24, 0x21	; 33
     200:	89 bb       	out	0x19, r24	; 25
			
	// Calculate difference
	uint32_t diff = 0U;

	if ( readValue < oldValue )
     202:	80 91 78 02 	lds	r24, 0x0278	; 0x800278 <oldValue>
     206:	90 91 79 02 	lds	r25, 0x0279	; 0x800279 <oldValue+0x1>
     20a:	68 17       	cp	r22, r24
     20c:	79 07       	cpc	r23, r25
     20e:	58 f5       	brcc	.+86     	; 0x266 <__vector_41+0xf6>
	{
		if ( timeroverflow != 0 )
     210:	80 91 74 02 	lds	r24, 0x0274	; 0x800274 <timeroverflow>
     214:	90 91 75 02 	lds	r25, 0x0275	; 0x800275 <timeroverflow+0x1>
     218:	a0 91 76 02 	lds	r26, 0x0276	; 0x800276 <timeroverflow+0x2>
     21c:	b0 91 77 02 	lds	r27, 0x0277	; 0x800277 <timeroverflow+0x3>
     220:	89 2b       	or	r24, r25
     222:	8a 2b       	or	r24, r26
     224:	8b 2b       	or	r24, r27
     226:	99 f0       	breq	.+38     	; 0x24e <__vector_41+0xde>
		{
			timeroverflow--;
     228:	80 91 74 02 	lds	r24, 0x0274	; 0x800274 <timeroverflow>
     22c:	90 91 75 02 	lds	r25, 0x0275	; 0x800275 <timeroverflow+0x1>
     230:	a0 91 76 02 	lds	r26, 0x0276	; 0x800276 <timeroverflow+0x2>
     234:	b0 91 77 02 	lds	r27, 0x0277	; 0x800277 <timeroverflow+0x3>
     238:	01 97       	sbiw	r24, 0x01	; 1
     23a:	a1 09       	sbc	r26, r1
     23c:	b1 09       	sbc	r27, r1
     23e:	80 93 74 02 	sts	0x0274, r24	; 0x800274 <timeroverflow>
     242:	90 93 75 02 	sts	0x0275, r25	; 0x800275 <timeroverflow+0x1>
     246:	a0 93 76 02 	sts	0x0276, r26	; 0x800276 <timeroverflow+0x2>
     24a:	b0 93 77 02 	sts	0x0277, r27	; 0x800277 <timeroverflow+0x3>
		}
		diff = ( 0xFFFF - oldValue ) + readValue;
     24e:	80 91 78 02 	lds	r24, 0x0278	; 0x800278 <oldValue>
     252:	90 91 79 02 	lds	r25, 0x0279	; 0x800279 <oldValue+0x1>
     256:	68 1b       	sub	r22, r24
     258:	79 0b       	sbc	r23, r25
     25a:	61 50       	subi	r22, 0x01	; 1
     25c:	71 09       	sbc	r23, r1
     25e:	cb 01       	movw	r24, r22
     260:	a0 e0       	ldi	r26, 0x00	; 0
     262:	b0 e0       	ldi	r27, 0x00	; 0
     264:	09 c0       	rjmp	.+18     	; 0x278 <__vector_41+0x108>
	}
	else
	{
		diff = readValue - oldValue;
     266:	80 91 78 02 	lds	r24, 0x0278	; 0x800278 <oldValue>
     26a:	90 91 79 02 	lds	r25, 0x0279	; 0x800279 <oldValue+0x1>
     26e:	68 1b       	sub	r22, r24
     270:	79 0b       	sbc	r23, r25
     272:	cb 01       	movw	r24, r22
     274:	a0 e0       	ldi	r26, 0x00	; 0
     276:	b0 e0       	ldi	r27, 0x00	; 0
	}
	
	// Add timeroverflow to total diff
	diff += timeroverflow << 16U;
     278:	40 91 74 02 	lds	r20, 0x0274	; 0x800274 <timeroverflow>
     27c:	50 91 75 02 	lds	r21, 0x0275	; 0x800275 <timeroverflow+0x1>
     280:	60 91 76 02 	lds	r22, 0x0276	; 0x800276 <timeroverflow+0x2>
     284:	70 91 77 02 	lds	r23, 0x0277	; 0x800277 <timeroverflow+0x3>
     288:	ba 01       	movw	r22, r20
     28a:	55 27       	eor	r21, r21
     28c:	44 27       	eor	r20, r20
     28e:	8a 01       	movw	r16, r20
     290:	9b 01       	movw	r18, r22
     292:	08 0f       	add	r16, r24
     294:	19 1f       	adc	r17, r25
     296:	2a 1f       	adc	r18, r26
     298:	3b 1f       	adc	r19, r27
     29a:	c9 01       	movw	r24, r18
     29c:	b8 01       	movw	r22, r16
	
	// Calculate period
	period = diff * tick * 1000000;
     29e:	c0 90 06 02 	lds	r12, 0x0206	; 0x800206 <tick>
     2a2:	d0 90 07 02 	lds	r13, 0x0207	; 0x800207 <tick+0x1>
     2a6:	e0 90 08 02 	lds	r14, 0x0208	; 0x800208 <tick+0x2>
     2aa:	f0 90 09 02 	lds	r15, 0x0209	; 0x800209 <tick+0x3>
     2ae:	0e 94 0b 0e 	call	0x1c16	; 0x1c16 <__floatunsisf>
     2b2:	a7 01       	movw	r20, r14
     2b4:	96 01       	movw	r18, r12
     2b6:	0e 94 c1 0e 	call	0x1d82	; 0x1d82 <__mulsf3>
     2ba:	20 e0       	ldi	r18, 0x00	; 0
     2bc:	34 e2       	ldi	r19, 0x24	; 36
     2be:	44 e7       	ldi	r20, 0x74	; 116
     2c0:	59 e4       	ldi	r21, 0x49	; 73
     2c2:	0e 94 c1 0e 	call	0x1d82	; 0x1d82 <__mulsf3>
     2c6:	0e 94 df 0d 	call	0x1bbe	; 0x1bbe <__fixunssfsi>
     2ca:	70 93 73 02 	sts	0x0273, r23	; 0x800273 <__data_end+0x1>
     2ce:	60 93 72 02 	sts	0x0272, r22	; 0x800272 <__data_end>
     2d2:	ff 91       	pop	r31
     2d4:	ef 91       	pop	r30
     2d6:	bf 91       	pop	r27
     2d8:	af 91       	pop	r26
     2da:	9f 91       	pop	r25
     2dc:	8f 91       	pop	r24
     2de:	7f 91       	pop	r23
     2e0:	6f 91       	pop	r22
     2e2:	5f 91       	pop	r21
     2e4:	4f 91       	pop	r20
     2e6:	3f 91       	pop	r19
     2e8:	2f 91       	pop	r18
     2ea:	1f 91       	pop	r17
     2ec:	0f 91       	pop	r16
     2ee:	ff 90       	pop	r15
     2f0:	ef 90       	pop	r14
     2f2:	df 90       	pop	r13
     2f4:	cf 90       	pop	r12
     2f6:	0f 90       	pop	r0
     2f8:	0b be       	out	0x3b, r0	; 59
     2fa:	0f 90       	pop	r0
     2fc:	0f be       	out	0x3f, r0	; 63
     2fe:	0f 90       	pop	r0
     300:	1f 90       	pop	r1
     302:	18 95       	reti

00000304 <__cxa_pure_virtual>:
void * operator new(size_t size);
void operator delete(void * ptr);

int __cxa_guard_acquire(__guard *g) {return !*(char *)(g);};
void __cxa_guard_release (__guard *g) {*(char *)g = 1;};
void __cxa_guard_abort (__guard *) {};
     304:	ff cf       	rjmp	.-2      	; 0x304 <__cxa_pure_virtual>

00000306 <_Znwj>:

void * operator new(size_t size)
{
	return malloc(size);
     306:	0c 94 33 0f 	jmp	0x1e66	; 0x1e66 <malloc>
}
     30a:	08 95       	ret

0000030c <_ZdlPv>:

void operator delete(void * ptr)
{
	ptr != NULL ? free(ptr) : void(0);
     30c:	00 97       	sbiw	r24, 0x00	; 0
     30e:	11 f0       	breq	.+4      	; 0x314 <_ZdlPv+0x8>
     310:	0c 94 cb 0f 	jmp	0x1f96	; 0x1f96 <free>
     314:	08 95       	ret

00000316 <_Z16RobotarmTestMainPv>:
 */ 

#include "RobotArm.h"

void RobotarmTestMain( void* armPtr )
{
     316:	ec 01       	movw	r28, r24
	Robotarm* arm = ( Robotarm* ) armPtr;
	
	while (1)
	{
		arm->grabBlock();
     318:	ce 01       	movw	r24, r28
     31a:	a0 d0       	rcall	.+320    	; 0x45c <_ZN8Robotarm9grabBlockEv>
		vTaskDelay( 500 / portTICK_RATE_MS );
     31c:	84 ef       	ldi	r24, 0xF4	; 244
     31e:	91 e0       	ldi	r25, 0x01	; 1
     320:	0e 94 00 0d 	call	0x1a00	; 0x1a00 <vTaskDelay>
		arm->moveBlockToZoneOne();
     324:	ce 01       	movw	r24, r28
     326:	58 d1       	rcall	.+688    	; 0x5d8 <_ZN8Robotarm18moveBlockToZoneOneEv>
		vTaskDelay( 500 / portTICK_RATE_MS );
     328:	84 ef       	ldi	r24, 0xF4	; 244
     32a:	91 e0       	ldi	r25, 0x01	; 1
     32c:	0e 94 00 0d 	call	0x1a00	; 0x1a00 <vTaskDelay>
     330:	f3 cf       	rjmp	.-26     	; 0x318 <_Z16RobotarmTestMainPv+0x2>

00000332 <_Z9FirstTaskPv>:

#include "RobotArm/Test/RobotArmTestMain.h"

void FirstTask( void *pvParameters )
{
	RobotarmTestMain( pvParameters );
     332:	f1 df       	rcall	.-30     	; 0x316 <_Z16RobotarmTestMainPv>

00000334 <main>:
		vTaskDelay(100/portTICK_RATE_MS);
	}
}

int main(void)
{
     334:	cf 93       	push	r28
     336:	df 93       	push	r29
     338:	cd b7       	in	r28, 0x3d	; 61
     33a:	de b7       	in	r29, 0x3e	; 62
     33c:	2e 97       	sbiw	r28, 0x0e	; 14
     33e:	0f b6       	in	r0, 0x3f	; 63
     340:	f8 94       	cli
     342:	de bf       	out	0x3e, r29	; 62
     344:	0f be       	out	0x3f, r0	; 63
     346:	cd bf       	out	0x3d, r28	; 61
	Robotarm arm = Robotarm();
     348:	ce 01       	movw	r24, r28
     34a:	01 96       	adiw	r24, 0x01	; 1
     34c:	2b d0       	rcall	.+86     	; 0x3a4 <_ZN8RobotarmC1Ev>
	xTaskCreate(FirstTask,  ( signed char * ) "Task", configMAIN_STACK_SIZE, &arm, tskIDLE_PRIORITY, NULL);
     34e:	a1 2c       	mov	r10, r1
     350:	b1 2c       	mov	r11, r1
     352:	c1 2c       	mov	r12, r1
     354:	d1 2c       	mov	r13, r1
     356:	e1 2c       	mov	r14, r1
     358:	f1 2c       	mov	r15, r1
     35a:	00 e0       	ldi	r16, 0x00	; 0
     35c:	9e 01       	movw	r18, r28
     35e:	2f 5f       	subi	r18, 0xFF	; 255
     360:	3f 4f       	sbci	r19, 0xFF	; 255
     362:	48 ec       	ldi	r20, 0xC8	; 200
     364:	50 e0       	ldi	r21, 0x00	; 0
     366:	6d e0       	ldi	r22, 0x0D	; 13
     368:	72 e0       	ldi	r23, 0x02	; 2
     36a:	89 e9       	ldi	r24, 0x99	; 153
     36c:	91 e0       	ldi	r25, 0x01	; 1
     36e:	0e 94 01 0b 	call	0x1602	; 0x1602 <xTaskGenericCreate>
	vTaskStartScheduler();
     372:	0e 94 b9 0b 	call	0x1772	; 0x1772 <vTaskStartScheduler>
     376:	ff cf       	rjmp	.-2      	; 0x376 <main+0x42>

00000378 <_ZN8Robotarm14startMotorImplEPv>:
	motors_[3]->SetDegrees(90);
	vTaskDelay( 250 / portTICK_RATE_MS );
}

void Robotarm::startMotorImpl( void *_this )
{
     378:	8c 01       	movw	r16, r24
void Robotarm::MotorSpeedController()
{
	while(1)
	{
		/* Move all motors one step. */
		for ( uint8_t i = 0U; i < 6U; i++ )
     37a:	c0 e0       	ldi	r28, 0x00	; 0
     37c:	c6 30       	cpi	r28, 0x06	; 6
     37e:	e8 f7       	brcc	.-6      	; 0x37a <_ZN8Robotarm14startMotorImplEPv+0x2>
		{
			motors_[i]->TurnMotor();
     380:	ec 2f       	mov	r30, r28
     382:	f0 e0       	ldi	r31, 0x00	; 0
     384:	31 96       	adiw	r30, 0x01	; 1
     386:	ee 0f       	add	r30, r30
     388:	ff 1f       	adc	r31, r31
     38a:	e0 0f       	add	r30, r16
     38c:	f1 1f       	adc	r31, r17
     38e:	80 81       	ld	r24, Z
     390:	91 81       	ldd	r25, Z+1	; 0x01
     392:	dc 01       	movw	r26, r24
     394:	ed 91       	ld	r30, X+
     396:	fc 91       	ld	r31, X
     398:	04 80       	ldd	r0, Z+4	; 0x04
     39a:	f5 81       	ldd	r31, Z+5	; 0x05
     39c:	e0 2d       	mov	r30, r0
     39e:	19 95       	eicall
void Robotarm::MotorSpeedController()
{
	while(1)
	{
		/* Move all motors one step. */
		for ( uint8_t i = 0U; i < 6U; i++ )
     3a0:	cf 5f       	subi	r28, 0xFF	; 255
     3a2:	ec cf       	rjmp	.-40     	; 0x37c <_ZN8Robotarm14startMotorImplEPv+0x4>

000003a4 <_ZN8RobotarmC1Ev>:
/* RTOS include */
#include "FreeRTOS.h"
#include "task.h"
#include "portmacro.h"

Robotarm::Robotarm() : tmr1_(), tmr3_()
     3a4:	af 92       	push	r10
     3a6:	bf 92       	push	r11
     3a8:	cf 92       	push	r12
     3aa:	df 92       	push	r13
     3ac:	ef 92       	push	r14
     3ae:	ff 92       	push	r15
     3b0:	0f 93       	push	r16
     3b2:	1f 93       	push	r17
     3b4:	cf 93       	push	r28
     3b6:	df 93       	push	r29
     3b8:	ec 01       	movw	r28, r24
     3ba:	19 d5       	rcall	.+2610   	; 0xdee <_ZN6Timer1C1Ev>
     3bc:	8e 01       	movw	r16, r28
     3be:	0f 5f       	subi	r16, 0xFF	; 255
     3c0:	1f 4f       	sbci	r17, 0xFF	; 255
     3c2:	c8 01       	movw	r24, r16
     3c4:	ad d5       	rcall	.+2906   	; 0xf20 <_ZN6Timer5C1Ev>
{
	/* Create all motor objects */
	motors_[0] = new M1( &tmr1_ );
     3c6:	89 e1       	ldi	r24, 0x19	; 25
     3c8:	90 e0       	ldi	r25, 0x00	; 0
     3ca:	9d df       	rcall	.-198    	; 0x306 <_Znwj>
     3cc:	7c 01       	movw	r14, r24
     3ce:	be 01       	movw	r22, r28
     3d0:	b0 d1       	rcall	.+864    	; 0x732 <_ZN2M1C1EP6Timer1>
     3d2:	fb 82       	std	Y+3, r15	; 0x03
     3d4:	ea 82       	std	Y+2, r14	; 0x02
	motors_[1] = new M2( &tmr1_ );
     3d6:	89 e1       	ldi	r24, 0x19	; 25
     3d8:	90 e0       	ldi	r25, 0x00	; 0
     3da:	95 df       	rcall	.-214    	; 0x306 <_Znwj>
     3dc:	7c 01       	movw	r14, r24
     3de:	be 01       	movw	r22, r28
     3e0:	4e d2       	rcall	.+1180   	; 0x87e <_ZN2M2C1EP6Timer1>
     3e2:	fd 82       	std	Y+5, r15	; 0x05
     3e4:	ec 82       	std	Y+4, r14	; 0x04
	motors_[2] = new M3( &tmr1_ );
     3e6:	89 e1       	ldi	r24, 0x19	; 25
     3e8:	90 e0       	ldi	r25, 0x00	; 0
     3ea:	8d df       	rcall	.-230    	; 0x306 <_Znwj>
     3ec:	7c 01       	movw	r14, r24
     3ee:	be 01       	movw	r22, r28
     3f0:	ec d2       	rcall	.+1496   	; 0x9ca <_ZN2M3C1EP6Timer1>
     3f2:	ff 82       	std	Y+7, r15	; 0x07
     3f4:	ee 82       	std	Y+6, r14	; 0x06
	motors_[3] = new M4( &tmr3_ );
     3f6:	89 e1       	ldi	r24, 0x19	; 25
     3f8:	90 e0       	ldi	r25, 0x00	; 0
     3fa:	85 df       	rcall	.-246    	; 0x306 <_Znwj>
     3fc:	7c 01       	movw	r14, r24
     3fe:	b8 01       	movw	r22, r16
     400:	88 d3       	rcall	.+1808   	; 0xb12 <_ZN2M4C1EP6Timer5>
     402:	f9 86       	std	Y+9, r15	; 0x09
     404:	e8 86       	std	Y+8, r14	; 0x08
	motors_[4] = new M5( &tmr3_ );
     406:	89 e1       	ldi	r24, 0x19	; 25
     408:	90 e0       	ldi	r25, 0x00	; 0
     40a:	7d df       	rcall	.-262    	; 0x306 <_Znwj>
     40c:	7c 01       	movw	r14, r24
     40e:	b8 01       	movw	r22, r16
     410:	21 d4       	rcall	.+2114   	; 0xc54 <_ZN2M5C1EP6Timer5>
     412:	fb 86       	std	Y+11, r15	; 0x0b
     414:	ea 86       	std	Y+10, r14	; 0x0a
	motors_[5] = new M6( &tmr3_ );
     416:	89 e1       	ldi	r24, 0x19	; 25
     418:	90 e0       	ldi	r25, 0x00	; 0
     41a:	75 df       	rcall	.-278    	; 0x306 <_Znwj>
     41c:	7c 01       	movw	r14, r24
     41e:	b8 01       	movw	r22, r16
     420:	b6 d4       	rcall	.+2412   	; 0xd8e <_ZN2M6C1EP6Timer5>
     422:	fd 86       	std	Y+13, r15	; 0x0d
     424:	ec 86       	std	Y+12, r14	; 0x0c
     426:	a1 2c       	mov	r10, r1
     428:	b1 2c       	mov	r11, r1
	
	/* Create task to control motors */
	xTaskCreate(this->startMotorImpl,  ( signed char * ) "Motors", configMAIN_STACK_SIZE, this, tskIDLE_PRIORITY, NULL);
     42a:	c1 2c       	mov	r12, r1
     42c:	d1 2c       	mov	r13, r1
     42e:	e1 2c       	mov	r14, r1
     430:	f1 2c       	mov	r15, r1
     432:	00 e0       	ldi	r16, 0x00	; 0
     434:	9e 01       	movw	r18, r28
     436:	48 ec       	ldi	r20, 0xC8	; 200
     438:	50 e0       	ldi	r21, 0x00	; 0
     43a:	62 e1       	ldi	r22, 0x12	; 18
     43c:	72 e0       	ldi	r23, 0x02	; 2
     43e:	8c eb       	ldi	r24, 0xBC	; 188
     440:	91 e0       	ldi	r25, 0x01	; 1
     442:	0e 94 01 0b 	call	0x1602	; 0x1602 <xTaskGenericCreate>
     446:	df 91       	pop	r29
     448:	cf 91       	pop	r28
}
     44a:	1f 91       	pop	r17
     44c:	0f 91       	pop	r16
     44e:	ff 90       	pop	r15
     450:	ef 90       	pop	r14
     452:	df 90       	pop	r13
     454:	cf 90       	pop	r12
     456:	bf 90       	pop	r11
     458:	af 90       	pop	r10
     45a:	08 95       	ret

0000045c <_ZN8Robotarm9grabBlockEv>:
     45c:	cf 93       	push	r28
     45e:	df 93       	push	r29

void Robotarm::grabBlock()
{
     460:	ec 01       	movw	r28, r24
	motors_[3]->SetDegrees(40);
     462:	88 85       	ldd	r24, Y+8	; 0x08
     464:	99 85       	ldd	r25, Y+9	; 0x09
     466:	dc 01       	movw	r26, r24
     468:	ed 91       	ld	r30, X+
     46a:	fc 91       	ld	r31, X
     46c:	06 80       	ldd	r0, Z+6	; 0x06
     46e:	f7 81       	ldd	r31, Z+7	; 0x07
     470:	e0 2d       	mov	r30, r0
     472:	68 e2       	ldi	r22, 0x28	; 40
     474:	19 95       	eicall
	motors_[4]->SetDegrees(90);
     476:	8a 85       	ldd	r24, Y+10	; 0x0a
     478:	9b 85       	ldd	r25, Y+11	; 0x0b
     47a:	dc 01       	movw	r26, r24
     47c:	ed 91       	ld	r30, X+
     47e:	fc 91       	ld	r31, X
     480:	06 80       	ldd	r0, Z+6	; 0x06
     482:	f7 81       	ldd	r31, Z+7	; 0x07
     484:	e0 2d       	mov	r30, r0
     486:	6a e5       	ldi	r22, 0x5A	; 90
     488:	19 95       	eicall
	motors_[0]->SetDegrees(0);
     48a:	8a 81       	ldd	r24, Y+2	; 0x02
     48c:	9b 81       	ldd	r25, Y+3	; 0x03
     48e:	dc 01       	movw	r26, r24
     490:	ed 91       	ld	r30, X+
     492:	fc 91       	ld	r31, X
     494:	06 80       	ldd	r0, Z+6	; 0x06
     496:	f7 81       	ldd	r31, Z+7	; 0x07
     498:	e0 2d       	mov	r30, r0
     49a:	60 e0       	ldi	r22, 0x00	; 0
     49c:	19 95       	eicall
	vTaskDelay( 1500 / portTICK_RATE_MS );
     49e:	8c ed       	ldi	r24, 0xDC	; 220
     4a0:	95 e0       	ldi	r25, 0x05	; 5
     4a2:	0e 94 00 0d 	call	0x1a00	; 0x1a00 <vTaskDelay>
	motors_[1]->SetDegrees(35);
     4a6:	8c 81       	ldd	r24, Y+4	; 0x04
     4a8:	9d 81       	ldd	r25, Y+5	; 0x05
     4aa:	dc 01       	movw	r26, r24
     4ac:	ed 91       	ld	r30, X+
     4ae:	fc 91       	ld	r31, X
     4b0:	06 80       	ldd	r0, Z+6	; 0x06
     4b2:	f7 81       	ldd	r31, Z+7	; 0x07
     4b4:	e0 2d       	mov	r30, r0
     4b6:	63 e2       	ldi	r22, 0x23	; 35
     4b8:	19 95       	eicall
	motors_[2]->SetDegrees(63);
     4ba:	8e 81       	ldd	r24, Y+6	; 0x06
     4bc:	9f 81       	ldd	r25, Y+7	; 0x07
     4be:	dc 01       	movw	r26, r24
     4c0:	ed 91       	ld	r30, X+
     4c2:	fc 91       	ld	r31, X
     4c4:	06 80       	ldd	r0, Z+6	; 0x06
     4c6:	f7 81       	ldd	r31, Z+7	; 0x07
     4c8:	e0 2d       	mov	r30, r0
     4ca:	6f e3       	ldi	r22, 0x3F	; 63
     4cc:	19 95       	eicall
	vTaskDelay( 1500 / portTICK_RATE_MS );
     4ce:	8c ed       	ldi	r24, 0xDC	; 220
     4d0:	95 e0       	ldi	r25, 0x05	; 5
     4d2:	0e 94 00 0d 	call	0x1a00	; 0x1a00 <vTaskDelay>
	motors_[5]->SetDegrees(63);
     4d6:	8c 85       	ldd	r24, Y+12	; 0x0c
     4d8:	9d 85       	ldd	r25, Y+13	; 0x0d
     4da:	dc 01       	movw	r26, r24
     4dc:	ed 91       	ld	r30, X+
     4de:	fc 91       	ld	r31, X
     4e0:	06 80       	ldd	r0, Z+6	; 0x06
     4e2:	f7 81       	ldd	r31, Z+7	; 0x07
     4e4:	e0 2d       	mov	r30, r0
     4e6:	6f e3       	ldi	r22, 0x3F	; 63
     4e8:	19 95       	eicall
	vTaskDelay( 250 / portTICK_RATE_MS );
     4ea:	8a ef       	ldi	r24, 0xFA	; 250
     4ec:	90 e0       	ldi	r25, 0x00	; 0
     4ee:	0e 94 00 0d 	call	0x1a00	; 0x1a00 <vTaskDelay>
	motors_[1]->SetDegrees(70);
     4f2:	8c 81       	ldd	r24, Y+4	; 0x04
     4f4:	9d 81       	ldd	r25, Y+5	; 0x05
     4f6:	dc 01       	movw	r26, r24
     4f8:	ed 91       	ld	r30, X+
     4fa:	fc 91       	ld	r31, X
     4fc:	06 80       	ldd	r0, Z+6	; 0x06
     4fe:	f7 81       	ldd	r31, Z+7	; 0x07
     500:	e0 2d       	mov	r30, r0
     502:	66 e4       	ldi	r22, 0x46	; 70
     504:	19 95       	eicall
	motors_[2]->SetDegrees(70);
     506:	8e 81       	ldd	r24, Y+6	; 0x06
     508:	9f 81       	ldd	r25, Y+7	; 0x07
     50a:	dc 01       	movw	r26, r24
     50c:	ed 91       	ld	r30, X+
     50e:	fc 91       	ld	r31, X
     510:	06 80       	ldd	r0, Z+6	; 0x06
     512:	f7 81       	ldd	r31, Z+7	; 0x07
     514:	e0 2d       	mov	r30, r0
     516:	66 e4       	ldi	r22, 0x46	; 70
     518:	19 95       	eicall
	motors_[3]->SetDegrees(70);
     51a:	88 85       	ldd	r24, Y+8	; 0x08
     51c:	99 85       	ldd	r25, Y+9	; 0x09
     51e:	dc 01       	movw	r26, r24
     520:	ed 91       	ld	r30, X+
     522:	fc 91       	ld	r31, X
     524:	06 80       	ldd	r0, Z+6	; 0x06
     526:	f7 81       	ldd	r31, Z+7	; 0x07
     528:	e0 2d       	mov	r30, r0
     52a:	66 e4       	ldi	r22, 0x46	; 70
     52c:	19 95       	eicall
}
     52e:	df 91       	pop	r29
     530:	cf 91       	pop	r28
     532:	08 95       	ret

00000534 <_ZN8Robotarm18ArmDownReleaseItemEv>:
	motors_[0]->SetDegrees(180);
	ArmDownReleaseItem();
}

void Robotarm::ArmDownReleaseItem()
{
     534:	cf 93       	push	r28
     536:	df 93       	push	r29
     538:	ec 01       	movw	r28, r24
	vTaskDelay( 1500 / portTICK_RATE_MS );
     53a:	8c ed       	ldi	r24, 0xDC	; 220
     53c:	95 e0       	ldi	r25, 0x05	; 5
     53e:	0e 94 00 0d 	call	0x1a00	; 0x1a00 <vTaskDelay>
	motors_[1]->SetDegrees(35);
     542:	8c 81       	ldd	r24, Y+4	; 0x04
     544:	9d 81       	ldd	r25, Y+5	; 0x05
     546:	dc 01       	movw	r26, r24
     548:	ed 91       	ld	r30, X+
     54a:	fc 91       	ld	r31, X
     54c:	06 80       	ldd	r0, Z+6	; 0x06
     54e:	f7 81       	ldd	r31, Z+7	; 0x07
     550:	e0 2d       	mov	r30, r0
     552:	63 e2       	ldi	r22, 0x23	; 35
     554:	19 95       	eicall
	motors_[2]->SetDegrees(40);
     556:	8e 81       	ldd	r24, Y+6	; 0x06
     558:	9f 81       	ldd	r25, Y+7	; 0x07
     55a:	dc 01       	movw	r26, r24
     55c:	ed 91       	ld	r30, X+
     55e:	fc 91       	ld	r31, X
     560:	06 80       	ldd	r0, Z+6	; 0x06
     562:	f7 81       	ldd	r31, Z+7	; 0x07
     564:	e0 2d       	mov	r30, r0
     566:	68 e2       	ldi	r22, 0x28	; 40
     568:	19 95       	eicall
	vTaskDelay( 1500 / portTICK_RATE_MS );
     56a:	8c ed       	ldi	r24, 0xDC	; 220
     56c:	95 e0       	ldi	r25, 0x05	; 5
     56e:	0e 94 00 0d 	call	0x1a00	; 0x1a00 <vTaskDelay>
	motors_[5]->SetDegrees(0);
     572:	8c 85       	ldd	r24, Y+12	; 0x0c
     574:	9d 85       	ldd	r25, Y+13	; 0x0d
     576:	dc 01       	movw	r26, r24
     578:	ed 91       	ld	r30, X+
     57a:	fc 91       	ld	r31, X
     57c:	06 80       	ldd	r0, Z+6	; 0x06
     57e:	f7 81       	ldd	r31, Z+7	; 0x07
     580:	e0 2d       	mov	r30, r0
     582:	60 e0       	ldi	r22, 0x00	; 0
     584:	19 95       	eicall
	vTaskDelay( 250 / portTICK_RATE_MS );
     586:	8a ef       	ldi	r24, 0xFA	; 250
     588:	90 e0       	ldi	r25, 0x00	; 0
     58a:	0e 94 00 0d 	call	0x1a00	; 0x1a00 <vTaskDelay>
	motors_[1]->SetDegrees(90);
     58e:	8c 81       	ldd	r24, Y+4	; 0x04
     590:	9d 81       	ldd	r25, Y+5	; 0x05
     592:	dc 01       	movw	r26, r24
     594:	ed 91       	ld	r30, X+
     596:	fc 91       	ld	r31, X
     598:	06 80       	ldd	r0, Z+6	; 0x06
     59a:	f7 81       	ldd	r31, Z+7	; 0x07
     59c:	e0 2d       	mov	r30, r0
     59e:	6a e5       	ldi	r22, 0x5A	; 90
     5a0:	19 95       	eicall
	motors_[2]->SetDegrees(90);
     5a2:	8e 81       	ldd	r24, Y+6	; 0x06
     5a4:	9f 81       	ldd	r25, Y+7	; 0x07
     5a6:	dc 01       	movw	r26, r24
     5a8:	ed 91       	ld	r30, X+
     5aa:	fc 91       	ld	r31, X
     5ac:	06 80       	ldd	r0, Z+6	; 0x06
     5ae:	f7 81       	ldd	r31, Z+7	; 0x07
     5b0:	e0 2d       	mov	r30, r0
     5b2:	6a e5       	ldi	r22, 0x5A	; 90
     5b4:	19 95       	eicall
	motors_[3]->SetDegrees(90);
     5b6:	88 85       	ldd	r24, Y+8	; 0x08
     5b8:	99 85       	ldd	r25, Y+9	; 0x09
     5ba:	dc 01       	movw	r26, r24
     5bc:	ed 91       	ld	r30, X+
     5be:	fc 91       	ld	r31, X
     5c0:	06 80       	ldd	r0, Z+6	; 0x06
     5c2:	f7 81       	ldd	r31, Z+7	; 0x07
     5c4:	e0 2d       	mov	r30, r0
     5c6:	6a e5       	ldi	r22, 0x5A	; 90
     5c8:	19 95       	eicall
	vTaskDelay( 250 / portTICK_RATE_MS );
     5ca:	8a ef       	ldi	r24, 0xFA	; 250
     5cc:	90 e0       	ldi	r25, 0x00	; 0
     5ce:	0e 94 00 0d 	call	0x1a00	; 0x1a00 <vTaskDelay>
}
     5d2:	df 91       	pop	r29
     5d4:	cf 91       	pop	r28
     5d6:	08 95       	ret

000005d8 <_ZN8Robotarm18moveBlockToZoneOneEv>:
	motors_[2]->SetDegrees(70);
	motors_[3]->SetDegrees(70);
}

void Robotarm::moveBlockToZoneOne()
{
     5d8:	cf 93       	push	r28
     5da:	df 93       	push	r29
     5dc:	ec 01       	movw	r28, r24
	motors_[0]->SetDegrees(90);
     5de:	8a 81       	ldd	r24, Y+2	; 0x02
     5e0:	9b 81       	ldd	r25, Y+3	; 0x03
     5e2:	dc 01       	movw	r26, r24
     5e4:	ed 91       	ld	r30, X+
     5e6:	fc 91       	ld	r31, X
     5e8:	06 80       	ldd	r0, Z+6	; 0x06
     5ea:	f7 81       	ldd	r31, Z+7	; 0x07
     5ec:	e0 2d       	mov	r30, r0
     5ee:	6a e5       	ldi	r22, 0x5A	; 90
     5f0:	19 95       	eicall
	ArmDownReleaseItem();
     5f2:	ce 01       	movw	r24, r28
     5f4:	9f df       	rcall	.-194    	; 0x534 <_ZN8Robotarm18ArmDownReleaseItemEv>
}
     5f6:	df 91       	pop	r29
     5f8:	cf 91       	pop	r28
     5fa:	08 95       	ret

000005fc <_ZN5Motor10SetDegreesEh>:
	*	 can be used to turn motor at a specific speed set by \ref delay. C
	*	 Note that this function needs to run multiple times to work as intended.
	*    @param uint8_t	degrees to turn
	*    @return void Nothing
	*/
	virtual void SetDegrees( uint8_t degrees )
     5fc:	cf 92       	push	r12
     5fe:	df 92       	push	r13
     600:	ef 92       	push	r14
     602:	ff 92       	push	r15
     604:	cf 93       	push	r28
     606:	df 93       	push	r29
	{
		if ( maxDegrees_ >= degrees )
     608:	fc 01       	movw	r30, r24
     60a:	26 89       	ldd	r18, Z+22	; 0x16
     60c:	26 17       	cp	r18, r22
     60e:	c0 f0       	brcs	.+48     	; 0x640 <_ZN5Motor10SetDegreesEh+0x44>
     610:	ec 01       	movw	r28, r24
		{
			percent_ = percentPrDeg * degrees + startpercent_;
     612:	c6 80       	ldd	r12, Z+6	; 0x06
     614:	d7 80       	ldd	r13, Z+7	; 0x07
     616:	e0 84       	ldd	r14, Z+8	; 0x08
     618:	f1 84       	ldd	r15, Z+9	; 0x09
     61a:	70 e0       	ldi	r23, 0x00	; 0
     61c:	80 e0       	ldi	r24, 0x00	; 0
     61e:	90 e0       	ldi	r25, 0x00	; 0
     620:	0e 94 0d 0e 	call	0x1c1a	; 0x1c1a <__floatsisf>
     624:	a7 01       	movw	r20, r14
     626:	96 01       	movw	r18, r12
     628:	0e 94 c1 0e 	call	0x1d82	; 0x1d82 <__mulsf3>
     62c:	2a 89       	ldd	r18, Y+18	; 0x12
     62e:	3b 89       	ldd	r19, Y+19	; 0x13
     630:	4c 89       	ldd	r20, Y+20	; 0x14
     632:	5d 89       	ldd	r21, Y+21	; 0x15
     634:	0e 94 77 0d 	call	0x1aee	; 0x1aee <__addsf3>
     638:	6a 87       	std	Y+10, r22	; 0x0a
     63a:	7b 87       	std	Y+11, r23	; 0x0b
     63c:	8c 87       	std	Y+12, r24	; 0x0c
     63e:	9d 87       	std	Y+13, r25	; 0x0d
		}
	}
     640:	df 91       	pop	r29
     642:	cf 91       	pop	r28
     644:	ff 90       	pop	r15
     646:	ef 90       	pop	r14
     648:	df 90       	pop	r13
     64a:	cf 90       	pop	r12
     64c:	08 95       	ret

0000064e <_ZN2M1D1Ev>:

class Motor
{
//functions
public:
	virtual ~Motor() {};
     64e:	2d e1       	ldi	r18, 0x1D	; 29
     650:	32 e0       	ldi	r19, 0x02	; 2
     652:	fc 01       	movw	r30, r24
     654:	31 83       	std	Z+1, r19	; 0x01
     656:	20 83       	st	Z, r18
     658:	08 95       	ret

0000065a <_ZN2M1D0Ev>:
	SetDegrees( 90 );
	tmr1Ptr_->setDutyCycleComA( percent_ );
	oldPercent_ = percent_;
} 

M1::~M1()
     65a:	cf 93       	push	r28
     65c:	df 93       	push	r29
     65e:	ec 01       	movw	r28, r24
{
}
     660:	f6 df       	rcall	.-20     	; 0x64e <_ZN2M1D1Ev>
     662:	ce 01       	movw	r24, r28
     664:	53 de       	rcall	.-858    	; 0x30c <_ZdlPv>
     666:	df 91       	pop	r29
     668:	cf 91       	pop	r28
     66a:	08 95       	ret

0000066c <_ZN2M19TurnMotorEv>:

void M1::TurnMotor()
{
     66c:	4f 92       	push	r4
     66e:	5f 92       	push	r5
     670:	6f 92       	push	r6
     672:	7f 92       	push	r7
     674:	8f 92       	push	r8
     676:	9f 92       	push	r9
     678:	af 92       	push	r10
     67a:	bf 92       	push	r11
     67c:	cf 92       	push	r12
     67e:	df 92       	push	r13
     680:	ef 92       	push	r14
     682:	ff 92       	push	r15
     684:	cf 93       	push	r28
     686:	df 93       	push	r29
     688:	ec 01       	movw	r28, r24
	if ( percent_ > oldPercent_ + PERCENT_PR_TICK )
     68a:	8a 84       	ldd	r8, Y+10	; 0x0a
     68c:	9b 84       	ldd	r9, Y+11	; 0x0b
     68e:	ac 84       	ldd	r10, Y+12	; 0x0c
     690:	bd 84       	ldd	r11, Y+13	; 0x0d
     692:	ce 84       	ldd	r12, Y+14	; 0x0e
     694:	df 84       	ldd	r13, Y+15	; 0x0f
     696:	e8 88       	ldd	r14, Y+16	; 0x10
     698:	f9 88       	ldd	r15, Y+17	; 0x11
     69a:	20 e0       	ldi	r18, 0x00	; 0
     69c:	30 e0       	ldi	r19, 0x00	; 0
     69e:	40 e8       	ldi	r20, 0x80	; 128
     6a0:	5d e3       	ldi	r21, 0x3D	; 61
     6a2:	c7 01       	movw	r24, r14
     6a4:	b6 01       	movw	r22, r12
     6a6:	0e 94 77 0d 	call	0x1aee	; 0x1aee <__addsf3>
     6aa:	2b 01       	movw	r4, r22
     6ac:	3c 01       	movw	r6, r24
     6ae:	9b 01       	movw	r18, r22
     6b0:	ac 01       	movw	r20, r24
     6b2:	c5 01       	movw	r24, r10
     6b4:	b4 01       	movw	r22, r8
     6b6:	0e 94 bd 0e 	call	0x1d7a	; 0x1d7a <__gesf2>
     6ba:	18 16       	cp	r1, r24
     6bc:	74 f4       	brge	.+28     	; 0x6da <_ZN2M19TurnMotorEv+0x6e>
	{
		oldPercent_ += PERCENT_PR_TICK;
     6be:	4e 86       	std	Y+14, r4	; 0x0e
     6c0:	5f 86       	std	Y+15, r5	; 0x0f
     6c2:	68 8a       	std	Y+16, r6	; 0x10
     6c4:	79 8a       	std	Y+17, r7	; 0x11
		tmr1Ptr_->setDutyCycleComA( oldPercent_ );
     6c6:	b3 01       	movw	r22, r6
     6c8:	a2 01       	movw	r20, r4
     6ca:	8a 81       	ldd	r24, Y+2	; 0x02
     6cc:	9b 81       	ldd	r25, Y+3	; 0x03
     6ce:	b3 d3       	rcall	.+1894   	; 0xe36 <_ZN6Timer116setDutyCycleComAEf>
		vTaskDelay( delay_ / portTICK_RATE_MS );
     6d0:	8f 89       	ldd	r24, Y+23	; 0x17
     6d2:	98 8d       	ldd	r25, Y+24	; 0x18
     6d4:	0e 94 00 0d 	call	0x1a00	; 0x1a00 <vTaskDelay>
     6d8:	1d c0       	rjmp	.+58     	; 0x714 <_ZN2M19TurnMotorEv+0xa8>
	}
	else if ( percent_ < oldPercent_ )
     6da:	a7 01       	movw	r20, r14
     6dc:	96 01       	movw	r18, r12
     6de:	c5 01       	movw	r24, r10
     6e0:	b4 01       	movw	r22, r8
     6e2:	0e 94 db 0d 	call	0x1bb6	; 0x1bb6 <__cmpsf2>
     6e6:	88 23       	and	r24, r24
     6e8:	ac f4       	brge	.+42     	; 0x714 <_ZN2M19TurnMotorEv+0xa8>
	{
		oldPercent_ -= PERCENT_PR_TICK;
     6ea:	20 e0       	ldi	r18, 0x00	; 0
     6ec:	30 e0       	ldi	r19, 0x00	; 0
     6ee:	40 e8       	ldi	r20, 0x80	; 128
     6f0:	5d e3       	ldi	r21, 0x3D	; 61
     6f2:	c7 01       	movw	r24, r14
     6f4:	b6 01       	movw	r22, r12
     6f6:	0e 94 76 0d 	call	0x1aec	; 0x1aec <__subsf3>
     6fa:	ab 01       	movw	r20, r22
     6fc:	bc 01       	movw	r22, r24
     6fe:	4e 87       	std	Y+14, r20	; 0x0e
     700:	5f 87       	std	Y+15, r21	; 0x0f
     702:	68 8b       	std	Y+16, r22	; 0x10
     704:	79 8b       	std	Y+17, r23	; 0x11
		tmr1Ptr_->setDutyCycleComA( oldPercent_ );
     706:	8a 81       	ldd	r24, Y+2	; 0x02
     708:	9b 81       	ldd	r25, Y+3	; 0x03
     70a:	95 d3       	rcall	.+1834   	; 0xe36 <_ZN6Timer116setDutyCycleComAEf>
		vTaskDelay( delay_ / portTICK_RATE_MS );
     70c:	8f 89       	ldd	r24, Y+23	; 0x17
     70e:	98 8d       	ldd	r25, Y+24	; 0x18
     710:	0e 94 00 0d 	call	0x1a00	; 0x1a00 <vTaskDelay>
	}
}
     714:	df 91       	pop	r29
     716:	cf 91       	pop	r28
     718:	ff 90       	pop	r15
     71a:	ef 90       	pop	r14
     71c:	df 90       	pop	r13
     71e:	cf 90       	pop	r12
     720:	bf 90       	pop	r11
     722:	af 90       	pop	r10
     724:	9f 90       	pop	r9
     726:	8f 90       	pop	r8
     728:	7f 90       	pop	r7
     72a:	6f 90       	pop	r6
     72c:	5f 90       	pop	r5
     72e:	4f 90       	pop	r4
     730:	08 95       	ret

00000732 <_ZN2M1C1EP6Timer1>:
* Author: jespe
*/

#include "M1.h"

M1::M1( Timer1* tmr )
     732:	cf 93       	push	r28
     734:	df 93       	push	r29
     736:	ec 01       	movw	r28, r24
     738:	cb 01       	movw	r24, r22
     73a:	29 e2       	ldi	r18, 0x29	; 41
     73c:	32 e0       	ldi	r19, 0x02	; 2
     73e:	39 83       	std	Y+1, r19	; 0x01
     740:	28 83       	st	Y, r18
{
	/* Store timer pointer */
	tmr1Ptr_ = tmr;
     742:	7b 83       	std	Y+3, r23	; 0x03
     744:	6a 83       	std	Y+2, r22	; 0x02
	
	/* This value is number of percent to add or subtract pr degree. */
	percentPrDeg = 0.0555555555555556;
     746:	49 e3       	ldi	r20, 0x39	; 57
     748:	5e e8       	ldi	r21, 0x8E	; 142
     74a:	63 e6       	ldi	r22, 0x63	; 99
     74c:	7d e3       	ldi	r23, 0x3D	; 61
     74e:	4e 83       	std	Y+6, r20	; 0x06
     750:	5f 83       	std	Y+7, r21	; 0x07
     752:	68 87       	std	Y+8, r22	; 0x08
     754:	79 87       	std	Y+9, r23	; 0x09
	
	/* This value is the lowest duty cycle percentage needed to make motor turn. */
	startpercent_ = 2.5;
     756:	40 e0       	ldi	r20, 0x00	; 0
     758:	50 e0       	ldi	r21, 0x00	; 0
     75a:	60 e2       	ldi	r22, 0x20	; 32
     75c:	70 e4       	ldi	r23, 0x40	; 64
     75e:	4a 8b       	std	Y+18, r20	; 0x12
     760:	5b 8b       	std	Y+19, r21	; 0x13
     762:	6c 8b       	std	Y+20, r22	; 0x14
     764:	7d 8b       	std	Y+21, r23	; 0x15
	
	/* This value is the delay on motor. A lower value makes motors go faster and higher value makes motors go slower. */
	delay_ = 10;
     766:	2a e0       	ldi	r18, 0x0A	; 10
     768:	30 e0       	ldi	r19, 0x00	; 0
     76a:	38 8f       	std	Y+24, r19	; 0x18
     76c:	2f 8b       	std	Y+23, r18	; 0x17
	
	/* This value is the maximum number of degrees the motor can turn */
	maxDegrees_ = 180;
     76e:	24 eb       	ldi	r18, 0xB4	; 180
     770:	2e 8b       	std	Y+22, r18	; 0x16
	*/
	virtual void SetDegrees( uint8_t degrees )
	{
		if ( maxDegrees_ >= degrees )
		{
			percent_ = percentPrDeg * degrees + startpercent_;
     772:	40 e0       	ldi	r20, 0x00	; 0
     774:	50 e0       	ldi	r21, 0x00	; 0
     776:	60 ef       	ldi	r22, 0xF0	; 240
     778:	70 e4       	ldi	r23, 0x40	; 64
     77a:	4a 87       	std	Y+10, r20	; 0x0a
     77c:	5b 87       	std	Y+11, r21	; 0x0b
     77e:	6c 87       	std	Y+12, r22	; 0x0c
     780:	7d 87       	std	Y+13, r23	; 0x0d
	
	/* Set motor to default startup value */
	SetDegrees( 90 );
	tmr1Ptr_->setDutyCycleComA( percent_ );
     782:	59 d3       	rcall	.+1714   	; 0xe36 <_ZN6Timer116setDutyCycleComAEf>
	oldPercent_ = percent_;
     784:	8a 85       	ldd	r24, Y+10	; 0x0a
     786:	9b 85       	ldd	r25, Y+11	; 0x0b
     788:	ac 85       	ldd	r26, Y+12	; 0x0c
     78a:	bd 85       	ldd	r27, Y+13	; 0x0d
     78c:	8e 87       	std	Y+14, r24	; 0x0e
     78e:	9f 87       	std	Y+15, r25	; 0x0f
     790:	a8 8b       	std	Y+16, r26	; 0x10
     792:	b9 8b       	std	Y+17, r27	; 0x11
} 
     794:	df 91       	pop	r29
     796:	cf 91       	pop	r28
     798:	08 95       	ret

0000079a <_ZN2M2D1Ev>:

class Motor
{
//functions
public:
	virtual ~Motor() {};
     79a:	2d e1       	ldi	r18, 0x1D	; 29
     79c:	32 e0       	ldi	r19, 0x02	; 2
     79e:	fc 01       	movw	r30, r24
     7a0:	31 83       	std	Z+1, r19	; 0x01
     7a2:	20 83       	st	Z, r18
     7a4:	08 95       	ret

000007a6 <_ZN2M2D0Ev>:
	SetDegrees( 90 );
	tmr1Ptr_->setDutyCycleComB( percent_ );
	oldPercent_ = percent_;
}

M2::~M2()
     7a6:	cf 93       	push	r28
     7a8:	df 93       	push	r29
     7aa:	ec 01       	movw	r28, r24
{
}
     7ac:	f6 df       	rcall	.-20     	; 0x79a <_ZN2M2D1Ev>
     7ae:	ce 01       	movw	r24, r28
     7b0:	ad dd       	rcall	.-1190   	; 0x30c <_ZdlPv>
     7b2:	df 91       	pop	r29
     7b4:	cf 91       	pop	r28
     7b6:	08 95       	ret

000007b8 <_ZN2M29TurnMotorEv>:

void M2::TurnMotor()
{
     7b8:	4f 92       	push	r4
     7ba:	5f 92       	push	r5
     7bc:	6f 92       	push	r6
     7be:	7f 92       	push	r7
     7c0:	8f 92       	push	r8
     7c2:	9f 92       	push	r9
     7c4:	af 92       	push	r10
     7c6:	bf 92       	push	r11
     7c8:	cf 92       	push	r12
     7ca:	df 92       	push	r13
     7cc:	ef 92       	push	r14
     7ce:	ff 92       	push	r15
     7d0:	cf 93       	push	r28
     7d2:	df 93       	push	r29
     7d4:	ec 01       	movw	r28, r24
	if ( percent_ > oldPercent_ + PERCENT_PR_TICK )
     7d6:	8a 84       	ldd	r8, Y+10	; 0x0a
     7d8:	9b 84       	ldd	r9, Y+11	; 0x0b
     7da:	ac 84       	ldd	r10, Y+12	; 0x0c
     7dc:	bd 84       	ldd	r11, Y+13	; 0x0d
     7de:	ce 84       	ldd	r12, Y+14	; 0x0e
     7e0:	df 84       	ldd	r13, Y+15	; 0x0f
     7e2:	e8 88       	ldd	r14, Y+16	; 0x10
     7e4:	f9 88       	ldd	r15, Y+17	; 0x11
     7e6:	20 e0       	ldi	r18, 0x00	; 0
     7e8:	30 e0       	ldi	r19, 0x00	; 0
     7ea:	40 e8       	ldi	r20, 0x80	; 128
     7ec:	5d e3       	ldi	r21, 0x3D	; 61
     7ee:	c7 01       	movw	r24, r14
     7f0:	b6 01       	movw	r22, r12
     7f2:	0e 94 77 0d 	call	0x1aee	; 0x1aee <__addsf3>
     7f6:	2b 01       	movw	r4, r22
     7f8:	3c 01       	movw	r6, r24
     7fa:	9b 01       	movw	r18, r22
     7fc:	ac 01       	movw	r20, r24
     7fe:	c5 01       	movw	r24, r10
     800:	b4 01       	movw	r22, r8
     802:	0e 94 bd 0e 	call	0x1d7a	; 0x1d7a <__gesf2>
     806:	18 16       	cp	r1, r24
     808:	74 f4       	brge	.+28     	; 0x826 <_ZN2M29TurnMotorEv+0x6e>
	{
		oldPercent_ += PERCENT_PR_TICK;
     80a:	4e 86       	std	Y+14, r4	; 0x0e
     80c:	5f 86       	std	Y+15, r5	; 0x0f
     80e:	68 8a       	std	Y+16, r6	; 0x10
     810:	79 8a       	std	Y+17, r7	; 0x11
		tmr1Ptr_->setDutyCycleComB( oldPercent_ );
     812:	b3 01       	movw	r22, r6
     814:	a2 01       	movw	r20, r4
     816:	8a 81       	ldd	r24, Y+2	; 0x02
     818:	9b 81       	ldd	r25, Y+3	; 0x03
     81a:	34 d3       	rcall	.+1640   	; 0xe84 <_ZN6Timer116setDutyCycleComBEf>
		vTaskDelay( delay_ / portTICK_RATE_MS );
     81c:	8f 89       	ldd	r24, Y+23	; 0x17
     81e:	98 8d       	ldd	r25, Y+24	; 0x18
     820:	0e 94 00 0d 	call	0x1a00	; 0x1a00 <vTaskDelay>
     824:	1d c0       	rjmp	.+58     	; 0x860 <_ZN2M29TurnMotorEv+0xa8>
	}
	else if ( percent_ < oldPercent_ )
     826:	a7 01       	movw	r20, r14
     828:	96 01       	movw	r18, r12
     82a:	c5 01       	movw	r24, r10
     82c:	b4 01       	movw	r22, r8
     82e:	0e 94 db 0d 	call	0x1bb6	; 0x1bb6 <__cmpsf2>
     832:	88 23       	and	r24, r24
     834:	ac f4       	brge	.+42     	; 0x860 <_ZN2M29TurnMotorEv+0xa8>
	{
		oldPercent_ -= PERCENT_PR_TICK;
     836:	20 e0       	ldi	r18, 0x00	; 0
     838:	30 e0       	ldi	r19, 0x00	; 0
     83a:	40 e8       	ldi	r20, 0x80	; 128
     83c:	5d e3       	ldi	r21, 0x3D	; 61
     83e:	c7 01       	movw	r24, r14
     840:	b6 01       	movw	r22, r12
     842:	0e 94 76 0d 	call	0x1aec	; 0x1aec <__subsf3>
     846:	ab 01       	movw	r20, r22
     848:	bc 01       	movw	r22, r24
     84a:	4e 87       	std	Y+14, r20	; 0x0e
     84c:	5f 87       	std	Y+15, r21	; 0x0f
     84e:	68 8b       	std	Y+16, r22	; 0x10
     850:	79 8b       	std	Y+17, r23	; 0x11
		tmr1Ptr_->setDutyCycleComB( oldPercent_ );
     852:	8a 81       	ldd	r24, Y+2	; 0x02
     854:	9b 81       	ldd	r25, Y+3	; 0x03
     856:	16 d3       	rcall	.+1580   	; 0xe84 <_ZN6Timer116setDutyCycleComBEf>
		vTaskDelay( delay_ / portTICK_RATE_MS );
     858:	8f 89       	ldd	r24, Y+23	; 0x17
     85a:	98 8d       	ldd	r25, Y+24	; 0x18
     85c:	0e 94 00 0d 	call	0x1a00	; 0x1a00 <vTaskDelay>
	}
}
     860:	df 91       	pop	r29
     862:	cf 91       	pop	r28
     864:	ff 90       	pop	r15
     866:	ef 90       	pop	r14
     868:	df 90       	pop	r13
     86a:	cf 90       	pop	r12
     86c:	bf 90       	pop	r11
     86e:	af 90       	pop	r10
     870:	9f 90       	pop	r9
     872:	8f 90       	pop	r8
     874:	7f 90       	pop	r7
     876:	6f 90       	pop	r6
     878:	5f 90       	pop	r5
     87a:	4f 90       	pop	r4
     87c:	08 95       	ret

0000087e <_ZN2M2C1EP6Timer1>:
* Author: jespe
*/

#include "M2.h"

M2::M2( Timer1* tmr )
     87e:	cf 93       	push	r28
     880:	df 93       	push	r29
     882:	ec 01       	movw	r28, r24
     884:	cb 01       	movw	r24, r22
     886:	25 e3       	ldi	r18, 0x35	; 53
     888:	32 e0       	ldi	r19, 0x02	; 2
     88a:	39 83       	std	Y+1, r19	; 0x01
     88c:	28 83       	st	Y, r18
{
	/* Store timer pointer */
	tmr1Ptr_ = tmr;
     88e:	7b 83       	std	Y+3, r23	; 0x03
     890:	6a 83       	std	Y+2, r22	; 0x02
	
	/* This value is number of percent to add or subtract pr degree. */
	percentPrDeg = 0.06;
     892:	4f e8       	ldi	r20, 0x8F	; 143
     894:	52 ec       	ldi	r21, 0xC2	; 194
     896:	65 e7       	ldi	r22, 0x75	; 117
     898:	7d e3       	ldi	r23, 0x3D	; 61
     89a:	4e 83       	std	Y+6, r20	; 0x06
     89c:	5f 83       	std	Y+7, r21	; 0x07
     89e:	68 87       	std	Y+8, r22	; 0x08
     8a0:	79 87       	std	Y+9, r23	; 0x09

	/* This value is the lowest duty cycle percentage needed to make motor turn. */
	startpercent_ = 3;
     8a2:	40 e0       	ldi	r20, 0x00	; 0
     8a4:	50 e0       	ldi	r21, 0x00	; 0
     8a6:	60 e4       	ldi	r22, 0x40	; 64
     8a8:	70 e4       	ldi	r23, 0x40	; 64
     8aa:	4a 8b       	std	Y+18, r20	; 0x12
     8ac:	5b 8b       	std	Y+19, r21	; 0x13
     8ae:	6c 8b       	std	Y+20, r22	; 0x14
     8b0:	7d 8b       	std	Y+21, r23	; 0x15

	/* This value is the delay on motor. A lower value makes motors go faster and higher value makes motors go slower. Value is in MS */
	delay_ = 10;
     8b2:	2a e0       	ldi	r18, 0x0A	; 10
     8b4:	30 e0       	ldi	r19, 0x00	; 0
     8b6:	38 8f       	std	Y+24, r19	; 0x18
     8b8:	2f 8b       	std	Y+23, r18	; 0x17

	/* This value is the maximum number of degrees the motor can turn */
	maxDegrees_ = 150;
     8ba:	26 e9       	ldi	r18, 0x96	; 150
     8bc:	2e 8b       	std	Y+22, r18	; 0x16
	*/
	virtual void SetDegrees( uint8_t degrees )
	{
		if ( maxDegrees_ >= degrees )
		{
			percent_ = percentPrDeg * degrees + startpercent_;
     8be:	46 e6       	ldi	r20, 0x66	; 102
     8c0:	56 e6       	ldi	r21, 0x66	; 102
     8c2:	66 e0       	ldi	r22, 0x06	; 6
     8c4:	71 e4       	ldi	r23, 0x41	; 65
     8c6:	4a 87       	std	Y+10, r20	; 0x0a
     8c8:	5b 87       	std	Y+11, r21	; 0x0b
     8ca:	6c 87       	std	Y+12, r22	; 0x0c
     8cc:	7d 87       	std	Y+13, r23	; 0x0d

	/* Set motor to default startup value */
	SetDegrees( 90 );
	tmr1Ptr_->setDutyCycleComB( percent_ );
     8ce:	da d2       	rcall	.+1460   	; 0xe84 <_ZN6Timer116setDutyCycleComBEf>
	oldPercent_ = percent_;
     8d0:	8a 85       	ldd	r24, Y+10	; 0x0a
     8d2:	9b 85       	ldd	r25, Y+11	; 0x0b
     8d4:	ac 85       	ldd	r26, Y+12	; 0x0c
     8d6:	bd 85       	ldd	r27, Y+13	; 0x0d
     8d8:	8e 87       	std	Y+14, r24	; 0x0e
     8da:	9f 87       	std	Y+15, r25	; 0x0f
     8dc:	a8 8b       	std	Y+16, r26	; 0x10
     8de:	b9 8b       	std	Y+17, r27	; 0x11
}
     8e0:	df 91       	pop	r29
     8e2:	cf 91       	pop	r28
     8e4:	08 95       	ret

000008e6 <_ZN2M3D1Ev>:

class Motor
{
//functions
public:
	virtual ~Motor() {};
     8e6:	2d e1       	ldi	r18, 0x1D	; 29
     8e8:	32 e0       	ldi	r19, 0x02	; 2
     8ea:	fc 01       	movw	r30, r24
     8ec:	31 83       	std	Z+1, r19	; 0x01
     8ee:	20 83       	st	Z, r18
     8f0:	08 95       	ret

000008f2 <_ZN2M3D0Ev>:
	SetDegrees( 90 );
	tmr1Ptr_->setDutyCycleComC( percent_ );
	oldPercent_ = percent_;	
}

M3::~M3()
     8f2:	cf 93       	push	r28
     8f4:	df 93       	push	r29
     8f6:	ec 01       	movw	r28, r24
{
}
     8f8:	f6 df       	rcall	.-20     	; 0x8e6 <_ZN2M3D1Ev>
     8fa:	ce 01       	movw	r24, r28
     8fc:	07 dd       	rcall	.-1522   	; 0x30c <_ZdlPv>
     8fe:	df 91       	pop	r29
     900:	cf 91       	pop	r28
     902:	08 95       	ret

00000904 <_ZN2M39TurnMotorEv>:

void M3::TurnMotor()
{
     904:	4f 92       	push	r4
     906:	5f 92       	push	r5
     908:	6f 92       	push	r6
     90a:	7f 92       	push	r7
     90c:	8f 92       	push	r8
     90e:	9f 92       	push	r9
     910:	af 92       	push	r10
     912:	bf 92       	push	r11
     914:	cf 92       	push	r12
     916:	df 92       	push	r13
     918:	ef 92       	push	r14
     91a:	ff 92       	push	r15
     91c:	cf 93       	push	r28
     91e:	df 93       	push	r29
     920:	ec 01       	movw	r28, r24
	if ( percent_ > oldPercent_ + PERCENT_PR_TICK )
     922:	8a 84       	ldd	r8, Y+10	; 0x0a
     924:	9b 84       	ldd	r9, Y+11	; 0x0b
     926:	ac 84       	ldd	r10, Y+12	; 0x0c
     928:	bd 84       	ldd	r11, Y+13	; 0x0d
     92a:	ce 84       	ldd	r12, Y+14	; 0x0e
     92c:	df 84       	ldd	r13, Y+15	; 0x0f
     92e:	e8 88       	ldd	r14, Y+16	; 0x10
     930:	f9 88       	ldd	r15, Y+17	; 0x11
     932:	20 e0       	ldi	r18, 0x00	; 0
     934:	30 e0       	ldi	r19, 0x00	; 0
     936:	40 e8       	ldi	r20, 0x80	; 128
     938:	5d e3       	ldi	r21, 0x3D	; 61
     93a:	c7 01       	movw	r24, r14
     93c:	b6 01       	movw	r22, r12
     93e:	0e 94 77 0d 	call	0x1aee	; 0x1aee <__addsf3>
     942:	2b 01       	movw	r4, r22
     944:	3c 01       	movw	r6, r24
     946:	9b 01       	movw	r18, r22
     948:	ac 01       	movw	r20, r24
     94a:	c5 01       	movw	r24, r10
     94c:	b4 01       	movw	r22, r8
     94e:	0e 94 bd 0e 	call	0x1d7a	; 0x1d7a <__gesf2>
     952:	18 16       	cp	r1, r24
     954:	74 f4       	brge	.+28     	; 0x972 <_ZN2M39TurnMotorEv+0x6e>
	{
		oldPercent_ += PERCENT_PR_TICK;
     956:	4e 86       	std	Y+14, r4	; 0x0e
     958:	5f 86       	std	Y+15, r5	; 0x0f
     95a:	68 8a       	std	Y+16, r6	; 0x10
     95c:	79 8a       	std	Y+17, r7	; 0x11
		tmr1Ptr_->setDutyCycleComC( oldPercent_ );
     95e:	b3 01       	movw	r22, r6
     960:	a2 01       	movw	r20, r4
     962:	8a 81       	ldd	r24, Y+2	; 0x02
     964:	9b 81       	ldd	r25, Y+3	; 0x03
     966:	b5 d2       	rcall	.+1386   	; 0xed2 <_ZN6Timer116setDutyCycleComCEf>
		vTaskDelay( delay_ / portTICK_RATE_MS );
     968:	8f 89       	ldd	r24, Y+23	; 0x17
     96a:	98 8d       	ldd	r25, Y+24	; 0x18
     96c:	0e 94 00 0d 	call	0x1a00	; 0x1a00 <vTaskDelay>
     970:	1d c0       	rjmp	.+58     	; 0x9ac <_ZN2M39TurnMotorEv+0xa8>
	}
	else if ( percent_ < oldPercent_ )
     972:	a7 01       	movw	r20, r14
     974:	96 01       	movw	r18, r12
     976:	c5 01       	movw	r24, r10
     978:	b4 01       	movw	r22, r8
     97a:	0e 94 db 0d 	call	0x1bb6	; 0x1bb6 <__cmpsf2>
     97e:	88 23       	and	r24, r24
     980:	ac f4       	brge	.+42     	; 0x9ac <_ZN2M39TurnMotorEv+0xa8>
	{
		oldPercent_ -= PERCENT_PR_TICK;
     982:	20 e0       	ldi	r18, 0x00	; 0
     984:	30 e0       	ldi	r19, 0x00	; 0
     986:	40 e8       	ldi	r20, 0x80	; 128
     988:	5d e3       	ldi	r21, 0x3D	; 61
     98a:	c7 01       	movw	r24, r14
     98c:	b6 01       	movw	r22, r12
     98e:	0e 94 76 0d 	call	0x1aec	; 0x1aec <__subsf3>
     992:	ab 01       	movw	r20, r22
     994:	bc 01       	movw	r22, r24
     996:	4e 87       	std	Y+14, r20	; 0x0e
     998:	5f 87       	std	Y+15, r21	; 0x0f
     99a:	68 8b       	std	Y+16, r22	; 0x10
     99c:	79 8b       	std	Y+17, r23	; 0x11
		tmr1Ptr_->setDutyCycleComC( oldPercent_ );
     99e:	8a 81       	ldd	r24, Y+2	; 0x02
     9a0:	9b 81       	ldd	r25, Y+3	; 0x03
     9a2:	97 d2       	rcall	.+1326   	; 0xed2 <_ZN6Timer116setDutyCycleComCEf>
		vTaskDelay( delay_ / portTICK_RATE_MS );
     9a4:	8f 89       	ldd	r24, Y+23	; 0x17
     9a6:	98 8d       	ldd	r25, Y+24	; 0x18
     9a8:	0e 94 00 0d 	call	0x1a00	; 0x1a00 <vTaskDelay>
	}
}
     9ac:	df 91       	pop	r29
     9ae:	cf 91       	pop	r28
     9b0:	ff 90       	pop	r15
     9b2:	ef 90       	pop	r14
     9b4:	df 90       	pop	r13
     9b6:	cf 90       	pop	r12
     9b8:	bf 90       	pop	r11
     9ba:	af 90       	pop	r10
     9bc:	9f 90       	pop	r9
     9be:	8f 90       	pop	r8
     9c0:	7f 90       	pop	r7
     9c2:	6f 90       	pop	r6
     9c4:	5f 90       	pop	r5
     9c6:	4f 90       	pop	r4
     9c8:	08 95       	ret

000009ca <_ZN2M3C1EP6Timer1>:
*/

#include "M3.h"


M3::M3( Timer1* tmr )
     9ca:	cf 93       	push	r28
     9cc:	df 93       	push	r29
     9ce:	ec 01       	movw	r28, r24
     9d0:	cb 01       	movw	r24, r22
     9d2:	21 e4       	ldi	r18, 0x41	; 65
     9d4:	32 e0       	ldi	r19, 0x02	; 2
     9d6:	39 83       	std	Y+1, r19	; 0x01
     9d8:	28 83       	st	Y, r18
{
	/* Store timer pointer */
	tmr1Ptr_ = tmr;
     9da:	7b 83       	std	Y+3, r23	; 0x03
     9dc:	6a 83       	std	Y+2, r22	; 0x02
		
	/* This value is number of percent to add or subtract pr degree. */
	percentPrDeg = 0.0555555555555556;
     9de:	49 e3       	ldi	r20, 0x39	; 57
     9e0:	5e e8       	ldi	r21, 0x8E	; 142
     9e2:	63 e6       	ldi	r22, 0x63	; 99
     9e4:	7d e3       	ldi	r23, 0x3D	; 61
     9e6:	4e 83       	std	Y+6, r20	; 0x06
     9e8:	5f 83       	std	Y+7, r21	; 0x07
     9ea:	68 87       	std	Y+8, r22	; 0x08
     9ec:	79 87       	std	Y+9, r23	; 0x09
	
	/* This value is the lowest duty cycle percentage needed to make motor turn. */
	startpercent_ = 2.5;
     9ee:	40 e0       	ldi	r20, 0x00	; 0
     9f0:	50 e0       	ldi	r21, 0x00	; 0
     9f2:	60 e2       	ldi	r22, 0x20	; 32
     9f4:	70 e4       	ldi	r23, 0x40	; 64
     9f6:	4a 8b       	std	Y+18, r20	; 0x12
     9f8:	5b 8b       	std	Y+19, r21	; 0x13
     9fa:	6c 8b       	std	Y+20, r22	; 0x14
     9fc:	7d 8b       	std	Y+21, r23	; 0x15

	/* This value is the delay on motor. A lower value makes motors go faster and higher value makes motors go slower. Value is in MS */
	delay_ = 10;
     9fe:	2a e0       	ldi	r18, 0x0A	; 10
     a00:	30 e0       	ldi	r19, 0x00	; 0
     a02:	38 8f       	std	Y+24, r19	; 0x18
     a04:	2f 8b       	std	Y+23, r18	; 0x17
	
	/* This value is the maximum number of degrees the motor can turn */
	maxDegrees_ = 180;
     a06:	24 eb       	ldi	r18, 0xB4	; 180
     a08:	2e 8b       	std	Y+22, r18	; 0x16
	*/
	virtual void SetDegrees( uint8_t degrees )
	{
		if ( maxDegrees_ >= degrees )
		{
			percent_ = percentPrDeg * degrees + startpercent_;
     a0a:	40 e0       	ldi	r20, 0x00	; 0
     a0c:	50 e0       	ldi	r21, 0x00	; 0
     a0e:	60 ef       	ldi	r22, 0xF0	; 240
     a10:	70 e4       	ldi	r23, 0x40	; 64
     a12:	4a 87       	std	Y+10, r20	; 0x0a
     a14:	5b 87       	std	Y+11, r21	; 0x0b
     a16:	6c 87       	std	Y+12, r22	; 0x0c
     a18:	7d 87       	std	Y+13, r23	; 0x0d
	
	/* Set motor to default startup value */
	SetDegrees( 90 );
	tmr1Ptr_->setDutyCycleComC( percent_ );
     a1a:	5b d2       	rcall	.+1206   	; 0xed2 <_ZN6Timer116setDutyCycleComCEf>
	oldPercent_ = percent_;	
     a1c:	8a 85       	ldd	r24, Y+10	; 0x0a
     a1e:	9b 85       	ldd	r25, Y+11	; 0x0b
     a20:	ac 85       	ldd	r26, Y+12	; 0x0c
     a22:	bd 85       	ldd	r27, Y+13	; 0x0d
     a24:	8e 87       	std	Y+14, r24	; 0x0e
     a26:	9f 87       	std	Y+15, r25	; 0x0f
     a28:	a8 8b       	std	Y+16, r26	; 0x10
     a2a:	b9 8b       	std	Y+17, r27	; 0x11
}
     a2c:	df 91       	pop	r29
     a2e:	cf 91       	pop	r28
     a30:	08 95       	ret

00000a32 <_ZN2M4D1Ev>:

class Motor
{
//functions
public:
	virtual ~Motor() {};
     a32:	2d e1       	ldi	r18, 0x1D	; 29
     a34:	32 e0       	ldi	r19, 0x02	; 2
     a36:	fc 01       	movw	r30, r24
     a38:	31 83       	std	Z+1, r19	; 0x01
     a3a:	20 83       	st	Z, r18
     a3c:	08 95       	ret

00000a3e <_ZN2M4D0Ev>:
	SetDegrees( 90 );
	tmr3Ptr_->setDutyCycleComA( percent_ );
	oldPercent_ = percent_;
}

M4::~M4()
     a3e:	cf 93       	push	r28
     a40:	df 93       	push	r29
     a42:	ec 01       	movw	r28, r24
{
} 
     a44:	f6 df       	rcall	.-20     	; 0xa32 <_ZN2M4D1Ev>
     a46:	ce 01       	movw	r24, r28
     a48:	61 dc       	rcall	.-1854   	; 0x30c <_ZdlPv>
     a4a:	df 91       	pop	r29
     a4c:	cf 91       	pop	r28
     a4e:	08 95       	ret

00000a50 <_ZN2M49TurnMotorEv>:

void M4::TurnMotor()
{
     a50:	4f 92       	push	r4
     a52:	5f 92       	push	r5
     a54:	6f 92       	push	r6
     a56:	7f 92       	push	r7
     a58:	8f 92       	push	r8
     a5a:	9f 92       	push	r9
     a5c:	af 92       	push	r10
     a5e:	bf 92       	push	r11
     a60:	cf 92       	push	r12
     a62:	df 92       	push	r13
     a64:	ef 92       	push	r14
     a66:	ff 92       	push	r15
     a68:	cf 93       	push	r28
     a6a:	df 93       	push	r29
     a6c:	ec 01       	movw	r28, r24
	if ( percent_ > oldPercent_ + PERCENT_PR_TICK )
     a6e:	8a 84       	ldd	r8, Y+10	; 0x0a
     a70:	9b 84       	ldd	r9, Y+11	; 0x0b
     a72:	ac 84       	ldd	r10, Y+12	; 0x0c
     a74:	bd 84       	ldd	r11, Y+13	; 0x0d
     a76:	ce 84       	ldd	r12, Y+14	; 0x0e
     a78:	df 84       	ldd	r13, Y+15	; 0x0f
     a7a:	e8 88       	ldd	r14, Y+16	; 0x10
     a7c:	f9 88       	ldd	r15, Y+17	; 0x11
     a7e:	20 e0       	ldi	r18, 0x00	; 0
     a80:	30 e0       	ldi	r19, 0x00	; 0
     a82:	40 e8       	ldi	r20, 0x80	; 128
     a84:	5d e3       	ldi	r21, 0x3D	; 61
     a86:	c7 01       	movw	r24, r14
     a88:	b6 01       	movw	r22, r12
     a8a:	0e 94 77 0d 	call	0x1aee	; 0x1aee <__addsf3>
     a8e:	2b 01       	movw	r4, r22
     a90:	3c 01       	movw	r6, r24
     a92:	9b 01       	movw	r18, r22
     a94:	ac 01       	movw	r20, r24
     a96:	c5 01       	movw	r24, r10
     a98:	b4 01       	movw	r22, r8
     a9a:	0e 94 bd 0e 	call	0x1d7a	; 0x1d7a <__gesf2>
     a9e:	18 16       	cp	r1, r24
     aa0:	6c f4       	brge	.+26     	; 0xabc <_ZN2M49TurnMotorEv+0x6c>
	{
		oldPercent_ += PERCENT_PR_TICK;
     aa2:	4e 86       	std	Y+14, r4	; 0x0e
     aa4:	5f 86       	std	Y+15, r5	; 0x0f
     aa6:	68 8a       	std	Y+16, r6	; 0x10
     aa8:	79 8a       	std	Y+17, r7	; 0x11
		tmr3Ptr_->setDutyCycleComA( oldPercent_ );
     aaa:	b3 01       	movw	r22, r6
     aac:	a2 01       	movw	r20, r4
     aae:	8c 81       	ldd	r24, Y+4	; 0x04
     ab0:	9d 81       	ldd	r25, Y+5	; 0x05
     ab2:	5c d2       	rcall	.+1208   	; 0xf6c <_ZN6Timer516setDutyCycleComAEf>
		vTaskDelay( 10 / portTICK_RATE_MS );
     ab4:	8a e0       	ldi	r24, 0x0A	; 10
     ab6:	90 e0       	ldi	r25, 0x00	; 0
     ab8:	a3 d7       	rcall	.+3910   	; 0x1a00 <vTaskDelay>
     aba:	1c c0       	rjmp	.+56     	; 0xaf4 <_ZN2M49TurnMotorEv+0xa4>
	}
	else if ( percent_ < oldPercent_ )
     abc:	a7 01       	movw	r20, r14
     abe:	96 01       	movw	r18, r12
     ac0:	c5 01       	movw	r24, r10
     ac2:	b4 01       	movw	r22, r8
     ac4:	0e 94 db 0d 	call	0x1bb6	; 0x1bb6 <__cmpsf2>
     ac8:	88 23       	and	r24, r24
     aca:	a4 f4       	brge	.+40     	; 0xaf4 <_ZN2M49TurnMotorEv+0xa4>
	{
		oldPercent_ -= PERCENT_PR_TICK;
     acc:	20 e0       	ldi	r18, 0x00	; 0
     ace:	30 e0       	ldi	r19, 0x00	; 0
     ad0:	40 e8       	ldi	r20, 0x80	; 128
     ad2:	5d e3       	ldi	r21, 0x3D	; 61
     ad4:	c7 01       	movw	r24, r14
     ad6:	b6 01       	movw	r22, r12
     ad8:	0e 94 76 0d 	call	0x1aec	; 0x1aec <__subsf3>
     adc:	ab 01       	movw	r20, r22
     ade:	bc 01       	movw	r22, r24
     ae0:	4e 87       	std	Y+14, r20	; 0x0e
     ae2:	5f 87       	std	Y+15, r21	; 0x0f
     ae4:	68 8b       	std	Y+16, r22	; 0x10
     ae6:	79 8b       	std	Y+17, r23	; 0x11
		tmr3Ptr_->setDutyCycleComA( oldPercent_ );
     ae8:	8c 81       	ldd	r24, Y+4	; 0x04
     aea:	9d 81       	ldd	r25, Y+5	; 0x05
     aec:	3f d2       	rcall	.+1150   	; 0xf6c <_ZN6Timer516setDutyCycleComAEf>
		vTaskDelay( 10 / portTICK_RATE_MS );
     aee:	8a e0       	ldi	r24, 0x0A	; 10
     af0:	90 e0       	ldi	r25, 0x00	; 0
     af2:	86 d7       	rcall	.+3852   	; 0x1a00 <vTaskDelay>
     af4:	df 91       	pop	r29
	}
}
     af6:	cf 91       	pop	r28
     af8:	ff 90       	pop	r15
     afa:	ef 90       	pop	r14
     afc:	df 90       	pop	r13
     afe:	cf 90       	pop	r12
     b00:	bf 90       	pop	r11
     b02:	af 90       	pop	r10
     b04:	9f 90       	pop	r9
     b06:	8f 90       	pop	r8
     b08:	7f 90       	pop	r7
     b0a:	6f 90       	pop	r6
     b0c:	5f 90       	pop	r5
     b0e:	4f 90       	pop	r4
     b10:	08 95       	ret

00000b12 <_ZN2M4C1EP6Timer5>:
     b12:	cf 93       	push	r28
* Author: jespe
*/

#include "M4.h"

M4::M4( Timer5* tmr )
     b14:	df 93       	push	r29
     b16:	ec 01       	movw	r28, r24
     b18:	cb 01       	movw	r24, r22
     b1a:	2d e4       	ldi	r18, 0x4D	; 77
     b1c:	32 e0       	ldi	r19, 0x02	; 2
     b1e:	39 83       	std	Y+1, r19	; 0x01
     b20:	28 83       	st	Y, r18
{
	/* Store timer pointer */
	tmr3Ptr_ = tmr;
     b22:	7d 83       	std	Y+5, r23	; 0x05
     b24:	6c 83       	std	Y+4, r22	; 0x04
	
	/* This value is number of percent to add or subtract pr degree. */
	percentPrDeg = 0.0555555555555556;
     b26:	49 e3       	ldi	r20, 0x39	; 57
     b28:	5e e8       	ldi	r21, 0x8E	; 142
     b2a:	63 e6       	ldi	r22, 0x63	; 99
     b2c:	7d e3       	ldi	r23, 0x3D	; 61
     b2e:	4e 83       	std	Y+6, r20	; 0x06
     b30:	5f 83       	std	Y+7, r21	; 0x07
     b32:	68 87       	std	Y+8, r22	; 0x08
     b34:	79 87       	std	Y+9, r23	; 0x09
	
	/* This value is the lowest duty cycle percentage needed to make motor turn. */
	startpercent_ = 2.5;
     b36:	40 e0       	ldi	r20, 0x00	; 0
     b38:	50 e0       	ldi	r21, 0x00	; 0
     b3a:	60 e2       	ldi	r22, 0x20	; 32
     b3c:	70 e4       	ldi	r23, 0x40	; 64
     b3e:	4a 8b       	std	Y+18, r20	; 0x12
     b40:	5b 8b       	std	Y+19, r21	; 0x13
     b42:	6c 8b       	std	Y+20, r22	; 0x14
     b44:	7d 8b       	std	Y+21, r23	; 0x15
		
	/* This value is the delay on motor. A lower value makes motors go faster and higher value makes motors go slower. Value is in MS */
	delay_ = 5;
     b46:	25 e0       	ldi	r18, 0x05	; 5
     b48:	30 e0       	ldi	r19, 0x00	; 0
     b4a:	38 8f       	std	Y+24, r19	; 0x18
     b4c:	2f 8b       	std	Y+23, r18	; 0x17
	
	/* This value is the maximum number of degrees the motor can turn */
	maxDegrees_ = 180;
     b4e:	24 eb       	ldi	r18, 0xB4	; 180
     b50:	2e 8b       	std	Y+22, r18	; 0x16
	*/
	virtual void SetDegrees( uint8_t degrees )
	{
		if ( maxDegrees_ >= degrees )
		{
			percent_ = percentPrDeg * degrees + startpercent_;
     b52:	40 e0       	ldi	r20, 0x00	; 0
     b54:	50 e0       	ldi	r21, 0x00	; 0
     b56:	60 ef       	ldi	r22, 0xF0	; 240
     b58:	70 e4       	ldi	r23, 0x40	; 64
     b5a:	4a 87       	std	Y+10, r20	; 0x0a
     b5c:	5b 87       	std	Y+11, r21	; 0x0b
     b5e:	6c 87       	std	Y+12, r22	; 0x0c
     b60:	7d 87       	std	Y+13, r23	; 0x0d
	
	/* Set motor to default startup value */
	SetDegrees( 90 );
	tmr3Ptr_->setDutyCycleComA( percent_ );
     b62:	04 d2       	rcall	.+1032   	; 0xf6c <_ZN6Timer516setDutyCycleComAEf>
	oldPercent_ = percent_;
     b64:	8a 85       	ldd	r24, Y+10	; 0x0a
     b66:	9b 85       	ldd	r25, Y+11	; 0x0b
     b68:	ac 85       	ldd	r26, Y+12	; 0x0c
     b6a:	bd 85       	ldd	r27, Y+13	; 0x0d
     b6c:	8e 87       	std	Y+14, r24	; 0x0e
     b6e:	9f 87       	std	Y+15, r25	; 0x0f
     b70:	a8 8b       	std	Y+16, r26	; 0x10
     b72:	b9 8b       	std	Y+17, r27	; 0x11
}
     b74:	df 91       	pop	r29
     b76:	cf 91       	pop	r28
     b78:	08 95       	ret

00000b7a <_ZN2M5D1Ev>:

class Motor
{
//functions
public:
	virtual ~Motor() {};
     b7a:	2d e1       	ldi	r18, 0x1D	; 29
     b7c:	32 e0       	ldi	r19, 0x02	; 2
     b7e:	fc 01       	movw	r30, r24
     b80:	31 83       	std	Z+1, r19	; 0x01
     b82:	20 83       	st	Z, r18
     b84:	08 95       	ret

00000b86 <_ZN2M5D0Ev>:
	SetDegrees( 0 );
	tmr3Ptr_->setDutyCycleComB( percent_ );
	oldPercent_ = percent_;
}

M5::~M5()
     b86:	cf 93       	push	r28
     b88:	df 93       	push	r29
     b8a:	ec 01       	movw	r28, r24
{
}
     b8c:	f6 df       	rcall	.-20     	; 0xb7a <_ZN2M5D1Ev>
     b8e:	ce 01       	movw	r24, r28
     b90:	bd db       	rcall	.-2182   	; 0x30c <_ZdlPv>
     b92:	df 91       	pop	r29
     b94:	cf 91       	pop	r28
     b96:	08 95       	ret

00000b98 <_ZN2M59TurnMotorEv>:

void M5::TurnMotor()
{
     b98:	4f 92       	push	r4
     b9a:	5f 92       	push	r5
     b9c:	6f 92       	push	r6
     b9e:	7f 92       	push	r7
     ba0:	8f 92       	push	r8
     ba2:	9f 92       	push	r9
     ba4:	af 92       	push	r10
     ba6:	bf 92       	push	r11
     ba8:	cf 92       	push	r12
     baa:	df 92       	push	r13
     bac:	ef 92       	push	r14
     bae:	ff 92       	push	r15
     bb0:	cf 93       	push	r28
     bb2:	df 93       	push	r29
     bb4:	ec 01       	movw	r28, r24
	if ( percent_ > oldPercent_ + PERCENT_PR_TICK )
     bb6:	8a 84       	ldd	r8, Y+10	; 0x0a
     bb8:	9b 84       	ldd	r9, Y+11	; 0x0b
     bba:	ac 84       	ldd	r10, Y+12	; 0x0c
     bbc:	bd 84       	ldd	r11, Y+13	; 0x0d
     bbe:	ce 84       	ldd	r12, Y+14	; 0x0e
     bc0:	df 84       	ldd	r13, Y+15	; 0x0f
     bc2:	e8 88       	ldd	r14, Y+16	; 0x10
     bc4:	f9 88       	ldd	r15, Y+17	; 0x11
     bc6:	20 e0       	ldi	r18, 0x00	; 0
     bc8:	30 e0       	ldi	r19, 0x00	; 0
     bca:	40 e8       	ldi	r20, 0x80	; 128
     bcc:	5d e3       	ldi	r21, 0x3D	; 61
     bce:	c7 01       	movw	r24, r14
     bd0:	b6 01       	movw	r22, r12
     bd2:	8d d7       	rcall	.+3866   	; 0x1aee <__addsf3>
     bd4:	2b 01       	movw	r4, r22
     bd6:	3c 01       	movw	r6, r24
     bd8:	9b 01       	movw	r18, r22
     bda:	ac 01       	movw	r20, r24
     bdc:	c5 01       	movw	r24, r10
     bde:	b4 01       	movw	r22, r8
     be0:	0e 94 bd 0e 	call	0x1d7a	; 0x1d7a <__gesf2>
     be4:	18 16       	cp	r1, r24
     be6:	6c f4       	brge	.+26     	; 0xc02 <_ZN2M59TurnMotorEv+0x6a>
	{
		oldPercent_ += PERCENT_PR_TICK;
     be8:	4e 86       	std	Y+14, r4	; 0x0e
     bea:	5f 86       	std	Y+15, r5	; 0x0f
     bec:	68 8a       	std	Y+16, r6	; 0x10
     bee:	79 8a       	std	Y+17, r7	; 0x11
		tmr3Ptr_->setDutyCycleComB( oldPercent_ );
     bf0:	b3 01       	movw	r22, r6
     bf2:	a2 01       	movw	r20, r4
     bf4:	8c 81       	ldd	r24, Y+4	; 0x04
     bf6:	9d 81       	ldd	r25, Y+5	; 0x05
     bf8:	e0 d1       	rcall	.+960    	; 0xfba <_ZN6Timer516setDutyCycleComBEf>
		vTaskDelay( delay_ / portTICK_RATE_MS );
     bfa:	8f 89       	ldd	r24, Y+23	; 0x17
     bfc:	98 8d       	ldd	r25, Y+24	; 0x18
     bfe:	00 d7       	rcall	.+3584   	; 0x1a00 <vTaskDelay>
     c00:	1a c0       	rjmp	.+52     	; 0xc36 <_ZN2M59TurnMotorEv+0x9e>
	}
	else if ( percent_ < oldPercent_ )
     c02:	a7 01       	movw	r20, r14
     c04:	96 01       	movw	r18, r12
     c06:	c5 01       	movw	r24, r10
     c08:	b4 01       	movw	r22, r8
     c0a:	d5 d7       	rcall	.+4010   	; 0x1bb6 <__cmpsf2>
     c0c:	88 23       	and	r24, r24
     c0e:	9c f4       	brge	.+38     	; 0xc36 <_ZN2M59TurnMotorEv+0x9e>
	{
		oldPercent_ -= PERCENT_PR_TICK;
     c10:	20 e0       	ldi	r18, 0x00	; 0
     c12:	30 e0       	ldi	r19, 0x00	; 0
     c14:	40 e8       	ldi	r20, 0x80	; 128
     c16:	5d e3       	ldi	r21, 0x3D	; 61
     c18:	c7 01       	movw	r24, r14
     c1a:	b6 01       	movw	r22, r12
     c1c:	67 d7       	rcall	.+3790   	; 0x1aec <__subsf3>
     c1e:	ab 01       	movw	r20, r22
     c20:	bc 01       	movw	r22, r24
     c22:	4e 87       	std	Y+14, r20	; 0x0e
     c24:	5f 87       	std	Y+15, r21	; 0x0f
     c26:	68 8b       	std	Y+16, r22	; 0x10
		tmr3Ptr_->setDutyCycleComB( oldPercent_ );
     c28:	79 8b       	std	Y+17, r23	; 0x11
     c2a:	8c 81       	ldd	r24, Y+4	; 0x04
     c2c:	9d 81       	ldd	r25, Y+5	; 0x05
		vTaskDelay( delay_ / portTICK_RATE_MS );
     c2e:	c5 d1       	rcall	.+906    	; 0xfba <_ZN6Timer516setDutyCycleComBEf>
     c30:	8f 89       	ldd	r24, Y+23	; 0x17
     c32:	98 8d       	ldd	r25, Y+24	; 0x18
     c34:	e5 d6       	rcall	.+3530   	; 0x1a00 <vTaskDelay>
	}
}
     c36:	df 91       	pop	r29
     c38:	cf 91       	pop	r28
     c3a:	ff 90       	pop	r15
     c3c:	ef 90       	pop	r14
     c3e:	df 90       	pop	r13
     c40:	cf 90       	pop	r12
     c42:	bf 90       	pop	r11
     c44:	af 90       	pop	r10
     c46:	9f 90       	pop	r9
     c48:	8f 90       	pop	r8
     c4a:	7f 90       	pop	r7
     c4c:	6f 90       	pop	r6
     c4e:	5f 90       	pop	r5
     c50:	4f 90       	pop	r4
     c52:	08 95       	ret

00000c54 <_ZN2M5C1EP6Timer5>:
* Author: jespe
*/

#include "M5.h"

M5::M5( Timer5* tmr )
     c54:	cf 93       	push	r28
     c56:	df 93       	push	r29
     c58:	ec 01       	movw	r28, r24
     c5a:	cb 01       	movw	r24, r22
     c5c:	29 e5       	ldi	r18, 0x59	; 89
     c5e:	32 e0       	ldi	r19, 0x02	; 2
     c60:	39 83       	std	Y+1, r19	; 0x01
     c62:	28 83       	st	Y, r18
{
	/* Store timer pointer */
	tmr3Ptr_ = tmr;
     c64:	7d 83       	std	Y+5, r23	; 0x05
     c66:	6c 83       	std	Y+4, r22	; 0x04
	
	/* This value is number of percent to add or subtract pr degree. */
	percentPrDeg = 0.0555555555555556;
     c68:	49 e3       	ldi	r20, 0x39	; 57
     c6a:	5e e8       	ldi	r21, 0x8E	; 142
     c6c:	63 e6       	ldi	r22, 0x63	; 99
     c6e:	7d e3       	ldi	r23, 0x3D	; 61
     c70:	4e 83       	std	Y+6, r20	; 0x06
     c72:	5f 83       	std	Y+7, r21	; 0x07
     c74:	68 87       	std	Y+8, r22	; 0x08
     c76:	79 87       	std	Y+9, r23	; 0x09
	
	/* This value is the lowest duty cycle percentage needed to make motor turn. */
	startpercent_ = 2.5;
     c78:	40 e0       	ldi	r20, 0x00	; 0
     c7a:	50 e0       	ldi	r21, 0x00	; 0
     c7c:	60 e2       	ldi	r22, 0x20	; 32
     c7e:	70 e4       	ldi	r23, 0x40	; 64
     c80:	4a 8b       	std	Y+18, r20	; 0x12
     c82:	5b 8b       	std	Y+19, r21	; 0x13
     c84:	6c 8b       	std	Y+20, r22	; 0x14
     c86:	7d 8b       	std	Y+21, r23	; 0x15
	
	/* This value is the delay on motor. A lower value makes motors go faster and higher value makes motors go slower. Value is in MS */
	delay_ = 1;
     c88:	21 e0       	ldi	r18, 0x01	; 1
     c8a:	30 e0       	ldi	r19, 0x00	; 0
     c8c:	38 8f       	std	Y+24, r19	; 0x18
     c8e:	2f 8b       	std	Y+23, r18	; 0x17
	
	/* This value is the maximum number of degrees the motor can turn */
	maxDegrees_ = 180;
     c90:	24 eb       	ldi	r18, 0xB4	; 180
     c92:	2e 8b       	std	Y+22, r18	; 0x16
	*/
	virtual void SetDegrees( uint8_t degrees )
	{
		if ( maxDegrees_ >= degrees )
		{
			percent_ = percentPrDeg * degrees + startpercent_;
     c94:	4a 87       	std	Y+10, r20	; 0x0a
     c96:	5b 87       	std	Y+11, r21	; 0x0b
     c98:	6c 87       	std	Y+12, r22	; 0x0c
     c9a:	7d 87       	std	Y+13, r23	; 0x0d
	
	/* Set motor to default startup value */
	SetDegrees( 0 );
	tmr3Ptr_->setDutyCycleComB( percent_ );
     c9c:	8e d1       	rcall	.+796    	; 0xfba <_ZN6Timer516setDutyCycleComBEf>
	oldPercent_ = percent_;
     c9e:	8a 85       	ldd	r24, Y+10	; 0x0a
     ca0:	9b 85       	ldd	r25, Y+11	; 0x0b
     ca2:	ac 85       	ldd	r26, Y+12	; 0x0c
     ca4:	bd 85       	ldd	r27, Y+13	; 0x0d
     ca6:	8e 87       	std	Y+14, r24	; 0x0e
     ca8:	9f 87       	std	Y+15, r25	; 0x0f
     caa:	a8 8b       	std	Y+16, r26	; 0x10
     cac:	b9 8b       	std	Y+17, r27	; 0x11
}
     cae:	df 91       	pop	r29
     cb0:	cf 91       	pop	r28
     cb2:	08 95       	ret

00000cb4 <_ZN2M6D1Ev>:

class Motor
{
//functions
public:
	virtual ~Motor() {};
     cb4:	2d e1       	ldi	r18, 0x1D	; 29
     cb6:	32 e0       	ldi	r19, 0x02	; 2
     cb8:	fc 01       	movw	r30, r24
     cba:	31 83       	std	Z+1, r19	; 0x01
     cbc:	20 83       	st	Z, r18
     cbe:	08 95       	ret

00000cc0 <_ZN2M6D0Ev>:
	SetDegrees( 0 );
	tmr3Ptr_->setDutyCycleComC( percent_ );
	oldPercent_ = percent_;
}

M6::~M6()
     cc0:	cf 93       	push	r28
     cc2:	df 93       	push	r29
     cc4:	ec 01       	movw	r28, r24
{
}
     cc6:	f6 df       	rcall	.-20     	; 0xcb4 <_ZN2M6D1Ev>
     cc8:	ce 01       	movw	r24, r28
     cca:	20 db       	rcall	.-2496   	; 0x30c <_ZdlPv>
     ccc:	df 91       	pop	r29
     cce:	cf 91       	pop	r28
     cd0:	08 95       	ret

00000cd2 <_ZN2M69TurnMotorEv>:

void M6::TurnMotor()
{
     cd2:	4f 92       	push	r4
     cd4:	5f 92       	push	r5
     cd6:	6f 92       	push	r6
     cd8:	7f 92       	push	r7
     cda:	8f 92       	push	r8
     cdc:	9f 92       	push	r9
     cde:	af 92       	push	r10
     ce0:	bf 92       	push	r11
     ce2:	cf 92       	push	r12
     ce4:	df 92       	push	r13
     ce6:	ef 92       	push	r14
     ce8:	ff 92       	push	r15
     cea:	cf 93       	push	r28
     cec:	df 93       	push	r29
     cee:	ec 01       	movw	r28, r24
	if ( percent_ > oldPercent_ + PERCENT_PR_TICK )
     cf0:	8a 84       	ldd	r8, Y+10	; 0x0a
     cf2:	9b 84       	ldd	r9, Y+11	; 0x0b
     cf4:	ac 84       	ldd	r10, Y+12	; 0x0c
     cf6:	bd 84       	ldd	r11, Y+13	; 0x0d
     cf8:	ce 84       	ldd	r12, Y+14	; 0x0e
     cfa:	df 84       	ldd	r13, Y+15	; 0x0f
     cfc:	e8 88       	ldd	r14, Y+16	; 0x10
     cfe:	f9 88       	ldd	r15, Y+17	; 0x11
     d00:	20 e0       	ldi	r18, 0x00	; 0
     d02:	30 e0       	ldi	r19, 0x00	; 0
     d04:	40 e8       	ldi	r20, 0x80	; 128
     d06:	5d e3       	ldi	r21, 0x3D	; 61
     d08:	c7 01       	movw	r24, r14
     d0a:	b6 01       	movw	r22, r12
     d0c:	f0 d6       	rcall	.+3552   	; 0x1aee <__addsf3>
     d0e:	2b 01       	movw	r4, r22
     d10:	3c 01       	movw	r6, r24
     d12:	9b 01       	movw	r18, r22
     d14:	ac 01       	movw	r20, r24
     d16:	c5 01       	movw	r24, r10
     d18:	b4 01       	movw	r22, r8
     d1a:	0e 94 bd 0e 	call	0x1d7a	; 0x1d7a <__gesf2>
     d1e:	18 16       	cp	r1, r24
     d20:	6c f4       	brge	.+26     	; 0xd3c <_ZN2M69TurnMotorEv+0x6a>
	{
		oldPercent_ += 0.0625;
     d22:	4e 86       	std	Y+14, r4	; 0x0e
     d24:	5f 86       	std	Y+15, r5	; 0x0f
     d26:	68 8a       	std	Y+16, r6	; 0x10
     d28:	79 8a       	std	Y+17, r7	; 0x11
		tmr3Ptr_->setDutyCycleComC( oldPercent_ );
     d2a:	b3 01       	movw	r22, r6
     d2c:	a2 01       	movw	r20, r4
     d2e:	8c 81       	ldd	r24, Y+4	; 0x04
     d30:	9d 81       	ldd	r25, Y+5	; 0x05
     d32:	6a d1       	rcall	.+724    	; 0x1008 <_ZN6Timer516setDutyCycleComCEf>
		vTaskDelay( delay_ / portTICK_RATE_MS );
     d34:	8f 89       	ldd	r24, Y+23	; 0x17
     d36:	98 8d       	ldd	r25, Y+24	; 0x18
     d38:	63 d6       	rcall	.+3270   	; 0x1a00 <vTaskDelay>
     d3a:	1a c0       	rjmp	.+52     	; 0xd70 <_ZN2M69TurnMotorEv+0x9e>
	}
	else if ( percent_ < oldPercent_ )
     d3c:	a7 01       	movw	r20, r14
     d3e:	96 01       	movw	r18, r12
     d40:	c5 01       	movw	r24, r10
     d42:	b4 01       	movw	r22, r8
     d44:	38 d7       	rcall	.+3696   	; 0x1bb6 <__cmpsf2>
     d46:	88 23       	and	r24, r24
     d48:	9c f4       	brge	.+38     	; 0xd70 <_ZN2M69TurnMotorEv+0x9e>
	{
		oldPercent_ -= 0.0625;
     d4a:	20 e0       	ldi	r18, 0x00	; 0
     d4c:	30 e0       	ldi	r19, 0x00	; 0
     d4e:	40 e8       	ldi	r20, 0x80	; 128
     d50:	5d e3       	ldi	r21, 0x3D	; 61
     d52:	c7 01       	movw	r24, r14
     d54:	b6 01       	movw	r22, r12
     d56:	ca d6       	rcall	.+3476   	; 0x1aec <__subsf3>
     d58:	ab 01       	movw	r20, r22
     d5a:	bc 01       	movw	r22, r24
     d5c:	4e 87       	std	Y+14, r20	; 0x0e
     d5e:	5f 87       	std	Y+15, r21	; 0x0f
     d60:	68 8b       	std	Y+16, r22	; 0x10
		tmr3Ptr_->setDutyCycleComC( oldPercent_ );
     d62:	79 8b       	std	Y+17, r23	; 0x11
     d64:	8c 81       	ldd	r24, Y+4	; 0x04
     d66:	9d 81       	ldd	r25, Y+5	; 0x05
		vTaskDelay( delay_ / portTICK_RATE_MS );
     d68:	4f d1       	rcall	.+670    	; 0x1008 <_ZN6Timer516setDutyCycleComCEf>
     d6a:	8f 89       	ldd	r24, Y+23	; 0x17
     d6c:	98 8d       	ldd	r25, Y+24	; 0x18
     d6e:	48 d6       	rcall	.+3216   	; 0x1a00 <vTaskDelay>
	}
}
     d70:	df 91       	pop	r29
     d72:	cf 91       	pop	r28
     d74:	ff 90       	pop	r15
     d76:	ef 90       	pop	r14
     d78:	df 90       	pop	r13
     d7a:	cf 90       	pop	r12
     d7c:	bf 90       	pop	r11
     d7e:	af 90       	pop	r10
     d80:	9f 90       	pop	r9
     d82:	8f 90       	pop	r8
     d84:	7f 90       	pop	r7
     d86:	6f 90       	pop	r6
     d88:	5f 90       	pop	r5
     d8a:	4f 90       	pop	r4
     d8c:	08 95       	ret

00000d8e <_ZN2M6C1EP6Timer5>:
* Author: jespe
*/

#include "M6.h"

M6::M6( Timer5* tmr )
     d8e:	cf 93       	push	r28
     d90:	df 93       	push	r29
     d92:	ec 01       	movw	r28, r24
     d94:	cb 01       	movw	r24, r22
     d96:	25 e6       	ldi	r18, 0x65	; 101
     d98:	32 e0       	ldi	r19, 0x02	; 2
     d9a:	39 83       	std	Y+1, r19	; 0x01
     d9c:	28 83       	st	Y, r18
{
	/* Store timer pointer */
	tmr3Ptr_ = tmr;
     d9e:	7d 83       	std	Y+5, r23	; 0x05
     da0:	6c 83       	std	Y+4, r22	; 0x04
	
	/* This value is number of percent to add or subtract pr degree. */
	percentPrDeg = 0.07936507936507;
     da2:	49 e2       	ldi	r20, 0x29	; 41
     da4:	5a e8       	ldi	r21, 0x8A	; 138
     da6:	62 ea       	ldi	r22, 0xA2	; 162
     da8:	7d e3       	ldi	r23, 0x3D	; 61
     daa:	4e 83       	std	Y+6, r20	; 0x06
     dac:	5f 83       	std	Y+7, r21	; 0x07
     dae:	68 87       	std	Y+8, r22	; 0x08
     db0:	79 87       	std	Y+9, r23	; 0x09
	
	/* This value is the lowest duty cycle percentage needed to make motor turn. */
	startpercent_ = 2.5;
     db2:	40 e0       	ldi	r20, 0x00	; 0
     db4:	50 e0       	ldi	r21, 0x00	; 0
     db6:	60 e2       	ldi	r22, 0x20	; 32
     db8:	70 e4       	ldi	r23, 0x40	; 64
     dba:	4a 8b       	std	Y+18, r20	; 0x12
     dbc:	5b 8b       	std	Y+19, r21	; 0x13
     dbe:	6c 8b       	std	Y+20, r22	; 0x14
     dc0:	7d 8b       	std	Y+21, r23	; 0x15
	
	/* This value is the delay on motor. A lower value makes motors go faster and higher value makes motors go slower. Value is in MS */
	delay_ = 1;
     dc2:	21 e0       	ldi	r18, 0x01	; 1
     dc4:	30 e0       	ldi	r19, 0x00	; 0
     dc6:	38 8f       	std	Y+24, r19	; 0x18
     dc8:	2f 8b       	std	Y+23, r18	; 0x17
	
	/* This value is the maximum number of degrees the motor can turn */
	maxDegrees_ = 63;
     dca:	2f e3       	ldi	r18, 0x3F	; 63
     dcc:	2e 8b       	std	Y+22, r18	; 0x16
	*/
	virtual void SetDegrees( uint8_t degrees )
	{
		if ( maxDegrees_ >= degrees )
		{
			percent_ = percentPrDeg * degrees + startpercent_;
     dce:	4a 87       	std	Y+10, r20	; 0x0a
     dd0:	5b 87       	std	Y+11, r21	; 0x0b
     dd2:	6c 87       	std	Y+12, r22	; 0x0c
     dd4:	7d 87       	std	Y+13, r23	; 0x0d
	
	/* Set motor to default startup value */
	SetDegrees( 0 );
	tmr3Ptr_->setDutyCycleComC( percent_ );
     dd6:	18 d1       	rcall	.+560    	; 0x1008 <_ZN6Timer516setDutyCycleComCEf>
	oldPercent_ = percent_;
     dd8:	8a 85       	ldd	r24, Y+10	; 0x0a
     dda:	9b 85       	ldd	r25, Y+11	; 0x0b
     ddc:	ac 85       	ldd	r26, Y+12	; 0x0c
     dde:	bd 85       	ldd	r27, Y+13	; 0x0d
     de0:	8e 87       	std	Y+14, r24	; 0x0e
     de2:	9f 87       	std	Y+15, r25	; 0x0f
     de4:	a8 8b       	std	Y+16, r26	; 0x10
     de6:	b9 8b       	std	Y+17, r27	; 0x11
}
     de8:	df 91       	pop	r29
     dea:	cf 91       	pop	r28
     dec:	08 95       	ret

00000dee <_ZN6Timer1C1Ev>:
#include <avr/io.h>

Timer1::Timer1()
{
	// Set all needed ports to outputs
	ROBOTARM_M1_OUT_PORT |= ( 1 << ROBOTARM_M1_OUT_PIN );
     dee:	84 b1       	in	r24, 0x04	; 4
     df0:	80 62       	ori	r24, 0x20	; 32
     df2:	84 b9       	out	0x04, r24	; 4
	ROBOTARM_M2_OUT_PORT |= ( 1 << ROBOTARM_M2_OUT_PIN );
     df4:	84 b1       	in	r24, 0x04	; 4
     df6:	80 64       	ori	r24, 0x40	; 64
     df8:	84 b9       	out	0x04, r24	; 4
	ROBOTARM_M3_OUT_PORT |= ( 1 << ROBOTARM_M3_OUT_PIN );
     dfa:	84 b1       	in	r24, 0x04	; 4
     dfc:	80 68       	ori	r24, 0x80	; 128
     dfe:	84 b9       	out	0x04, r24	; 4
		
	// Set timer to run in PWM, Phase Correct mode with 50 Hz freq. 
	TCCR1A = ( 1 << COM1A1 ) | ( 1 << COM1B1 ) | ( 1 << COM1C1 ) | ( 0 << WGM10 ) | ( 0 << WGM11 );
     e00:	88 ea       	ldi	r24, 0xA8	; 168
     e02:	80 93 80 00 	sts	0x0080, r24	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
	TCCR1B = ( 1 << WGM13 ) | ( 0 << CS10 )  | ( 1 << CS12 );
     e06:	84 e1       	ldi	r24, 0x14	; 20
     e08:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x700081>
	TCCR1C = 0;
     e0c:	10 92 82 00 	sts	0x0082, r1	; 0x800082 <__TEXT_REGION_LENGTH__+0x700082>
	ICR1 = 622;
     e10:	8e e6       	ldi	r24, 0x6E	; 110
     e12:	92 e0       	ldi	r25, 0x02	; 2
     e14:	90 93 87 00 	sts	0x0087, r25	; 0x800087 <__TEXT_REGION_LENGTH__+0x700087>
     e18:	80 93 86 00 	sts	0x0086, r24	; 0x800086 <__TEXT_REGION_LENGTH__+0x700086>
	
	OCR1A = 0;
     e1c:	10 92 89 00 	sts	0x0089, r1	; 0x800089 <__TEXT_REGION_LENGTH__+0x700089>
     e20:	10 92 88 00 	sts	0x0088, r1	; 0x800088 <__TEXT_REGION_LENGTH__+0x700088>
	OCR1B = 0;
     e24:	10 92 8b 00 	sts	0x008B, r1	; 0x80008b <__TEXT_REGION_LENGTH__+0x70008b>
     e28:	10 92 8a 00 	sts	0x008A, r1	; 0x80008a <__TEXT_REGION_LENGTH__+0x70008a>
	OCR1C = 0;
     e2c:	10 92 8d 00 	sts	0x008D, r1	; 0x80008d <__TEXT_REGION_LENGTH__+0x70008d>
     e30:	10 92 8c 00 	sts	0x008C, r1	; 0x80008c <__TEXT_REGION_LENGTH__+0x70008c>
     e34:	08 95       	ret

00000e36 <_ZN6Timer116setDutyCycleComAEf>:
}

void Timer1::setDutyCycleComA( float dutyCycle )
{
     e36:	cf 92       	push	r12
     e38:	df 92       	push	r13
     e3a:	ef 92       	push	r14
     e3c:	ff 92       	push	r15
     e3e:	6a 01       	movw	r12, r20
     e40:	7b 01       	movw	r14, r22
	float percent = ICR1/100;
     e42:	20 91 86 00 	lds	r18, 0x0086	; 0x800086 <__TEXT_REGION_LENGTH__+0x700086>
     e46:	30 91 87 00 	lds	r19, 0x0087	; 0x800087 <__TEXT_REGION_LENGTH__+0x700087>
     e4a:	36 95       	lsr	r19
     e4c:	27 95       	ror	r18
     e4e:	36 95       	lsr	r19
     e50:	27 95       	ror	r18
     e52:	ab e7       	ldi	r26, 0x7B	; 123
     e54:	b4 e1       	ldi	r27, 0x14	; 20
     e56:	f8 d7       	rcall	.+4080   	; 0x1e48 <__umulhisi3>
     e58:	96 95       	lsr	r25
     e5a:	87 95       	ror	r24
	OCR1A = (uint8_t)percent*dutyCycle;
     e5c:	bc 01       	movw	r22, r24
     e5e:	77 27       	eor	r23, r23
     e60:	07 2e       	mov	r0, r23
     e62:	00 0c       	add	r0, r0
     e64:	88 0b       	sbc	r24, r24
     e66:	99 0b       	sbc	r25, r25
     e68:	d8 d6       	rcall	.+3504   	; 0x1c1a <__floatsisf>
     e6a:	a7 01       	movw	r20, r14
     e6c:	96 01       	movw	r18, r12
     e6e:	89 d7       	rcall	.+3858   	; 0x1d82 <__mulsf3>
     e70:	a6 d6       	rcall	.+3404   	; 0x1bbe <__fixunssfsi>
     e72:	70 93 89 00 	sts	0x0089, r23	; 0x800089 <__TEXT_REGION_LENGTH__+0x700089>
     e76:	60 93 88 00 	sts	0x0088, r22	; 0x800088 <__TEXT_REGION_LENGTH__+0x700088>
}
     e7a:	ff 90       	pop	r15
     e7c:	ef 90       	pop	r14
     e7e:	df 90       	pop	r13
     e80:	cf 90       	pop	r12
     e82:	08 95       	ret

00000e84 <_ZN6Timer116setDutyCycleComBEf>:

void Timer1::setDutyCycleComB( float dutyCycle )
{
     e84:	cf 92       	push	r12
     e86:	df 92       	push	r13
     e88:	ef 92       	push	r14
     e8a:	ff 92       	push	r15
     e8c:	6a 01       	movw	r12, r20
     e8e:	7b 01       	movw	r14, r22
	float percent = ICR1/100;
     e90:	20 91 86 00 	lds	r18, 0x0086	; 0x800086 <__TEXT_REGION_LENGTH__+0x700086>
     e94:	30 91 87 00 	lds	r19, 0x0087	; 0x800087 <__TEXT_REGION_LENGTH__+0x700087>
     e98:	36 95       	lsr	r19
     e9a:	27 95       	ror	r18
     e9c:	36 95       	lsr	r19
     e9e:	27 95       	ror	r18
     ea0:	ab e7       	ldi	r26, 0x7B	; 123
     ea2:	b4 e1       	ldi	r27, 0x14	; 20
     ea4:	d1 d7       	rcall	.+4002   	; 0x1e48 <__umulhisi3>
     ea6:	96 95       	lsr	r25
     ea8:	87 95       	ror	r24
	OCR1B = (uint8_t)percent*dutyCycle;
     eaa:	bc 01       	movw	r22, r24
     eac:	77 27       	eor	r23, r23
     eae:	07 2e       	mov	r0, r23
     eb0:	00 0c       	add	r0, r0
     eb2:	88 0b       	sbc	r24, r24
     eb4:	99 0b       	sbc	r25, r25
     eb6:	b1 d6       	rcall	.+3426   	; 0x1c1a <__floatsisf>
     eb8:	a7 01       	movw	r20, r14
     eba:	96 01       	movw	r18, r12
     ebc:	62 d7       	rcall	.+3780   	; 0x1d82 <__mulsf3>
     ebe:	7f d6       	rcall	.+3326   	; 0x1bbe <__fixunssfsi>
     ec0:	70 93 8b 00 	sts	0x008B, r23	; 0x80008b <__TEXT_REGION_LENGTH__+0x70008b>
     ec4:	60 93 8a 00 	sts	0x008A, r22	; 0x80008a <__TEXT_REGION_LENGTH__+0x70008a>
}
     ec8:	ff 90       	pop	r15
     eca:	ef 90       	pop	r14
     ecc:	df 90       	pop	r13
     ece:	cf 90       	pop	r12
     ed0:	08 95       	ret

00000ed2 <_ZN6Timer116setDutyCycleComCEf>:

void Timer1::setDutyCycleComC( float dutyCycle )
{
     ed2:	cf 92       	push	r12
     ed4:	df 92       	push	r13
     ed6:	ef 92       	push	r14
     ed8:	ff 92       	push	r15
     eda:	6a 01       	movw	r12, r20
     edc:	7b 01       	movw	r14, r22
	float percent = ICR1/100;
     ede:	20 91 86 00 	lds	r18, 0x0086	; 0x800086 <__TEXT_REGION_LENGTH__+0x700086>
     ee2:	30 91 87 00 	lds	r19, 0x0087	; 0x800087 <__TEXT_REGION_LENGTH__+0x700087>
     ee6:	36 95       	lsr	r19
     ee8:	27 95       	ror	r18
     eea:	36 95       	lsr	r19
     eec:	27 95       	ror	r18
     eee:	ab e7       	ldi	r26, 0x7B	; 123
     ef0:	b4 e1       	ldi	r27, 0x14	; 20
     ef2:	aa d7       	rcall	.+3924   	; 0x1e48 <__umulhisi3>
     ef4:	96 95       	lsr	r25
     ef6:	87 95       	ror	r24
	OCR1C = (uint8_t)percent*dutyCycle;
     ef8:	bc 01       	movw	r22, r24
     efa:	77 27       	eor	r23, r23
     efc:	07 2e       	mov	r0, r23
     efe:	00 0c       	add	r0, r0
     f00:	88 0b       	sbc	r24, r24
     f02:	99 0b       	sbc	r25, r25
     f04:	8a d6       	rcall	.+3348   	; 0x1c1a <__floatsisf>
     f06:	a7 01       	movw	r20, r14
     f08:	96 01       	movw	r18, r12
     f0a:	3b d7       	rcall	.+3702   	; 0x1d82 <__mulsf3>
     f0c:	58 d6       	rcall	.+3248   	; 0x1bbe <__fixunssfsi>
     f0e:	70 93 8d 00 	sts	0x008D, r23	; 0x80008d <__TEXT_REGION_LENGTH__+0x70008d>
     f12:	60 93 8c 00 	sts	0x008C, r22	; 0x80008c <__TEXT_REGION_LENGTH__+0x70008c>
     f16:	ff 90       	pop	r15
     f18:	ef 90       	pop	r14
     f1a:	df 90       	pop	r13
     f1c:	cf 90       	pop	r12
     f1e:	08 95       	ret

00000f20 <_ZN6Timer5C1Ev>:
#include <avr/io.h>

Timer5::Timer5()
{
	// Set all needed ports to outputs
	ROBOTARM_M4_OUT_PORT |= ( 1 << ROBOTARM_M4_OUT_PIN );
     f20:	ea e0       	ldi	r30, 0x0A	; 10
     f22:	f1 e0       	ldi	r31, 0x01	; 1
     f24:	80 81       	ld	r24, Z
     f26:	88 60       	ori	r24, 0x08	; 8
     f28:	80 83       	st	Z, r24
	ROBOTARM_M5_OUT_PORT |= ( 1 << ROBOTARM_M5_OUT_PIN );
     f2a:	80 81       	ld	r24, Z
     f2c:	80 61       	ori	r24, 0x10	; 16
     f2e:	80 83       	st	Z, r24
	ROBOTARM_M6_OUT_PORT |= ( 1 << ROBOTARM_M6_OUT_PIN );
     f30:	80 81       	ld	r24, Z
     f32:	80 62       	ori	r24, 0x20	; 32
     f34:	80 83       	st	Z, r24
	
	// Set timer to run in PWM, Phase Correct mode with 50 Hz freq.
	TCCR5A = ( 1 << COM3A1 ) | ( 1 << COM3B1 ) | ( 1 << COM3C1 ) | ( 0 << WGM30 ) | ( 0 << WGM31 );
     f36:	88 ea       	ldi	r24, 0xA8	; 168
     f38:	80 93 20 01 	sts	0x0120, r24	; 0x800120 <__TEXT_REGION_LENGTH__+0x700120>
	TCCR5B = ( 1 << WGM33 ) | ( 0 << CS30 )  | ( 1 << CS32 );
     f3c:	84 e1       	ldi	r24, 0x14	; 20
     f3e:	80 93 21 01 	sts	0x0121, r24	; 0x800121 <__TEXT_REGION_LENGTH__+0x700121>
	TCCR5C = 0;
     f42:	10 92 22 01 	sts	0x0122, r1	; 0x800122 <__TEXT_REGION_LENGTH__+0x700122>
	ICR5 = 622;
     f46:	8e e6       	ldi	r24, 0x6E	; 110
     f48:	92 e0       	ldi	r25, 0x02	; 2
     f4a:	90 93 27 01 	sts	0x0127, r25	; 0x800127 <__TEXT_REGION_LENGTH__+0x700127>
     f4e:	80 93 26 01 	sts	0x0126, r24	; 0x800126 <__TEXT_REGION_LENGTH__+0x700126>
	
	OCR5A = 0;
     f52:	10 92 29 01 	sts	0x0129, r1	; 0x800129 <__TEXT_REGION_LENGTH__+0x700129>
     f56:	10 92 28 01 	sts	0x0128, r1	; 0x800128 <__TEXT_REGION_LENGTH__+0x700128>
	OCR5B = 0;
     f5a:	10 92 2b 01 	sts	0x012B, r1	; 0x80012b <__TEXT_REGION_LENGTH__+0x70012b>
     f5e:	10 92 2a 01 	sts	0x012A, r1	; 0x80012a <__TEXT_REGION_LENGTH__+0x70012a>
	OCR5C = 0;
     f62:	10 92 2d 01 	sts	0x012D, r1	; 0x80012d <__TEXT_REGION_LENGTH__+0x70012d>
     f66:	10 92 2c 01 	sts	0x012C, r1	; 0x80012c <__TEXT_REGION_LENGTH__+0x70012c>
     f6a:	08 95       	ret

00000f6c <_ZN6Timer516setDutyCycleComAEf>:
}

void Timer5::setDutyCycleComA( float dutyCycle )
{
     f6c:	cf 92       	push	r12
     f6e:	df 92       	push	r13
     f70:	ef 92       	push	r14
     f72:	ff 92       	push	r15
     f74:	6a 01       	movw	r12, r20
     f76:	7b 01       	movw	r14, r22
	float percent = ICR5/100;
     f78:	20 91 26 01 	lds	r18, 0x0126	; 0x800126 <__TEXT_REGION_LENGTH__+0x700126>
     f7c:	30 91 27 01 	lds	r19, 0x0127	; 0x800127 <__TEXT_REGION_LENGTH__+0x700127>
     f80:	36 95       	lsr	r19
     f82:	27 95       	ror	r18
     f84:	36 95       	lsr	r19
     f86:	27 95       	ror	r18
     f88:	ab e7       	ldi	r26, 0x7B	; 123
     f8a:	b4 e1       	ldi	r27, 0x14	; 20
     f8c:	5d d7       	rcall	.+3770   	; 0x1e48 <__umulhisi3>
     f8e:	96 95       	lsr	r25
     f90:	87 95       	ror	r24
	OCR5A = (uint8_t)percent*dutyCycle;
     f92:	bc 01       	movw	r22, r24
     f94:	77 27       	eor	r23, r23
     f96:	07 2e       	mov	r0, r23
     f98:	00 0c       	add	r0, r0
     f9a:	88 0b       	sbc	r24, r24
     f9c:	99 0b       	sbc	r25, r25
     f9e:	3d d6       	rcall	.+3194   	; 0x1c1a <__floatsisf>
     fa0:	a7 01       	movw	r20, r14
     fa2:	96 01       	movw	r18, r12
     fa4:	ee d6       	rcall	.+3548   	; 0x1d82 <__mulsf3>
     fa6:	0b d6       	rcall	.+3094   	; 0x1bbe <__fixunssfsi>
     fa8:	70 93 29 01 	sts	0x0129, r23	; 0x800129 <__TEXT_REGION_LENGTH__+0x700129>
     fac:	60 93 28 01 	sts	0x0128, r22	; 0x800128 <__TEXT_REGION_LENGTH__+0x700128>
}
     fb0:	ff 90       	pop	r15
     fb2:	ef 90       	pop	r14
     fb4:	df 90       	pop	r13
     fb6:	cf 90       	pop	r12
     fb8:	08 95       	ret

00000fba <_ZN6Timer516setDutyCycleComBEf>:

void Timer5::setDutyCycleComB( float dutyCycle )
{
     fba:	cf 92       	push	r12
     fbc:	df 92       	push	r13
     fbe:	ef 92       	push	r14
     fc0:	ff 92       	push	r15
     fc2:	6a 01       	movw	r12, r20
     fc4:	7b 01       	movw	r14, r22
	float percent = ICR5/100;
     fc6:	20 91 26 01 	lds	r18, 0x0126	; 0x800126 <__TEXT_REGION_LENGTH__+0x700126>
     fca:	30 91 27 01 	lds	r19, 0x0127	; 0x800127 <__TEXT_REGION_LENGTH__+0x700127>
     fce:	36 95       	lsr	r19
     fd0:	27 95       	ror	r18
     fd2:	36 95       	lsr	r19
     fd4:	27 95       	ror	r18
     fd6:	ab e7       	ldi	r26, 0x7B	; 123
     fd8:	b4 e1       	ldi	r27, 0x14	; 20
     fda:	36 d7       	rcall	.+3692   	; 0x1e48 <__umulhisi3>
     fdc:	96 95       	lsr	r25
     fde:	87 95       	ror	r24
	OCR5B = (uint8_t)percent*dutyCycle;
     fe0:	bc 01       	movw	r22, r24
     fe2:	77 27       	eor	r23, r23
     fe4:	07 2e       	mov	r0, r23
     fe6:	00 0c       	add	r0, r0
     fe8:	88 0b       	sbc	r24, r24
     fea:	99 0b       	sbc	r25, r25
     fec:	16 d6       	rcall	.+3116   	; 0x1c1a <__floatsisf>
     fee:	a7 01       	movw	r20, r14
     ff0:	96 01       	movw	r18, r12
     ff2:	c7 d6       	rcall	.+3470   	; 0x1d82 <__mulsf3>
     ff4:	e4 d5       	rcall	.+3016   	; 0x1bbe <__fixunssfsi>
     ff6:	70 93 2b 01 	sts	0x012B, r23	; 0x80012b <__TEXT_REGION_LENGTH__+0x70012b>
     ffa:	60 93 2a 01 	sts	0x012A, r22	; 0x80012a <__TEXT_REGION_LENGTH__+0x70012a>
}
     ffe:	ff 90       	pop	r15
    1000:	ef 90       	pop	r14
    1002:	df 90       	pop	r13
    1004:	cf 90       	pop	r12
    1006:	08 95       	ret

00001008 <_ZN6Timer516setDutyCycleComCEf>:

void Timer5::setDutyCycleComC( float dutyCycle )
{
    1008:	cf 92       	push	r12
    100a:	df 92       	push	r13
    100c:	ef 92       	push	r14
    100e:	ff 92       	push	r15
    1010:	6a 01       	movw	r12, r20
    1012:	7b 01       	movw	r14, r22
	float percent = ICR5/100;
    1014:	20 91 26 01 	lds	r18, 0x0126	; 0x800126 <__TEXT_REGION_LENGTH__+0x700126>
    1018:	30 91 27 01 	lds	r19, 0x0127	; 0x800127 <__TEXT_REGION_LENGTH__+0x700127>
    101c:	36 95       	lsr	r19
    101e:	27 95       	ror	r18
    1020:	36 95       	lsr	r19
    1022:	27 95       	ror	r18
    1024:	ab e7       	ldi	r26, 0x7B	; 123
    1026:	b4 e1       	ldi	r27, 0x14	; 20
    1028:	0f d7       	rcall	.+3614   	; 0x1e48 <__umulhisi3>
    102a:	96 95       	lsr	r25
    102c:	87 95       	ror	r24
	OCR5C = (uint8_t)percent*dutyCycle;
    102e:	bc 01       	movw	r22, r24
    1030:	77 27       	eor	r23, r23
    1032:	07 2e       	mov	r0, r23
    1034:	00 0c       	add	r0, r0
    1036:	88 0b       	sbc	r24, r24
    1038:	99 0b       	sbc	r25, r25
    103a:	ef d5       	rcall	.+3038   	; 0x1c1a <__floatsisf>
    103c:	a7 01       	movw	r20, r14
    103e:	96 01       	movw	r18, r12
    1040:	a0 d6       	rcall	.+3392   	; 0x1d82 <__mulsf3>
    1042:	bd d5       	rcall	.+2938   	; 0x1bbe <__fixunssfsi>
    1044:	70 93 2d 01 	sts	0x012D, r23	; 0x80012d <__TEXT_REGION_LENGTH__+0x70012d>
    1048:	60 93 2c 01 	sts	0x012C, r22	; 0x80012c <__TEXT_REGION_LENGTH__+0x70012c>
    104c:	ff 90       	pop	r15
    104e:	ef 90       	pop	r14
    1050:	df 90       	pop	r13
    1052:	cf 90       	pop	r12
    1054:	08 95       	ret

00001056 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
    1056:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
    1058:	03 96       	adiw	r24, 0x03	; 3
    105a:	92 83       	std	Z+2, r25	; 0x02
    105c:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    105e:	2f ef       	ldi	r18, 0xFF	; 255
    1060:	3f ef       	ldi	r19, 0xFF	; 255
    1062:	34 83       	std	Z+4, r19	; 0x04
    1064:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
    1066:	96 83       	std	Z+6, r25	; 0x06
    1068:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
    106a:	90 87       	std	Z+8, r25	; 0x08
    106c:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
    106e:	10 82       	st	Z, r1
    1070:	08 95       	ret

00001072 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    1072:	fc 01       	movw	r30, r24
    1074:	11 86       	std	Z+9, r1	; 0x09
    1076:	10 86       	std	Z+8, r1	; 0x08
    1078:	08 95       	ret

0000107a <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
    107a:	cf 93       	push	r28
    107c:	df 93       	push	r29
    107e:	fc 01       	movw	r30, r24
    1080:	db 01       	movw	r26, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
    1082:	21 81       	ldd	r18, Z+1	; 0x01
    1084:	32 81       	ldd	r19, Z+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
    1086:	e9 01       	movw	r28, r18
    1088:	8a 81       	ldd	r24, Y+2	; 0x02
    108a:	9b 81       	ldd	r25, Y+3	; 0x03
    108c:	13 96       	adiw	r26, 0x03	; 3
    108e:	9c 93       	st	X, r25
    1090:	8e 93       	st	-X, r24
    1092:	12 97       	sbiw	r26, 0x02	; 2
	pxNewListItem->pxPrevious = pxList->pxIndex;
    1094:	81 81       	ldd	r24, Z+1	; 0x01
    1096:	92 81       	ldd	r25, Z+2	; 0x02
    1098:	15 96       	adiw	r26, 0x05	; 5
    109a:	9c 93       	st	X, r25
    109c:	8e 93       	st	-X, r24
    109e:	14 97       	sbiw	r26, 0x04	; 4
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    10a0:	8a 81       	ldd	r24, Y+2	; 0x02
    10a2:	9b 81       	ldd	r25, Y+3	; 0x03
    10a4:	ec 01       	movw	r28, r24
    10a6:	7d 83       	std	Y+5, r23	; 0x05
    10a8:	6c 83       	std	Y+4, r22	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
    10aa:	e9 01       	movw	r28, r18
    10ac:	7b 83       	std	Y+3, r23	; 0x03
    10ae:	6a 83       	std	Y+2, r22	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
    10b0:	72 83       	std	Z+2, r23	; 0x02
    10b2:	61 83       	std	Z+1, r22	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    10b4:	19 96       	adiw	r26, 0x09	; 9
    10b6:	fc 93       	st	X, r31
    10b8:	ee 93       	st	-X, r30
    10ba:	18 97       	sbiw	r26, 0x08	; 8

	( pxList->uxNumberOfItems )++;
    10bc:	80 81       	ld	r24, Z
    10be:	8f 5f       	subi	r24, 0xFF	; 255
    10c0:	80 83       	st	Z, r24
}
    10c2:	df 91       	pop	r29
    10c4:	cf 91       	pop	r28
    10c6:	08 95       	ret

000010c8 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
    10c8:	cf 93       	push	r28
    10ca:	df 93       	push	r29
    10cc:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
    10ce:	48 81       	ld	r20, Y
    10d0:	59 81       	ldd	r21, Y+1	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    10d2:	4f 3f       	cpi	r20, 0xFF	; 255
    10d4:	2f ef       	ldi	r18, 0xFF	; 255
    10d6:	52 07       	cpc	r21, r18
    10d8:	31 f4       	brne	.+12     	; 0x10e6 <vListInsert+0x1e>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    10da:	dc 01       	movw	r26, r24
    10dc:	17 96       	adiw	r26, 0x07	; 7
    10de:	ed 91       	ld	r30, X+
    10e0:	fc 91       	ld	r31, X
    10e2:	18 97       	sbiw	r26, 0x08	; 8
    10e4:	0d c0       	rjmp	.+26     	; 0x1100 <vListInsert+0x38>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    10e6:	fc 01       	movw	r30, r24
    10e8:	33 96       	adiw	r30, 0x03	; 3
    10ea:	03 c0       	rjmp	.+6      	; 0x10f2 <vListInsert+0x2a>
    10ec:	02 80       	ldd	r0, Z+2	; 0x02
    10ee:	f3 81       	ldd	r31, Z+3	; 0x03
    10f0:	e0 2d       	mov	r30, r0
    10f2:	a2 81       	ldd	r26, Z+2	; 0x02
    10f4:	b3 81       	ldd	r27, Z+3	; 0x03
    10f6:	2d 91       	ld	r18, X+
    10f8:	3c 91       	ld	r19, X
    10fa:	42 17       	cp	r20, r18
    10fc:	53 07       	cpc	r21, r19
    10fe:	b0 f7       	brcc	.-20     	; 0x10ec <vListInsert+0x24>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    1100:	a2 81       	ldd	r26, Z+2	; 0x02
    1102:	b3 81       	ldd	r27, Z+3	; 0x03
    1104:	bb 83       	std	Y+3, r27	; 0x03
    1106:	aa 83       	std	Y+2, r26	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    1108:	15 96       	adiw	r26, 0x05	; 5
    110a:	dc 93       	st	X, r29
    110c:	ce 93       	st	-X, r28
    110e:	14 97       	sbiw	r26, 0x04	; 4
	pxNewListItem->pxPrevious = pxIterator;
    1110:	fd 83       	std	Y+5, r31	; 0x05
    1112:	ec 83       	std	Y+4, r30	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    1114:	d3 83       	std	Z+3, r29	; 0x03
    1116:	c2 83       	std	Z+2, r28	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1118:	99 87       	std	Y+9, r25	; 0x09
    111a:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    111c:	fc 01       	movw	r30, r24
    111e:	20 81       	ld	r18, Z
    1120:	2f 5f       	subi	r18, 0xFF	; 255
    1122:	20 83       	st	Z, r18
}
    1124:	df 91       	pop	r29
    1126:	cf 91       	pop	r28
    1128:	08 95       	ret

0000112a <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
    112a:	fc 01       	movw	r30, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    112c:	a2 81       	ldd	r26, Z+2	; 0x02
    112e:	b3 81       	ldd	r27, Z+3	; 0x03
    1130:	84 81       	ldd	r24, Z+4	; 0x04
    1132:	95 81       	ldd	r25, Z+5	; 0x05
    1134:	15 96       	adiw	r26, 0x05	; 5
    1136:	9c 93       	st	X, r25
    1138:	8e 93       	st	-X, r24
    113a:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    113c:	a4 81       	ldd	r26, Z+4	; 0x04
    113e:	b5 81       	ldd	r27, Z+5	; 0x05
    1140:	82 81       	ldd	r24, Z+2	; 0x02
    1142:	93 81       	ldd	r25, Z+3	; 0x03
    1144:	13 96       	adiw	r26, 0x03	; 3
    1146:	9c 93       	st	X, r25
    1148:	8e 93       	st	-X, r24
    114a:	12 97       	sbiw	r26, 0x02	; 2
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    114c:	a0 85       	ldd	r26, Z+8	; 0x08
    114e:	b1 85       	ldd	r27, Z+9	; 0x09

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    1150:	11 96       	adiw	r26, 0x01	; 1
    1152:	8d 91       	ld	r24, X+
    1154:	9c 91       	ld	r25, X
    1156:	12 97       	sbiw	r26, 0x02	; 2
    1158:	e8 17       	cp	r30, r24
    115a:	f9 07       	cpc	r31, r25
    115c:	31 f4       	brne	.+12     	; 0x116a <vListRemove+0x40>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    115e:	84 81       	ldd	r24, Z+4	; 0x04
    1160:	95 81       	ldd	r25, Z+5	; 0x05
    1162:	12 96       	adiw	r26, 0x02	; 2
    1164:	9c 93       	st	X, r25
    1166:	8e 93       	st	-X, r24
    1168:	11 97       	sbiw	r26, 0x01	; 1
	}

	pxItemToRemove->pvContainer = NULL;
    116a:	11 86       	std	Z+9, r1	; 0x09
    116c:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    116e:	8c 91       	ld	r24, X
    1170:	81 50       	subi	r24, 0x01	; 1
    1172:	8c 93       	st	X, r24
    1174:	08 95       	ret

00001176 <prvSetupTimerInterrupt>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    1176:	8a ef       	ldi	r24, 0xFA	; 250
    1178:	87 bd       	out	0x27, r24	; 39
    117a:	82 e0       	ldi	r24, 0x02	; 2
    117c:	84 bd       	out	0x24, r24	; 36
    117e:	93 e0       	ldi	r25, 0x03	; 3
    1180:	95 bd       	out	0x25, r25	; 37
    1182:	80 93 6e 00 	sts	0x006E, r24	; 0x80006e <__TEXT_REGION_LENGTH__+0x70006e>
    1186:	08 95       	ret

00001188 <pxPortInitialiseStack>:
    1188:	31 e1       	ldi	r19, 0x11	; 17
    118a:	fc 01       	movw	r30, r24
    118c:	30 83       	st	Z, r19
    118e:	31 97       	sbiw	r30, 0x01	; 1
    1190:	22 e2       	ldi	r18, 0x22	; 34
    1192:	20 83       	st	Z, r18
    1194:	31 97       	sbiw	r30, 0x01	; 1
    1196:	a3 e3       	ldi	r26, 0x33	; 51
    1198:	a0 83       	st	Z, r26
    119a:	31 97       	sbiw	r30, 0x01	; 1
    119c:	60 83       	st	Z, r22
    119e:	31 97       	sbiw	r30, 0x01	; 1
    11a0:	70 83       	st	Z, r23
    11a2:	31 97       	sbiw	r30, 0x01	; 1
    11a4:	10 82       	st	Z, r1
    11a6:	31 97       	sbiw	r30, 0x01	; 1
    11a8:	10 82       	st	Z, r1
    11aa:	31 97       	sbiw	r30, 0x01	; 1
    11ac:	60 e8       	ldi	r22, 0x80	; 128
    11ae:	60 83       	st	Z, r22
    11b0:	31 97       	sbiw	r30, 0x01	; 1
    11b2:	10 82       	st	Z, r1
    11b4:	31 97       	sbiw	r30, 0x01	; 1
    11b6:	10 82       	st	Z, r1
    11b8:	31 97       	sbiw	r30, 0x01	; 1
    11ba:	10 82       	st	Z, r1
    11bc:	31 97       	sbiw	r30, 0x01	; 1
    11be:	62 e0       	ldi	r22, 0x02	; 2
    11c0:	60 83       	st	Z, r22
    11c2:	31 97       	sbiw	r30, 0x01	; 1
    11c4:	63 e0       	ldi	r22, 0x03	; 3
    11c6:	60 83       	st	Z, r22
    11c8:	31 97       	sbiw	r30, 0x01	; 1
    11ca:	64 e0       	ldi	r22, 0x04	; 4
    11cc:	60 83       	st	Z, r22
    11ce:	31 97       	sbiw	r30, 0x01	; 1
    11d0:	65 e0       	ldi	r22, 0x05	; 5
    11d2:	60 83       	st	Z, r22
    11d4:	31 97       	sbiw	r30, 0x01	; 1
    11d6:	66 e0       	ldi	r22, 0x06	; 6
    11d8:	60 83       	st	Z, r22
    11da:	31 97       	sbiw	r30, 0x01	; 1
    11dc:	67 e0       	ldi	r22, 0x07	; 7
    11de:	60 83       	st	Z, r22
    11e0:	31 97       	sbiw	r30, 0x01	; 1
    11e2:	68 e0       	ldi	r22, 0x08	; 8
    11e4:	60 83       	st	Z, r22
    11e6:	31 97       	sbiw	r30, 0x01	; 1
    11e8:	69 e0       	ldi	r22, 0x09	; 9
    11ea:	60 83       	st	Z, r22
    11ec:	31 97       	sbiw	r30, 0x01	; 1
    11ee:	60 e1       	ldi	r22, 0x10	; 16
    11f0:	60 83       	st	Z, r22
    11f2:	31 97       	sbiw	r30, 0x01	; 1
    11f4:	30 83       	st	Z, r19
    11f6:	31 97       	sbiw	r30, 0x01	; 1
    11f8:	32 e1       	ldi	r19, 0x12	; 18
    11fa:	30 83       	st	Z, r19
    11fc:	31 97       	sbiw	r30, 0x01	; 1
    11fe:	33 e1       	ldi	r19, 0x13	; 19
    1200:	30 83       	st	Z, r19
    1202:	31 97       	sbiw	r30, 0x01	; 1
    1204:	34 e1       	ldi	r19, 0x14	; 20
    1206:	30 83       	st	Z, r19
    1208:	31 97       	sbiw	r30, 0x01	; 1
    120a:	35 e1       	ldi	r19, 0x15	; 21
    120c:	30 83       	st	Z, r19
    120e:	31 97       	sbiw	r30, 0x01	; 1
    1210:	36 e1       	ldi	r19, 0x16	; 22
    1212:	30 83       	st	Z, r19
    1214:	31 97       	sbiw	r30, 0x01	; 1
    1216:	37 e1       	ldi	r19, 0x17	; 23
    1218:	30 83       	st	Z, r19
    121a:	31 97       	sbiw	r30, 0x01	; 1
    121c:	38 e1       	ldi	r19, 0x18	; 24
    121e:	30 83       	st	Z, r19
    1220:	31 97       	sbiw	r30, 0x01	; 1
    1222:	39 e1       	ldi	r19, 0x19	; 25
    1224:	30 83       	st	Z, r19
    1226:	31 97       	sbiw	r30, 0x01	; 1
    1228:	30 e2       	ldi	r19, 0x20	; 32
    122a:	30 83       	st	Z, r19
    122c:	31 97       	sbiw	r30, 0x01	; 1
    122e:	31 e2       	ldi	r19, 0x21	; 33
    1230:	30 83       	st	Z, r19
    1232:	31 97       	sbiw	r30, 0x01	; 1
    1234:	20 83       	st	Z, r18
    1236:	31 97       	sbiw	r30, 0x01	; 1
    1238:	23 e2       	ldi	r18, 0x23	; 35
    123a:	20 83       	st	Z, r18
    123c:	31 97       	sbiw	r30, 0x01	; 1
    123e:	40 83       	st	Z, r20
    1240:	31 97       	sbiw	r30, 0x01	; 1
    1242:	50 83       	st	Z, r21
    1244:	31 97       	sbiw	r30, 0x01	; 1
    1246:	26 e2       	ldi	r18, 0x26	; 38
    1248:	20 83       	st	Z, r18
    124a:	31 97       	sbiw	r30, 0x01	; 1
    124c:	27 e2       	ldi	r18, 0x27	; 39
    124e:	20 83       	st	Z, r18
    1250:	31 97       	sbiw	r30, 0x01	; 1
    1252:	28 e2       	ldi	r18, 0x28	; 40
    1254:	20 83       	st	Z, r18
    1256:	31 97       	sbiw	r30, 0x01	; 1
    1258:	29 e2       	ldi	r18, 0x29	; 41
    125a:	20 83       	st	Z, r18
    125c:	31 97       	sbiw	r30, 0x01	; 1
    125e:	20 e3       	ldi	r18, 0x30	; 48
    1260:	20 83       	st	Z, r18
    1262:	31 97       	sbiw	r30, 0x01	; 1
    1264:	21 e3       	ldi	r18, 0x31	; 49
    1266:	20 83       	st	Z, r18
    1268:	89 97       	sbiw	r24, 0x29	; 41
    126a:	08 95       	ret

0000126c <xPortStartScheduler>:
    126c:	84 df       	rcall	.-248    	; 0x1176 <prvSetupTimerInterrupt>
    126e:	a0 91 8b 08 	lds	r26, 0x088B	; 0x80088b <pxCurrentTCB>
    1272:	b0 91 8c 08 	lds	r27, 0x088C	; 0x80088c <pxCurrentTCB+0x1>
    1276:	cd 91       	ld	r28, X+
    1278:	cd bf       	out	0x3d, r28	; 61
    127a:	dd 91       	ld	r29, X+
    127c:	de bf       	out	0x3e, r29	; 62
    127e:	ff 91       	pop	r31
    1280:	ef 91       	pop	r30
    1282:	df 91       	pop	r29
    1284:	cf 91       	pop	r28
    1286:	bf 91       	pop	r27
    1288:	af 91       	pop	r26
    128a:	9f 91       	pop	r25
    128c:	8f 91       	pop	r24
    128e:	7f 91       	pop	r23
    1290:	6f 91       	pop	r22
    1292:	5f 91       	pop	r21
    1294:	4f 91       	pop	r20
    1296:	3f 91       	pop	r19
    1298:	2f 91       	pop	r18
    129a:	1f 91       	pop	r17
    129c:	0f 91       	pop	r16
    129e:	ff 90       	pop	r15
    12a0:	ef 90       	pop	r14
    12a2:	df 90       	pop	r13
    12a4:	cf 90       	pop	r12
    12a6:	bf 90       	pop	r11
    12a8:	af 90       	pop	r10
    12aa:	9f 90       	pop	r9
    12ac:	8f 90       	pop	r8
    12ae:	7f 90       	pop	r7
    12b0:	6f 90       	pop	r6
    12b2:	5f 90       	pop	r5
    12b4:	4f 90       	pop	r4
    12b6:	3f 90       	pop	r3
    12b8:	2f 90       	pop	r2
    12ba:	1f 90       	pop	r1
    12bc:	0f 90       	pop	r0
    12be:	0c be       	out	0x3c, r0	; 60
    12c0:	0f 90       	pop	r0
    12c2:	0b be       	out	0x3b, r0	; 59
    12c4:	0f 90       	pop	r0
    12c6:	0f be       	out	0x3f, r0	; 63
    12c8:	0f 90       	pop	r0
    12ca:	08 95       	ret
    12cc:	81 e0       	ldi	r24, 0x01	; 1
    12ce:	08 95       	ret

000012d0 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    12d0:	0f 92       	push	r0
    12d2:	0f b6       	in	r0, 0x3f	; 63
    12d4:	f8 94       	cli
    12d6:	0f 92       	push	r0
    12d8:	0b b6       	in	r0, 0x3b	; 59
    12da:	0f 92       	push	r0
    12dc:	0c b6       	in	r0, 0x3c	; 60
    12de:	0f 92       	push	r0
    12e0:	1f 92       	push	r1
    12e2:	11 24       	eor	r1, r1
    12e4:	2f 92       	push	r2
    12e6:	3f 92       	push	r3
    12e8:	4f 92       	push	r4
    12ea:	5f 92       	push	r5
    12ec:	6f 92       	push	r6
    12ee:	7f 92       	push	r7
    12f0:	8f 92       	push	r8
    12f2:	9f 92       	push	r9
    12f4:	af 92       	push	r10
    12f6:	bf 92       	push	r11
    12f8:	cf 92       	push	r12
    12fa:	df 92       	push	r13
    12fc:	ef 92       	push	r14
    12fe:	ff 92       	push	r15
    1300:	0f 93       	push	r16
    1302:	1f 93       	push	r17
    1304:	2f 93       	push	r18
    1306:	3f 93       	push	r19
    1308:	4f 93       	push	r20
    130a:	5f 93       	push	r21
    130c:	6f 93       	push	r22
    130e:	7f 93       	push	r23
    1310:	8f 93       	push	r24
    1312:	9f 93       	push	r25
    1314:	af 93       	push	r26
    1316:	bf 93       	push	r27
    1318:	cf 93       	push	r28
    131a:	df 93       	push	r29
    131c:	ef 93       	push	r30
    131e:	ff 93       	push	r31
    1320:	a0 91 8b 08 	lds	r26, 0x088B	; 0x80088b <pxCurrentTCB>
    1324:	b0 91 8c 08 	lds	r27, 0x088C	; 0x80088c <pxCurrentTCB+0x1>
    1328:	0d b6       	in	r0, 0x3d	; 61
    132a:	0d 92       	st	X+, r0
    132c:	0e b6       	in	r0, 0x3e	; 62
    132e:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    1330:	84 d3       	rcall	.+1800   	; 0x1a3a <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1332:	a0 91 8b 08 	lds	r26, 0x088B	; 0x80088b <pxCurrentTCB>
    1336:	b0 91 8c 08 	lds	r27, 0x088C	; 0x80088c <pxCurrentTCB+0x1>
    133a:	cd 91       	ld	r28, X+
    133c:	cd bf       	out	0x3d, r28	; 61
    133e:	dd 91       	ld	r29, X+
    1340:	de bf       	out	0x3e, r29	; 62
    1342:	ff 91       	pop	r31
    1344:	ef 91       	pop	r30
    1346:	df 91       	pop	r29
    1348:	cf 91       	pop	r28
    134a:	bf 91       	pop	r27
    134c:	af 91       	pop	r26
    134e:	9f 91       	pop	r25
    1350:	8f 91       	pop	r24
    1352:	7f 91       	pop	r23
    1354:	6f 91       	pop	r22
    1356:	5f 91       	pop	r21
    1358:	4f 91       	pop	r20
    135a:	3f 91       	pop	r19
    135c:	2f 91       	pop	r18
    135e:	1f 91       	pop	r17
    1360:	0f 91       	pop	r16
    1362:	ff 90       	pop	r15
    1364:	ef 90       	pop	r14
    1366:	df 90       	pop	r13
    1368:	cf 90       	pop	r12
    136a:	bf 90       	pop	r11
    136c:	af 90       	pop	r10
    136e:	9f 90       	pop	r9
    1370:	8f 90       	pop	r8
    1372:	7f 90       	pop	r7
    1374:	6f 90       	pop	r6
    1376:	5f 90       	pop	r5
    1378:	4f 90       	pop	r4
    137a:	3f 90       	pop	r3
    137c:	2f 90       	pop	r2
    137e:	1f 90       	pop	r1
    1380:	0f 90       	pop	r0
    1382:	0c be       	out	0x3c, r0	; 60
    1384:	0f 90       	pop	r0
    1386:	0b be       	out	0x3b, r0	; 59
    1388:	0f 90       	pop	r0
    138a:	0f be       	out	0x3f, r0	; 63
    138c:	0f 90       	pop	r0

	asm volatile ( "ret" );
    138e:	08 95       	ret

00001390 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    1390:	0f 92       	push	r0
    1392:	0f b6       	in	r0, 0x3f	; 63
    1394:	f8 94       	cli
    1396:	0f 92       	push	r0
    1398:	0b b6       	in	r0, 0x3b	; 59
    139a:	0f 92       	push	r0
    139c:	0c b6       	in	r0, 0x3c	; 60
    139e:	0f 92       	push	r0
    13a0:	1f 92       	push	r1
    13a2:	11 24       	eor	r1, r1
    13a4:	2f 92       	push	r2
    13a6:	3f 92       	push	r3
    13a8:	4f 92       	push	r4
    13aa:	5f 92       	push	r5
    13ac:	6f 92       	push	r6
    13ae:	7f 92       	push	r7
    13b0:	8f 92       	push	r8
    13b2:	9f 92       	push	r9
    13b4:	af 92       	push	r10
    13b6:	bf 92       	push	r11
    13b8:	cf 92       	push	r12
    13ba:	df 92       	push	r13
    13bc:	ef 92       	push	r14
    13be:	ff 92       	push	r15
    13c0:	0f 93       	push	r16
    13c2:	1f 93       	push	r17
    13c4:	2f 93       	push	r18
    13c6:	3f 93       	push	r19
    13c8:	4f 93       	push	r20
    13ca:	5f 93       	push	r21
    13cc:	6f 93       	push	r22
    13ce:	7f 93       	push	r23
    13d0:	8f 93       	push	r24
    13d2:	9f 93       	push	r25
    13d4:	af 93       	push	r26
    13d6:	bf 93       	push	r27
    13d8:	cf 93       	push	r28
    13da:	df 93       	push	r29
    13dc:	ef 93       	push	r30
    13de:	ff 93       	push	r31
    13e0:	a0 91 8b 08 	lds	r26, 0x088B	; 0x80088b <pxCurrentTCB>
    13e4:	b0 91 8c 08 	lds	r27, 0x088C	; 0x80088c <pxCurrentTCB+0x1>
    13e8:	0d b6       	in	r0, 0x3d	; 61
    13ea:	0d 92       	st	X+, r0
    13ec:	0e b6       	in	r0, 0x3e	; 62
    13ee:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    13f0:	ef d1       	rcall	.+990    	; 0x17d0 <vTaskIncrementTick>
	vTaskSwitchContext();
    13f2:	23 d3       	rcall	.+1606   	; 0x1a3a <vTaskSwitchContext>
    13f4:	a0 91 8b 08 	lds	r26, 0x088B	; 0x80088b <pxCurrentTCB>
	portRESTORE_CONTEXT();
    13f8:	b0 91 8c 08 	lds	r27, 0x088C	; 0x80088c <pxCurrentTCB+0x1>
    13fc:	cd 91       	ld	r28, X+
    13fe:	cd bf       	out	0x3d, r28	; 61
    1400:	dd 91       	ld	r29, X+
    1402:	de bf       	out	0x3e, r29	; 62
    1404:	ff 91       	pop	r31
    1406:	ef 91       	pop	r30
    1408:	df 91       	pop	r29
    140a:	cf 91       	pop	r28
    140c:	bf 91       	pop	r27
    140e:	af 91       	pop	r26
    1410:	9f 91       	pop	r25
    1412:	8f 91       	pop	r24
    1414:	7f 91       	pop	r23
    1416:	6f 91       	pop	r22
    1418:	5f 91       	pop	r21
    141a:	4f 91       	pop	r20
    141c:	3f 91       	pop	r19
    141e:	2f 91       	pop	r18
    1420:	1f 91       	pop	r17
    1422:	0f 91       	pop	r16
    1424:	ff 90       	pop	r15
    1426:	ef 90       	pop	r14
    1428:	df 90       	pop	r13
    142a:	cf 90       	pop	r12
    142c:	bf 90       	pop	r11
    142e:	af 90       	pop	r10
    1430:	9f 90       	pop	r9
    1432:	8f 90       	pop	r8
    1434:	7f 90       	pop	r7
    1436:	6f 90       	pop	r6
    1438:	5f 90       	pop	r5
    143a:	4f 90       	pop	r4
    143c:	3f 90       	pop	r3
    143e:	2f 90       	pop	r2
    1440:	1f 90       	pop	r1
    1442:	0f 90       	pop	r0
    1444:	0c be       	out	0x3c, r0	; 60
    1446:	0f 90       	pop	r0
    1448:	0b be       	out	0x3b, r0	; 59
    144a:	0f 90       	pop	r0
    144c:	0f be       	out	0x3f, r0	; 63
    144e:	0f 90       	pop	r0
    1450:	08 95       	ret

00001452 <__vector_21>:
	asm volatile ( "ret" );
    1452:	9e df       	rcall	.-196    	; 0x1390 <vPortYieldFromTick>
//	void SIG_OUTPUT_COMPARE1A( void )
	void TIMER0_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER0_COMPA_vect( void )
	{
		vPortYieldFromTick();
		asm volatile ( "reti" );
    1454:	18 95       	reti

00001456 <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    1456:	cf 93       	push	r28
    1458:	df 93       	push	r29
    145a:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
    145c:	b3 d1       	rcall	.+870    	; 0x17c4 <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
    145e:	20 91 7a 02 	lds	r18, 0x027A	; 0x80027a <xNextFreeByte>
    1462:	30 91 7b 02 	lds	r19, 0x027B	; 0x80027b <xNextFreeByte+0x1>
    1466:	c9 01       	movw	r24, r18
    1468:	8c 0f       	add	r24, r28
    146a:	9d 1f       	adc	r25, r29
    146c:	8c 3d       	cpi	r24, 0xDC	; 220
    146e:	45 e0       	ldi	r20, 0x05	; 5
    1470:	94 07       	cpc	r25, r20
    1472:	58 f4       	brcc	.+22     	; 0x148a <pvPortMalloc+0x34>
    1474:	28 17       	cp	r18, r24
    1476:	39 07       	cpc	r19, r25
    1478:	58 f4       	brcc	.+22     	; 0x1490 <pvPortMalloc+0x3a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
    147a:	e9 01       	movw	r28, r18
    147c:	c4 58       	subi	r28, 0x84	; 132
    147e:	dd 4f       	sbci	r29, 0xFD	; 253
			xNextFreeByte += xWantedSize;			
    1480:	90 93 7b 02 	sts	0x027B, r25	; 0x80027b <xNextFreeByte+0x1>
    1484:	80 93 7a 02 	sts	0x027A, r24	; 0x80027a <xNextFreeByte>
    1488:	05 c0       	rjmp	.+10     	; 0x1494 <pvPortMalloc+0x3e>
static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL; 
    148a:	c0 e0       	ldi	r28, 0x00	; 0
    148c:	d0 e0       	ldi	r29, 0x00	; 0
    148e:	02 c0       	rjmp	.+4      	; 0x1494 <pvPortMalloc+0x3e>
    1490:	c0 e0       	ldi	r28, 0x00	; 0
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
			xNextFreeByte += xWantedSize;			
		}	
	}
	xTaskResumeAll();
    1492:	d0 e0       	ldi	r29, 0x00	; 0
    1494:	44 d2       	rcall	.+1160   	; 0x191e <xTaskResumeAll>
		}
	}
	#endif	

	return pvReturn;
}
    1496:	ce 01       	movw	r24, r28
    1498:	df 91       	pop	r29
    149a:	cf 91       	pop	r28
    149c:	08 95       	ret

0000149e <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    149e:	08 95       	ret

000014a0 <prvIdleTask>:
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
		}
	}
    14a0:	80 91 82 08 	lds	r24, 0x0882	; 0x800882 <pxReadyTasksLists>
    14a4:	82 30       	cpi	r24, 0x02	; 2
    14a6:	e0 f3       	brcs	.-8      	; 0x14a0 <prvIdleTask>
    14a8:	13 df       	rcall	.-474    	; 0x12d0 <vPortYield>
    14aa:	fa cf       	rjmp	.-12     	; 0x14a0 <prvIdleTask>

000014ac <prvAllocateTCBAndStack>:
    14ac:	ef 92       	push	r14
    14ae:	ff 92       	push	r15
    14b0:	0f 93       	push	r16
    14b2:	1f 93       	push	r17
    14b4:	cf 93       	push	r28
    14b6:	df 93       	push	r29
    14b8:	7c 01       	movw	r14, r24
    14ba:	eb 01       	movw	r28, r22
    14bc:	81 e2       	ldi	r24, 0x21	; 33
    14be:	90 e0       	ldi	r25, 0x00	; 0
    14c0:	ca df       	rcall	.-108    	; 0x1456 <pvPortMalloc>
    14c2:	8c 01       	movw	r16, r24
    14c4:	89 2b       	or	r24, r25
    14c6:	a1 f0       	breq	.+40     	; 0x14f0 <prvAllocateTCBAndStack+0x44>
    14c8:	20 97       	sbiw	r28, 0x00	; 0
    14ca:	19 f4       	brne	.+6      	; 0x14d2 <prvAllocateTCBAndStack+0x26>
    14cc:	c7 01       	movw	r24, r14
    14ce:	c3 df       	rcall	.-122    	; 0x1456 <pvPortMalloc>
    14d0:	01 c0       	rjmp	.+2      	; 0x14d4 <prvAllocateTCBAndStack+0x28>
    14d2:	ce 01       	movw	r24, r28
    14d4:	f8 01       	movw	r30, r16
    14d6:	90 8f       	std	Z+24, r25	; 0x18
    14d8:	87 8b       	std	Z+23, r24	; 0x17
    14da:	00 97       	sbiw	r24, 0x00	; 0
    14dc:	29 f4       	brne	.+10     	; 0x14e8 <prvAllocateTCBAndStack+0x3c>
    14de:	c8 01       	movw	r24, r16
    14e0:	de df       	rcall	.-68     	; 0x149e <vPortFree>
    14e2:	00 e0       	ldi	r16, 0x00	; 0
    14e4:	10 e0       	ldi	r17, 0x00	; 0
    14e6:	04 c0       	rjmp	.+8      	; 0x14f0 <prvAllocateTCBAndStack+0x44>
    14e8:	a7 01       	movw	r20, r14
    14ea:	65 ea       	ldi	r22, 0xA5	; 165
    14ec:	70 e0       	ldi	r23, 0x00	; 0
    14ee:	dc d5       	rcall	.+3000   	; 0x20a8 <memset>
    14f0:	c8 01       	movw	r24, r16
    14f2:	df 91       	pop	r29
    14f4:	cf 91       	pop	r28
    14f6:	1f 91       	pop	r17
    14f8:	0f 91       	pop	r16
    14fa:	ff 90       	pop	r15
    14fc:	ef 90       	pop	r14
    14fe:	08 95       	ret

00001500 <prvInitialiseTCBVariables>:
    1500:	1f 93       	push	r17
    1502:	cf 93       	push	r28
    1504:	df 93       	push	r29
    1506:	ec 01       	movw	r28, r24
    1508:	14 2f       	mov	r17, r20
    150a:	48 e0       	ldi	r20, 0x08	; 8
    150c:	50 e0       	ldi	r21, 0x00	; 0
    150e:	49 96       	adiw	r24, 0x19	; 25
    1510:	d2 d5       	rcall	.+2980   	; 0x20b6 <strncpy>
    1512:	18 a2       	std	Y+32, r1	; 0x20
    1514:	11 11       	cpse	r17, r1
    1516:	10 e0       	ldi	r17, 0x00	; 0
    1518:	1e 8b       	std	Y+22, r17	; 0x16
    151a:	ce 01       	movw	r24, r28
    151c:	02 96       	adiw	r24, 0x02	; 2
    151e:	a9 dd       	rcall	.-1198   	; 0x1072 <vListInitialiseItem>
    1520:	ce 01       	movw	r24, r28
    1522:	0c 96       	adiw	r24, 0x0c	; 12
    1524:	a6 dd       	rcall	.-1204   	; 0x1072 <vListInitialiseItem>
    1526:	d9 87       	std	Y+9, r29	; 0x09
    1528:	c8 87       	std	Y+8, r28	; 0x08
    152a:	81 e0       	ldi	r24, 0x01	; 1
    152c:	90 e0       	ldi	r25, 0x00	; 0
    152e:	81 1b       	sub	r24, r17
    1530:	91 09       	sbc	r25, r1
    1532:	9d 87       	std	Y+13, r25	; 0x0d
    1534:	8c 87       	std	Y+12, r24	; 0x0c
    1536:	db 8b       	std	Y+19, r29	; 0x13
    1538:	ca 8b       	std	Y+18, r28	; 0x12
    153a:	df 91       	pop	r29
    153c:	cf 91       	pop	r28
    153e:	1f 91       	pop	r17
    1540:	08 95       	ret

00001542 <prvInitialiseTaskLists>:
    1542:	cf 93       	push	r28
    1544:	c0 e0       	ldi	r28, 0x00	; 0
    1546:	0f c0       	rjmp	.+30     	; 0x1566 <prvInitialiseTaskLists+0x24>
    1548:	8c 2f       	mov	r24, r28
    154a:	90 e0       	ldi	r25, 0x00	; 0
    154c:	9c 01       	movw	r18, r24
    154e:	22 0f       	add	r18, r18
    1550:	33 1f       	adc	r19, r19
    1552:	22 0f       	add	r18, r18
    1554:	33 1f       	adc	r19, r19
    1556:	22 0f       	add	r18, r18
    1558:	33 1f       	adc	r19, r19
    155a:	82 0f       	add	r24, r18
    155c:	93 1f       	adc	r25, r19
    155e:	8e 57       	subi	r24, 0x7E	; 126
    1560:	97 4f       	sbci	r25, 0xF7	; 247
    1562:	79 dd       	rcall	.-1294   	; 0x1056 <vListInitialise>
    1564:	cf 5f       	subi	r28, 0xFF	; 255
    1566:	cc 23       	and	r28, r28
    1568:	79 f3       	breq	.-34     	; 0x1548 <prvInitialiseTaskLists+0x6>
    156a:	89 e7       	ldi	r24, 0x79	; 121
    156c:	98 e0       	ldi	r25, 0x08	; 8
    156e:	73 dd       	rcall	.-1306   	; 0x1056 <vListInitialise>
    1570:	80 e7       	ldi	r24, 0x70	; 112
    1572:	98 e0       	ldi	r25, 0x08	; 8
    1574:	70 dd       	rcall	.-1312   	; 0x1056 <vListInitialise>
    1576:	83 e6       	ldi	r24, 0x63	; 99
    1578:	98 e0       	ldi	r25, 0x08	; 8
    157a:	6d dd       	rcall	.-1318   	; 0x1056 <vListInitialise>
    157c:	89 e7       	ldi	r24, 0x79	; 121
    157e:	98 e0       	ldi	r25, 0x08	; 8
    1580:	90 93 6f 08 	sts	0x086F, r25	; 0x80086f <pxDelayedTaskList+0x1>
    1584:	80 93 6e 08 	sts	0x086E, r24	; 0x80086e <pxDelayedTaskList>
    1588:	80 e7       	ldi	r24, 0x70	; 112
    158a:	98 e0       	ldi	r25, 0x08	; 8
    158c:	90 93 6d 08 	sts	0x086D, r25	; 0x80086d <pxOverflowDelayedTaskList+0x1>
    1590:	80 93 6c 08 	sts	0x086C, r24	; 0x80086c <pxOverflowDelayedTaskList>
    1594:	cf 91       	pop	r28
    1596:	08 95       	ret

00001598 <prvAddCurrentTaskToDelayedList>:
    1598:	cf 93       	push	r28
    159a:	df 93       	push	r29
    159c:	ec 01       	movw	r28, r24
    159e:	e0 91 8b 08 	lds	r30, 0x088B	; 0x80088b <pxCurrentTCB>
    15a2:	f0 91 8c 08 	lds	r31, 0x088C	; 0x80088c <pxCurrentTCB+0x1>
    15a6:	93 83       	std	Z+3, r25	; 0x03
    15a8:	82 83       	std	Z+2, r24	; 0x02
    15aa:	80 91 60 08 	lds	r24, 0x0860	; 0x800860 <xTickCount>
    15ae:	90 91 61 08 	lds	r25, 0x0861	; 0x800861 <xTickCount+0x1>
    15b2:	c8 17       	cp	r28, r24
    15b4:	d9 07       	cpc	r29, r25
    15b6:	60 f4       	brcc	.+24     	; 0x15d0 <prvAddCurrentTaskToDelayedList+0x38>
    15b8:	60 91 8b 08 	lds	r22, 0x088B	; 0x80088b <pxCurrentTCB>
    15bc:	70 91 8c 08 	lds	r23, 0x088C	; 0x80088c <pxCurrentTCB+0x1>
    15c0:	80 91 6c 08 	lds	r24, 0x086C	; 0x80086c <pxOverflowDelayedTaskList>
    15c4:	90 91 6d 08 	lds	r25, 0x086D	; 0x80086d <pxOverflowDelayedTaskList+0x1>
    15c8:	6e 5f       	subi	r22, 0xFE	; 254
    15ca:	7f 4f       	sbci	r23, 0xFF	; 255
    15cc:	7d dd       	rcall	.-1286   	; 0x10c8 <vListInsert>
    15ce:	16 c0       	rjmp	.+44     	; 0x15fc <prvAddCurrentTaskToDelayedList+0x64>
    15d0:	60 91 8b 08 	lds	r22, 0x088B	; 0x80088b <pxCurrentTCB>
    15d4:	70 91 8c 08 	lds	r23, 0x088C	; 0x80088c <pxCurrentTCB+0x1>
    15d8:	80 91 6e 08 	lds	r24, 0x086E	; 0x80086e <pxDelayedTaskList>
    15dc:	90 91 6f 08 	lds	r25, 0x086F	; 0x80086f <pxDelayedTaskList+0x1>
    15e0:	6e 5f       	subi	r22, 0xFE	; 254
    15e2:	7f 4f       	sbci	r23, 0xFF	; 255
    15e4:	71 dd       	rcall	.-1310   	; 0x10c8 <vListInsert>
    15e6:	80 91 0b 02 	lds	r24, 0x020B	; 0x80020b <xNextTaskUnblockTime>
    15ea:	90 91 0c 02 	lds	r25, 0x020C	; 0x80020c <xNextTaskUnblockTime+0x1>
    15ee:	c8 17       	cp	r28, r24
    15f0:	d9 07       	cpc	r29, r25
    15f2:	20 f4       	brcc	.+8      	; 0x15fc <prvAddCurrentTaskToDelayedList+0x64>
    15f4:	d0 93 0c 02 	sts	0x020C, r29	; 0x80020c <xNextTaskUnblockTime+0x1>
    15f8:	c0 93 0b 02 	sts	0x020B, r28	; 0x80020b <xNextTaskUnblockTime>
    15fc:	df 91       	pop	r29
    15fe:	cf 91       	pop	r28
    1600:	08 95       	ret

00001602 <xTaskGenericCreate>:
    1602:	2f 92       	push	r2
    1604:	3f 92       	push	r3
    1606:	4f 92       	push	r4
    1608:	5f 92       	push	r5
    160a:	7f 92       	push	r7
    160c:	8f 92       	push	r8
    160e:	9f 92       	push	r9
    1610:	af 92       	push	r10
    1612:	bf 92       	push	r11
    1614:	cf 92       	push	r12
    1616:	df 92       	push	r13
    1618:	ef 92       	push	r14
    161a:	ff 92       	push	r15
    161c:	0f 93       	push	r16
    161e:	1f 93       	push	r17
    1620:	cf 93       	push	r28
    1622:	df 93       	push	r29
    1624:	00 d0       	rcall	.+0      	; 0x1626 <xTaskGenericCreate+0x24>
    1626:	1f 92       	push	r1
    1628:	cd b7       	in	r28, 0x3d	; 61
    162a:	de b7       	in	r29, 0x3e	; 62
    162c:	9a 83       	std	Y+2, r25	; 0x02
    162e:	89 83       	std	Y+1, r24	; 0x01
    1630:	4b 01       	movw	r8, r22
    1632:	5c 83       	std	Y+4, r21	; 0x04
    1634:	4b 83       	std	Y+3, r20	; 0x03
    1636:	19 01       	movw	r2, r18
    1638:	70 2e       	mov	r7, r16
    163a:	b6 01       	movw	r22, r12
    163c:	25 01       	movw	r4, r10
    163e:	ca 01       	movw	r24, r20
    1640:	35 df       	rcall	.-406    	; 0x14ac <prvAllocateTCBAndStack>
    1642:	5c 01       	movw	r10, r24
    1644:	00 97       	sbiw	r24, 0x00	; 0
    1646:	09 f4       	brne	.+2      	; 0x164a <xTaskGenericCreate+0x48>
    1648:	6c c0       	rjmp	.+216    	; 0x1722 <xTaskGenericCreate+0x120>
    164a:	fc 01       	movw	r30, r24
    164c:	c7 88       	ldd	r12, Z+23	; 0x17
    164e:	d0 8c       	ldd	r13, Z+24	; 0x18
    1650:	8b 81       	ldd	r24, Y+3	; 0x03
    1652:	9c 81       	ldd	r25, Y+4	; 0x04
    1654:	01 97       	sbiw	r24, 0x01	; 1
    1656:	c8 0e       	add	r12, r24
    1658:	d9 1e       	adc	r13, r25
    165a:	0b 81       	ldd	r16, Y+3	; 0x03
    165c:	1c 81       	ldd	r17, Y+4	; 0x04
    165e:	92 01       	movw	r18, r4
    1660:	47 2d       	mov	r20, r7
    1662:	b4 01       	movw	r22, r8
    1664:	c5 01       	movw	r24, r10
    1666:	4c df       	rcall	.-360    	; 0x1500 <prvInitialiseTCBVariables>
    1668:	a1 01       	movw	r20, r2
    166a:	69 81       	ldd	r22, Y+1	; 0x01
    166c:	7a 81       	ldd	r23, Y+2	; 0x02
    166e:	c6 01       	movw	r24, r12
    1670:	8b dd       	rcall	.-1258   	; 0x1188 <pxPortInitialiseStack>
    1672:	f5 01       	movw	r30, r10
    1674:	91 83       	std	Z+1, r25	; 0x01
    1676:	80 83       	st	Z, r24
    1678:	e1 14       	cp	r14, r1
    167a:	f1 04       	cpc	r15, r1
    167c:	19 f0       	breq	.+6      	; 0x1684 <xTaskGenericCreate+0x82>
    167e:	f7 01       	movw	r30, r14
    1680:	b1 82       	std	Z+1, r11	; 0x01
    1682:	a0 82       	st	Z, r10
    1684:	0f b6       	in	r0, 0x3f	; 63
    1686:	f8 94       	cli
    1688:	0f 92       	push	r0
    168a:	80 91 62 08 	lds	r24, 0x0862	; 0x800862 <uxCurrentNumberOfTasks>
    168e:	8f 5f       	subi	r24, 0xFF	; 255
    1690:	80 93 62 08 	sts	0x0862, r24	; 0x800862 <uxCurrentNumberOfTasks>
    1694:	80 91 8b 08 	lds	r24, 0x088B	; 0x80088b <pxCurrentTCB>
    1698:	90 91 8c 08 	lds	r25, 0x088C	; 0x80088c <pxCurrentTCB+0x1>
    169c:	89 2b       	or	r24, r25
    169e:	51 f4       	brne	.+20     	; 0x16b4 <xTaskGenericCreate+0xb2>
    16a0:	b0 92 8c 08 	sts	0x088C, r11	; 0x80088c <pxCurrentTCB+0x1>
    16a4:	a0 92 8b 08 	sts	0x088B, r10	; 0x80088b <pxCurrentTCB>
    16a8:	80 91 62 08 	lds	r24, 0x0862	; 0x800862 <uxCurrentNumberOfTasks>
    16ac:	81 30       	cpi	r24, 0x01	; 1
    16ae:	89 f4       	brne	.+34     	; 0x16d2 <xTaskGenericCreate+0xd0>
    16b0:	48 df       	rcall	.-368    	; 0x1542 <prvInitialiseTaskLists>
    16b2:	0f c0       	rjmp	.+30     	; 0x16d2 <xTaskGenericCreate+0xd0>
    16b4:	80 91 5d 08 	lds	r24, 0x085D	; 0x80085d <xSchedulerRunning>
    16b8:	81 11       	cpse	r24, r1
    16ba:	0b c0       	rjmp	.+22     	; 0x16d2 <xTaskGenericCreate+0xd0>
    16bc:	e0 91 8b 08 	lds	r30, 0x088B	; 0x80088b <pxCurrentTCB>
    16c0:	f0 91 8c 08 	lds	r31, 0x088C	; 0x80088c <pxCurrentTCB+0x1>
    16c4:	86 89       	ldd	r24, Z+22	; 0x16
    16c6:	78 16       	cp	r7, r24
    16c8:	20 f0       	brcs	.+8      	; 0x16d2 <xTaskGenericCreate+0xd0>
    16ca:	b0 92 8c 08 	sts	0x088C, r11	; 0x80088c <pxCurrentTCB+0x1>
    16ce:	a0 92 8b 08 	sts	0x088B, r10	; 0x80088b <pxCurrentTCB>
    16d2:	f5 01       	movw	r30, r10
    16d4:	86 89       	ldd	r24, Z+22	; 0x16
    16d6:	90 91 5f 08 	lds	r25, 0x085F	; 0x80085f <uxTopUsedPriority>
    16da:	98 17       	cp	r25, r24
    16dc:	10 f4       	brcc	.+4      	; 0x16e2 <xTaskGenericCreate+0xe0>
    16de:	80 93 5f 08 	sts	0x085F, r24	; 0x80085f <uxTopUsedPriority>
    16e2:	90 91 58 08 	lds	r25, 0x0858	; 0x800858 <uxTCBNumber>
    16e6:	9f 5f       	subi	r25, 0xFF	; 255
    16e8:	90 93 58 08 	sts	0x0858, r25	; 0x800858 <uxTCBNumber>
    16ec:	90 91 5e 08 	lds	r25, 0x085E	; 0x80085e <uxTopReadyPriority>
    16f0:	98 17       	cp	r25, r24
    16f2:	10 f4       	brcc	.+4      	; 0x16f8 <xTaskGenericCreate+0xf6>
    16f4:	80 93 5e 08 	sts	0x085E, r24	; 0x80085e <uxTopReadyPriority>
    16f8:	90 e0       	ldi	r25, 0x00	; 0
    16fa:	b5 01       	movw	r22, r10
    16fc:	6e 5f       	subi	r22, 0xFE	; 254
    16fe:	7f 4f       	sbci	r23, 0xFF	; 255
    1700:	9c 01       	movw	r18, r24
    1702:	22 0f       	add	r18, r18
    1704:	33 1f       	adc	r19, r19
    1706:	22 0f       	add	r18, r18
    1708:	33 1f       	adc	r19, r19
    170a:	22 0f       	add	r18, r18
    170c:	33 1f       	adc	r19, r19
    170e:	82 0f       	add	r24, r18
    1710:	93 1f       	adc	r25, r19
    1712:	8e 57       	subi	r24, 0x7E	; 126
    1714:	97 4f       	sbci	r25, 0xF7	; 247
    1716:	b1 dc       	rcall	.-1694   	; 0x107a <vListInsertEnd>
    1718:	0f 90       	pop	r0
    171a:	0f be       	out	0x3f, r0	; 63
    171c:	f1 e0       	ldi	r31, 0x01	; 1
    171e:	f9 83       	std	Y+1, r31	; 0x01
    1720:	02 c0       	rjmp	.+4      	; 0x1726 <xTaskGenericCreate+0x124>
    1722:	8f ef       	ldi	r24, 0xFF	; 255
    1724:	89 83       	std	Y+1, r24	; 0x01
    1726:	e9 81       	ldd	r30, Y+1	; 0x01
    1728:	e1 30       	cpi	r30, 0x01	; 1
    172a:	61 f4       	brne	.+24     	; 0x1744 <xTaskGenericCreate+0x142>
    172c:	80 91 5d 08 	lds	r24, 0x085D	; 0x80085d <xSchedulerRunning>
    1730:	88 23       	and	r24, r24
    1732:	41 f0       	breq	.+16     	; 0x1744 <xTaskGenericCreate+0x142>
    1734:	e0 91 8b 08 	lds	r30, 0x088B	; 0x80088b <pxCurrentTCB>
    1738:	f0 91 8c 08 	lds	r31, 0x088C	; 0x80088c <pxCurrentTCB+0x1>
    173c:	86 89       	ldd	r24, Z+22	; 0x16
    173e:	87 15       	cp	r24, r7
    1740:	08 f4       	brcc	.+2      	; 0x1744 <xTaskGenericCreate+0x142>
    1742:	c6 dd       	rcall	.-1140   	; 0x12d0 <vPortYield>
    1744:	89 81       	ldd	r24, Y+1	; 0x01
    1746:	0f 90       	pop	r0
    1748:	0f 90       	pop	r0
    174a:	0f 90       	pop	r0
    174c:	0f 90       	pop	r0
    174e:	df 91       	pop	r29
    1750:	cf 91       	pop	r28
    1752:	1f 91       	pop	r17
    1754:	0f 91       	pop	r16
    1756:	ff 90       	pop	r15
    1758:	ef 90       	pop	r14
    175a:	df 90       	pop	r13
    175c:	cf 90       	pop	r12
    175e:	bf 90       	pop	r11
    1760:	af 90       	pop	r10
    1762:	9f 90       	pop	r9
    1764:	8f 90       	pop	r8
    1766:	7f 90       	pop	r7
    1768:	5f 90       	pop	r5
    176a:	4f 90       	pop	r4
    176c:	3f 90       	pop	r3
    176e:	2f 90       	pop	r2
    1770:	08 95       	ret

00001772 <vTaskStartScheduler>:
    1772:	af 92       	push	r10
    1774:	bf 92       	push	r11
    1776:	cf 92       	push	r12
    1778:	df 92       	push	r13
    177a:	ef 92       	push	r14
    177c:	ff 92       	push	r15
    177e:	0f 93       	push	r16
    1780:	a1 2c       	mov	r10, r1
    1782:	b1 2c       	mov	r11, r1
    1784:	c1 2c       	mov	r12, r1
    1786:	d1 2c       	mov	r13, r1
    1788:	e1 2c       	mov	r14, r1
    178a:	f1 2c       	mov	r15, r1
    178c:	00 e0       	ldi	r16, 0x00	; 0
    178e:	20 e0       	ldi	r18, 0x00	; 0
    1790:	30 e0       	ldi	r19, 0x00	; 0
    1792:	45 e5       	ldi	r20, 0x55	; 85
    1794:	50 e0       	ldi	r21, 0x00	; 0
    1796:	6d e6       	ldi	r22, 0x6D	; 109
    1798:	72 e0       	ldi	r23, 0x02	; 2
    179a:	80 e5       	ldi	r24, 0x50	; 80
    179c:	9a e0       	ldi	r25, 0x0A	; 10
    179e:	31 df       	rcall	.-414    	; 0x1602 <xTaskGenericCreate>
    17a0:	81 30       	cpi	r24, 0x01	; 1
    17a2:	41 f4       	brne	.+16     	; 0x17b4 <vTaskStartScheduler+0x42>
    17a4:	f8 94       	cli
    17a6:	80 93 5d 08 	sts	0x085D, r24	; 0x80085d <xSchedulerRunning>
    17aa:	10 92 61 08 	sts	0x0861, r1	; 0x800861 <xTickCount+0x1>
    17ae:	10 92 60 08 	sts	0x0860, r1	; 0x800860 <xTickCount>
    17b2:	5c dd       	rcall	.-1352   	; 0x126c <xPortStartScheduler>
    17b4:	0f 91       	pop	r16
    17b6:	ff 90       	pop	r15
    17b8:	ef 90       	pop	r14
    17ba:	df 90       	pop	r13
    17bc:	cf 90       	pop	r12
    17be:	bf 90       	pop	r11
    17c0:	af 90       	pop	r10
    17c2:	08 95       	ret

000017c4 <vTaskSuspendAll>:
    17c4:	80 91 5c 08 	lds	r24, 0x085C	; 0x80085c <uxSchedulerSuspended>
    17c8:	8f 5f       	subi	r24, 0xFF	; 255
    17ca:	80 93 5c 08 	sts	0x085C, r24	; 0x80085c <uxSchedulerSuspended>
    17ce:	08 95       	ret

000017d0 <vTaskIncrementTick>:
    17d0:	0f 93       	push	r16
    17d2:	1f 93       	push	r17
    17d4:	cf 93       	push	r28
    17d6:	df 93       	push	r29
    17d8:	80 91 5c 08 	lds	r24, 0x085C	; 0x80085c <uxSchedulerSuspended>
    17dc:	81 11       	cpse	r24, r1
    17de:	95 c0       	rjmp	.+298    	; 0x190a <vTaskIncrementTick+0x13a>
    17e0:	80 91 60 08 	lds	r24, 0x0860	; 0x800860 <xTickCount>
    17e4:	90 91 61 08 	lds	r25, 0x0861	; 0x800861 <xTickCount+0x1>
    17e8:	01 96       	adiw	r24, 0x01	; 1
    17ea:	90 93 61 08 	sts	0x0861, r25	; 0x800861 <xTickCount+0x1>
    17ee:	80 93 60 08 	sts	0x0860, r24	; 0x800860 <xTickCount>
    17f2:	80 91 60 08 	lds	r24, 0x0860	; 0x800860 <xTickCount>
    17f6:	90 91 61 08 	lds	r25, 0x0861	; 0x800861 <xTickCount+0x1>
    17fa:	89 2b       	or	r24, r25
    17fc:	99 f5       	brne	.+102    	; 0x1864 <vTaskIncrementTick+0x94>
    17fe:	80 91 6e 08 	lds	r24, 0x086E	; 0x80086e <pxDelayedTaskList>
    1802:	90 91 6f 08 	lds	r25, 0x086F	; 0x80086f <pxDelayedTaskList+0x1>
    1806:	20 91 6c 08 	lds	r18, 0x086C	; 0x80086c <pxOverflowDelayedTaskList>
    180a:	30 91 6d 08 	lds	r19, 0x086D	; 0x80086d <pxOverflowDelayedTaskList+0x1>
    180e:	30 93 6f 08 	sts	0x086F, r19	; 0x80086f <pxDelayedTaskList+0x1>
    1812:	20 93 6e 08 	sts	0x086E, r18	; 0x80086e <pxDelayedTaskList>
    1816:	90 93 6d 08 	sts	0x086D, r25	; 0x80086d <pxOverflowDelayedTaskList+0x1>
    181a:	80 93 6c 08 	sts	0x086C, r24	; 0x80086c <pxOverflowDelayedTaskList>
    181e:	80 91 59 08 	lds	r24, 0x0859	; 0x800859 <xNumOfOverflows>
    1822:	8f 5f       	subi	r24, 0xFF	; 255
    1824:	80 93 59 08 	sts	0x0859, r24	; 0x800859 <xNumOfOverflows>
    1828:	e0 91 6e 08 	lds	r30, 0x086E	; 0x80086e <pxDelayedTaskList>
    182c:	f0 91 6f 08 	lds	r31, 0x086F	; 0x80086f <pxDelayedTaskList+0x1>
    1830:	80 81       	ld	r24, Z
    1832:	81 11       	cpse	r24, r1
    1834:	07 c0       	rjmp	.+14     	; 0x1844 <vTaskIncrementTick+0x74>
    1836:	8f ef       	ldi	r24, 0xFF	; 255
    1838:	9f ef       	ldi	r25, 0xFF	; 255
    183a:	90 93 0c 02 	sts	0x020C, r25	; 0x80020c <xNextTaskUnblockTime+0x1>
    183e:	80 93 0b 02 	sts	0x020B, r24	; 0x80020b <xNextTaskUnblockTime>
    1842:	10 c0       	rjmp	.+32     	; 0x1864 <vTaskIncrementTick+0x94>
    1844:	e0 91 6e 08 	lds	r30, 0x086E	; 0x80086e <pxDelayedTaskList>
    1848:	f0 91 6f 08 	lds	r31, 0x086F	; 0x80086f <pxDelayedTaskList+0x1>
    184c:	05 80       	ldd	r0, Z+5	; 0x05
    184e:	f6 81       	ldd	r31, Z+6	; 0x06
    1850:	e0 2d       	mov	r30, r0
    1852:	06 80       	ldd	r0, Z+6	; 0x06
    1854:	f7 81       	ldd	r31, Z+7	; 0x07
    1856:	e0 2d       	mov	r30, r0
    1858:	82 81       	ldd	r24, Z+2	; 0x02
    185a:	93 81       	ldd	r25, Z+3	; 0x03
    185c:	90 93 0c 02 	sts	0x020C, r25	; 0x80020c <xNextTaskUnblockTime+0x1>
    1860:	80 93 0b 02 	sts	0x020B, r24	; 0x80020b <xNextTaskUnblockTime>
    1864:	20 91 60 08 	lds	r18, 0x0860	; 0x800860 <xTickCount>
    1868:	30 91 61 08 	lds	r19, 0x0861	; 0x800861 <xTickCount+0x1>
    186c:	80 91 0b 02 	lds	r24, 0x020B	; 0x80020b <xNextTaskUnblockTime>
    1870:	90 91 0c 02 	lds	r25, 0x020C	; 0x80020c <xNextTaskUnblockTime+0x1>
    1874:	28 17       	cp	r18, r24
    1876:	39 07       	cpc	r19, r25
    1878:	08 f4       	brcc	.+2      	; 0x187c <vTaskIncrementTick+0xac>
    187a:	4c c0       	rjmp	.+152    	; 0x1914 <vTaskIncrementTick+0x144>
    187c:	e0 91 6e 08 	lds	r30, 0x086E	; 0x80086e <pxDelayedTaskList>
    1880:	f0 91 6f 08 	lds	r31, 0x086F	; 0x80086f <pxDelayedTaskList+0x1>
    1884:	80 81       	ld	r24, Z
    1886:	81 11       	cpse	r24, r1
    1888:	07 c0       	rjmp	.+14     	; 0x1898 <vTaskIncrementTick+0xc8>
    188a:	8f ef       	ldi	r24, 0xFF	; 255
    188c:	9f ef       	ldi	r25, 0xFF	; 255
    188e:	90 93 0c 02 	sts	0x020C, r25	; 0x80020c <xNextTaskUnblockTime+0x1>
    1892:	80 93 0b 02 	sts	0x020B, r24	; 0x80020b <xNextTaskUnblockTime>
    1896:	3e c0       	rjmp	.+124    	; 0x1914 <vTaskIncrementTick+0x144>
    1898:	e0 91 6e 08 	lds	r30, 0x086E	; 0x80086e <pxDelayedTaskList>
    189c:	f0 91 6f 08 	lds	r31, 0x086F	; 0x80086f <pxDelayedTaskList+0x1>
    18a0:	05 80       	ldd	r0, Z+5	; 0x05
    18a2:	f6 81       	ldd	r31, Z+6	; 0x06
    18a4:	e0 2d       	mov	r30, r0
    18a6:	c6 81       	ldd	r28, Z+6	; 0x06
    18a8:	d7 81       	ldd	r29, Z+7	; 0x07
    18aa:	8a 81       	ldd	r24, Y+2	; 0x02
    18ac:	9b 81       	ldd	r25, Y+3	; 0x03
    18ae:	20 91 60 08 	lds	r18, 0x0860	; 0x800860 <xTickCount>
    18b2:	30 91 61 08 	lds	r19, 0x0861	; 0x800861 <xTickCount+0x1>
    18b6:	28 17       	cp	r18, r24
    18b8:	39 07       	cpc	r19, r25
    18ba:	28 f4       	brcc	.+10     	; 0x18c6 <vTaskIncrementTick+0xf6>
    18bc:	90 93 0c 02 	sts	0x020C, r25	; 0x80020c <xNextTaskUnblockTime+0x1>
    18c0:	80 93 0b 02 	sts	0x020B, r24	; 0x80020b <xNextTaskUnblockTime>
    18c4:	27 c0       	rjmp	.+78     	; 0x1914 <vTaskIncrementTick+0x144>
    18c6:	8e 01       	movw	r16, r28
    18c8:	0e 5f       	subi	r16, 0xFE	; 254
    18ca:	1f 4f       	sbci	r17, 0xFF	; 255
    18cc:	c8 01       	movw	r24, r16
    18ce:	2d dc       	rcall	.-1958   	; 0x112a <vListRemove>
    18d0:	8c 89       	ldd	r24, Y+20	; 0x14
    18d2:	9d 89       	ldd	r25, Y+21	; 0x15
    18d4:	89 2b       	or	r24, r25
    18d6:	19 f0       	breq	.+6      	; 0x18de <vTaskIncrementTick+0x10e>
    18d8:	ce 01       	movw	r24, r28
    18da:	0c 96       	adiw	r24, 0x0c	; 12
    18dc:	26 dc       	rcall	.-1972   	; 0x112a <vListRemove>
    18de:	8e 89       	ldd	r24, Y+22	; 0x16
    18e0:	90 91 5e 08 	lds	r25, 0x085E	; 0x80085e <uxTopReadyPriority>
    18e4:	98 17       	cp	r25, r24
    18e6:	10 f4       	brcc	.+4      	; 0x18ec <vTaskIncrementTick+0x11c>
    18e8:	80 93 5e 08 	sts	0x085E, r24	; 0x80085e <uxTopReadyPriority>
    18ec:	90 e0       	ldi	r25, 0x00	; 0
    18ee:	9c 01       	movw	r18, r24
    18f0:	22 0f       	add	r18, r18
    18f2:	33 1f       	adc	r19, r19
    18f4:	22 0f       	add	r18, r18
    18f6:	33 1f       	adc	r19, r19
    18f8:	22 0f       	add	r18, r18
    18fa:	33 1f       	adc	r19, r19
    18fc:	82 0f       	add	r24, r18
    18fe:	93 1f       	adc	r25, r19
    1900:	b8 01       	movw	r22, r16
    1902:	8e 57       	subi	r24, 0x7E	; 126
    1904:	97 4f       	sbci	r25, 0xF7	; 247
    1906:	b9 db       	rcall	.-2190   	; 0x107a <vListInsertEnd>
    1908:	b9 cf       	rjmp	.-142    	; 0x187c <vTaskIncrementTick+0xac>
    190a:	80 91 5b 08 	lds	r24, 0x085B	; 0x80085b <uxMissedTicks>
    190e:	8f 5f       	subi	r24, 0xFF	; 255
    1910:	80 93 5b 08 	sts	0x085B, r24	; 0x80085b <uxMissedTicks>
    1914:	df 91       	pop	r29
    1916:	cf 91       	pop	r28
    1918:	1f 91       	pop	r17
    191a:	0f 91       	pop	r16
    191c:	08 95       	ret

0000191e <xTaskResumeAll>:
    191e:	ff 92       	push	r15
    1920:	0f 93       	push	r16
    1922:	1f 93       	push	r17
    1924:	cf 93       	push	r28
    1926:	df 93       	push	r29
    1928:	0f b6       	in	r0, 0x3f	; 63
    192a:	f8 94       	cli
    192c:	0f 92       	push	r0
    192e:	80 91 5c 08 	lds	r24, 0x085C	; 0x80085c <uxSchedulerSuspended>
    1932:	81 50       	subi	r24, 0x01	; 1
    1934:	80 93 5c 08 	sts	0x085C, r24	; 0x80085c <uxSchedulerSuspended>
    1938:	80 91 5c 08 	lds	r24, 0x085C	; 0x80085c <uxSchedulerSuspended>
    193c:	81 11       	cpse	r24, r1
    193e:	55 c0       	rjmp	.+170    	; 0x19ea <xTaskResumeAll+0xcc>
    1940:	80 91 62 08 	lds	r24, 0x0862	; 0x800862 <uxCurrentNumberOfTasks>
    1944:	81 11       	cpse	r24, r1
    1946:	2f c0       	rjmp	.+94     	; 0x19a6 <xTaskResumeAll+0x88>
    1948:	53 c0       	rjmp	.+166    	; 0x19f0 <xTaskResumeAll+0xd2>
    194a:	e0 91 68 08 	lds	r30, 0x0868	; 0x800868 <xPendingReadyList+0x5>
    194e:	f0 91 69 08 	lds	r31, 0x0869	; 0x800869 <xPendingReadyList+0x6>
    1952:	c6 81       	ldd	r28, Z+6	; 0x06
    1954:	d7 81       	ldd	r29, Z+7	; 0x07
    1956:	ce 01       	movw	r24, r28
    1958:	0c 96       	adiw	r24, 0x0c	; 12
    195a:	e7 db       	rcall	.-2098   	; 0x112a <vListRemove>
    195c:	8e 01       	movw	r16, r28
    195e:	0e 5f       	subi	r16, 0xFE	; 254
    1960:	1f 4f       	sbci	r17, 0xFF	; 255
    1962:	c8 01       	movw	r24, r16
    1964:	e2 db       	rcall	.-2108   	; 0x112a <vListRemove>
    1966:	8e 89       	ldd	r24, Y+22	; 0x16
    1968:	90 91 5e 08 	lds	r25, 0x085E	; 0x80085e <uxTopReadyPriority>
    196c:	98 17       	cp	r25, r24
    196e:	10 f4       	brcc	.+4      	; 0x1974 <xTaskResumeAll+0x56>
    1970:	80 93 5e 08 	sts	0x085E, r24	; 0x80085e <uxTopReadyPriority>
    1974:	90 e0       	ldi	r25, 0x00	; 0
    1976:	9c 01       	movw	r18, r24
    1978:	22 0f       	add	r18, r18
    197a:	33 1f       	adc	r19, r19
    197c:	22 0f       	add	r18, r18
    197e:	33 1f       	adc	r19, r19
    1980:	22 0f       	add	r18, r18
    1982:	33 1f       	adc	r19, r19
    1984:	82 0f       	add	r24, r18
    1986:	93 1f       	adc	r25, r19
    1988:	b8 01       	movw	r22, r16
    198a:	8e 57       	subi	r24, 0x7E	; 126
    198c:	97 4f       	sbci	r25, 0xF7	; 247
    198e:	75 db       	rcall	.-2326   	; 0x107a <vListInsertEnd>
    1990:	9e 89       	ldd	r25, Y+22	; 0x16
    1992:	e0 91 8b 08 	lds	r30, 0x088B	; 0x80088b <pxCurrentTCB>
    1996:	f0 91 8c 08 	lds	r31, 0x088C	; 0x80088c <pxCurrentTCB+0x1>
    199a:	86 89       	ldd	r24, Z+22	; 0x16
    199c:	98 17       	cp	r25, r24
    199e:	20 f0       	brcs	.+8      	; 0x19a8 <xTaskResumeAll+0x8a>
    19a0:	ff 24       	eor	r15, r15
    19a2:	f3 94       	inc	r15
    19a4:	01 c0       	rjmp	.+2      	; 0x19a8 <xTaskResumeAll+0x8a>
    19a6:	f1 2c       	mov	r15, r1
    19a8:	80 91 63 08 	lds	r24, 0x0863	; 0x800863 <xPendingReadyList>
    19ac:	81 11       	cpse	r24, r1
    19ae:	cd cf       	rjmp	.-102    	; 0x194a <xTaskResumeAll+0x2c>
    19b0:	80 91 5b 08 	lds	r24, 0x085B	; 0x80085b <uxMissedTicks>
    19b4:	81 11       	cpse	r24, r1
    19b6:	07 c0       	rjmp	.+14     	; 0x19c6 <xTaskResumeAll+0xa8>
    19b8:	0c c0       	rjmp	.+24     	; 0x19d2 <xTaskResumeAll+0xb4>
    19ba:	0a df       	rcall	.-492    	; 0x17d0 <vTaskIncrementTick>
    19bc:	80 91 5b 08 	lds	r24, 0x085B	; 0x80085b <uxMissedTicks>
    19c0:	81 50       	subi	r24, 0x01	; 1
    19c2:	80 93 5b 08 	sts	0x085B, r24	; 0x80085b <uxMissedTicks>
    19c6:	80 91 5b 08 	lds	r24, 0x085B	; 0x80085b <uxMissedTicks>
    19ca:	81 11       	cpse	r24, r1
    19cc:	f6 cf       	rjmp	.-20     	; 0x19ba <xTaskResumeAll+0x9c>
    19ce:	ff 24       	eor	r15, r15
    19d0:	f3 94       	inc	r15
    19d2:	81 e0       	ldi	r24, 0x01	; 1
    19d4:	f8 16       	cp	r15, r24
    19d6:	21 f0       	breq	.+8      	; 0x19e0 <xTaskResumeAll+0xc2>
    19d8:	80 91 5a 08 	lds	r24, 0x085A	; 0x80085a <xMissedYield>
    19dc:	81 30       	cpi	r24, 0x01	; 1
    19de:	39 f4       	brne	.+14     	; 0x19ee <xTaskResumeAll+0xd0>
    19e0:	10 92 5a 08 	sts	0x085A, r1	; 0x80085a <xMissedYield>
    19e4:	75 dc       	rcall	.-1814   	; 0x12d0 <vPortYield>
    19e6:	81 e0       	ldi	r24, 0x01	; 1
    19e8:	03 c0       	rjmp	.+6      	; 0x19f0 <xTaskResumeAll+0xd2>
    19ea:	80 e0       	ldi	r24, 0x00	; 0
    19ec:	01 c0       	rjmp	.+2      	; 0x19f0 <xTaskResumeAll+0xd2>
    19ee:	80 e0       	ldi	r24, 0x00	; 0
    19f0:	0f 90       	pop	r0
    19f2:	0f be       	out	0x3f, r0	; 63
    19f4:	df 91       	pop	r29
    19f6:	cf 91       	pop	r28
    19f8:	1f 91       	pop	r17
    19fa:	0f 91       	pop	r16
    19fc:	ff 90       	pop	r15
    19fe:	08 95       	ret

00001a00 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    1a00:	cf 93       	push	r28
    1a02:	df 93       	push	r29
    1a04:	ec 01       	movw	r28, r24
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    1a06:	89 2b       	or	r24, r25
    1a08:	89 f0       	breq	.+34     	; 0x1a2c <vTaskDelay+0x2c>
		{
			vTaskSuspendAll();
    1a0a:	dc de       	rcall	.-584    	; 0x17c4 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    1a0c:	80 91 60 08 	lds	r24, 0x0860	; 0x800860 <xTickCount>
    1a10:	90 91 61 08 	lds	r25, 0x0861	; 0x800861 <xTickCount+0x1>
    1a14:	c8 0f       	add	r28, r24
    1a16:	d9 1f       	adc	r29, r25

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1a18:	80 91 8b 08 	lds	r24, 0x088B	; 0x80088b <pxCurrentTCB>
    1a1c:	90 91 8c 08 	lds	r25, 0x088C	; 0x80088c <pxCurrentTCB+0x1>
    1a20:	02 96       	adiw	r24, 0x02	; 2
    1a22:	83 db       	rcall	.-2298   	; 0x112a <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    1a24:	ce 01       	movw	r24, r28
    1a26:	b8 dd       	rcall	.-1168   	; 0x1598 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    1a28:	7a df       	rcall	.-268    	; 0x191e <xTaskResumeAll>
    1a2a:	01 c0       	rjmp	.+2      	; 0x1a2e <vTaskDelay+0x2e>
#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    1a2c:	80 e0       	ldi	r24, 0x00	; 0
			xAlreadyYielded = xTaskResumeAll();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    1a2e:	81 11       	cpse	r24, r1
    1a30:	01 c0       	rjmp	.+2      	; 0x1a34 <vTaskDelay+0x34>
		{
			portYIELD_WITHIN_API();
    1a32:	4e dc       	rcall	.-1892   	; 0x12d0 <vPortYield>
    1a34:	df 91       	pop	r29
		}
	}
    1a36:	cf 91       	pop	r28
    1a38:	08 95       	ret

00001a3a <vTaskSwitchContext>:
    1a3a:	80 91 5c 08 	lds	r24, 0x085C	; 0x80085c <uxSchedulerSuspended>
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    1a3e:	88 23       	and	r24, r24
    1a40:	49 f0       	breq	.+18     	; 0x1a54 <vTaskSwitchContext+0x1a>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    1a42:	81 e0       	ldi	r24, 0x01	; 1
    1a44:	80 93 5a 08 	sts	0x085A, r24	; 0x80085a <xMissedYield>
    1a48:	08 95       	ret
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    1a4a:	80 91 5e 08 	lds	r24, 0x085E	; 0x80085e <uxTopReadyPriority>
    1a4e:	81 50       	subi	r24, 0x01	; 1
    1a50:	80 93 5e 08 	sts	0x085E, r24	; 0x80085e <uxTopReadyPriority>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    1a54:	80 91 5e 08 	lds	r24, 0x085E	; 0x80085e <uxTopReadyPriority>
    1a58:	90 e0       	ldi	r25, 0x00	; 0
    1a5a:	fc 01       	movw	r30, r24
    1a5c:	ee 0f       	add	r30, r30
    1a5e:	ff 1f       	adc	r31, r31
    1a60:	ee 0f       	add	r30, r30
    1a62:	ff 1f       	adc	r31, r31
    1a64:	ee 0f       	add	r30, r30
    1a66:	ff 1f       	adc	r31, r31
    1a68:	8e 0f       	add	r24, r30
    1a6a:	9f 1f       	adc	r25, r31
    1a6c:	fc 01       	movw	r30, r24
    1a6e:	ee 57       	subi	r30, 0x7E	; 126
    1a70:	f7 4f       	sbci	r31, 0xF7	; 247
    1a72:	80 81       	ld	r24, Z
    1a74:	88 23       	and	r24, r24
    1a76:	49 f3       	breq	.-46     	; 0x1a4a <vTaskSwitchContext+0x10>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    1a78:	80 91 5e 08 	lds	r24, 0x085E	; 0x80085e <uxTopReadyPriority>
    1a7c:	90 e0       	ldi	r25, 0x00	; 0
    1a7e:	9c 01       	movw	r18, r24
    1a80:	22 0f       	add	r18, r18
    1a82:	33 1f       	adc	r19, r19
    1a84:	22 0f       	add	r18, r18
    1a86:	33 1f       	adc	r19, r19
    1a88:	22 0f       	add	r18, r18
    1a8a:	33 1f       	adc	r19, r19
    1a8c:	28 0f       	add	r18, r24
    1a8e:	39 1f       	adc	r19, r25
    1a90:	d9 01       	movw	r26, r18
    1a92:	ae 57       	subi	r26, 0x7E	; 126
    1a94:	b7 4f       	sbci	r27, 0xF7	; 247
    1a96:	11 96       	adiw	r26, 0x01	; 1
    1a98:	ed 91       	ld	r30, X+
    1a9a:	fc 91       	ld	r31, X
    1a9c:	12 97       	sbiw	r26, 0x02	; 2
    1a9e:	02 80       	ldd	r0, Z+2	; 0x02
    1aa0:	f3 81       	ldd	r31, Z+3	; 0x03
    1aa2:	e0 2d       	mov	r30, r0
    1aa4:	12 96       	adiw	r26, 0x02	; 2
    1aa6:	fc 93       	st	X, r31
    1aa8:	ee 93       	st	-X, r30
    1aaa:	11 97       	sbiw	r26, 0x01	; 1
    1aac:	2b 57       	subi	r18, 0x7B	; 123
    1aae:	37 4f       	sbci	r19, 0xF7	; 247
    1ab0:	e2 17       	cp	r30, r18
    1ab2:	f3 07       	cpc	r31, r19
    1ab4:	29 f4       	brne	.+10     	; 0x1ac0 <vTaskSwitchContext+0x86>
    1ab6:	22 81       	ldd	r18, Z+2	; 0x02
    1ab8:	33 81       	ldd	r19, Z+3	; 0x03
    1aba:	fd 01       	movw	r30, r26
    1abc:	32 83       	std	Z+2, r19	; 0x02
    1abe:	21 83       	std	Z+1, r18	; 0x01
    1ac0:	fc 01       	movw	r30, r24
    1ac2:	ee 0f       	add	r30, r30
    1ac4:	ff 1f       	adc	r31, r31
    1ac6:	ee 0f       	add	r30, r30
    1ac8:	ff 1f       	adc	r31, r31
    1aca:	ee 0f       	add	r30, r30
    1acc:	ff 1f       	adc	r31, r31
    1ace:	8e 0f       	add	r24, r30
    1ad0:	9f 1f       	adc	r25, r31
    1ad2:	fc 01       	movw	r30, r24
    1ad4:	ee 57       	subi	r30, 0x7E	; 126
    1ad6:	f7 4f       	sbci	r31, 0xF7	; 247
    1ad8:	01 80       	ldd	r0, Z+1	; 0x01
    1ada:	f2 81       	ldd	r31, Z+2	; 0x02
    1adc:	e0 2d       	mov	r30, r0
    1ade:	86 81       	ldd	r24, Z+6	; 0x06
    1ae0:	97 81       	ldd	r25, Z+7	; 0x07
    1ae2:	90 93 8c 08 	sts	0x088C, r25	; 0x80088c <pxCurrentTCB+0x1>
    1ae6:	80 93 8b 08 	sts	0x088B, r24	; 0x80088b <pxCurrentTCB>
    1aea:	08 95       	ret

00001aec <__subsf3>:
    1aec:	50 58       	subi	r21, 0x80	; 128

00001aee <__addsf3>:
    1aee:	bb 27       	eor	r27, r27
    1af0:	aa 27       	eor	r26, r26
    1af2:	0e d0       	rcall	.+28     	; 0x1b10 <__addsf3x>
    1af4:	08 c1       	rjmp	.+528    	; 0x1d06 <__fp_round>
    1af6:	f9 d0       	rcall	.+498    	; 0x1cea <__fp_pscA>
    1af8:	30 f0       	brcs	.+12     	; 0x1b06 <__addsf3+0x18>
    1afa:	fe d0       	rcall	.+508    	; 0x1cf8 <__fp_pscB>
    1afc:	20 f0       	brcs	.+8      	; 0x1b06 <__addsf3+0x18>
    1afe:	31 f4       	brne	.+12     	; 0x1b0c <__addsf3+0x1e>
    1b00:	9f 3f       	cpi	r25, 0xFF	; 255
    1b02:	11 f4       	brne	.+4      	; 0x1b08 <__addsf3+0x1a>
    1b04:	1e f4       	brtc	.+6      	; 0x1b0c <__addsf3+0x1e>
    1b06:	ee c0       	rjmp	.+476    	; 0x1ce4 <__fp_nan>
    1b08:	0e f4       	brtc	.+2      	; 0x1b0c <__addsf3+0x1e>
    1b0a:	e0 95       	com	r30
    1b0c:	e7 fb       	bst	r30, 7
    1b0e:	e4 c0       	rjmp	.+456    	; 0x1cd8 <__fp_inf>

00001b10 <__addsf3x>:
    1b10:	e9 2f       	mov	r30, r25
    1b12:	0a d1       	rcall	.+532    	; 0x1d28 <__fp_split3>
    1b14:	80 f3       	brcs	.-32     	; 0x1af6 <__addsf3+0x8>
    1b16:	ba 17       	cp	r27, r26
    1b18:	62 07       	cpc	r22, r18
    1b1a:	73 07       	cpc	r23, r19
    1b1c:	84 07       	cpc	r24, r20
    1b1e:	95 07       	cpc	r25, r21
    1b20:	18 f0       	brcs	.+6      	; 0x1b28 <__addsf3x+0x18>
    1b22:	71 f4       	brne	.+28     	; 0x1b40 <__addsf3x+0x30>
    1b24:	9e f5       	brtc	.+102    	; 0x1b8c <__addsf3x+0x7c>
    1b26:	22 c1       	rjmp	.+580    	; 0x1d6c <__fp_zero>
    1b28:	0e f4       	brtc	.+2      	; 0x1b2c <__addsf3x+0x1c>
    1b2a:	e0 95       	com	r30
    1b2c:	0b 2e       	mov	r0, r27
    1b2e:	ba 2f       	mov	r27, r26
    1b30:	a0 2d       	mov	r26, r0
    1b32:	0b 01       	movw	r0, r22
    1b34:	b9 01       	movw	r22, r18
    1b36:	90 01       	movw	r18, r0
    1b38:	0c 01       	movw	r0, r24
    1b3a:	ca 01       	movw	r24, r20
    1b3c:	a0 01       	movw	r20, r0
    1b3e:	11 24       	eor	r1, r1
    1b40:	ff 27       	eor	r31, r31
    1b42:	59 1b       	sub	r21, r25
    1b44:	99 f0       	breq	.+38     	; 0x1b6c <__addsf3x+0x5c>
    1b46:	59 3f       	cpi	r21, 0xF9	; 249
    1b48:	50 f4       	brcc	.+20     	; 0x1b5e <__addsf3x+0x4e>
    1b4a:	50 3e       	cpi	r21, 0xE0	; 224
    1b4c:	68 f1       	brcs	.+90     	; 0x1ba8 <__addsf3x+0x98>
    1b4e:	1a 16       	cp	r1, r26
    1b50:	f0 40       	sbci	r31, 0x00	; 0
    1b52:	a2 2f       	mov	r26, r18
    1b54:	23 2f       	mov	r18, r19
    1b56:	34 2f       	mov	r19, r20
    1b58:	44 27       	eor	r20, r20
    1b5a:	58 5f       	subi	r21, 0xF8	; 248
    1b5c:	f3 cf       	rjmp	.-26     	; 0x1b44 <__addsf3x+0x34>
    1b5e:	46 95       	lsr	r20
    1b60:	37 95       	ror	r19
    1b62:	27 95       	ror	r18
    1b64:	a7 95       	ror	r26
    1b66:	f0 40       	sbci	r31, 0x00	; 0
    1b68:	53 95       	inc	r21
    1b6a:	c9 f7       	brne	.-14     	; 0x1b5e <__addsf3x+0x4e>
    1b6c:	7e f4       	brtc	.+30     	; 0x1b8c <__addsf3x+0x7c>
    1b6e:	1f 16       	cp	r1, r31
    1b70:	ba 0b       	sbc	r27, r26
    1b72:	62 0b       	sbc	r22, r18
    1b74:	73 0b       	sbc	r23, r19
    1b76:	84 0b       	sbc	r24, r20
    1b78:	ba f0       	brmi	.+46     	; 0x1ba8 <__addsf3x+0x98>
    1b7a:	91 50       	subi	r25, 0x01	; 1
    1b7c:	a1 f0       	breq	.+40     	; 0x1ba6 <__addsf3x+0x96>
    1b7e:	ff 0f       	add	r31, r31
    1b80:	bb 1f       	adc	r27, r27
    1b82:	66 1f       	adc	r22, r22
    1b84:	77 1f       	adc	r23, r23
    1b86:	88 1f       	adc	r24, r24
    1b88:	c2 f7       	brpl	.-16     	; 0x1b7a <__addsf3x+0x6a>
    1b8a:	0e c0       	rjmp	.+28     	; 0x1ba8 <__addsf3x+0x98>
    1b8c:	ba 0f       	add	r27, r26
    1b8e:	62 1f       	adc	r22, r18
    1b90:	73 1f       	adc	r23, r19
    1b92:	84 1f       	adc	r24, r20
    1b94:	48 f4       	brcc	.+18     	; 0x1ba8 <__addsf3x+0x98>
    1b96:	87 95       	ror	r24
    1b98:	77 95       	ror	r23
    1b9a:	67 95       	ror	r22
    1b9c:	b7 95       	ror	r27
    1b9e:	f7 95       	ror	r31
    1ba0:	9e 3f       	cpi	r25, 0xFE	; 254
    1ba2:	08 f0       	brcs	.+2      	; 0x1ba6 <__addsf3x+0x96>
    1ba4:	b3 cf       	rjmp	.-154    	; 0x1b0c <__addsf3+0x1e>
    1ba6:	93 95       	inc	r25
    1ba8:	88 0f       	add	r24, r24
    1baa:	08 f0       	brcs	.+2      	; 0x1bae <__addsf3x+0x9e>
    1bac:	99 27       	eor	r25, r25
    1bae:	ee 0f       	add	r30, r30
    1bb0:	97 95       	ror	r25
    1bb2:	87 95       	ror	r24
    1bb4:	08 95       	ret

00001bb6 <__cmpsf2>:
    1bb6:	6c d0       	rcall	.+216    	; 0x1c90 <__fp_cmp>
    1bb8:	08 f4       	brcc	.+2      	; 0x1bbc <__cmpsf2+0x6>
    1bba:	81 e0       	ldi	r24, 0x01	; 1
    1bbc:	08 95       	ret

00001bbe <__fixunssfsi>:
    1bbe:	bc d0       	rcall	.+376    	; 0x1d38 <__fp_splitA>
    1bc0:	88 f0       	brcs	.+34     	; 0x1be4 <__fixunssfsi+0x26>
    1bc2:	9f 57       	subi	r25, 0x7F	; 127
    1bc4:	90 f0       	brcs	.+36     	; 0x1bea <__fixunssfsi+0x2c>
    1bc6:	b9 2f       	mov	r27, r25
    1bc8:	99 27       	eor	r25, r25
    1bca:	b7 51       	subi	r27, 0x17	; 23
    1bcc:	a0 f0       	brcs	.+40     	; 0x1bf6 <__fixunssfsi+0x38>
    1bce:	d1 f0       	breq	.+52     	; 0x1c04 <__fixunssfsi+0x46>
    1bd0:	66 0f       	add	r22, r22
    1bd2:	77 1f       	adc	r23, r23
    1bd4:	88 1f       	adc	r24, r24
    1bd6:	99 1f       	adc	r25, r25
    1bd8:	1a f0       	brmi	.+6      	; 0x1be0 <__fixunssfsi+0x22>
    1bda:	ba 95       	dec	r27
    1bdc:	c9 f7       	brne	.-14     	; 0x1bd0 <__fixunssfsi+0x12>
    1bde:	12 c0       	rjmp	.+36     	; 0x1c04 <__fixunssfsi+0x46>
    1be0:	b1 30       	cpi	r27, 0x01	; 1
    1be2:	81 f0       	breq	.+32     	; 0x1c04 <__fixunssfsi+0x46>
    1be4:	c3 d0       	rcall	.+390    	; 0x1d6c <__fp_zero>
    1be6:	b1 e0       	ldi	r27, 0x01	; 1
    1be8:	08 95       	ret
    1bea:	c0 c0       	rjmp	.+384    	; 0x1d6c <__fp_zero>
    1bec:	67 2f       	mov	r22, r23
    1bee:	78 2f       	mov	r23, r24
    1bf0:	88 27       	eor	r24, r24
    1bf2:	b8 5f       	subi	r27, 0xF8	; 248
    1bf4:	39 f0       	breq	.+14     	; 0x1c04 <__fixunssfsi+0x46>
    1bf6:	b9 3f       	cpi	r27, 0xF9	; 249
    1bf8:	cc f3       	brlt	.-14     	; 0x1bec <__fixunssfsi+0x2e>
    1bfa:	86 95       	lsr	r24
    1bfc:	77 95       	ror	r23
    1bfe:	67 95       	ror	r22
    1c00:	b3 95       	inc	r27
    1c02:	d9 f7       	brne	.-10     	; 0x1bfa <__fixunssfsi+0x3c>
    1c04:	3e f4       	brtc	.+14     	; 0x1c14 <__fixunssfsi+0x56>
    1c06:	90 95       	com	r25
    1c08:	80 95       	com	r24
    1c0a:	70 95       	com	r23
    1c0c:	61 95       	neg	r22
    1c0e:	7f 4f       	sbci	r23, 0xFF	; 255
    1c10:	8f 4f       	sbci	r24, 0xFF	; 255
    1c12:	9f 4f       	sbci	r25, 0xFF	; 255
    1c14:	08 95       	ret

00001c16 <__floatunsisf>:
    1c16:	e8 94       	clt
    1c18:	09 c0       	rjmp	.+18     	; 0x1c2c <__floatsisf+0x12>

00001c1a <__floatsisf>:
    1c1a:	97 fb       	bst	r25, 7
    1c1c:	3e f4       	brtc	.+14     	; 0x1c2c <__floatsisf+0x12>
    1c1e:	90 95       	com	r25
    1c20:	80 95       	com	r24
    1c22:	70 95       	com	r23
    1c24:	61 95       	neg	r22
    1c26:	7f 4f       	sbci	r23, 0xFF	; 255
    1c28:	8f 4f       	sbci	r24, 0xFF	; 255
    1c2a:	9f 4f       	sbci	r25, 0xFF	; 255
    1c2c:	99 23       	and	r25, r25
    1c2e:	a9 f0       	breq	.+42     	; 0x1c5a <__floatsisf+0x40>
    1c30:	f9 2f       	mov	r31, r25
    1c32:	96 e9       	ldi	r25, 0x96	; 150
    1c34:	bb 27       	eor	r27, r27
    1c36:	93 95       	inc	r25
    1c38:	f6 95       	lsr	r31
    1c3a:	87 95       	ror	r24
    1c3c:	77 95       	ror	r23
    1c3e:	67 95       	ror	r22
    1c40:	b7 95       	ror	r27
    1c42:	f1 11       	cpse	r31, r1
    1c44:	f8 cf       	rjmp	.-16     	; 0x1c36 <__floatsisf+0x1c>
    1c46:	fa f4       	brpl	.+62     	; 0x1c86 <__floatsisf+0x6c>
    1c48:	bb 0f       	add	r27, r27
    1c4a:	11 f4       	brne	.+4      	; 0x1c50 <__floatsisf+0x36>
    1c4c:	60 ff       	sbrs	r22, 0
    1c4e:	1b c0       	rjmp	.+54     	; 0x1c86 <__floatsisf+0x6c>
    1c50:	6f 5f       	subi	r22, 0xFF	; 255
    1c52:	7f 4f       	sbci	r23, 0xFF	; 255
    1c54:	8f 4f       	sbci	r24, 0xFF	; 255
    1c56:	9f 4f       	sbci	r25, 0xFF	; 255
    1c58:	16 c0       	rjmp	.+44     	; 0x1c86 <__floatsisf+0x6c>
    1c5a:	88 23       	and	r24, r24
    1c5c:	11 f0       	breq	.+4      	; 0x1c62 <__floatsisf+0x48>
    1c5e:	96 e9       	ldi	r25, 0x96	; 150
    1c60:	11 c0       	rjmp	.+34     	; 0x1c84 <__floatsisf+0x6a>
    1c62:	77 23       	and	r23, r23
    1c64:	21 f0       	breq	.+8      	; 0x1c6e <__floatsisf+0x54>
    1c66:	9e e8       	ldi	r25, 0x8E	; 142
    1c68:	87 2f       	mov	r24, r23
    1c6a:	76 2f       	mov	r23, r22
    1c6c:	05 c0       	rjmp	.+10     	; 0x1c78 <__floatsisf+0x5e>
    1c6e:	66 23       	and	r22, r22
    1c70:	71 f0       	breq	.+28     	; 0x1c8e <__floatsisf+0x74>
    1c72:	96 e8       	ldi	r25, 0x86	; 134
    1c74:	86 2f       	mov	r24, r22
    1c76:	70 e0       	ldi	r23, 0x00	; 0
    1c78:	60 e0       	ldi	r22, 0x00	; 0
    1c7a:	2a f0       	brmi	.+10     	; 0x1c86 <__floatsisf+0x6c>
    1c7c:	9a 95       	dec	r25
    1c7e:	66 0f       	add	r22, r22
    1c80:	77 1f       	adc	r23, r23
    1c82:	88 1f       	adc	r24, r24
    1c84:	da f7       	brpl	.-10     	; 0x1c7c <__floatsisf+0x62>
    1c86:	88 0f       	add	r24, r24
    1c88:	96 95       	lsr	r25
    1c8a:	87 95       	ror	r24
    1c8c:	97 f9       	bld	r25, 7
    1c8e:	08 95       	ret

00001c90 <__fp_cmp>:
    1c90:	99 0f       	add	r25, r25
    1c92:	00 08       	sbc	r0, r0
    1c94:	55 0f       	add	r21, r21
    1c96:	aa 0b       	sbc	r26, r26
    1c98:	e0 e8       	ldi	r30, 0x80	; 128
    1c9a:	fe ef       	ldi	r31, 0xFE	; 254
    1c9c:	16 16       	cp	r1, r22
    1c9e:	17 06       	cpc	r1, r23
    1ca0:	e8 07       	cpc	r30, r24
    1ca2:	f9 07       	cpc	r31, r25
    1ca4:	c0 f0       	brcs	.+48     	; 0x1cd6 <__fp_cmp+0x46>
    1ca6:	12 16       	cp	r1, r18
    1ca8:	13 06       	cpc	r1, r19
    1caa:	e4 07       	cpc	r30, r20
    1cac:	f5 07       	cpc	r31, r21
    1cae:	98 f0       	brcs	.+38     	; 0x1cd6 <__fp_cmp+0x46>
    1cb0:	62 1b       	sub	r22, r18
    1cb2:	73 0b       	sbc	r23, r19
    1cb4:	84 0b       	sbc	r24, r20
    1cb6:	95 0b       	sbc	r25, r21
    1cb8:	39 f4       	brne	.+14     	; 0x1cc8 <__fp_cmp+0x38>
    1cba:	0a 26       	eor	r0, r26
    1cbc:	61 f0       	breq	.+24     	; 0x1cd6 <__fp_cmp+0x46>
    1cbe:	23 2b       	or	r18, r19
    1cc0:	24 2b       	or	r18, r20
    1cc2:	25 2b       	or	r18, r21
    1cc4:	21 f4       	brne	.+8      	; 0x1cce <__fp_cmp+0x3e>
    1cc6:	08 95       	ret
    1cc8:	0a 26       	eor	r0, r26
    1cca:	09 f4       	brne	.+2      	; 0x1cce <__fp_cmp+0x3e>
    1ccc:	a1 40       	sbci	r26, 0x01	; 1
    1cce:	a6 95       	lsr	r26
    1cd0:	8f ef       	ldi	r24, 0xFF	; 255
    1cd2:	81 1d       	adc	r24, r1
    1cd4:	81 1d       	adc	r24, r1
    1cd6:	08 95       	ret

00001cd8 <__fp_inf>:
    1cd8:	97 f9       	bld	r25, 7
    1cda:	9f 67       	ori	r25, 0x7F	; 127
    1cdc:	80 e8       	ldi	r24, 0x80	; 128
    1cde:	70 e0       	ldi	r23, 0x00	; 0
    1ce0:	60 e0       	ldi	r22, 0x00	; 0
    1ce2:	08 95       	ret

00001ce4 <__fp_nan>:
    1ce4:	9f ef       	ldi	r25, 0xFF	; 255
    1ce6:	80 ec       	ldi	r24, 0xC0	; 192
    1ce8:	08 95       	ret

00001cea <__fp_pscA>:
    1cea:	00 24       	eor	r0, r0
    1cec:	0a 94       	dec	r0
    1cee:	16 16       	cp	r1, r22
    1cf0:	17 06       	cpc	r1, r23
    1cf2:	18 06       	cpc	r1, r24
    1cf4:	09 06       	cpc	r0, r25
    1cf6:	08 95       	ret

00001cf8 <__fp_pscB>:
    1cf8:	00 24       	eor	r0, r0
    1cfa:	0a 94       	dec	r0
    1cfc:	12 16       	cp	r1, r18
    1cfe:	13 06       	cpc	r1, r19
    1d00:	14 06       	cpc	r1, r20
    1d02:	05 06       	cpc	r0, r21
    1d04:	08 95       	ret

00001d06 <__fp_round>:
    1d06:	09 2e       	mov	r0, r25
    1d08:	03 94       	inc	r0
    1d0a:	00 0c       	add	r0, r0
    1d0c:	11 f4       	brne	.+4      	; 0x1d12 <__fp_round+0xc>
    1d0e:	88 23       	and	r24, r24
    1d10:	52 f0       	brmi	.+20     	; 0x1d26 <__fp_round+0x20>
    1d12:	bb 0f       	add	r27, r27
    1d14:	40 f4       	brcc	.+16     	; 0x1d26 <__fp_round+0x20>
    1d16:	bf 2b       	or	r27, r31
    1d18:	11 f4       	brne	.+4      	; 0x1d1e <__fp_round+0x18>
    1d1a:	60 ff       	sbrs	r22, 0
    1d1c:	04 c0       	rjmp	.+8      	; 0x1d26 <__fp_round+0x20>
    1d1e:	6f 5f       	subi	r22, 0xFF	; 255
    1d20:	7f 4f       	sbci	r23, 0xFF	; 255
    1d22:	8f 4f       	sbci	r24, 0xFF	; 255
    1d24:	9f 4f       	sbci	r25, 0xFF	; 255
    1d26:	08 95       	ret

00001d28 <__fp_split3>:
    1d28:	57 fd       	sbrc	r21, 7
    1d2a:	90 58       	subi	r25, 0x80	; 128
    1d2c:	44 0f       	add	r20, r20
    1d2e:	55 1f       	adc	r21, r21
    1d30:	59 f0       	breq	.+22     	; 0x1d48 <__fp_splitA+0x10>
    1d32:	5f 3f       	cpi	r21, 0xFF	; 255
    1d34:	71 f0       	breq	.+28     	; 0x1d52 <__fp_splitA+0x1a>
    1d36:	47 95       	ror	r20

00001d38 <__fp_splitA>:
    1d38:	88 0f       	add	r24, r24
    1d3a:	97 fb       	bst	r25, 7
    1d3c:	99 1f       	adc	r25, r25
    1d3e:	61 f0       	breq	.+24     	; 0x1d58 <__fp_splitA+0x20>
    1d40:	9f 3f       	cpi	r25, 0xFF	; 255
    1d42:	79 f0       	breq	.+30     	; 0x1d62 <__fp_splitA+0x2a>
    1d44:	87 95       	ror	r24
    1d46:	08 95       	ret
    1d48:	12 16       	cp	r1, r18
    1d4a:	13 06       	cpc	r1, r19
    1d4c:	14 06       	cpc	r1, r20
    1d4e:	55 1f       	adc	r21, r21
    1d50:	f2 cf       	rjmp	.-28     	; 0x1d36 <__fp_split3+0xe>
    1d52:	46 95       	lsr	r20
    1d54:	f1 df       	rcall	.-30     	; 0x1d38 <__fp_splitA>
    1d56:	08 c0       	rjmp	.+16     	; 0x1d68 <__fp_splitA+0x30>
    1d58:	16 16       	cp	r1, r22
    1d5a:	17 06       	cpc	r1, r23
    1d5c:	18 06       	cpc	r1, r24
    1d5e:	99 1f       	adc	r25, r25
    1d60:	f1 cf       	rjmp	.-30     	; 0x1d44 <__fp_splitA+0xc>
    1d62:	86 95       	lsr	r24
    1d64:	71 05       	cpc	r23, r1
    1d66:	61 05       	cpc	r22, r1
    1d68:	08 94       	sec
    1d6a:	08 95       	ret

00001d6c <__fp_zero>:
    1d6c:	e8 94       	clt

00001d6e <__fp_szero>:
    1d6e:	bb 27       	eor	r27, r27
    1d70:	66 27       	eor	r22, r22
    1d72:	77 27       	eor	r23, r23
    1d74:	cb 01       	movw	r24, r22
    1d76:	97 f9       	bld	r25, 7
    1d78:	08 95       	ret

00001d7a <__gesf2>:
    1d7a:	8a df       	rcall	.-236    	; 0x1c90 <__fp_cmp>
    1d7c:	08 f4       	brcc	.+2      	; 0x1d80 <__gesf2+0x6>
    1d7e:	8f ef       	ldi	r24, 0xFF	; 255
    1d80:	08 95       	ret

00001d82 <__mulsf3>:
    1d82:	0b d0       	rcall	.+22     	; 0x1d9a <__mulsf3x>
    1d84:	c0 cf       	rjmp	.-128    	; 0x1d06 <__fp_round>
    1d86:	b1 df       	rcall	.-158    	; 0x1cea <__fp_pscA>
    1d88:	28 f0       	brcs	.+10     	; 0x1d94 <__mulsf3+0x12>
    1d8a:	b6 df       	rcall	.-148    	; 0x1cf8 <__fp_pscB>
    1d8c:	18 f0       	brcs	.+6      	; 0x1d94 <__mulsf3+0x12>
    1d8e:	95 23       	and	r25, r21
    1d90:	09 f0       	breq	.+2      	; 0x1d94 <__mulsf3+0x12>
    1d92:	a2 cf       	rjmp	.-188    	; 0x1cd8 <__fp_inf>
    1d94:	a7 cf       	rjmp	.-178    	; 0x1ce4 <__fp_nan>
    1d96:	11 24       	eor	r1, r1
    1d98:	ea cf       	rjmp	.-44     	; 0x1d6e <__fp_szero>

00001d9a <__mulsf3x>:
    1d9a:	c6 df       	rcall	.-116    	; 0x1d28 <__fp_split3>
    1d9c:	a0 f3       	brcs	.-24     	; 0x1d86 <__mulsf3+0x4>

00001d9e <__mulsf3_pse>:
    1d9e:	95 9f       	mul	r25, r21
    1da0:	d1 f3       	breq	.-12     	; 0x1d96 <__mulsf3+0x14>
    1da2:	95 0f       	add	r25, r21
    1da4:	50 e0       	ldi	r21, 0x00	; 0
    1da6:	55 1f       	adc	r21, r21
    1da8:	62 9f       	mul	r22, r18
    1daa:	f0 01       	movw	r30, r0
    1dac:	72 9f       	mul	r23, r18
    1dae:	bb 27       	eor	r27, r27
    1db0:	f0 0d       	add	r31, r0
    1db2:	b1 1d       	adc	r27, r1
    1db4:	63 9f       	mul	r22, r19
    1db6:	aa 27       	eor	r26, r26
    1db8:	f0 0d       	add	r31, r0
    1dba:	b1 1d       	adc	r27, r1
    1dbc:	aa 1f       	adc	r26, r26
    1dbe:	64 9f       	mul	r22, r20
    1dc0:	66 27       	eor	r22, r22
    1dc2:	b0 0d       	add	r27, r0
    1dc4:	a1 1d       	adc	r26, r1
    1dc6:	66 1f       	adc	r22, r22
    1dc8:	82 9f       	mul	r24, r18
    1dca:	22 27       	eor	r18, r18
    1dcc:	b0 0d       	add	r27, r0
    1dce:	a1 1d       	adc	r26, r1
    1dd0:	62 1f       	adc	r22, r18
    1dd2:	73 9f       	mul	r23, r19
    1dd4:	b0 0d       	add	r27, r0
    1dd6:	a1 1d       	adc	r26, r1
    1dd8:	62 1f       	adc	r22, r18
    1dda:	83 9f       	mul	r24, r19
    1ddc:	a0 0d       	add	r26, r0
    1dde:	61 1d       	adc	r22, r1
    1de0:	22 1f       	adc	r18, r18
    1de2:	74 9f       	mul	r23, r20
    1de4:	33 27       	eor	r19, r19
    1de6:	a0 0d       	add	r26, r0
    1de8:	61 1d       	adc	r22, r1
    1dea:	23 1f       	adc	r18, r19
    1dec:	84 9f       	mul	r24, r20
    1dee:	60 0d       	add	r22, r0
    1df0:	21 1d       	adc	r18, r1
    1df2:	82 2f       	mov	r24, r18
    1df4:	76 2f       	mov	r23, r22
    1df6:	6a 2f       	mov	r22, r26
    1df8:	11 24       	eor	r1, r1
    1dfa:	9f 57       	subi	r25, 0x7F	; 127
    1dfc:	50 40       	sbci	r21, 0x00	; 0
    1dfe:	8a f0       	brmi	.+34     	; 0x1e22 <__mulsf3_pse+0x84>
    1e00:	e1 f0       	breq	.+56     	; 0x1e3a <__mulsf3_pse+0x9c>
    1e02:	88 23       	and	r24, r24
    1e04:	4a f0       	brmi	.+18     	; 0x1e18 <__mulsf3_pse+0x7a>
    1e06:	ee 0f       	add	r30, r30
    1e08:	ff 1f       	adc	r31, r31
    1e0a:	bb 1f       	adc	r27, r27
    1e0c:	66 1f       	adc	r22, r22
    1e0e:	77 1f       	adc	r23, r23
    1e10:	88 1f       	adc	r24, r24
    1e12:	91 50       	subi	r25, 0x01	; 1
    1e14:	50 40       	sbci	r21, 0x00	; 0
    1e16:	a9 f7       	brne	.-22     	; 0x1e02 <__mulsf3_pse+0x64>
    1e18:	9e 3f       	cpi	r25, 0xFE	; 254
    1e1a:	51 05       	cpc	r21, r1
    1e1c:	70 f0       	brcs	.+28     	; 0x1e3a <__mulsf3_pse+0x9c>
    1e1e:	5c cf       	rjmp	.-328    	; 0x1cd8 <__fp_inf>
    1e20:	a6 cf       	rjmp	.-180    	; 0x1d6e <__fp_szero>
    1e22:	5f 3f       	cpi	r21, 0xFF	; 255
    1e24:	ec f3       	brlt	.-6      	; 0x1e20 <__mulsf3_pse+0x82>
    1e26:	98 3e       	cpi	r25, 0xE8	; 232
    1e28:	dc f3       	brlt	.-10     	; 0x1e20 <__mulsf3_pse+0x82>
    1e2a:	86 95       	lsr	r24
    1e2c:	77 95       	ror	r23
    1e2e:	67 95       	ror	r22
    1e30:	b7 95       	ror	r27
    1e32:	f7 95       	ror	r31
    1e34:	e7 95       	ror	r30
    1e36:	9f 5f       	subi	r25, 0xFF	; 255
    1e38:	c1 f7       	brne	.-16     	; 0x1e2a <__mulsf3_pse+0x8c>
    1e3a:	fe 2b       	or	r31, r30
    1e3c:	88 0f       	add	r24, r24
    1e3e:	91 1d       	adc	r25, r1
    1e40:	96 95       	lsr	r25
    1e42:	87 95       	ror	r24
    1e44:	97 f9       	bld	r25, 7
    1e46:	08 95       	ret

00001e48 <__umulhisi3>:
    1e48:	a2 9f       	mul	r26, r18
    1e4a:	b0 01       	movw	r22, r0
    1e4c:	b3 9f       	mul	r27, r19
    1e4e:	c0 01       	movw	r24, r0
    1e50:	a3 9f       	mul	r26, r19
    1e52:	70 0d       	add	r23, r0
    1e54:	81 1d       	adc	r24, r1
    1e56:	11 24       	eor	r1, r1
    1e58:	91 1d       	adc	r25, r1
    1e5a:	b2 9f       	mul	r27, r18
    1e5c:	70 0d       	add	r23, r0
    1e5e:	81 1d       	adc	r24, r1
    1e60:	11 24       	eor	r1, r1
    1e62:	91 1d       	adc	r25, r1
    1e64:	08 95       	ret

00001e66 <malloc>:
    1e66:	0f 93       	push	r16
    1e68:	1f 93       	push	r17
    1e6a:	cf 93       	push	r28
    1e6c:	df 93       	push	r29
    1e6e:	82 30       	cpi	r24, 0x02	; 2
    1e70:	91 05       	cpc	r25, r1
    1e72:	10 f4       	brcc	.+4      	; 0x1e78 <malloc+0x12>
    1e74:	82 e0       	ldi	r24, 0x02	; 2
    1e76:	90 e0       	ldi	r25, 0x00	; 0
    1e78:	e0 91 8f 08 	lds	r30, 0x088F	; 0x80088f <__flp>
    1e7c:	f0 91 90 08 	lds	r31, 0x0890	; 0x800890 <__flp+0x1>
    1e80:	20 e0       	ldi	r18, 0x00	; 0
    1e82:	30 e0       	ldi	r19, 0x00	; 0
    1e84:	a0 e0       	ldi	r26, 0x00	; 0
    1e86:	b0 e0       	ldi	r27, 0x00	; 0
    1e88:	30 97       	sbiw	r30, 0x00	; 0
    1e8a:	19 f1       	breq	.+70     	; 0x1ed2 <malloc+0x6c>
    1e8c:	40 81       	ld	r20, Z
    1e8e:	51 81       	ldd	r21, Z+1	; 0x01
    1e90:	02 81       	ldd	r16, Z+2	; 0x02
    1e92:	13 81       	ldd	r17, Z+3	; 0x03
    1e94:	48 17       	cp	r20, r24
    1e96:	59 07       	cpc	r21, r25
    1e98:	c8 f0       	brcs	.+50     	; 0x1ecc <malloc+0x66>
    1e9a:	84 17       	cp	r24, r20
    1e9c:	95 07       	cpc	r25, r21
    1e9e:	69 f4       	brne	.+26     	; 0x1eba <malloc+0x54>
    1ea0:	10 97       	sbiw	r26, 0x00	; 0
    1ea2:	31 f0       	breq	.+12     	; 0x1eb0 <malloc+0x4a>
    1ea4:	12 96       	adiw	r26, 0x02	; 2
    1ea6:	0c 93       	st	X, r16
    1ea8:	12 97       	sbiw	r26, 0x02	; 2
    1eaa:	13 96       	adiw	r26, 0x03	; 3
    1eac:	1c 93       	st	X, r17
    1eae:	27 c0       	rjmp	.+78     	; 0x1efe <malloc+0x98>
    1eb0:	00 93 8f 08 	sts	0x088F, r16	; 0x80088f <__flp>
    1eb4:	10 93 90 08 	sts	0x0890, r17	; 0x800890 <__flp+0x1>
    1eb8:	22 c0       	rjmp	.+68     	; 0x1efe <malloc+0x98>
    1eba:	21 15       	cp	r18, r1
    1ebc:	31 05       	cpc	r19, r1
    1ebe:	19 f0       	breq	.+6      	; 0x1ec6 <malloc+0x60>
    1ec0:	42 17       	cp	r20, r18
    1ec2:	53 07       	cpc	r21, r19
    1ec4:	18 f4       	brcc	.+6      	; 0x1ecc <malloc+0x66>
    1ec6:	9a 01       	movw	r18, r20
    1ec8:	bd 01       	movw	r22, r26
    1eca:	ef 01       	movw	r28, r30
    1ecc:	df 01       	movw	r26, r30
    1ece:	f8 01       	movw	r30, r16
    1ed0:	db cf       	rjmp	.-74     	; 0x1e88 <malloc+0x22>
    1ed2:	21 15       	cp	r18, r1
    1ed4:	31 05       	cpc	r19, r1
    1ed6:	f9 f0       	breq	.+62     	; 0x1f16 <malloc+0xb0>
    1ed8:	28 1b       	sub	r18, r24
    1eda:	39 0b       	sbc	r19, r25
    1edc:	24 30       	cpi	r18, 0x04	; 4
    1ede:	31 05       	cpc	r19, r1
    1ee0:	80 f4       	brcc	.+32     	; 0x1f02 <malloc+0x9c>
    1ee2:	8a 81       	ldd	r24, Y+2	; 0x02
    1ee4:	9b 81       	ldd	r25, Y+3	; 0x03
    1ee6:	61 15       	cp	r22, r1
    1ee8:	71 05       	cpc	r23, r1
    1eea:	21 f0       	breq	.+8      	; 0x1ef4 <malloc+0x8e>
    1eec:	fb 01       	movw	r30, r22
    1eee:	93 83       	std	Z+3, r25	; 0x03
    1ef0:	82 83       	std	Z+2, r24	; 0x02
    1ef2:	04 c0       	rjmp	.+8      	; 0x1efc <malloc+0x96>
    1ef4:	90 93 90 08 	sts	0x0890, r25	; 0x800890 <__flp+0x1>
    1ef8:	80 93 8f 08 	sts	0x088F, r24	; 0x80088f <__flp>
    1efc:	fe 01       	movw	r30, r28
    1efe:	32 96       	adiw	r30, 0x02	; 2
    1f00:	44 c0       	rjmp	.+136    	; 0x1f8a <malloc+0x124>
    1f02:	fe 01       	movw	r30, r28
    1f04:	e2 0f       	add	r30, r18
    1f06:	f3 1f       	adc	r31, r19
    1f08:	81 93       	st	Z+, r24
    1f0a:	91 93       	st	Z+, r25
    1f0c:	22 50       	subi	r18, 0x02	; 2
    1f0e:	31 09       	sbc	r19, r1
    1f10:	39 83       	std	Y+1, r19	; 0x01
    1f12:	28 83       	st	Y, r18
    1f14:	3a c0       	rjmp	.+116    	; 0x1f8a <malloc+0x124>
    1f16:	20 91 8d 08 	lds	r18, 0x088D	; 0x80088d <__brkval>
    1f1a:	30 91 8e 08 	lds	r19, 0x088E	; 0x80088e <__brkval+0x1>
    1f1e:	23 2b       	or	r18, r19
    1f20:	41 f4       	brne	.+16     	; 0x1f32 <malloc+0xcc>
    1f22:	20 91 02 02 	lds	r18, 0x0202	; 0x800202 <__malloc_heap_start>
    1f26:	30 91 03 02 	lds	r19, 0x0203	; 0x800203 <__malloc_heap_start+0x1>
    1f2a:	30 93 8e 08 	sts	0x088E, r19	; 0x80088e <__brkval+0x1>
    1f2e:	20 93 8d 08 	sts	0x088D, r18	; 0x80088d <__brkval>
    1f32:	20 91 00 02 	lds	r18, 0x0200	; 0x800200 <__data_start>
    1f36:	30 91 01 02 	lds	r19, 0x0201	; 0x800201 <__data_start+0x1>
    1f3a:	21 15       	cp	r18, r1
    1f3c:	31 05       	cpc	r19, r1
    1f3e:	41 f4       	brne	.+16     	; 0x1f50 <malloc+0xea>
    1f40:	2d b7       	in	r18, 0x3d	; 61
    1f42:	3e b7       	in	r19, 0x3e	; 62
    1f44:	40 91 04 02 	lds	r20, 0x0204	; 0x800204 <__malloc_margin>
    1f48:	50 91 05 02 	lds	r21, 0x0205	; 0x800205 <__malloc_margin+0x1>
    1f4c:	24 1b       	sub	r18, r20
    1f4e:	35 0b       	sbc	r19, r21
    1f50:	e0 91 8d 08 	lds	r30, 0x088D	; 0x80088d <__brkval>
    1f54:	f0 91 8e 08 	lds	r31, 0x088E	; 0x80088e <__brkval+0x1>
    1f58:	e2 17       	cp	r30, r18
    1f5a:	f3 07       	cpc	r31, r19
    1f5c:	a0 f4       	brcc	.+40     	; 0x1f86 <malloc+0x120>
    1f5e:	2e 1b       	sub	r18, r30
    1f60:	3f 0b       	sbc	r19, r31
    1f62:	28 17       	cp	r18, r24
    1f64:	39 07       	cpc	r19, r25
    1f66:	78 f0       	brcs	.+30     	; 0x1f86 <malloc+0x120>
    1f68:	ac 01       	movw	r20, r24
    1f6a:	4e 5f       	subi	r20, 0xFE	; 254
    1f6c:	5f 4f       	sbci	r21, 0xFF	; 255
    1f6e:	24 17       	cp	r18, r20
    1f70:	35 07       	cpc	r19, r21
    1f72:	48 f0       	brcs	.+18     	; 0x1f86 <malloc+0x120>
    1f74:	4e 0f       	add	r20, r30
    1f76:	5f 1f       	adc	r21, r31
    1f78:	50 93 8e 08 	sts	0x088E, r21	; 0x80088e <__brkval+0x1>
    1f7c:	40 93 8d 08 	sts	0x088D, r20	; 0x80088d <__brkval>
    1f80:	81 93       	st	Z+, r24
    1f82:	91 93       	st	Z+, r25
    1f84:	02 c0       	rjmp	.+4      	; 0x1f8a <malloc+0x124>
    1f86:	e0 e0       	ldi	r30, 0x00	; 0
    1f88:	f0 e0       	ldi	r31, 0x00	; 0
    1f8a:	cf 01       	movw	r24, r30
    1f8c:	df 91       	pop	r29
    1f8e:	cf 91       	pop	r28
    1f90:	1f 91       	pop	r17
    1f92:	0f 91       	pop	r16
    1f94:	08 95       	ret

00001f96 <free>:
    1f96:	cf 93       	push	r28
    1f98:	df 93       	push	r29
    1f9a:	00 97       	sbiw	r24, 0x00	; 0
    1f9c:	09 f4       	brne	.+2      	; 0x1fa0 <free+0xa>
    1f9e:	81 c0       	rjmp	.+258    	; 0x20a2 <free+0x10c>
    1fa0:	fc 01       	movw	r30, r24
    1fa2:	32 97       	sbiw	r30, 0x02	; 2
    1fa4:	13 82       	std	Z+3, r1	; 0x03
    1fa6:	12 82       	std	Z+2, r1	; 0x02
    1fa8:	a0 91 8f 08 	lds	r26, 0x088F	; 0x80088f <__flp>
    1fac:	b0 91 90 08 	lds	r27, 0x0890	; 0x800890 <__flp+0x1>
    1fb0:	10 97       	sbiw	r26, 0x00	; 0
    1fb2:	81 f4       	brne	.+32     	; 0x1fd4 <free+0x3e>
    1fb4:	20 81       	ld	r18, Z
    1fb6:	31 81       	ldd	r19, Z+1	; 0x01
    1fb8:	82 0f       	add	r24, r18
    1fba:	93 1f       	adc	r25, r19
    1fbc:	20 91 8d 08 	lds	r18, 0x088D	; 0x80088d <__brkval>
    1fc0:	30 91 8e 08 	lds	r19, 0x088E	; 0x80088e <__brkval+0x1>
    1fc4:	28 17       	cp	r18, r24
    1fc6:	39 07       	cpc	r19, r25
    1fc8:	51 f5       	brne	.+84     	; 0x201e <free+0x88>
    1fca:	f0 93 8e 08 	sts	0x088E, r31	; 0x80088e <__brkval+0x1>
    1fce:	e0 93 8d 08 	sts	0x088D, r30	; 0x80088d <__brkval>
    1fd2:	67 c0       	rjmp	.+206    	; 0x20a2 <free+0x10c>
    1fd4:	ed 01       	movw	r28, r26
    1fd6:	20 e0       	ldi	r18, 0x00	; 0
    1fd8:	30 e0       	ldi	r19, 0x00	; 0
    1fda:	ce 17       	cp	r28, r30
    1fdc:	df 07       	cpc	r29, r31
    1fde:	40 f4       	brcc	.+16     	; 0x1ff0 <free+0x5a>
    1fe0:	4a 81       	ldd	r20, Y+2	; 0x02
    1fe2:	5b 81       	ldd	r21, Y+3	; 0x03
    1fe4:	9e 01       	movw	r18, r28
    1fe6:	41 15       	cp	r20, r1
    1fe8:	51 05       	cpc	r21, r1
    1fea:	f1 f0       	breq	.+60     	; 0x2028 <free+0x92>
    1fec:	ea 01       	movw	r28, r20
    1fee:	f5 cf       	rjmp	.-22     	; 0x1fda <free+0x44>
    1ff0:	d3 83       	std	Z+3, r29	; 0x03
    1ff2:	c2 83       	std	Z+2, r28	; 0x02
    1ff4:	40 81       	ld	r20, Z
    1ff6:	51 81       	ldd	r21, Z+1	; 0x01
    1ff8:	84 0f       	add	r24, r20
    1ffa:	95 1f       	adc	r25, r21
    1ffc:	c8 17       	cp	r28, r24
    1ffe:	d9 07       	cpc	r29, r25
    2000:	59 f4       	brne	.+22     	; 0x2018 <free+0x82>
    2002:	88 81       	ld	r24, Y
    2004:	99 81       	ldd	r25, Y+1	; 0x01
    2006:	84 0f       	add	r24, r20
    2008:	95 1f       	adc	r25, r21
    200a:	02 96       	adiw	r24, 0x02	; 2
    200c:	91 83       	std	Z+1, r25	; 0x01
    200e:	80 83       	st	Z, r24
    2010:	8a 81       	ldd	r24, Y+2	; 0x02
    2012:	9b 81       	ldd	r25, Y+3	; 0x03
    2014:	93 83       	std	Z+3, r25	; 0x03
    2016:	82 83       	std	Z+2, r24	; 0x02
    2018:	21 15       	cp	r18, r1
    201a:	31 05       	cpc	r19, r1
    201c:	29 f4       	brne	.+10     	; 0x2028 <free+0x92>
    201e:	f0 93 90 08 	sts	0x0890, r31	; 0x800890 <__flp+0x1>
    2022:	e0 93 8f 08 	sts	0x088F, r30	; 0x80088f <__flp>
    2026:	3d c0       	rjmp	.+122    	; 0x20a2 <free+0x10c>
    2028:	e9 01       	movw	r28, r18
    202a:	fb 83       	std	Y+3, r31	; 0x03
    202c:	ea 83       	std	Y+2, r30	; 0x02
    202e:	49 91       	ld	r20, Y+
    2030:	59 91       	ld	r21, Y+
    2032:	c4 0f       	add	r28, r20
    2034:	d5 1f       	adc	r29, r21
    2036:	ec 17       	cp	r30, r28
    2038:	fd 07       	cpc	r31, r29
    203a:	61 f4       	brne	.+24     	; 0x2054 <free+0xbe>
    203c:	80 81       	ld	r24, Z
    203e:	91 81       	ldd	r25, Z+1	; 0x01
    2040:	84 0f       	add	r24, r20
    2042:	95 1f       	adc	r25, r21
    2044:	02 96       	adiw	r24, 0x02	; 2
    2046:	e9 01       	movw	r28, r18
    2048:	99 83       	std	Y+1, r25	; 0x01
    204a:	88 83       	st	Y, r24
    204c:	82 81       	ldd	r24, Z+2	; 0x02
    204e:	93 81       	ldd	r25, Z+3	; 0x03
    2050:	9b 83       	std	Y+3, r25	; 0x03
    2052:	8a 83       	std	Y+2, r24	; 0x02
    2054:	e0 e0       	ldi	r30, 0x00	; 0
    2056:	f0 e0       	ldi	r31, 0x00	; 0
    2058:	12 96       	adiw	r26, 0x02	; 2
    205a:	8d 91       	ld	r24, X+
    205c:	9c 91       	ld	r25, X
    205e:	13 97       	sbiw	r26, 0x03	; 3
    2060:	00 97       	sbiw	r24, 0x00	; 0
    2062:	19 f0       	breq	.+6      	; 0x206a <free+0xd4>
    2064:	fd 01       	movw	r30, r26
    2066:	dc 01       	movw	r26, r24
    2068:	f7 cf       	rjmp	.-18     	; 0x2058 <free+0xc2>
    206a:	8d 91       	ld	r24, X+
    206c:	9c 91       	ld	r25, X
    206e:	11 97       	sbiw	r26, 0x01	; 1
    2070:	9d 01       	movw	r18, r26
    2072:	2e 5f       	subi	r18, 0xFE	; 254
    2074:	3f 4f       	sbci	r19, 0xFF	; 255
    2076:	82 0f       	add	r24, r18
    2078:	93 1f       	adc	r25, r19
    207a:	20 91 8d 08 	lds	r18, 0x088D	; 0x80088d <__brkval>
    207e:	30 91 8e 08 	lds	r19, 0x088E	; 0x80088e <__brkval+0x1>
    2082:	28 17       	cp	r18, r24
    2084:	39 07       	cpc	r19, r25
    2086:	69 f4       	brne	.+26     	; 0x20a2 <free+0x10c>
    2088:	30 97       	sbiw	r30, 0x00	; 0
    208a:	29 f4       	brne	.+10     	; 0x2096 <free+0x100>
    208c:	10 92 90 08 	sts	0x0890, r1	; 0x800890 <__flp+0x1>
    2090:	10 92 8f 08 	sts	0x088F, r1	; 0x80088f <__flp>
    2094:	02 c0       	rjmp	.+4      	; 0x209a <free+0x104>
    2096:	13 82       	std	Z+3, r1	; 0x03
    2098:	12 82       	std	Z+2, r1	; 0x02
    209a:	b0 93 8e 08 	sts	0x088E, r27	; 0x80088e <__brkval+0x1>
    209e:	a0 93 8d 08 	sts	0x088D, r26	; 0x80088d <__brkval>
    20a2:	df 91       	pop	r29
    20a4:	cf 91       	pop	r28
    20a6:	08 95       	ret

000020a8 <memset>:
    20a8:	dc 01       	movw	r26, r24
    20aa:	01 c0       	rjmp	.+2      	; 0x20ae <memset+0x6>
    20ac:	6d 93       	st	X+, r22
    20ae:	41 50       	subi	r20, 0x01	; 1
    20b0:	50 40       	sbci	r21, 0x00	; 0
    20b2:	e0 f7       	brcc	.-8      	; 0x20ac <memset+0x4>
    20b4:	08 95       	ret

000020b6 <strncpy>:
    20b6:	fb 01       	movw	r30, r22
    20b8:	dc 01       	movw	r26, r24
    20ba:	41 50       	subi	r20, 0x01	; 1
    20bc:	50 40       	sbci	r21, 0x00	; 0
    20be:	48 f0       	brcs	.+18     	; 0x20d2 <strncpy+0x1c>
    20c0:	01 90       	ld	r0, Z+
    20c2:	0d 92       	st	X+, r0
    20c4:	00 20       	and	r0, r0
    20c6:	c9 f7       	brne	.-14     	; 0x20ba <strncpy+0x4>
    20c8:	01 c0       	rjmp	.+2      	; 0x20cc <strncpy+0x16>
    20ca:	1d 92       	st	X+, r1
    20cc:	41 50       	subi	r20, 0x01	; 1
    20ce:	50 40       	sbci	r21, 0x00	; 0
    20d0:	e0 f7       	brcc	.-8      	; 0x20ca <strncpy+0x14>
    20d2:	08 95       	ret

000020d4 <_exit>:
    20d4:	f8 94       	cli

000020d6 <__stop_program>:
    20d6:	ff cf       	rjmp	.-2      	; 0x20d6 <__stop_program>
