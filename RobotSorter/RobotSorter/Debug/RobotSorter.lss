
RobotSorter.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000074  00800200  00002490  00002524  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002490  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000069e  00800274  00800274  00002598  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00002598  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  000025c8  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000658  00000000  00000000  00002608  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00008986  00000000  00000000  00002c60  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000340a  00000000  00000000  0000b5e6  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000039f1  00000000  00000000  0000e9f0  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001280  00000000  00000000  000123e4  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000225a  00000000  00000000  00013664  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00004494  00000000  00000000  000158be  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000548  00000000  00000000  00019d52  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	73 c0       	rjmp	.+230    	; 0xe8 <__dtors_end>
       2:	00 00       	nop
       4:	a1 c0       	rjmp	.+322    	; 0x148 <__bad_interrupt>
       6:	00 00       	nop
       8:	9f c0       	rjmp	.+318    	; 0x148 <__bad_interrupt>
       a:	00 00       	nop
       c:	9d c0       	rjmp	.+314    	; 0x148 <__bad_interrupt>
       e:	00 00       	nop
      10:	9b c0       	rjmp	.+310    	; 0x148 <__bad_interrupt>
      12:	00 00       	nop
      14:	0c 94 2f 0f 	jmp	0x1e5e	; 0x1e5e <__vector_5>
      18:	97 c0       	rjmp	.+302    	; 0x148 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	95 c0       	rjmp	.+298    	; 0x148 <__bad_interrupt>
      1e:	00 00       	nop
      20:	93 c0       	rjmp	.+294    	; 0x148 <__bad_interrupt>
      22:	00 00       	nop
      24:	91 c0       	rjmp	.+290    	; 0x148 <__bad_interrupt>
      26:	00 00       	nop
      28:	8f c0       	rjmp	.+286    	; 0x148 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	8d c0       	rjmp	.+282    	; 0x148 <__bad_interrupt>
      2e:	00 00       	nop
      30:	8b c0       	rjmp	.+278    	; 0x148 <__bad_interrupt>
      32:	00 00       	nop
      34:	89 c0       	rjmp	.+274    	; 0x148 <__bad_interrupt>
      36:	00 00       	nop
      38:	87 c0       	rjmp	.+270    	; 0x148 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	85 c0       	rjmp	.+266    	; 0x148 <__bad_interrupt>
      3e:	00 00       	nop
      40:	83 c0       	rjmp	.+262    	; 0x148 <__bad_interrupt>
      42:	00 00       	nop
      44:	81 c0       	rjmp	.+258    	; 0x148 <__bad_interrupt>
      46:	00 00       	nop
      48:	7f c0       	rjmp	.+254    	; 0x148 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	7d c0       	rjmp	.+250    	; 0x148 <__bad_interrupt>
      4e:	00 00       	nop
      50:	7b c0       	rjmp	.+246    	; 0x148 <__bad_interrupt>
      52:	00 00       	nop
      54:	0c 94 5c 0a 	jmp	0x14b8	; 0x14b8 <__vector_21>
      58:	77 c0       	rjmp	.+238    	; 0x148 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	75 c0       	rjmp	.+234    	; 0x148 <__bad_interrupt>
      5e:	00 00       	nop
      60:	73 c0       	rjmp	.+230    	; 0x148 <__bad_interrupt>
      62:	00 00       	nop
      64:	71 c0       	rjmp	.+226    	; 0x148 <__bad_interrupt>
      66:	00 00       	nop
      68:	6f c0       	rjmp	.+222    	; 0x148 <__bad_interrupt>
      6a:	00 00       	nop
      6c:	6d c0       	rjmp	.+218    	; 0x148 <__bad_interrupt>
      6e:	00 00       	nop
      70:	6b c0       	rjmp	.+214    	; 0x148 <__bad_interrupt>
      72:	00 00       	nop
      74:	69 c0       	rjmp	.+210    	; 0x148 <__bad_interrupt>
      76:	00 00       	nop
      78:	67 c0       	rjmp	.+206    	; 0x148 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	65 c0       	rjmp	.+202    	; 0x148 <__bad_interrupt>
      7e:	00 00       	nop
      80:	63 c0       	rjmp	.+198    	; 0x148 <__bad_interrupt>
      82:	00 00       	nop
      84:	61 c0       	rjmp	.+194    	; 0x148 <__bad_interrupt>
      86:	00 00       	nop
      88:	5f c0       	rjmp	.+190    	; 0x148 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	5d c0       	rjmp	.+186    	; 0x148 <__bad_interrupt>
      8e:	00 00       	nop
      90:	5b c0       	rjmp	.+182    	; 0x148 <__bad_interrupt>
      92:	00 00       	nop
      94:	59 c0       	rjmp	.+178    	; 0x148 <__bad_interrupt>
      96:	00 00       	nop
      98:	57 c0       	rjmp	.+174    	; 0x148 <__bad_interrupt>
      9a:	00 00       	nop
      9c:	55 c0       	rjmp	.+170    	; 0x148 <__bad_interrupt>
      9e:	00 00       	nop
      a0:	53 c0       	rjmp	.+166    	; 0x148 <__bad_interrupt>
      a2:	00 00       	nop
      a4:	3a c1       	rjmp	.+628    	; 0x31a <__vector_41>
      a6:	00 00       	nop
      a8:	4f c0       	rjmp	.+158    	; 0x148 <__bad_interrupt>
      aa:	00 00       	nop
      ac:	4d c0       	rjmp	.+154    	; 0x148 <__bad_interrupt>
      ae:	00 00       	nop
      b0:	4b c0       	rjmp	.+150    	; 0x148 <__bad_interrupt>
      b2:	00 00       	nop
      b4:	0d c1       	rjmp	.+538    	; 0x2d0 <__vector_45>
      b6:	00 00       	nop
      b8:	47 c0       	rjmp	.+142    	; 0x148 <__bad_interrupt>
      ba:	00 00       	nop
      bc:	45 c0       	rjmp	.+138    	; 0x148 <__bad_interrupt>
      be:	00 00       	nop
      c0:	43 c0       	rjmp	.+134    	; 0x148 <__bad_interrupt>
      c2:	00 00       	nop
      c4:	41 c0       	rjmp	.+130    	; 0x148 <__bad_interrupt>
      c6:	00 00       	nop
      c8:	3f c0       	rjmp	.+126    	; 0x148 <__bad_interrupt>
      ca:	00 00       	nop
      cc:	3d c0       	rjmp	.+122    	; 0x148 <__bad_interrupt>
      ce:	00 00       	nop
      d0:	3b c0       	rjmp	.+118    	; 0x148 <__bad_interrupt>
      d2:	00 00       	nop
      d4:	39 c0       	rjmp	.+114    	; 0x148 <__bad_interrupt>
      d6:	00 00       	nop
      d8:	37 c0       	rjmp	.+110    	; 0x148 <__bad_interrupt>
      da:	00 00       	nop
      dc:	35 c0       	rjmp	.+106    	; 0x148 <__bad_interrupt>
      de:	00 00       	nop
      e0:	33 c0       	rjmp	.+102    	; 0x148 <__bad_interrupt>
	...

000000e4 <__ctors_start>:
      e4:	9c 02       	muls	r25, r28

000000e6 <__ctors_end>:
      e6:	a2 02       	muls	r26, r18

000000e8 <__dtors_end>:
      e8:	11 24       	eor	r1, r1
      ea:	1f be       	out	0x3f, r1	; 63
      ec:	cf ef       	ldi	r28, 0xFF	; 255
      ee:	d1 e2       	ldi	r29, 0x21	; 33
      f0:	de bf       	out	0x3e, r29	; 62
      f2:	cd bf       	out	0x3d, r28	; 61
      f4:	00 e0       	ldi	r16, 0x00	; 0
      f6:	0c bf       	out	0x3c, r16	; 60

000000f8 <__do_copy_data>:
      f8:	12 e0       	ldi	r17, 0x02	; 2
      fa:	a0 e0       	ldi	r26, 0x00	; 0
      fc:	b2 e0       	ldi	r27, 0x02	; 2
      fe:	e0 e9       	ldi	r30, 0x90	; 144
     100:	f4 e2       	ldi	r31, 0x24	; 36
     102:	00 e0       	ldi	r16, 0x00	; 0
     104:	0b bf       	out	0x3b, r16	; 59
     106:	02 c0       	rjmp	.+4      	; 0x10c <__do_copy_data+0x14>
     108:	07 90       	elpm	r0, Z+
     10a:	0d 92       	st	X+, r0
     10c:	a4 37       	cpi	r26, 0x74	; 116
     10e:	b1 07       	cpc	r27, r17
     110:	d9 f7       	brne	.-10     	; 0x108 <__do_copy_data+0x10>

00000112 <__do_clear_bss>:
     112:	29 e0       	ldi	r18, 0x09	; 9
     114:	a4 e7       	ldi	r26, 0x74	; 116
     116:	b2 e0       	ldi	r27, 0x02	; 2
     118:	01 c0       	rjmp	.+2      	; 0x11c <.do_clear_bss_start>

0000011a <.do_clear_bss_loop>:
     11a:	1d 92       	st	X+, r1

0000011c <.do_clear_bss_start>:
     11c:	a2 31       	cpi	r26, 0x12	; 18
     11e:	b2 07       	cpc	r27, r18
     120:	e1 f7       	brne	.-8      	; 0x11a <.do_clear_bss_loop>

00000122 <__do_global_ctors>:
     122:	10 e0       	ldi	r17, 0x00	; 0
     124:	c3 e7       	ldi	r28, 0x73	; 115
     126:	d0 e0       	ldi	r29, 0x00	; 0
     128:	00 e0       	ldi	r16, 0x00	; 0
     12a:	06 c0       	rjmp	.+12     	; 0x138 <__do_global_ctors+0x16>
     12c:	21 97       	sbiw	r28, 0x01	; 1
     12e:	01 09       	sbc	r16, r1
     130:	80 2f       	mov	r24, r16
     132:	fe 01       	movw	r30, r28
     134:	0e 94 e9 10 	call	0x21d2	; 0x21d2 <__tablejump2__>
     138:	c2 37       	cpi	r28, 0x72	; 114
     13a:	d1 07       	cpc	r29, r17
     13c:	80 e0       	ldi	r24, 0x00	; 0
     13e:	08 07       	cpc	r16, r24
     140:	a9 f7       	brne	.-22     	; 0x12c <__do_global_ctors+0xa>
     142:	e6 d1       	rcall	.+972    	; 0x510 <main>
     144:	0c 94 37 12 	jmp	0x246e	; 0x246e <__do_global_dtors>

00000148 <__bad_interrupt>:
     148:	5b cf       	rjmp	.-330    	; 0x0 <__vectors>

0000014a <_ZN5ColorC1Ev>:

#include "Color.h"
#include <string.h>

// default constructor
Color::Color()
     14a:	08 95       	ret

0000014c <_ZN5ColorD1Ev>:
{
}

// default destructor
Color::~Color()
     14c:	08 95       	ret

0000014e <_ZN11ColorSensorD1Ev>:
	}
	else
	{
		/* Cant add more colors. Increase size of array. */
	}
}
     14e:	0f 93       	push	r16
     150:	1f 93       	push	r17
     152:	cf 93       	push	r28
     154:	df 93       	push	r29
     156:	8c 01       	movw	r16, r24
     158:	0f 5f       	subi	r16, 0xFF	; 255
     15a:	1f 4f       	sbci	r17, 0xFF	; 255
     15c:	51 f0       	breq	.+20     	; 0x172 <_ZN11ColorSensorD1Ev+0x24>
     15e:	ec 01       	movw	r28, r24
     160:	c5 5a       	subi	r28, 0xA5	; 165
     162:	df 4f       	sbci	r29, 0xFF	; 255
     164:	c0 17       	cp	r28, r16
     166:	d1 07       	cpc	r29, r17
     168:	21 f0       	breq	.+8      	; 0x172 <_ZN11ColorSensorD1Ev+0x24>
     16a:	29 97       	sbiw	r28, 0x09	; 9
     16c:	ce 01       	movw	r24, r28
     16e:	ee df       	rcall	.-36     	; 0x14c <_ZN5ColorD1Ev>
     170:	f9 cf       	rjmp	.-14     	; 0x164 <_ZN11ColorSensorD1Ev+0x16>
     172:	df 91       	pop	r29
     174:	cf 91       	pop	r28
     176:	1f 91       	pop	r17
     178:	0f 91       	pop	r16
     17a:	08 95       	ret

0000017c <_ZN11ColorSensor9setFilterE6Filter>:
     17c:	61 30       	cpi	r22, 0x01	; 1
     17e:	31 f0       	breq	.+12     	; 0x18c <_ZN11ColorSensor9setFilterE6Filter+0x10>
     180:	00 f1       	brcs	.+64     	; 0x1c2 <_ZN11ColorSensor9setFilterE6Filter+0x46>
     182:	62 30       	cpi	r22, 0x02	; 2
     184:	a9 f0       	breq	.+42     	; 0x1b0 <_ZN11ColorSensor9setFilterE6Filter+0x34>
     186:	63 30       	cpi	r22, 0x03	; 3
     188:	51 f0       	breq	.+20     	; 0x19e <_ZN11ColorSensor9setFilterE6Filter+0x22>
     18a:	08 95       	ret
     18c:	e8 e0       	ldi	r30, 0x08	; 8
     18e:	f1 e0       	ldi	r31, 0x01	; 1
     190:	80 81       	ld	r24, Z
     192:	8a 7f       	andi	r24, 0xFA	; 250
     194:	80 83       	st	Z, r24
     196:	80 81       	ld	r24, Z
     198:	8b 7f       	andi	r24, 0xFB	; 251
     19a:	80 83       	st	Z, r24
     19c:	08 95       	ret
     19e:	e8 e0       	ldi	r30, 0x08	; 8
     1a0:	f1 e0       	ldi	r31, 0x01	; 1
     1a2:	80 81       	ld	r24, Z
     1a4:	8a 7f       	andi	r24, 0xFA	; 250
     1a6:	80 83       	st	Z, r24
     1a8:	80 81       	ld	r24, Z
     1aa:	84 60       	ori	r24, 0x04	; 4
     1ac:	80 83       	st	Z, r24
     1ae:	08 95       	ret
     1b0:	e8 e0       	ldi	r30, 0x08	; 8
     1b2:	f1 e0       	ldi	r31, 0x01	; 1
     1b4:	80 81       	ld	r24, Z
     1b6:	85 60       	ori	r24, 0x05	; 5
     1b8:	80 83       	st	Z, r24
     1ba:	80 81       	ld	r24, Z
     1bc:	84 60       	ori	r24, 0x04	; 4
     1be:	80 83       	st	Z, r24
     1c0:	08 95       	ret
     1c2:	e8 e0       	ldi	r30, 0x08	; 8
     1c4:	f1 e0       	ldi	r31, 0x01	; 1
     1c6:	80 81       	ld	r24, Z
     1c8:	85 60       	ori	r24, 0x05	; 5
     1ca:	80 83       	st	Z, r24
     1cc:	80 81       	ld	r24, Z
     1ce:	8b 7f       	andi	r24, 0xFB	; 251
     1d0:	80 83       	st	Z, r24
     1d2:	08 95       	ret

000001d4 <_ZN11ColorSensor19setFrequencyscalingE16FrequencyScaling>:
	}	
}

void ColorSensor::setFrequencyscaling( FrequencyScaling scaling )
{
	switch (scaling)
     1d4:	61 30       	cpi	r22, 0x01	; 1
     1d6:	79 f0       	breq	.+30     	; 0x1f6 <_ZN11ColorSensor19setFrequencyscalingE16FrequencyScaling+0x22>
     1d8:	28 f0       	brcs	.+10     	; 0x1e4 <_ZN11ColorSensor19setFrequencyscalingE16FrequencyScaling+0x10>
     1da:	62 30       	cpi	r22, 0x02	; 2
     1dc:	a9 f0       	breq	.+42     	; 0x208 <_ZN11ColorSensor19setFrequencyscalingE16FrequencyScaling+0x34>
     1de:	63 30       	cpi	r22, 0x03	; 3
     1e0:	e1 f0       	breq	.+56     	; 0x21a <_ZN11ColorSensor19setFrequencyscalingE16FrequencyScaling+0x46>
     1e2:	08 95       	ret
	{
	case powerDown:
		COLORSENSOR_S0_PORT &= ~( COLORSENSOR_S0_PIN );
     1e4:	e8 e0       	ldi	r30, 0x08	; 8
     1e6:	f1 e0       	ldi	r31, 0x01	; 1
     1e8:	80 81       	ld	r24, Z
     1ea:	88 7f       	andi	r24, 0xF8	; 248
     1ec:	80 83       	st	Z, r24
		COLORSENSOR_S1_PORT &= ~( COLORSENSOR_S1_PIN );
     1ee:	80 81       	ld	r24, Z
     1f0:	89 7f       	andi	r24, 0xF9	; 249
     1f2:	80 83       	st	Z, r24
		break;
     1f4:	08 95       	ret

	case twoPercent:
		COLORSENSOR_S0_PORT &= ~( COLORSENSOR_S0_PIN );
     1f6:	e8 e0       	ldi	r30, 0x08	; 8
     1f8:	f1 e0       	ldi	r31, 0x01	; 1
     1fa:	80 81       	ld	r24, Z
     1fc:	88 7f       	andi	r24, 0xF8	; 248
     1fe:	80 83       	st	Z, r24
		COLORSENSOR_S1_PORT |= COLORSENSOR_S1_PIN;
     200:	80 81       	ld	r24, Z
     202:	86 60       	ori	r24, 0x06	; 6
     204:	80 83       	st	Z, r24
		break;
     206:	08 95       	ret

	case twentyPercent:
		COLORSENSOR_S0_PORT |= COLORSENSOR_S0_PIN;
     208:	e8 e0       	ldi	r30, 0x08	; 8
     20a:	f1 e0       	ldi	r31, 0x01	; 1
     20c:	80 81       	ld	r24, Z
     20e:	87 60       	ori	r24, 0x07	; 7
     210:	80 83       	st	Z, r24
		COLORSENSOR_S1_PORT &= ~( COLORSENSOR_S1_PIN );
     212:	80 81       	ld	r24, Z
     214:	89 7f       	andi	r24, 0xF9	; 249
     216:	80 83       	st	Z, r24
		break;
     218:	08 95       	ret

	case hundredPercent:
		COLORSENSOR_S0_PORT |= COLORSENSOR_S0_PIN;
     21a:	e8 e0       	ldi	r30, 0x08	; 8
     21c:	f1 e0       	ldi	r31, 0x01	; 1
     21e:	80 81       	ld	r24, Z
     220:	87 60       	ori	r24, 0x07	; 7
     222:	80 83       	st	Z, r24
		COLORSENSOR_S1_PORT |= COLORSENSOR_S1_PIN;
     224:	80 81       	ld	r24, Z
     226:	86 60       	ori	r24, 0x06	; 6
     228:	80 83       	st	Z, r24
     22a:	08 95       	ret

0000022c <_ZN11ColorSensorC1E16FrequencyScaling>:
#include "FreeRTOS.h"
#include "task.h"
#include "portmacro.h"

// default constructor
ColorSensor::ColorSensor( FrequencyScaling scaling )
     22c:	bf 92       	push	r11
     22e:	cf 92       	push	r12
     230:	df 92       	push	r13
     232:	ef 92       	push	r14
     234:	ff 92       	push	r15
     236:	0f 93       	push	r16
     238:	1f 93       	push	r17
     23a:	cf 93       	push	r28
     23c:	df 93       	push	r29
     23e:	1f 92       	push	r1
     240:	cd b7       	in	r28, 0x3d	; 61
     242:	de b7       	in	r29, 0x3e	; 62
     244:	6c 01       	movw	r12, r24
     246:	b6 2e       	mov	r11, r22
     248:	26 d0       	rcall	.+76     	; 0x296 <_ZN6Timer4C1Ev>
     24a:	76 01       	movw	r14, r12
     24c:	8f ef       	ldi	r24, 0xFF	; 255
     24e:	e8 1a       	sub	r14, r24
     250:	f8 0a       	sbc	r15, r24
     252:	09 e0       	ldi	r16, 0x09	; 9
     254:	10 e0       	ldi	r17, 0x00	; 0
     256:	0f 3f       	cpi	r16, 0xFF	; 255
     258:	8f ef       	ldi	r24, 0xFF	; 255
     25a:	18 07       	cpc	r17, r24
     25c:	41 f0       	breq	.+16     	; 0x26e <_ZN11ColorSensorC1E16FrequencyScaling+0x42>
     25e:	c7 01       	movw	r24, r14
     260:	74 df       	rcall	.-280    	; 0x14a <_ZN5ColorC1Ev>
     262:	89 e0       	ldi	r24, 0x09	; 9
     264:	e8 0e       	add	r14, r24
     266:	f1 1c       	adc	r15, r1
     268:	01 50       	subi	r16, 0x01	; 1
     26a:	11 09       	sbc	r17, r1
     26c:	f4 cf       	rjmp	.-24     	; 0x256 <_ZN11ColorSensorC1E16FrequencyScaling+0x2a>
{
	frequency_ = Timer4();
     26e:	ce 01       	movw	r24, r28
     270:	01 96       	adiw	r24, 0x01	; 1
     272:	11 d0       	rcall	.+34     	; 0x296 <_ZN6Timer4C1Ev>

	// Set default filter and scaling
	setFilter( noFilter );
     274:	60 e0       	ldi	r22, 0x00	; 0
     276:	c6 01       	movw	r24, r12
     278:	81 df       	rcall	.-254    	; 0x17c <_ZN11ColorSensor9setFilterE6Filter>
	setFrequencyscaling( scaling );
     27a:	6b 2d       	mov	r22, r11
     27c:	c6 01       	movw	r24, r12
     27e:	aa df       	rcall	.-172    	; 0x1d4 <_ZN11ColorSensor19setFrequencyscalingE16FrequencyScaling>
     280:	0f 90       	pop	r0
}
     282:	df 91       	pop	r29
     284:	cf 91       	pop	r28
     286:	1f 91       	pop	r17
     288:	0f 91       	pop	r16
     28a:	ff 90       	pop	r15
     28c:	ef 90       	pop	r14
     28e:	df 90       	pop	r13
     290:	cf 90       	pop	r12
     292:	bf 90       	pop	r11
     294:	08 95       	ret

00000296 <_ZN6Timer4C1Ev>:
     296:	e8 e0       	ldi	r30, 0x08	; 8
			break;
		}
	}
	
	return period;
}
     298:	f1 e0       	ldi	r31, 0x01	; 1
     29a:	80 81       	ld	r24, Z
     29c:	80 68       	ori	r24, 0x80	; 128
     29e:	80 83       	st	Z, r24
     2a0:	80 81       	ld	r24, Z
     2a2:	80 64       	ori	r24, 0x40	; 64
     2a4:	80 83       	st	Z, r24
     2a6:	80 81       	ld	r24, Z
     2a8:	80 62       	ori	r24, 0x20	; 32
     2aa:	80 83       	st	Z, r24
     2ac:	80 81       	ld	r24, Z
     2ae:	80 61       	ori	r24, 0x10	; 16
     2b0:	80 83       	st	Z, r24
     2b2:	10 92 a0 00 	sts	0x00A0, r1	; 0x8000a0 <__TEXT_REGION_LENGTH__+0x7000a0>
     2b6:	83 ec       	ldi	r24, 0xC3	; 195
     2b8:	80 93 a1 00 	sts	0x00A1, r24	; 0x8000a1 <__TEXT_REGION_LENGTH__+0x7000a1>
     2bc:	10 92 a2 00 	sts	0x00A2, r1	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     2c0:	81 e2       	ldi	r24, 0x21	; 33
     2c2:	89 bb       	out	0x19, r24	; 25
     2c4:	10 92 a5 00 	sts	0x00A5, r1	; 0x8000a5 <__TEXT_REGION_LENGTH__+0x7000a5>
     2c8:	10 92 a4 00 	sts	0x00A4, r1	; 0x8000a4 <__TEXT_REGION_LENGTH__+0x7000a4>
     2cc:	78 94       	sei
     2ce:	08 95       	ret

000002d0 <__vector_45>:

ISR(TIMER4_OVF_vect)
{
     2d0:	1f 92       	push	r1
     2d2:	0f 92       	push	r0
     2d4:	0f b6       	in	r0, 0x3f	; 63
     2d6:	0f 92       	push	r0
     2d8:	11 24       	eor	r1, r1
     2da:	8f 93       	push	r24
     2dc:	9f 93       	push	r25
     2de:	af 93       	push	r26
     2e0:	bf 93       	push	r27
	timeroverflow++;
     2e2:	80 91 76 02 	lds	r24, 0x0276	; 0x800276 <timeroverflow>
     2e6:	90 91 77 02 	lds	r25, 0x0277	; 0x800277 <timeroverflow+0x1>
     2ea:	a0 91 78 02 	lds	r26, 0x0278	; 0x800278 <timeroverflow+0x2>
     2ee:	b0 91 79 02 	lds	r27, 0x0279	; 0x800279 <timeroverflow+0x3>
     2f2:	01 96       	adiw	r24, 0x01	; 1
     2f4:	a1 1d       	adc	r26, r1
     2f6:	b1 1d       	adc	r27, r1
     2f8:	80 93 76 02 	sts	0x0276, r24	; 0x800276 <timeroverflow>
     2fc:	90 93 77 02 	sts	0x0277, r25	; 0x800277 <timeroverflow+0x1>
     300:	a0 93 78 02 	sts	0x0278, r26	; 0x800278 <timeroverflow+0x2>
     304:	b0 93 79 02 	sts	0x0279, r27	; 0x800279 <timeroverflow+0x3>
}
     308:	bf 91       	pop	r27
     30a:	af 91       	pop	r26
     30c:	9f 91       	pop	r25
     30e:	8f 91       	pop	r24
     310:	0f 90       	pop	r0
     312:	0f be       	out	0x3f, r0	; 63
     314:	0f 90       	pop	r0
     316:	1f 90       	pop	r1
     318:	18 95       	reti

0000031a <__vector_41>:

ISR(TIMER4_CAPT_vect)
{
     31a:	1f 92       	push	r1
     31c:	0f 92       	push	r0
     31e:	0f b6       	in	r0, 0x3f	; 63
     320:	0f 92       	push	r0
     322:	11 24       	eor	r1, r1
     324:	0b b6       	in	r0, 0x3b	; 59
     326:	0f 92       	push	r0
     328:	cf 92       	push	r12
     32a:	df 92       	push	r13
     32c:	ef 92       	push	r14
     32e:	ff 92       	push	r15
     330:	0f 93       	push	r16
     332:	1f 93       	push	r17
     334:	2f 93       	push	r18
     336:	3f 93       	push	r19
     338:	4f 93       	push	r20
     33a:	5f 93       	push	r21
     33c:	6f 93       	push	r22
     33e:	7f 93       	push	r23
     340:	8f 93       	push	r24
     342:	9f 93       	push	r25
     344:	af 93       	push	r26
     346:	bf 93       	push	r27
     348:	ef 93       	push	r30
     34a:	ff 93       	push	r31
	// Read value of timer
	uint16_t readValue = ICR4;
     34c:	60 91 a6 00 	lds	r22, 0x00A6	; 0x8000a6 <__TEXT_REGION_LENGTH__+0x7000a6>
     350:	70 91 a7 00 	lds	r23, 0x00A7	; 0x8000a7 <__TEXT_REGION_LENGTH__+0x7000a7>

	if ( first == true )
     354:	80 91 0a 02 	lds	r24, 0x020A	; 0x80020a <first>
     358:	88 23       	and	r24, r24
     35a:	79 f0       	breq	.+30     	; 0x37a <__vector_41+0x60>
	{
		timeroverflow = 0U;
     35c:	10 92 76 02 	sts	0x0276, r1	; 0x800276 <timeroverflow>
     360:	10 92 77 02 	sts	0x0277, r1	; 0x800277 <timeroverflow+0x1>
     364:	10 92 78 02 	sts	0x0278, r1	; 0x800278 <timeroverflow+0x2>
     368:	10 92 79 02 	sts	0x0279, r1	; 0x800279 <timeroverflow+0x3>
		oldValue = readValue;
     36c:	70 93 7b 02 	sts	0x027B, r23	; 0x80027b <oldValue+0x1>
     370:	60 93 7a 02 	sts	0x027A, r22	; 0x80027a <oldValue>
		first = false;
     374:	10 92 0a 02 	sts	0x020A, r1	; 0x80020a <first>
		return;
     378:	81 c0       	rjmp	.+258    	; 0x47c <__LOCK_REGION_LENGTH__+0x7c>
	}
	
	// Check if overflow is pending
	if ( TIFR4 & ( 1 << TOV4 ))
     37a:	c8 9b       	sbis	0x19, 0	; 25
     37c:	13 c0       	rjmp	.+38     	; 0x3a4 <__vector_41+0x8a>
	{
		timeroverflow++;
     37e:	80 91 76 02 	lds	r24, 0x0276	; 0x800276 <timeroverflow>
     382:	90 91 77 02 	lds	r25, 0x0277	; 0x800277 <timeroverflow+0x1>
     386:	a0 91 78 02 	lds	r26, 0x0278	; 0x800278 <timeroverflow+0x2>
     38a:	b0 91 79 02 	lds	r27, 0x0279	; 0x800279 <timeroverflow+0x3>
     38e:	01 96       	adiw	r24, 0x01	; 1
     390:	a1 1d       	adc	r26, r1
     392:	b1 1d       	adc	r27, r1
     394:	80 93 76 02 	sts	0x0276, r24	; 0x800276 <timeroverflow>
     398:	90 93 77 02 	sts	0x0277, r25	; 0x800277 <timeroverflow+0x1>
     39c:	a0 93 78 02 	sts	0x0278, r26	; 0x800278 <timeroverflow+0x2>
     3a0:	b0 93 79 02 	sts	0x0279, r27	; 0x800279 <timeroverflow+0x3>
	}
		
	// Disable interrupt and clear pending
	TIMSK4 = 0U;	
     3a4:	10 92 72 00 	sts	0x0072, r1	; 0x800072 <__TEXT_REGION_LENGTH__+0x700072>
	TIFR4 = ( 1 << ICF4 ) | ( 1 << TOV4 );		
     3a8:	81 e2       	ldi	r24, 0x21	; 33
     3aa:	89 bb       	out	0x19, r24	; 25
			
	// Calculate difference
	uint32_t diff = 0U;

	if ( readValue < oldValue )
     3ac:	80 91 7a 02 	lds	r24, 0x027A	; 0x80027a <oldValue>
     3b0:	90 91 7b 02 	lds	r25, 0x027B	; 0x80027b <oldValue+0x1>
     3b4:	68 17       	cp	r22, r24
     3b6:	79 07       	cpc	r23, r25
     3b8:	58 f5       	brcc	.+86     	; 0x410 <__LOCK_REGION_LENGTH__+0x10>
	{
		if ( timeroverflow != 0 )
     3ba:	80 91 76 02 	lds	r24, 0x0276	; 0x800276 <timeroverflow>
     3be:	90 91 77 02 	lds	r25, 0x0277	; 0x800277 <timeroverflow+0x1>
     3c2:	a0 91 78 02 	lds	r26, 0x0278	; 0x800278 <timeroverflow+0x2>
     3c6:	b0 91 79 02 	lds	r27, 0x0279	; 0x800279 <timeroverflow+0x3>
     3ca:	89 2b       	or	r24, r25
     3cc:	8a 2b       	or	r24, r26
     3ce:	8b 2b       	or	r24, r27
     3d0:	99 f0       	breq	.+38     	; 0x3f8 <__vector_41+0xde>
		{
			timeroverflow--;
     3d2:	80 91 76 02 	lds	r24, 0x0276	; 0x800276 <timeroverflow>
     3d6:	90 91 77 02 	lds	r25, 0x0277	; 0x800277 <timeroverflow+0x1>
     3da:	a0 91 78 02 	lds	r26, 0x0278	; 0x800278 <timeroverflow+0x2>
     3de:	b0 91 79 02 	lds	r27, 0x0279	; 0x800279 <timeroverflow+0x3>
     3e2:	01 97       	sbiw	r24, 0x01	; 1
     3e4:	a1 09       	sbc	r26, r1
     3e6:	b1 09       	sbc	r27, r1
     3e8:	80 93 76 02 	sts	0x0276, r24	; 0x800276 <timeroverflow>
     3ec:	90 93 77 02 	sts	0x0277, r25	; 0x800277 <timeroverflow+0x1>
     3f0:	a0 93 78 02 	sts	0x0278, r26	; 0x800278 <timeroverflow+0x2>
     3f4:	b0 93 79 02 	sts	0x0279, r27	; 0x800279 <timeroverflow+0x3>
		}
		diff = ( 0xFFFF - oldValue ) + readValue;
     3f8:	80 91 7a 02 	lds	r24, 0x027A	; 0x80027a <oldValue>
     3fc:	90 91 7b 02 	lds	r25, 0x027B	; 0x80027b <oldValue+0x1>
     400:	68 1b       	sub	r22, r24
     402:	79 0b       	sbc	r23, r25
     404:	61 50       	subi	r22, 0x01	; 1
     406:	71 09       	sbc	r23, r1
     408:	cb 01       	movw	r24, r22
     40a:	a0 e0       	ldi	r26, 0x00	; 0
     40c:	b0 e0       	ldi	r27, 0x00	; 0
     40e:	09 c0       	rjmp	.+18     	; 0x422 <__LOCK_REGION_LENGTH__+0x22>
	}
	else
	{
		diff = readValue - oldValue;
     410:	80 91 7a 02 	lds	r24, 0x027A	; 0x80027a <oldValue>
     414:	90 91 7b 02 	lds	r25, 0x027B	; 0x80027b <oldValue+0x1>
     418:	68 1b       	sub	r22, r24
     41a:	79 0b       	sbc	r23, r25
     41c:	cb 01       	movw	r24, r22
     41e:	a0 e0       	ldi	r26, 0x00	; 0
     420:	b0 e0       	ldi	r27, 0x00	; 0
	}
	
	// Add timeroverflow to total diff
	diff += timeroverflow << 16U;
     422:	40 91 76 02 	lds	r20, 0x0276	; 0x800276 <timeroverflow>
     426:	50 91 77 02 	lds	r21, 0x0277	; 0x800277 <timeroverflow+0x1>
     42a:	60 91 78 02 	lds	r22, 0x0278	; 0x800278 <timeroverflow+0x2>
     42e:	70 91 79 02 	lds	r23, 0x0279	; 0x800279 <timeroverflow+0x3>
     432:	ba 01       	movw	r22, r20
     434:	55 27       	eor	r21, r21
     436:	44 27       	eor	r20, r20
     438:	8a 01       	movw	r16, r20
     43a:	9b 01       	movw	r18, r22
     43c:	08 0f       	add	r16, r24
     43e:	19 1f       	adc	r17, r25
     440:	2a 1f       	adc	r18, r26
     442:	3b 1f       	adc	r19, r27
     444:	c9 01       	movw	r24, r18
     446:	b8 01       	movw	r22, r16
	
	// Calculate period
	period = diff * tick * 1000000;
     448:	c0 90 06 02 	lds	r12, 0x0206	; 0x800206 <tick>
     44c:	d0 90 07 02 	lds	r13, 0x0207	; 0x800207 <tick+0x1>
     450:	e0 90 08 02 	lds	r14, 0x0208	; 0x800208 <tick+0x2>
     454:	f0 90 09 02 	lds	r15, 0x0209	; 0x800209 <tick+0x3>
     458:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <__floatunsisf>
     45c:	a7 01       	movw	r20, r14
     45e:	96 01       	movw	r18, r12
     460:	0e 94 86 10 	call	0x210c	; 0x210c <__mulsf3>
     464:	20 e0       	ldi	r18, 0x00	; 0
     466:	34 e2       	ldi	r19, 0x24	; 36
     468:	44 e7       	ldi	r20, 0x74	; 116
     46a:	59 e4       	ldi	r21, 0x49	; 73
     46c:	0e 94 86 10 	call	0x210c	; 0x210c <__mulsf3>
     470:	0e 94 a4 0f 	call	0x1f48	; 0x1f48 <__fixunssfsi>
     474:	70 93 75 02 	sts	0x0275, r23	; 0x800275 <__data_end+0x1>
     478:	60 93 74 02 	sts	0x0274, r22	; 0x800274 <__data_end>
     47c:	ff 91       	pop	r31
     47e:	ef 91       	pop	r30
     480:	bf 91       	pop	r27
     482:	af 91       	pop	r26
     484:	9f 91       	pop	r25
     486:	8f 91       	pop	r24
     488:	7f 91       	pop	r23
     48a:	6f 91       	pop	r22
     48c:	5f 91       	pop	r21
     48e:	4f 91       	pop	r20
     490:	3f 91       	pop	r19
     492:	2f 91       	pop	r18
     494:	1f 91       	pop	r17
     496:	0f 91       	pop	r16
     498:	ff 90       	pop	r15
     49a:	ef 90       	pop	r14
     49c:	df 90       	pop	r13
     49e:	cf 90       	pop	r12
     4a0:	0f 90       	pop	r0
     4a2:	0b be       	out	0x3b, r0	; 59
     4a4:	0f 90       	pop	r0
     4a6:	0f be       	out	0x3f, r0	; 63
     4a8:	0f 90       	pop	r0
     4aa:	1f 90       	pop	r1
     4ac:	18 95       	reti

000004ae <_Z8MainTaskPv>:
		
		case 5U:
		arm.grabBlock();
		vTaskDelay( 500 / portTICK_RATE_MS );
		arm.moveBlockToZoneSix();
		vTaskDelay( 500 / portTICK_RATE_MS );
     4ae:	8c e7       	ldi	r24, 0x7C	; 124
     4b0:	92 e0       	ldi	r25, 0x02	; 2
     4b2:	0e 94 00 0f 	call	0x1e00	; 0x1e00 <_ZN11Touchscreen11clearScreenEv>
     4b6:	ff cf       	rjmp	.-2      	; 0x4b6 <_Z8MainTaskPv+0x8>

000004b8 <_Z41__static_initialization_and_destruction_0ii>:
     4b8:	0f 93       	push	r16
     4ba:	1f 93       	push	r17
     4bc:	cf 93       	push	r28
     4be:	df 93       	push	r29
     4c0:	ec 01       	movw	r28, r24
     4c2:	8b 01       	movw	r16, r22
     4c4:	01 97       	sbiw	r24, 0x01	; 1
     4c6:	71 f4       	brne	.+28     	; 0x4e4 <_Z41__static_initialization_and_destruction_0ii+0x2c>
     4c8:	6f 3f       	cpi	r22, 0xFF	; 255
     4ca:	7f 4f       	sbci	r23, 0xFF	; 255
     4cc:	59 f4       	brne	.+22     	; 0x4e4 <_Z41__static_initialization_and_destruction_0ii+0x2c>
     4ce:	8d ee       	ldi	r24, 0xED	; 237
     4d0:	92 e0       	ldi	r25, 0x02	; 2
     4d2:	54 d0       	rcall	.+168    	; 0x57c <_ZN8RobotarmC1Ev>
     4d4:	62 e0       	ldi	r22, 0x02	; 2
     4d6:	82 e9       	ldi	r24, 0x92	; 146
     4d8:	92 e0       	ldi	r25, 0x02	; 2
     4da:	a8 de       	rcall	.-688    	; 0x22c <_ZN11ColorSensorC1E16FrequencyScaling>
     4dc:	8c e7       	ldi	r24, 0x7C	; 124
     4de:	92 e0       	ldi	r25, 0x02	; 2
     4e0:	0e 94 98 0e 	call	0x1d30	; 0x1d30 <_ZN11TouchscreenC1Ev>
     4e4:	cd 2b       	or	r28, r29
     4e6:	31 f4       	brne	.+12     	; 0x4f4 <_Z41__static_initialization_and_destruction_0ii+0x3c>
     4e8:	0f 3f       	cpi	r16, 0xFF	; 255
     4ea:	1f 4f       	sbci	r17, 0xFF	; 255
     4ec:	19 f4       	brne	.+6      	; 0x4f4 <_Z41__static_initialization_and_destruction_0ii+0x3c>
     4ee:	82 e9       	ldi	r24, 0x92	; 146
     4f0:	92 e0       	ldi	r25, 0x02	; 2
     4f2:	2d de       	rcall	.-934    	; 0x14e <_ZN11ColorSensorD1Ev>
     4f4:	df 91       	pop	r29
     4f6:	cf 91       	pop	r28
     4f8:	1f 91       	pop	r17
     4fa:	0f 91       	pop	r16
     4fc:	08 95       	ret

000004fe <__cxa_pure_virtual>:
     4fe:	ff cf       	rjmp	.-2      	; 0x4fe <__cxa_pure_virtual>

00000500 <_Znwj>:
     500:	0c 94 00 11 	jmp	0x2200	; 0x2200 <malloc>
     504:	08 95       	ret

00000506 <_ZdlPv>:
     506:	00 97       	sbiw	r24, 0x00	; 0
     508:	11 f0       	breq	.+4      	; 0x50e <_ZdlPv+0x8>
     50a:	0c 94 98 11 	jmp	0x2330	; 0x2330 <free>
     50e:	08 95       	ret

00000510 <main>:
	}
}

int main(void)
{
	xTaskCreate(MainTask,  ( signed char * ) "Task", configMAIN_STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL);
     510:	a1 2c       	mov	r10, r1
     512:	b1 2c       	mov	r11, r1
     514:	c1 2c       	mov	r12, r1
     516:	d1 2c       	mov	r13, r1
     518:	e1 2c       	mov	r14, r1
     51a:	f1 2c       	mov	r15, r1
     51c:	00 e0       	ldi	r16, 0x00	; 0
     51e:	20 e0       	ldi	r18, 0x00	; 0
     520:	30 e0       	ldi	r19, 0x00	; 0
     522:	48 ec       	ldi	r20, 0xC8	; 200
     524:	50 e0       	ldi	r21, 0x00	; 0
     526:	6e e0       	ldi	r22, 0x0E	; 14
     528:	72 e0       	ldi	r23, 0x02	; 2
     52a:	87 e5       	ldi	r24, 0x57	; 87
     52c:	92 e0       	ldi	r25, 0x02	; 2
     52e:	0e 94 34 0b 	call	0x1668	; 0x1668 <xTaskGenericCreate>
	vTaskStartScheduler();
     532:	0e 94 ec 0b 	call	0x17d8	; 0x17d8 <vTaskStartScheduler>
     536:	ff cf       	rjmp	.-2      	; 0x536 <main+0x26>

00000538 <_GLOBAL__sub_I___cxa_pure_virtual>:

	while (1)
	{
	}
}
     538:	6f ef       	ldi	r22, 0xFF	; 255
     53a:	7f ef       	ldi	r23, 0xFF	; 255
     53c:	81 e0       	ldi	r24, 0x01	; 1
     53e:	90 e0       	ldi	r25, 0x00	; 0
     540:	bb cf       	rjmp	.-138    	; 0x4b8 <_Z41__static_initialization_and_destruction_0ii>
     542:	08 95       	ret

00000544 <_GLOBAL__sub_D___cxa_pure_virtual>:
     544:	6f ef       	ldi	r22, 0xFF	; 255
     546:	7f ef       	ldi	r23, 0xFF	; 255
     548:	80 e0       	ldi	r24, 0x00	; 0
     54a:	90 e0       	ldi	r25, 0x00	; 0
     54c:	b5 cf       	rjmp	.-150    	; 0x4b8 <_Z41__static_initialization_and_destruction_0ii>
     54e:	08 95       	ret

00000550 <_ZN8Robotarm14startMotorImplEPv>:
	motors_[3]->SetDegrees(90);
	vTaskDelay( 250 / portTICK_RATE_MS );
}

void Robotarm::startMotorImpl( void *_this )
{
     550:	8c 01       	movw	r16, r24
void Robotarm::MotorSpeedController()
{
	while(1)
	{
		/* Move all motors one step. */
		for ( uint8_t i = 0U; i < 6U; i++ )
     552:	c0 e0       	ldi	r28, 0x00	; 0
     554:	c6 30       	cpi	r28, 0x06	; 6
     556:	e8 f7       	brcc	.-6      	; 0x552 <_ZN8Robotarm14startMotorImplEPv+0x2>
		{
			motors_[i]->TurnMotor();
     558:	ec 2f       	mov	r30, r28
     55a:	f0 e0       	ldi	r31, 0x00	; 0
     55c:	31 96       	adiw	r30, 0x01	; 1
     55e:	ee 0f       	add	r30, r30
     560:	ff 1f       	adc	r31, r31
     562:	e0 0f       	add	r30, r16
     564:	f1 1f       	adc	r31, r17
     566:	80 81       	ld	r24, Z
     568:	91 81       	ldd	r25, Z+1	; 0x01
     56a:	dc 01       	movw	r26, r24
     56c:	ed 91       	ld	r30, X+
     56e:	fc 91       	ld	r31, X
     570:	04 80       	ldd	r0, Z+4	; 0x04
     572:	f5 81       	ldd	r31, Z+5	; 0x05
     574:	e0 2d       	mov	r30, r0
     576:	19 95       	eicall
void Robotarm::MotorSpeedController()
{
	while(1)
	{
		/* Move all motors one step. */
		for ( uint8_t i = 0U; i < 6U; i++ )
     578:	cf 5f       	subi	r28, 0xFF	; 255
     57a:	ec cf       	rjmp	.-40     	; 0x554 <_ZN8Robotarm14startMotorImplEPv+0x4>

0000057c <_ZN8RobotarmC1Ev>:
/* RTOS include */
#include "FreeRTOS.h"
#include "task.h"
#include "portmacro.h"

Robotarm::Robotarm() : tmr1_(), tmr3_()
     57c:	af 92       	push	r10
     57e:	bf 92       	push	r11
     580:	cf 92       	push	r12
     582:	df 92       	push	r13
     584:	ef 92       	push	r14
     586:	ff 92       	push	r15
     588:	0f 93       	push	r16
     58a:	1f 93       	push	r17
     58c:	cf 93       	push	r28
     58e:	df 93       	push	r29
     590:	ec 01       	movw	r28, r24
     592:	4f d4       	rcall	.+2206   	; 0xe32 <_ZN6Timer1C1Ev>
     594:	8e 01       	movw	r16, r28
     596:	0f 5f       	subi	r16, 0xFF	; 255
     598:	1f 4f       	sbci	r17, 0xFF	; 255
     59a:	c8 01       	movw	r24, r16
     59c:	ee d4       	rcall	.+2524   	; 0xf7a <_ZN6Timer5C1Ev>
{
	/* Create all motor objects */
	motors_[0] = new M1( &tmr1_ );
     59e:	89 e1       	ldi	r24, 0x19	; 25
     5a0:	90 e0       	ldi	r25, 0x00	; 0
     5a2:	ae df       	rcall	.-164    	; 0x500 <_Znwj>
     5a4:	7c 01       	movw	r14, r24
     5a6:	be 01       	movw	r22, r28
     5a8:	e0 d0       	rcall	.+448    	; 0x76a <_ZN2M1C1EP6Timer1>
     5aa:	fb 82       	std	Y+3, r15	; 0x03
     5ac:	ea 82       	std	Y+2, r14	; 0x02
	motors_[1] = new M2( &tmr1_ );
     5ae:	89 e1       	ldi	r24, 0x19	; 25
     5b0:	90 e0       	ldi	r25, 0x00	; 0
     5b2:	a6 df       	rcall	.-180    	; 0x500 <_Znwj>
     5b4:	7c 01       	movw	r14, r24
     5b6:	be 01       	movw	r22, r28
     5b8:	7e d1       	rcall	.+764    	; 0x8b6 <_ZN2M2C1EP6Timer1>
     5ba:	fd 82       	std	Y+5, r15	; 0x05
     5bc:	ec 82       	std	Y+4, r14	; 0x04
	motors_[2] = new M3( &tmr1_ );
     5be:	89 e1       	ldi	r24, 0x19	; 25
     5c0:	90 e0       	ldi	r25, 0x00	; 0
     5c2:	9e df       	rcall	.-196    	; 0x500 <_Znwj>
     5c4:	7c 01       	movw	r14, r24
     5c6:	be 01       	movw	r22, r28
     5c8:	1c d2       	rcall	.+1080   	; 0xa02 <_ZN2M3C1EP6Timer1>
     5ca:	ff 82       	std	Y+7, r15	; 0x07
     5cc:	ee 82       	std	Y+6, r14	; 0x06
	motors_[3] = new M4( &tmr3_ );
     5ce:	89 e1       	ldi	r24, 0x19	; 25
     5d0:	90 e0       	ldi	r25, 0x00	; 0
     5d2:	96 df       	rcall	.-212    	; 0x500 <_Znwj>
     5d4:	7c 01       	movw	r14, r24
     5d6:	b8 01       	movw	r22, r16
     5d8:	b8 d2       	rcall	.+1392   	; 0xb4a <_ZN2M4C1EP6Timer5>
     5da:	f9 86       	std	Y+9, r15	; 0x09
     5dc:	e8 86       	std	Y+8, r14	; 0x08
	motors_[4] = new M5( &tmr3_ );
     5de:	89 e1       	ldi	r24, 0x19	; 25
     5e0:	90 e0       	ldi	r25, 0x00	; 0
     5e2:	8e df       	rcall	.-228    	; 0x500 <_Znwj>
     5e4:	7c 01       	movw	r14, r24
     5e6:	b8 01       	movw	r22, r16
     5e8:	54 d3       	rcall	.+1704   	; 0xc92 <_ZN2M5C1EP6Timer5>
     5ea:	fb 86       	std	Y+11, r15	; 0x0b
     5ec:	ea 86       	std	Y+10, r14	; 0x0a
	motors_[5] = new M6( &tmr3_ );
     5ee:	89 e1       	ldi	r24, 0x19	; 25
     5f0:	90 e0       	ldi	r25, 0x00	; 0
     5f2:	86 df       	rcall	.-244    	; 0x500 <_Znwj>
     5f4:	7c 01       	movw	r14, r24
     5f6:	b8 01       	movw	r22, r16
     5f8:	ec d3       	rcall	.+2008   	; 0xdd2 <_ZN2M6C1EP6Timer5>
     5fa:	fd 86       	std	Y+13, r15	; 0x0d
     5fc:	ec 86       	std	Y+12, r14	; 0x0c
     5fe:	a1 2c       	mov	r10, r1
     600:	b1 2c       	mov	r11, r1
	
	/* Create task to control motors */
	xTaskCreate(this->startMotorImpl,  ( signed char * ) "Motors", configMAIN_STACK_SIZE, this, tskIDLE_PRIORITY, NULL);
     602:	c1 2c       	mov	r12, r1
     604:	d1 2c       	mov	r13, r1
     606:	e1 2c       	mov	r14, r1
     608:	f1 2c       	mov	r15, r1
     60a:	00 e0       	ldi	r16, 0x00	; 0
     60c:	9e 01       	movw	r18, r28
     60e:	48 ec       	ldi	r20, 0xC8	; 200
     610:	50 e0       	ldi	r21, 0x00	; 0
     612:	63 e1       	ldi	r22, 0x13	; 19
     614:	72 e0       	ldi	r23, 0x02	; 2
     616:	88 ea       	ldi	r24, 0xA8	; 168
     618:	92 e0       	ldi	r25, 0x02	; 2
     61a:	0e 94 34 0b 	call	0x1668	; 0x1668 <xTaskGenericCreate>
     61e:	df 91       	pop	r29
     620:	cf 91       	pop	r28
}
     622:	1f 91       	pop	r17
     624:	0f 91       	pop	r16
     626:	ff 90       	pop	r15
     628:	ef 90       	pop	r14
     62a:	df 90       	pop	r13
     62c:	cf 90       	pop	r12
     62e:	bf 90       	pop	r11
     630:	af 90       	pop	r10
     632:	08 95       	ret

00000634 <_ZN5Motor10SetDegreesEh>:
	*	 can be used to turn motor at a specific speed set by \ref delay. C
	*	 Note that this function needs to run multiple times to work as intended.
	*    @param uint8_t	degrees to turn
	*    @return void Nothing
	*/
	virtual void SetDegrees( uint8_t degrees )
     634:	cf 92       	push	r12
     636:	df 92       	push	r13
     638:	ef 92       	push	r14
     63a:	ff 92       	push	r15
     63c:	cf 93       	push	r28
     63e:	df 93       	push	r29
	{
		if ( maxDegrees_ >= degrees )
     640:	fc 01       	movw	r30, r24
     642:	26 89       	ldd	r18, Z+22	; 0x16
     644:	26 17       	cp	r18, r22
     646:	c0 f0       	brcs	.+48     	; 0x678 <_ZN5Motor10SetDegreesEh+0x44>
     648:	ec 01       	movw	r28, r24
		{
			percent_ = percentPrDeg * degrees + startpercent_;
     64a:	c6 80       	ldd	r12, Z+6	; 0x06
     64c:	d7 80       	ldd	r13, Z+7	; 0x07
     64e:	e0 84       	ldd	r14, Z+8	; 0x08
     650:	f1 84       	ldd	r15, Z+9	; 0x09
     652:	70 e0       	ldi	r23, 0x00	; 0
     654:	80 e0       	ldi	r24, 0x00	; 0
     656:	90 e0       	ldi	r25, 0x00	; 0
     658:	0e 94 d2 0f 	call	0x1fa4	; 0x1fa4 <__floatsisf>
     65c:	a7 01       	movw	r20, r14
     65e:	96 01       	movw	r18, r12
     660:	0e 94 86 10 	call	0x210c	; 0x210c <__mulsf3>
     664:	2a 89       	ldd	r18, Y+18	; 0x12
     666:	3b 89       	ldd	r19, Y+19	; 0x13
     668:	4c 89       	ldd	r20, Y+20	; 0x14
     66a:	5d 89       	ldd	r21, Y+21	; 0x15
     66c:	0e 94 3c 0f 	call	0x1e78	; 0x1e78 <__addsf3>
     670:	6a 87       	std	Y+10, r22	; 0x0a
     672:	7b 87       	std	Y+11, r23	; 0x0b
     674:	8c 87       	std	Y+12, r24	; 0x0c
     676:	9d 87       	std	Y+13, r25	; 0x0d
		}
	}
     678:	df 91       	pop	r29
     67a:	cf 91       	pop	r28
     67c:	ff 90       	pop	r15
     67e:	ef 90       	pop	r14
     680:	df 90       	pop	r13
     682:	cf 90       	pop	r12
     684:	08 95       	ret

00000686 <_ZN2M1D1Ev>:

class Motor
{
//functions
public:
	virtual ~Motor() {};
     686:	2e e1       	ldi	r18, 0x1E	; 30
     688:	32 e0       	ldi	r19, 0x02	; 2
     68a:	fc 01       	movw	r30, r24
     68c:	31 83       	std	Z+1, r19	; 0x01
     68e:	20 83       	st	Z, r18
     690:	08 95       	ret

00000692 <_ZN2M1D0Ev>:
	SetDegrees( 90 );
	tmr1Ptr_->setDutyCycleComA( percent_ );
	oldPercent_ = percent_;
} 

M1::~M1()
     692:	cf 93       	push	r28
     694:	df 93       	push	r29
     696:	ec 01       	movw	r28, r24
{
}
     698:	f6 df       	rcall	.-20     	; 0x686 <_ZN2M1D1Ev>
     69a:	ce 01       	movw	r24, r28
     69c:	34 df       	rcall	.-408    	; 0x506 <_ZdlPv>
     69e:	df 91       	pop	r29
     6a0:	cf 91       	pop	r28
     6a2:	08 95       	ret

000006a4 <_ZN2M19TurnMotorEv>:

void M1::TurnMotor()
{
     6a4:	4f 92       	push	r4
     6a6:	5f 92       	push	r5
     6a8:	6f 92       	push	r6
     6aa:	7f 92       	push	r7
     6ac:	8f 92       	push	r8
     6ae:	9f 92       	push	r9
     6b0:	af 92       	push	r10
     6b2:	bf 92       	push	r11
     6b4:	cf 92       	push	r12
     6b6:	df 92       	push	r13
     6b8:	ef 92       	push	r14
     6ba:	ff 92       	push	r15
     6bc:	cf 93       	push	r28
     6be:	df 93       	push	r29
     6c0:	ec 01       	movw	r28, r24
	if ( percent_ > oldPercent_ + PERCENT_PR_TICK )
     6c2:	8a 84       	ldd	r8, Y+10	; 0x0a
     6c4:	9b 84       	ldd	r9, Y+11	; 0x0b
     6c6:	ac 84       	ldd	r10, Y+12	; 0x0c
     6c8:	bd 84       	ldd	r11, Y+13	; 0x0d
     6ca:	ce 84       	ldd	r12, Y+14	; 0x0e
     6cc:	df 84       	ldd	r13, Y+15	; 0x0f
     6ce:	e8 88       	ldd	r14, Y+16	; 0x10
     6d0:	f9 88       	ldd	r15, Y+17	; 0x11
     6d2:	20 e0       	ldi	r18, 0x00	; 0
     6d4:	30 e0       	ldi	r19, 0x00	; 0
     6d6:	40 e8       	ldi	r20, 0x80	; 128
     6d8:	5d e3       	ldi	r21, 0x3D	; 61
     6da:	c7 01       	movw	r24, r14
     6dc:	b6 01       	movw	r22, r12
     6de:	0e 94 3c 0f 	call	0x1e78	; 0x1e78 <__addsf3>
     6e2:	2b 01       	movw	r4, r22
     6e4:	3c 01       	movw	r6, r24
     6e6:	9b 01       	movw	r18, r22
     6e8:	ac 01       	movw	r20, r24
     6ea:	c5 01       	movw	r24, r10
     6ec:	b4 01       	movw	r22, r8
     6ee:	0e 94 82 10 	call	0x2104	; 0x2104 <__gesf2>
     6f2:	18 16       	cp	r1, r24
     6f4:	74 f4       	brge	.+28     	; 0x712 <_ZN2M19TurnMotorEv+0x6e>
	{
		oldPercent_ += PERCENT_PR_TICK;
     6f6:	4e 86       	std	Y+14, r4	; 0x0e
     6f8:	5f 86       	std	Y+15, r5	; 0x0f
     6fa:	68 8a       	std	Y+16, r6	; 0x10
     6fc:	79 8a       	std	Y+17, r7	; 0x11
		tmr1Ptr_->setDutyCycleComA( oldPercent_ );
     6fe:	b3 01       	movw	r22, r6
     700:	a2 01       	movw	r20, r4
     702:	8a 81       	ldd	r24, Y+2	; 0x02
     704:	9b 81       	ldd	r25, Y+3	; 0x03
     706:	b9 d3       	rcall	.+1906   	; 0xe7a <_ZN6Timer116setDutyCycleComAEf>
		vTaskDelay( delay_ / portTICK_RATE_MS );
     708:	8f 89       	ldd	r24, Y+23	; 0x17
     70a:	98 8d       	ldd	r25, Y+24	; 0x18
     70c:	0e 94 33 0d 	call	0x1a66	; 0x1a66 <vTaskDelay>
     710:	1d c0       	rjmp	.+58     	; 0x74c <_ZN2M19TurnMotorEv+0xa8>
	}
	else if ( percent_ < oldPercent_ )
     712:	a7 01       	movw	r20, r14
     714:	96 01       	movw	r18, r12
     716:	c5 01       	movw	r24, r10
     718:	b4 01       	movw	r22, r8
     71a:	0e 94 a0 0f 	call	0x1f40	; 0x1f40 <__cmpsf2>
     71e:	88 23       	and	r24, r24
     720:	ac f4       	brge	.+42     	; 0x74c <_ZN2M19TurnMotorEv+0xa8>
	{
		oldPercent_ -= PERCENT_PR_TICK;
     722:	20 e0       	ldi	r18, 0x00	; 0
     724:	30 e0       	ldi	r19, 0x00	; 0
     726:	40 e8       	ldi	r20, 0x80	; 128
     728:	5d e3       	ldi	r21, 0x3D	; 61
     72a:	c7 01       	movw	r24, r14
     72c:	b6 01       	movw	r22, r12
     72e:	0e 94 3b 0f 	call	0x1e76	; 0x1e76 <__subsf3>
     732:	ab 01       	movw	r20, r22
     734:	bc 01       	movw	r22, r24
     736:	4e 87       	std	Y+14, r20	; 0x0e
     738:	5f 87       	std	Y+15, r21	; 0x0f
     73a:	68 8b       	std	Y+16, r22	; 0x10
     73c:	79 8b       	std	Y+17, r23	; 0x11
		tmr1Ptr_->setDutyCycleComA( oldPercent_ );
     73e:	8a 81       	ldd	r24, Y+2	; 0x02
     740:	9b 81       	ldd	r25, Y+3	; 0x03
     742:	9b d3       	rcall	.+1846   	; 0xe7a <_ZN6Timer116setDutyCycleComAEf>
		vTaskDelay( delay_ / portTICK_RATE_MS );
     744:	8f 89       	ldd	r24, Y+23	; 0x17
     746:	98 8d       	ldd	r25, Y+24	; 0x18
     748:	0e 94 33 0d 	call	0x1a66	; 0x1a66 <vTaskDelay>
	}
}
     74c:	df 91       	pop	r29
     74e:	cf 91       	pop	r28
     750:	ff 90       	pop	r15
     752:	ef 90       	pop	r14
     754:	df 90       	pop	r13
     756:	cf 90       	pop	r12
     758:	bf 90       	pop	r11
     75a:	af 90       	pop	r10
     75c:	9f 90       	pop	r9
     75e:	8f 90       	pop	r8
     760:	7f 90       	pop	r7
     762:	6f 90       	pop	r6
     764:	5f 90       	pop	r5
     766:	4f 90       	pop	r4
     768:	08 95       	ret

0000076a <_ZN2M1C1EP6Timer1>:
* Author: jespe
*/

#include "M1.h"

M1::M1( Timer1* tmr )
     76a:	cf 93       	push	r28
     76c:	df 93       	push	r29
     76e:	ec 01       	movw	r28, r24
     770:	cb 01       	movw	r24, r22
     772:	2a e2       	ldi	r18, 0x2A	; 42
     774:	32 e0       	ldi	r19, 0x02	; 2
     776:	39 83       	std	Y+1, r19	; 0x01
     778:	28 83       	st	Y, r18
{
	/* Store timer pointer */
	tmr1Ptr_ = tmr;
     77a:	7b 83       	std	Y+3, r23	; 0x03
     77c:	6a 83       	std	Y+2, r22	; 0x02
	
	/* This value is number of percent to add or subtract pr degree. */
	percentPrDeg = 0.0555555555555556;
     77e:	49 e3       	ldi	r20, 0x39	; 57
     780:	5e e8       	ldi	r21, 0x8E	; 142
     782:	63 e6       	ldi	r22, 0x63	; 99
     784:	7d e3       	ldi	r23, 0x3D	; 61
     786:	4e 83       	std	Y+6, r20	; 0x06
     788:	5f 83       	std	Y+7, r21	; 0x07
     78a:	68 87       	std	Y+8, r22	; 0x08
     78c:	79 87       	std	Y+9, r23	; 0x09
	
	/* This value is the lowest duty cycle percentage needed to make motor turn. */
	startpercent_ = 2.5;
     78e:	40 e0       	ldi	r20, 0x00	; 0
     790:	50 e0       	ldi	r21, 0x00	; 0
     792:	60 e2       	ldi	r22, 0x20	; 32
     794:	70 e4       	ldi	r23, 0x40	; 64
     796:	4a 8b       	std	Y+18, r20	; 0x12
     798:	5b 8b       	std	Y+19, r21	; 0x13
     79a:	6c 8b       	std	Y+20, r22	; 0x14
     79c:	7d 8b       	std	Y+21, r23	; 0x15
	
	/* This value is the delay on motor. A lower value makes motors go faster and higher value makes motors go slower. */
	delay_ = 10;
     79e:	2a e0       	ldi	r18, 0x0A	; 10
     7a0:	30 e0       	ldi	r19, 0x00	; 0
     7a2:	38 8f       	std	Y+24, r19	; 0x18
     7a4:	2f 8b       	std	Y+23, r18	; 0x17
	
	/* This value is the maximum number of degrees the motor can turn */
	maxDegrees_ = 180;
     7a6:	24 eb       	ldi	r18, 0xB4	; 180
     7a8:	2e 8b       	std	Y+22, r18	; 0x16
	*/
	virtual void SetDegrees( uint8_t degrees )
	{
		if ( maxDegrees_ >= degrees )
		{
			percent_ = percentPrDeg * degrees + startpercent_;
     7aa:	40 e0       	ldi	r20, 0x00	; 0
     7ac:	50 e0       	ldi	r21, 0x00	; 0
     7ae:	60 ef       	ldi	r22, 0xF0	; 240
     7b0:	70 e4       	ldi	r23, 0x40	; 64
     7b2:	4a 87       	std	Y+10, r20	; 0x0a
     7b4:	5b 87       	std	Y+11, r21	; 0x0b
     7b6:	6c 87       	std	Y+12, r22	; 0x0c
     7b8:	7d 87       	std	Y+13, r23	; 0x0d
	
	/* Set motor to default startup value */
	SetDegrees( 90 );
	tmr1Ptr_->setDutyCycleComA( percent_ );
     7ba:	5f d3       	rcall	.+1726   	; 0xe7a <_ZN6Timer116setDutyCycleComAEf>
	oldPercent_ = percent_;
     7bc:	8a 85       	ldd	r24, Y+10	; 0x0a
     7be:	9b 85       	ldd	r25, Y+11	; 0x0b
     7c0:	ac 85       	ldd	r26, Y+12	; 0x0c
     7c2:	bd 85       	ldd	r27, Y+13	; 0x0d
     7c4:	8e 87       	std	Y+14, r24	; 0x0e
     7c6:	9f 87       	std	Y+15, r25	; 0x0f
     7c8:	a8 8b       	std	Y+16, r26	; 0x10
     7ca:	b9 8b       	std	Y+17, r27	; 0x11
} 
     7cc:	df 91       	pop	r29
     7ce:	cf 91       	pop	r28
     7d0:	08 95       	ret

000007d2 <_ZN2M2D1Ev>:

class Motor
{
//functions
public:
	virtual ~Motor() {};
     7d2:	2e e1       	ldi	r18, 0x1E	; 30
     7d4:	32 e0       	ldi	r19, 0x02	; 2
     7d6:	fc 01       	movw	r30, r24
     7d8:	31 83       	std	Z+1, r19	; 0x01
     7da:	20 83       	st	Z, r18
     7dc:	08 95       	ret

000007de <_ZN2M2D0Ev>:
	SetDegrees( 90 );
	tmr1Ptr_->setDutyCycleComB( percent_ );
	oldPercent_ = percent_;
}

M2::~M2()
     7de:	cf 93       	push	r28
     7e0:	df 93       	push	r29
     7e2:	ec 01       	movw	r28, r24
{
}
     7e4:	f6 df       	rcall	.-20     	; 0x7d2 <_ZN2M2D1Ev>
     7e6:	ce 01       	movw	r24, r28
     7e8:	8e de       	rcall	.-740    	; 0x506 <_ZdlPv>
     7ea:	df 91       	pop	r29
     7ec:	cf 91       	pop	r28
     7ee:	08 95       	ret

000007f0 <_ZN2M29TurnMotorEv>:

void M2::TurnMotor()
{
     7f0:	4f 92       	push	r4
     7f2:	5f 92       	push	r5
     7f4:	6f 92       	push	r6
     7f6:	7f 92       	push	r7
     7f8:	8f 92       	push	r8
     7fa:	9f 92       	push	r9
     7fc:	af 92       	push	r10
     7fe:	bf 92       	push	r11
     800:	cf 92       	push	r12
     802:	df 92       	push	r13
     804:	ef 92       	push	r14
     806:	ff 92       	push	r15
     808:	cf 93       	push	r28
     80a:	df 93       	push	r29
     80c:	ec 01       	movw	r28, r24
	if ( percent_ > oldPercent_ + PERCENT_PR_TICK )
     80e:	8a 84       	ldd	r8, Y+10	; 0x0a
     810:	9b 84       	ldd	r9, Y+11	; 0x0b
     812:	ac 84       	ldd	r10, Y+12	; 0x0c
     814:	bd 84       	ldd	r11, Y+13	; 0x0d
     816:	ce 84       	ldd	r12, Y+14	; 0x0e
     818:	df 84       	ldd	r13, Y+15	; 0x0f
     81a:	e8 88       	ldd	r14, Y+16	; 0x10
     81c:	f9 88       	ldd	r15, Y+17	; 0x11
     81e:	20 e0       	ldi	r18, 0x00	; 0
     820:	30 e0       	ldi	r19, 0x00	; 0
     822:	40 e8       	ldi	r20, 0x80	; 128
     824:	5d e3       	ldi	r21, 0x3D	; 61
     826:	c7 01       	movw	r24, r14
     828:	b6 01       	movw	r22, r12
     82a:	0e 94 3c 0f 	call	0x1e78	; 0x1e78 <__addsf3>
     82e:	2b 01       	movw	r4, r22
     830:	3c 01       	movw	r6, r24
     832:	9b 01       	movw	r18, r22
     834:	ac 01       	movw	r20, r24
     836:	c5 01       	movw	r24, r10
     838:	b4 01       	movw	r22, r8
     83a:	0e 94 82 10 	call	0x2104	; 0x2104 <__gesf2>
     83e:	18 16       	cp	r1, r24
     840:	74 f4       	brge	.+28     	; 0x85e <_ZN2M29TurnMotorEv+0x6e>
	{
		oldPercent_ += PERCENT_PR_TICK;
     842:	4e 86       	std	Y+14, r4	; 0x0e
     844:	5f 86       	std	Y+15, r5	; 0x0f
     846:	68 8a       	std	Y+16, r6	; 0x10
     848:	79 8a       	std	Y+17, r7	; 0x11
		tmr1Ptr_->setDutyCycleComB( oldPercent_ );
     84a:	b3 01       	movw	r22, r6
     84c:	a2 01       	movw	r20, r4
     84e:	8a 81       	ldd	r24, Y+2	; 0x02
     850:	9b 81       	ldd	r25, Y+3	; 0x03
     852:	3e d3       	rcall	.+1660   	; 0xed0 <_ZN6Timer116setDutyCycleComBEf>
		vTaskDelay( delay_ / portTICK_RATE_MS );
     854:	8f 89       	ldd	r24, Y+23	; 0x17
     856:	98 8d       	ldd	r25, Y+24	; 0x18
     858:	0e 94 33 0d 	call	0x1a66	; 0x1a66 <vTaskDelay>
     85c:	1d c0       	rjmp	.+58     	; 0x898 <_ZN2M29TurnMotorEv+0xa8>
	}
	else if ( percent_ < oldPercent_ )
     85e:	a7 01       	movw	r20, r14
     860:	96 01       	movw	r18, r12
     862:	c5 01       	movw	r24, r10
     864:	b4 01       	movw	r22, r8
     866:	0e 94 a0 0f 	call	0x1f40	; 0x1f40 <__cmpsf2>
     86a:	88 23       	and	r24, r24
     86c:	ac f4       	brge	.+42     	; 0x898 <_ZN2M29TurnMotorEv+0xa8>
	{
		oldPercent_ -= PERCENT_PR_TICK;
     86e:	20 e0       	ldi	r18, 0x00	; 0
     870:	30 e0       	ldi	r19, 0x00	; 0
     872:	40 e8       	ldi	r20, 0x80	; 128
     874:	5d e3       	ldi	r21, 0x3D	; 61
     876:	c7 01       	movw	r24, r14
     878:	b6 01       	movw	r22, r12
     87a:	0e 94 3b 0f 	call	0x1e76	; 0x1e76 <__subsf3>
     87e:	ab 01       	movw	r20, r22
     880:	bc 01       	movw	r22, r24
     882:	4e 87       	std	Y+14, r20	; 0x0e
     884:	5f 87       	std	Y+15, r21	; 0x0f
     886:	68 8b       	std	Y+16, r22	; 0x10
     888:	79 8b       	std	Y+17, r23	; 0x11
		tmr1Ptr_->setDutyCycleComB( oldPercent_ );
     88a:	8a 81       	ldd	r24, Y+2	; 0x02
     88c:	9b 81       	ldd	r25, Y+3	; 0x03
     88e:	20 d3       	rcall	.+1600   	; 0xed0 <_ZN6Timer116setDutyCycleComBEf>
		vTaskDelay( delay_ / portTICK_RATE_MS );
     890:	8f 89       	ldd	r24, Y+23	; 0x17
     892:	98 8d       	ldd	r25, Y+24	; 0x18
     894:	0e 94 33 0d 	call	0x1a66	; 0x1a66 <vTaskDelay>
	}
}
     898:	df 91       	pop	r29
     89a:	cf 91       	pop	r28
     89c:	ff 90       	pop	r15
     89e:	ef 90       	pop	r14
     8a0:	df 90       	pop	r13
     8a2:	cf 90       	pop	r12
     8a4:	bf 90       	pop	r11
     8a6:	af 90       	pop	r10
     8a8:	9f 90       	pop	r9
     8aa:	8f 90       	pop	r8
     8ac:	7f 90       	pop	r7
     8ae:	6f 90       	pop	r6
     8b0:	5f 90       	pop	r5
     8b2:	4f 90       	pop	r4
     8b4:	08 95       	ret

000008b6 <_ZN2M2C1EP6Timer1>:
* Author: jespe
*/

#include "M2.h"

M2::M2( Timer1* tmr )
     8b6:	cf 93       	push	r28
     8b8:	df 93       	push	r29
     8ba:	ec 01       	movw	r28, r24
     8bc:	cb 01       	movw	r24, r22
     8be:	26 e3       	ldi	r18, 0x36	; 54
     8c0:	32 e0       	ldi	r19, 0x02	; 2
     8c2:	39 83       	std	Y+1, r19	; 0x01
     8c4:	28 83       	st	Y, r18
{
	/* Store timer pointer */
	tmr1Ptr_ = tmr;
     8c6:	7b 83       	std	Y+3, r23	; 0x03
     8c8:	6a 83       	std	Y+2, r22	; 0x02
	
	/* This value is number of percent to add or subtract pr degree. */
	percentPrDeg = 0.06;
     8ca:	4f e8       	ldi	r20, 0x8F	; 143
     8cc:	52 ec       	ldi	r21, 0xC2	; 194
     8ce:	65 e7       	ldi	r22, 0x75	; 117
     8d0:	7d e3       	ldi	r23, 0x3D	; 61
     8d2:	4e 83       	std	Y+6, r20	; 0x06
     8d4:	5f 83       	std	Y+7, r21	; 0x07
     8d6:	68 87       	std	Y+8, r22	; 0x08
     8d8:	79 87       	std	Y+9, r23	; 0x09

	/* This value is the lowest duty cycle percentage needed to make motor turn. */
	startpercent_ = 3;
     8da:	40 e0       	ldi	r20, 0x00	; 0
     8dc:	50 e0       	ldi	r21, 0x00	; 0
     8de:	60 e4       	ldi	r22, 0x40	; 64
     8e0:	70 e4       	ldi	r23, 0x40	; 64
     8e2:	4a 8b       	std	Y+18, r20	; 0x12
     8e4:	5b 8b       	std	Y+19, r21	; 0x13
     8e6:	6c 8b       	std	Y+20, r22	; 0x14
     8e8:	7d 8b       	std	Y+21, r23	; 0x15

	/* This value is the delay on motor. A lower value makes motors go faster and higher value makes motors go slower. Value is in MS */
	delay_ = 10;
     8ea:	2a e0       	ldi	r18, 0x0A	; 10
     8ec:	30 e0       	ldi	r19, 0x00	; 0
     8ee:	38 8f       	std	Y+24, r19	; 0x18
     8f0:	2f 8b       	std	Y+23, r18	; 0x17

	/* This value is the maximum number of degrees the motor can turn */
	maxDegrees_ = 150;
     8f2:	26 e9       	ldi	r18, 0x96	; 150
     8f4:	2e 8b       	std	Y+22, r18	; 0x16
	*/
	virtual void SetDegrees( uint8_t degrees )
	{
		if ( maxDegrees_ >= degrees )
		{
			percent_ = percentPrDeg * degrees + startpercent_;
     8f6:	46 e6       	ldi	r20, 0x66	; 102
     8f8:	56 e6       	ldi	r21, 0x66	; 102
     8fa:	66 e0       	ldi	r22, 0x06	; 6
     8fc:	71 e4       	ldi	r23, 0x41	; 65
     8fe:	4a 87       	std	Y+10, r20	; 0x0a
     900:	5b 87       	std	Y+11, r21	; 0x0b
     902:	6c 87       	std	Y+12, r22	; 0x0c
     904:	7d 87       	std	Y+13, r23	; 0x0d

	/* Set motor to default startup value */
	SetDegrees( 90 );
	tmr1Ptr_->setDutyCycleComB( percent_ );
     906:	e4 d2       	rcall	.+1480   	; 0xed0 <_ZN6Timer116setDutyCycleComBEf>
	oldPercent_ = percent_;
     908:	8a 85       	ldd	r24, Y+10	; 0x0a
     90a:	9b 85       	ldd	r25, Y+11	; 0x0b
     90c:	ac 85       	ldd	r26, Y+12	; 0x0c
     90e:	bd 85       	ldd	r27, Y+13	; 0x0d
     910:	8e 87       	std	Y+14, r24	; 0x0e
     912:	9f 87       	std	Y+15, r25	; 0x0f
     914:	a8 8b       	std	Y+16, r26	; 0x10
     916:	b9 8b       	std	Y+17, r27	; 0x11
}
     918:	df 91       	pop	r29
     91a:	cf 91       	pop	r28
     91c:	08 95       	ret

0000091e <_ZN2M3D1Ev>:

class Motor
{
//functions
public:
	virtual ~Motor() {};
     91e:	2e e1       	ldi	r18, 0x1E	; 30
     920:	32 e0       	ldi	r19, 0x02	; 2
     922:	fc 01       	movw	r30, r24
     924:	31 83       	std	Z+1, r19	; 0x01
     926:	20 83       	st	Z, r18
     928:	08 95       	ret

0000092a <_ZN2M3D0Ev>:
	SetDegrees( 90 );
	tmr1Ptr_->setDutyCycleComC( percent_ );
	oldPercent_ = percent_;	
}

M3::~M3()
     92a:	cf 93       	push	r28
     92c:	df 93       	push	r29
     92e:	ec 01       	movw	r28, r24
{
}
     930:	f6 df       	rcall	.-20     	; 0x91e <_ZN2M3D1Ev>
     932:	ce 01       	movw	r24, r28
     934:	e8 dd       	rcall	.-1072   	; 0x506 <_ZdlPv>
     936:	df 91       	pop	r29
     938:	cf 91       	pop	r28
     93a:	08 95       	ret

0000093c <_ZN2M39TurnMotorEv>:

void M3::TurnMotor()
{
     93c:	4f 92       	push	r4
     93e:	5f 92       	push	r5
     940:	6f 92       	push	r6
     942:	7f 92       	push	r7
     944:	8f 92       	push	r8
     946:	9f 92       	push	r9
     948:	af 92       	push	r10
     94a:	bf 92       	push	r11
     94c:	cf 92       	push	r12
     94e:	df 92       	push	r13
     950:	ef 92       	push	r14
     952:	ff 92       	push	r15
     954:	cf 93       	push	r28
     956:	df 93       	push	r29
     958:	ec 01       	movw	r28, r24
	if ( percent_ > oldPercent_ + PERCENT_PR_TICK )
     95a:	8a 84       	ldd	r8, Y+10	; 0x0a
     95c:	9b 84       	ldd	r9, Y+11	; 0x0b
     95e:	ac 84       	ldd	r10, Y+12	; 0x0c
     960:	bd 84       	ldd	r11, Y+13	; 0x0d
     962:	ce 84       	ldd	r12, Y+14	; 0x0e
     964:	df 84       	ldd	r13, Y+15	; 0x0f
     966:	e8 88       	ldd	r14, Y+16	; 0x10
     968:	f9 88       	ldd	r15, Y+17	; 0x11
     96a:	20 e0       	ldi	r18, 0x00	; 0
     96c:	30 e0       	ldi	r19, 0x00	; 0
     96e:	40 e8       	ldi	r20, 0x80	; 128
     970:	5d e3       	ldi	r21, 0x3D	; 61
     972:	c7 01       	movw	r24, r14
     974:	b6 01       	movw	r22, r12
     976:	0e 94 3c 0f 	call	0x1e78	; 0x1e78 <__addsf3>
     97a:	2b 01       	movw	r4, r22
     97c:	3c 01       	movw	r6, r24
     97e:	9b 01       	movw	r18, r22
     980:	ac 01       	movw	r20, r24
     982:	c5 01       	movw	r24, r10
     984:	b4 01       	movw	r22, r8
     986:	0e 94 82 10 	call	0x2104	; 0x2104 <__gesf2>
     98a:	18 16       	cp	r1, r24
     98c:	74 f4       	brge	.+28     	; 0x9aa <_ZN2M39TurnMotorEv+0x6e>
	{
		oldPercent_ += PERCENT_PR_TICK;
     98e:	4e 86       	std	Y+14, r4	; 0x0e
     990:	5f 86       	std	Y+15, r5	; 0x0f
     992:	68 8a       	std	Y+16, r6	; 0x10
     994:	79 8a       	std	Y+17, r7	; 0x11
		tmr1Ptr_->setDutyCycleComC( oldPercent_ );
     996:	b3 01       	movw	r22, r6
     998:	a2 01       	movw	r20, r4
     99a:	8a 81       	ldd	r24, Y+2	; 0x02
     99c:	9b 81       	ldd	r25, Y+3	; 0x03
     99e:	c3 d2       	rcall	.+1414   	; 0xf26 <_ZN6Timer116setDutyCycleComCEf>
		vTaskDelay( delay_ / portTICK_RATE_MS );
     9a0:	8f 89       	ldd	r24, Y+23	; 0x17
     9a2:	98 8d       	ldd	r25, Y+24	; 0x18
     9a4:	0e 94 33 0d 	call	0x1a66	; 0x1a66 <vTaskDelay>
     9a8:	1d c0       	rjmp	.+58     	; 0x9e4 <_ZN2M39TurnMotorEv+0xa8>
	}
	else if ( percent_ < oldPercent_ )
     9aa:	a7 01       	movw	r20, r14
     9ac:	96 01       	movw	r18, r12
     9ae:	c5 01       	movw	r24, r10
     9b0:	b4 01       	movw	r22, r8
     9b2:	0e 94 a0 0f 	call	0x1f40	; 0x1f40 <__cmpsf2>
     9b6:	88 23       	and	r24, r24
     9b8:	ac f4       	brge	.+42     	; 0x9e4 <_ZN2M39TurnMotorEv+0xa8>
	{
		oldPercent_ -= PERCENT_PR_TICK;
     9ba:	20 e0       	ldi	r18, 0x00	; 0
     9bc:	30 e0       	ldi	r19, 0x00	; 0
     9be:	40 e8       	ldi	r20, 0x80	; 128
     9c0:	5d e3       	ldi	r21, 0x3D	; 61
     9c2:	c7 01       	movw	r24, r14
     9c4:	b6 01       	movw	r22, r12
     9c6:	0e 94 3b 0f 	call	0x1e76	; 0x1e76 <__subsf3>
     9ca:	ab 01       	movw	r20, r22
     9cc:	bc 01       	movw	r22, r24
     9ce:	4e 87       	std	Y+14, r20	; 0x0e
     9d0:	5f 87       	std	Y+15, r21	; 0x0f
     9d2:	68 8b       	std	Y+16, r22	; 0x10
     9d4:	79 8b       	std	Y+17, r23	; 0x11
		tmr1Ptr_->setDutyCycleComC( oldPercent_ );
     9d6:	8a 81       	ldd	r24, Y+2	; 0x02
     9d8:	9b 81       	ldd	r25, Y+3	; 0x03
     9da:	a5 d2       	rcall	.+1354   	; 0xf26 <_ZN6Timer116setDutyCycleComCEf>
		vTaskDelay( delay_ / portTICK_RATE_MS );
     9dc:	8f 89       	ldd	r24, Y+23	; 0x17
     9de:	98 8d       	ldd	r25, Y+24	; 0x18
     9e0:	0e 94 33 0d 	call	0x1a66	; 0x1a66 <vTaskDelay>
	}
}
     9e4:	df 91       	pop	r29
     9e6:	cf 91       	pop	r28
     9e8:	ff 90       	pop	r15
     9ea:	ef 90       	pop	r14
     9ec:	df 90       	pop	r13
     9ee:	cf 90       	pop	r12
     9f0:	bf 90       	pop	r11
     9f2:	af 90       	pop	r10
     9f4:	9f 90       	pop	r9
     9f6:	8f 90       	pop	r8
     9f8:	7f 90       	pop	r7
     9fa:	6f 90       	pop	r6
     9fc:	5f 90       	pop	r5
     9fe:	4f 90       	pop	r4
     a00:	08 95       	ret

00000a02 <_ZN2M3C1EP6Timer1>:
*/

#include "M3.h"


M3::M3( Timer1* tmr )
     a02:	cf 93       	push	r28
     a04:	df 93       	push	r29
     a06:	ec 01       	movw	r28, r24
     a08:	cb 01       	movw	r24, r22
     a0a:	22 e4       	ldi	r18, 0x42	; 66
     a0c:	32 e0       	ldi	r19, 0x02	; 2
     a0e:	39 83       	std	Y+1, r19	; 0x01
     a10:	28 83       	st	Y, r18
{
	/* Store timer pointer */
	tmr1Ptr_ = tmr;
     a12:	7b 83       	std	Y+3, r23	; 0x03
     a14:	6a 83       	std	Y+2, r22	; 0x02
		
	/* This value is number of percent to add or subtract pr degree. */
	percentPrDeg = 0.0555555555555556;
     a16:	49 e3       	ldi	r20, 0x39	; 57
     a18:	5e e8       	ldi	r21, 0x8E	; 142
     a1a:	63 e6       	ldi	r22, 0x63	; 99
     a1c:	7d e3       	ldi	r23, 0x3D	; 61
     a1e:	4e 83       	std	Y+6, r20	; 0x06
     a20:	5f 83       	std	Y+7, r21	; 0x07
     a22:	68 87       	std	Y+8, r22	; 0x08
     a24:	79 87       	std	Y+9, r23	; 0x09
	
	/* This value is the lowest duty cycle percentage needed to make motor turn. */
	startpercent_ = 2.5;
     a26:	40 e0       	ldi	r20, 0x00	; 0
     a28:	50 e0       	ldi	r21, 0x00	; 0
     a2a:	60 e2       	ldi	r22, 0x20	; 32
     a2c:	70 e4       	ldi	r23, 0x40	; 64
     a2e:	4a 8b       	std	Y+18, r20	; 0x12
     a30:	5b 8b       	std	Y+19, r21	; 0x13
     a32:	6c 8b       	std	Y+20, r22	; 0x14
     a34:	7d 8b       	std	Y+21, r23	; 0x15

	/* This value is the delay on motor. A lower value makes motors go faster and higher value makes motors go slower. Value is in MS */
	delay_ = 10;
     a36:	2a e0       	ldi	r18, 0x0A	; 10
     a38:	30 e0       	ldi	r19, 0x00	; 0
     a3a:	38 8f       	std	Y+24, r19	; 0x18
     a3c:	2f 8b       	std	Y+23, r18	; 0x17
	
	/* This value is the maximum number of degrees the motor can turn */
	maxDegrees_ = 180;
     a3e:	24 eb       	ldi	r18, 0xB4	; 180
     a40:	2e 8b       	std	Y+22, r18	; 0x16
	*/
	virtual void SetDegrees( uint8_t degrees )
	{
		if ( maxDegrees_ >= degrees )
		{
			percent_ = percentPrDeg * degrees + startpercent_;
     a42:	40 e0       	ldi	r20, 0x00	; 0
     a44:	50 e0       	ldi	r21, 0x00	; 0
     a46:	60 ef       	ldi	r22, 0xF0	; 240
     a48:	70 e4       	ldi	r23, 0x40	; 64
     a4a:	4a 87       	std	Y+10, r20	; 0x0a
     a4c:	5b 87       	std	Y+11, r21	; 0x0b
     a4e:	6c 87       	std	Y+12, r22	; 0x0c
     a50:	7d 87       	std	Y+13, r23	; 0x0d
	
	/* Set motor to default startup value */
	SetDegrees( 90 );
	tmr1Ptr_->setDutyCycleComC( percent_ );
     a52:	69 d2       	rcall	.+1234   	; 0xf26 <_ZN6Timer116setDutyCycleComCEf>
	oldPercent_ = percent_;	
     a54:	8a 85       	ldd	r24, Y+10	; 0x0a
     a56:	9b 85       	ldd	r25, Y+11	; 0x0b
     a58:	ac 85       	ldd	r26, Y+12	; 0x0c
     a5a:	bd 85       	ldd	r27, Y+13	; 0x0d
     a5c:	8e 87       	std	Y+14, r24	; 0x0e
     a5e:	9f 87       	std	Y+15, r25	; 0x0f
     a60:	a8 8b       	std	Y+16, r26	; 0x10
     a62:	b9 8b       	std	Y+17, r27	; 0x11
}
     a64:	df 91       	pop	r29
     a66:	cf 91       	pop	r28
     a68:	08 95       	ret

00000a6a <_ZN2M4D1Ev>:

class Motor
{
//functions
public:
	virtual ~Motor() {};
     a6a:	2e e1       	ldi	r18, 0x1E	; 30
     a6c:	32 e0       	ldi	r19, 0x02	; 2
     a6e:	fc 01       	movw	r30, r24
     a70:	31 83       	std	Z+1, r19	; 0x01
     a72:	20 83       	st	Z, r18
     a74:	08 95       	ret

00000a76 <_ZN2M4D0Ev>:
	SetDegrees( 90 );
	tmr3Ptr_->setDutyCycleComA( percent_ );
	oldPercent_ = percent_;
}

M4::~M4()
     a76:	cf 93       	push	r28
     a78:	df 93       	push	r29
     a7a:	ec 01       	movw	r28, r24
{
} 
     a7c:	f6 df       	rcall	.-20     	; 0xa6a <_ZN2M4D1Ev>
     a7e:	ce 01       	movw	r24, r28
     a80:	42 dd       	rcall	.-1404   	; 0x506 <_ZdlPv>
     a82:	df 91       	pop	r29
     a84:	cf 91       	pop	r28
     a86:	08 95       	ret

00000a88 <_ZN2M49TurnMotorEv>:

void M4::TurnMotor()
{
     a88:	4f 92       	push	r4
     a8a:	5f 92       	push	r5
     a8c:	6f 92       	push	r6
     a8e:	7f 92       	push	r7
     a90:	8f 92       	push	r8
     a92:	9f 92       	push	r9
     a94:	af 92       	push	r10
     a96:	bf 92       	push	r11
     a98:	cf 92       	push	r12
     a9a:	df 92       	push	r13
     a9c:	ef 92       	push	r14
     a9e:	ff 92       	push	r15
     aa0:	cf 93       	push	r28
     aa2:	df 93       	push	r29
     aa4:	ec 01       	movw	r28, r24
	if ( percent_ > oldPercent_ + PERCENT_PR_TICK )
     aa6:	8a 84       	ldd	r8, Y+10	; 0x0a
     aa8:	9b 84       	ldd	r9, Y+11	; 0x0b
     aaa:	ac 84       	ldd	r10, Y+12	; 0x0c
     aac:	bd 84       	ldd	r11, Y+13	; 0x0d
     aae:	ce 84       	ldd	r12, Y+14	; 0x0e
     ab0:	df 84       	ldd	r13, Y+15	; 0x0f
     ab2:	e8 88       	ldd	r14, Y+16	; 0x10
     ab4:	f9 88       	ldd	r15, Y+17	; 0x11
     ab6:	20 e0       	ldi	r18, 0x00	; 0
     ab8:	30 e0       	ldi	r19, 0x00	; 0
     aba:	40 e8       	ldi	r20, 0x80	; 128
     abc:	5d e3       	ldi	r21, 0x3D	; 61
     abe:	c7 01       	movw	r24, r14
     ac0:	b6 01       	movw	r22, r12
     ac2:	0e 94 3c 0f 	call	0x1e78	; 0x1e78 <__addsf3>
     ac6:	2b 01       	movw	r4, r22
     ac8:	3c 01       	movw	r6, r24
     aca:	9b 01       	movw	r18, r22
     acc:	ac 01       	movw	r20, r24
     ace:	c5 01       	movw	r24, r10
     ad0:	b4 01       	movw	r22, r8
     ad2:	0e 94 82 10 	call	0x2104	; 0x2104 <__gesf2>
     ad6:	18 16       	cp	r1, r24
     ad8:	6c f4       	brge	.+26     	; 0xaf4 <_ZN2M49TurnMotorEv+0x6c>
	{
		oldPercent_ += PERCENT_PR_TICK;
     ada:	4e 86       	std	Y+14, r4	; 0x0e
     adc:	5f 86       	std	Y+15, r5	; 0x0f
     ade:	68 8a       	std	Y+16, r6	; 0x10
     ae0:	79 8a       	std	Y+17, r7	; 0x11
		tmr3Ptr_->setDutyCycleComA( oldPercent_ );
     ae2:	b3 01       	movw	r22, r6
     ae4:	a2 01       	movw	r20, r4
     ae6:	8c 81       	ldd	r24, Y+4	; 0x04
     ae8:	9d 81       	ldd	r25, Y+5	; 0x05
     aea:	6d d2       	rcall	.+1242   	; 0xfc6 <_ZN6Timer516setDutyCycleComAEf>
		vTaskDelay( 10 / portTICK_RATE_MS );
     aec:	8a e0       	ldi	r24, 0x0A	; 10
     aee:	90 e0       	ldi	r25, 0x00	; 0
     af0:	ba d7       	rcall	.+3956   	; 0x1a66 <vTaskDelay>
     af2:	1c c0       	rjmp	.+56     	; 0xb2c <_ZN2M49TurnMotorEv+0xa4>
	}
	else if ( percent_ < oldPercent_ )
     af4:	a7 01       	movw	r20, r14
     af6:	96 01       	movw	r18, r12
     af8:	c5 01       	movw	r24, r10
     afa:	b4 01       	movw	r22, r8
     afc:	0e 94 a0 0f 	call	0x1f40	; 0x1f40 <__cmpsf2>
     b00:	88 23       	and	r24, r24
     b02:	a4 f4       	brge	.+40     	; 0xb2c <_ZN2M49TurnMotorEv+0xa4>
	{
		oldPercent_ -= PERCENT_PR_TICK;
     b04:	20 e0       	ldi	r18, 0x00	; 0
     b06:	30 e0       	ldi	r19, 0x00	; 0
     b08:	40 e8       	ldi	r20, 0x80	; 128
     b0a:	5d e3       	ldi	r21, 0x3D	; 61
     b0c:	c7 01       	movw	r24, r14
     b0e:	b6 01       	movw	r22, r12
     b10:	0e 94 3b 0f 	call	0x1e76	; 0x1e76 <__subsf3>
     b14:	ab 01       	movw	r20, r22
     b16:	bc 01       	movw	r22, r24
     b18:	4e 87       	std	Y+14, r20	; 0x0e
     b1a:	5f 87       	std	Y+15, r21	; 0x0f
     b1c:	68 8b       	std	Y+16, r22	; 0x10
     b1e:	79 8b       	std	Y+17, r23	; 0x11
		tmr3Ptr_->setDutyCycleComA( oldPercent_ );
     b20:	8c 81       	ldd	r24, Y+4	; 0x04
     b22:	9d 81       	ldd	r25, Y+5	; 0x05
     b24:	50 d2       	rcall	.+1184   	; 0xfc6 <_ZN6Timer516setDutyCycleComAEf>
		vTaskDelay( 10 / portTICK_RATE_MS );
     b26:	8a e0       	ldi	r24, 0x0A	; 10
     b28:	90 e0       	ldi	r25, 0x00	; 0
     b2a:	9d d7       	rcall	.+3898   	; 0x1a66 <vTaskDelay>
     b2c:	df 91       	pop	r29
	}
}
     b2e:	cf 91       	pop	r28
     b30:	ff 90       	pop	r15
     b32:	ef 90       	pop	r14
     b34:	df 90       	pop	r13
     b36:	cf 90       	pop	r12
     b38:	bf 90       	pop	r11
     b3a:	af 90       	pop	r10
     b3c:	9f 90       	pop	r9
     b3e:	8f 90       	pop	r8
     b40:	7f 90       	pop	r7
     b42:	6f 90       	pop	r6
     b44:	5f 90       	pop	r5
     b46:	4f 90       	pop	r4
     b48:	08 95       	ret

00000b4a <_ZN2M4C1EP6Timer5>:
     b4a:	cf 93       	push	r28
* Author: jespe
*/

#include "M4.h"

M4::M4( Timer5* tmr )
     b4c:	df 93       	push	r29
     b4e:	ec 01       	movw	r28, r24
     b50:	cb 01       	movw	r24, r22
     b52:	2e e4       	ldi	r18, 0x4E	; 78
     b54:	32 e0       	ldi	r19, 0x02	; 2
     b56:	39 83       	std	Y+1, r19	; 0x01
     b58:	28 83       	st	Y, r18
{
	/* Store timer pointer */
	tmr3Ptr_ = tmr;
     b5a:	7d 83       	std	Y+5, r23	; 0x05
     b5c:	6c 83       	std	Y+4, r22	; 0x04
	
	/* This value is number of percent to add or subtract pr degree. */
	percentPrDeg = 0.0555555555555556;
     b5e:	49 e3       	ldi	r20, 0x39	; 57
     b60:	5e e8       	ldi	r21, 0x8E	; 142
     b62:	63 e6       	ldi	r22, 0x63	; 99
     b64:	7d e3       	ldi	r23, 0x3D	; 61
     b66:	4e 83       	std	Y+6, r20	; 0x06
     b68:	5f 83       	std	Y+7, r21	; 0x07
     b6a:	68 87       	std	Y+8, r22	; 0x08
     b6c:	79 87       	std	Y+9, r23	; 0x09
	
	/* This value is the lowest duty cycle percentage needed to make motor turn. */
	startpercent_ = 2.5;
     b6e:	40 e0       	ldi	r20, 0x00	; 0
     b70:	50 e0       	ldi	r21, 0x00	; 0
     b72:	60 e2       	ldi	r22, 0x20	; 32
     b74:	70 e4       	ldi	r23, 0x40	; 64
     b76:	4a 8b       	std	Y+18, r20	; 0x12
     b78:	5b 8b       	std	Y+19, r21	; 0x13
     b7a:	6c 8b       	std	Y+20, r22	; 0x14
     b7c:	7d 8b       	std	Y+21, r23	; 0x15
		
	/* This value is the delay on motor. A lower value makes motors go faster and higher value makes motors go slower. Value is in MS */
	delay_ = 5;
     b7e:	25 e0       	ldi	r18, 0x05	; 5
     b80:	30 e0       	ldi	r19, 0x00	; 0
     b82:	38 8f       	std	Y+24, r19	; 0x18
     b84:	2f 8b       	std	Y+23, r18	; 0x17
	
	/* This value is the maximum number of degrees the motor can turn */
	maxDegrees_ = 180;
     b86:	24 eb       	ldi	r18, 0xB4	; 180
     b88:	2e 8b       	std	Y+22, r18	; 0x16
	*/
	virtual void SetDegrees( uint8_t degrees )
	{
		if ( maxDegrees_ >= degrees )
		{
			percent_ = percentPrDeg * degrees + startpercent_;
     b8a:	40 e0       	ldi	r20, 0x00	; 0
     b8c:	50 e0       	ldi	r21, 0x00	; 0
     b8e:	60 ef       	ldi	r22, 0xF0	; 240
     b90:	70 e4       	ldi	r23, 0x40	; 64
     b92:	4a 87       	std	Y+10, r20	; 0x0a
     b94:	5b 87       	std	Y+11, r21	; 0x0b
     b96:	6c 87       	std	Y+12, r22	; 0x0c
     b98:	7d 87       	std	Y+13, r23	; 0x0d
	
	/* Set motor to default startup value */
	SetDegrees( 90 );
	tmr3Ptr_->setDutyCycleComA( percent_ );
     b9a:	15 d2       	rcall	.+1066   	; 0xfc6 <_ZN6Timer516setDutyCycleComAEf>
	oldPercent_ = percent_;
     b9c:	8a 85       	ldd	r24, Y+10	; 0x0a
     b9e:	9b 85       	ldd	r25, Y+11	; 0x0b
     ba0:	ac 85       	ldd	r26, Y+12	; 0x0c
     ba2:	bd 85       	ldd	r27, Y+13	; 0x0d
     ba4:	8e 87       	std	Y+14, r24	; 0x0e
     ba6:	9f 87       	std	Y+15, r25	; 0x0f
     ba8:	a8 8b       	std	Y+16, r26	; 0x10
     baa:	b9 8b       	std	Y+17, r27	; 0x11
}
     bac:	df 91       	pop	r29
     bae:	cf 91       	pop	r28
     bb0:	08 95       	ret

00000bb2 <_ZN2M5D1Ev>:

class Motor
{
//functions
public:
	virtual ~Motor() {};
     bb2:	2e e1       	ldi	r18, 0x1E	; 30
     bb4:	32 e0       	ldi	r19, 0x02	; 2
     bb6:	fc 01       	movw	r30, r24
     bb8:	31 83       	std	Z+1, r19	; 0x01
     bba:	20 83       	st	Z, r18
     bbc:	08 95       	ret

00000bbe <_ZN2M5D0Ev>:
	SetDegrees( 0 );
	tmr3Ptr_->setDutyCycleComB( percent_ );
	oldPercent_ = percent_;
}

M5::~M5()
     bbe:	cf 93       	push	r28
     bc0:	df 93       	push	r29
     bc2:	ec 01       	movw	r28, r24
{
}
     bc4:	f6 df       	rcall	.-20     	; 0xbb2 <_ZN2M5D1Ev>
     bc6:	ce 01       	movw	r24, r28
     bc8:	9e dc       	rcall	.-1732   	; 0x506 <_ZdlPv>
     bca:	df 91       	pop	r29
     bcc:	cf 91       	pop	r28
     bce:	08 95       	ret

00000bd0 <_ZN2M59TurnMotorEv>:

void M5::TurnMotor()
{
     bd0:	4f 92       	push	r4
     bd2:	5f 92       	push	r5
     bd4:	6f 92       	push	r6
     bd6:	7f 92       	push	r7
     bd8:	8f 92       	push	r8
     bda:	9f 92       	push	r9
     bdc:	af 92       	push	r10
     bde:	bf 92       	push	r11
     be0:	cf 92       	push	r12
     be2:	df 92       	push	r13
     be4:	ef 92       	push	r14
     be6:	ff 92       	push	r15
     be8:	cf 93       	push	r28
     bea:	df 93       	push	r29
     bec:	ec 01       	movw	r28, r24
	if ( percent_ > oldPercent_ + PERCENT_PR_TICK )
     bee:	8a 84       	ldd	r8, Y+10	; 0x0a
     bf0:	9b 84       	ldd	r9, Y+11	; 0x0b
     bf2:	ac 84       	ldd	r10, Y+12	; 0x0c
     bf4:	bd 84       	ldd	r11, Y+13	; 0x0d
     bf6:	ce 84       	ldd	r12, Y+14	; 0x0e
     bf8:	df 84       	ldd	r13, Y+15	; 0x0f
     bfa:	e8 88       	ldd	r14, Y+16	; 0x10
     bfc:	f9 88       	ldd	r15, Y+17	; 0x11
     bfe:	20 e0       	ldi	r18, 0x00	; 0
     c00:	30 e0       	ldi	r19, 0x00	; 0
     c02:	40 e8       	ldi	r20, 0x80	; 128
     c04:	5d e3       	ldi	r21, 0x3D	; 61
     c06:	c7 01       	movw	r24, r14
     c08:	b6 01       	movw	r22, r12
     c0a:	0e 94 3c 0f 	call	0x1e78	; 0x1e78 <__addsf3>
     c0e:	2b 01       	movw	r4, r22
     c10:	3c 01       	movw	r6, r24
     c12:	9b 01       	movw	r18, r22
     c14:	ac 01       	movw	r20, r24
     c16:	c5 01       	movw	r24, r10
     c18:	b4 01       	movw	r22, r8
     c1a:	0e 94 82 10 	call	0x2104	; 0x2104 <__gesf2>
     c1e:	18 16       	cp	r1, r24
     c20:	6c f4       	brge	.+26     	; 0xc3c <_ZN2M59TurnMotorEv+0x6c>
	{
		oldPercent_ += PERCENT_PR_TICK;
     c22:	4e 86       	std	Y+14, r4	; 0x0e
     c24:	5f 86       	std	Y+15, r5	; 0x0f
     c26:	68 8a       	std	Y+16, r6	; 0x10
     c28:	79 8a       	std	Y+17, r7	; 0x11
		tmr3Ptr_->setDutyCycleComB( oldPercent_ );
     c2a:	b3 01       	movw	r22, r6
     c2c:	a2 01       	movw	r20, r4
     c2e:	8c 81       	ldd	r24, Y+4	; 0x04
     c30:	9d 81       	ldd	r25, Y+5	; 0x05
     c32:	f2 d1       	rcall	.+996    	; 0x1018 <_ZN6Timer516setDutyCycleComBEf>
		vTaskDelay( delay_ / portTICK_RATE_MS );
     c34:	8f 89       	ldd	r24, Y+23	; 0x17
     c36:	98 8d       	ldd	r25, Y+24	; 0x18
     c38:	16 d7       	rcall	.+3628   	; 0x1a66 <vTaskDelay>
     c3a:	1c c0       	rjmp	.+56     	; 0xc74 <_ZN2M59TurnMotorEv+0xa4>
	}
	else if ( percent_ < oldPercent_ )
     c3c:	a7 01       	movw	r20, r14
     c3e:	96 01       	movw	r18, r12
     c40:	c5 01       	movw	r24, r10
     c42:	b4 01       	movw	r22, r8
     c44:	0e 94 a0 0f 	call	0x1f40	; 0x1f40 <__cmpsf2>
     c48:	88 23       	and	r24, r24
     c4a:	a4 f4       	brge	.+40     	; 0xc74 <_ZN2M59TurnMotorEv+0xa4>
	{
		oldPercent_ -= PERCENT_PR_TICK;
     c4c:	20 e0       	ldi	r18, 0x00	; 0
     c4e:	30 e0       	ldi	r19, 0x00	; 0
     c50:	40 e8       	ldi	r20, 0x80	; 128
     c52:	5d e3       	ldi	r21, 0x3D	; 61
     c54:	c7 01       	movw	r24, r14
     c56:	b6 01       	movw	r22, r12
     c58:	0e 94 3b 0f 	call	0x1e76	; 0x1e76 <__subsf3>
     c5c:	ab 01       	movw	r20, r22
     c5e:	bc 01       	movw	r22, r24
     c60:	4e 87       	std	Y+14, r20	; 0x0e
     c62:	5f 87       	std	Y+15, r21	; 0x0f
     c64:	68 8b       	std	Y+16, r22	; 0x10
     c66:	79 8b       	std	Y+17, r23	; 0x11
		tmr3Ptr_->setDutyCycleComB( oldPercent_ );
     c68:	8c 81       	ldd	r24, Y+4	; 0x04
     c6a:	9d 81       	ldd	r25, Y+5	; 0x05
     c6c:	d5 d1       	rcall	.+938    	; 0x1018 <_ZN6Timer516setDutyCycleComBEf>
		vTaskDelay( delay_ / portTICK_RATE_MS );
     c6e:	8f 89       	ldd	r24, Y+23	; 0x17
     c70:	98 8d       	ldd	r25, Y+24	; 0x18
     c72:	f9 d6       	rcall	.+3570   	; 0x1a66 <vTaskDelay>
     c74:	df 91       	pop	r29
	}
}
     c76:	cf 91       	pop	r28
     c78:	ff 90       	pop	r15
     c7a:	ef 90       	pop	r14
     c7c:	df 90       	pop	r13
     c7e:	cf 90       	pop	r12
     c80:	bf 90       	pop	r11
     c82:	af 90       	pop	r10
     c84:	9f 90       	pop	r9
     c86:	8f 90       	pop	r8
     c88:	7f 90       	pop	r7
     c8a:	6f 90       	pop	r6
     c8c:	5f 90       	pop	r5
     c8e:	4f 90       	pop	r4
     c90:	08 95       	ret

00000c92 <_ZN2M5C1EP6Timer5>:
     c92:	cf 93       	push	r28
* Author: jespe
*/

#include "M5.h"

M5::M5( Timer5* tmr )
     c94:	df 93       	push	r29
     c96:	ec 01       	movw	r28, r24
     c98:	cb 01       	movw	r24, r22
     c9a:	2a e5       	ldi	r18, 0x5A	; 90
     c9c:	32 e0       	ldi	r19, 0x02	; 2
     c9e:	39 83       	std	Y+1, r19	; 0x01
     ca0:	28 83       	st	Y, r18
{
	/* Store timer pointer */
	tmr3Ptr_ = tmr;
     ca2:	7d 83       	std	Y+5, r23	; 0x05
     ca4:	6c 83       	std	Y+4, r22	; 0x04
	
	/* This value is number of percent to add or subtract pr degree. */
	percentPrDeg = 0.0555555555555556;
     ca6:	49 e3       	ldi	r20, 0x39	; 57
     ca8:	5e e8       	ldi	r21, 0x8E	; 142
     caa:	63 e6       	ldi	r22, 0x63	; 99
     cac:	7d e3       	ldi	r23, 0x3D	; 61
     cae:	4e 83       	std	Y+6, r20	; 0x06
     cb0:	5f 83       	std	Y+7, r21	; 0x07
     cb2:	68 87       	std	Y+8, r22	; 0x08
     cb4:	79 87       	std	Y+9, r23	; 0x09
	
	/* This value is the lowest duty cycle percentage needed to make motor turn. */
	startpercent_ = 2.5;
     cb6:	40 e0       	ldi	r20, 0x00	; 0
     cb8:	50 e0       	ldi	r21, 0x00	; 0
     cba:	60 e2       	ldi	r22, 0x20	; 32
     cbc:	70 e4       	ldi	r23, 0x40	; 64
     cbe:	4a 8b       	std	Y+18, r20	; 0x12
     cc0:	5b 8b       	std	Y+19, r21	; 0x13
     cc2:	6c 8b       	std	Y+20, r22	; 0x14
     cc4:	7d 8b       	std	Y+21, r23	; 0x15
	
	/* This value is the delay on motor. A lower value makes motors go faster and higher value makes motors go slower. Value is in MS */
	delay_ = 1;
     cc6:	21 e0       	ldi	r18, 0x01	; 1
     cc8:	30 e0       	ldi	r19, 0x00	; 0
     cca:	38 8f       	std	Y+24, r19	; 0x18
     ccc:	2f 8b       	std	Y+23, r18	; 0x17
	
	/* This value is the maximum number of degrees the motor can turn */
	maxDegrees_ = 180;
     cce:	24 eb       	ldi	r18, 0xB4	; 180
     cd0:	2e 8b       	std	Y+22, r18	; 0x16
	*/
	virtual void SetDegrees( uint8_t degrees )
	{
		if ( maxDegrees_ >= degrees )
		{
			percent_ = percentPrDeg * degrees + startpercent_;
     cd2:	4a 87       	std	Y+10, r20	; 0x0a
     cd4:	5b 87       	std	Y+11, r21	; 0x0b
     cd6:	6c 87       	std	Y+12, r22	; 0x0c
     cd8:	7d 87       	std	Y+13, r23	; 0x0d
	
	/* Set motor to default startup value */
	SetDegrees( 0 );
	tmr3Ptr_->setDutyCycleComB( percent_ );
     cda:	9e d1       	rcall	.+828    	; 0x1018 <_ZN6Timer516setDutyCycleComBEf>
	oldPercent_ = percent_;
     cdc:	8a 85       	ldd	r24, Y+10	; 0x0a
     cde:	9b 85       	ldd	r25, Y+11	; 0x0b
     ce0:	ac 85       	ldd	r26, Y+12	; 0x0c
     ce2:	bd 85       	ldd	r27, Y+13	; 0x0d
     ce4:	8e 87       	std	Y+14, r24	; 0x0e
     ce6:	9f 87       	std	Y+15, r25	; 0x0f
     ce8:	a8 8b       	std	Y+16, r26	; 0x10
     cea:	b9 8b       	std	Y+17, r27	; 0x11
}
     cec:	df 91       	pop	r29
     cee:	cf 91       	pop	r28
     cf0:	08 95       	ret

00000cf2 <_ZN2M6D1Ev>:

class Motor
{
//functions
public:
	virtual ~Motor() {};
     cf2:	2e e1       	ldi	r18, 0x1E	; 30
     cf4:	32 e0       	ldi	r19, 0x02	; 2
     cf6:	fc 01       	movw	r30, r24
     cf8:	31 83       	std	Z+1, r19	; 0x01
     cfa:	20 83       	st	Z, r18
     cfc:	08 95       	ret

00000cfe <_ZN2M6D0Ev>:
	SetDegrees( 0 );
	tmr3Ptr_->setDutyCycleComC( percent_ );
	oldPercent_ = percent_;
}

M6::~M6()
     cfe:	cf 93       	push	r28
     d00:	df 93       	push	r29
     d02:	ec 01       	movw	r28, r24
{
}
     d04:	f6 df       	rcall	.-20     	; 0xcf2 <_ZN2M6D1Ev>
     d06:	ce 01       	movw	r24, r28
     d08:	fe db       	rcall	.-2052   	; 0x506 <_ZdlPv>
     d0a:	df 91       	pop	r29
     d0c:	cf 91       	pop	r28
     d0e:	08 95       	ret

00000d10 <_ZN2M69TurnMotorEv>:

void M6::TurnMotor()
{
     d10:	4f 92       	push	r4
     d12:	5f 92       	push	r5
     d14:	6f 92       	push	r6
     d16:	7f 92       	push	r7
     d18:	8f 92       	push	r8
     d1a:	9f 92       	push	r9
     d1c:	af 92       	push	r10
     d1e:	bf 92       	push	r11
     d20:	cf 92       	push	r12
     d22:	df 92       	push	r13
     d24:	ef 92       	push	r14
     d26:	ff 92       	push	r15
     d28:	cf 93       	push	r28
     d2a:	df 93       	push	r29
     d2c:	ec 01       	movw	r28, r24
	if ( percent_ > oldPercent_ + PERCENT_PR_TICK )
     d2e:	8a 84       	ldd	r8, Y+10	; 0x0a
     d30:	9b 84       	ldd	r9, Y+11	; 0x0b
     d32:	ac 84       	ldd	r10, Y+12	; 0x0c
     d34:	bd 84       	ldd	r11, Y+13	; 0x0d
     d36:	ce 84       	ldd	r12, Y+14	; 0x0e
     d38:	df 84       	ldd	r13, Y+15	; 0x0f
     d3a:	e8 88       	ldd	r14, Y+16	; 0x10
     d3c:	f9 88       	ldd	r15, Y+17	; 0x11
     d3e:	20 e0       	ldi	r18, 0x00	; 0
     d40:	30 e0       	ldi	r19, 0x00	; 0
     d42:	40 e8       	ldi	r20, 0x80	; 128
     d44:	5d e3       	ldi	r21, 0x3D	; 61
     d46:	c7 01       	movw	r24, r14
     d48:	b6 01       	movw	r22, r12
     d4a:	0e 94 3c 0f 	call	0x1e78	; 0x1e78 <__addsf3>
     d4e:	2b 01       	movw	r4, r22
     d50:	3c 01       	movw	r6, r24
     d52:	9b 01       	movw	r18, r22
     d54:	ac 01       	movw	r20, r24
     d56:	c5 01       	movw	r24, r10
     d58:	b4 01       	movw	r22, r8
     d5a:	0e 94 82 10 	call	0x2104	; 0x2104 <__gesf2>
     d5e:	18 16       	cp	r1, r24
     d60:	6c f4       	brge	.+26     	; 0xd7c <_ZN2M69TurnMotorEv+0x6c>
	{
		oldPercent_ += 0.0625;
     d62:	4e 86       	std	Y+14, r4	; 0x0e
     d64:	5f 86       	std	Y+15, r5	; 0x0f
     d66:	68 8a       	std	Y+16, r6	; 0x10
     d68:	79 8a       	std	Y+17, r7	; 0x11
		tmr3Ptr_->setDutyCycleComC( oldPercent_ );
     d6a:	b3 01       	movw	r22, r6
     d6c:	a2 01       	movw	r20, r4
     d6e:	8c 81       	ldd	r24, Y+4	; 0x04
     d70:	9d 81       	ldd	r25, Y+5	; 0x05
     d72:	7b d1       	rcall	.+758    	; 0x106a <_ZN6Timer516setDutyCycleComCEf>
		vTaskDelay( delay_ / portTICK_RATE_MS );
     d74:	8f 89       	ldd	r24, Y+23	; 0x17
     d76:	98 8d       	ldd	r25, Y+24	; 0x18
     d78:	76 d6       	rcall	.+3308   	; 0x1a66 <vTaskDelay>
     d7a:	1c c0       	rjmp	.+56     	; 0xdb4 <_ZN2M69TurnMotorEv+0xa4>
	}
	else if ( percent_ < oldPercent_ )
     d7c:	a7 01       	movw	r20, r14
     d7e:	96 01       	movw	r18, r12
     d80:	c5 01       	movw	r24, r10
     d82:	b4 01       	movw	r22, r8
     d84:	0e 94 a0 0f 	call	0x1f40	; 0x1f40 <__cmpsf2>
     d88:	88 23       	and	r24, r24
     d8a:	a4 f4       	brge	.+40     	; 0xdb4 <_ZN2M69TurnMotorEv+0xa4>
	{
		oldPercent_ -= 0.0625;
     d8c:	20 e0       	ldi	r18, 0x00	; 0
     d8e:	30 e0       	ldi	r19, 0x00	; 0
     d90:	40 e8       	ldi	r20, 0x80	; 128
     d92:	5d e3       	ldi	r21, 0x3D	; 61
     d94:	c7 01       	movw	r24, r14
     d96:	b6 01       	movw	r22, r12
     d98:	0e 94 3b 0f 	call	0x1e76	; 0x1e76 <__subsf3>
     d9c:	ab 01       	movw	r20, r22
     d9e:	bc 01       	movw	r22, r24
     da0:	4e 87       	std	Y+14, r20	; 0x0e
     da2:	5f 87       	std	Y+15, r21	; 0x0f
     da4:	68 8b       	std	Y+16, r22	; 0x10
     da6:	79 8b       	std	Y+17, r23	; 0x11
		tmr3Ptr_->setDutyCycleComC( oldPercent_ );
     da8:	8c 81       	ldd	r24, Y+4	; 0x04
     daa:	9d 81       	ldd	r25, Y+5	; 0x05
     dac:	5e d1       	rcall	.+700    	; 0x106a <_ZN6Timer516setDutyCycleComCEf>
		vTaskDelay( delay_ / portTICK_RATE_MS );
     dae:	8f 89       	ldd	r24, Y+23	; 0x17
     db0:	98 8d       	ldd	r25, Y+24	; 0x18
     db2:	59 d6       	rcall	.+3250   	; 0x1a66 <vTaskDelay>
     db4:	df 91       	pop	r29
	}
}
     db6:	cf 91       	pop	r28
     db8:	ff 90       	pop	r15
     dba:	ef 90       	pop	r14
     dbc:	df 90       	pop	r13
     dbe:	cf 90       	pop	r12
     dc0:	bf 90       	pop	r11
     dc2:	af 90       	pop	r10
     dc4:	9f 90       	pop	r9
     dc6:	8f 90       	pop	r8
     dc8:	7f 90       	pop	r7
     dca:	6f 90       	pop	r6
     dcc:	5f 90       	pop	r5
     dce:	4f 90       	pop	r4
     dd0:	08 95       	ret

00000dd2 <_ZN2M6C1EP6Timer5>:
     dd2:	cf 93       	push	r28
* Author: jespe
*/

#include "M6.h"

M6::M6( Timer5* tmr )
     dd4:	df 93       	push	r29
     dd6:	ec 01       	movw	r28, r24
     dd8:	cb 01       	movw	r24, r22
     dda:	26 e6       	ldi	r18, 0x66	; 102
     ddc:	32 e0       	ldi	r19, 0x02	; 2
     dde:	39 83       	std	Y+1, r19	; 0x01
     de0:	28 83       	st	Y, r18
{
	/* Store timer pointer */
	tmr3Ptr_ = tmr;
     de2:	7d 83       	std	Y+5, r23	; 0x05
     de4:	6c 83       	std	Y+4, r22	; 0x04
	
	/* This value is number of percent to add or subtract pr degree. */
	percentPrDeg = 0.07936507936507;
     de6:	49 e2       	ldi	r20, 0x29	; 41
     de8:	5a e8       	ldi	r21, 0x8A	; 138
     dea:	62 ea       	ldi	r22, 0xA2	; 162
     dec:	7d e3       	ldi	r23, 0x3D	; 61
     dee:	4e 83       	std	Y+6, r20	; 0x06
     df0:	5f 83       	std	Y+7, r21	; 0x07
     df2:	68 87       	std	Y+8, r22	; 0x08
     df4:	79 87       	std	Y+9, r23	; 0x09
	
	/* This value is the lowest duty cycle percentage needed to make motor turn. */
	startpercent_ = 2.5;
     df6:	40 e0       	ldi	r20, 0x00	; 0
     df8:	50 e0       	ldi	r21, 0x00	; 0
     dfa:	60 e2       	ldi	r22, 0x20	; 32
     dfc:	70 e4       	ldi	r23, 0x40	; 64
     dfe:	4a 8b       	std	Y+18, r20	; 0x12
     e00:	5b 8b       	std	Y+19, r21	; 0x13
     e02:	6c 8b       	std	Y+20, r22	; 0x14
     e04:	7d 8b       	std	Y+21, r23	; 0x15
	
	/* This value is the delay on motor. A lower value makes motors go faster and higher value makes motors go slower. Value is in MS */
	delay_ = 1;
     e06:	21 e0       	ldi	r18, 0x01	; 1
     e08:	30 e0       	ldi	r19, 0x00	; 0
     e0a:	38 8f       	std	Y+24, r19	; 0x18
     e0c:	2f 8b       	std	Y+23, r18	; 0x17
	
	/* This value is the maximum number of degrees the motor can turn */
	maxDegrees_ = 63;
     e0e:	2f e3       	ldi	r18, 0x3F	; 63
     e10:	2e 8b       	std	Y+22, r18	; 0x16
	*/
	virtual void SetDegrees( uint8_t degrees )
	{
		if ( maxDegrees_ >= degrees )
		{
			percent_ = percentPrDeg * degrees + startpercent_;
     e12:	4a 87       	std	Y+10, r20	; 0x0a
     e14:	5b 87       	std	Y+11, r21	; 0x0b
     e16:	6c 87       	std	Y+12, r22	; 0x0c
     e18:	7d 87       	std	Y+13, r23	; 0x0d
	
	/* Set motor to default startup value */
	SetDegrees( 0 );
	tmr3Ptr_->setDutyCycleComC( percent_ );
     e1a:	27 d1       	rcall	.+590    	; 0x106a <_ZN6Timer516setDutyCycleComCEf>
	oldPercent_ = percent_;
     e1c:	8a 85       	ldd	r24, Y+10	; 0x0a
     e1e:	9b 85       	ldd	r25, Y+11	; 0x0b
     e20:	ac 85       	ldd	r26, Y+12	; 0x0c
     e22:	bd 85       	ldd	r27, Y+13	; 0x0d
     e24:	8e 87       	std	Y+14, r24	; 0x0e
     e26:	9f 87       	std	Y+15, r25	; 0x0f
     e28:	a8 8b       	std	Y+16, r26	; 0x10
     e2a:	b9 8b       	std	Y+17, r27	; 0x11
}
     e2c:	df 91       	pop	r29
     e2e:	cf 91       	pop	r28
     e30:	08 95       	ret

00000e32 <_ZN6Timer1C1Ev>:
#include <avr/io.h>

Timer1::Timer1()
{
	// Set all needed ports to outputs
	ROBOTARM_M1_OUT_PORT |= ( 1 << ROBOTARM_M1_OUT_PIN );
     e32:	84 b1       	in	r24, 0x04	; 4
     e34:	80 62       	ori	r24, 0x20	; 32
     e36:	84 b9       	out	0x04, r24	; 4
	ROBOTARM_M2_OUT_PORT |= ( 1 << ROBOTARM_M2_OUT_PIN );
     e38:	84 b1       	in	r24, 0x04	; 4
     e3a:	80 64       	ori	r24, 0x40	; 64
     e3c:	84 b9       	out	0x04, r24	; 4
	ROBOTARM_M3_OUT_PORT |= ( 1 << ROBOTARM_M3_OUT_PIN );
     e3e:	84 b1       	in	r24, 0x04	; 4
     e40:	80 68       	ori	r24, 0x80	; 128
     e42:	84 b9       	out	0x04, r24	; 4
		
	// Set timer to run in PWM, Phase Correct mode with 50 Hz freq. 
	TCCR1A = ( 1 << COM1A1 ) | ( 1 << COM1B1 ) | ( 1 << COM1C1 ) | ( 0 << WGM10 ) | ( 0 << WGM11 );
     e44:	88 ea       	ldi	r24, 0xA8	; 168
     e46:	80 93 80 00 	sts	0x0080, r24	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
	TCCR1B = ( 1 << WGM13 ) | ( 0 << CS10 )  | ( 1 << CS12 );
     e4a:	84 e1       	ldi	r24, 0x14	; 20
     e4c:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x700081>
	TCCR1C = 0;
     e50:	10 92 82 00 	sts	0x0082, r1	; 0x800082 <__TEXT_REGION_LENGTH__+0x700082>
	ICR1 = 622;
     e54:	8e e6       	ldi	r24, 0x6E	; 110
     e56:	92 e0       	ldi	r25, 0x02	; 2
     e58:	90 93 87 00 	sts	0x0087, r25	; 0x800087 <__TEXT_REGION_LENGTH__+0x700087>
     e5c:	80 93 86 00 	sts	0x0086, r24	; 0x800086 <__TEXT_REGION_LENGTH__+0x700086>
	
	OCR1A = 0;
     e60:	10 92 89 00 	sts	0x0089, r1	; 0x800089 <__TEXT_REGION_LENGTH__+0x700089>
     e64:	10 92 88 00 	sts	0x0088, r1	; 0x800088 <__TEXT_REGION_LENGTH__+0x700088>
	OCR1B = 0;
     e68:	10 92 8b 00 	sts	0x008B, r1	; 0x80008b <__TEXT_REGION_LENGTH__+0x70008b>
     e6c:	10 92 8a 00 	sts	0x008A, r1	; 0x80008a <__TEXT_REGION_LENGTH__+0x70008a>
	OCR1C = 0;
     e70:	10 92 8d 00 	sts	0x008D, r1	; 0x80008d <__TEXT_REGION_LENGTH__+0x70008d>
     e74:	10 92 8c 00 	sts	0x008C, r1	; 0x80008c <__TEXT_REGION_LENGTH__+0x70008c>
     e78:	08 95       	ret

00000e7a <_ZN6Timer116setDutyCycleComAEf>:
}

void Timer1::setDutyCycleComA( float dutyCycle )
{
     e7a:	cf 92       	push	r12
     e7c:	df 92       	push	r13
     e7e:	ef 92       	push	r14
     e80:	ff 92       	push	r15
     e82:	6a 01       	movw	r12, r20
     e84:	7b 01       	movw	r14, r22
	float percent = ICR1/100;
     e86:	20 91 86 00 	lds	r18, 0x0086	; 0x800086 <__TEXT_REGION_LENGTH__+0x700086>
     e8a:	30 91 87 00 	lds	r19, 0x0087	; 0x800087 <__TEXT_REGION_LENGTH__+0x700087>
     e8e:	36 95       	lsr	r19
     e90:	27 95       	ror	r18
     e92:	36 95       	lsr	r19
     e94:	27 95       	ror	r18
     e96:	ab e7       	ldi	r26, 0x7B	; 123
     e98:	b4 e1       	ldi	r27, 0x14	; 20
     e9a:	0e 94 f1 10 	call	0x21e2	; 0x21e2 <__umulhisi3>
     e9e:	96 95       	lsr	r25
     ea0:	87 95       	ror	r24
	OCR1A = (uint8_t)percent*dutyCycle;
     ea2:	bc 01       	movw	r22, r24
     ea4:	77 27       	eor	r23, r23
     ea6:	07 2e       	mov	r0, r23
     ea8:	00 0c       	add	r0, r0
     eaa:	88 0b       	sbc	r24, r24
     eac:	99 0b       	sbc	r25, r25
     eae:	0e 94 d2 0f 	call	0x1fa4	; 0x1fa4 <__floatsisf>
     eb2:	a7 01       	movw	r20, r14
     eb4:	96 01       	movw	r18, r12
     eb6:	0e 94 86 10 	call	0x210c	; 0x210c <__mulsf3>
     eba:	0e 94 a4 0f 	call	0x1f48	; 0x1f48 <__fixunssfsi>
     ebe:	70 93 89 00 	sts	0x0089, r23	; 0x800089 <__TEXT_REGION_LENGTH__+0x700089>
     ec2:	60 93 88 00 	sts	0x0088, r22	; 0x800088 <__TEXT_REGION_LENGTH__+0x700088>
}
     ec6:	ff 90       	pop	r15
     ec8:	ef 90       	pop	r14
     eca:	df 90       	pop	r13
     ecc:	cf 90       	pop	r12
     ece:	08 95       	ret

00000ed0 <_ZN6Timer116setDutyCycleComBEf>:

void Timer1::setDutyCycleComB( float dutyCycle )
{
     ed0:	cf 92       	push	r12
     ed2:	df 92       	push	r13
     ed4:	ef 92       	push	r14
     ed6:	ff 92       	push	r15
     ed8:	6a 01       	movw	r12, r20
     eda:	7b 01       	movw	r14, r22
	float percent = ICR1/100;
     edc:	20 91 86 00 	lds	r18, 0x0086	; 0x800086 <__TEXT_REGION_LENGTH__+0x700086>
     ee0:	30 91 87 00 	lds	r19, 0x0087	; 0x800087 <__TEXT_REGION_LENGTH__+0x700087>
     ee4:	36 95       	lsr	r19
     ee6:	27 95       	ror	r18
     ee8:	36 95       	lsr	r19
     eea:	27 95       	ror	r18
     eec:	ab e7       	ldi	r26, 0x7B	; 123
     eee:	b4 e1       	ldi	r27, 0x14	; 20
     ef0:	0e 94 f1 10 	call	0x21e2	; 0x21e2 <__umulhisi3>
     ef4:	96 95       	lsr	r25
     ef6:	87 95       	ror	r24
	OCR1B = (uint8_t)percent*dutyCycle;
     ef8:	bc 01       	movw	r22, r24
     efa:	77 27       	eor	r23, r23
     efc:	07 2e       	mov	r0, r23
     efe:	00 0c       	add	r0, r0
     f00:	88 0b       	sbc	r24, r24
     f02:	99 0b       	sbc	r25, r25
     f04:	0e 94 d2 0f 	call	0x1fa4	; 0x1fa4 <__floatsisf>
     f08:	a7 01       	movw	r20, r14
     f0a:	96 01       	movw	r18, r12
     f0c:	0e 94 86 10 	call	0x210c	; 0x210c <__mulsf3>
     f10:	0e 94 a4 0f 	call	0x1f48	; 0x1f48 <__fixunssfsi>
     f14:	70 93 8b 00 	sts	0x008B, r23	; 0x80008b <__TEXT_REGION_LENGTH__+0x70008b>
     f18:	60 93 8a 00 	sts	0x008A, r22	; 0x80008a <__TEXT_REGION_LENGTH__+0x70008a>
}
     f1c:	ff 90       	pop	r15
     f1e:	ef 90       	pop	r14
     f20:	df 90       	pop	r13
     f22:	cf 90       	pop	r12
     f24:	08 95       	ret

00000f26 <_ZN6Timer116setDutyCycleComCEf>:

void Timer1::setDutyCycleComC( float dutyCycle )
{
     f26:	cf 92       	push	r12
     f28:	df 92       	push	r13
     f2a:	ef 92       	push	r14
     f2c:	ff 92       	push	r15
     f2e:	6a 01       	movw	r12, r20
     f30:	7b 01       	movw	r14, r22
	float percent = ICR1/100;
     f32:	20 91 86 00 	lds	r18, 0x0086	; 0x800086 <__TEXT_REGION_LENGTH__+0x700086>
     f36:	30 91 87 00 	lds	r19, 0x0087	; 0x800087 <__TEXT_REGION_LENGTH__+0x700087>
     f3a:	36 95       	lsr	r19
     f3c:	27 95       	ror	r18
     f3e:	36 95       	lsr	r19
     f40:	27 95       	ror	r18
     f42:	ab e7       	ldi	r26, 0x7B	; 123
     f44:	b4 e1       	ldi	r27, 0x14	; 20
     f46:	0e 94 f1 10 	call	0x21e2	; 0x21e2 <__umulhisi3>
     f4a:	96 95       	lsr	r25
     f4c:	87 95       	ror	r24
	OCR1C = (uint8_t)percent*dutyCycle;
     f4e:	bc 01       	movw	r22, r24
     f50:	77 27       	eor	r23, r23
     f52:	07 2e       	mov	r0, r23
     f54:	00 0c       	add	r0, r0
     f56:	88 0b       	sbc	r24, r24
     f58:	99 0b       	sbc	r25, r25
     f5a:	0e 94 d2 0f 	call	0x1fa4	; 0x1fa4 <__floatsisf>
     f5e:	a7 01       	movw	r20, r14
     f60:	96 01       	movw	r18, r12
     f62:	0e 94 86 10 	call	0x210c	; 0x210c <__mulsf3>
     f66:	f0 d7       	rcall	.+4064   	; 0x1f48 <__fixunssfsi>
     f68:	70 93 8d 00 	sts	0x008D, r23	; 0x80008d <__TEXT_REGION_LENGTH__+0x70008d>
     f6c:	60 93 8c 00 	sts	0x008C, r22	; 0x80008c <__TEXT_REGION_LENGTH__+0x70008c>
     f70:	ff 90       	pop	r15
     f72:	ef 90       	pop	r14
     f74:	df 90       	pop	r13
     f76:	cf 90       	pop	r12
     f78:	08 95       	ret

00000f7a <_ZN6Timer5C1Ev>:
#include <avr/io.h>

Timer5::Timer5()
{
	// Set all needed ports to outputs
	ROBOTARM_M4_OUT_PORT |= ( 1 << ROBOTARM_M4_OUT_PIN );
     f7a:	ea e0       	ldi	r30, 0x0A	; 10
     f7c:	f1 e0       	ldi	r31, 0x01	; 1
     f7e:	80 81       	ld	r24, Z
     f80:	88 60       	ori	r24, 0x08	; 8
     f82:	80 83       	st	Z, r24
	ROBOTARM_M5_OUT_PORT |= ( 1 << ROBOTARM_M5_OUT_PIN );
     f84:	80 81       	ld	r24, Z
     f86:	80 61       	ori	r24, 0x10	; 16
     f88:	80 83       	st	Z, r24
	ROBOTARM_M6_OUT_PORT |= ( 1 << ROBOTARM_M6_OUT_PIN );
     f8a:	80 81       	ld	r24, Z
     f8c:	80 62       	ori	r24, 0x20	; 32
     f8e:	80 83       	st	Z, r24
	
	// Set timer to run in PWM, Phase Correct mode with 50 Hz freq.
	TCCR5A = ( 1 << COM3A1 ) | ( 1 << COM3B1 ) | ( 1 << COM3C1 ) | ( 0 << WGM30 ) | ( 0 << WGM31 );
     f90:	88 ea       	ldi	r24, 0xA8	; 168
     f92:	80 93 20 01 	sts	0x0120, r24	; 0x800120 <__TEXT_REGION_LENGTH__+0x700120>
	TCCR5B = ( 1 << WGM33 ) | ( 0 << CS30 )  | ( 1 << CS32 );
     f96:	84 e1       	ldi	r24, 0x14	; 20
     f98:	80 93 21 01 	sts	0x0121, r24	; 0x800121 <__TEXT_REGION_LENGTH__+0x700121>
	TCCR5C = 0;
     f9c:	10 92 22 01 	sts	0x0122, r1	; 0x800122 <__TEXT_REGION_LENGTH__+0x700122>
	ICR5 = 622;
     fa0:	8e e6       	ldi	r24, 0x6E	; 110
     fa2:	92 e0       	ldi	r25, 0x02	; 2
     fa4:	90 93 27 01 	sts	0x0127, r25	; 0x800127 <__TEXT_REGION_LENGTH__+0x700127>
     fa8:	80 93 26 01 	sts	0x0126, r24	; 0x800126 <__TEXT_REGION_LENGTH__+0x700126>
	
	OCR5A = 0;
     fac:	10 92 29 01 	sts	0x0129, r1	; 0x800129 <__TEXT_REGION_LENGTH__+0x700129>
     fb0:	10 92 28 01 	sts	0x0128, r1	; 0x800128 <__TEXT_REGION_LENGTH__+0x700128>
	OCR5B = 0;
     fb4:	10 92 2b 01 	sts	0x012B, r1	; 0x80012b <__TEXT_REGION_LENGTH__+0x70012b>
     fb8:	10 92 2a 01 	sts	0x012A, r1	; 0x80012a <__TEXT_REGION_LENGTH__+0x70012a>
	OCR5C = 0;
     fbc:	10 92 2d 01 	sts	0x012D, r1	; 0x80012d <__TEXT_REGION_LENGTH__+0x70012d>
     fc0:	10 92 2c 01 	sts	0x012C, r1	; 0x80012c <__TEXT_REGION_LENGTH__+0x70012c>
     fc4:	08 95       	ret

00000fc6 <_ZN6Timer516setDutyCycleComAEf>:
}

void Timer5::setDutyCycleComA( float dutyCycle )
{
     fc6:	cf 92       	push	r12
     fc8:	df 92       	push	r13
     fca:	ef 92       	push	r14
     fcc:	ff 92       	push	r15
     fce:	6a 01       	movw	r12, r20
     fd0:	7b 01       	movw	r14, r22
	float percent = ICR5/100;
     fd2:	20 91 26 01 	lds	r18, 0x0126	; 0x800126 <__TEXT_REGION_LENGTH__+0x700126>
     fd6:	30 91 27 01 	lds	r19, 0x0127	; 0x800127 <__TEXT_REGION_LENGTH__+0x700127>
     fda:	36 95       	lsr	r19
     fdc:	27 95       	ror	r18
     fde:	36 95       	lsr	r19
     fe0:	27 95       	ror	r18
     fe2:	ab e7       	ldi	r26, 0x7B	; 123
     fe4:	b4 e1       	ldi	r27, 0x14	; 20
     fe6:	0e 94 f1 10 	call	0x21e2	; 0x21e2 <__umulhisi3>
     fea:	96 95       	lsr	r25
     fec:	87 95       	ror	r24
	OCR5A = (uint8_t)percent*dutyCycle;
     fee:	bc 01       	movw	r22, r24
     ff0:	77 27       	eor	r23, r23
     ff2:	07 2e       	mov	r0, r23
     ff4:	00 0c       	add	r0, r0
     ff6:	88 0b       	sbc	r24, r24
     ff8:	99 0b       	sbc	r25, r25
     ffa:	d4 d7       	rcall	.+4008   	; 0x1fa4 <__floatsisf>
     ffc:	a7 01       	movw	r20, r14
     ffe:	96 01       	movw	r18, r12
    1000:	0e 94 86 10 	call	0x210c	; 0x210c <__mulsf3>
    1004:	a1 d7       	rcall	.+3906   	; 0x1f48 <__fixunssfsi>
    1006:	70 93 29 01 	sts	0x0129, r23	; 0x800129 <__TEXT_REGION_LENGTH__+0x700129>
    100a:	60 93 28 01 	sts	0x0128, r22	; 0x800128 <__TEXT_REGION_LENGTH__+0x700128>
}
    100e:	ff 90       	pop	r15
    1010:	ef 90       	pop	r14
    1012:	df 90       	pop	r13
    1014:	cf 90       	pop	r12
    1016:	08 95       	ret

00001018 <_ZN6Timer516setDutyCycleComBEf>:

void Timer5::setDutyCycleComB( float dutyCycle )
{
    1018:	cf 92       	push	r12
    101a:	df 92       	push	r13
    101c:	ef 92       	push	r14
    101e:	ff 92       	push	r15
    1020:	6a 01       	movw	r12, r20
    1022:	7b 01       	movw	r14, r22
	float percent = ICR5/100;
    1024:	20 91 26 01 	lds	r18, 0x0126	; 0x800126 <__TEXT_REGION_LENGTH__+0x700126>
    1028:	30 91 27 01 	lds	r19, 0x0127	; 0x800127 <__TEXT_REGION_LENGTH__+0x700127>
    102c:	36 95       	lsr	r19
    102e:	27 95       	ror	r18
    1030:	36 95       	lsr	r19
    1032:	27 95       	ror	r18
    1034:	ab e7       	ldi	r26, 0x7B	; 123
    1036:	b4 e1       	ldi	r27, 0x14	; 20
    1038:	0e 94 f1 10 	call	0x21e2	; 0x21e2 <__umulhisi3>
    103c:	96 95       	lsr	r25
    103e:	87 95       	ror	r24
	OCR5B = (uint8_t)percent*dutyCycle;
    1040:	bc 01       	movw	r22, r24
    1042:	77 27       	eor	r23, r23
    1044:	07 2e       	mov	r0, r23
    1046:	00 0c       	add	r0, r0
    1048:	88 0b       	sbc	r24, r24
    104a:	99 0b       	sbc	r25, r25
    104c:	ab d7       	rcall	.+3926   	; 0x1fa4 <__floatsisf>
    104e:	a7 01       	movw	r20, r14
    1050:	96 01       	movw	r18, r12
    1052:	0e 94 86 10 	call	0x210c	; 0x210c <__mulsf3>
    1056:	78 d7       	rcall	.+3824   	; 0x1f48 <__fixunssfsi>
    1058:	70 93 2b 01 	sts	0x012B, r23	; 0x80012b <__TEXT_REGION_LENGTH__+0x70012b>
    105c:	60 93 2a 01 	sts	0x012A, r22	; 0x80012a <__TEXT_REGION_LENGTH__+0x70012a>
}
    1060:	ff 90       	pop	r15
    1062:	ef 90       	pop	r14
    1064:	df 90       	pop	r13
    1066:	cf 90       	pop	r12
    1068:	08 95       	ret

0000106a <_ZN6Timer516setDutyCycleComCEf>:

void Timer5::setDutyCycleComC( float dutyCycle )
{
    106a:	cf 92       	push	r12
    106c:	df 92       	push	r13
    106e:	ef 92       	push	r14
    1070:	ff 92       	push	r15
    1072:	6a 01       	movw	r12, r20
    1074:	7b 01       	movw	r14, r22
	float percent = ICR5/100;
    1076:	20 91 26 01 	lds	r18, 0x0126	; 0x800126 <__TEXT_REGION_LENGTH__+0x700126>
    107a:	30 91 27 01 	lds	r19, 0x0127	; 0x800127 <__TEXT_REGION_LENGTH__+0x700127>
    107e:	36 95       	lsr	r19
    1080:	27 95       	ror	r18
    1082:	36 95       	lsr	r19
    1084:	27 95       	ror	r18
    1086:	ab e7       	ldi	r26, 0x7B	; 123
    1088:	b4 e1       	ldi	r27, 0x14	; 20
    108a:	0e 94 f1 10 	call	0x21e2	; 0x21e2 <__umulhisi3>
    108e:	96 95       	lsr	r25
    1090:	87 95       	ror	r24
	OCR5C = (uint8_t)percent*dutyCycle;
    1092:	bc 01       	movw	r22, r24
    1094:	77 27       	eor	r23, r23
    1096:	07 2e       	mov	r0, r23
    1098:	00 0c       	add	r0, r0
    109a:	88 0b       	sbc	r24, r24
    109c:	99 0b       	sbc	r25, r25
    109e:	82 d7       	rcall	.+3844   	; 0x1fa4 <__floatsisf>
    10a0:	a7 01       	movw	r20, r14
    10a2:	96 01       	movw	r18, r12
    10a4:	0e 94 86 10 	call	0x210c	; 0x210c <__mulsf3>
    10a8:	4f d7       	rcall	.+3742   	; 0x1f48 <__fixunssfsi>
    10aa:	70 93 2d 01 	sts	0x012D, r23	; 0x80012d <__TEXT_REGION_LENGTH__+0x70012d>
    10ae:	60 93 2c 01 	sts	0x012C, r22	; 0x80012c <__TEXT_REGION_LENGTH__+0x70012c>
    10b2:	ff 90       	pop	r15
    10b4:	ef 90       	pop	r14
    10b6:	df 90       	pop	r13
    10b8:	cf 90       	pop	r12
    10ba:	08 95       	ret

000010bc <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
    10bc:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
    10be:	03 96       	adiw	r24, 0x03	; 3
    10c0:	92 83       	std	Z+2, r25	; 0x02
    10c2:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    10c4:	2f ef       	ldi	r18, 0xFF	; 255
    10c6:	3f ef       	ldi	r19, 0xFF	; 255
    10c8:	34 83       	std	Z+4, r19	; 0x04
    10ca:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
    10cc:	96 83       	std	Z+6, r25	; 0x06
    10ce:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
    10d0:	90 87       	std	Z+8, r25	; 0x08
    10d2:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
    10d4:	10 82       	st	Z, r1
    10d6:	08 95       	ret

000010d8 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    10d8:	fc 01       	movw	r30, r24
    10da:	11 86       	std	Z+9, r1	; 0x09
    10dc:	10 86       	std	Z+8, r1	; 0x08
    10de:	08 95       	ret

000010e0 <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
    10e0:	cf 93       	push	r28
    10e2:	df 93       	push	r29
    10e4:	fc 01       	movw	r30, r24
    10e6:	db 01       	movw	r26, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
    10e8:	21 81       	ldd	r18, Z+1	; 0x01
    10ea:	32 81       	ldd	r19, Z+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
    10ec:	e9 01       	movw	r28, r18
    10ee:	8a 81       	ldd	r24, Y+2	; 0x02
    10f0:	9b 81       	ldd	r25, Y+3	; 0x03
    10f2:	13 96       	adiw	r26, 0x03	; 3
    10f4:	9c 93       	st	X, r25
    10f6:	8e 93       	st	-X, r24
    10f8:	12 97       	sbiw	r26, 0x02	; 2
	pxNewListItem->pxPrevious = pxList->pxIndex;
    10fa:	81 81       	ldd	r24, Z+1	; 0x01
    10fc:	92 81       	ldd	r25, Z+2	; 0x02
    10fe:	15 96       	adiw	r26, 0x05	; 5
    1100:	9c 93       	st	X, r25
    1102:	8e 93       	st	-X, r24
    1104:	14 97       	sbiw	r26, 0x04	; 4
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    1106:	8a 81       	ldd	r24, Y+2	; 0x02
    1108:	9b 81       	ldd	r25, Y+3	; 0x03
    110a:	ec 01       	movw	r28, r24
    110c:	7d 83       	std	Y+5, r23	; 0x05
    110e:	6c 83       	std	Y+4, r22	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
    1110:	e9 01       	movw	r28, r18
    1112:	7b 83       	std	Y+3, r23	; 0x03
    1114:	6a 83       	std	Y+2, r22	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
    1116:	72 83       	std	Z+2, r23	; 0x02
    1118:	61 83       	std	Z+1, r22	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    111a:	19 96       	adiw	r26, 0x09	; 9
    111c:	fc 93       	st	X, r31
    111e:	ee 93       	st	-X, r30
    1120:	18 97       	sbiw	r26, 0x08	; 8

	( pxList->uxNumberOfItems )++;
    1122:	80 81       	ld	r24, Z
    1124:	8f 5f       	subi	r24, 0xFF	; 255
    1126:	80 83       	st	Z, r24
}
    1128:	df 91       	pop	r29
    112a:	cf 91       	pop	r28
    112c:	08 95       	ret

0000112e <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
    112e:	cf 93       	push	r28
    1130:	df 93       	push	r29
    1132:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
    1134:	48 81       	ld	r20, Y
    1136:	59 81       	ldd	r21, Y+1	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    1138:	4f 3f       	cpi	r20, 0xFF	; 255
    113a:	2f ef       	ldi	r18, 0xFF	; 255
    113c:	52 07       	cpc	r21, r18
    113e:	31 f4       	brne	.+12     	; 0x114c <vListInsert+0x1e>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    1140:	dc 01       	movw	r26, r24
    1142:	17 96       	adiw	r26, 0x07	; 7
    1144:	ed 91       	ld	r30, X+
    1146:	fc 91       	ld	r31, X
    1148:	18 97       	sbiw	r26, 0x08	; 8
    114a:	0d c0       	rjmp	.+26     	; 0x1166 <vListInsert+0x38>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    114c:	fc 01       	movw	r30, r24
    114e:	33 96       	adiw	r30, 0x03	; 3
    1150:	03 c0       	rjmp	.+6      	; 0x1158 <vListInsert+0x2a>
    1152:	02 80       	ldd	r0, Z+2	; 0x02
    1154:	f3 81       	ldd	r31, Z+3	; 0x03
    1156:	e0 2d       	mov	r30, r0
    1158:	a2 81       	ldd	r26, Z+2	; 0x02
    115a:	b3 81       	ldd	r27, Z+3	; 0x03
    115c:	2d 91       	ld	r18, X+
    115e:	3c 91       	ld	r19, X
    1160:	42 17       	cp	r20, r18
    1162:	53 07       	cpc	r21, r19
    1164:	b0 f7       	brcc	.-20     	; 0x1152 <vListInsert+0x24>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    1166:	a2 81       	ldd	r26, Z+2	; 0x02
    1168:	b3 81       	ldd	r27, Z+3	; 0x03
    116a:	bb 83       	std	Y+3, r27	; 0x03
    116c:	aa 83       	std	Y+2, r26	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    116e:	15 96       	adiw	r26, 0x05	; 5
    1170:	dc 93       	st	X, r29
    1172:	ce 93       	st	-X, r28
    1174:	14 97       	sbiw	r26, 0x04	; 4
	pxNewListItem->pxPrevious = pxIterator;
    1176:	fd 83       	std	Y+5, r31	; 0x05
    1178:	ec 83       	std	Y+4, r30	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    117a:	d3 83       	std	Z+3, r29	; 0x03
    117c:	c2 83       	std	Z+2, r28	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    117e:	99 87       	std	Y+9, r25	; 0x09
    1180:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    1182:	fc 01       	movw	r30, r24
    1184:	20 81       	ld	r18, Z
    1186:	2f 5f       	subi	r18, 0xFF	; 255
    1188:	20 83       	st	Z, r18
}
    118a:	df 91       	pop	r29
    118c:	cf 91       	pop	r28
    118e:	08 95       	ret

00001190 <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
    1190:	fc 01       	movw	r30, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    1192:	a2 81       	ldd	r26, Z+2	; 0x02
    1194:	b3 81       	ldd	r27, Z+3	; 0x03
    1196:	84 81       	ldd	r24, Z+4	; 0x04
    1198:	95 81       	ldd	r25, Z+5	; 0x05
    119a:	15 96       	adiw	r26, 0x05	; 5
    119c:	9c 93       	st	X, r25
    119e:	8e 93       	st	-X, r24
    11a0:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    11a2:	a4 81       	ldd	r26, Z+4	; 0x04
    11a4:	b5 81       	ldd	r27, Z+5	; 0x05
    11a6:	82 81       	ldd	r24, Z+2	; 0x02
    11a8:	93 81       	ldd	r25, Z+3	; 0x03
    11aa:	13 96       	adiw	r26, 0x03	; 3
    11ac:	9c 93       	st	X, r25
    11ae:	8e 93       	st	-X, r24
    11b0:	12 97       	sbiw	r26, 0x02	; 2
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    11b2:	a0 85       	ldd	r26, Z+8	; 0x08
    11b4:	b1 85       	ldd	r27, Z+9	; 0x09

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    11b6:	11 96       	adiw	r26, 0x01	; 1
    11b8:	8d 91       	ld	r24, X+
    11ba:	9c 91       	ld	r25, X
    11bc:	12 97       	sbiw	r26, 0x02	; 2
    11be:	e8 17       	cp	r30, r24
    11c0:	f9 07       	cpc	r31, r25
    11c2:	31 f4       	brne	.+12     	; 0x11d0 <vListRemove+0x40>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    11c4:	84 81       	ldd	r24, Z+4	; 0x04
    11c6:	95 81       	ldd	r25, Z+5	; 0x05
    11c8:	12 96       	adiw	r26, 0x02	; 2
    11ca:	9c 93       	st	X, r25
    11cc:	8e 93       	st	-X, r24
    11ce:	11 97       	sbiw	r26, 0x01	; 1
	}

	pxItemToRemove->pvContainer = NULL;
    11d0:	11 86       	std	Z+9, r1	; 0x09
    11d2:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    11d4:	8c 91       	ld	r24, X
    11d6:	81 50       	subi	r24, 0x01	; 1
    11d8:	8c 93       	st	X, r24
    11da:	08 95       	ret

000011dc <prvSetupTimerInterrupt>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    11dc:	8a ef       	ldi	r24, 0xFA	; 250
    11de:	87 bd       	out	0x27, r24	; 39
    11e0:	82 e0       	ldi	r24, 0x02	; 2
    11e2:	84 bd       	out	0x24, r24	; 36
    11e4:	93 e0       	ldi	r25, 0x03	; 3
    11e6:	95 bd       	out	0x25, r25	; 37
    11e8:	80 93 6e 00 	sts	0x006E, r24	; 0x80006e <__TEXT_REGION_LENGTH__+0x70006e>
    11ec:	08 95       	ret

000011ee <pxPortInitialiseStack>:
    11ee:	31 e1       	ldi	r19, 0x11	; 17
    11f0:	fc 01       	movw	r30, r24
    11f2:	30 83       	st	Z, r19
    11f4:	31 97       	sbiw	r30, 0x01	; 1
    11f6:	22 e2       	ldi	r18, 0x22	; 34
    11f8:	20 83       	st	Z, r18
    11fa:	31 97       	sbiw	r30, 0x01	; 1
    11fc:	a3 e3       	ldi	r26, 0x33	; 51
    11fe:	a0 83       	st	Z, r26
    1200:	31 97       	sbiw	r30, 0x01	; 1
    1202:	60 83       	st	Z, r22
    1204:	31 97       	sbiw	r30, 0x01	; 1
    1206:	70 83       	st	Z, r23
    1208:	31 97       	sbiw	r30, 0x01	; 1
    120a:	10 82       	st	Z, r1
    120c:	31 97       	sbiw	r30, 0x01	; 1
    120e:	10 82       	st	Z, r1
    1210:	31 97       	sbiw	r30, 0x01	; 1
    1212:	60 e8       	ldi	r22, 0x80	; 128
    1214:	60 83       	st	Z, r22
    1216:	31 97       	sbiw	r30, 0x01	; 1
    1218:	10 82       	st	Z, r1
    121a:	31 97       	sbiw	r30, 0x01	; 1
    121c:	10 82       	st	Z, r1
    121e:	31 97       	sbiw	r30, 0x01	; 1
    1220:	10 82       	st	Z, r1
    1222:	31 97       	sbiw	r30, 0x01	; 1
    1224:	62 e0       	ldi	r22, 0x02	; 2
    1226:	60 83       	st	Z, r22
    1228:	31 97       	sbiw	r30, 0x01	; 1
    122a:	63 e0       	ldi	r22, 0x03	; 3
    122c:	60 83       	st	Z, r22
    122e:	31 97       	sbiw	r30, 0x01	; 1
    1230:	64 e0       	ldi	r22, 0x04	; 4
    1232:	60 83       	st	Z, r22
    1234:	31 97       	sbiw	r30, 0x01	; 1
    1236:	65 e0       	ldi	r22, 0x05	; 5
    1238:	60 83       	st	Z, r22
    123a:	31 97       	sbiw	r30, 0x01	; 1
    123c:	66 e0       	ldi	r22, 0x06	; 6
    123e:	60 83       	st	Z, r22
    1240:	31 97       	sbiw	r30, 0x01	; 1
    1242:	67 e0       	ldi	r22, 0x07	; 7
    1244:	60 83       	st	Z, r22
    1246:	31 97       	sbiw	r30, 0x01	; 1
    1248:	68 e0       	ldi	r22, 0x08	; 8
    124a:	60 83       	st	Z, r22
    124c:	31 97       	sbiw	r30, 0x01	; 1
    124e:	69 e0       	ldi	r22, 0x09	; 9
    1250:	60 83       	st	Z, r22
    1252:	31 97       	sbiw	r30, 0x01	; 1
    1254:	60 e1       	ldi	r22, 0x10	; 16
    1256:	60 83       	st	Z, r22
    1258:	31 97       	sbiw	r30, 0x01	; 1
    125a:	30 83       	st	Z, r19
    125c:	31 97       	sbiw	r30, 0x01	; 1
    125e:	32 e1       	ldi	r19, 0x12	; 18
    1260:	30 83       	st	Z, r19
    1262:	31 97       	sbiw	r30, 0x01	; 1
    1264:	33 e1       	ldi	r19, 0x13	; 19
    1266:	30 83       	st	Z, r19
    1268:	31 97       	sbiw	r30, 0x01	; 1
    126a:	34 e1       	ldi	r19, 0x14	; 20
    126c:	30 83       	st	Z, r19
    126e:	31 97       	sbiw	r30, 0x01	; 1
    1270:	35 e1       	ldi	r19, 0x15	; 21
    1272:	30 83       	st	Z, r19
    1274:	31 97       	sbiw	r30, 0x01	; 1
    1276:	36 e1       	ldi	r19, 0x16	; 22
    1278:	30 83       	st	Z, r19
    127a:	31 97       	sbiw	r30, 0x01	; 1
    127c:	37 e1       	ldi	r19, 0x17	; 23
    127e:	30 83       	st	Z, r19
    1280:	31 97       	sbiw	r30, 0x01	; 1
    1282:	38 e1       	ldi	r19, 0x18	; 24
    1284:	30 83       	st	Z, r19
    1286:	31 97       	sbiw	r30, 0x01	; 1
    1288:	39 e1       	ldi	r19, 0x19	; 25
    128a:	30 83       	st	Z, r19
    128c:	31 97       	sbiw	r30, 0x01	; 1
    128e:	30 e2       	ldi	r19, 0x20	; 32
    1290:	30 83       	st	Z, r19
    1292:	31 97       	sbiw	r30, 0x01	; 1
    1294:	31 e2       	ldi	r19, 0x21	; 33
    1296:	30 83       	st	Z, r19
    1298:	31 97       	sbiw	r30, 0x01	; 1
    129a:	20 83       	st	Z, r18
    129c:	31 97       	sbiw	r30, 0x01	; 1
    129e:	23 e2       	ldi	r18, 0x23	; 35
    12a0:	20 83       	st	Z, r18
    12a2:	31 97       	sbiw	r30, 0x01	; 1
    12a4:	40 83       	st	Z, r20
    12a6:	31 97       	sbiw	r30, 0x01	; 1
    12a8:	50 83       	st	Z, r21
    12aa:	31 97       	sbiw	r30, 0x01	; 1
    12ac:	26 e2       	ldi	r18, 0x26	; 38
    12ae:	20 83       	st	Z, r18
    12b0:	31 97       	sbiw	r30, 0x01	; 1
    12b2:	27 e2       	ldi	r18, 0x27	; 39
    12b4:	20 83       	st	Z, r18
    12b6:	31 97       	sbiw	r30, 0x01	; 1
    12b8:	28 e2       	ldi	r18, 0x28	; 40
    12ba:	20 83       	st	Z, r18
    12bc:	31 97       	sbiw	r30, 0x01	; 1
    12be:	29 e2       	ldi	r18, 0x29	; 41
    12c0:	20 83       	st	Z, r18
    12c2:	31 97       	sbiw	r30, 0x01	; 1
    12c4:	20 e3       	ldi	r18, 0x30	; 48
    12c6:	20 83       	st	Z, r18
    12c8:	31 97       	sbiw	r30, 0x01	; 1
    12ca:	21 e3       	ldi	r18, 0x31	; 49
    12cc:	20 83       	st	Z, r18
    12ce:	89 97       	sbiw	r24, 0x29	; 41
    12d0:	08 95       	ret

000012d2 <xPortStartScheduler>:
    12d2:	84 df       	rcall	.-248    	; 0x11dc <prvSetupTimerInterrupt>
    12d4:	a0 91 0c 09 	lds	r26, 0x090C	; 0x80090c <pxCurrentTCB>
    12d8:	b0 91 0d 09 	lds	r27, 0x090D	; 0x80090d <pxCurrentTCB+0x1>
    12dc:	cd 91       	ld	r28, X+
    12de:	cd bf       	out	0x3d, r28	; 61
    12e0:	dd 91       	ld	r29, X+
    12e2:	de bf       	out	0x3e, r29	; 62
    12e4:	ff 91       	pop	r31
    12e6:	ef 91       	pop	r30
    12e8:	df 91       	pop	r29
    12ea:	cf 91       	pop	r28
    12ec:	bf 91       	pop	r27
    12ee:	af 91       	pop	r26
    12f0:	9f 91       	pop	r25
    12f2:	8f 91       	pop	r24
    12f4:	7f 91       	pop	r23
    12f6:	6f 91       	pop	r22
    12f8:	5f 91       	pop	r21
    12fa:	4f 91       	pop	r20
    12fc:	3f 91       	pop	r19
    12fe:	2f 91       	pop	r18
    1300:	1f 91       	pop	r17
    1302:	0f 91       	pop	r16
    1304:	ff 90       	pop	r15
    1306:	ef 90       	pop	r14
    1308:	df 90       	pop	r13
    130a:	cf 90       	pop	r12
    130c:	bf 90       	pop	r11
    130e:	af 90       	pop	r10
    1310:	9f 90       	pop	r9
    1312:	8f 90       	pop	r8
    1314:	7f 90       	pop	r7
    1316:	6f 90       	pop	r6
    1318:	5f 90       	pop	r5
    131a:	4f 90       	pop	r4
    131c:	3f 90       	pop	r3
    131e:	2f 90       	pop	r2
    1320:	1f 90       	pop	r1
    1322:	0f 90       	pop	r0
    1324:	0c be       	out	0x3c, r0	; 60
    1326:	0f 90       	pop	r0
    1328:	0b be       	out	0x3b, r0	; 59
    132a:	0f 90       	pop	r0
    132c:	0f be       	out	0x3f, r0	; 63
    132e:	0f 90       	pop	r0
    1330:	08 95       	ret
    1332:	81 e0       	ldi	r24, 0x01	; 1
    1334:	08 95       	ret

00001336 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    1336:	0f 92       	push	r0
    1338:	0f b6       	in	r0, 0x3f	; 63
    133a:	f8 94       	cli
    133c:	0f 92       	push	r0
    133e:	0b b6       	in	r0, 0x3b	; 59
    1340:	0f 92       	push	r0
    1342:	0c b6       	in	r0, 0x3c	; 60
    1344:	0f 92       	push	r0
    1346:	1f 92       	push	r1
    1348:	11 24       	eor	r1, r1
    134a:	2f 92       	push	r2
    134c:	3f 92       	push	r3
    134e:	4f 92       	push	r4
    1350:	5f 92       	push	r5
    1352:	6f 92       	push	r6
    1354:	7f 92       	push	r7
    1356:	8f 92       	push	r8
    1358:	9f 92       	push	r9
    135a:	af 92       	push	r10
    135c:	bf 92       	push	r11
    135e:	cf 92       	push	r12
    1360:	df 92       	push	r13
    1362:	ef 92       	push	r14
    1364:	ff 92       	push	r15
    1366:	0f 93       	push	r16
    1368:	1f 93       	push	r17
    136a:	2f 93       	push	r18
    136c:	3f 93       	push	r19
    136e:	4f 93       	push	r20
    1370:	5f 93       	push	r21
    1372:	6f 93       	push	r22
    1374:	7f 93       	push	r23
    1376:	8f 93       	push	r24
    1378:	9f 93       	push	r25
    137a:	af 93       	push	r26
    137c:	bf 93       	push	r27
    137e:	cf 93       	push	r28
    1380:	df 93       	push	r29
    1382:	ef 93       	push	r30
    1384:	ff 93       	push	r31
    1386:	a0 91 0c 09 	lds	r26, 0x090C	; 0x80090c <pxCurrentTCB>
    138a:	b0 91 0d 09 	lds	r27, 0x090D	; 0x80090d <pxCurrentTCB+0x1>
    138e:	0d b6       	in	r0, 0x3d	; 61
    1390:	0d 92       	st	X+, r0
    1392:	0e b6       	in	r0, 0x3e	; 62
    1394:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    1396:	84 d3       	rcall	.+1800   	; 0x1aa0 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1398:	a0 91 0c 09 	lds	r26, 0x090C	; 0x80090c <pxCurrentTCB>
    139c:	b0 91 0d 09 	lds	r27, 0x090D	; 0x80090d <pxCurrentTCB+0x1>
    13a0:	cd 91       	ld	r28, X+
    13a2:	cd bf       	out	0x3d, r28	; 61
    13a4:	dd 91       	ld	r29, X+
    13a6:	de bf       	out	0x3e, r29	; 62
    13a8:	ff 91       	pop	r31
    13aa:	ef 91       	pop	r30
    13ac:	df 91       	pop	r29
    13ae:	cf 91       	pop	r28
    13b0:	bf 91       	pop	r27
    13b2:	af 91       	pop	r26
    13b4:	9f 91       	pop	r25
    13b6:	8f 91       	pop	r24
    13b8:	7f 91       	pop	r23
    13ba:	6f 91       	pop	r22
    13bc:	5f 91       	pop	r21
    13be:	4f 91       	pop	r20
    13c0:	3f 91       	pop	r19
    13c2:	2f 91       	pop	r18
    13c4:	1f 91       	pop	r17
    13c6:	0f 91       	pop	r16
    13c8:	ff 90       	pop	r15
    13ca:	ef 90       	pop	r14
    13cc:	df 90       	pop	r13
    13ce:	cf 90       	pop	r12
    13d0:	bf 90       	pop	r11
    13d2:	af 90       	pop	r10
    13d4:	9f 90       	pop	r9
    13d6:	8f 90       	pop	r8
    13d8:	7f 90       	pop	r7
    13da:	6f 90       	pop	r6
    13dc:	5f 90       	pop	r5
    13de:	4f 90       	pop	r4
    13e0:	3f 90       	pop	r3
    13e2:	2f 90       	pop	r2
    13e4:	1f 90       	pop	r1
    13e6:	0f 90       	pop	r0
    13e8:	0c be       	out	0x3c, r0	; 60
    13ea:	0f 90       	pop	r0
    13ec:	0b be       	out	0x3b, r0	; 59
    13ee:	0f 90       	pop	r0
    13f0:	0f be       	out	0x3f, r0	; 63
    13f2:	0f 90       	pop	r0

	asm volatile ( "ret" );
    13f4:	08 95       	ret

000013f6 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    13f6:	0f 92       	push	r0
    13f8:	0f b6       	in	r0, 0x3f	; 63
    13fa:	f8 94       	cli
    13fc:	0f 92       	push	r0
    13fe:	0b b6       	in	r0, 0x3b	; 59
    1400:	0f 92       	push	r0
    1402:	0c b6       	in	r0, 0x3c	; 60
    1404:	0f 92       	push	r0
    1406:	1f 92       	push	r1
    1408:	11 24       	eor	r1, r1
    140a:	2f 92       	push	r2
    140c:	3f 92       	push	r3
    140e:	4f 92       	push	r4
    1410:	5f 92       	push	r5
    1412:	6f 92       	push	r6
    1414:	7f 92       	push	r7
    1416:	8f 92       	push	r8
    1418:	9f 92       	push	r9
    141a:	af 92       	push	r10
    141c:	bf 92       	push	r11
    141e:	cf 92       	push	r12
    1420:	df 92       	push	r13
    1422:	ef 92       	push	r14
    1424:	ff 92       	push	r15
    1426:	0f 93       	push	r16
    1428:	1f 93       	push	r17
    142a:	2f 93       	push	r18
    142c:	3f 93       	push	r19
    142e:	4f 93       	push	r20
    1430:	5f 93       	push	r21
    1432:	6f 93       	push	r22
    1434:	7f 93       	push	r23
    1436:	8f 93       	push	r24
    1438:	9f 93       	push	r25
    143a:	af 93       	push	r26
    143c:	bf 93       	push	r27
    143e:	cf 93       	push	r28
    1440:	df 93       	push	r29
    1442:	ef 93       	push	r30
    1444:	ff 93       	push	r31
    1446:	a0 91 0c 09 	lds	r26, 0x090C	; 0x80090c <pxCurrentTCB>
    144a:	b0 91 0d 09 	lds	r27, 0x090D	; 0x80090d <pxCurrentTCB+0x1>
    144e:	0d b6       	in	r0, 0x3d	; 61
    1450:	0d 92       	st	X+, r0
    1452:	0e b6       	in	r0, 0x3e	; 62
    1454:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    1456:	ef d1       	rcall	.+990    	; 0x1836 <vTaskIncrementTick>
	vTaskSwitchContext();
    1458:	23 d3       	rcall	.+1606   	; 0x1aa0 <vTaskSwitchContext>
    145a:	a0 91 0c 09 	lds	r26, 0x090C	; 0x80090c <pxCurrentTCB>
	portRESTORE_CONTEXT();
    145e:	b0 91 0d 09 	lds	r27, 0x090D	; 0x80090d <pxCurrentTCB+0x1>
    1462:	cd 91       	ld	r28, X+
    1464:	cd bf       	out	0x3d, r28	; 61
    1466:	dd 91       	ld	r29, X+
    1468:	de bf       	out	0x3e, r29	; 62
    146a:	ff 91       	pop	r31
    146c:	ef 91       	pop	r30
    146e:	df 91       	pop	r29
    1470:	cf 91       	pop	r28
    1472:	bf 91       	pop	r27
    1474:	af 91       	pop	r26
    1476:	9f 91       	pop	r25
    1478:	8f 91       	pop	r24
    147a:	7f 91       	pop	r23
    147c:	6f 91       	pop	r22
    147e:	5f 91       	pop	r21
    1480:	4f 91       	pop	r20
    1482:	3f 91       	pop	r19
    1484:	2f 91       	pop	r18
    1486:	1f 91       	pop	r17
    1488:	0f 91       	pop	r16
    148a:	ff 90       	pop	r15
    148c:	ef 90       	pop	r14
    148e:	df 90       	pop	r13
    1490:	cf 90       	pop	r12
    1492:	bf 90       	pop	r11
    1494:	af 90       	pop	r10
    1496:	9f 90       	pop	r9
    1498:	8f 90       	pop	r8
    149a:	7f 90       	pop	r7
    149c:	6f 90       	pop	r6
    149e:	5f 90       	pop	r5
    14a0:	4f 90       	pop	r4
    14a2:	3f 90       	pop	r3
    14a4:	2f 90       	pop	r2
    14a6:	1f 90       	pop	r1
    14a8:	0f 90       	pop	r0
    14aa:	0c be       	out	0x3c, r0	; 60
    14ac:	0f 90       	pop	r0
    14ae:	0b be       	out	0x3b, r0	; 59
    14b0:	0f 90       	pop	r0
    14b2:	0f be       	out	0x3f, r0	; 63
    14b4:	0f 90       	pop	r0
    14b6:	08 95       	ret

000014b8 <__vector_21>:
	asm volatile ( "ret" );
    14b8:	9e df       	rcall	.-196    	; 0x13f6 <vPortYieldFromTick>
//	void SIG_OUTPUT_COMPARE1A( void )
	void TIMER0_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER0_COMPA_vect( void )
	{
		vPortYieldFromTick();
		asm volatile ( "reti" );
    14ba:	18 95       	reti

000014bc <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    14bc:	cf 93       	push	r28
    14be:	df 93       	push	r29
    14c0:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
    14c2:	b3 d1       	rcall	.+870    	; 0x182a <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
    14c4:	20 91 fb 02 	lds	r18, 0x02FB	; 0x8002fb <xNextFreeByte>
    14c8:	30 91 fc 02 	lds	r19, 0x02FC	; 0x8002fc <xNextFreeByte+0x1>
    14cc:	c9 01       	movw	r24, r18
    14ce:	8c 0f       	add	r24, r28
    14d0:	9d 1f       	adc	r25, r29
    14d2:	8c 3d       	cpi	r24, 0xDC	; 220
    14d4:	45 e0       	ldi	r20, 0x05	; 5
    14d6:	94 07       	cpc	r25, r20
    14d8:	58 f4       	brcc	.+22     	; 0x14f0 <pvPortMalloc+0x34>
    14da:	28 17       	cp	r18, r24
    14dc:	39 07       	cpc	r19, r25
    14de:	58 f4       	brcc	.+22     	; 0x14f6 <pvPortMalloc+0x3a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
    14e0:	e9 01       	movw	r28, r18
    14e2:	c3 50       	subi	r28, 0x03	; 3
    14e4:	dd 4f       	sbci	r29, 0xFD	; 253
			xNextFreeByte += xWantedSize;			
    14e6:	90 93 fc 02 	sts	0x02FC, r25	; 0x8002fc <xNextFreeByte+0x1>
    14ea:	80 93 fb 02 	sts	0x02FB, r24	; 0x8002fb <xNextFreeByte>
    14ee:	05 c0       	rjmp	.+10     	; 0x14fa <pvPortMalloc+0x3e>
static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL; 
    14f0:	c0 e0       	ldi	r28, 0x00	; 0
    14f2:	d0 e0       	ldi	r29, 0x00	; 0
    14f4:	02 c0       	rjmp	.+4      	; 0x14fa <pvPortMalloc+0x3e>
    14f6:	c0 e0       	ldi	r28, 0x00	; 0
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
			xNextFreeByte += xWantedSize;			
		}	
	}
	xTaskResumeAll();
    14f8:	d0 e0       	ldi	r29, 0x00	; 0
    14fa:	44 d2       	rcall	.+1160   	; 0x1984 <xTaskResumeAll>
		}
	}
	#endif	

	return pvReturn;
}
    14fc:	ce 01       	movw	r24, r28
    14fe:	df 91       	pop	r29
    1500:	cf 91       	pop	r28
    1502:	08 95       	ret

00001504 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    1504:	08 95       	ret

00001506 <prvIdleTask>:
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
		}
	}
    1506:	80 91 03 09 	lds	r24, 0x0903	; 0x800903 <pxReadyTasksLists>
    150a:	82 30       	cpi	r24, 0x02	; 2
    150c:	e0 f3       	brcs	.-8      	; 0x1506 <prvIdleTask>
    150e:	13 df       	rcall	.-474    	; 0x1336 <vPortYield>
    1510:	fa cf       	rjmp	.-12     	; 0x1506 <prvIdleTask>

00001512 <prvAllocateTCBAndStack>:
    1512:	ef 92       	push	r14
    1514:	ff 92       	push	r15
    1516:	0f 93       	push	r16
    1518:	1f 93       	push	r17
    151a:	cf 93       	push	r28
    151c:	df 93       	push	r29
    151e:	7c 01       	movw	r14, r24
    1520:	eb 01       	movw	r28, r22
    1522:	81 e2       	ldi	r24, 0x21	; 33
    1524:	90 e0       	ldi	r25, 0x00	; 0
    1526:	ca df       	rcall	.-108    	; 0x14bc <pvPortMalloc>
    1528:	8c 01       	movw	r16, r24
    152a:	89 2b       	or	r24, r25
    152c:	a1 f0       	breq	.+40     	; 0x1556 <prvAllocateTCBAndStack+0x44>
    152e:	20 97       	sbiw	r28, 0x00	; 0
    1530:	19 f4       	brne	.+6      	; 0x1538 <prvAllocateTCBAndStack+0x26>
    1532:	c7 01       	movw	r24, r14
    1534:	c3 df       	rcall	.-122    	; 0x14bc <pvPortMalloc>
    1536:	01 c0       	rjmp	.+2      	; 0x153a <prvAllocateTCBAndStack+0x28>
    1538:	ce 01       	movw	r24, r28
    153a:	f8 01       	movw	r30, r16
    153c:	90 8f       	std	Z+24, r25	; 0x18
    153e:	87 8b       	std	Z+23, r24	; 0x17
    1540:	00 97       	sbiw	r24, 0x00	; 0
    1542:	29 f4       	brne	.+10     	; 0x154e <prvAllocateTCBAndStack+0x3c>
    1544:	c8 01       	movw	r24, r16
    1546:	de df       	rcall	.-68     	; 0x1504 <vPortFree>
    1548:	00 e0       	ldi	r16, 0x00	; 0
    154a:	10 e0       	ldi	r17, 0x00	; 0
    154c:	04 c0       	rjmp	.+8      	; 0x1556 <prvAllocateTCBAndStack+0x44>
    154e:	a7 01       	movw	r20, r14
    1550:	65 ea       	ldi	r22, 0xA5	; 165
    1552:	70 e0       	ldi	r23, 0x00	; 0
    1554:	76 d7       	rcall	.+3820   	; 0x2442 <memset>
    1556:	c8 01       	movw	r24, r16
    1558:	df 91       	pop	r29
    155a:	cf 91       	pop	r28
    155c:	1f 91       	pop	r17
    155e:	0f 91       	pop	r16
    1560:	ff 90       	pop	r15
    1562:	ef 90       	pop	r14
    1564:	08 95       	ret

00001566 <prvInitialiseTCBVariables>:
    1566:	1f 93       	push	r17
    1568:	cf 93       	push	r28
    156a:	df 93       	push	r29
    156c:	ec 01       	movw	r28, r24
    156e:	14 2f       	mov	r17, r20
    1570:	48 e0       	ldi	r20, 0x08	; 8
    1572:	50 e0       	ldi	r21, 0x00	; 0
    1574:	49 96       	adiw	r24, 0x19	; 25
    1576:	6c d7       	rcall	.+3800   	; 0x2450 <strncpy>
    1578:	18 a2       	std	Y+32, r1	; 0x20
    157a:	11 11       	cpse	r17, r1
    157c:	10 e0       	ldi	r17, 0x00	; 0
    157e:	1e 8b       	std	Y+22, r17	; 0x16
    1580:	ce 01       	movw	r24, r28
    1582:	02 96       	adiw	r24, 0x02	; 2
    1584:	a9 dd       	rcall	.-1198   	; 0x10d8 <vListInitialiseItem>
    1586:	ce 01       	movw	r24, r28
    1588:	0c 96       	adiw	r24, 0x0c	; 12
    158a:	a6 dd       	rcall	.-1204   	; 0x10d8 <vListInitialiseItem>
    158c:	d9 87       	std	Y+9, r29	; 0x09
    158e:	c8 87       	std	Y+8, r28	; 0x08
    1590:	81 e0       	ldi	r24, 0x01	; 1
    1592:	90 e0       	ldi	r25, 0x00	; 0
    1594:	81 1b       	sub	r24, r17
    1596:	91 09       	sbc	r25, r1
    1598:	9d 87       	std	Y+13, r25	; 0x0d
    159a:	8c 87       	std	Y+12, r24	; 0x0c
    159c:	db 8b       	std	Y+19, r29	; 0x13
    159e:	ca 8b       	std	Y+18, r28	; 0x12
    15a0:	df 91       	pop	r29
    15a2:	cf 91       	pop	r28
    15a4:	1f 91       	pop	r17
    15a6:	08 95       	ret

000015a8 <prvInitialiseTaskLists>:
    15a8:	cf 93       	push	r28
    15aa:	c0 e0       	ldi	r28, 0x00	; 0
    15ac:	0f c0       	rjmp	.+30     	; 0x15cc <prvInitialiseTaskLists+0x24>
    15ae:	8c 2f       	mov	r24, r28
    15b0:	90 e0       	ldi	r25, 0x00	; 0
    15b2:	9c 01       	movw	r18, r24
    15b4:	22 0f       	add	r18, r18
    15b6:	33 1f       	adc	r19, r19
    15b8:	22 0f       	add	r18, r18
    15ba:	33 1f       	adc	r19, r19
    15bc:	22 0f       	add	r18, r18
    15be:	33 1f       	adc	r19, r19
    15c0:	82 0f       	add	r24, r18
    15c2:	93 1f       	adc	r25, r19
    15c4:	8d 5f       	subi	r24, 0xFD	; 253
    15c6:	96 4f       	sbci	r25, 0xF6	; 246
    15c8:	79 dd       	rcall	.-1294   	; 0x10bc <vListInitialise>
    15ca:	cf 5f       	subi	r28, 0xFF	; 255
    15cc:	cc 23       	and	r28, r28
    15ce:	79 f3       	breq	.-34     	; 0x15ae <prvInitialiseTaskLists+0x6>
    15d0:	8a ef       	ldi	r24, 0xFA	; 250
    15d2:	98 e0       	ldi	r25, 0x08	; 8
    15d4:	73 dd       	rcall	.-1306   	; 0x10bc <vListInitialise>
    15d6:	81 ef       	ldi	r24, 0xF1	; 241
    15d8:	98 e0       	ldi	r25, 0x08	; 8
    15da:	70 dd       	rcall	.-1312   	; 0x10bc <vListInitialise>
    15dc:	84 ee       	ldi	r24, 0xE4	; 228
    15de:	98 e0       	ldi	r25, 0x08	; 8
    15e0:	6d dd       	rcall	.-1318   	; 0x10bc <vListInitialise>
    15e2:	8a ef       	ldi	r24, 0xFA	; 250
    15e4:	98 e0       	ldi	r25, 0x08	; 8
    15e6:	90 93 f0 08 	sts	0x08F0, r25	; 0x8008f0 <pxDelayedTaskList+0x1>
    15ea:	80 93 ef 08 	sts	0x08EF, r24	; 0x8008ef <pxDelayedTaskList>
    15ee:	81 ef       	ldi	r24, 0xF1	; 241
    15f0:	98 e0       	ldi	r25, 0x08	; 8
    15f2:	90 93 ee 08 	sts	0x08EE, r25	; 0x8008ee <pxOverflowDelayedTaskList+0x1>
    15f6:	80 93 ed 08 	sts	0x08ED, r24	; 0x8008ed <pxOverflowDelayedTaskList>
    15fa:	cf 91       	pop	r28
    15fc:	08 95       	ret

000015fe <prvAddCurrentTaskToDelayedList>:
    15fe:	cf 93       	push	r28
    1600:	df 93       	push	r29
    1602:	ec 01       	movw	r28, r24
    1604:	e0 91 0c 09 	lds	r30, 0x090C	; 0x80090c <pxCurrentTCB>
    1608:	f0 91 0d 09 	lds	r31, 0x090D	; 0x80090d <pxCurrentTCB+0x1>
    160c:	93 83       	std	Z+3, r25	; 0x03
    160e:	82 83       	std	Z+2, r24	; 0x02
    1610:	80 91 e1 08 	lds	r24, 0x08E1	; 0x8008e1 <xTickCount>
    1614:	90 91 e2 08 	lds	r25, 0x08E2	; 0x8008e2 <xTickCount+0x1>
    1618:	c8 17       	cp	r28, r24
    161a:	d9 07       	cpc	r29, r25
    161c:	60 f4       	brcc	.+24     	; 0x1636 <prvAddCurrentTaskToDelayedList+0x38>
    161e:	60 91 0c 09 	lds	r22, 0x090C	; 0x80090c <pxCurrentTCB>
    1622:	70 91 0d 09 	lds	r23, 0x090D	; 0x80090d <pxCurrentTCB+0x1>
    1626:	80 91 ed 08 	lds	r24, 0x08ED	; 0x8008ed <pxOverflowDelayedTaskList>
    162a:	90 91 ee 08 	lds	r25, 0x08EE	; 0x8008ee <pxOverflowDelayedTaskList+0x1>
    162e:	6e 5f       	subi	r22, 0xFE	; 254
    1630:	7f 4f       	sbci	r23, 0xFF	; 255
    1632:	7d dd       	rcall	.-1286   	; 0x112e <vListInsert>
    1634:	16 c0       	rjmp	.+44     	; 0x1662 <prvAddCurrentTaskToDelayedList+0x64>
    1636:	60 91 0c 09 	lds	r22, 0x090C	; 0x80090c <pxCurrentTCB>
    163a:	70 91 0d 09 	lds	r23, 0x090D	; 0x80090d <pxCurrentTCB+0x1>
    163e:	80 91 ef 08 	lds	r24, 0x08EF	; 0x8008ef <pxDelayedTaskList>
    1642:	90 91 f0 08 	lds	r25, 0x08F0	; 0x8008f0 <pxDelayedTaskList+0x1>
    1646:	6e 5f       	subi	r22, 0xFE	; 254
    1648:	7f 4f       	sbci	r23, 0xFF	; 255
    164a:	71 dd       	rcall	.-1310   	; 0x112e <vListInsert>
    164c:	80 91 0b 02 	lds	r24, 0x020B	; 0x80020b <xNextTaskUnblockTime>
    1650:	90 91 0c 02 	lds	r25, 0x020C	; 0x80020c <xNextTaskUnblockTime+0x1>
    1654:	c8 17       	cp	r28, r24
    1656:	d9 07       	cpc	r29, r25
    1658:	20 f4       	brcc	.+8      	; 0x1662 <prvAddCurrentTaskToDelayedList+0x64>
    165a:	d0 93 0c 02 	sts	0x020C, r29	; 0x80020c <xNextTaskUnblockTime+0x1>
    165e:	c0 93 0b 02 	sts	0x020B, r28	; 0x80020b <xNextTaskUnblockTime>
    1662:	df 91       	pop	r29
    1664:	cf 91       	pop	r28
    1666:	08 95       	ret

00001668 <xTaskGenericCreate>:
    1668:	2f 92       	push	r2
    166a:	3f 92       	push	r3
    166c:	4f 92       	push	r4
    166e:	5f 92       	push	r5
    1670:	7f 92       	push	r7
    1672:	8f 92       	push	r8
    1674:	9f 92       	push	r9
    1676:	af 92       	push	r10
    1678:	bf 92       	push	r11
    167a:	cf 92       	push	r12
    167c:	df 92       	push	r13
    167e:	ef 92       	push	r14
    1680:	ff 92       	push	r15
    1682:	0f 93       	push	r16
    1684:	1f 93       	push	r17
    1686:	cf 93       	push	r28
    1688:	df 93       	push	r29
    168a:	00 d0       	rcall	.+0      	; 0x168c <xTaskGenericCreate+0x24>
    168c:	1f 92       	push	r1
    168e:	cd b7       	in	r28, 0x3d	; 61
    1690:	de b7       	in	r29, 0x3e	; 62
    1692:	9a 83       	std	Y+2, r25	; 0x02
    1694:	89 83       	std	Y+1, r24	; 0x01
    1696:	4b 01       	movw	r8, r22
    1698:	5c 83       	std	Y+4, r21	; 0x04
    169a:	4b 83       	std	Y+3, r20	; 0x03
    169c:	19 01       	movw	r2, r18
    169e:	70 2e       	mov	r7, r16
    16a0:	b6 01       	movw	r22, r12
    16a2:	25 01       	movw	r4, r10
    16a4:	ca 01       	movw	r24, r20
    16a6:	35 df       	rcall	.-406    	; 0x1512 <prvAllocateTCBAndStack>
    16a8:	5c 01       	movw	r10, r24
    16aa:	00 97       	sbiw	r24, 0x00	; 0
    16ac:	09 f4       	brne	.+2      	; 0x16b0 <xTaskGenericCreate+0x48>
    16ae:	6c c0       	rjmp	.+216    	; 0x1788 <xTaskGenericCreate+0x120>
    16b0:	fc 01       	movw	r30, r24
    16b2:	c7 88       	ldd	r12, Z+23	; 0x17
    16b4:	d0 8c       	ldd	r13, Z+24	; 0x18
    16b6:	8b 81       	ldd	r24, Y+3	; 0x03
    16b8:	9c 81       	ldd	r25, Y+4	; 0x04
    16ba:	01 97       	sbiw	r24, 0x01	; 1
    16bc:	c8 0e       	add	r12, r24
    16be:	d9 1e       	adc	r13, r25
    16c0:	0b 81       	ldd	r16, Y+3	; 0x03
    16c2:	1c 81       	ldd	r17, Y+4	; 0x04
    16c4:	92 01       	movw	r18, r4
    16c6:	47 2d       	mov	r20, r7
    16c8:	b4 01       	movw	r22, r8
    16ca:	c5 01       	movw	r24, r10
    16cc:	4c df       	rcall	.-360    	; 0x1566 <prvInitialiseTCBVariables>
    16ce:	a1 01       	movw	r20, r2
    16d0:	69 81       	ldd	r22, Y+1	; 0x01
    16d2:	7a 81       	ldd	r23, Y+2	; 0x02
    16d4:	c6 01       	movw	r24, r12
    16d6:	8b dd       	rcall	.-1258   	; 0x11ee <pxPortInitialiseStack>
    16d8:	f5 01       	movw	r30, r10
    16da:	91 83       	std	Z+1, r25	; 0x01
    16dc:	80 83       	st	Z, r24
    16de:	e1 14       	cp	r14, r1
    16e0:	f1 04       	cpc	r15, r1
    16e2:	19 f0       	breq	.+6      	; 0x16ea <xTaskGenericCreate+0x82>
    16e4:	f7 01       	movw	r30, r14
    16e6:	b1 82       	std	Z+1, r11	; 0x01
    16e8:	a0 82       	st	Z, r10
    16ea:	0f b6       	in	r0, 0x3f	; 63
    16ec:	f8 94       	cli
    16ee:	0f 92       	push	r0
    16f0:	80 91 e3 08 	lds	r24, 0x08E3	; 0x8008e3 <uxCurrentNumberOfTasks>
    16f4:	8f 5f       	subi	r24, 0xFF	; 255
    16f6:	80 93 e3 08 	sts	0x08E3, r24	; 0x8008e3 <uxCurrentNumberOfTasks>
    16fa:	80 91 0c 09 	lds	r24, 0x090C	; 0x80090c <pxCurrentTCB>
    16fe:	90 91 0d 09 	lds	r25, 0x090D	; 0x80090d <pxCurrentTCB+0x1>
    1702:	89 2b       	or	r24, r25
    1704:	51 f4       	brne	.+20     	; 0x171a <xTaskGenericCreate+0xb2>
    1706:	b0 92 0d 09 	sts	0x090D, r11	; 0x80090d <pxCurrentTCB+0x1>
    170a:	a0 92 0c 09 	sts	0x090C, r10	; 0x80090c <pxCurrentTCB>
    170e:	80 91 e3 08 	lds	r24, 0x08E3	; 0x8008e3 <uxCurrentNumberOfTasks>
    1712:	81 30       	cpi	r24, 0x01	; 1
    1714:	89 f4       	brne	.+34     	; 0x1738 <xTaskGenericCreate+0xd0>
    1716:	48 df       	rcall	.-368    	; 0x15a8 <prvInitialiseTaskLists>
    1718:	0f c0       	rjmp	.+30     	; 0x1738 <xTaskGenericCreate+0xd0>
    171a:	80 91 de 08 	lds	r24, 0x08DE	; 0x8008de <xSchedulerRunning>
    171e:	81 11       	cpse	r24, r1
    1720:	0b c0       	rjmp	.+22     	; 0x1738 <xTaskGenericCreate+0xd0>
    1722:	e0 91 0c 09 	lds	r30, 0x090C	; 0x80090c <pxCurrentTCB>
    1726:	f0 91 0d 09 	lds	r31, 0x090D	; 0x80090d <pxCurrentTCB+0x1>
    172a:	86 89       	ldd	r24, Z+22	; 0x16
    172c:	78 16       	cp	r7, r24
    172e:	20 f0       	brcs	.+8      	; 0x1738 <xTaskGenericCreate+0xd0>
    1730:	b0 92 0d 09 	sts	0x090D, r11	; 0x80090d <pxCurrentTCB+0x1>
    1734:	a0 92 0c 09 	sts	0x090C, r10	; 0x80090c <pxCurrentTCB>
    1738:	f5 01       	movw	r30, r10
    173a:	86 89       	ldd	r24, Z+22	; 0x16
    173c:	90 91 e0 08 	lds	r25, 0x08E0	; 0x8008e0 <uxTopUsedPriority>
    1740:	98 17       	cp	r25, r24
    1742:	10 f4       	brcc	.+4      	; 0x1748 <xTaskGenericCreate+0xe0>
    1744:	80 93 e0 08 	sts	0x08E0, r24	; 0x8008e0 <uxTopUsedPriority>
    1748:	90 91 d9 08 	lds	r25, 0x08D9	; 0x8008d9 <uxTCBNumber>
    174c:	9f 5f       	subi	r25, 0xFF	; 255
    174e:	90 93 d9 08 	sts	0x08D9, r25	; 0x8008d9 <uxTCBNumber>
    1752:	90 91 df 08 	lds	r25, 0x08DF	; 0x8008df <uxTopReadyPriority>
    1756:	98 17       	cp	r25, r24
    1758:	10 f4       	brcc	.+4      	; 0x175e <xTaskGenericCreate+0xf6>
    175a:	80 93 df 08 	sts	0x08DF, r24	; 0x8008df <uxTopReadyPriority>
    175e:	90 e0       	ldi	r25, 0x00	; 0
    1760:	b5 01       	movw	r22, r10
    1762:	6e 5f       	subi	r22, 0xFE	; 254
    1764:	7f 4f       	sbci	r23, 0xFF	; 255
    1766:	9c 01       	movw	r18, r24
    1768:	22 0f       	add	r18, r18
    176a:	33 1f       	adc	r19, r19
    176c:	22 0f       	add	r18, r18
    176e:	33 1f       	adc	r19, r19
    1770:	22 0f       	add	r18, r18
    1772:	33 1f       	adc	r19, r19
    1774:	82 0f       	add	r24, r18
    1776:	93 1f       	adc	r25, r19
    1778:	8d 5f       	subi	r24, 0xFD	; 253
    177a:	96 4f       	sbci	r25, 0xF6	; 246
    177c:	b1 dc       	rcall	.-1694   	; 0x10e0 <vListInsertEnd>
    177e:	0f 90       	pop	r0
    1780:	0f be       	out	0x3f, r0	; 63
    1782:	f1 e0       	ldi	r31, 0x01	; 1
    1784:	f9 83       	std	Y+1, r31	; 0x01
    1786:	02 c0       	rjmp	.+4      	; 0x178c <xTaskGenericCreate+0x124>
    1788:	8f ef       	ldi	r24, 0xFF	; 255
    178a:	89 83       	std	Y+1, r24	; 0x01
    178c:	e9 81       	ldd	r30, Y+1	; 0x01
    178e:	e1 30       	cpi	r30, 0x01	; 1
    1790:	61 f4       	brne	.+24     	; 0x17aa <xTaskGenericCreate+0x142>
    1792:	80 91 de 08 	lds	r24, 0x08DE	; 0x8008de <xSchedulerRunning>
    1796:	88 23       	and	r24, r24
    1798:	41 f0       	breq	.+16     	; 0x17aa <xTaskGenericCreate+0x142>
    179a:	e0 91 0c 09 	lds	r30, 0x090C	; 0x80090c <pxCurrentTCB>
    179e:	f0 91 0d 09 	lds	r31, 0x090D	; 0x80090d <pxCurrentTCB+0x1>
    17a2:	86 89       	ldd	r24, Z+22	; 0x16
    17a4:	87 15       	cp	r24, r7
    17a6:	08 f4       	brcc	.+2      	; 0x17aa <xTaskGenericCreate+0x142>
    17a8:	c6 dd       	rcall	.-1140   	; 0x1336 <vPortYield>
    17aa:	89 81       	ldd	r24, Y+1	; 0x01
    17ac:	0f 90       	pop	r0
    17ae:	0f 90       	pop	r0
    17b0:	0f 90       	pop	r0
    17b2:	0f 90       	pop	r0
    17b4:	df 91       	pop	r29
    17b6:	cf 91       	pop	r28
    17b8:	1f 91       	pop	r17
    17ba:	0f 91       	pop	r16
    17bc:	ff 90       	pop	r15
    17be:	ef 90       	pop	r14
    17c0:	df 90       	pop	r13
    17c2:	cf 90       	pop	r12
    17c4:	bf 90       	pop	r11
    17c6:	af 90       	pop	r10
    17c8:	9f 90       	pop	r9
    17ca:	8f 90       	pop	r8
    17cc:	7f 90       	pop	r7
    17ce:	5f 90       	pop	r5
    17d0:	4f 90       	pop	r4
    17d2:	3f 90       	pop	r3
    17d4:	2f 90       	pop	r2
    17d6:	08 95       	ret

000017d8 <vTaskStartScheduler>:
    17d8:	af 92       	push	r10
    17da:	bf 92       	push	r11
    17dc:	cf 92       	push	r12
    17de:	df 92       	push	r13
    17e0:	ef 92       	push	r14
    17e2:	ff 92       	push	r15
    17e4:	0f 93       	push	r16
    17e6:	a1 2c       	mov	r10, r1
    17e8:	b1 2c       	mov	r11, r1
    17ea:	c1 2c       	mov	r12, r1
    17ec:	d1 2c       	mov	r13, r1
    17ee:	e1 2c       	mov	r14, r1
    17f0:	f1 2c       	mov	r15, r1
    17f2:	00 e0       	ldi	r16, 0x00	; 0
    17f4:	20 e0       	ldi	r18, 0x00	; 0
    17f6:	30 e0       	ldi	r19, 0x00	; 0
    17f8:	45 e5       	ldi	r20, 0x55	; 85
    17fa:	50 e0       	ldi	r21, 0x00	; 0
    17fc:	6e e6       	ldi	r22, 0x6E	; 110
    17fe:	72 e0       	ldi	r23, 0x02	; 2
    1800:	83 e8       	ldi	r24, 0x83	; 131
    1802:	9a e0       	ldi	r25, 0x0A	; 10
    1804:	31 df       	rcall	.-414    	; 0x1668 <xTaskGenericCreate>
    1806:	81 30       	cpi	r24, 0x01	; 1
    1808:	41 f4       	brne	.+16     	; 0x181a <vTaskStartScheduler+0x42>
    180a:	f8 94       	cli
    180c:	80 93 de 08 	sts	0x08DE, r24	; 0x8008de <xSchedulerRunning>
    1810:	10 92 e2 08 	sts	0x08E2, r1	; 0x8008e2 <xTickCount+0x1>
    1814:	10 92 e1 08 	sts	0x08E1, r1	; 0x8008e1 <xTickCount>
    1818:	5c dd       	rcall	.-1352   	; 0x12d2 <xPortStartScheduler>
    181a:	0f 91       	pop	r16
    181c:	ff 90       	pop	r15
    181e:	ef 90       	pop	r14
    1820:	df 90       	pop	r13
    1822:	cf 90       	pop	r12
    1824:	bf 90       	pop	r11
    1826:	af 90       	pop	r10
    1828:	08 95       	ret

0000182a <vTaskSuspendAll>:
    182a:	80 91 dd 08 	lds	r24, 0x08DD	; 0x8008dd <uxSchedulerSuspended>
    182e:	8f 5f       	subi	r24, 0xFF	; 255
    1830:	80 93 dd 08 	sts	0x08DD, r24	; 0x8008dd <uxSchedulerSuspended>
    1834:	08 95       	ret

00001836 <vTaskIncrementTick>:
    1836:	0f 93       	push	r16
    1838:	1f 93       	push	r17
    183a:	cf 93       	push	r28
    183c:	df 93       	push	r29
    183e:	80 91 dd 08 	lds	r24, 0x08DD	; 0x8008dd <uxSchedulerSuspended>
    1842:	81 11       	cpse	r24, r1
    1844:	95 c0       	rjmp	.+298    	; 0x1970 <vTaskIncrementTick+0x13a>
    1846:	80 91 e1 08 	lds	r24, 0x08E1	; 0x8008e1 <xTickCount>
    184a:	90 91 e2 08 	lds	r25, 0x08E2	; 0x8008e2 <xTickCount+0x1>
    184e:	01 96       	adiw	r24, 0x01	; 1
    1850:	90 93 e2 08 	sts	0x08E2, r25	; 0x8008e2 <xTickCount+0x1>
    1854:	80 93 e1 08 	sts	0x08E1, r24	; 0x8008e1 <xTickCount>
    1858:	80 91 e1 08 	lds	r24, 0x08E1	; 0x8008e1 <xTickCount>
    185c:	90 91 e2 08 	lds	r25, 0x08E2	; 0x8008e2 <xTickCount+0x1>
    1860:	89 2b       	or	r24, r25
    1862:	99 f5       	brne	.+102    	; 0x18ca <vTaskIncrementTick+0x94>
    1864:	80 91 ef 08 	lds	r24, 0x08EF	; 0x8008ef <pxDelayedTaskList>
    1868:	90 91 f0 08 	lds	r25, 0x08F0	; 0x8008f0 <pxDelayedTaskList+0x1>
    186c:	20 91 ed 08 	lds	r18, 0x08ED	; 0x8008ed <pxOverflowDelayedTaskList>
    1870:	30 91 ee 08 	lds	r19, 0x08EE	; 0x8008ee <pxOverflowDelayedTaskList+0x1>
    1874:	30 93 f0 08 	sts	0x08F0, r19	; 0x8008f0 <pxDelayedTaskList+0x1>
    1878:	20 93 ef 08 	sts	0x08EF, r18	; 0x8008ef <pxDelayedTaskList>
    187c:	90 93 ee 08 	sts	0x08EE, r25	; 0x8008ee <pxOverflowDelayedTaskList+0x1>
    1880:	80 93 ed 08 	sts	0x08ED, r24	; 0x8008ed <pxOverflowDelayedTaskList>
    1884:	80 91 da 08 	lds	r24, 0x08DA	; 0x8008da <xNumOfOverflows>
    1888:	8f 5f       	subi	r24, 0xFF	; 255
    188a:	80 93 da 08 	sts	0x08DA, r24	; 0x8008da <xNumOfOverflows>
    188e:	e0 91 ef 08 	lds	r30, 0x08EF	; 0x8008ef <pxDelayedTaskList>
    1892:	f0 91 f0 08 	lds	r31, 0x08F0	; 0x8008f0 <pxDelayedTaskList+0x1>
    1896:	80 81       	ld	r24, Z
    1898:	81 11       	cpse	r24, r1
    189a:	07 c0       	rjmp	.+14     	; 0x18aa <vTaskIncrementTick+0x74>
    189c:	8f ef       	ldi	r24, 0xFF	; 255
    189e:	9f ef       	ldi	r25, 0xFF	; 255
    18a0:	90 93 0c 02 	sts	0x020C, r25	; 0x80020c <xNextTaskUnblockTime+0x1>
    18a4:	80 93 0b 02 	sts	0x020B, r24	; 0x80020b <xNextTaskUnblockTime>
    18a8:	10 c0       	rjmp	.+32     	; 0x18ca <vTaskIncrementTick+0x94>
    18aa:	e0 91 ef 08 	lds	r30, 0x08EF	; 0x8008ef <pxDelayedTaskList>
    18ae:	f0 91 f0 08 	lds	r31, 0x08F0	; 0x8008f0 <pxDelayedTaskList+0x1>
    18b2:	05 80       	ldd	r0, Z+5	; 0x05
    18b4:	f6 81       	ldd	r31, Z+6	; 0x06
    18b6:	e0 2d       	mov	r30, r0
    18b8:	06 80       	ldd	r0, Z+6	; 0x06
    18ba:	f7 81       	ldd	r31, Z+7	; 0x07
    18bc:	e0 2d       	mov	r30, r0
    18be:	82 81       	ldd	r24, Z+2	; 0x02
    18c0:	93 81       	ldd	r25, Z+3	; 0x03
    18c2:	90 93 0c 02 	sts	0x020C, r25	; 0x80020c <xNextTaskUnblockTime+0x1>
    18c6:	80 93 0b 02 	sts	0x020B, r24	; 0x80020b <xNextTaskUnblockTime>
    18ca:	20 91 e1 08 	lds	r18, 0x08E1	; 0x8008e1 <xTickCount>
    18ce:	30 91 e2 08 	lds	r19, 0x08E2	; 0x8008e2 <xTickCount+0x1>
    18d2:	80 91 0b 02 	lds	r24, 0x020B	; 0x80020b <xNextTaskUnblockTime>
    18d6:	90 91 0c 02 	lds	r25, 0x020C	; 0x80020c <xNextTaskUnblockTime+0x1>
    18da:	28 17       	cp	r18, r24
    18dc:	39 07       	cpc	r19, r25
    18de:	08 f4       	brcc	.+2      	; 0x18e2 <vTaskIncrementTick+0xac>
    18e0:	4c c0       	rjmp	.+152    	; 0x197a <vTaskIncrementTick+0x144>
    18e2:	e0 91 ef 08 	lds	r30, 0x08EF	; 0x8008ef <pxDelayedTaskList>
    18e6:	f0 91 f0 08 	lds	r31, 0x08F0	; 0x8008f0 <pxDelayedTaskList+0x1>
    18ea:	80 81       	ld	r24, Z
    18ec:	81 11       	cpse	r24, r1
    18ee:	07 c0       	rjmp	.+14     	; 0x18fe <vTaskIncrementTick+0xc8>
    18f0:	8f ef       	ldi	r24, 0xFF	; 255
    18f2:	9f ef       	ldi	r25, 0xFF	; 255
    18f4:	90 93 0c 02 	sts	0x020C, r25	; 0x80020c <xNextTaskUnblockTime+0x1>
    18f8:	80 93 0b 02 	sts	0x020B, r24	; 0x80020b <xNextTaskUnblockTime>
    18fc:	3e c0       	rjmp	.+124    	; 0x197a <vTaskIncrementTick+0x144>
    18fe:	e0 91 ef 08 	lds	r30, 0x08EF	; 0x8008ef <pxDelayedTaskList>
    1902:	f0 91 f0 08 	lds	r31, 0x08F0	; 0x8008f0 <pxDelayedTaskList+0x1>
    1906:	05 80       	ldd	r0, Z+5	; 0x05
    1908:	f6 81       	ldd	r31, Z+6	; 0x06
    190a:	e0 2d       	mov	r30, r0
    190c:	c6 81       	ldd	r28, Z+6	; 0x06
    190e:	d7 81       	ldd	r29, Z+7	; 0x07
    1910:	8a 81       	ldd	r24, Y+2	; 0x02
    1912:	9b 81       	ldd	r25, Y+3	; 0x03
    1914:	20 91 e1 08 	lds	r18, 0x08E1	; 0x8008e1 <xTickCount>
    1918:	30 91 e2 08 	lds	r19, 0x08E2	; 0x8008e2 <xTickCount+0x1>
    191c:	28 17       	cp	r18, r24
    191e:	39 07       	cpc	r19, r25
    1920:	28 f4       	brcc	.+10     	; 0x192c <vTaskIncrementTick+0xf6>
    1922:	90 93 0c 02 	sts	0x020C, r25	; 0x80020c <xNextTaskUnblockTime+0x1>
    1926:	80 93 0b 02 	sts	0x020B, r24	; 0x80020b <xNextTaskUnblockTime>
    192a:	27 c0       	rjmp	.+78     	; 0x197a <vTaskIncrementTick+0x144>
    192c:	8e 01       	movw	r16, r28
    192e:	0e 5f       	subi	r16, 0xFE	; 254
    1930:	1f 4f       	sbci	r17, 0xFF	; 255
    1932:	c8 01       	movw	r24, r16
    1934:	2d dc       	rcall	.-1958   	; 0x1190 <vListRemove>
    1936:	8c 89       	ldd	r24, Y+20	; 0x14
    1938:	9d 89       	ldd	r25, Y+21	; 0x15
    193a:	89 2b       	or	r24, r25
    193c:	19 f0       	breq	.+6      	; 0x1944 <vTaskIncrementTick+0x10e>
    193e:	ce 01       	movw	r24, r28
    1940:	0c 96       	adiw	r24, 0x0c	; 12
    1942:	26 dc       	rcall	.-1972   	; 0x1190 <vListRemove>
    1944:	8e 89       	ldd	r24, Y+22	; 0x16
    1946:	90 91 df 08 	lds	r25, 0x08DF	; 0x8008df <uxTopReadyPriority>
    194a:	98 17       	cp	r25, r24
    194c:	10 f4       	brcc	.+4      	; 0x1952 <vTaskIncrementTick+0x11c>
    194e:	80 93 df 08 	sts	0x08DF, r24	; 0x8008df <uxTopReadyPriority>
    1952:	90 e0       	ldi	r25, 0x00	; 0
    1954:	9c 01       	movw	r18, r24
    1956:	22 0f       	add	r18, r18
    1958:	33 1f       	adc	r19, r19
    195a:	22 0f       	add	r18, r18
    195c:	33 1f       	adc	r19, r19
    195e:	22 0f       	add	r18, r18
    1960:	33 1f       	adc	r19, r19
    1962:	82 0f       	add	r24, r18
    1964:	93 1f       	adc	r25, r19
    1966:	b8 01       	movw	r22, r16
    1968:	8d 5f       	subi	r24, 0xFD	; 253
    196a:	96 4f       	sbci	r25, 0xF6	; 246
    196c:	b9 db       	rcall	.-2190   	; 0x10e0 <vListInsertEnd>
    196e:	b9 cf       	rjmp	.-142    	; 0x18e2 <vTaskIncrementTick+0xac>
    1970:	80 91 dc 08 	lds	r24, 0x08DC	; 0x8008dc <uxMissedTicks>
    1974:	8f 5f       	subi	r24, 0xFF	; 255
    1976:	80 93 dc 08 	sts	0x08DC, r24	; 0x8008dc <uxMissedTicks>
    197a:	df 91       	pop	r29
    197c:	cf 91       	pop	r28
    197e:	1f 91       	pop	r17
    1980:	0f 91       	pop	r16
    1982:	08 95       	ret

00001984 <xTaskResumeAll>:
    1984:	ff 92       	push	r15
    1986:	0f 93       	push	r16
    1988:	1f 93       	push	r17
    198a:	cf 93       	push	r28
    198c:	df 93       	push	r29
    198e:	0f b6       	in	r0, 0x3f	; 63
    1990:	f8 94       	cli
    1992:	0f 92       	push	r0
    1994:	80 91 dd 08 	lds	r24, 0x08DD	; 0x8008dd <uxSchedulerSuspended>
    1998:	81 50       	subi	r24, 0x01	; 1
    199a:	80 93 dd 08 	sts	0x08DD, r24	; 0x8008dd <uxSchedulerSuspended>
    199e:	80 91 dd 08 	lds	r24, 0x08DD	; 0x8008dd <uxSchedulerSuspended>
    19a2:	81 11       	cpse	r24, r1
    19a4:	55 c0       	rjmp	.+170    	; 0x1a50 <xTaskResumeAll+0xcc>
    19a6:	80 91 e3 08 	lds	r24, 0x08E3	; 0x8008e3 <uxCurrentNumberOfTasks>
    19aa:	81 11       	cpse	r24, r1
    19ac:	2f c0       	rjmp	.+94     	; 0x1a0c <xTaskResumeAll+0x88>
    19ae:	53 c0       	rjmp	.+166    	; 0x1a56 <xTaskResumeAll+0xd2>
    19b0:	e0 91 e9 08 	lds	r30, 0x08E9	; 0x8008e9 <xPendingReadyList+0x5>
    19b4:	f0 91 ea 08 	lds	r31, 0x08EA	; 0x8008ea <xPendingReadyList+0x6>
    19b8:	c6 81       	ldd	r28, Z+6	; 0x06
    19ba:	d7 81       	ldd	r29, Z+7	; 0x07
    19bc:	ce 01       	movw	r24, r28
    19be:	0c 96       	adiw	r24, 0x0c	; 12
    19c0:	e7 db       	rcall	.-2098   	; 0x1190 <vListRemove>
    19c2:	8e 01       	movw	r16, r28
    19c4:	0e 5f       	subi	r16, 0xFE	; 254
    19c6:	1f 4f       	sbci	r17, 0xFF	; 255
    19c8:	c8 01       	movw	r24, r16
    19ca:	e2 db       	rcall	.-2108   	; 0x1190 <vListRemove>
    19cc:	8e 89       	ldd	r24, Y+22	; 0x16
    19ce:	90 91 df 08 	lds	r25, 0x08DF	; 0x8008df <uxTopReadyPriority>
    19d2:	98 17       	cp	r25, r24
    19d4:	10 f4       	brcc	.+4      	; 0x19da <xTaskResumeAll+0x56>
    19d6:	80 93 df 08 	sts	0x08DF, r24	; 0x8008df <uxTopReadyPriority>
    19da:	90 e0       	ldi	r25, 0x00	; 0
    19dc:	9c 01       	movw	r18, r24
    19de:	22 0f       	add	r18, r18
    19e0:	33 1f       	adc	r19, r19
    19e2:	22 0f       	add	r18, r18
    19e4:	33 1f       	adc	r19, r19
    19e6:	22 0f       	add	r18, r18
    19e8:	33 1f       	adc	r19, r19
    19ea:	82 0f       	add	r24, r18
    19ec:	93 1f       	adc	r25, r19
    19ee:	b8 01       	movw	r22, r16
    19f0:	8d 5f       	subi	r24, 0xFD	; 253
    19f2:	96 4f       	sbci	r25, 0xF6	; 246
    19f4:	75 db       	rcall	.-2326   	; 0x10e0 <vListInsertEnd>
    19f6:	9e 89       	ldd	r25, Y+22	; 0x16
    19f8:	e0 91 0c 09 	lds	r30, 0x090C	; 0x80090c <pxCurrentTCB>
    19fc:	f0 91 0d 09 	lds	r31, 0x090D	; 0x80090d <pxCurrentTCB+0x1>
    1a00:	86 89       	ldd	r24, Z+22	; 0x16
    1a02:	98 17       	cp	r25, r24
    1a04:	20 f0       	brcs	.+8      	; 0x1a0e <xTaskResumeAll+0x8a>
    1a06:	ff 24       	eor	r15, r15
    1a08:	f3 94       	inc	r15
    1a0a:	01 c0       	rjmp	.+2      	; 0x1a0e <xTaskResumeAll+0x8a>
    1a0c:	f1 2c       	mov	r15, r1
    1a0e:	80 91 e4 08 	lds	r24, 0x08E4	; 0x8008e4 <xPendingReadyList>
    1a12:	81 11       	cpse	r24, r1
    1a14:	cd cf       	rjmp	.-102    	; 0x19b0 <xTaskResumeAll+0x2c>
    1a16:	80 91 dc 08 	lds	r24, 0x08DC	; 0x8008dc <uxMissedTicks>
    1a1a:	81 11       	cpse	r24, r1
    1a1c:	07 c0       	rjmp	.+14     	; 0x1a2c <xTaskResumeAll+0xa8>
    1a1e:	0c c0       	rjmp	.+24     	; 0x1a38 <xTaskResumeAll+0xb4>
    1a20:	0a df       	rcall	.-492    	; 0x1836 <vTaskIncrementTick>
    1a22:	80 91 dc 08 	lds	r24, 0x08DC	; 0x8008dc <uxMissedTicks>
    1a26:	81 50       	subi	r24, 0x01	; 1
    1a28:	80 93 dc 08 	sts	0x08DC, r24	; 0x8008dc <uxMissedTicks>
    1a2c:	80 91 dc 08 	lds	r24, 0x08DC	; 0x8008dc <uxMissedTicks>
    1a30:	81 11       	cpse	r24, r1
    1a32:	f6 cf       	rjmp	.-20     	; 0x1a20 <xTaskResumeAll+0x9c>
    1a34:	ff 24       	eor	r15, r15
    1a36:	f3 94       	inc	r15
    1a38:	81 e0       	ldi	r24, 0x01	; 1
    1a3a:	f8 16       	cp	r15, r24
    1a3c:	21 f0       	breq	.+8      	; 0x1a46 <xTaskResumeAll+0xc2>
    1a3e:	80 91 db 08 	lds	r24, 0x08DB	; 0x8008db <xMissedYield>
    1a42:	81 30       	cpi	r24, 0x01	; 1
    1a44:	39 f4       	brne	.+14     	; 0x1a54 <xTaskResumeAll+0xd0>
    1a46:	10 92 db 08 	sts	0x08DB, r1	; 0x8008db <xMissedYield>
    1a4a:	75 dc       	rcall	.-1814   	; 0x1336 <vPortYield>
    1a4c:	81 e0       	ldi	r24, 0x01	; 1
    1a4e:	03 c0       	rjmp	.+6      	; 0x1a56 <xTaskResumeAll+0xd2>
    1a50:	80 e0       	ldi	r24, 0x00	; 0
    1a52:	01 c0       	rjmp	.+2      	; 0x1a56 <xTaskResumeAll+0xd2>
    1a54:	80 e0       	ldi	r24, 0x00	; 0
    1a56:	0f 90       	pop	r0
    1a58:	0f be       	out	0x3f, r0	; 63
    1a5a:	df 91       	pop	r29
    1a5c:	cf 91       	pop	r28
    1a5e:	1f 91       	pop	r17
    1a60:	0f 91       	pop	r16
    1a62:	ff 90       	pop	r15
    1a64:	08 95       	ret

00001a66 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    1a66:	cf 93       	push	r28
    1a68:	df 93       	push	r29
    1a6a:	ec 01       	movw	r28, r24
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    1a6c:	89 2b       	or	r24, r25
    1a6e:	89 f0       	breq	.+34     	; 0x1a92 <vTaskDelay+0x2c>
		{
			vTaskSuspendAll();
    1a70:	dc de       	rcall	.-584    	; 0x182a <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    1a72:	80 91 e1 08 	lds	r24, 0x08E1	; 0x8008e1 <xTickCount>
    1a76:	90 91 e2 08 	lds	r25, 0x08E2	; 0x8008e2 <xTickCount+0x1>
    1a7a:	c8 0f       	add	r28, r24
    1a7c:	d9 1f       	adc	r29, r25

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1a7e:	80 91 0c 09 	lds	r24, 0x090C	; 0x80090c <pxCurrentTCB>
    1a82:	90 91 0d 09 	lds	r25, 0x090D	; 0x80090d <pxCurrentTCB+0x1>
    1a86:	02 96       	adiw	r24, 0x02	; 2
    1a88:	83 db       	rcall	.-2298   	; 0x1190 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    1a8a:	ce 01       	movw	r24, r28
    1a8c:	b8 dd       	rcall	.-1168   	; 0x15fe <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    1a8e:	7a df       	rcall	.-268    	; 0x1984 <xTaskResumeAll>
    1a90:	01 c0       	rjmp	.+2      	; 0x1a94 <vTaskDelay+0x2e>
#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    1a92:	80 e0       	ldi	r24, 0x00	; 0
			xAlreadyYielded = xTaskResumeAll();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    1a94:	81 11       	cpse	r24, r1
    1a96:	01 c0       	rjmp	.+2      	; 0x1a9a <vTaskDelay+0x34>
		{
			portYIELD_WITHIN_API();
    1a98:	4e dc       	rcall	.-1892   	; 0x1336 <vPortYield>
    1a9a:	df 91       	pop	r29
		}
	}
    1a9c:	cf 91       	pop	r28
    1a9e:	08 95       	ret

00001aa0 <vTaskSwitchContext>:
    1aa0:	80 91 dd 08 	lds	r24, 0x08DD	; 0x8008dd <uxSchedulerSuspended>
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    1aa4:	88 23       	and	r24, r24
    1aa6:	49 f0       	breq	.+18     	; 0x1aba <vTaskSwitchContext+0x1a>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    1aa8:	81 e0       	ldi	r24, 0x01	; 1
    1aaa:	80 93 db 08 	sts	0x08DB, r24	; 0x8008db <xMissedYield>
    1aae:	08 95       	ret
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    1ab0:	80 91 df 08 	lds	r24, 0x08DF	; 0x8008df <uxTopReadyPriority>
    1ab4:	81 50       	subi	r24, 0x01	; 1
    1ab6:	80 93 df 08 	sts	0x08DF, r24	; 0x8008df <uxTopReadyPriority>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    1aba:	80 91 df 08 	lds	r24, 0x08DF	; 0x8008df <uxTopReadyPriority>
    1abe:	90 e0       	ldi	r25, 0x00	; 0
    1ac0:	fc 01       	movw	r30, r24
    1ac2:	ee 0f       	add	r30, r30
    1ac4:	ff 1f       	adc	r31, r31
    1ac6:	ee 0f       	add	r30, r30
    1ac8:	ff 1f       	adc	r31, r31
    1aca:	ee 0f       	add	r30, r30
    1acc:	ff 1f       	adc	r31, r31
    1ace:	8e 0f       	add	r24, r30
    1ad0:	9f 1f       	adc	r25, r31
    1ad2:	fc 01       	movw	r30, r24
    1ad4:	ed 5f       	subi	r30, 0xFD	; 253
    1ad6:	f6 4f       	sbci	r31, 0xF6	; 246
    1ad8:	80 81       	ld	r24, Z
    1ada:	88 23       	and	r24, r24
    1adc:	49 f3       	breq	.-46     	; 0x1ab0 <vTaskSwitchContext+0x10>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    1ade:	80 91 df 08 	lds	r24, 0x08DF	; 0x8008df <uxTopReadyPriority>
    1ae2:	90 e0       	ldi	r25, 0x00	; 0
    1ae4:	9c 01       	movw	r18, r24
    1ae6:	22 0f       	add	r18, r18
    1ae8:	33 1f       	adc	r19, r19
    1aea:	22 0f       	add	r18, r18
    1aec:	33 1f       	adc	r19, r19
    1aee:	22 0f       	add	r18, r18
    1af0:	33 1f       	adc	r19, r19
    1af2:	28 0f       	add	r18, r24
    1af4:	39 1f       	adc	r19, r25
    1af6:	d9 01       	movw	r26, r18
    1af8:	ad 5f       	subi	r26, 0xFD	; 253
    1afa:	b6 4f       	sbci	r27, 0xF6	; 246
    1afc:	11 96       	adiw	r26, 0x01	; 1
    1afe:	ed 91       	ld	r30, X+
    1b00:	fc 91       	ld	r31, X
    1b02:	12 97       	sbiw	r26, 0x02	; 2
    1b04:	02 80       	ldd	r0, Z+2	; 0x02
    1b06:	f3 81       	ldd	r31, Z+3	; 0x03
    1b08:	e0 2d       	mov	r30, r0
    1b0a:	12 96       	adiw	r26, 0x02	; 2
    1b0c:	fc 93       	st	X, r31
    1b0e:	ee 93       	st	-X, r30
    1b10:	11 97       	sbiw	r26, 0x01	; 1
    1b12:	2a 5f       	subi	r18, 0xFA	; 250
    1b14:	36 4f       	sbci	r19, 0xF6	; 246
    1b16:	e2 17       	cp	r30, r18
    1b18:	f3 07       	cpc	r31, r19
    1b1a:	29 f4       	brne	.+10     	; 0x1b26 <vTaskSwitchContext+0x86>
    1b1c:	22 81       	ldd	r18, Z+2	; 0x02
    1b1e:	33 81       	ldd	r19, Z+3	; 0x03
    1b20:	fd 01       	movw	r30, r26
    1b22:	32 83       	std	Z+2, r19	; 0x02
    1b24:	21 83       	std	Z+1, r18	; 0x01
    1b26:	fc 01       	movw	r30, r24
    1b28:	ee 0f       	add	r30, r30
    1b2a:	ff 1f       	adc	r31, r31
    1b2c:	ee 0f       	add	r30, r30
    1b2e:	ff 1f       	adc	r31, r31
    1b30:	ee 0f       	add	r30, r30
    1b32:	ff 1f       	adc	r31, r31
    1b34:	8e 0f       	add	r24, r30
    1b36:	9f 1f       	adc	r25, r31
    1b38:	fc 01       	movw	r30, r24
    1b3a:	ed 5f       	subi	r30, 0xFD	; 253
    1b3c:	f6 4f       	sbci	r31, 0xF6	; 246
    1b3e:	01 80       	ldd	r0, Z+1	; 0x01
    1b40:	f2 81       	ldd	r31, Z+2	; 0x02
    1b42:	e0 2d       	mov	r30, r0
    1b44:	86 81       	ldd	r24, Z+6	; 0x06
    1b46:	97 81       	ldd	r25, Z+7	; 0x07
    1b48:	90 93 0d 09 	sts	0x090D, r25	; 0x80090d <pxCurrentTCB+0x1>
    1b4c:	80 93 0c 09 	sts	0x090C, r24	; 0x80090c <pxCurrentTCB>
    1b50:	08 95       	ret

00001b52 <_Z12WriteCommandj>:
}

void DisplayOff()
{
	// Send command DisplayOff which is 0x28 in HEX.
	WriteCommand(0x28);
    1b52:	2b b1       	in	r18, 0x0b	; 11
    1b54:	2f 77       	andi	r18, 0x7F	; 127
    1b56:	2b b9       	out	0x0b, r18	; 11
    1b58:	24 b3       	in	r18, 0x14	; 20
    1b5a:	2d 7f       	andi	r18, 0xFD	; 253
    1b5c:	24 bb       	out	0x14, r18	; 20
    1b5e:	00 00       	nop
    1b60:	92 b9       	out	0x02, r25	; 2
    1b62:	88 b9       	out	0x08, r24	; 8
    1b64:	84 b3       	in	r24, 0x14	; 20
    1b66:	8b 7f       	andi	r24, 0xFB	; 251
    1b68:	84 bb       	out	0x14, r24	; 20
    1b6a:	00 00       	nop
    1b6c:	84 b3       	in	r24, 0x14	; 20
    1b6e:	84 60       	ori	r24, 0x04	; 4
    1b70:	84 bb       	out	0x14, r24	; 20
    1b72:	00 00       	nop
    1b74:	84 b3       	in	r24, 0x14	; 20
    1b76:	82 60       	ori	r24, 0x02	; 2
    1b78:	84 bb       	out	0x14, r24	; 20
    1b7a:	08 95       	ret

00001b7c <_Z9WriteDataj>:
    1b7c:	2b b1       	in	r18, 0x0b	; 11
    1b7e:	20 68       	ori	r18, 0x80	; 128
    1b80:	2b b9       	out	0x0b, r18	; 11
    1b82:	24 b3       	in	r18, 0x14	; 20
    1b84:	2d 7f       	andi	r18, 0xFD	; 253
    1b86:	24 bb       	out	0x14, r18	; 20
    1b88:	00 00       	nop
    1b8a:	92 b9       	out	0x02, r25	; 2
    1b8c:	88 b9       	out	0x08, r24	; 8
    1b8e:	84 b3       	in	r24, 0x14	; 20
    1b90:	8b 7f       	andi	r24, 0xFB	; 251
    1b92:	84 bb       	out	0x14, r24	; 20
    1b94:	00 00       	nop
    1b96:	84 b3       	in	r24, 0x14	; 20
    1b98:	84 60       	ori	r24, 0x04	; 4
    1b9a:	84 bb       	out	0x14, r24	; 20
    1b9c:	00 00       	nop
    1b9e:	84 b3       	in	r24, 0x14	; 20
    1ba0:	82 60       	ori	r24, 0x02	; 2
    1ba2:	84 bb       	out	0x14, r24	; 20
    1ba4:	08 95       	ret

00001ba6 <_Z9DisplayOnv>:
}

void DisplayOn()
{
	// Send command DisplayOn which is 0x29 in HEX.
	WriteCommand(0x29);
    1ba6:	89 e2       	ldi	r24, 0x29	; 41
    1ba8:	90 e0       	ldi	r25, 0x00	; 0
    1baa:	d3 cf       	rjmp	.-90     	; 0x1b52 <_Z12WriteCommandj>
    1bac:	08 95       	ret

00001bae <_Z8SleepOutv>:
}

void SleepOut()
{
	// Send command SleepOut which is 0x11 in HEX. 
	WriteCommand(0x11);
    1bae:	81 e1       	ldi	r24, 0x11	; 17
    1bb0:	90 e0       	ldi	r25, 0x00	; 0
    1bb2:	cf cf       	rjmp	.-98     	; 0x1b52 <_Z12WriteCommandj>
    1bb4:	08 95       	ret

00001bb6 <_Z19MemoryAccessControlh>:
}

void MemoryAccessControl(unsigned char parameter)
{
    1bb6:	cf 93       	push	r28
    1bb8:	c8 2f       	mov	r28, r24
	WriteCommand(0x36);
    1bba:	86 e3       	ldi	r24, 0x36	; 54
    1bbc:	90 e0       	ldi	r25, 0x00	; 0
    1bbe:	c9 df       	rcall	.-110    	; 0x1b52 <_Z12WriteCommandj>
	WriteData(parameter);
    1bc0:	8c 2f       	mov	r24, r28
    1bc2:	90 e0       	ldi	r25, 0x00	; 0
    1bc4:	db df       	rcall	.-74     	; 0x1b7c <_Z9WriteDataj>
}
    1bc6:	cf 91       	pop	r28
    1bc8:	08 95       	ret

00001bca <_Z20InterfacePixelFormath>:

void InterfacePixelFormat(unsigned char parameter)
{
    1bca:	cf 93       	push	r28
    1bcc:	c8 2f       	mov	r28, r24
	WriteCommand(0x3A);
    1bce:	8a e3       	ldi	r24, 0x3A	; 58
    1bd0:	90 e0       	ldi	r25, 0x00	; 0
    1bd2:	bf df       	rcall	.-130    	; 0x1b52 <_Z12WriteCommandj>
	WriteData(parameter);
    1bd4:	8c 2f       	mov	r24, r28
    1bd6:	90 e0       	ldi	r25, 0x00	; 0
    1bd8:	d1 df       	rcall	.-94     	; 0x1b7c <_Z9WriteDataj>
}
    1bda:	cf 91       	pop	r28
    1bdc:	08 95       	ret

00001bde <_Z11DisplayInitv>:

// Initializes (resets) the display
void DisplayInit()
{
	// Control pins are outputs
	DDRG |= 0b00000111;
    1bde:	83 b3       	in	r24, 0x13	; 19
    1be0:	87 60       	ori	r24, 0x07	; 7
    1be2:	83 bb       	out	0x13, r24	; 19
	DDRD |= 0b10000000;
    1be4:	8a b1       	in	r24, 0x0a	; 10
    1be6:	80 68       	ori	r24, 0x80	; 128
    1be8:	8a b9       	out	0x0a, r24	; 10
	
	// Data pins are outputs
	DDRA = 0xFF;
    1bea:	8f ef       	ldi	r24, 0xFF	; 255
    1bec:	81 b9       	out	0x01, r24	; 1
	DDRC = 0xFF;
    1bee:	87 b9       	out	0x07, r24	; 7
	
	// All control pins high;
	PORTG |= 0b00000111;
    1bf0:	84 b3       	in	r24, 0x14	; 20
    1bf2:	87 60       	ori	r24, 0x07	; 7
    1bf4:	84 bb       	out	0x14, r24	; 20
	PORTD |= 0b10000000;
    1bf6:	8b b1       	in	r24, 0x0b	; 11
    1bf8:	80 68       	ori	r24, 0x80	; 128
    1bfa:	8b b9       	out	0x0b, r24	; 11
	
	// Pull reset pin - Wait min 10 uS
	RST_PORT &= ~(1 << RST_BIT);
    1bfc:	84 b3       	in	r24, 0x14	; 20
    1bfe:	8e 7f       	andi	r24, 0xFE	; 254
    1c00:	84 bb       	out	0x14, r24	; 20
	vTaskDelay( 500 / portTICK_RATE_MS );
    1c02:	84 ef       	ldi	r24, 0xF4	; 244
    1c04:	91 e0       	ldi	r25, 0x01	; 1
    1c06:	2f df       	rcall	.-418    	; 0x1a66 <vTaskDelay>
	RST_PORT |= (1 << RST_BIT);
    1c08:	84 b3       	in	r24, 0x14	; 20
    1c0a:	81 60       	ori	r24, 0x01	; 1
    1c0c:	84 bb       	out	0x14, r24	; 20
	
	// Wait for display to be rdy
	vTaskDelay( 500 / portTICK_RATE_MS );
    1c0e:	84 ef       	ldi	r24, 0xF4	; 244
    1c10:	91 e0       	ldi	r25, 0x01	; 1
    1c12:	29 df       	rcall	.-430    	; 0x1a66 <vTaskDelay>
	
	// Set pixel interface and memoryaccesscontrol
	InterfacePixelFormat(0b00000101);
    1c14:	85 e0       	ldi	r24, 0x05	; 5
    1c16:	d9 df       	rcall	.-78     	; 0x1bca <_Z20InterfacePixelFormath>
	MemoryAccessControl(0b00001000);
    1c18:	88 e0       	ldi	r24, 0x08	; 8
    1c1a:	cd df       	rcall	.-102    	; 0x1bb6 <_Z19MemoryAccessControlh>
	
	// Call sleepout and display on.
	SleepOut();
    1c1c:	c8 df       	rcall	.-112    	; 0x1bae <_Z8SleepOutv>
    1c1e:	c3 cf       	rjmp	.-122    	; 0x1ba6 <_Z9DisplayOnv>
	DisplayOn();
    1c20:	08 95       	ret

00001c22 <_Z11MemoryWritev>:
    1c22:	8c e2       	ldi	r24, 0x2C	; 44
    1c24:	90 e0       	ldi	r25, 0x00	; 0
	WriteData(parameter);
}

void MemoryWrite()
{
	WriteCommand(0x2C);
    1c26:	95 cf       	rjmp	.-214    	; 0x1b52 <_Z12WriteCommandj>
    1c28:	08 95       	ret

00001c2a <_Z10WritePixelhhh>:
}

// Red 0-31, Green 0-63, Blue 0-31
void WritePixel(unsigned char Red, unsigned char Green, unsigned char Blue)
{
	uint16_t toSend = (Red << 11U) | (Green << 5U) | (Blue);
    1c2a:	90 e0       	ldi	r25, 0x00	; 0
    1c2c:	98 2f       	mov	r25, r24
    1c2e:	88 27       	eor	r24, r24
    1c30:	99 0f       	add	r25, r25
    1c32:	99 0f       	add	r25, r25
    1c34:	99 0f       	add	r25, r25
    1c36:	20 e2       	ldi	r18, 0x20	; 32
    1c38:	62 9f       	mul	r22, r18
    1c3a:	b0 01       	movw	r22, r0
    1c3c:	11 24       	eor	r1, r1
    1c3e:	86 2b       	or	r24, r22
    1c40:	97 2b       	or	r25, r23
	WriteData(toSend);
    1c42:	84 2b       	or	r24, r20
    1c44:	9b cf       	rjmp	.-202    	; 0x1b7c <_Z9WriteDataj>
    1c46:	08 95       	ret

00001c48 <_Z16SetColumnAddressjj>:
}

// Set Column Address (0-239), Start > End
void SetColumnAddress(unsigned int Start, unsigned int End)
{
    1c48:	0f 93       	push	r16
    1c4a:	1f 93       	push	r17
    1c4c:	cf 93       	push	r28
    1c4e:	df 93       	push	r29
	if (Start < End)
    1c50:	86 17       	cp	r24, r22
    1c52:	97 07       	cpc	r25, r23
    1c54:	78 f4       	brcc	.+30     	; 0x1c74 <_Z16SetColumnAddressjj+0x2c>
    1c56:	eb 01       	movw	r28, r22
    1c58:	8c 01       	movw	r16, r24
	{
		WriteCommand(0x2A);
    1c5a:	8a e2       	ldi	r24, 0x2A	; 42
    1c5c:	90 e0       	ldi	r25, 0x00	; 0
    1c5e:	79 df       	rcall	.-270    	; 0x1b52 <_Z12WriteCommandj>
		WriteData(Start >> 8U);
    1c60:	81 2f       	mov	r24, r17
    1c62:	90 e0       	ldi	r25, 0x00	; 0
    1c64:	8b df       	rcall	.-234    	; 0x1b7c <_Z9WriteDataj>
		WriteData(Start);
    1c66:	c8 01       	movw	r24, r16
    1c68:	89 df       	rcall	.-238    	; 0x1b7c <_Z9WriteDataj>
		WriteData(End >> 8U);
    1c6a:	8d 2f       	mov	r24, r29
    1c6c:	90 e0       	ldi	r25, 0x00	; 0
    1c6e:	86 df       	rcall	.-244    	; 0x1b7c <_Z9WriteDataj>
		WriteData(End);
    1c70:	ce 01       	movw	r24, r28
    1c72:	84 df       	rcall	.-248    	; 0x1b7c <_Z9WriteDataj>
    1c74:	df 91       	pop	r29
	}
}
    1c76:	cf 91       	pop	r28
    1c78:	1f 91       	pop	r17
    1c7a:	0f 91       	pop	r16
    1c7c:	08 95       	ret

00001c7e <_Z14SetPageAddressjj>:
    1c7e:	0f 93       	push	r16

// Set Page Address (0-319), Start > End
void SetPageAddress(unsigned int Start, unsigned int End)
{
    1c80:	1f 93       	push	r17
    1c82:	cf 93       	push	r28
    1c84:	df 93       	push	r29
	if (Start < End)
    1c86:	86 17       	cp	r24, r22
    1c88:	97 07       	cpc	r25, r23
    1c8a:	78 f4       	brcc	.+30     	; 0x1caa <_Z14SetPageAddressjj+0x2c>
    1c8c:	eb 01       	movw	r28, r22
    1c8e:	8c 01       	movw	r16, r24
	{
		WriteCommand(0x2B);
    1c90:	8b e2       	ldi	r24, 0x2B	; 43
    1c92:	90 e0       	ldi	r25, 0x00	; 0
    1c94:	5e df       	rcall	.-324    	; 0x1b52 <_Z12WriteCommandj>
		WriteData(Start >> 8U);
    1c96:	81 2f       	mov	r24, r17
    1c98:	90 e0       	ldi	r25, 0x00	; 0
    1c9a:	70 df       	rcall	.-288    	; 0x1b7c <_Z9WriteDataj>
		WriteData(Start);
    1c9c:	c8 01       	movw	r24, r16
    1c9e:	6e df       	rcall	.-292    	; 0x1b7c <_Z9WriteDataj>
		WriteData(End >> 8U);
    1ca0:	8d 2f       	mov	r24, r29
    1ca2:	90 e0       	ldi	r25, 0x00	; 0
    1ca4:	6b df       	rcall	.-298    	; 0x1b7c <_Z9WriteDataj>
		WriteData(End);
    1ca6:	ce 01       	movw	r24, r28
    1ca8:	69 df       	rcall	.-302    	; 0x1b7c <_Z9WriteDataj>
    1caa:	df 91       	pop	r29
	}
}
    1cac:	cf 91       	pop	r28
    1cae:	1f 91       	pop	r17
    1cb0:	0f 91       	pop	r16
    1cb2:	08 95       	ret

00001cb4 <_Z13FillRectanglejjjjhhh>:
    1cb4:	6f 92       	push	r6
// Fills rectangle with specified color
// (StartX,StartY) = Upper left corner. X horizontal (0-319) , Y vertical (0-239).
// Height (1-240) is vertical. Width (1-320) is horizontal.
// R-G-B = 5-6-5 bits.
void FillRectangle(unsigned int StartX, unsigned int StartY, unsigned int Width, unsigned int Height, unsigned char Blue, unsigned char Green, unsigned char Red)
{
    1cb6:	7f 92       	push	r7
    1cb8:	8f 92       	push	r8
    1cba:	9f 92       	push	r9
    1cbc:	af 92       	push	r10
    1cbe:	bf 92       	push	r11
    1cc0:	cf 92       	push	r12
    1cc2:	ef 92       	push	r14
    1cc4:	0f 93       	push	r16
    1cc6:	cf 93       	push	r28
    1cc8:	df 93       	push	r29
    1cca:	5b 01       	movw	r10, r22
    1ccc:	3a 01       	movw	r6, r20
    1cce:	e9 01       	movw	r28, r18
	SetPageAddress(StartX,StartX+Width-1);
    1cd0:	bc 01       	movw	r22, r24
    1cd2:	64 0f       	add	r22, r20
    1cd4:	75 1f       	adc	r23, r21
    1cd6:	61 50       	subi	r22, 0x01	; 1
    1cd8:	71 09       	sbc	r23, r1
    1cda:	d1 df       	rcall	.-94     	; 0x1c7e <_Z14SetPageAddressjj>
	SetColumnAddress(StartY,StartY+Height-1);
    1cdc:	b5 01       	movw	r22, r10
    1cde:	6c 0f       	add	r22, r28
    1ce0:	7d 1f       	adc	r23, r29
    1ce2:	61 50       	subi	r22, 0x01	; 1
    1ce4:	71 09       	sbc	r23, r1
    1ce6:	c5 01       	movw	r24, r10
	MemoryWrite();
    1ce8:	af df       	rcall	.-162    	; 0x1c48 <_Z16SetColumnAddressjj>
    1cea:	9b df       	rcall	.-202    	; 0x1c22 <_Z11MemoryWritev>
	
	for (uint32_t counter = 0; counter < (uint32_t)Width*Height; counter++)
    1cec:	81 2c       	mov	r8, r1
    1cee:	91 2c       	mov	r9, r1
    1cf0:	54 01       	movw	r10, r8
    1cf2:	93 01       	movw	r18, r6
    1cf4:	de 01       	movw	r26, r28
    1cf6:	75 d2       	rcall	.+1258   	; 0x21e2 <__umulhisi3>
    1cf8:	86 16       	cp	r8, r22
    1cfa:	97 06       	cpc	r9, r23
    1cfc:	a8 06       	cpc	r10, r24
    1cfe:	b9 06       	cpc	r11, r25
	{
		WritePixel(Red,Green,Blue);
    1d00:	50 f4       	brcc	.+20     	; 0x1d16 <_Z13FillRectanglejjjjhhh+0x62>
    1d02:	40 2f       	mov	r20, r16
    1d04:	6e 2d       	mov	r22, r14
    1d06:	8c 2d       	mov	r24, r12
    1d08:	90 df       	rcall	.-224    	; 0x1c2a <_Z10WritePixelhhh>
{
	SetPageAddress(StartX,StartX+Width-1);
	SetColumnAddress(StartY,StartY+Height-1);
	MemoryWrite();
	
	for (uint32_t counter = 0; counter < (uint32_t)Width*Height; counter++)
    1d0a:	8f ef       	ldi	r24, 0xFF	; 255
    1d0c:	88 1a       	sub	r8, r24
    1d0e:	98 0a       	sbc	r9, r24
    1d10:	a8 0a       	sbc	r10, r24
    1d12:	b8 0a       	sbc	r11, r24
	{
		WritePixel(Red,Green,Blue);
	}
	SleepOut();
    1d14:	ee cf       	rjmp	.-36     	; 0x1cf2 <_Z13FillRectanglejjjjhhh+0x3e>
    1d16:	4b df       	rcall	.-362    	; 0x1bae <_Z8SleepOutv>
}
    1d18:	df 91       	pop	r29
    1d1a:	cf 91       	pop	r28
    1d1c:	0f 91       	pop	r16
    1d1e:	ef 90       	pop	r14
    1d20:	cf 90       	pop	r12
    1d22:	bf 90       	pop	r11
    1d24:	af 90       	pop	r10
    1d26:	9f 90       	pop	r9
    1d28:	8f 90       	pop	r8
    1d2a:	7f 90       	pop	r7
    1d2c:	6f 90       	pop	r6
    1d2e:	08 95       	ret

00001d30 <_ZN11TouchscreenC1Ev>:
	else
	{
		return 0;
	}
	
}
    1d30:	0f 93       	push	r16
    1d32:	1f 93       	push	r17
    1d34:	cf 93       	push	r28
    1d36:	df 93       	push	r29
    1d38:	cd b7       	in	r28, 0x3d	; 61
    1d3a:	de b7       	in	r29, 0x3e	; 62
    1d3c:	66 97       	sbiw	r28, 0x16	; 22
    1d3e:	0f b6       	in	r0, 0x3f	; 63
    1d40:	f8 94       	cli
    1d42:	de bf       	out	0x3e, r29	; 62
    1d44:	0f be       	out	0x3f, r0	; 63
    1d46:	cd bf       	out	0x3d, r28	; 61
    1d48:	8c 01       	movw	r16, r24
    1d4a:	87 d0       	rcall	.+270    	; 0x1e5a <_ZN11TouchDriverC1Ev>
    1d4c:	f8 01       	movw	r30, r16
    1d4e:	12 82       	std	Z+2, r1	; 0x02
    1d50:	13 82       	std	Z+3, r1	; 0x03
    1d52:	14 82       	std	Z+4, r1	; 0x04
    1d54:	15 82       	std	Z+5, r1	; 0x05
    1d56:	16 82       	std	Z+6, r1	; 0x06
    1d58:	17 82       	std	Z+7, r1	; 0x07
    1d5a:	10 86       	std	Z+8, r1	; 0x08
    1d5c:	12 86       	std	Z+10, r1	; 0x0a
    1d5e:	11 86       	std	Z+9, r1	; 0x09
    1d60:	13 86       	std	Z+11, r1	; 0x0b
    1d62:	14 86       	std	Z+12, r1	; 0x0c
    1d64:	15 86       	std	Z+13, r1	; 0x0d
    1d66:	16 86       	std	Z+14, r1	; 0x0e
    1d68:	17 86       	std	Z+15, r1	; 0x0f
    1d6a:	10 8a       	std	Z+16, r1	; 0x10
    1d6c:	11 8a       	std	Z+17, r1	; 0x11
    1d6e:	12 8a       	std	Z+18, r1	; 0x12
    1d70:	14 8a       	std	Z+20, r1	; 0x14
    1d72:	13 8a       	std	Z+19, r1	; 0x13
    1d74:	15 8a       	std	Z+21, r1	; 0x15
    1d76:	ce 01       	movw	r24, r28
    1d78:	45 96       	adiw	r24, 0x15	; 21
    1d7a:	6f d0       	rcall	.+222    	; 0x1e5a <_ZN11TouchDriverC1Ev>
    1d7c:	8d 89       	ldd	r24, Y+21	; 0x15
    1d7e:	9e 89       	ldd	r25, Y+22	; 0x16
    1d80:	d8 01       	movw	r26, r16
    1d82:	8d 93       	st	X+, r24
    1d84:	9d 93       	st	X+, r25
    1d86:	84 e1       	ldi	r24, 0x14	; 20
    1d88:	8b 87       	std	Y+11, r24	; 0x0b
    1d8a:	46 e4       	ldi	r20, 0x46	; 70
    1d8c:	4c 87       	std	Y+12, r20	; 0x0c
    1d8e:	88 e7       	ldi	r24, 0x78	; 120
    1d90:	90 e0       	ldi	r25, 0x00	; 0
    1d92:	9b 8b       	std	Y+19, r25	; 0x13
    1d94:	8a 8b       	std	Y+18, r24	; 0x12
    1d96:	3a ea       	ldi	r19, 0xAA	; 170
    1d98:	3c 8b       	std	Y+20, r19	; 0x14
    1d9a:	84 e6       	ldi	r24, 0x64	; 100
    1d9c:	8e 87       	std	Y+14, r24	; 0x0e
    1d9e:	8d 87       	std	Y+13, r24	; 0x0d
    1da0:	9d e1       	ldi	r25, 0x1D	; 29
    1da2:	9f 87       	std	Y+15, r25	; 0x0f
    1da4:	9a ee       	ldi	r25, 0xEA	; 234
    1da6:	98 8b       	std	Y+16, r25	; 0x10
    1da8:	22 e0       	ldi	r18, 0x02	; 2
    1daa:	29 8b       	std	Y+17, r18	; 0x11
    1dac:	5a e0       	ldi	r21, 0x0A	; 10
    1dae:	fe 01       	movw	r30, r28
    1db0:	3b 96       	adiw	r30, 0x0b	; 11
    1db2:	01 90       	ld	r0, Z+
    1db4:	0d 92       	st	X+, r0
    1db6:	5a 95       	dec	r21
    1db8:	e1 f7       	brne	.-8      	; 0x1db2 <_ZN11TouchscreenC1Ev+0x82>
    1dba:	58 ec       	ldi	r21, 0xC8	; 200
    1dbc:	59 83       	std	Y+1, r21	; 0x01
    1dbe:	4a 83       	std	Y+2, r20	; 0x02
    1dc0:	4c e2       	ldi	r20, 0x2C	; 44
    1dc2:	51 e0       	ldi	r21, 0x01	; 1
    1dc4:	59 87       	std	Y+9, r21	; 0x09
    1dc6:	48 87       	std	Y+8, r20	; 0x08
    1dc8:	3a 87       	std	Y+10, r19	; 0x0a
    1dca:	8c 83       	std	Y+4, r24	; 0x04
    1dcc:	8b 83       	std	Y+3, r24	; 0x03
    1dce:	8c e2       	ldi	r24, 0x2C	; 44
    1dd0:	8d 83       	std	Y+5, r24	; 0x05
    1dd2:	2e 83       	std	Y+6, r18	; 0x06
    1dd4:	9f 83       	std	Y+7, r25	; 0x07
    1dd6:	8a e0       	ldi	r24, 0x0A	; 10
    1dd8:	fe 01       	movw	r30, r28
    1dda:	31 96       	adiw	r30, 0x01	; 1
    1ddc:	d8 01       	movw	r26, r16
    1dde:	1c 96       	adiw	r26, 0x0c	; 12
    1de0:	01 90       	ld	r0, Z+
    1de2:	0d 92       	st	X+, r0
    1de4:	8a 95       	dec	r24
    1de6:	e1 f7       	brne	.-8      	; 0x1de0 <_ZN11TouchscreenC1Ev+0xb0>
    1de8:	fa de       	rcall	.-524    	; 0x1bde <_Z11DisplayInitv>
    1dea:	66 96       	adiw	r28, 0x16	; 22
    1dec:	0f b6       	in	r0, 0x3f	; 63
    1dee:	f8 94       	cli
    1df0:	de bf       	out	0x3e, r29	; 62
    1df2:	0f be       	out	0x3f, r0	; 63
    1df4:	cd bf       	out	0x3d, r28	; 61
    1df6:	df 91       	pop	r29
    1df8:	cf 91       	pop	r28
    1dfa:	1f 91       	pop	r17
    1dfc:	0f 91       	pop	r16
    1dfe:	08 95       	ret

00001e00 <_ZN11Touchscreen11clearScreenEv>:

void Touchscreen::clearScreen(void)
{
    1e00:	cf 92       	push	r12
    1e02:	ef 92       	push	r14
    1e04:	0f 93       	push	r16
	// Full Screen White
	FillRectangle(0,0,320,240,255,255,255);
    1e06:	cc 24       	eor	r12, r12
    1e08:	ca 94       	dec	r12
    1e0a:	ee 24       	eor	r14, r14
    1e0c:	ea 94       	dec	r14
    1e0e:	0f ef       	ldi	r16, 0xFF	; 255
    1e10:	20 ef       	ldi	r18, 0xF0	; 240
    1e12:	30 e0       	ldi	r19, 0x00	; 0
    1e14:	40 e4       	ldi	r20, 0x40	; 64
    1e16:	51 e0       	ldi	r21, 0x01	; 1
    1e18:	60 e0       	ldi	r22, 0x00	; 0
    1e1a:	70 e0       	ldi	r23, 0x00	; 0
    1e1c:	80 e0       	ldi	r24, 0x00	; 0
    1e1e:	90 e0       	ldi	r25, 0x00	; 0
    1e20:	49 df       	rcall	.-366    	; 0x1cb4 <_Z13FillRectanglejjjjhhh>
}
    1e22:	0f 91       	pop	r16
    1e24:	ef 90       	pop	r14
    1e26:	cf 90       	pop	r12
    1e28:	08 95       	ret

00001e2a <_ZN11TouchDriver15initTouchDriverEv>:
	/* MODE							= 12bit = High							*/
	/* SER/DFR						= Differential = Low					*/
	/* PD1/PD0						= Device always powered = 11			*/
	/************************************************************************/
	
	dinXByte = 0b10011100;
    1e2a:	2c e9       	ldi	r18, 0x9C	; 156
    1e2c:	fc 01       	movw	r30, r24
    1e2e:	20 83       	st	Z, r18
	dinYByte = 0b11011100;
    1e30:	2c ed       	ldi	r18, 0xDC	; 220
    1e32:	21 83       	std	Z+1, r18	; 0x01
	
	DDRH |= BIT4;
    1e34:	e1 e0       	ldi	r30, 0x01	; 1
    1e36:	f1 e0       	ldi	r31, 0x01	; 1
    1e38:	80 81       	ld	r24, Z
    1e3a:	84 60       	ori	r24, 0x04	; 4
    1e3c:	80 83       	st	Z, r24
	DDRE |= BIT4;
    1e3e:	8d b1       	in	r24, 0x0d	; 13
    1e40:	84 60       	ori	r24, 0x04	; 4
    1e42:	8d b9       	out	0x0d, r24	; 13
	DDRG |= BIT6;
    1e44:	83 b3       	in	r24, 0x13	; 19
    1e46:	86 60       	ori	r24, 0x06	; 6
    1e48:	83 bb       	out	0x13, r24	; 19
	
	// Enable Interrupt
	EICRB = 00000010;
    1e4a:	88 e0       	ldi	r24, 0x08	; 8
    1e4c:	80 93 6a 00 	sts	0x006A, r24	; 0x80006a <__TEXT_REGION_LENGTH__+0x70006a>
	EIMSK |= 0b00010000;
    1e50:	8d b3       	in	r24, 0x1d	; 29
    1e52:	80 61       	ori	r24, 0x10	; 16
    1e54:	8d bb       	out	0x1d, r24	; 29
	
	sei();
    1e56:	78 94       	sei
    1e58:	08 95       	ret

00001e5a <_ZN11TouchDriverC1Ev>:
/* PE4 = IRQ (Not Used)													*/
/************************************************************************/

TouchDriver::TouchDriver()
{
	initTouchDriver();
    1e5a:	e7 cf       	rjmp	.-50     	; 0x1e2a <_ZN11TouchDriver15initTouchDriverEv>
    1e5c:	08 95       	ret

00001e5e <__vector_5>:
	sei();
	
}

ISR (INT4_vect)
{
    1e5e:	1f 92       	push	r1
    1e60:	0f 92       	push	r0
    1e62:	0f b6       	in	r0, 0x3f	; 63
    1e64:	0f 92       	push	r0
    1e66:	11 24       	eor	r1, r1
	eIntHappend = 0;
    1e68:	10 92 0d 02 	sts	0x020D, r1	; 0x80020d <eIntHappend>
}
    1e6c:	0f 90       	pop	r0
    1e6e:	0f be       	out	0x3f, r0	; 63
    1e70:	0f 90       	pop	r0
    1e72:	1f 90       	pop	r1
    1e74:	18 95       	reti

00001e76 <__subsf3>:
    1e76:	50 58       	subi	r21, 0x80	; 128

00001e78 <__addsf3>:
    1e78:	bb 27       	eor	r27, r27
    1e7a:	aa 27       	eor	r26, r26
    1e7c:	0e d0       	rcall	.+28     	; 0x1e9a <__addsf3x>
    1e7e:	08 c1       	rjmp	.+528    	; 0x2090 <__fp_round>
    1e80:	f9 d0       	rcall	.+498    	; 0x2074 <__fp_pscA>
    1e82:	30 f0       	brcs	.+12     	; 0x1e90 <__addsf3+0x18>
    1e84:	fe d0       	rcall	.+508    	; 0x2082 <__fp_pscB>
    1e86:	20 f0       	brcs	.+8      	; 0x1e90 <__addsf3+0x18>
    1e88:	31 f4       	brne	.+12     	; 0x1e96 <__addsf3+0x1e>
    1e8a:	9f 3f       	cpi	r25, 0xFF	; 255
    1e8c:	11 f4       	brne	.+4      	; 0x1e92 <__addsf3+0x1a>
    1e8e:	1e f4       	brtc	.+6      	; 0x1e96 <__addsf3+0x1e>
    1e90:	ee c0       	rjmp	.+476    	; 0x206e <__fp_nan>
    1e92:	0e f4       	brtc	.+2      	; 0x1e96 <__addsf3+0x1e>
    1e94:	e0 95       	com	r30
    1e96:	e7 fb       	bst	r30, 7
    1e98:	e4 c0       	rjmp	.+456    	; 0x2062 <__fp_inf>

00001e9a <__addsf3x>:
    1e9a:	e9 2f       	mov	r30, r25
    1e9c:	0a d1       	rcall	.+532    	; 0x20b2 <__fp_split3>
    1e9e:	80 f3       	brcs	.-32     	; 0x1e80 <__addsf3+0x8>
    1ea0:	ba 17       	cp	r27, r26
    1ea2:	62 07       	cpc	r22, r18
    1ea4:	73 07       	cpc	r23, r19
    1ea6:	84 07       	cpc	r24, r20
    1ea8:	95 07       	cpc	r25, r21
    1eaa:	18 f0       	brcs	.+6      	; 0x1eb2 <__addsf3x+0x18>
    1eac:	71 f4       	brne	.+28     	; 0x1eca <__addsf3x+0x30>
    1eae:	9e f5       	brtc	.+102    	; 0x1f16 <__addsf3x+0x7c>
    1eb0:	22 c1       	rjmp	.+580    	; 0x20f6 <__fp_zero>
    1eb2:	0e f4       	brtc	.+2      	; 0x1eb6 <__addsf3x+0x1c>
    1eb4:	e0 95       	com	r30
    1eb6:	0b 2e       	mov	r0, r27
    1eb8:	ba 2f       	mov	r27, r26
    1eba:	a0 2d       	mov	r26, r0
    1ebc:	0b 01       	movw	r0, r22
    1ebe:	b9 01       	movw	r22, r18
    1ec0:	90 01       	movw	r18, r0
    1ec2:	0c 01       	movw	r0, r24
    1ec4:	ca 01       	movw	r24, r20
    1ec6:	a0 01       	movw	r20, r0
    1ec8:	11 24       	eor	r1, r1
    1eca:	ff 27       	eor	r31, r31
    1ecc:	59 1b       	sub	r21, r25
    1ece:	99 f0       	breq	.+38     	; 0x1ef6 <__addsf3x+0x5c>
    1ed0:	59 3f       	cpi	r21, 0xF9	; 249
    1ed2:	50 f4       	brcc	.+20     	; 0x1ee8 <__addsf3x+0x4e>
    1ed4:	50 3e       	cpi	r21, 0xE0	; 224
    1ed6:	68 f1       	brcs	.+90     	; 0x1f32 <__addsf3x+0x98>
    1ed8:	1a 16       	cp	r1, r26
    1eda:	f0 40       	sbci	r31, 0x00	; 0
    1edc:	a2 2f       	mov	r26, r18
    1ede:	23 2f       	mov	r18, r19
    1ee0:	34 2f       	mov	r19, r20
    1ee2:	44 27       	eor	r20, r20
    1ee4:	58 5f       	subi	r21, 0xF8	; 248
    1ee6:	f3 cf       	rjmp	.-26     	; 0x1ece <__addsf3x+0x34>
    1ee8:	46 95       	lsr	r20
    1eea:	37 95       	ror	r19
    1eec:	27 95       	ror	r18
    1eee:	a7 95       	ror	r26
    1ef0:	f0 40       	sbci	r31, 0x00	; 0
    1ef2:	53 95       	inc	r21
    1ef4:	c9 f7       	brne	.-14     	; 0x1ee8 <__addsf3x+0x4e>
    1ef6:	7e f4       	brtc	.+30     	; 0x1f16 <__addsf3x+0x7c>
    1ef8:	1f 16       	cp	r1, r31
    1efa:	ba 0b       	sbc	r27, r26
    1efc:	62 0b       	sbc	r22, r18
    1efe:	73 0b       	sbc	r23, r19
    1f00:	84 0b       	sbc	r24, r20
    1f02:	ba f0       	brmi	.+46     	; 0x1f32 <__addsf3x+0x98>
    1f04:	91 50       	subi	r25, 0x01	; 1
    1f06:	a1 f0       	breq	.+40     	; 0x1f30 <__addsf3x+0x96>
    1f08:	ff 0f       	add	r31, r31
    1f0a:	bb 1f       	adc	r27, r27
    1f0c:	66 1f       	adc	r22, r22
    1f0e:	77 1f       	adc	r23, r23
    1f10:	88 1f       	adc	r24, r24
    1f12:	c2 f7       	brpl	.-16     	; 0x1f04 <__addsf3x+0x6a>
    1f14:	0e c0       	rjmp	.+28     	; 0x1f32 <__addsf3x+0x98>
    1f16:	ba 0f       	add	r27, r26
    1f18:	62 1f       	adc	r22, r18
    1f1a:	73 1f       	adc	r23, r19
    1f1c:	84 1f       	adc	r24, r20
    1f1e:	48 f4       	brcc	.+18     	; 0x1f32 <__addsf3x+0x98>
    1f20:	87 95       	ror	r24
    1f22:	77 95       	ror	r23
    1f24:	67 95       	ror	r22
    1f26:	b7 95       	ror	r27
    1f28:	f7 95       	ror	r31
    1f2a:	9e 3f       	cpi	r25, 0xFE	; 254
    1f2c:	08 f0       	brcs	.+2      	; 0x1f30 <__addsf3x+0x96>
    1f2e:	b3 cf       	rjmp	.-154    	; 0x1e96 <__addsf3+0x1e>
    1f30:	93 95       	inc	r25
    1f32:	88 0f       	add	r24, r24
    1f34:	08 f0       	brcs	.+2      	; 0x1f38 <__addsf3x+0x9e>
    1f36:	99 27       	eor	r25, r25
    1f38:	ee 0f       	add	r30, r30
    1f3a:	97 95       	ror	r25
    1f3c:	87 95       	ror	r24
    1f3e:	08 95       	ret

00001f40 <__cmpsf2>:
    1f40:	6c d0       	rcall	.+216    	; 0x201a <__fp_cmp>
    1f42:	08 f4       	brcc	.+2      	; 0x1f46 <__cmpsf2+0x6>
    1f44:	81 e0       	ldi	r24, 0x01	; 1
    1f46:	08 95       	ret

00001f48 <__fixunssfsi>:
    1f48:	bc d0       	rcall	.+376    	; 0x20c2 <__fp_splitA>
    1f4a:	88 f0       	brcs	.+34     	; 0x1f6e <__fixunssfsi+0x26>
    1f4c:	9f 57       	subi	r25, 0x7F	; 127
    1f4e:	90 f0       	brcs	.+36     	; 0x1f74 <__fixunssfsi+0x2c>
    1f50:	b9 2f       	mov	r27, r25
    1f52:	99 27       	eor	r25, r25
    1f54:	b7 51       	subi	r27, 0x17	; 23
    1f56:	a0 f0       	brcs	.+40     	; 0x1f80 <__fixunssfsi+0x38>
    1f58:	d1 f0       	breq	.+52     	; 0x1f8e <__fixunssfsi+0x46>
    1f5a:	66 0f       	add	r22, r22
    1f5c:	77 1f       	adc	r23, r23
    1f5e:	88 1f       	adc	r24, r24
    1f60:	99 1f       	adc	r25, r25
    1f62:	1a f0       	brmi	.+6      	; 0x1f6a <__fixunssfsi+0x22>
    1f64:	ba 95       	dec	r27
    1f66:	c9 f7       	brne	.-14     	; 0x1f5a <__fixunssfsi+0x12>
    1f68:	12 c0       	rjmp	.+36     	; 0x1f8e <__fixunssfsi+0x46>
    1f6a:	b1 30       	cpi	r27, 0x01	; 1
    1f6c:	81 f0       	breq	.+32     	; 0x1f8e <__fixunssfsi+0x46>
    1f6e:	c3 d0       	rcall	.+390    	; 0x20f6 <__fp_zero>
    1f70:	b1 e0       	ldi	r27, 0x01	; 1
    1f72:	08 95       	ret
    1f74:	c0 c0       	rjmp	.+384    	; 0x20f6 <__fp_zero>
    1f76:	67 2f       	mov	r22, r23
    1f78:	78 2f       	mov	r23, r24
    1f7a:	88 27       	eor	r24, r24
    1f7c:	b8 5f       	subi	r27, 0xF8	; 248
    1f7e:	39 f0       	breq	.+14     	; 0x1f8e <__fixunssfsi+0x46>
    1f80:	b9 3f       	cpi	r27, 0xF9	; 249
    1f82:	cc f3       	brlt	.-14     	; 0x1f76 <__fixunssfsi+0x2e>
    1f84:	86 95       	lsr	r24
    1f86:	77 95       	ror	r23
    1f88:	67 95       	ror	r22
    1f8a:	b3 95       	inc	r27
    1f8c:	d9 f7       	brne	.-10     	; 0x1f84 <__fixunssfsi+0x3c>
    1f8e:	3e f4       	brtc	.+14     	; 0x1f9e <__fixunssfsi+0x56>
    1f90:	90 95       	com	r25
    1f92:	80 95       	com	r24
    1f94:	70 95       	com	r23
    1f96:	61 95       	neg	r22
    1f98:	7f 4f       	sbci	r23, 0xFF	; 255
    1f9a:	8f 4f       	sbci	r24, 0xFF	; 255
    1f9c:	9f 4f       	sbci	r25, 0xFF	; 255
    1f9e:	08 95       	ret

00001fa0 <__floatunsisf>:
    1fa0:	e8 94       	clt
    1fa2:	09 c0       	rjmp	.+18     	; 0x1fb6 <__floatsisf+0x12>

00001fa4 <__floatsisf>:
    1fa4:	97 fb       	bst	r25, 7
    1fa6:	3e f4       	brtc	.+14     	; 0x1fb6 <__floatsisf+0x12>
    1fa8:	90 95       	com	r25
    1faa:	80 95       	com	r24
    1fac:	70 95       	com	r23
    1fae:	61 95       	neg	r22
    1fb0:	7f 4f       	sbci	r23, 0xFF	; 255
    1fb2:	8f 4f       	sbci	r24, 0xFF	; 255
    1fb4:	9f 4f       	sbci	r25, 0xFF	; 255
    1fb6:	99 23       	and	r25, r25
    1fb8:	a9 f0       	breq	.+42     	; 0x1fe4 <__floatsisf+0x40>
    1fba:	f9 2f       	mov	r31, r25
    1fbc:	96 e9       	ldi	r25, 0x96	; 150
    1fbe:	bb 27       	eor	r27, r27
    1fc0:	93 95       	inc	r25
    1fc2:	f6 95       	lsr	r31
    1fc4:	87 95       	ror	r24
    1fc6:	77 95       	ror	r23
    1fc8:	67 95       	ror	r22
    1fca:	b7 95       	ror	r27
    1fcc:	f1 11       	cpse	r31, r1
    1fce:	f8 cf       	rjmp	.-16     	; 0x1fc0 <__floatsisf+0x1c>
    1fd0:	fa f4       	brpl	.+62     	; 0x2010 <__floatsisf+0x6c>
    1fd2:	bb 0f       	add	r27, r27
    1fd4:	11 f4       	brne	.+4      	; 0x1fda <__floatsisf+0x36>
    1fd6:	60 ff       	sbrs	r22, 0
    1fd8:	1b c0       	rjmp	.+54     	; 0x2010 <__floatsisf+0x6c>
    1fda:	6f 5f       	subi	r22, 0xFF	; 255
    1fdc:	7f 4f       	sbci	r23, 0xFF	; 255
    1fde:	8f 4f       	sbci	r24, 0xFF	; 255
    1fe0:	9f 4f       	sbci	r25, 0xFF	; 255
    1fe2:	16 c0       	rjmp	.+44     	; 0x2010 <__floatsisf+0x6c>
    1fe4:	88 23       	and	r24, r24
    1fe6:	11 f0       	breq	.+4      	; 0x1fec <__floatsisf+0x48>
    1fe8:	96 e9       	ldi	r25, 0x96	; 150
    1fea:	11 c0       	rjmp	.+34     	; 0x200e <__floatsisf+0x6a>
    1fec:	77 23       	and	r23, r23
    1fee:	21 f0       	breq	.+8      	; 0x1ff8 <__floatsisf+0x54>
    1ff0:	9e e8       	ldi	r25, 0x8E	; 142
    1ff2:	87 2f       	mov	r24, r23
    1ff4:	76 2f       	mov	r23, r22
    1ff6:	05 c0       	rjmp	.+10     	; 0x2002 <__floatsisf+0x5e>
    1ff8:	66 23       	and	r22, r22
    1ffa:	71 f0       	breq	.+28     	; 0x2018 <__floatsisf+0x74>
    1ffc:	96 e8       	ldi	r25, 0x86	; 134
    1ffe:	86 2f       	mov	r24, r22
    2000:	70 e0       	ldi	r23, 0x00	; 0
    2002:	60 e0       	ldi	r22, 0x00	; 0
    2004:	2a f0       	brmi	.+10     	; 0x2010 <__floatsisf+0x6c>
    2006:	9a 95       	dec	r25
    2008:	66 0f       	add	r22, r22
    200a:	77 1f       	adc	r23, r23
    200c:	88 1f       	adc	r24, r24
    200e:	da f7       	brpl	.-10     	; 0x2006 <__floatsisf+0x62>
    2010:	88 0f       	add	r24, r24
    2012:	96 95       	lsr	r25
    2014:	87 95       	ror	r24
    2016:	97 f9       	bld	r25, 7
    2018:	08 95       	ret

0000201a <__fp_cmp>:
    201a:	99 0f       	add	r25, r25
    201c:	00 08       	sbc	r0, r0
    201e:	55 0f       	add	r21, r21
    2020:	aa 0b       	sbc	r26, r26
    2022:	e0 e8       	ldi	r30, 0x80	; 128
    2024:	fe ef       	ldi	r31, 0xFE	; 254
    2026:	16 16       	cp	r1, r22
    2028:	17 06       	cpc	r1, r23
    202a:	e8 07       	cpc	r30, r24
    202c:	f9 07       	cpc	r31, r25
    202e:	c0 f0       	brcs	.+48     	; 0x2060 <__fp_cmp+0x46>
    2030:	12 16       	cp	r1, r18
    2032:	13 06       	cpc	r1, r19
    2034:	e4 07       	cpc	r30, r20
    2036:	f5 07       	cpc	r31, r21
    2038:	98 f0       	brcs	.+38     	; 0x2060 <__fp_cmp+0x46>
    203a:	62 1b       	sub	r22, r18
    203c:	73 0b       	sbc	r23, r19
    203e:	84 0b       	sbc	r24, r20
    2040:	95 0b       	sbc	r25, r21
    2042:	39 f4       	brne	.+14     	; 0x2052 <__fp_cmp+0x38>
    2044:	0a 26       	eor	r0, r26
    2046:	61 f0       	breq	.+24     	; 0x2060 <__fp_cmp+0x46>
    2048:	23 2b       	or	r18, r19
    204a:	24 2b       	or	r18, r20
    204c:	25 2b       	or	r18, r21
    204e:	21 f4       	brne	.+8      	; 0x2058 <__fp_cmp+0x3e>
    2050:	08 95       	ret
    2052:	0a 26       	eor	r0, r26
    2054:	09 f4       	brne	.+2      	; 0x2058 <__fp_cmp+0x3e>
    2056:	a1 40       	sbci	r26, 0x01	; 1
    2058:	a6 95       	lsr	r26
    205a:	8f ef       	ldi	r24, 0xFF	; 255
    205c:	81 1d       	adc	r24, r1
    205e:	81 1d       	adc	r24, r1
    2060:	08 95       	ret

00002062 <__fp_inf>:
    2062:	97 f9       	bld	r25, 7
    2064:	9f 67       	ori	r25, 0x7F	; 127
    2066:	80 e8       	ldi	r24, 0x80	; 128
    2068:	70 e0       	ldi	r23, 0x00	; 0
    206a:	60 e0       	ldi	r22, 0x00	; 0
    206c:	08 95       	ret

0000206e <__fp_nan>:
    206e:	9f ef       	ldi	r25, 0xFF	; 255
    2070:	80 ec       	ldi	r24, 0xC0	; 192
    2072:	08 95       	ret

00002074 <__fp_pscA>:
    2074:	00 24       	eor	r0, r0
    2076:	0a 94       	dec	r0
    2078:	16 16       	cp	r1, r22
    207a:	17 06       	cpc	r1, r23
    207c:	18 06       	cpc	r1, r24
    207e:	09 06       	cpc	r0, r25
    2080:	08 95       	ret

00002082 <__fp_pscB>:
    2082:	00 24       	eor	r0, r0
    2084:	0a 94       	dec	r0
    2086:	12 16       	cp	r1, r18
    2088:	13 06       	cpc	r1, r19
    208a:	14 06       	cpc	r1, r20
    208c:	05 06       	cpc	r0, r21
    208e:	08 95       	ret

00002090 <__fp_round>:
    2090:	09 2e       	mov	r0, r25
    2092:	03 94       	inc	r0
    2094:	00 0c       	add	r0, r0
    2096:	11 f4       	brne	.+4      	; 0x209c <__fp_round+0xc>
    2098:	88 23       	and	r24, r24
    209a:	52 f0       	brmi	.+20     	; 0x20b0 <__fp_round+0x20>
    209c:	bb 0f       	add	r27, r27
    209e:	40 f4       	brcc	.+16     	; 0x20b0 <__fp_round+0x20>
    20a0:	bf 2b       	or	r27, r31
    20a2:	11 f4       	brne	.+4      	; 0x20a8 <__fp_round+0x18>
    20a4:	60 ff       	sbrs	r22, 0
    20a6:	04 c0       	rjmp	.+8      	; 0x20b0 <__fp_round+0x20>
    20a8:	6f 5f       	subi	r22, 0xFF	; 255
    20aa:	7f 4f       	sbci	r23, 0xFF	; 255
    20ac:	8f 4f       	sbci	r24, 0xFF	; 255
    20ae:	9f 4f       	sbci	r25, 0xFF	; 255
    20b0:	08 95       	ret

000020b2 <__fp_split3>:
    20b2:	57 fd       	sbrc	r21, 7
    20b4:	90 58       	subi	r25, 0x80	; 128
    20b6:	44 0f       	add	r20, r20
    20b8:	55 1f       	adc	r21, r21
    20ba:	59 f0       	breq	.+22     	; 0x20d2 <__fp_splitA+0x10>
    20bc:	5f 3f       	cpi	r21, 0xFF	; 255
    20be:	71 f0       	breq	.+28     	; 0x20dc <__fp_splitA+0x1a>
    20c0:	47 95       	ror	r20

000020c2 <__fp_splitA>:
    20c2:	88 0f       	add	r24, r24
    20c4:	97 fb       	bst	r25, 7
    20c6:	99 1f       	adc	r25, r25
    20c8:	61 f0       	breq	.+24     	; 0x20e2 <__fp_splitA+0x20>
    20ca:	9f 3f       	cpi	r25, 0xFF	; 255
    20cc:	79 f0       	breq	.+30     	; 0x20ec <__fp_splitA+0x2a>
    20ce:	87 95       	ror	r24
    20d0:	08 95       	ret
    20d2:	12 16       	cp	r1, r18
    20d4:	13 06       	cpc	r1, r19
    20d6:	14 06       	cpc	r1, r20
    20d8:	55 1f       	adc	r21, r21
    20da:	f2 cf       	rjmp	.-28     	; 0x20c0 <__fp_split3+0xe>
    20dc:	46 95       	lsr	r20
    20de:	f1 df       	rcall	.-30     	; 0x20c2 <__fp_splitA>
    20e0:	08 c0       	rjmp	.+16     	; 0x20f2 <__fp_splitA+0x30>
    20e2:	16 16       	cp	r1, r22
    20e4:	17 06       	cpc	r1, r23
    20e6:	18 06       	cpc	r1, r24
    20e8:	99 1f       	adc	r25, r25
    20ea:	f1 cf       	rjmp	.-30     	; 0x20ce <__fp_splitA+0xc>
    20ec:	86 95       	lsr	r24
    20ee:	71 05       	cpc	r23, r1
    20f0:	61 05       	cpc	r22, r1
    20f2:	08 94       	sec
    20f4:	08 95       	ret

000020f6 <__fp_zero>:
    20f6:	e8 94       	clt

000020f8 <__fp_szero>:
    20f8:	bb 27       	eor	r27, r27
    20fa:	66 27       	eor	r22, r22
    20fc:	77 27       	eor	r23, r23
    20fe:	cb 01       	movw	r24, r22
    2100:	97 f9       	bld	r25, 7
    2102:	08 95       	ret

00002104 <__gesf2>:
    2104:	8a df       	rcall	.-236    	; 0x201a <__fp_cmp>
    2106:	08 f4       	brcc	.+2      	; 0x210a <__gesf2+0x6>
    2108:	8f ef       	ldi	r24, 0xFF	; 255
    210a:	08 95       	ret

0000210c <__mulsf3>:
    210c:	0b d0       	rcall	.+22     	; 0x2124 <__mulsf3x>
    210e:	c0 cf       	rjmp	.-128    	; 0x2090 <__fp_round>
    2110:	b1 df       	rcall	.-158    	; 0x2074 <__fp_pscA>
    2112:	28 f0       	brcs	.+10     	; 0x211e <__mulsf3+0x12>
    2114:	b6 df       	rcall	.-148    	; 0x2082 <__fp_pscB>
    2116:	18 f0       	brcs	.+6      	; 0x211e <__mulsf3+0x12>
    2118:	95 23       	and	r25, r21
    211a:	09 f0       	breq	.+2      	; 0x211e <__mulsf3+0x12>
    211c:	a2 cf       	rjmp	.-188    	; 0x2062 <__fp_inf>
    211e:	a7 cf       	rjmp	.-178    	; 0x206e <__fp_nan>
    2120:	11 24       	eor	r1, r1
    2122:	ea cf       	rjmp	.-44     	; 0x20f8 <__fp_szero>

00002124 <__mulsf3x>:
    2124:	c6 df       	rcall	.-116    	; 0x20b2 <__fp_split3>
    2126:	a0 f3       	brcs	.-24     	; 0x2110 <__mulsf3+0x4>

00002128 <__mulsf3_pse>:
    2128:	95 9f       	mul	r25, r21
    212a:	d1 f3       	breq	.-12     	; 0x2120 <__mulsf3+0x14>
    212c:	95 0f       	add	r25, r21
    212e:	50 e0       	ldi	r21, 0x00	; 0
    2130:	55 1f       	adc	r21, r21
    2132:	62 9f       	mul	r22, r18
    2134:	f0 01       	movw	r30, r0
    2136:	72 9f       	mul	r23, r18
    2138:	bb 27       	eor	r27, r27
    213a:	f0 0d       	add	r31, r0
    213c:	b1 1d       	adc	r27, r1
    213e:	63 9f       	mul	r22, r19
    2140:	aa 27       	eor	r26, r26
    2142:	f0 0d       	add	r31, r0
    2144:	b1 1d       	adc	r27, r1
    2146:	aa 1f       	adc	r26, r26
    2148:	64 9f       	mul	r22, r20
    214a:	66 27       	eor	r22, r22
    214c:	b0 0d       	add	r27, r0
    214e:	a1 1d       	adc	r26, r1
    2150:	66 1f       	adc	r22, r22
    2152:	82 9f       	mul	r24, r18
    2154:	22 27       	eor	r18, r18
    2156:	b0 0d       	add	r27, r0
    2158:	a1 1d       	adc	r26, r1
    215a:	62 1f       	adc	r22, r18
    215c:	73 9f       	mul	r23, r19
    215e:	b0 0d       	add	r27, r0
    2160:	a1 1d       	adc	r26, r1
    2162:	62 1f       	adc	r22, r18
    2164:	83 9f       	mul	r24, r19
    2166:	a0 0d       	add	r26, r0
    2168:	61 1d       	adc	r22, r1
    216a:	22 1f       	adc	r18, r18
    216c:	74 9f       	mul	r23, r20
    216e:	33 27       	eor	r19, r19
    2170:	a0 0d       	add	r26, r0
    2172:	61 1d       	adc	r22, r1
    2174:	23 1f       	adc	r18, r19
    2176:	84 9f       	mul	r24, r20
    2178:	60 0d       	add	r22, r0
    217a:	21 1d       	adc	r18, r1
    217c:	82 2f       	mov	r24, r18
    217e:	76 2f       	mov	r23, r22
    2180:	6a 2f       	mov	r22, r26
    2182:	11 24       	eor	r1, r1
    2184:	9f 57       	subi	r25, 0x7F	; 127
    2186:	50 40       	sbci	r21, 0x00	; 0
    2188:	8a f0       	brmi	.+34     	; 0x21ac <__mulsf3_pse+0x84>
    218a:	e1 f0       	breq	.+56     	; 0x21c4 <__mulsf3_pse+0x9c>
    218c:	88 23       	and	r24, r24
    218e:	4a f0       	brmi	.+18     	; 0x21a2 <__mulsf3_pse+0x7a>
    2190:	ee 0f       	add	r30, r30
    2192:	ff 1f       	adc	r31, r31
    2194:	bb 1f       	adc	r27, r27
    2196:	66 1f       	adc	r22, r22
    2198:	77 1f       	adc	r23, r23
    219a:	88 1f       	adc	r24, r24
    219c:	91 50       	subi	r25, 0x01	; 1
    219e:	50 40       	sbci	r21, 0x00	; 0
    21a0:	a9 f7       	brne	.-22     	; 0x218c <__mulsf3_pse+0x64>
    21a2:	9e 3f       	cpi	r25, 0xFE	; 254
    21a4:	51 05       	cpc	r21, r1
    21a6:	70 f0       	brcs	.+28     	; 0x21c4 <__mulsf3_pse+0x9c>
    21a8:	5c cf       	rjmp	.-328    	; 0x2062 <__fp_inf>
    21aa:	a6 cf       	rjmp	.-180    	; 0x20f8 <__fp_szero>
    21ac:	5f 3f       	cpi	r21, 0xFF	; 255
    21ae:	ec f3       	brlt	.-6      	; 0x21aa <__mulsf3_pse+0x82>
    21b0:	98 3e       	cpi	r25, 0xE8	; 232
    21b2:	dc f3       	brlt	.-10     	; 0x21aa <__mulsf3_pse+0x82>
    21b4:	86 95       	lsr	r24
    21b6:	77 95       	ror	r23
    21b8:	67 95       	ror	r22
    21ba:	b7 95       	ror	r27
    21bc:	f7 95       	ror	r31
    21be:	e7 95       	ror	r30
    21c0:	9f 5f       	subi	r25, 0xFF	; 255
    21c2:	c1 f7       	brne	.-16     	; 0x21b4 <__mulsf3_pse+0x8c>
    21c4:	fe 2b       	or	r31, r30
    21c6:	88 0f       	add	r24, r24
    21c8:	91 1d       	adc	r25, r1
    21ca:	96 95       	lsr	r25
    21cc:	87 95       	ror	r24
    21ce:	97 f9       	bld	r25, 7
    21d0:	08 95       	ret

000021d2 <__tablejump2__>:
    21d2:	ee 0f       	add	r30, r30
    21d4:	ff 1f       	adc	r31, r31
    21d6:	88 1f       	adc	r24, r24
    21d8:	8b bf       	out	0x3b, r24	; 59
    21da:	07 90       	elpm	r0, Z+
    21dc:	f6 91       	elpm	r31, Z
    21de:	e0 2d       	mov	r30, r0
    21e0:	19 94       	eijmp

000021e2 <__umulhisi3>:
    21e2:	a2 9f       	mul	r26, r18
    21e4:	b0 01       	movw	r22, r0
    21e6:	b3 9f       	mul	r27, r19
    21e8:	c0 01       	movw	r24, r0
    21ea:	a3 9f       	mul	r26, r19
    21ec:	70 0d       	add	r23, r0
    21ee:	81 1d       	adc	r24, r1
    21f0:	11 24       	eor	r1, r1
    21f2:	91 1d       	adc	r25, r1
    21f4:	b2 9f       	mul	r27, r18
    21f6:	70 0d       	add	r23, r0
    21f8:	81 1d       	adc	r24, r1
    21fa:	11 24       	eor	r1, r1
    21fc:	91 1d       	adc	r25, r1
    21fe:	08 95       	ret

00002200 <malloc>:
    2200:	0f 93       	push	r16
    2202:	1f 93       	push	r17
    2204:	cf 93       	push	r28
    2206:	df 93       	push	r29
    2208:	82 30       	cpi	r24, 0x02	; 2
    220a:	91 05       	cpc	r25, r1
    220c:	10 f4       	brcc	.+4      	; 0x2212 <malloc+0x12>
    220e:	82 e0       	ldi	r24, 0x02	; 2
    2210:	90 e0       	ldi	r25, 0x00	; 0
    2212:	e0 91 10 09 	lds	r30, 0x0910	; 0x800910 <__flp>
    2216:	f0 91 11 09 	lds	r31, 0x0911	; 0x800911 <__flp+0x1>
    221a:	20 e0       	ldi	r18, 0x00	; 0
    221c:	30 e0       	ldi	r19, 0x00	; 0
    221e:	a0 e0       	ldi	r26, 0x00	; 0
    2220:	b0 e0       	ldi	r27, 0x00	; 0
    2222:	30 97       	sbiw	r30, 0x00	; 0
    2224:	19 f1       	breq	.+70     	; 0x226c <malloc+0x6c>
    2226:	40 81       	ld	r20, Z
    2228:	51 81       	ldd	r21, Z+1	; 0x01
    222a:	02 81       	ldd	r16, Z+2	; 0x02
    222c:	13 81       	ldd	r17, Z+3	; 0x03
    222e:	48 17       	cp	r20, r24
    2230:	59 07       	cpc	r21, r25
    2232:	c8 f0       	brcs	.+50     	; 0x2266 <malloc+0x66>
    2234:	84 17       	cp	r24, r20
    2236:	95 07       	cpc	r25, r21
    2238:	69 f4       	brne	.+26     	; 0x2254 <malloc+0x54>
    223a:	10 97       	sbiw	r26, 0x00	; 0
    223c:	31 f0       	breq	.+12     	; 0x224a <malloc+0x4a>
    223e:	12 96       	adiw	r26, 0x02	; 2
    2240:	0c 93       	st	X, r16
    2242:	12 97       	sbiw	r26, 0x02	; 2
    2244:	13 96       	adiw	r26, 0x03	; 3
    2246:	1c 93       	st	X, r17
    2248:	27 c0       	rjmp	.+78     	; 0x2298 <malloc+0x98>
    224a:	00 93 10 09 	sts	0x0910, r16	; 0x800910 <__flp>
    224e:	10 93 11 09 	sts	0x0911, r17	; 0x800911 <__flp+0x1>
    2252:	22 c0       	rjmp	.+68     	; 0x2298 <malloc+0x98>
    2254:	21 15       	cp	r18, r1
    2256:	31 05       	cpc	r19, r1
    2258:	19 f0       	breq	.+6      	; 0x2260 <malloc+0x60>
    225a:	42 17       	cp	r20, r18
    225c:	53 07       	cpc	r21, r19
    225e:	18 f4       	brcc	.+6      	; 0x2266 <malloc+0x66>
    2260:	9a 01       	movw	r18, r20
    2262:	bd 01       	movw	r22, r26
    2264:	ef 01       	movw	r28, r30
    2266:	df 01       	movw	r26, r30
    2268:	f8 01       	movw	r30, r16
    226a:	db cf       	rjmp	.-74     	; 0x2222 <malloc+0x22>
    226c:	21 15       	cp	r18, r1
    226e:	31 05       	cpc	r19, r1
    2270:	f9 f0       	breq	.+62     	; 0x22b0 <malloc+0xb0>
    2272:	28 1b       	sub	r18, r24
    2274:	39 0b       	sbc	r19, r25
    2276:	24 30       	cpi	r18, 0x04	; 4
    2278:	31 05       	cpc	r19, r1
    227a:	80 f4       	brcc	.+32     	; 0x229c <malloc+0x9c>
    227c:	8a 81       	ldd	r24, Y+2	; 0x02
    227e:	9b 81       	ldd	r25, Y+3	; 0x03
    2280:	61 15       	cp	r22, r1
    2282:	71 05       	cpc	r23, r1
    2284:	21 f0       	breq	.+8      	; 0x228e <malloc+0x8e>
    2286:	fb 01       	movw	r30, r22
    2288:	93 83       	std	Z+3, r25	; 0x03
    228a:	82 83       	std	Z+2, r24	; 0x02
    228c:	04 c0       	rjmp	.+8      	; 0x2296 <malloc+0x96>
    228e:	90 93 11 09 	sts	0x0911, r25	; 0x800911 <__flp+0x1>
    2292:	80 93 10 09 	sts	0x0910, r24	; 0x800910 <__flp>
    2296:	fe 01       	movw	r30, r28
    2298:	32 96       	adiw	r30, 0x02	; 2
    229a:	44 c0       	rjmp	.+136    	; 0x2324 <malloc+0x124>
    229c:	fe 01       	movw	r30, r28
    229e:	e2 0f       	add	r30, r18
    22a0:	f3 1f       	adc	r31, r19
    22a2:	81 93       	st	Z+, r24
    22a4:	91 93       	st	Z+, r25
    22a6:	22 50       	subi	r18, 0x02	; 2
    22a8:	31 09       	sbc	r19, r1
    22aa:	39 83       	std	Y+1, r19	; 0x01
    22ac:	28 83       	st	Y, r18
    22ae:	3a c0       	rjmp	.+116    	; 0x2324 <malloc+0x124>
    22b0:	20 91 0e 09 	lds	r18, 0x090E	; 0x80090e <__brkval>
    22b4:	30 91 0f 09 	lds	r19, 0x090F	; 0x80090f <__brkval+0x1>
    22b8:	23 2b       	or	r18, r19
    22ba:	41 f4       	brne	.+16     	; 0x22cc <malloc+0xcc>
    22bc:	20 91 02 02 	lds	r18, 0x0202	; 0x800202 <__malloc_heap_start>
    22c0:	30 91 03 02 	lds	r19, 0x0203	; 0x800203 <__malloc_heap_start+0x1>
    22c4:	30 93 0f 09 	sts	0x090F, r19	; 0x80090f <__brkval+0x1>
    22c8:	20 93 0e 09 	sts	0x090E, r18	; 0x80090e <__brkval>
    22cc:	20 91 00 02 	lds	r18, 0x0200	; 0x800200 <__data_start>
    22d0:	30 91 01 02 	lds	r19, 0x0201	; 0x800201 <__data_start+0x1>
    22d4:	21 15       	cp	r18, r1
    22d6:	31 05       	cpc	r19, r1
    22d8:	41 f4       	brne	.+16     	; 0x22ea <malloc+0xea>
    22da:	2d b7       	in	r18, 0x3d	; 61
    22dc:	3e b7       	in	r19, 0x3e	; 62
    22de:	40 91 04 02 	lds	r20, 0x0204	; 0x800204 <__malloc_margin>
    22e2:	50 91 05 02 	lds	r21, 0x0205	; 0x800205 <__malloc_margin+0x1>
    22e6:	24 1b       	sub	r18, r20
    22e8:	35 0b       	sbc	r19, r21
    22ea:	e0 91 0e 09 	lds	r30, 0x090E	; 0x80090e <__brkval>
    22ee:	f0 91 0f 09 	lds	r31, 0x090F	; 0x80090f <__brkval+0x1>
    22f2:	e2 17       	cp	r30, r18
    22f4:	f3 07       	cpc	r31, r19
    22f6:	a0 f4       	brcc	.+40     	; 0x2320 <malloc+0x120>
    22f8:	2e 1b       	sub	r18, r30
    22fa:	3f 0b       	sbc	r19, r31
    22fc:	28 17       	cp	r18, r24
    22fe:	39 07       	cpc	r19, r25
    2300:	78 f0       	brcs	.+30     	; 0x2320 <malloc+0x120>
    2302:	ac 01       	movw	r20, r24
    2304:	4e 5f       	subi	r20, 0xFE	; 254
    2306:	5f 4f       	sbci	r21, 0xFF	; 255
    2308:	24 17       	cp	r18, r20
    230a:	35 07       	cpc	r19, r21
    230c:	48 f0       	brcs	.+18     	; 0x2320 <malloc+0x120>
    230e:	4e 0f       	add	r20, r30
    2310:	5f 1f       	adc	r21, r31
    2312:	50 93 0f 09 	sts	0x090F, r21	; 0x80090f <__brkval+0x1>
    2316:	40 93 0e 09 	sts	0x090E, r20	; 0x80090e <__brkval>
    231a:	81 93       	st	Z+, r24
    231c:	91 93       	st	Z+, r25
    231e:	02 c0       	rjmp	.+4      	; 0x2324 <malloc+0x124>
    2320:	e0 e0       	ldi	r30, 0x00	; 0
    2322:	f0 e0       	ldi	r31, 0x00	; 0
    2324:	cf 01       	movw	r24, r30
    2326:	df 91       	pop	r29
    2328:	cf 91       	pop	r28
    232a:	1f 91       	pop	r17
    232c:	0f 91       	pop	r16
    232e:	08 95       	ret

00002330 <free>:
    2330:	cf 93       	push	r28
    2332:	df 93       	push	r29
    2334:	00 97       	sbiw	r24, 0x00	; 0
    2336:	09 f4       	brne	.+2      	; 0x233a <free+0xa>
    2338:	81 c0       	rjmp	.+258    	; 0x243c <free+0x10c>
    233a:	fc 01       	movw	r30, r24
    233c:	32 97       	sbiw	r30, 0x02	; 2
    233e:	13 82       	std	Z+3, r1	; 0x03
    2340:	12 82       	std	Z+2, r1	; 0x02
    2342:	a0 91 10 09 	lds	r26, 0x0910	; 0x800910 <__flp>
    2346:	b0 91 11 09 	lds	r27, 0x0911	; 0x800911 <__flp+0x1>
    234a:	10 97       	sbiw	r26, 0x00	; 0
    234c:	81 f4       	brne	.+32     	; 0x236e <free+0x3e>
    234e:	20 81       	ld	r18, Z
    2350:	31 81       	ldd	r19, Z+1	; 0x01
    2352:	82 0f       	add	r24, r18
    2354:	93 1f       	adc	r25, r19
    2356:	20 91 0e 09 	lds	r18, 0x090E	; 0x80090e <__brkval>
    235a:	30 91 0f 09 	lds	r19, 0x090F	; 0x80090f <__brkval+0x1>
    235e:	28 17       	cp	r18, r24
    2360:	39 07       	cpc	r19, r25
    2362:	51 f5       	brne	.+84     	; 0x23b8 <free+0x88>
    2364:	f0 93 0f 09 	sts	0x090F, r31	; 0x80090f <__brkval+0x1>
    2368:	e0 93 0e 09 	sts	0x090E, r30	; 0x80090e <__brkval>
    236c:	67 c0       	rjmp	.+206    	; 0x243c <free+0x10c>
    236e:	ed 01       	movw	r28, r26
    2370:	20 e0       	ldi	r18, 0x00	; 0
    2372:	30 e0       	ldi	r19, 0x00	; 0
    2374:	ce 17       	cp	r28, r30
    2376:	df 07       	cpc	r29, r31
    2378:	40 f4       	brcc	.+16     	; 0x238a <free+0x5a>
    237a:	4a 81       	ldd	r20, Y+2	; 0x02
    237c:	5b 81       	ldd	r21, Y+3	; 0x03
    237e:	9e 01       	movw	r18, r28
    2380:	41 15       	cp	r20, r1
    2382:	51 05       	cpc	r21, r1
    2384:	f1 f0       	breq	.+60     	; 0x23c2 <free+0x92>
    2386:	ea 01       	movw	r28, r20
    2388:	f5 cf       	rjmp	.-22     	; 0x2374 <free+0x44>
    238a:	d3 83       	std	Z+3, r29	; 0x03
    238c:	c2 83       	std	Z+2, r28	; 0x02
    238e:	40 81       	ld	r20, Z
    2390:	51 81       	ldd	r21, Z+1	; 0x01
    2392:	84 0f       	add	r24, r20
    2394:	95 1f       	adc	r25, r21
    2396:	c8 17       	cp	r28, r24
    2398:	d9 07       	cpc	r29, r25
    239a:	59 f4       	brne	.+22     	; 0x23b2 <free+0x82>
    239c:	88 81       	ld	r24, Y
    239e:	99 81       	ldd	r25, Y+1	; 0x01
    23a0:	84 0f       	add	r24, r20
    23a2:	95 1f       	adc	r25, r21
    23a4:	02 96       	adiw	r24, 0x02	; 2
    23a6:	91 83       	std	Z+1, r25	; 0x01
    23a8:	80 83       	st	Z, r24
    23aa:	8a 81       	ldd	r24, Y+2	; 0x02
    23ac:	9b 81       	ldd	r25, Y+3	; 0x03
    23ae:	93 83       	std	Z+3, r25	; 0x03
    23b0:	82 83       	std	Z+2, r24	; 0x02
    23b2:	21 15       	cp	r18, r1
    23b4:	31 05       	cpc	r19, r1
    23b6:	29 f4       	brne	.+10     	; 0x23c2 <free+0x92>
    23b8:	f0 93 11 09 	sts	0x0911, r31	; 0x800911 <__flp+0x1>
    23bc:	e0 93 10 09 	sts	0x0910, r30	; 0x800910 <__flp>
    23c0:	3d c0       	rjmp	.+122    	; 0x243c <free+0x10c>
    23c2:	e9 01       	movw	r28, r18
    23c4:	fb 83       	std	Y+3, r31	; 0x03
    23c6:	ea 83       	std	Y+2, r30	; 0x02
    23c8:	49 91       	ld	r20, Y+
    23ca:	59 91       	ld	r21, Y+
    23cc:	c4 0f       	add	r28, r20
    23ce:	d5 1f       	adc	r29, r21
    23d0:	ec 17       	cp	r30, r28
    23d2:	fd 07       	cpc	r31, r29
    23d4:	61 f4       	brne	.+24     	; 0x23ee <free+0xbe>
    23d6:	80 81       	ld	r24, Z
    23d8:	91 81       	ldd	r25, Z+1	; 0x01
    23da:	84 0f       	add	r24, r20
    23dc:	95 1f       	adc	r25, r21
    23de:	02 96       	adiw	r24, 0x02	; 2
    23e0:	e9 01       	movw	r28, r18
    23e2:	99 83       	std	Y+1, r25	; 0x01
    23e4:	88 83       	st	Y, r24
    23e6:	82 81       	ldd	r24, Z+2	; 0x02
    23e8:	93 81       	ldd	r25, Z+3	; 0x03
    23ea:	9b 83       	std	Y+3, r25	; 0x03
    23ec:	8a 83       	std	Y+2, r24	; 0x02
    23ee:	e0 e0       	ldi	r30, 0x00	; 0
    23f0:	f0 e0       	ldi	r31, 0x00	; 0
    23f2:	12 96       	adiw	r26, 0x02	; 2
    23f4:	8d 91       	ld	r24, X+
    23f6:	9c 91       	ld	r25, X
    23f8:	13 97       	sbiw	r26, 0x03	; 3
    23fa:	00 97       	sbiw	r24, 0x00	; 0
    23fc:	19 f0       	breq	.+6      	; 0x2404 <free+0xd4>
    23fe:	fd 01       	movw	r30, r26
    2400:	dc 01       	movw	r26, r24
    2402:	f7 cf       	rjmp	.-18     	; 0x23f2 <free+0xc2>
    2404:	8d 91       	ld	r24, X+
    2406:	9c 91       	ld	r25, X
    2408:	11 97       	sbiw	r26, 0x01	; 1
    240a:	9d 01       	movw	r18, r26
    240c:	2e 5f       	subi	r18, 0xFE	; 254
    240e:	3f 4f       	sbci	r19, 0xFF	; 255
    2410:	82 0f       	add	r24, r18
    2412:	93 1f       	adc	r25, r19
    2414:	20 91 0e 09 	lds	r18, 0x090E	; 0x80090e <__brkval>
    2418:	30 91 0f 09 	lds	r19, 0x090F	; 0x80090f <__brkval+0x1>
    241c:	28 17       	cp	r18, r24
    241e:	39 07       	cpc	r19, r25
    2420:	69 f4       	brne	.+26     	; 0x243c <free+0x10c>
    2422:	30 97       	sbiw	r30, 0x00	; 0
    2424:	29 f4       	brne	.+10     	; 0x2430 <free+0x100>
    2426:	10 92 11 09 	sts	0x0911, r1	; 0x800911 <__flp+0x1>
    242a:	10 92 10 09 	sts	0x0910, r1	; 0x800910 <__flp>
    242e:	02 c0       	rjmp	.+4      	; 0x2434 <free+0x104>
    2430:	13 82       	std	Z+3, r1	; 0x03
    2432:	12 82       	std	Z+2, r1	; 0x02
    2434:	b0 93 0f 09 	sts	0x090F, r27	; 0x80090f <__brkval+0x1>
    2438:	a0 93 0e 09 	sts	0x090E, r26	; 0x80090e <__brkval>
    243c:	df 91       	pop	r29
    243e:	cf 91       	pop	r28
    2440:	08 95       	ret

00002442 <memset>:
    2442:	dc 01       	movw	r26, r24
    2444:	01 c0       	rjmp	.+2      	; 0x2448 <memset+0x6>
    2446:	6d 93       	st	X+, r22
    2448:	41 50       	subi	r20, 0x01	; 1
    244a:	50 40       	sbci	r21, 0x00	; 0
    244c:	e0 f7       	brcc	.-8      	; 0x2446 <memset+0x4>
    244e:	08 95       	ret

00002450 <strncpy>:
    2450:	fb 01       	movw	r30, r22
    2452:	dc 01       	movw	r26, r24
    2454:	41 50       	subi	r20, 0x01	; 1
    2456:	50 40       	sbci	r21, 0x00	; 0
    2458:	48 f0       	brcs	.+18     	; 0x246c <strncpy+0x1c>
    245a:	01 90       	ld	r0, Z+
    245c:	0d 92       	st	X+, r0
    245e:	00 20       	and	r0, r0
    2460:	c9 f7       	brne	.-14     	; 0x2454 <strncpy+0x4>
    2462:	01 c0       	rjmp	.+2      	; 0x2466 <strncpy+0x16>
    2464:	1d 92       	st	X+, r1
    2466:	41 50       	subi	r20, 0x01	; 1
    2468:	50 40       	sbci	r21, 0x00	; 0
    246a:	e0 f7       	brcc	.-8      	; 0x2464 <strncpy+0x14>
    246c:	08 95       	ret

0000246e <__do_global_dtors>:
    246e:	10 e0       	ldi	r17, 0x00	; 0
    2470:	c3 e7       	ldi	r28, 0x73	; 115
    2472:	d0 e0       	ldi	r29, 0x00	; 0
    2474:	00 e0       	ldi	r16, 0x00	; 0
    2476:	05 c0       	rjmp	.+10     	; 0x2482 <__do_global_dtors+0x14>
    2478:	80 2f       	mov	r24, r16
    247a:	fe 01       	movw	r30, r28
    247c:	aa de       	rcall	.-684    	; 0x21d2 <__tablejump2__>
    247e:	21 96       	adiw	r28, 0x01	; 1
    2480:	01 1d       	adc	r16, r1
    2482:	c4 37       	cpi	r28, 0x74	; 116
    2484:	d1 07       	cpc	r29, r17
    2486:	80 e0       	ldi	r24, 0x00	; 0
    2488:	08 07       	cpc	r16, r24
    248a:	b1 f7       	brne	.-20     	; 0x2478 <__do_global_dtors+0xa>
    248c:	f8 94       	cli

0000248e <__stop_program>:
    248e:	ff cf       	rjmp	.-2      	; 0x248e <__stop_program>
