
RobotSorter.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000008e  00800200  00002df0  00002e84  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002df0  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000069f  0080028e  0080028e  00002f12  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00002f12  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00002f44  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000660  00000000  00000000  00002f84  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00008a6a  00000000  00000000  000035e4  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00003424  00000000  00000000  0000c04e  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00003a00  00000000  00000000  0000f472  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  0000129c  00000000  00000000  00012e74  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00002285  00000000  00000000  00014110  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00004599  00000000  00000000  00016395  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000550  00000000  00000000  0001a92e  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	73 c0       	rjmp	.+230    	; 0xe8 <__dtors_end>
       2:	00 00       	nop
       4:	a1 c0       	rjmp	.+322    	; 0x148 <__bad_interrupt>
       6:	00 00       	nop
       8:	9f c0       	rjmp	.+318    	; 0x148 <__bad_interrupt>
       a:	00 00       	nop
       c:	9d c0       	rjmp	.+314    	; 0x148 <__bad_interrupt>
       e:	00 00       	nop
      10:	9b c0       	rjmp	.+310    	; 0x148 <__bad_interrupt>
      12:	00 00       	nop
      14:	0c 94 c4 12 	jmp	0x2588	; 0x2588 <__vector_5>
      18:	97 c0       	rjmp	.+302    	; 0x148 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	95 c0       	rjmp	.+298    	; 0x148 <__bad_interrupt>
      1e:	00 00       	nop
      20:	93 c0       	rjmp	.+294    	; 0x148 <__bad_interrupt>
      22:	00 00       	nop
      24:	91 c0       	rjmp	.+290    	; 0x148 <__bad_interrupt>
      26:	00 00       	nop
      28:	8f c0       	rjmp	.+286    	; 0x148 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	8d c0       	rjmp	.+282    	; 0x148 <__bad_interrupt>
      2e:	00 00       	nop
      30:	8b c0       	rjmp	.+278    	; 0x148 <__bad_interrupt>
      32:	00 00       	nop
      34:	89 c0       	rjmp	.+274    	; 0x148 <__bad_interrupt>
      36:	00 00       	nop
      38:	87 c0       	rjmp	.+270    	; 0x148 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	85 c0       	rjmp	.+266    	; 0x148 <__bad_interrupt>
      3e:	00 00       	nop
      40:	83 c0       	rjmp	.+262    	; 0x148 <__bad_interrupt>
      42:	00 00       	nop
      44:	81 c0       	rjmp	.+258    	; 0x148 <__bad_interrupt>
      46:	00 00       	nop
      48:	7f c0       	rjmp	.+254    	; 0x148 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	7d c0       	rjmp	.+250    	; 0x148 <__bad_interrupt>
      4e:	00 00       	nop
      50:	7b c0       	rjmp	.+246    	; 0x148 <__bad_interrupt>
      52:	00 00       	nop
      54:	0c 94 40 0d 	jmp	0x1a80	; 0x1a80 <__vector_21>
      58:	77 c0       	rjmp	.+238    	; 0x148 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	75 c0       	rjmp	.+234    	; 0x148 <__bad_interrupt>
      5e:	00 00       	nop
      60:	73 c0       	rjmp	.+230    	; 0x148 <__bad_interrupt>
      62:	00 00       	nop
      64:	71 c0       	rjmp	.+226    	; 0x148 <__bad_interrupt>
      66:	00 00       	nop
      68:	6f c0       	rjmp	.+222    	; 0x148 <__bad_interrupt>
      6a:	00 00       	nop
      6c:	6d c0       	rjmp	.+218    	; 0x148 <__bad_interrupt>
      6e:	00 00       	nop
      70:	6b c0       	rjmp	.+214    	; 0x148 <__bad_interrupt>
      72:	00 00       	nop
      74:	69 c0       	rjmp	.+210    	; 0x148 <__bad_interrupt>
      76:	00 00       	nop
      78:	67 c0       	rjmp	.+206    	; 0x148 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	65 c0       	rjmp	.+202    	; 0x148 <__bad_interrupt>
      7e:	00 00       	nop
      80:	63 c0       	rjmp	.+198    	; 0x148 <__bad_interrupt>
      82:	00 00       	nop
      84:	61 c0       	rjmp	.+194    	; 0x148 <__bad_interrupt>
      86:	00 00       	nop
      88:	5f c0       	rjmp	.+190    	; 0x148 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	5d c0       	rjmp	.+186    	; 0x148 <__bad_interrupt>
      8e:	00 00       	nop
      90:	5b c0       	rjmp	.+182    	; 0x148 <__bad_interrupt>
      92:	00 00       	nop
      94:	59 c0       	rjmp	.+178    	; 0x148 <__bad_interrupt>
      96:	00 00       	nop
      98:	57 c0       	rjmp	.+174    	; 0x148 <__bad_interrupt>
      9a:	00 00       	nop
      9c:	55 c0       	rjmp	.+170    	; 0x148 <__bad_interrupt>
      9e:	00 00       	nop
      a0:	53 c0       	rjmp	.+166    	; 0x148 <__bad_interrupt>
      a2:	00 00       	nop
      a4:	67 c2       	rjmp	.+1230   	; 0x574 <__vector_41>
      a6:	00 00       	nop
      a8:	4f c0       	rjmp	.+158    	; 0x148 <__bad_interrupt>
      aa:	00 00       	nop
      ac:	4d c0       	rjmp	.+154    	; 0x148 <__bad_interrupt>
      ae:	00 00       	nop
      b0:	4b c0       	rjmp	.+150    	; 0x148 <__bad_interrupt>
      b2:	00 00       	nop
      b4:	3a c2       	rjmp	.+1140   	; 0x52a <__vector_45>
      b6:	00 00       	nop
      b8:	47 c0       	rjmp	.+142    	; 0x148 <__bad_interrupt>
      ba:	00 00       	nop
      bc:	45 c0       	rjmp	.+138    	; 0x148 <__bad_interrupt>
      be:	00 00       	nop
      c0:	43 c0       	rjmp	.+134    	; 0x148 <__bad_interrupt>
      c2:	00 00       	nop
      c4:	41 c0       	rjmp	.+130    	; 0x148 <__bad_interrupt>
      c6:	00 00       	nop
      c8:	3f c0       	rjmp	.+126    	; 0x148 <__bad_interrupt>
      ca:	00 00       	nop
      cc:	3d c0       	rjmp	.+122    	; 0x148 <__bad_interrupt>
      ce:	00 00       	nop
      d0:	3b c0       	rjmp	.+118    	; 0x148 <__bad_interrupt>
      d2:	00 00       	nop
      d4:	39 c0       	rjmp	.+114    	; 0x148 <__bad_interrupt>
      d6:	00 00       	nop
      d8:	37 c0       	rjmp	.+110    	; 0x148 <__bad_interrupt>
      da:	00 00       	nop
      dc:	35 c0       	rjmp	.+106    	; 0x148 <__bad_interrupt>
      de:	00 00       	nop
      e0:	33 c0       	rjmp	.+102    	; 0x148 <__bad_interrupt>
	...

000000e4 <__ctors_start>:
      e4:	f3 03       	fmuls	r23, r19

000000e6 <__ctors_end>:
      e6:	f9 03       	fmulsu	r23, r17

000000e8 <__dtors_end>:
      e8:	11 24       	eor	r1, r1
      ea:	1f be       	out	0x3f, r1	; 63
      ec:	cf ef       	ldi	r28, 0xFF	; 255
      ee:	d1 e2       	ldi	r29, 0x21	; 33
      f0:	de bf       	out	0x3e, r29	; 62
      f2:	cd bf       	out	0x3d, r28	; 61
      f4:	00 e0       	ldi	r16, 0x00	; 0
      f6:	0c bf       	out	0x3c, r16	; 60

000000f8 <__do_copy_data>:
      f8:	12 e0       	ldi	r17, 0x02	; 2
      fa:	a0 e0       	ldi	r26, 0x00	; 0
      fc:	b2 e0       	ldi	r27, 0x02	; 2
      fe:	e0 ef       	ldi	r30, 0xF0	; 240
     100:	fd e2       	ldi	r31, 0x2D	; 45
     102:	00 e0       	ldi	r16, 0x00	; 0
     104:	0b bf       	out	0x3b, r16	; 59
     106:	02 c0       	rjmp	.+4      	; 0x10c <__do_copy_data+0x14>
     108:	07 90       	elpm	r0, Z+
     10a:	0d 92       	st	X+, r0
     10c:	ae 38       	cpi	r26, 0x8E	; 142
     10e:	b1 07       	cpc	r27, r17
     110:	d9 f7       	brne	.-10     	; 0x108 <__do_copy_data+0x10>

00000112 <__do_clear_bss>:
     112:	29 e0       	ldi	r18, 0x09	; 9
     114:	ae e8       	ldi	r26, 0x8E	; 142
     116:	b2 e0       	ldi	r27, 0x02	; 2
     118:	01 c0       	rjmp	.+2      	; 0x11c <.do_clear_bss_start>

0000011a <.do_clear_bss_loop>:
     11a:	1d 92       	st	X+, r1

0000011c <.do_clear_bss_start>:
     11c:	ad 32       	cpi	r26, 0x2D	; 45
     11e:	b2 07       	cpc	r27, r18
     120:	e1 f7       	brne	.-8      	; 0x11a <.do_clear_bss_loop>

00000122 <__do_global_ctors>:
     122:	10 e0       	ldi	r17, 0x00	; 0
     124:	c3 e7       	ldi	r28, 0x73	; 115
     126:	d0 e0       	ldi	r29, 0x00	; 0
     128:	00 e0       	ldi	r16, 0x00	; 0
     12a:	06 c0       	rjmp	.+12     	; 0x138 <__do_global_ctors+0x16>
     12c:	21 97       	sbiw	r28, 0x01	; 1
     12e:	01 09       	sbc	r16, r1
     130:	80 2f       	mov	r24, r16
     132:	fe 01       	movw	r30, r28
     134:	0e 94 99 15 	call	0x2b32	; 0x2b32 <__tablejump2__>
     138:	c2 37       	cpi	r28, 0x72	; 114
     13a:	d1 07       	cpc	r29, r17
     13c:	80 e0       	ldi	r24, 0x00	; 0
     13e:	08 07       	cpc	r16, r24
     140:	a9 f7       	brne	.-22     	; 0x12c <__do_global_ctors+0xa>
     142:	33 d3       	rcall	.+1638   	; 0x7aa <main>
     144:	0c 94 e7 16 	jmp	0x2dce	; 0x2dce <__do_global_dtors>

00000148 <__bad_interrupt>:
     148:	5b cf       	rjmp	.-330    	; 0x0 <__vectors>

0000014a <_ZN5ColorC1Ev>:
}

uint8_t Color::getColorIndex( void )
{
	return _colorIndex;
}
     14a:	08 95       	ret

0000014c <_ZN5ColorD1Ev>:
     14c:	08 95       	ret

0000014e <_ZN5Color12getRedPeriodEv>:
     14e:	fc 01       	movw	r30, r24
     150:	80 81       	ld	r24, Z
     152:	91 81       	ldd	r25, Z+1	; 0x01
     154:	08 95       	ret

00000156 <_ZN5Color13getBluePeriodEv>:
     156:	fc 01       	movw	r30, r24
     158:	82 81       	ldd	r24, Z+2	; 0x02
     15a:	93 81       	ldd	r25, Z+3	; 0x03
     15c:	08 95       	ret

0000015e <_ZN5Color14getGreenPeriodEv>:
     15e:	fc 01       	movw	r30, r24
     160:	84 81       	ldd	r24, Z+4	; 0x04
     162:	95 81       	ldd	r25, Z+5	; 0x05
     164:	08 95       	ret

00000166 <_ZN5Color14getWhitePeriodEv>:
     166:	fc 01       	movw	r30, r24
     168:	86 81       	ldd	r24, Z+6	; 0x06
     16a:	97 81       	ldd	r25, Z+7	; 0x07
     16c:	08 95       	ret

0000016e <_ZN5Color12setRedPeriodEj>:

void Color::setRedPeriod( uint16_t redPeriod )
{
	_redPeriod = redPeriod;
     16e:	fc 01       	movw	r30, r24
     170:	71 83       	std	Z+1, r23	; 0x01
     172:	60 83       	st	Z, r22
     174:	08 95       	ret

00000176 <_ZN5Color13setBluePeriodEj>:
}

void Color::setBluePeriod( uint16_t bluePeriod )
{
	_bluePeriod = bluePeriod;
     176:	fc 01       	movw	r30, r24
     178:	73 83       	std	Z+3, r23	; 0x03
     17a:	62 83       	std	Z+2, r22	; 0x02
     17c:	08 95       	ret

0000017e <_ZN5Color14setGreenPeriodEj>:
}

void Color::setGreenPeriod( uint16_t greenPeriod )
{
	_greenPeriod = greenPeriod;
     17e:	fc 01       	movw	r30, r24
     180:	75 83       	std	Z+5, r23	; 0x05
     182:	64 83       	std	Z+4, r22	; 0x04
     184:	08 95       	ret

00000186 <_ZN5Color14setWhitePeriodEj>:
}

void Color::setWhitePeriod( uint16_t whitePeriod )
{
	_whitePeriod = whitePeriod;
     186:	fc 01       	movw	r30, r24
     188:	77 83       	std	Z+7, r23	; 0x07
     18a:	66 83       	std	Z+6, r22	; 0x06
     18c:	08 95       	ret

0000018e <_ZN5Color13setColorIndexEh>:
}

void Color::setColorIndex( uint8_t index )
{
	_colorIndex = index;
     18e:	fc 01       	movw	r30, r24
     190:	60 87       	std	Z+8, r22	; 0x08
     192:	08 95       	ret

00000194 <_ZN11ColorSensorD1Ev>:
	setFilter( noFilter );
	setFrequencyscaling( scaling );
}

// default destructor
ColorSensor::~ColorSensor()
     194:	0f 93       	push	r16
     196:	1f 93       	push	r17
     198:	cf 93       	push	r28
     19a:	df 93       	push	r29
     19c:	8c 01       	movw	r16, r24
     19e:	0f 5f       	subi	r16, 0xFF	; 255
     1a0:	1f 4f       	sbci	r17, 0xFF	; 255
     1a2:	51 f0       	breq	.+20     	; 0x1b8 <_ZN11ColorSensorD1Ev+0x24>
     1a4:	ec 01       	movw	r28, r24
     1a6:	c5 5a       	subi	r28, 0xA5	; 165
     1a8:	df 4f       	sbci	r29, 0xFF	; 255
     1aa:	c0 17       	cp	r28, r16
     1ac:	d1 07       	cpc	r29, r17
     1ae:	21 f0       	breq	.+8      	; 0x1b8 <_ZN11ColorSensorD1Ev+0x24>
     1b0:	29 97       	sbiw	r28, 0x09	; 9
     1b2:	ce 01       	movw	r24, r28
     1b4:	cb df       	rcall	.-106    	; 0x14c <_ZN5ColorD1Ev>
     1b6:	f9 cf       	rjmp	.-14     	; 0x1aa <_ZN11ColorSensorD1Ev+0x16>
{	
}
     1b8:	df 91       	pop	r29
     1ba:	cf 91       	pop	r28
     1bc:	1f 91       	pop	r17
     1be:	0f 91       	pop	r16
     1c0:	08 95       	ret

000001c2 <_ZN11ColorSensor9setFilterE6Filter>:
	}
}

void ColorSensor::setFilter( Filter filter_ )
{
	switch ( filter_ )
     1c2:	61 30       	cpi	r22, 0x01	; 1
     1c4:	31 f0       	breq	.+12     	; 0x1d2 <_ZN11ColorSensor9setFilterE6Filter+0x10>
     1c6:	00 f1       	brcs	.+64     	; 0x208 <_ZN11ColorSensor9setFilterE6Filter+0x46>
     1c8:	62 30       	cpi	r22, 0x02	; 2
     1ca:	a9 f0       	breq	.+42     	; 0x1f6 <_ZN11ColorSensor9setFilterE6Filter+0x34>
     1cc:	63 30       	cpi	r22, 0x03	; 3
     1ce:	51 f0       	breq	.+20     	; 0x1e4 <_ZN11ColorSensor9setFilterE6Filter+0x22>
     1d0:	08 95       	ret
	{
	case redFilter:
		COLORSENSOR_S2_PORT &= ~( COLORSENSOR_S2_PIN );
     1d2:	e8 e0       	ldi	r30, 0x08	; 8
     1d4:	f1 e0       	ldi	r31, 0x01	; 1
     1d6:	80 81       	ld	r24, Z
     1d8:	8a 7f       	andi	r24, 0xFA	; 250
     1da:	80 83       	st	Z, r24
		COLORSENSOR_S3_PORT &= ~( COLORSENSOR_S3_PIN );
     1dc:	80 81       	ld	r24, Z
     1de:	8b 7f       	andi	r24, 0xFB	; 251
     1e0:	80 83       	st	Z, r24
		break;
     1e2:	08 95       	ret

	case blueFilter:
		COLORSENSOR_S2_PORT &= ~( COLORSENSOR_S2_PIN );
     1e4:	e8 e0       	ldi	r30, 0x08	; 8
     1e6:	f1 e0       	ldi	r31, 0x01	; 1
     1e8:	80 81       	ld	r24, Z
     1ea:	8a 7f       	andi	r24, 0xFA	; 250
     1ec:	80 83       	st	Z, r24
		COLORSENSOR_S3_PORT |= COLORSENSOR_S3_PIN;
     1ee:	80 81       	ld	r24, Z
     1f0:	84 60       	ori	r24, 0x04	; 4
     1f2:	80 83       	st	Z, r24
		break;
     1f4:	08 95       	ret

	case greenFilter:
		COLORSENSOR_S2_PORT |= COLORSENSOR_S2_PIN;
     1f6:	e8 e0       	ldi	r30, 0x08	; 8
     1f8:	f1 e0       	ldi	r31, 0x01	; 1
     1fa:	80 81       	ld	r24, Z
     1fc:	85 60       	ori	r24, 0x05	; 5
     1fe:	80 83       	st	Z, r24
		COLORSENSOR_S3_PORT |= COLORSENSOR_S3_PIN;
     200:	80 81       	ld	r24, Z
     202:	84 60       	ori	r24, 0x04	; 4
     204:	80 83       	st	Z, r24
		break;
     206:	08 95       	ret

	case noFilter:
		COLORSENSOR_S2_PORT |= COLORSENSOR_S2_PIN;
     208:	e8 e0       	ldi	r30, 0x08	; 8
     20a:	f1 e0       	ldi	r31, 0x01	; 1
     20c:	80 81       	ld	r24, Z
     20e:	85 60       	ori	r24, 0x05	; 5
     210:	80 83       	st	Z, r24
		COLORSENSOR_S3_PORT &= ~( COLORSENSOR_S3_PIN );
     212:	80 81       	ld	r24, Z
     214:	8b 7f       	andi	r24, 0xFB	; 251
     216:	80 83       	st	Z, r24
     218:	08 95       	ret

0000021a <_ZN11ColorSensor8getColorEv>:
ColorSensor::~ColorSensor()
{	
}

uint8_t ColorSensor::getColor()
{
     21a:	6f 92       	push	r6
     21c:	7f 92       	push	r7
     21e:	8f 92       	push	r8
     220:	9f 92       	push	r9
     222:	af 92       	push	r10
     224:	bf 92       	push	r11
     226:	cf 92       	push	r12
     228:	df 92       	push	r13
     22a:	ef 92       	push	r14
     22c:	ff 92       	push	r15
     22e:	0f 93       	push	r16
     230:	1f 93       	push	r17
     232:	cf 93       	push	r28
     234:	df 93       	push	r29
     236:	8c 01       	movw	r16, r24
	uint8_t result = 255;
	
	// Get period values from all filters
	setFilter( redFilter );
     238:	61 e0       	ldi	r22, 0x01	; 1
     23a:	c3 df       	rcall	.-122    	; 0x1c2 <_ZN11ColorSensor9setFilterE6Filter>
	uint16_t redPeriod = frequency_.getPeriod();
     23c:	c8 01       	movw	r24, r16
     23e:	43 d1       	rcall	.+646    	; 0x4c6 <_ZN6Timer49getPeriodEv>
     240:	7c 01       	movw	r14, r24

	setFilter( blueFilter );
     242:	63 e0       	ldi	r22, 0x03	; 3
     244:	c8 01       	movw	r24, r16
	uint16_t bluePeriod = frequency_.getPeriod();  
     246:	bd df       	rcall	.-134    	; 0x1c2 <_ZN11ColorSensor9setFilterE6Filter>
     248:	c8 01       	movw	r24, r16
     24a:	3d d1       	rcall	.+634    	; 0x4c6 <_ZN6Timer49getPeriodEv>

	setFilter( greenFilter );
     24c:	6c 01       	movw	r12, r24
     24e:	62 e0       	ldi	r22, 0x02	; 2
     250:	c8 01       	movw	r24, r16
	uint16_t greenPeriod = frequency_.getPeriod();
     252:	b7 df       	rcall	.-146    	; 0x1c2 <_ZN11ColorSensor9setFilterE6Filter>
     254:	c8 01       	movw	r24, r16
	
	setFilter( noFilter );
     256:	37 d1       	rcall	.+622    	; 0x4c6 <_ZN6Timer49getPeriodEv>
     258:	5c 01       	movw	r10, r24
     25a:	60 e0       	ldi	r22, 0x00	; 0
     25c:	c8 01       	movw	r24, r16
	uint16_t whitePeriod = frequency_.getPeriod();
     25e:	b1 df       	rcall	.-158    	; 0x1c2 <_ZN11ColorSensor9setFilterE6Filter>
     260:	c8 01       	movw	r24, r16
     262:	31 d1       	rcall	.+610    	; 0x4c6 <_ZN6Timer49getPeriodEv>
     264:	4c 01       	movw	r8, r24
	
	// Check all stored colors against read values	
	for ( uint8_t index = 0U; index < 10; index++)
     266:	71 2c       	mov	r7, r1
     268:	89 e0       	ldi	r24, 0x09	; 9
     26a:	87 15       	cp	r24, r7
     26c:	08 f4       	brcc	.+2      	; 0x270 <_ZN11ColorSensor8getColorEv+0x56>
     26e:	5a c0       	rjmp	.+180    	; 0x324 <_ZN11ColorSensor8getColorEv+0x10a>
	{		
		if ( _colors[index].getRedPeriod() + 5 > redPeriod && _colors[index].getRedPeriod() - 5 < redPeriod )
     270:	c7 2d       	mov	r28, r7
     272:	d0 e0       	ldi	r29, 0x00	; 0
     274:	ce 01       	movw	r24, r28
     276:	88 0f       	add	r24, r24
     278:	99 1f       	adc	r25, r25
     27a:	88 0f       	add	r24, r24
     27c:	99 1f       	adc	r25, r25
     27e:	88 0f       	add	r24, r24
     280:	99 1f       	adc	r25, r25
     282:	c8 0f       	add	r28, r24
     284:	d9 1f       	adc	r29, r25
     286:	21 96       	adiw	r28, 0x01	; 1
     288:	c0 0f       	add	r28, r16
     28a:	d1 1f       	adc	r29, r17
     28c:	ce 01       	movw	r24, r28
     28e:	5f df       	rcall	.-322    	; 0x14e <_ZN5Color12getRedPeriodEv>
     290:	05 96       	adiw	r24, 0x05	; 5
     292:	e8 16       	cp	r14, r24
     294:	f9 06       	cpc	r15, r25
     296:	48 f4       	brcc	.+18     	; 0x2aa <_ZN11ColorSensor8getColorEv+0x90>
     298:	ce 01       	movw	r24, r28
     29a:	59 df       	rcall	.-334    	; 0x14e <_ZN5Color12getRedPeriodEv>
     29c:	05 97       	sbiw	r24, 0x05	; 5
     29e:	8e 15       	cp	r24, r14
     2a0:	9f 05       	cpc	r25, r15
     2a2:	28 f4       	brcc	.+10     	; 0x2ae <_ZN11ColorSensor8getColorEv+0x94>
     2a4:	66 24       	eor	r6, r6
     2a6:	63 94       	inc	r6
     2a8:	03 c0       	rjmp	.+6      	; 0x2b0 <_ZN11ColorSensor8getColorEv+0x96>
     2aa:	61 2c       	mov	r6, r1
     2ac:	01 c0       	rjmp	.+2      	; 0x2b0 <_ZN11ColorSensor8getColorEv+0x96>
     2ae:	61 2c       	mov	r6, r1
		{
			if ( _colors[index].getBluePeriod() + 5 > bluePeriod && _colors[index].getBluePeriod() - 5 < bluePeriod )
     2b0:	66 20       	and	r6, r6
     2b2:	b1 f1       	breq	.+108    	; 0x320 <_ZN11ColorSensor8getColorEv+0x106>
     2b4:	ce 01       	movw	r24, r28
     2b6:	4f df       	rcall	.-354    	; 0x156 <_ZN5Color13getBluePeriodEv>
     2b8:	05 96       	adiw	r24, 0x05	; 5
     2ba:	c8 16       	cp	r12, r24
     2bc:	d9 06       	cpc	r13, r25
     2be:	38 f4       	brcc	.+14     	; 0x2ce <_ZN11ColorSensor8getColorEv+0xb4>
     2c0:	ce 01       	movw	r24, r28
     2c2:	49 df       	rcall	.-366    	; 0x156 <_ZN5Color13getBluePeriodEv>
     2c4:	05 97       	sbiw	r24, 0x05	; 5
     2c6:	8c 15       	cp	r24, r12
     2c8:	9d 05       	cpc	r25, r13
     2ca:	18 f4       	brcc	.+6      	; 0x2d2 <_ZN11ColorSensor8getColorEv+0xb8>
     2cc:	03 c0       	rjmp	.+6      	; 0x2d4 <_ZN11ColorSensor8getColorEv+0xba>
     2ce:	61 2c       	mov	r6, r1
     2d0:	01 c0       	rjmp	.+2      	; 0x2d4 <_ZN11ColorSensor8getColorEv+0xba>
     2d2:	61 2c       	mov	r6, r1
			{
				if ( _colors[index].getGreenPeriod() + 5 > greenPeriod && _colors[index].getGreenPeriod() - 5 < greenPeriod )
     2d4:	66 20       	and	r6, r6
     2d6:	21 f1       	breq	.+72     	; 0x320 <_ZN11ColorSensor8getColorEv+0x106>
     2d8:	ce 01       	movw	r24, r28
     2da:	41 df       	rcall	.-382    	; 0x15e <_ZN5Color14getGreenPeriodEv>
     2dc:	05 96       	adiw	r24, 0x05	; 5
     2de:	a8 16       	cp	r10, r24
     2e0:	b9 06       	cpc	r11, r25
     2e2:	38 f4       	brcc	.+14     	; 0x2f2 <_ZN11ColorSensor8getColorEv+0xd8>
     2e4:	ce 01       	movw	r24, r28
     2e6:	3b df       	rcall	.-394    	; 0x15e <_ZN5Color14getGreenPeriodEv>
     2e8:	05 97       	sbiw	r24, 0x05	; 5
     2ea:	8a 15       	cp	r24, r10
     2ec:	9b 05       	cpc	r25, r11
     2ee:	18 f4       	brcc	.+6      	; 0x2f6 <_ZN11ColorSensor8getColorEv+0xdc>
     2f0:	03 c0       	rjmp	.+6      	; 0x2f8 <_ZN11ColorSensor8getColorEv+0xde>
     2f2:	61 2c       	mov	r6, r1
     2f4:	01 c0       	rjmp	.+2      	; 0x2f8 <_ZN11ColorSensor8getColorEv+0xde>
     2f6:	61 2c       	mov	r6, r1
				{
					if ( _colors[index].getWhitePeriod() + 2 > whitePeriod && _colors[index].getWhitePeriod() - 2 < whitePeriod )
     2f8:	66 20       	and	r6, r6
     2fa:	91 f0       	breq	.+36     	; 0x320 <_ZN11ColorSensor8getColorEv+0x106>
     2fc:	ce 01       	movw	r24, r28
     2fe:	33 df       	rcall	.-410    	; 0x166 <_ZN5Color14getWhitePeriodEv>
     300:	02 96       	adiw	r24, 0x02	; 2
     302:	88 16       	cp	r8, r24
     304:	99 06       	cpc	r9, r25
     306:	38 f4       	brcc	.+14     	; 0x316 <_ZN11ColorSensor8getColorEv+0xfc>
     308:	ce 01       	movw	r24, r28
     30a:	2d df       	rcall	.-422    	; 0x166 <_ZN5Color14getWhitePeriodEv>
     30c:	02 97       	sbiw	r24, 0x02	; 2
     30e:	88 15       	cp	r24, r8
     310:	99 05       	cpc	r25, r9
     312:	18 f4       	brcc	.+6      	; 0x31a <_ZN11ColorSensor8getColorEv+0x100>
     314:	03 c0       	rjmp	.+6      	; 0x31c <_ZN11ColorSensor8getColorEv+0x102>
     316:	61 2c       	mov	r6, r1
     318:	01 c0       	rjmp	.+2      	; 0x31c <_ZN11ColorSensor8getColorEv+0x102>
     31a:	61 2c       	mov	r6, r1
     31c:	61 10       	cpse	r6, r1
     31e:	04 c0       	rjmp	.+8      	; 0x328 <_ZN11ColorSensor8getColorEv+0x10e>
	
	setFilter( noFilter );
	uint16_t whitePeriod = frequency_.getPeriod();
	
	// Check all stored colors against read values	
	for ( uint8_t index = 0U; index < 10; index++)
     320:	73 94       	inc	r7
     322:	a2 cf       	rjmp	.-188    	; 0x268 <_ZN11ColorSensor8getColorEv+0x4e>
{	
}

uint8_t ColorSensor::getColor()
{
	uint8_t result = 255;
     324:	77 24       	eor	r7, r7
     326:	7a 94       	dec	r7
		}
	}
	
	// Return value
	return result;
}
     328:	87 2d       	mov	r24, r7
     32a:	df 91       	pop	r29
     32c:	cf 91       	pop	r28
     32e:	1f 91       	pop	r17
     330:	0f 91       	pop	r16
     332:	ff 90       	pop	r15
     334:	ef 90       	pop	r14
     336:	df 90       	pop	r13
     338:	cf 90       	pop	r12
     33a:	bf 90       	pop	r11
     33c:	af 90       	pop	r10
     33e:	9f 90       	pop	r9
     340:	8f 90       	pop	r8
     342:	7f 90       	pop	r7
     344:	6f 90       	pop	r6
     346:	08 95       	ret

00000348 <_ZN11ColorSensor17addCalibrateColorEh>:

void ColorSensor::addCalibrateColor( uint8_t colorIndex )
{
     348:	ff 92       	push	r15
     34a:	0f 93       	push	r16
     34c:	1f 93       	push	r17
     34e:	cf 93       	push	r28
     350:	df 93       	push	r29
	if ( colorIndex < 10U )
     352:	6a 30       	cpi	r22, 0x0A	; 10
     354:	08 f0       	brcs	.+2      	; 0x358 <_ZN11ColorSensor17addCalibrateColorEh+0x10>
     356:	33 c0       	rjmp	.+102    	; 0x3be <_ZN11ColorSensor17addCalibrateColorEh+0x76>
     358:	f6 2e       	mov	r15, r22
     35a:	ec 01       	movw	r28, r24
	{	
		// Set all colors
		setFilter( redFilter );
     35c:	61 e0       	ldi	r22, 0x01	; 1
     35e:	31 df       	rcall	.-414    	; 0x1c2 <_ZN11ColorSensor9setFilterE6Filter>
		_colors[colorIndex].setRedPeriod( frequency_.getPeriod() );
     360:	ce 01       	movw	r24, r28
     362:	b1 d0       	rcall	.+354    	; 0x4c6 <_ZN6Timer49getPeriodEv>
     364:	2f 2d       	mov	r18, r15
     366:	30 e0       	ldi	r19, 0x00	; 0
     368:	89 01       	movw	r16, r18
     36a:	00 0f       	add	r16, r16
     36c:	11 1f       	adc	r17, r17
     36e:	00 0f       	add	r16, r16
     370:	11 1f       	adc	r17, r17
     372:	00 0f       	add	r16, r16
     374:	11 1f       	adc	r17, r17
     376:	02 0f       	add	r16, r18
     378:	13 1f       	adc	r17, r19
     37a:	0f 5f       	subi	r16, 0xFF	; 255
     37c:	1f 4f       	sbci	r17, 0xFF	; 255
     37e:	0c 0f       	add	r16, r28
     380:	1d 1f       	adc	r17, r29
     382:	bc 01       	movw	r22, r24
     384:	c8 01       	movw	r24, r16
     386:	f3 de       	rcall	.-538    	; 0x16e <_ZN5Color12setRedPeriodEj>

		setFilter( blueFilter );
     388:	63 e0       	ldi	r22, 0x03	; 3
     38a:	ce 01       	movw	r24, r28
     38c:	1a df       	rcall	.-460    	; 0x1c2 <_ZN11ColorSensor9setFilterE6Filter>
		_colors[colorIndex].setBluePeriod( frequency_.getPeriod() );
     38e:	ce 01       	movw	r24, r28
     390:	9a d0       	rcall	.+308    	; 0x4c6 <_ZN6Timer49getPeriodEv>
     392:	bc 01       	movw	r22, r24
     394:	c8 01       	movw	r24, r16
     396:	ef de       	rcall	.-546    	; 0x176 <_ZN5Color13setBluePeriodEj>
		
		setFilter( greenFilter );
     398:	62 e0       	ldi	r22, 0x02	; 2
     39a:	ce 01       	movw	r24, r28
     39c:	12 df       	rcall	.-476    	; 0x1c2 <_ZN11ColorSensor9setFilterE6Filter>
		_colors[colorIndex].setGreenPeriod( frequency_.getPeriod() );
     39e:	ce 01       	movw	r24, r28
     3a0:	92 d0       	rcall	.+292    	; 0x4c6 <_ZN6Timer49getPeriodEv>
     3a2:	bc 01       	movw	r22, r24
     3a4:	c8 01       	movw	r24, r16
     3a6:	eb de       	rcall	.-554    	; 0x17e <_ZN5Color14setGreenPeriodEj>
		
		setFilter( noFilter );
     3a8:	60 e0       	ldi	r22, 0x00	; 0
     3aa:	ce 01       	movw	r24, r28
     3ac:	0a df       	rcall	.-492    	; 0x1c2 <_ZN11ColorSensor9setFilterE6Filter>
		_colors[colorIndex].setWhitePeriod( frequency_.getPeriod() );
     3ae:	ce 01       	movw	r24, r28
     3b0:	8a d0       	rcall	.+276    	; 0x4c6 <_ZN6Timer49getPeriodEv>
     3b2:	bc 01       	movw	r22, r24
     3b4:	c8 01       	movw	r24, r16
     3b6:	e7 de       	rcall	.-562    	; 0x186 <_ZN5Color14setWhitePeriodEj>
     3b8:	6f 2d       	mov	r22, r15
     3ba:	c8 01       	movw	r24, r16
				
		// Set index
		_colors[colorIndex].setColorIndex( colorIndex );
     3bc:	e8 de       	rcall	.-560    	; 0x18e <_ZN5Color13setColorIndexEh>
     3be:	df 91       	pop	r29
     3c0:	cf 91       	pop	r28
     3c2:	1f 91       	pop	r17
	}
	else
	{
		/* Cant add more colors. Increase size of array. */
	}
}
     3c4:	0f 91       	pop	r16
     3c6:	ff 90       	pop	r15
     3c8:	08 95       	ret

000003ca <_ZN11ColorSensor19setFrequencyscalingE16FrequencyScaling>:
     3ca:	61 30       	cpi	r22, 0x01	; 1
     3cc:	79 f0       	breq	.+30     	; 0x3ec <_ZN11ColorSensor19setFrequencyscalingE16FrequencyScaling+0x22>
     3ce:	28 f0       	brcs	.+10     	; 0x3da <_ZN11ColorSensor19setFrequencyscalingE16FrequencyScaling+0x10>
	}	
}

void ColorSensor::setFrequencyscaling( FrequencyScaling scaling )
{
	switch (scaling)
     3d0:	62 30       	cpi	r22, 0x02	; 2
     3d2:	a9 f0       	breq	.+42     	; 0x3fe <_ZN11ColorSensor19setFrequencyscalingE16FrequencyScaling+0x34>
     3d4:	63 30       	cpi	r22, 0x03	; 3
     3d6:	e1 f0       	breq	.+56     	; 0x410 <__LOCK_REGION_LENGTH__+0x10>
     3d8:	08 95       	ret
	{
	case powerDown:
		COLORSENSOR_S0_PORT &= ~( COLORSENSOR_S0_PIN );
     3da:	e8 e0       	ldi	r30, 0x08	; 8
     3dc:	f1 e0       	ldi	r31, 0x01	; 1
     3de:	80 81       	ld	r24, Z
     3e0:	88 7f       	andi	r24, 0xF8	; 248
     3e2:	80 83       	st	Z, r24
		COLORSENSOR_S1_PORT &= ~( COLORSENSOR_S1_PIN );
     3e4:	80 81       	ld	r24, Z
     3e6:	89 7f       	andi	r24, 0xF9	; 249
     3e8:	80 83       	st	Z, r24
		break;
     3ea:	08 95       	ret

	case twoPercent:
		COLORSENSOR_S0_PORT &= ~( COLORSENSOR_S0_PIN );
     3ec:	e8 e0       	ldi	r30, 0x08	; 8
     3ee:	f1 e0       	ldi	r31, 0x01	; 1
     3f0:	80 81       	ld	r24, Z
     3f2:	88 7f       	andi	r24, 0xF8	; 248
     3f4:	80 83       	st	Z, r24
		COLORSENSOR_S1_PORT |= COLORSENSOR_S1_PIN;
     3f6:	80 81       	ld	r24, Z
     3f8:	86 60       	ori	r24, 0x06	; 6
     3fa:	80 83       	st	Z, r24
		break;
     3fc:	08 95       	ret

	case twentyPercent:
		COLORSENSOR_S0_PORT |= COLORSENSOR_S0_PIN;
     3fe:	e8 e0       	ldi	r30, 0x08	; 8
     400:	f1 e0       	ldi	r31, 0x01	; 1
     402:	80 81       	ld	r24, Z
     404:	87 60       	ori	r24, 0x07	; 7
     406:	80 83       	st	Z, r24
		COLORSENSOR_S1_PORT &= ~( COLORSENSOR_S1_PIN );
     408:	80 81       	ld	r24, Z
     40a:	89 7f       	andi	r24, 0xF9	; 249
     40c:	80 83       	st	Z, r24
		break;
     40e:	08 95       	ret

	case hundredPercent:
		COLORSENSOR_S0_PORT |= COLORSENSOR_S0_PIN;
     410:	e8 e0       	ldi	r30, 0x08	; 8
     412:	f1 e0       	ldi	r31, 0x01	; 1
     414:	80 81       	ld	r24, Z
     416:	87 60       	ori	r24, 0x07	; 7
     418:	80 83       	st	Z, r24
		COLORSENSOR_S1_PORT |= COLORSENSOR_S1_PIN;
     41a:	80 81       	ld	r24, Z
     41c:	86 60       	ori	r24, 0x06	; 6
     41e:	80 83       	st	Z, r24
     420:	08 95       	ret

00000422 <_ZN11ColorSensorC1E16FrequencyScaling>:
#include "FreeRTOS.h"
#include "task.h"
#include "portmacro.h"

// default constructor
ColorSensor::ColorSensor( FrequencyScaling scaling )
     422:	bf 92       	push	r11
     424:	cf 92       	push	r12
     426:	df 92       	push	r13
     428:	ef 92       	push	r14
     42a:	ff 92       	push	r15
     42c:	0f 93       	push	r16
     42e:	1f 93       	push	r17
     430:	cf 93       	push	r28
     432:	df 93       	push	r29
     434:	1f 92       	push	r1
     436:	cd b7       	in	r28, 0x3d	; 61
     438:	de b7       	in	r29, 0x3e	; 62
     43a:	6c 01       	movw	r12, r24
     43c:	b6 2e       	mov	r11, r22
     43e:	26 d0       	rcall	.+76     	; 0x48c <_ZN6Timer4C1Ev>
     440:	76 01       	movw	r14, r12
     442:	8f ef       	ldi	r24, 0xFF	; 255
     444:	e8 1a       	sub	r14, r24
     446:	f8 0a       	sbc	r15, r24
     448:	09 e0       	ldi	r16, 0x09	; 9
     44a:	10 e0       	ldi	r17, 0x00	; 0
     44c:	0f 3f       	cpi	r16, 0xFF	; 255
     44e:	8f ef       	ldi	r24, 0xFF	; 255
     450:	18 07       	cpc	r17, r24
     452:	41 f0       	breq	.+16     	; 0x464 <_ZN11ColorSensorC1E16FrequencyScaling+0x42>
     454:	c7 01       	movw	r24, r14
     456:	79 de       	rcall	.-782    	; 0x14a <_ZN5ColorC1Ev>
     458:	89 e0       	ldi	r24, 0x09	; 9
     45a:	e8 0e       	add	r14, r24
     45c:	f1 1c       	adc	r15, r1
     45e:	01 50       	subi	r16, 0x01	; 1
     460:	11 09       	sbc	r17, r1
     462:	f4 cf       	rjmp	.-24     	; 0x44c <_ZN11ColorSensorC1E16FrequencyScaling+0x2a>
{
	frequency_ = Timer4();
     464:	ce 01       	movw	r24, r28
     466:	01 96       	adiw	r24, 0x01	; 1
     468:	11 d0       	rcall	.+34     	; 0x48c <_ZN6Timer4C1Ev>

	// Set default filter and scaling
	setFilter( noFilter );
     46a:	60 e0       	ldi	r22, 0x00	; 0
     46c:	c6 01       	movw	r24, r12
     46e:	a9 de       	rcall	.-686    	; 0x1c2 <_ZN11ColorSensor9setFilterE6Filter>
	setFrequencyscaling( scaling );
     470:	6b 2d       	mov	r22, r11
     472:	c6 01       	movw	r24, r12
     474:	aa df       	rcall	.-172    	; 0x3ca <_ZN11ColorSensor19setFrequencyscalingE16FrequencyScaling>
     476:	0f 90       	pop	r0
}
     478:	df 91       	pop	r29
     47a:	cf 91       	pop	r28
     47c:	1f 91       	pop	r17
     47e:	0f 91       	pop	r16
     480:	ff 90       	pop	r15
     482:	ef 90       	pop	r14
     484:	df 90       	pop	r13
     486:	cf 90       	pop	r12
     488:	bf 90       	pop	r11
     48a:	08 95       	ret

0000048c <_ZN6Timer4C1Ev>:
//volatile float tick = 0.000064;

Timer4::Timer4()
{
	// Set ports to the right values.
	COLORSENSOR_S0_PORT |= ( 1 << COLORSENSOR_S0_PIN );
     48c:	e8 e0       	ldi	r30, 0x08	; 8
     48e:	f1 e0       	ldi	r31, 0x01	; 1
     490:	80 81       	ld	r24, Z
     492:	80 68       	ori	r24, 0x80	; 128
     494:	80 83       	st	Z, r24
	COLORSENSOR_S1_PORT |= ( 1 << COLORSENSOR_S1_PIN );
     496:	80 81       	ld	r24, Z
     498:	80 64       	ori	r24, 0x40	; 64
     49a:	80 83       	st	Z, r24
	COLORSENSOR_S2_PORT |= ( 1 << COLORSENSOR_S2_PIN );
     49c:	80 81       	ld	r24, Z
     49e:	80 62       	ori	r24, 0x20	; 32
     4a0:	80 83       	st	Z, r24
	COLORSENSOR_S3_PORT |= ( 1 << COLORSENSOR_S3_PIN );
     4a2:	80 81       	ld	r24, Z
     4a4:	80 61       	ori	r24, 0x10	; 16
     4a6:	80 83       	st	Z, r24
	
	// Setup timer to normal mode and pre scaler to 64
	TCCR4A = 0U;
     4a8:	10 92 a0 00 	sts	0x00A0, r1	; 0x8000a0 <__TEXT_REGION_LENGTH__+0x7000a0>
	TCCR4B = ( 1 << ICNC4 ) | ( 1 << ICES4 ) | ( 1 << CS40 ) | ( 1 << CS41 );
     4ac:	83 ec       	ldi	r24, 0xC3	; 195
     4ae:	80 93 a1 00 	sts	0x00A1, r24	; 0x8000a1 <__TEXT_REGION_LENGTH__+0x7000a1>
	TCCR4C = 0U;
     4b2:	10 92 a2 00 	sts	0x00A2, r1	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
	
	// Clear flags and set counter to zero
	TIFR4 = ( 1 << ICF4 ) | ( 1 << TOV4 );
     4b6:	81 e2       	ldi	r24, 0x21	; 33
     4b8:	89 bb       	out	0x19, r24	; 25
	TCNT4 = 0;        
     4ba:	10 92 a5 00 	sts	0x00A5, r1	; 0x8000a5 <__TEXT_REGION_LENGTH__+0x7000a5>
     4be:	10 92 a4 00 	sts	0x00A4, r1	; 0x8000a4 <__TEXT_REGION_LENGTH__+0x7000a4>

	// Enable global interrupts
    sei();
     4c2:	78 94       	sei
     4c4:	08 95       	ret

000004c6 <_ZN6Timer49getPeriodEv>:
}

uint16_t Timer4::getPeriod( void )
{
	// Reset all needed values
	first = true;
     4c6:	81 e0       	ldi	r24, 0x01	; 1
     4c8:	80 93 0a 02 	sts	0x020A, r24	; 0x80020a <first>
	oldValue = 0U;
     4cc:	10 92 95 02 	sts	0x0295, r1	; 0x800295 <oldValue+0x1>
     4d0:	10 92 94 02 	sts	0x0294, r1	; 0x800294 <oldValue>
	period = 0U;
     4d4:	10 92 8f 02 	sts	0x028F, r1	; 0x80028f <__data_end+0x1>
     4d8:	10 92 8e 02 	sts	0x028E, r1	; 0x80028e <__data_end>
	timeroverflow = 0;
     4dc:	10 92 90 02 	sts	0x0290, r1	; 0x800290 <timeroverflow>
     4e0:	10 92 91 02 	sts	0x0291, r1	; 0x800291 <timeroverflow+0x1>
     4e4:	10 92 92 02 	sts	0x0292, r1	; 0x800292 <timeroverflow+0x2>
     4e8:	10 92 93 02 	sts	0x0293, r1	; 0x800293 <timeroverflow+0x3>
	
	// Enable interrupt and clear pending
	TIFR4 = ( 1 << ICF4 ) | ( 1 << TOV4 );
     4ec:	81 e2       	ldi	r24, 0x21	; 33
     4ee:	89 bb       	out	0x19, r24	; 25
	TIMSK4 = ( 1 << ICIE4 ) | ( 1 << TOIE4 );	
     4f0:	80 93 72 00 	sts	0x0072, r24	; 0x800072 <__TEXT_REGION_LENGTH__+0x700072>
	
	// Wait until measurement has been taken
	while ( period == 0U )
     4f4:	80 91 8e 02 	lds	r24, 0x028E	; 0x80028e <__data_end>
     4f8:	90 91 8f 02 	lds	r25, 0x028F	; 0x80028f <__data_end+0x1>
     4fc:	89 2b       	or	r24, r25
     4fe:	81 f4       	brne	.+32     	; 0x520 <_ZN6Timer49getPeriodEv+0x5a>
	{
		if ( timeroverflow > 10U )
     500:	80 91 90 02 	lds	r24, 0x0290	; 0x800290 <timeroverflow>
     504:	90 91 91 02 	lds	r25, 0x0291	; 0x800291 <timeroverflow+0x1>
     508:	a0 91 92 02 	lds	r26, 0x0292	; 0x800292 <timeroverflow+0x2>
     50c:	b0 91 93 02 	lds	r27, 0x0293	; 0x800293 <timeroverflow+0x3>
     510:	0b 97       	sbiw	r24, 0x0b	; 11
     512:	a1 05       	cpc	r26, r1
     514:	b1 05       	cpc	r27, r1
     516:	70 f3       	brcs	.-36     	; 0x4f4 <_ZN6Timer49getPeriodEv+0x2e>
		{
			// Error - Disable interrupt and clear pending
			TIMSK4 = 0U;
     518:	10 92 72 00 	sts	0x0072, r1	; 0x800072 <__TEXT_REGION_LENGTH__+0x700072>
			TIFR4 = ( 1 << ICF4 ) | ( 1 << TOV4 );
     51c:	81 e2       	ldi	r24, 0x21	; 33
     51e:	89 bb       	out	0x19, r24	; 25
			break;
		}
	}
	
	return period;
     520:	80 91 8e 02 	lds	r24, 0x028E	; 0x80028e <__data_end>
     524:	90 91 8f 02 	lds	r25, 0x028F	; 0x80028f <__data_end+0x1>
}
     528:	08 95       	ret

0000052a <__vector_45>:

ISR(TIMER4_OVF_vect)
{
     52a:	1f 92       	push	r1
     52c:	0f 92       	push	r0
     52e:	0f b6       	in	r0, 0x3f	; 63
     530:	0f 92       	push	r0
     532:	11 24       	eor	r1, r1
     534:	8f 93       	push	r24
     536:	9f 93       	push	r25
     538:	af 93       	push	r26
     53a:	bf 93       	push	r27
	timeroverflow++;
     53c:	80 91 90 02 	lds	r24, 0x0290	; 0x800290 <timeroverflow>
     540:	90 91 91 02 	lds	r25, 0x0291	; 0x800291 <timeroverflow+0x1>
     544:	a0 91 92 02 	lds	r26, 0x0292	; 0x800292 <timeroverflow+0x2>
     548:	b0 91 93 02 	lds	r27, 0x0293	; 0x800293 <timeroverflow+0x3>
     54c:	01 96       	adiw	r24, 0x01	; 1
     54e:	a1 1d       	adc	r26, r1
     550:	b1 1d       	adc	r27, r1
     552:	80 93 90 02 	sts	0x0290, r24	; 0x800290 <timeroverflow>
     556:	90 93 91 02 	sts	0x0291, r25	; 0x800291 <timeroverflow+0x1>
     55a:	a0 93 92 02 	sts	0x0292, r26	; 0x800292 <timeroverflow+0x2>
     55e:	b0 93 93 02 	sts	0x0293, r27	; 0x800293 <timeroverflow+0x3>
}
     562:	bf 91       	pop	r27
     564:	af 91       	pop	r26
     566:	9f 91       	pop	r25
     568:	8f 91       	pop	r24
     56a:	0f 90       	pop	r0
     56c:	0f be       	out	0x3f, r0	; 63
     56e:	0f 90       	pop	r0
     570:	1f 90       	pop	r1
     572:	18 95       	reti

00000574 <__vector_41>:

ISR(TIMER4_CAPT_vect)
{
     574:	1f 92       	push	r1
     576:	0f 92       	push	r0
     578:	0f b6       	in	r0, 0x3f	; 63
     57a:	0f 92       	push	r0
     57c:	11 24       	eor	r1, r1
     57e:	0b b6       	in	r0, 0x3b	; 59
     580:	0f 92       	push	r0
     582:	cf 92       	push	r12
     584:	df 92       	push	r13
     586:	ef 92       	push	r14
     588:	ff 92       	push	r15
     58a:	0f 93       	push	r16
     58c:	1f 93       	push	r17
     58e:	2f 93       	push	r18
     590:	3f 93       	push	r19
     592:	4f 93       	push	r20
     594:	5f 93       	push	r21
     596:	6f 93       	push	r22
     598:	7f 93       	push	r23
     59a:	8f 93       	push	r24
     59c:	9f 93       	push	r25
     59e:	af 93       	push	r26
     5a0:	bf 93       	push	r27
     5a2:	ef 93       	push	r30
     5a4:	ff 93       	push	r31
	// Read value of timer
	uint16_t readValue = ICR4;
     5a6:	60 91 a6 00 	lds	r22, 0x00A6	; 0x8000a6 <__TEXT_REGION_LENGTH__+0x7000a6>
     5aa:	70 91 a7 00 	lds	r23, 0x00A7	; 0x8000a7 <__TEXT_REGION_LENGTH__+0x7000a7>

	if ( first == true )
     5ae:	80 91 0a 02 	lds	r24, 0x020A	; 0x80020a <first>
     5b2:	88 23       	and	r24, r24
     5b4:	79 f0       	breq	.+30     	; 0x5d4 <__vector_41+0x60>
	{
		timeroverflow = 0U;
     5b6:	10 92 90 02 	sts	0x0290, r1	; 0x800290 <timeroverflow>
     5ba:	10 92 91 02 	sts	0x0291, r1	; 0x800291 <timeroverflow+0x1>
     5be:	10 92 92 02 	sts	0x0292, r1	; 0x800292 <timeroverflow+0x2>
     5c2:	10 92 93 02 	sts	0x0293, r1	; 0x800293 <timeroverflow+0x3>
		oldValue = readValue;
     5c6:	70 93 95 02 	sts	0x0295, r23	; 0x800295 <oldValue+0x1>
     5ca:	60 93 94 02 	sts	0x0294, r22	; 0x800294 <oldValue>
		first = false;
     5ce:	10 92 0a 02 	sts	0x020A, r1	; 0x80020a <first>
		return;
     5d2:	81 c0       	rjmp	.+258    	; 0x6d6 <__vector_41+0x162>
	}
	
	// Check if overflow is pending
	if ( TIFR4 & ( 1 << TOV4 ))
     5d4:	c8 9b       	sbis	0x19, 0	; 25
     5d6:	13 c0       	rjmp	.+38     	; 0x5fe <__vector_41+0x8a>
	{
		timeroverflow++;
     5d8:	80 91 90 02 	lds	r24, 0x0290	; 0x800290 <timeroverflow>
     5dc:	90 91 91 02 	lds	r25, 0x0291	; 0x800291 <timeroverflow+0x1>
     5e0:	a0 91 92 02 	lds	r26, 0x0292	; 0x800292 <timeroverflow+0x2>
     5e4:	b0 91 93 02 	lds	r27, 0x0293	; 0x800293 <timeroverflow+0x3>
     5e8:	01 96       	adiw	r24, 0x01	; 1
     5ea:	a1 1d       	adc	r26, r1
     5ec:	b1 1d       	adc	r27, r1
     5ee:	80 93 90 02 	sts	0x0290, r24	; 0x800290 <timeroverflow>
     5f2:	90 93 91 02 	sts	0x0291, r25	; 0x800291 <timeroverflow+0x1>
     5f6:	a0 93 92 02 	sts	0x0292, r26	; 0x800292 <timeroverflow+0x2>
     5fa:	b0 93 93 02 	sts	0x0293, r27	; 0x800293 <timeroverflow+0x3>
	}
		
	// Disable interrupt and clear pending
	TIMSK4 = 0U;	
     5fe:	10 92 72 00 	sts	0x0072, r1	; 0x800072 <__TEXT_REGION_LENGTH__+0x700072>
	TIFR4 = ( 1 << ICF4 ) | ( 1 << TOV4 );		
     602:	81 e2       	ldi	r24, 0x21	; 33
     604:	89 bb       	out	0x19, r24	; 25
			
	// Calculate difference
	uint32_t diff = 0U;

	if ( readValue < oldValue )
     606:	80 91 94 02 	lds	r24, 0x0294	; 0x800294 <oldValue>
     60a:	90 91 95 02 	lds	r25, 0x0295	; 0x800295 <oldValue+0x1>
     60e:	68 17       	cp	r22, r24
     610:	79 07       	cpc	r23, r25
     612:	58 f5       	brcc	.+86     	; 0x66a <__vector_41+0xf6>
	{
		if ( timeroverflow != 0 )
     614:	80 91 90 02 	lds	r24, 0x0290	; 0x800290 <timeroverflow>
     618:	90 91 91 02 	lds	r25, 0x0291	; 0x800291 <timeroverflow+0x1>
     61c:	a0 91 92 02 	lds	r26, 0x0292	; 0x800292 <timeroverflow+0x2>
     620:	b0 91 93 02 	lds	r27, 0x0293	; 0x800293 <timeroverflow+0x3>
     624:	89 2b       	or	r24, r25
     626:	8a 2b       	or	r24, r26
     628:	8b 2b       	or	r24, r27
     62a:	99 f0       	breq	.+38     	; 0x652 <__vector_41+0xde>
		{
			timeroverflow--;
     62c:	80 91 90 02 	lds	r24, 0x0290	; 0x800290 <timeroverflow>
     630:	90 91 91 02 	lds	r25, 0x0291	; 0x800291 <timeroverflow+0x1>
     634:	a0 91 92 02 	lds	r26, 0x0292	; 0x800292 <timeroverflow+0x2>
     638:	b0 91 93 02 	lds	r27, 0x0293	; 0x800293 <timeroverflow+0x3>
     63c:	01 97       	sbiw	r24, 0x01	; 1
     63e:	a1 09       	sbc	r26, r1
     640:	b1 09       	sbc	r27, r1
     642:	80 93 90 02 	sts	0x0290, r24	; 0x800290 <timeroverflow>
     646:	90 93 91 02 	sts	0x0291, r25	; 0x800291 <timeroverflow+0x1>
     64a:	a0 93 92 02 	sts	0x0292, r26	; 0x800292 <timeroverflow+0x2>
     64e:	b0 93 93 02 	sts	0x0293, r27	; 0x800293 <timeroverflow+0x3>
		}
		diff = ( 0xFFFF - oldValue ) + readValue;
     652:	80 91 94 02 	lds	r24, 0x0294	; 0x800294 <oldValue>
     656:	90 91 95 02 	lds	r25, 0x0295	; 0x800295 <oldValue+0x1>
     65a:	68 1b       	sub	r22, r24
     65c:	79 0b       	sbc	r23, r25
     65e:	61 50       	subi	r22, 0x01	; 1
     660:	71 09       	sbc	r23, r1
     662:	cb 01       	movw	r24, r22
     664:	a0 e0       	ldi	r26, 0x00	; 0
     666:	b0 e0       	ldi	r27, 0x00	; 0
     668:	09 c0       	rjmp	.+18     	; 0x67c <__vector_41+0x108>
	}
	else
	{
		diff = readValue - oldValue;
     66a:	80 91 94 02 	lds	r24, 0x0294	; 0x800294 <oldValue>
     66e:	90 91 95 02 	lds	r25, 0x0295	; 0x800295 <oldValue+0x1>
     672:	68 1b       	sub	r22, r24
     674:	79 0b       	sbc	r23, r25
     676:	cb 01       	movw	r24, r22
     678:	a0 e0       	ldi	r26, 0x00	; 0
     67a:	b0 e0       	ldi	r27, 0x00	; 0
	}
	
	// Add timeroverflow to total diff
	diff += timeroverflow << 16U;
     67c:	40 91 90 02 	lds	r20, 0x0290	; 0x800290 <timeroverflow>
     680:	50 91 91 02 	lds	r21, 0x0291	; 0x800291 <timeroverflow+0x1>
     684:	60 91 92 02 	lds	r22, 0x0292	; 0x800292 <timeroverflow+0x2>
     688:	70 91 93 02 	lds	r23, 0x0293	; 0x800293 <timeroverflow+0x3>
     68c:	ba 01       	movw	r22, r20
     68e:	55 27       	eor	r21, r21
     690:	44 27       	eor	r20, r20
     692:	8a 01       	movw	r16, r20
     694:	9b 01       	movw	r18, r22
     696:	08 0f       	add	r16, r24
     698:	19 1f       	adc	r17, r25
     69a:	2a 1f       	adc	r18, r26
     69c:	3b 1f       	adc	r19, r27
     69e:	c9 01       	movw	r24, r18
     6a0:	b8 01       	movw	r22, r16
	
	// Calculate period
	period = diff * tick * 1000000;
     6a2:	c0 90 06 02 	lds	r12, 0x0206	; 0x800206 <tick>
     6a6:	d0 90 07 02 	lds	r13, 0x0207	; 0x800207 <tick+0x1>
     6aa:	e0 90 08 02 	lds	r14, 0x0208	; 0x800208 <tick+0x2>
     6ae:	f0 90 09 02 	lds	r15, 0x0209	; 0x800209 <tick+0x3>
     6b2:	0e 94 80 14 	call	0x2900	; 0x2900 <__floatunsisf>
     6b6:	a7 01       	movw	r20, r14
     6b8:	96 01       	movw	r18, r12
     6ba:	0e 94 36 15 	call	0x2a6c	; 0x2a6c <__mulsf3>
     6be:	20 e0       	ldi	r18, 0x00	; 0
     6c0:	34 e2       	ldi	r19, 0x24	; 36
     6c2:	44 e7       	ldi	r20, 0x74	; 116
     6c4:	59 e4       	ldi	r21, 0x49	; 73
     6c6:	0e 94 36 15 	call	0x2a6c	; 0x2a6c <__mulsf3>
     6ca:	0e 94 54 14 	call	0x28a8	; 0x28a8 <__fixunssfsi>
     6ce:	70 93 8f 02 	sts	0x028F, r23	; 0x80028f <__data_end+0x1>
     6d2:	60 93 8e 02 	sts	0x028E, r22	; 0x80028e <__data_end>
     6d6:	ff 91       	pop	r31
     6d8:	ef 91       	pop	r30
     6da:	bf 91       	pop	r27
     6dc:	af 91       	pop	r26
     6de:	9f 91       	pop	r25
     6e0:	8f 91       	pop	r24
     6e2:	7f 91       	pop	r23
     6e4:	6f 91       	pop	r22
     6e6:	5f 91       	pop	r21
     6e8:	4f 91       	pop	r20
     6ea:	3f 91       	pop	r19
     6ec:	2f 91       	pop	r18
     6ee:	1f 91       	pop	r17
     6f0:	0f 91       	pop	r16
     6f2:	ff 90       	pop	r15
     6f4:	ef 90       	pop	r14
     6f6:	df 90       	pop	r13
     6f8:	cf 90       	pop	r12
     6fa:	0f 90       	pop	r0
     6fc:	0b be       	out	0x3b, r0	; 59
     6fe:	0f 90       	pop	r0
     700:	0f be       	out	0x3f, r0	; 63
     702:	0f 90       	pop	r0
     704:	1f 90       	pop	r1
     706:	18 95       	reti

00000708 <_Z6KeypadPv>:
void * operator new(size_t size);
void operator delete(void * ptr);

int __cxa_guard_acquire(__guard *g) {return !*(char *)(g);};
void __cxa_guard_release (__guard *g) {*(char *)g = 1;};
void __cxa_guard_abort (__guard *) {};
     708:	ff cf       	rjmp	.-2      	; 0x708 <_Z6KeypadPv>

0000070a <_Z10DisplayArmPv>:
     70a:	87 e9       	ldi	r24, 0x97	; 151
     70c:	92 e0       	ldi	r25, 0x02	; 2
     70e:	0e 94 71 12 	call	0x24e2	; 0x24e2 <_ZN11Touchscreen11clearScreenEv>
     712:	87 e9       	ldi	r24, 0x97	; 151
     714:	92 e0       	ldi	r25, 0x02	; 2
     716:	0e 94 86 12 	call	0x250c	; 0x250c <_ZN11Touchscreen23presentButtonsOnDisplayEv>
     71a:	87 e9       	ldi	r24, 0x97	; 151
     71c:	92 e0       	ldi	r25, 0x02	; 2
     71e:	0e 94 e6 11 	call	0x23cc	; 0x23cc <_ZN11Touchscreen12checkButtonsEv>
     722:	81 30       	cpi	r24, 0x01	; 1
     724:	19 f0       	breq	.+6      	; 0x72c <_Z10DisplayArmPv+0x22>
     726:	82 30       	cpi	r24, 0x02	; 2
     728:	61 f0       	breq	.+24     	; 0x742 <_Z10DisplayArmPv+0x38>
     72a:	f3 cf       	rjmp	.-26     	; 0x712 <_Z10DisplayArmPv+0x8>
     72c:	60 91 96 02 	lds	r22, 0x0296	; 0x800296 <colorIndex>
     730:	8d ea       	ldi	r24, 0xAD	; 173
     732:	92 e0       	ldi	r25, 0x02	; 2
     734:	09 de       	rcall	.-1006   	; 0x348 <_ZN11ColorSensor17addCalibrateColorEh>
     736:	80 91 96 02 	lds	r24, 0x0296	; 0x800296 <colorIndex>
     73a:	8f 5f       	subi	r24, 0xFF	; 255
     73c:	80 93 96 02 	sts	0x0296, r24	; 0x800296 <colorIndex>
     740:	e8 cf       	rjmp	.-48     	; 0x712 <_Z10DisplayArmPv+0x8>
     742:	8d ea       	ldi	r24, 0xAD	; 173
     744:	92 e0       	ldi	r25, 0x02	; 2
     746:	69 dd       	rcall	.-1326   	; 0x21a <_ZN11ColorSensor8getColorEv>
     748:	68 2f       	mov	r22, r24
     74a:	88 e0       	ldi	r24, 0x08	; 8
     74c:	93 e0       	ldi	r25, 0x03	; 3
     74e:	f3 d1       	rcall	.+998    	; 0xb36 <_ZN8Robotarm8MoveItemEh>
     750:	e0 cf       	rjmp	.-64     	; 0x712 <_Z10DisplayArmPv+0x8>

00000752 <_Z41__static_initialization_and_destruction_0ii>:
     752:	0f 93       	push	r16
     754:	1f 93       	push	r17
     756:	cf 93       	push	r28
     758:	df 93       	push	r29
     75a:	ec 01       	movw	r28, r24
     75c:	8b 01       	movw	r16, r22
     75e:	01 97       	sbiw	r24, 0x01	; 1
     760:	71 f4       	brne	.+28     	; 0x77e <_Z41__static_initialization_and_destruction_0ii+0x2c>
     762:	6f 3f       	cpi	r22, 0xFF	; 255
     764:	7f 4f       	sbci	r23, 0xFF	; 255
     766:	59 f4       	brne	.+22     	; 0x77e <_Z41__static_initialization_and_destruction_0ii+0x2c>
     768:	88 e0       	ldi	r24, 0x08	; 8
     76a:	93 e0       	ldi	r25, 0x03	; 3
     76c:	5e d0       	rcall	.+188    	; 0x82a <_ZN8RobotarmC1Ev>
     76e:	62 e0       	ldi	r22, 0x02	; 2
     770:	8d ea       	ldi	r24, 0xAD	; 173
     772:	92 e0       	ldi	r25, 0x02	; 2
     774:	56 de       	rcall	.-852    	; 0x422 <_ZN11ColorSensorC1E16FrequencyScaling>
     776:	87 e9       	ldi	r24, 0x97	; 151
     778:	92 e0       	ldi	r25, 0x02	; 2
     77a:	0e 94 7e 11 	call	0x22fc	; 0x22fc <_ZN11TouchscreenC1Ev>
     77e:	cd 2b       	or	r28, r29
     780:	31 f4       	brne	.+12     	; 0x78e <_Z41__static_initialization_and_destruction_0ii+0x3c>
     782:	0f 3f       	cpi	r16, 0xFF	; 255
     784:	1f 4f       	sbci	r17, 0xFF	; 255
     786:	19 f4       	brne	.+6      	; 0x78e <_Z41__static_initialization_and_destruction_0ii+0x3c>
     788:	8d ea       	ldi	r24, 0xAD	; 173
     78a:	92 e0       	ldi	r25, 0x02	; 2
     78c:	03 dd       	rcall	.-1530   	; 0x194 <_ZN11ColorSensorD1Ev>
     78e:	df 91       	pop	r29
     790:	cf 91       	pop	r28
     792:	1f 91       	pop	r17
     794:	0f 91       	pop	r16
     796:	08 95       	ret

00000798 <__cxa_pure_virtual>:
     798:	ff cf       	rjmp	.-2      	; 0x798 <__cxa_pure_virtual>

0000079a <_Znwj>:

void * operator new(size_t size)
{
	return malloc(size);
     79a:	0c 94 b0 15 	jmp	0x2b60	; 0x2b60 <malloc>
}
     79e:	08 95       	ret

000007a0 <_ZdlPv>:

void operator delete(void * ptr)
{
	ptr != NULL ? free(ptr) : void(0);
     7a0:	00 97       	sbiw	r24, 0x00	; 0
     7a2:	11 f0       	breq	.+4      	; 0x7a8 <_ZdlPv+0x8>
     7a4:	0c 94 48 16 	jmp	0x2c90	; 0x2c90 <free>
     7a8:	08 95       	ret

000007aa <main>:
	}
}

int main(void)
{
	xTaskCreate(DisplayArm,  ( signed char * ) "Display + Arm Task", configMAIN_STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL);
     7aa:	a1 2c       	mov	r10, r1
     7ac:	b1 2c       	mov	r11, r1
     7ae:	c1 2c       	mov	r12, r1
     7b0:	d1 2c       	mov	r13, r1
     7b2:	e1 2c       	mov	r14, r1
     7b4:	f1 2c       	mov	r15, r1
     7b6:	00 e0       	ldi	r16, 0x00	; 0
     7b8:	20 e0       	ldi	r18, 0x00	; 0
     7ba:	30 e0       	ldi	r19, 0x00	; 0
     7bc:	48 ec       	ldi	r20, 0xC8	; 200
     7be:	50 e0       	ldi	r21, 0x00	; 0
     7c0:	6e e0       	ldi	r22, 0x0E	; 14
     7c2:	72 e0       	ldi	r23, 0x02	; 2
     7c4:	85 e8       	ldi	r24, 0x85	; 133
     7c6:	93 e0       	ldi	r25, 0x03	; 3
     7c8:	0e 94 1a 0e 	call	0x1c34	; 0x1c34 <xTaskGenericCreate>
	xTaskCreate(Keypad,  ( signed char * ) "Keypad Task", configMAIN_STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL);
     7cc:	20 e0       	ldi	r18, 0x00	; 0
     7ce:	30 e0       	ldi	r19, 0x00	; 0
     7d0:	48 ec       	ldi	r20, 0xC8	; 200
     7d2:	50 e0       	ldi	r21, 0x00	; 0
     7d4:	61 e2       	ldi	r22, 0x21	; 33
     7d6:	72 e0       	ldi	r23, 0x02	; 2
     7d8:	84 e8       	ldi	r24, 0x84	; 132
     7da:	93 e0       	ldi	r25, 0x03	; 3
     7dc:	0e 94 1a 0e 	call	0x1c34	; 0x1c34 <xTaskGenericCreate>
	vTaskStartScheduler();
     7e0:	0e 94 d2 0e 	call	0x1da4	; 0x1da4 <vTaskStartScheduler>
     7e4:	ff cf       	rjmp	.-2      	; 0x7e4 <main+0x3a>

000007e6 <_GLOBAL__sub_I___cxa_pure_virtual>:

	while (1)
	{
	}
}
     7e6:	6f ef       	ldi	r22, 0xFF	; 255
     7e8:	7f ef       	ldi	r23, 0xFF	; 255
     7ea:	81 e0       	ldi	r24, 0x01	; 1
     7ec:	90 e0       	ldi	r25, 0x00	; 0
     7ee:	b1 cf       	rjmp	.-158    	; 0x752 <_Z41__static_initialization_and_destruction_0ii>
     7f0:	08 95       	ret

000007f2 <_GLOBAL__sub_D___cxa_pure_virtual>:
     7f2:	6f ef       	ldi	r22, 0xFF	; 255
     7f4:	7f ef       	ldi	r23, 0xFF	; 255
     7f6:	80 e0       	ldi	r24, 0x00	; 0
     7f8:	90 e0       	ldi	r25, 0x00	; 0
     7fa:	ab cf       	rjmp	.-170    	; 0x752 <_Z41__static_initialization_and_destruction_0ii>
     7fc:	08 95       	ret

000007fe <_ZN8Robotarm14startMotorImplEPv>:
	motors_[3]->SetDegrees(90);
	vTaskDelay( 250 / portTICK_RATE_MS );
}

void Robotarm::startMotorImpl( void *_this )
{
     7fe:	8c 01       	movw	r16, r24
void Robotarm::MotorSpeedController()
{
	while(1)
	{
		/* Move all motors one step. */
		for ( uint8_t i = 0U; i < 6U; i++ )
     800:	c0 e0       	ldi	r28, 0x00	; 0
     802:	c6 30       	cpi	r28, 0x06	; 6
     804:	e8 f7       	brcc	.-6      	; 0x800 <_ZN8Robotarm14startMotorImplEPv+0x2>
		{
			motors_[i]->TurnMotor();
     806:	ec 2f       	mov	r30, r28
     808:	f0 e0       	ldi	r31, 0x00	; 0
     80a:	31 96       	adiw	r30, 0x01	; 1
     80c:	ee 0f       	add	r30, r30
     80e:	ff 1f       	adc	r31, r31
     810:	e0 0f       	add	r30, r16
     812:	f1 1f       	adc	r31, r17
     814:	80 81       	ld	r24, Z
     816:	91 81       	ldd	r25, Z+1	; 0x01
     818:	dc 01       	movw	r26, r24
     81a:	ed 91       	ld	r30, X+
     81c:	fc 91       	ld	r31, X
     81e:	04 80       	ldd	r0, Z+4	; 0x04
     820:	f5 81       	ldd	r31, Z+5	; 0x05
     822:	e0 2d       	mov	r30, r0
     824:	19 95       	eicall
void Robotarm::MotorSpeedController()
{
	while(1)
	{
		/* Move all motors one step. */
		for ( uint8_t i = 0U; i < 6U; i++ )
     826:	cf 5f       	subi	r28, 0xFF	; 255
     828:	ec cf       	rjmp	.-40     	; 0x802 <_ZN8Robotarm14startMotorImplEPv+0x4>

0000082a <_ZN8RobotarmC1Ev>:
/* RTOS include */
#include "FreeRTOS.h"
#include "task.h"
#include "portmacro.h"

Robotarm::Robotarm() : tmr1_(), tmr3_()
     82a:	af 92       	push	r10
     82c:	bf 92       	push	r11
     82e:	cf 92       	push	r12
     830:	df 92       	push	r13
     832:	ef 92       	push	r14
     834:	ff 92       	push	r15
     836:	0f 93       	push	r16
     838:	1f 93       	push	r17
     83a:	cf 93       	push	r28
     83c:	df 93       	push	r29
     83e:	ec 01       	movw	r28, r24
     840:	d5 d5       	rcall	.+2986   	; 0x13ec <_ZN6Timer1C1Ev>
     842:	8e 01       	movw	r16, r28
     844:	0f 5f       	subi	r16, 0xFF	; 255
     846:	1f 4f       	sbci	r17, 0xFF	; 255
     848:	c8 01       	movw	r24, r16
     84a:	75 d6       	rcall	.+3306   	; 0x1536 <_ZN6Timer5C1Ev>
{
	/* Create all motor objects */
	motors_[0] = new M1( &tmr1_ );
     84c:	89 e1       	ldi	r24, 0x19	; 25
     84e:	90 e0       	ldi	r25, 0x00	; 0
     850:	a4 df       	rcall	.-184    	; 0x79a <_Znwj>
     852:	7c 01       	movw	r14, r24
     854:	be 01       	movw	r22, r28
     856:	66 d2       	rcall	.+1228   	; 0xd24 <_ZN2M1C1EP6Timer1>
     858:	fb 82       	std	Y+3, r15	; 0x03
     85a:	ea 82       	std	Y+2, r14	; 0x02
	motors_[1] = new M2( &tmr1_ );
     85c:	89 e1       	ldi	r24, 0x19	; 25
     85e:	90 e0       	ldi	r25, 0x00	; 0
     860:	9c df       	rcall	.-200    	; 0x79a <_Znwj>
     862:	7c 01       	movw	r14, r24
     864:	be 01       	movw	r22, r28
     866:	04 d3       	rcall	.+1544   	; 0xe70 <_ZN2M2C1EP6Timer1>
     868:	fd 82       	std	Y+5, r15	; 0x05
     86a:	ec 82       	std	Y+4, r14	; 0x04
	motors_[2] = new M3( &tmr1_ );
     86c:	89 e1       	ldi	r24, 0x19	; 25
     86e:	90 e0       	ldi	r25, 0x00	; 0
     870:	94 df       	rcall	.-216    	; 0x79a <_Znwj>
     872:	7c 01       	movw	r14, r24
     874:	be 01       	movw	r22, r28
     876:	a2 d3       	rcall	.+1860   	; 0xfbc <_ZN2M3C1EP6Timer1>
     878:	ff 82       	std	Y+7, r15	; 0x07
     87a:	ee 82       	std	Y+6, r14	; 0x06
	motors_[3] = new M4( &tmr3_ );
     87c:	89 e1       	ldi	r24, 0x19	; 25
     87e:	90 e0       	ldi	r25, 0x00	; 0
     880:	8c df       	rcall	.-232    	; 0x79a <_Znwj>
     882:	7c 01       	movw	r14, r24
     884:	b8 01       	movw	r22, r16
     886:	3e d4       	rcall	.+2172   	; 0x1104 <_ZN2M4C1EP6Timer5>
     888:	f9 86       	std	Y+9, r15	; 0x09
     88a:	e8 86       	std	Y+8, r14	; 0x08
	motors_[4] = new M5( &tmr3_ );
     88c:	89 e1       	ldi	r24, 0x19	; 25
     88e:	90 e0       	ldi	r25, 0x00	; 0
     890:	84 df       	rcall	.-248    	; 0x79a <_Znwj>
     892:	7c 01       	movw	r14, r24
     894:	b8 01       	movw	r22, r16
     896:	da d4       	rcall	.+2484   	; 0x124c <_ZN2M5C1EP6Timer5>
     898:	fb 86       	std	Y+11, r15	; 0x0b
     89a:	ea 86       	std	Y+10, r14	; 0x0a
	motors_[5] = new M6( &tmr3_ );
     89c:	89 e1       	ldi	r24, 0x19	; 25
     89e:	90 e0       	ldi	r25, 0x00	; 0
     8a0:	7c df       	rcall	.-264    	; 0x79a <_Znwj>
     8a2:	7c 01       	movw	r14, r24
     8a4:	b8 01       	movw	r22, r16
     8a6:	72 d5       	rcall	.+2788   	; 0x138c <_ZN2M6C1EP6Timer5>
     8a8:	fd 86       	std	Y+13, r15	; 0x0d
     8aa:	ec 86       	std	Y+12, r14	; 0x0c
     8ac:	a1 2c       	mov	r10, r1
     8ae:	b1 2c       	mov	r11, r1
	
	/* Create task to control motors */
	xTaskCreate(this->startMotorImpl,  ( signed char * ) "Motors", configMAIN_STACK_SIZE, this, tskIDLE_PRIORITY, NULL);
     8b0:	c1 2c       	mov	r12, r1
     8b2:	d1 2c       	mov	r13, r1
     8b4:	e1 2c       	mov	r14, r1
     8b6:	f1 2c       	mov	r15, r1
     8b8:	00 e0       	ldi	r16, 0x00	; 0
     8ba:	9e 01       	movw	r18, r28
     8bc:	48 ec       	ldi	r20, 0xC8	; 200
     8be:	50 e0       	ldi	r21, 0x00	; 0
     8c0:	6d e2       	ldi	r22, 0x2D	; 45
     8c2:	72 e0       	ldi	r23, 0x02	; 2
     8c4:	8f ef       	ldi	r24, 0xFF	; 255
     8c6:	93 e0       	ldi	r25, 0x03	; 3
     8c8:	0e 94 1a 0e 	call	0x1c34	; 0x1c34 <xTaskGenericCreate>
     8cc:	df 91       	pop	r29
     8ce:	cf 91       	pop	r28
}
     8d0:	1f 91       	pop	r17
     8d2:	0f 91       	pop	r16
     8d4:	ff 90       	pop	r15
     8d6:	ef 90       	pop	r14
     8d8:	df 90       	pop	r13
     8da:	cf 90       	pop	r12
     8dc:	bf 90       	pop	r11
     8de:	af 90       	pop	r10
     8e0:	08 95       	ret

000008e2 <_ZN8Robotarm9grabBlockEv>:
     8e2:	cf 93       	push	r28
     8e4:	df 93       	push	r29
		break;
	}
}

void Robotarm::grabBlock()
{
     8e6:	ec 01       	movw	r28, r24
	motors_[3]->SetDegrees(40);
     8e8:	88 85       	ldd	r24, Y+8	; 0x08
     8ea:	99 85       	ldd	r25, Y+9	; 0x09
     8ec:	dc 01       	movw	r26, r24
     8ee:	ed 91       	ld	r30, X+
     8f0:	fc 91       	ld	r31, X
     8f2:	06 80       	ldd	r0, Z+6	; 0x06
     8f4:	f7 81       	ldd	r31, Z+7	; 0x07
     8f6:	e0 2d       	mov	r30, r0
     8f8:	68 e2       	ldi	r22, 0x28	; 40
     8fa:	19 95       	eicall
	motors_[4]->SetDegrees(90);
     8fc:	8a 85       	ldd	r24, Y+10	; 0x0a
     8fe:	9b 85       	ldd	r25, Y+11	; 0x0b
     900:	dc 01       	movw	r26, r24
     902:	ed 91       	ld	r30, X+
     904:	fc 91       	ld	r31, X
     906:	06 80       	ldd	r0, Z+6	; 0x06
     908:	f7 81       	ldd	r31, Z+7	; 0x07
     90a:	e0 2d       	mov	r30, r0
     90c:	6a e5       	ldi	r22, 0x5A	; 90
     90e:	19 95       	eicall
	motors_[0]->SetDegrees(0);
     910:	8a 81       	ldd	r24, Y+2	; 0x02
     912:	9b 81       	ldd	r25, Y+3	; 0x03
     914:	dc 01       	movw	r26, r24
     916:	ed 91       	ld	r30, X+
     918:	fc 91       	ld	r31, X
     91a:	06 80       	ldd	r0, Z+6	; 0x06
     91c:	f7 81       	ldd	r31, Z+7	; 0x07
     91e:	e0 2d       	mov	r30, r0
     920:	60 e0       	ldi	r22, 0x00	; 0
     922:	19 95       	eicall
	vTaskDelay( 1500 / portTICK_RATE_MS );
     924:	8c ed       	ldi	r24, 0xDC	; 220
     926:	95 e0       	ldi	r25, 0x05	; 5
     928:	0e 94 19 10 	call	0x2032	; 0x2032 <vTaskDelay>
	motors_[1]->SetDegrees(35);
     92c:	8c 81       	ldd	r24, Y+4	; 0x04
     92e:	9d 81       	ldd	r25, Y+5	; 0x05
     930:	dc 01       	movw	r26, r24
     932:	ed 91       	ld	r30, X+
     934:	fc 91       	ld	r31, X
     936:	06 80       	ldd	r0, Z+6	; 0x06
     938:	f7 81       	ldd	r31, Z+7	; 0x07
     93a:	e0 2d       	mov	r30, r0
     93c:	63 e2       	ldi	r22, 0x23	; 35
     93e:	19 95       	eicall
	motors_[2]->SetDegrees(63);
     940:	8e 81       	ldd	r24, Y+6	; 0x06
     942:	9f 81       	ldd	r25, Y+7	; 0x07
     944:	dc 01       	movw	r26, r24
     946:	ed 91       	ld	r30, X+
     948:	fc 91       	ld	r31, X
     94a:	06 80       	ldd	r0, Z+6	; 0x06
     94c:	f7 81       	ldd	r31, Z+7	; 0x07
     94e:	e0 2d       	mov	r30, r0
     950:	6f e3       	ldi	r22, 0x3F	; 63
     952:	19 95       	eicall
	vTaskDelay( 1500 / portTICK_RATE_MS );
     954:	8c ed       	ldi	r24, 0xDC	; 220
     956:	95 e0       	ldi	r25, 0x05	; 5
     958:	0e 94 19 10 	call	0x2032	; 0x2032 <vTaskDelay>
	motors_[5]->SetDegrees(63);
     95c:	8c 85       	ldd	r24, Y+12	; 0x0c
     95e:	9d 85       	ldd	r25, Y+13	; 0x0d
     960:	dc 01       	movw	r26, r24
     962:	ed 91       	ld	r30, X+
     964:	fc 91       	ld	r31, X
     966:	06 80       	ldd	r0, Z+6	; 0x06
     968:	f7 81       	ldd	r31, Z+7	; 0x07
     96a:	e0 2d       	mov	r30, r0
     96c:	6f e3       	ldi	r22, 0x3F	; 63
     96e:	19 95       	eicall
	vTaskDelay( 250 / portTICK_RATE_MS );
     970:	8a ef       	ldi	r24, 0xFA	; 250
     972:	90 e0       	ldi	r25, 0x00	; 0
     974:	0e 94 19 10 	call	0x2032	; 0x2032 <vTaskDelay>
	motors_[1]->SetDegrees(70);
     978:	8c 81       	ldd	r24, Y+4	; 0x04
     97a:	9d 81       	ldd	r25, Y+5	; 0x05
     97c:	dc 01       	movw	r26, r24
     97e:	ed 91       	ld	r30, X+
     980:	fc 91       	ld	r31, X
     982:	06 80       	ldd	r0, Z+6	; 0x06
     984:	f7 81       	ldd	r31, Z+7	; 0x07
     986:	e0 2d       	mov	r30, r0
     988:	66 e4       	ldi	r22, 0x46	; 70
     98a:	19 95       	eicall
	motors_[2]->SetDegrees(70);
     98c:	8e 81       	ldd	r24, Y+6	; 0x06
     98e:	9f 81       	ldd	r25, Y+7	; 0x07
     990:	dc 01       	movw	r26, r24
     992:	ed 91       	ld	r30, X+
     994:	fc 91       	ld	r31, X
     996:	06 80       	ldd	r0, Z+6	; 0x06
     998:	f7 81       	ldd	r31, Z+7	; 0x07
     99a:	e0 2d       	mov	r30, r0
     99c:	66 e4       	ldi	r22, 0x46	; 70
     99e:	19 95       	eicall
	motors_[3]->SetDegrees(70);
     9a0:	88 85       	ldd	r24, Y+8	; 0x08
     9a2:	99 85       	ldd	r25, Y+9	; 0x09
     9a4:	dc 01       	movw	r26, r24
     9a6:	ed 91       	ld	r30, X+
     9a8:	fc 91       	ld	r31, X
     9aa:	06 80       	ldd	r0, Z+6	; 0x06
     9ac:	f7 81       	ldd	r31, Z+7	; 0x07
     9ae:	e0 2d       	mov	r30, r0
     9b0:	66 e4       	ldi	r22, 0x46	; 70
     9b2:	19 95       	eicall
}
     9b4:	df 91       	pop	r29
     9b6:	cf 91       	pop	r28
     9b8:	08 95       	ret

000009ba <_ZN8Robotarm18ArmDownReleaseItemEv>:
	motors_[0]->SetDegrees(180);
	ArmDownReleaseItem();
}

void Robotarm::ArmDownReleaseItem()
{
     9ba:	cf 93       	push	r28
     9bc:	df 93       	push	r29
     9be:	ec 01       	movw	r28, r24
	vTaskDelay( 1500 / portTICK_RATE_MS );
     9c0:	8c ed       	ldi	r24, 0xDC	; 220
     9c2:	95 e0       	ldi	r25, 0x05	; 5
     9c4:	0e 94 19 10 	call	0x2032	; 0x2032 <vTaskDelay>
	motors_[1]->SetDegrees(35);
     9c8:	8c 81       	ldd	r24, Y+4	; 0x04
     9ca:	9d 81       	ldd	r25, Y+5	; 0x05
     9cc:	dc 01       	movw	r26, r24
     9ce:	ed 91       	ld	r30, X+
     9d0:	fc 91       	ld	r31, X
     9d2:	06 80       	ldd	r0, Z+6	; 0x06
     9d4:	f7 81       	ldd	r31, Z+7	; 0x07
     9d6:	e0 2d       	mov	r30, r0
     9d8:	63 e2       	ldi	r22, 0x23	; 35
     9da:	19 95       	eicall
	motors_[2]->SetDegrees(40);
     9dc:	8e 81       	ldd	r24, Y+6	; 0x06
     9de:	9f 81       	ldd	r25, Y+7	; 0x07
     9e0:	dc 01       	movw	r26, r24
     9e2:	ed 91       	ld	r30, X+
     9e4:	fc 91       	ld	r31, X
     9e6:	06 80       	ldd	r0, Z+6	; 0x06
     9e8:	f7 81       	ldd	r31, Z+7	; 0x07
     9ea:	e0 2d       	mov	r30, r0
     9ec:	68 e2       	ldi	r22, 0x28	; 40
     9ee:	19 95       	eicall
	vTaskDelay( 1500 / portTICK_RATE_MS );
     9f0:	8c ed       	ldi	r24, 0xDC	; 220
     9f2:	95 e0       	ldi	r25, 0x05	; 5
     9f4:	0e 94 19 10 	call	0x2032	; 0x2032 <vTaskDelay>
	motors_[5]->SetDegrees(0);
     9f8:	8c 85       	ldd	r24, Y+12	; 0x0c
     9fa:	9d 85       	ldd	r25, Y+13	; 0x0d
     9fc:	dc 01       	movw	r26, r24
     9fe:	ed 91       	ld	r30, X+
     a00:	fc 91       	ld	r31, X
     a02:	06 80       	ldd	r0, Z+6	; 0x06
     a04:	f7 81       	ldd	r31, Z+7	; 0x07
     a06:	e0 2d       	mov	r30, r0
     a08:	60 e0       	ldi	r22, 0x00	; 0
     a0a:	19 95       	eicall
	vTaskDelay( 250 / portTICK_RATE_MS );
     a0c:	8a ef       	ldi	r24, 0xFA	; 250
     a0e:	90 e0       	ldi	r25, 0x00	; 0
     a10:	0e 94 19 10 	call	0x2032	; 0x2032 <vTaskDelay>
	motors_[1]->SetDegrees(90);
     a14:	8c 81       	ldd	r24, Y+4	; 0x04
     a16:	9d 81       	ldd	r25, Y+5	; 0x05
     a18:	dc 01       	movw	r26, r24
     a1a:	ed 91       	ld	r30, X+
     a1c:	fc 91       	ld	r31, X
     a1e:	06 80       	ldd	r0, Z+6	; 0x06
     a20:	f7 81       	ldd	r31, Z+7	; 0x07
     a22:	e0 2d       	mov	r30, r0
     a24:	6a e5       	ldi	r22, 0x5A	; 90
     a26:	19 95       	eicall
	motors_[2]->SetDegrees(90);
     a28:	8e 81       	ldd	r24, Y+6	; 0x06
     a2a:	9f 81       	ldd	r25, Y+7	; 0x07
     a2c:	dc 01       	movw	r26, r24
     a2e:	ed 91       	ld	r30, X+
     a30:	fc 91       	ld	r31, X
     a32:	06 80       	ldd	r0, Z+6	; 0x06
     a34:	f7 81       	ldd	r31, Z+7	; 0x07
     a36:	e0 2d       	mov	r30, r0
     a38:	6a e5       	ldi	r22, 0x5A	; 90
     a3a:	19 95       	eicall
	motors_[3]->SetDegrees(90);
     a3c:	88 85       	ldd	r24, Y+8	; 0x08
     a3e:	99 85       	ldd	r25, Y+9	; 0x09
     a40:	dc 01       	movw	r26, r24
     a42:	ed 91       	ld	r30, X+
     a44:	fc 91       	ld	r31, X
     a46:	06 80       	ldd	r0, Z+6	; 0x06
     a48:	f7 81       	ldd	r31, Z+7	; 0x07
     a4a:	e0 2d       	mov	r30, r0
     a4c:	6a e5       	ldi	r22, 0x5A	; 90
     a4e:	19 95       	eicall
	vTaskDelay( 250 / portTICK_RATE_MS );
     a50:	8a ef       	ldi	r24, 0xFA	; 250
     a52:	90 e0       	ldi	r25, 0x00	; 0
     a54:	0e 94 19 10 	call	0x2032	; 0x2032 <vTaskDelay>
}
     a58:	df 91       	pop	r29
     a5a:	cf 91       	pop	r28
     a5c:	08 95       	ret

00000a5e <_ZN8Robotarm18moveBlockToZoneOneEv>:
	motors_[2]->SetDegrees(70);
	motors_[3]->SetDegrees(70);
}

void Robotarm::moveBlockToZoneOne()
{
     a5e:	cf 93       	push	r28
     a60:	df 93       	push	r29
     a62:	ec 01       	movw	r28, r24
	motors_[0]->SetDegrees(40);
     a64:	8a 81       	ldd	r24, Y+2	; 0x02
     a66:	9b 81       	ldd	r25, Y+3	; 0x03
     a68:	dc 01       	movw	r26, r24
     a6a:	ed 91       	ld	r30, X+
     a6c:	fc 91       	ld	r31, X
     a6e:	06 80       	ldd	r0, Z+6	; 0x06
     a70:	f7 81       	ldd	r31, Z+7	; 0x07
     a72:	e0 2d       	mov	r30, r0
     a74:	68 e2       	ldi	r22, 0x28	; 40
     a76:	19 95       	eicall
	ArmDownReleaseItem();
     a78:	ce 01       	movw	r24, r28
     a7a:	9f df       	rcall	.-194    	; 0x9ba <_ZN8Robotarm18ArmDownReleaseItemEv>
}
     a7c:	df 91       	pop	r29
     a7e:	cf 91       	pop	r28
     a80:	08 95       	ret

00000a82 <_ZN8Robotarm18moveBlockToZoneTwoEv>:

void Robotarm::moveBlockToZoneTwo()
{
     a82:	cf 93       	push	r28
     a84:	df 93       	push	r29
     a86:	ec 01       	movw	r28, r24
	motors_[0]->SetDegrees(68);
     a88:	8a 81       	ldd	r24, Y+2	; 0x02
     a8a:	9b 81       	ldd	r25, Y+3	; 0x03
     a8c:	dc 01       	movw	r26, r24
     a8e:	ed 91       	ld	r30, X+
     a90:	fc 91       	ld	r31, X
     a92:	06 80       	ldd	r0, Z+6	; 0x06
     a94:	f7 81       	ldd	r31, Z+7	; 0x07
     a96:	e0 2d       	mov	r30, r0
     a98:	64 e4       	ldi	r22, 0x44	; 68
     a9a:	19 95       	eicall
	ArmDownReleaseItem();
     a9c:	ce 01       	movw	r24, r28
     a9e:	8d df       	rcall	.-230    	; 0x9ba <_ZN8Robotarm18ArmDownReleaseItemEv>
}
     aa0:	df 91       	pop	r29
     aa2:	cf 91       	pop	r28
     aa4:	08 95       	ret

00000aa6 <_ZN8Robotarm20moveBlockToZoneThreeEv>:

void Robotarm::moveBlockToZoneThree()
{
     aa6:	cf 93       	push	r28
     aa8:	df 93       	push	r29
     aaa:	ec 01       	movw	r28, r24
	motors_[0]->SetDegrees(96);
     aac:	8a 81       	ldd	r24, Y+2	; 0x02
     aae:	9b 81       	ldd	r25, Y+3	; 0x03
     ab0:	dc 01       	movw	r26, r24
     ab2:	ed 91       	ld	r30, X+
     ab4:	fc 91       	ld	r31, X
     ab6:	06 80       	ldd	r0, Z+6	; 0x06
     ab8:	f7 81       	ldd	r31, Z+7	; 0x07
     aba:	e0 2d       	mov	r30, r0
     abc:	60 e6       	ldi	r22, 0x60	; 96
     abe:	19 95       	eicall
	ArmDownReleaseItem();
     ac0:	ce 01       	movw	r24, r28
     ac2:	7b df       	rcall	.-266    	; 0x9ba <_ZN8Robotarm18ArmDownReleaseItemEv>
}
     ac4:	df 91       	pop	r29
     ac6:	cf 91       	pop	r28
     ac8:	08 95       	ret

00000aca <_ZN8Robotarm19moveBlockToZoneFourEv>:

void Robotarm::moveBlockToZoneFour()
{
     aca:	cf 93       	push	r28
     acc:	df 93       	push	r29
     ace:	ec 01       	movw	r28, r24
	motors_[0]->SetDegrees(124);
     ad0:	8a 81       	ldd	r24, Y+2	; 0x02
     ad2:	9b 81       	ldd	r25, Y+3	; 0x03
     ad4:	dc 01       	movw	r26, r24
     ad6:	ed 91       	ld	r30, X+
     ad8:	fc 91       	ld	r31, X
     ada:	06 80       	ldd	r0, Z+6	; 0x06
     adc:	f7 81       	ldd	r31, Z+7	; 0x07
     ade:	e0 2d       	mov	r30, r0
     ae0:	6c e7       	ldi	r22, 0x7C	; 124
     ae2:	19 95       	eicall
	ArmDownReleaseItem();
     ae4:	ce 01       	movw	r24, r28
     ae6:	69 df       	rcall	.-302    	; 0x9ba <_ZN8Robotarm18ArmDownReleaseItemEv>
}
     ae8:	df 91       	pop	r29
     aea:	cf 91       	pop	r28
     aec:	08 95       	ret

00000aee <_ZN8Robotarm19moveBlockToZoneFiveEv>:

void Robotarm::moveBlockToZoneFive()
{
     aee:	cf 93       	push	r28
     af0:	df 93       	push	r29
     af2:	ec 01       	movw	r28, r24
	motors_[0]->SetDegrees(152);
     af4:	8a 81       	ldd	r24, Y+2	; 0x02
     af6:	9b 81       	ldd	r25, Y+3	; 0x03
     af8:	dc 01       	movw	r26, r24
     afa:	ed 91       	ld	r30, X+
     afc:	fc 91       	ld	r31, X
     afe:	06 80       	ldd	r0, Z+6	; 0x06
     b00:	f7 81       	ldd	r31, Z+7	; 0x07
     b02:	e0 2d       	mov	r30, r0
     b04:	68 e9       	ldi	r22, 0x98	; 152
     b06:	19 95       	eicall
	ArmDownReleaseItem();
     b08:	ce 01       	movw	r24, r28
     b0a:	57 df       	rcall	.-338    	; 0x9ba <_ZN8Robotarm18ArmDownReleaseItemEv>
}
     b0c:	df 91       	pop	r29
     b0e:	cf 91       	pop	r28
     b10:	08 95       	ret

00000b12 <_ZN8Robotarm18moveBlockToZoneSixEv>:

void Robotarm::moveBlockToZoneSix()
{
     b12:	cf 93       	push	r28
     b14:	df 93       	push	r29
     b16:	ec 01       	movw	r28, r24
	motors_[0]->SetDegrees(180);
     b18:	8a 81       	ldd	r24, Y+2	; 0x02
     b1a:	9b 81       	ldd	r25, Y+3	; 0x03
     b1c:	dc 01       	movw	r26, r24
     b1e:	ed 91       	ld	r30, X+
     b20:	fc 91       	ld	r31, X
     b22:	06 80       	ldd	r0, Z+6	; 0x06
     b24:	f7 81       	ldd	r31, Z+7	; 0x07
     b26:	e0 2d       	mov	r30, r0
     b28:	64 eb       	ldi	r22, 0xB4	; 180
     b2a:	19 95       	eicall
	ArmDownReleaseItem();
     b2c:	ce 01       	movw	r24, r28
     b2e:	45 df       	rcall	.-374    	; 0x9ba <_ZN8Robotarm18ArmDownReleaseItemEv>
}
     b30:	df 91       	pop	r29
     b32:	cf 91       	pop	r28
     b34:	08 95       	ret

00000b36 <_ZN8Robotarm8MoveItemEh>:
	/* Create task to control motors */
	xTaskCreate(this->startMotorImpl,  ( signed char * ) "Motors", configMAIN_STACK_SIZE, this, tskIDLE_PRIORITY, NULL);
}

void Robotarm::MoveItem( uint8_t color )
{
     b36:	cf 93       	push	r28
     b38:	df 93       	push	r29
     b3a:	ec 01       	movw	r28, r24
	switch ( color )
     b3c:	62 30       	cpi	r22, 0x02	; 2
     b3e:	29 f1       	breq	.+74     	; 0xb8a <_ZN8Robotarm8MoveItemEh+0x54>
     b40:	28 f4       	brcc	.+10     	; 0xb4c <_ZN8Robotarm8MoveItemEh+0x16>
     b42:	66 23       	and	r22, r22
     b44:	51 f0       	breq	.+20     	; 0xb5a <_ZN8Robotarm8MoveItemEh+0x24>
     b46:	61 30       	cpi	r22, 0x01	; 1
     b48:	a1 f0       	breq	.+40     	; 0xb72 <_ZN8Robotarm8MoveItemEh+0x3c>
     b4a:	4e c0       	rjmp	.+156    	; 0xbe8 <_ZN8Robotarm8MoveItemEh+0xb2>
     b4c:	64 30       	cpi	r22, 0x04	; 4
     b4e:	a9 f1       	breq	.+106    	; 0xbba <_ZN8Robotarm8MoveItemEh+0x84>
     b50:	40 f1       	brcs	.+80     	; 0xba2 <_ZN8Robotarm8MoveItemEh+0x6c>
     b52:	65 30       	cpi	r22, 0x05	; 5
     b54:	09 f4       	brne	.+2      	; 0xb58 <_ZN8Robotarm8MoveItemEh+0x22>
     b56:	3d c0       	rjmp	.+122    	; 0xbd2 <_ZN8Robotarm8MoveItemEh+0x9c>
     b58:	47 c0       	rjmp	.+142    	; 0xbe8 <_ZN8Robotarm8MoveItemEh+0xb2>
	{
		case 0U:
		grabBlock();
     b5a:	c3 de       	rcall	.-634    	; 0x8e2 <_ZN8Robotarm9grabBlockEv>
		vTaskDelay( 500 / portTICK_RATE_MS ); // This might not be needed!!! it can be added in Robotarm!!!! we will seeee later
     b5c:	84 ef       	ldi	r24, 0xF4	; 244
     b5e:	91 e0       	ldi	r25, 0x01	; 1
     b60:	0e 94 19 10 	call	0x2032	; 0x2032 <vTaskDelay>
		moveBlockToZoneOne();
     b64:	ce 01       	movw	r24, r28
     b66:	7b df       	rcall	.-266    	; 0xa5e <_ZN8Robotarm18moveBlockToZoneOneEv>
		vTaskDelay( 500 / portTICK_RATE_MS );
     b68:	84 ef       	ldi	r24, 0xF4	; 244
     b6a:	91 e0       	ldi	r25, 0x01	; 1
     b6c:	0e 94 19 10 	call	0x2032	; 0x2032 <vTaskDelay>
		break;
		
		case 1U:
		grabBlock();
     b70:	3b c0       	rjmp	.+118    	; 0xbe8 <_ZN8Robotarm8MoveItemEh+0xb2>
     b72:	b7 de       	rcall	.-658    	; 0x8e2 <_ZN8Robotarm9grabBlockEv>
		vTaskDelay( 500 / portTICK_RATE_MS );
     b74:	84 ef       	ldi	r24, 0xF4	; 244
     b76:	91 e0       	ldi	r25, 0x01	; 1
     b78:	0e 94 19 10 	call	0x2032	; 0x2032 <vTaskDelay>
		moveBlockToZoneTwo();
     b7c:	ce 01       	movw	r24, r28
     b7e:	81 df       	rcall	.-254    	; 0xa82 <_ZN8Robotarm18moveBlockToZoneTwoEv>
		vTaskDelay( 500 / portTICK_RATE_MS );
     b80:	84 ef       	ldi	r24, 0xF4	; 244
     b82:	91 e0       	ldi	r25, 0x01	; 1
     b84:	0e 94 19 10 	call	0x2032	; 0x2032 <vTaskDelay>
		break;
		
		case 2U:
		grabBlock();
     b88:	2f c0       	rjmp	.+94     	; 0xbe8 <_ZN8Robotarm8MoveItemEh+0xb2>
     b8a:	ab de       	rcall	.-682    	; 0x8e2 <_ZN8Robotarm9grabBlockEv>
		vTaskDelay( 500 / portTICK_RATE_MS );
     b8c:	84 ef       	ldi	r24, 0xF4	; 244
     b8e:	91 e0       	ldi	r25, 0x01	; 1
     b90:	0e 94 19 10 	call	0x2032	; 0x2032 <vTaskDelay>
		moveBlockToZoneThree();
     b94:	ce 01       	movw	r24, r28
		vTaskDelay( 500 / portTICK_RATE_MS );
     b96:	87 df       	rcall	.-242    	; 0xaa6 <_ZN8Robotarm20moveBlockToZoneThreeEv>
     b98:	84 ef       	ldi	r24, 0xF4	; 244
     b9a:	91 e0       	ldi	r25, 0x01	; 1
     b9c:	0e 94 19 10 	call	0x2032	; 0x2032 <vTaskDelay>
		break;
		
		case 3U:
		grabBlock();
     ba0:	23 c0       	rjmp	.+70     	; 0xbe8 <_ZN8Robotarm8MoveItemEh+0xb2>
		vTaskDelay( 500 / portTICK_RATE_MS );
     ba2:	9f de       	rcall	.-706    	; 0x8e2 <_ZN8Robotarm9grabBlockEv>
     ba4:	84 ef       	ldi	r24, 0xF4	; 244
     ba6:	91 e0       	ldi	r25, 0x01	; 1
     ba8:	0e 94 19 10 	call	0x2032	; 0x2032 <vTaskDelay>
		moveBlockToZoneFour();
     bac:	ce 01       	movw	r24, r28
		vTaskDelay( 500 / portTICK_RATE_MS );
     bae:	8d df       	rcall	.-230    	; 0xaca <_ZN8Robotarm19moveBlockToZoneFourEv>
     bb0:	84 ef       	ldi	r24, 0xF4	; 244
     bb2:	91 e0       	ldi	r25, 0x01	; 1
		break;
     bb4:	0e 94 19 10 	call	0x2032	; 0x2032 <vTaskDelay>
		
		case 4U:
		grabBlock();
     bb8:	17 c0       	rjmp	.+46     	; 0xbe8 <_ZN8Robotarm8MoveItemEh+0xb2>
		vTaskDelay( 500 / portTICK_RATE_MS );
     bba:	93 de       	rcall	.-730    	; 0x8e2 <_ZN8Robotarm9grabBlockEv>
     bbc:	84 ef       	ldi	r24, 0xF4	; 244
     bbe:	91 e0       	ldi	r25, 0x01	; 1
		moveBlockToZoneFive();
     bc0:	0e 94 19 10 	call	0x2032	; 0x2032 <vTaskDelay>
     bc4:	ce 01       	movw	r24, r28
		vTaskDelay( 500 / portTICK_RATE_MS );
     bc6:	93 df       	rcall	.-218    	; 0xaee <_ZN8Robotarm19moveBlockToZoneFiveEv>
     bc8:	84 ef       	ldi	r24, 0xF4	; 244
     bca:	91 e0       	ldi	r25, 0x01	; 1
		break;
     bcc:	0e 94 19 10 	call	0x2032	; 0x2032 <vTaskDelay>
		
		case 5U:
		grabBlock();
     bd0:	0b c0       	rjmp	.+22     	; 0xbe8 <_ZN8Robotarm8MoveItemEh+0xb2>
		vTaskDelay( 500 / portTICK_RATE_MS );
     bd2:	87 de       	rcall	.-754    	; 0x8e2 <_ZN8Robotarm9grabBlockEv>
     bd4:	84 ef       	ldi	r24, 0xF4	; 244
     bd6:	91 e0       	ldi	r25, 0x01	; 1
     bd8:	0e 94 19 10 	call	0x2032	; 0x2032 <vTaskDelay>
		moveBlockToZoneSix();
     bdc:	ce 01       	movw	r24, r28
     bde:	99 df       	rcall	.-206    	; 0xb12 <_ZN8Robotarm18moveBlockToZoneSixEv>
		vTaskDelay( 500 / portTICK_RATE_MS );
     be0:	84 ef       	ldi	r24, 0xF4	; 244
     be2:	91 e0       	ldi	r25, 0x01	; 1
     be4:	0e 94 19 10 	call	0x2032	; 0x2032 <vTaskDelay>
		break;
		
		default:
		break;
	}
}
     be8:	df 91       	pop	r29
     bea:	cf 91       	pop	r28
     bec:	08 95       	ret

00000bee <_ZN5Motor10SetDegreesEh>:
	*	 can be used to turn motor at a specific speed set by \ref delay. C
	*	 Note that this function needs to run multiple times to work as intended.
	*    @param uint8_t	degrees to turn
	*    @return void Nothing
	*/
	virtual void SetDegrees( uint8_t degrees )
     bee:	cf 92       	push	r12
     bf0:	df 92       	push	r13
     bf2:	ef 92       	push	r14
     bf4:	ff 92       	push	r15
     bf6:	cf 93       	push	r28
     bf8:	df 93       	push	r29
	{
		if ( maxDegrees_ >= degrees )
     bfa:	fc 01       	movw	r30, r24
     bfc:	26 89       	ldd	r18, Z+22	; 0x16
     bfe:	26 17       	cp	r18, r22
     c00:	c0 f0       	brcs	.+48     	; 0xc32 <_ZN5Motor10SetDegreesEh+0x44>
     c02:	ec 01       	movw	r28, r24
		{
			percent_ = percentPrDeg * degrees + startpercent_;
     c04:	c6 80       	ldd	r12, Z+6	; 0x06
     c06:	d7 80       	ldd	r13, Z+7	; 0x07
     c08:	e0 84       	ldd	r14, Z+8	; 0x08
     c0a:	f1 84       	ldd	r15, Z+9	; 0x09
     c0c:	70 e0       	ldi	r23, 0x00	; 0
     c0e:	80 e0       	ldi	r24, 0x00	; 0
     c10:	90 e0       	ldi	r25, 0x00	; 0
     c12:	0e 94 82 14 	call	0x2904	; 0x2904 <__floatsisf>
     c16:	a7 01       	movw	r20, r14
     c18:	96 01       	movw	r18, r12
     c1a:	0e 94 36 15 	call	0x2a6c	; 0x2a6c <__mulsf3>
     c1e:	2a 89       	ldd	r18, Y+18	; 0x12
     c20:	3b 89       	ldd	r19, Y+19	; 0x13
     c22:	4c 89       	ldd	r20, Y+20	; 0x14
     c24:	5d 89       	ldd	r21, Y+21	; 0x15
     c26:	0e 94 84 13 	call	0x2708	; 0x2708 <__addsf3>
     c2a:	6a 87       	std	Y+10, r22	; 0x0a
     c2c:	7b 87       	std	Y+11, r23	; 0x0b
     c2e:	8c 87       	std	Y+12, r24	; 0x0c
     c30:	9d 87       	std	Y+13, r25	; 0x0d
		}
	}
     c32:	df 91       	pop	r29
     c34:	cf 91       	pop	r28
     c36:	ff 90       	pop	r15
     c38:	ef 90       	pop	r14
     c3a:	df 90       	pop	r13
     c3c:	cf 90       	pop	r12
     c3e:	08 95       	ret

00000c40 <_ZN2M1D1Ev>:

class Motor
{
//functions
public:
	virtual ~Motor() {};
     c40:	28 e3       	ldi	r18, 0x38	; 56
     c42:	32 e0       	ldi	r19, 0x02	; 2
     c44:	fc 01       	movw	r30, r24
     c46:	31 83       	std	Z+1, r19	; 0x01
     c48:	20 83       	st	Z, r18
     c4a:	08 95       	ret

00000c4c <_ZN2M1D0Ev>:
	SetDegrees( 90 );
	tmr1Ptr_->setDutyCycleComA( percent_ );
	oldPercent_ = percent_;
} 

M1::~M1()
     c4c:	cf 93       	push	r28
     c4e:	df 93       	push	r29
     c50:	ec 01       	movw	r28, r24
{
}
     c52:	f6 df       	rcall	.-20     	; 0xc40 <_ZN2M1D1Ev>
     c54:	ce 01       	movw	r24, r28
     c56:	a4 dd       	rcall	.-1208   	; 0x7a0 <_ZdlPv>
     c58:	df 91       	pop	r29
     c5a:	cf 91       	pop	r28
     c5c:	08 95       	ret

00000c5e <_ZN2M19TurnMotorEv>:

void M1::TurnMotor()
{
     c5e:	4f 92       	push	r4
     c60:	5f 92       	push	r5
     c62:	6f 92       	push	r6
     c64:	7f 92       	push	r7
     c66:	8f 92       	push	r8
     c68:	9f 92       	push	r9
     c6a:	af 92       	push	r10
     c6c:	bf 92       	push	r11
     c6e:	cf 92       	push	r12
     c70:	df 92       	push	r13
     c72:	ef 92       	push	r14
     c74:	ff 92       	push	r15
     c76:	cf 93       	push	r28
     c78:	df 93       	push	r29
     c7a:	ec 01       	movw	r28, r24
	if ( percent_ > oldPercent_ + PERCENT_PR_TICK )
     c7c:	8a 84       	ldd	r8, Y+10	; 0x0a
     c7e:	9b 84       	ldd	r9, Y+11	; 0x0b
     c80:	ac 84       	ldd	r10, Y+12	; 0x0c
     c82:	bd 84       	ldd	r11, Y+13	; 0x0d
     c84:	ce 84       	ldd	r12, Y+14	; 0x0e
     c86:	df 84       	ldd	r13, Y+15	; 0x0f
     c88:	e8 88       	ldd	r14, Y+16	; 0x10
     c8a:	f9 88       	ldd	r15, Y+17	; 0x11
     c8c:	20 e0       	ldi	r18, 0x00	; 0
     c8e:	30 e0       	ldi	r19, 0x00	; 0
     c90:	40 e8       	ldi	r20, 0x80	; 128
     c92:	5d e3       	ldi	r21, 0x3D	; 61
     c94:	c7 01       	movw	r24, r14
     c96:	b6 01       	movw	r22, r12
     c98:	0e 94 84 13 	call	0x2708	; 0x2708 <__addsf3>
     c9c:	2b 01       	movw	r4, r22
     c9e:	3c 01       	movw	r6, r24
     ca0:	9b 01       	movw	r18, r22
     ca2:	ac 01       	movw	r20, r24
     ca4:	c5 01       	movw	r24, r10
     ca6:	b4 01       	movw	r22, r8
     ca8:	0e 94 32 15 	call	0x2a64	; 0x2a64 <__gesf2>
     cac:	18 16       	cp	r1, r24
     cae:	74 f4       	brge	.+28     	; 0xccc <_ZN2M19TurnMotorEv+0x6e>
	{
		oldPercent_ += PERCENT_PR_TICK;
     cb0:	4e 86       	std	Y+14, r4	; 0x0e
     cb2:	5f 86       	std	Y+15, r5	; 0x0f
     cb4:	68 8a       	std	Y+16, r6	; 0x10
     cb6:	79 8a       	std	Y+17, r7	; 0x11
		tmr1Ptr_->setDutyCycleComA( oldPercent_ );
     cb8:	b3 01       	movw	r22, r6
     cba:	a2 01       	movw	r20, r4
     cbc:	8a 81       	ldd	r24, Y+2	; 0x02
     cbe:	9b 81       	ldd	r25, Y+3	; 0x03
     cc0:	b9 d3       	rcall	.+1906   	; 0x1434 <_ZN6Timer116setDutyCycleComAEf>
		vTaskDelay( delay_ / portTICK_RATE_MS );
     cc2:	8f 89       	ldd	r24, Y+23	; 0x17
     cc4:	98 8d       	ldd	r25, Y+24	; 0x18
     cc6:	0e 94 19 10 	call	0x2032	; 0x2032 <vTaskDelay>
     cca:	1d c0       	rjmp	.+58     	; 0xd06 <_ZN2M19TurnMotorEv+0xa8>
	}
	else if ( percent_ < oldPercent_ )
     ccc:	a7 01       	movw	r20, r14
     cce:	96 01       	movw	r18, r12
     cd0:	c5 01       	movw	r24, r10
     cd2:	b4 01       	movw	r22, r8
     cd4:	0e 94 e8 13 	call	0x27d0	; 0x27d0 <__cmpsf2>
     cd8:	88 23       	and	r24, r24
     cda:	ac f4       	brge	.+42     	; 0xd06 <_ZN2M19TurnMotorEv+0xa8>
	{
		oldPercent_ -= PERCENT_PR_TICK;
     cdc:	20 e0       	ldi	r18, 0x00	; 0
     cde:	30 e0       	ldi	r19, 0x00	; 0
     ce0:	40 e8       	ldi	r20, 0x80	; 128
     ce2:	5d e3       	ldi	r21, 0x3D	; 61
     ce4:	c7 01       	movw	r24, r14
     ce6:	b6 01       	movw	r22, r12
     ce8:	0e 94 83 13 	call	0x2706	; 0x2706 <__subsf3>
     cec:	ab 01       	movw	r20, r22
     cee:	bc 01       	movw	r22, r24
     cf0:	4e 87       	std	Y+14, r20	; 0x0e
     cf2:	5f 87       	std	Y+15, r21	; 0x0f
     cf4:	68 8b       	std	Y+16, r22	; 0x10
     cf6:	79 8b       	std	Y+17, r23	; 0x11
		tmr1Ptr_->setDutyCycleComA( oldPercent_ );
     cf8:	8a 81       	ldd	r24, Y+2	; 0x02
     cfa:	9b 81       	ldd	r25, Y+3	; 0x03
     cfc:	9b d3       	rcall	.+1846   	; 0x1434 <_ZN6Timer116setDutyCycleComAEf>
		vTaskDelay( delay_ / portTICK_RATE_MS );
     cfe:	8f 89       	ldd	r24, Y+23	; 0x17
     d00:	98 8d       	ldd	r25, Y+24	; 0x18
     d02:	0e 94 19 10 	call	0x2032	; 0x2032 <vTaskDelay>
	}
}
     d06:	df 91       	pop	r29
     d08:	cf 91       	pop	r28
     d0a:	ff 90       	pop	r15
     d0c:	ef 90       	pop	r14
     d0e:	df 90       	pop	r13
     d10:	cf 90       	pop	r12
     d12:	bf 90       	pop	r11
     d14:	af 90       	pop	r10
     d16:	9f 90       	pop	r9
     d18:	8f 90       	pop	r8
     d1a:	7f 90       	pop	r7
     d1c:	6f 90       	pop	r6
     d1e:	5f 90       	pop	r5
     d20:	4f 90       	pop	r4
     d22:	08 95       	ret

00000d24 <_ZN2M1C1EP6Timer1>:
* Author: jespe
*/

#include "M1.h"

M1::M1( Timer1* tmr )
     d24:	cf 93       	push	r28
     d26:	df 93       	push	r29
     d28:	ec 01       	movw	r28, r24
     d2a:	cb 01       	movw	r24, r22
     d2c:	24 e4       	ldi	r18, 0x44	; 68
     d2e:	32 e0       	ldi	r19, 0x02	; 2
     d30:	39 83       	std	Y+1, r19	; 0x01
     d32:	28 83       	st	Y, r18
{
	/* Store timer pointer */
	tmr1Ptr_ = tmr;
     d34:	7b 83       	std	Y+3, r23	; 0x03
     d36:	6a 83       	std	Y+2, r22	; 0x02
	
	/* This value is number of percent to add or subtract pr degree. */
	percentPrDeg = 0.0555555555555556;
     d38:	49 e3       	ldi	r20, 0x39	; 57
     d3a:	5e e8       	ldi	r21, 0x8E	; 142
     d3c:	63 e6       	ldi	r22, 0x63	; 99
     d3e:	7d e3       	ldi	r23, 0x3D	; 61
     d40:	4e 83       	std	Y+6, r20	; 0x06
     d42:	5f 83       	std	Y+7, r21	; 0x07
     d44:	68 87       	std	Y+8, r22	; 0x08
     d46:	79 87       	std	Y+9, r23	; 0x09
	
	/* This value is the lowest duty cycle percentage needed to make motor turn. */
	startpercent_ = 2.5;
     d48:	40 e0       	ldi	r20, 0x00	; 0
     d4a:	50 e0       	ldi	r21, 0x00	; 0
     d4c:	60 e2       	ldi	r22, 0x20	; 32
     d4e:	70 e4       	ldi	r23, 0x40	; 64
     d50:	4a 8b       	std	Y+18, r20	; 0x12
     d52:	5b 8b       	std	Y+19, r21	; 0x13
     d54:	6c 8b       	std	Y+20, r22	; 0x14
     d56:	7d 8b       	std	Y+21, r23	; 0x15
	
	/* This value is the delay on motor. A lower value makes motors go faster and higher value makes motors go slower. */
	delay_ = 10;
     d58:	2a e0       	ldi	r18, 0x0A	; 10
     d5a:	30 e0       	ldi	r19, 0x00	; 0
     d5c:	38 8f       	std	Y+24, r19	; 0x18
     d5e:	2f 8b       	std	Y+23, r18	; 0x17
	
	/* This value is the maximum number of degrees the motor can turn */
	maxDegrees_ = 180;
     d60:	24 eb       	ldi	r18, 0xB4	; 180
     d62:	2e 8b       	std	Y+22, r18	; 0x16
	*/
	virtual void SetDegrees( uint8_t degrees )
	{
		if ( maxDegrees_ >= degrees )
		{
			percent_ = percentPrDeg * degrees + startpercent_;
     d64:	40 e0       	ldi	r20, 0x00	; 0
     d66:	50 e0       	ldi	r21, 0x00	; 0
     d68:	60 ef       	ldi	r22, 0xF0	; 240
     d6a:	70 e4       	ldi	r23, 0x40	; 64
     d6c:	4a 87       	std	Y+10, r20	; 0x0a
     d6e:	5b 87       	std	Y+11, r21	; 0x0b
     d70:	6c 87       	std	Y+12, r22	; 0x0c
     d72:	7d 87       	std	Y+13, r23	; 0x0d
	
	/* Set motor to default startup value */
	SetDegrees( 90 );
	tmr1Ptr_->setDutyCycleComA( percent_ );
     d74:	5f d3       	rcall	.+1726   	; 0x1434 <_ZN6Timer116setDutyCycleComAEf>
	oldPercent_ = percent_;
     d76:	8a 85       	ldd	r24, Y+10	; 0x0a
     d78:	9b 85       	ldd	r25, Y+11	; 0x0b
     d7a:	ac 85       	ldd	r26, Y+12	; 0x0c
     d7c:	bd 85       	ldd	r27, Y+13	; 0x0d
     d7e:	8e 87       	std	Y+14, r24	; 0x0e
     d80:	9f 87       	std	Y+15, r25	; 0x0f
     d82:	a8 8b       	std	Y+16, r26	; 0x10
     d84:	b9 8b       	std	Y+17, r27	; 0x11
} 
     d86:	df 91       	pop	r29
     d88:	cf 91       	pop	r28
     d8a:	08 95       	ret

00000d8c <_ZN2M2D1Ev>:

class Motor
{
//functions
public:
	virtual ~Motor() {};
     d8c:	28 e3       	ldi	r18, 0x38	; 56
     d8e:	32 e0       	ldi	r19, 0x02	; 2
     d90:	fc 01       	movw	r30, r24
     d92:	31 83       	std	Z+1, r19	; 0x01
     d94:	20 83       	st	Z, r18
     d96:	08 95       	ret

00000d98 <_ZN2M2D0Ev>:
	SetDegrees( 90 );
	tmr1Ptr_->setDutyCycleComB( percent_ );
	oldPercent_ = percent_;
}

M2::~M2()
     d98:	cf 93       	push	r28
     d9a:	df 93       	push	r29
     d9c:	ec 01       	movw	r28, r24
{
}
     d9e:	f6 df       	rcall	.-20     	; 0xd8c <_ZN2M2D1Ev>
     da0:	ce 01       	movw	r24, r28
     da2:	fe dc       	rcall	.-1540   	; 0x7a0 <_ZdlPv>
     da4:	df 91       	pop	r29
     da6:	cf 91       	pop	r28
     da8:	08 95       	ret

00000daa <_ZN2M29TurnMotorEv>:

void M2::TurnMotor()
{
     daa:	4f 92       	push	r4
     dac:	5f 92       	push	r5
     dae:	6f 92       	push	r6
     db0:	7f 92       	push	r7
     db2:	8f 92       	push	r8
     db4:	9f 92       	push	r9
     db6:	af 92       	push	r10
     db8:	bf 92       	push	r11
     dba:	cf 92       	push	r12
     dbc:	df 92       	push	r13
     dbe:	ef 92       	push	r14
     dc0:	ff 92       	push	r15
     dc2:	cf 93       	push	r28
     dc4:	df 93       	push	r29
     dc6:	ec 01       	movw	r28, r24
	if ( percent_ > oldPercent_ + PERCENT_PR_TICK )
     dc8:	8a 84       	ldd	r8, Y+10	; 0x0a
     dca:	9b 84       	ldd	r9, Y+11	; 0x0b
     dcc:	ac 84       	ldd	r10, Y+12	; 0x0c
     dce:	bd 84       	ldd	r11, Y+13	; 0x0d
     dd0:	ce 84       	ldd	r12, Y+14	; 0x0e
     dd2:	df 84       	ldd	r13, Y+15	; 0x0f
     dd4:	e8 88       	ldd	r14, Y+16	; 0x10
     dd6:	f9 88       	ldd	r15, Y+17	; 0x11
     dd8:	20 e0       	ldi	r18, 0x00	; 0
     dda:	30 e0       	ldi	r19, 0x00	; 0
     ddc:	40 e8       	ldi	r20, 0x80	; 128
     dde:	5d e3       	ldi	r21, 0x3D	; 61
     de0:	c7 01       	movw	r24, r14
     de2:	b6 01       	movw	r22, r12
     de4:	0e 94 84 13 	call	0x2708	; 0x2708 <__addsf3>
     de8:	2b 01       	movw	r4, r22
     dea:	3c 01       	movw	r6, r24
     dec:	9b 01       	movw	r18, r22
     dee:	ac 01       	movw	r20, r24
     df0:	c5 01       	movw	r24, r10
     df2:	b4 01       	movw	r22, r8
     df4:	0e 94 32 15 	call	0x2a64	; 0x2a64 <__gesf2>
     df8:	18 16       	cp	r1, r24
     dfa:	74 f4       	brge	.+28     	; 0xe18 <_ZN2M29TurnMotorEv+0x6e>
	{
		oldPercent_ += PERCENT_PR_TICK;
     dfc:	4e 86       	std	Y+14, r4	; 0x0e
     dfe:	5f 86       	std	Y+15, r5	; 0x0f
     e00:	68 8a       	std	Y+16, r6	; 0x10
     e02:	79 8a       	std	Y+17, r7	; 0x11
		tmr1Ptr_->setDutyCycleComB( oldPercent_ );
     e04:	b3 01       	movw	r22, r6
     e06:	a2 01       	movw	r20, r4
     e08:	8a 81       	ldd	r24, Y+2	; 0x02
     e0a:	9b 81       	ldd	r25, Y+3	; 0x03
     e0c:	3e d3       	rcall	.+1660   	; 0x148a <_ZN6Timer116setDutyCycleComBEf>
		vTaskDelay( delay_ / portTICK_RATE_MS );
     e0e:	8f 89       	ldd	r24, Y+23	; 0x17
     e10:	98 8d       	ldd	r25, Y+24	; 0x18
     e12:	0e 94 19 10 	call	0x2032	; 0x2032 <vTaskDelay>
     e16:	1d c0       	rjmp	.+58     	; 0xe52 <_ZN2M29TurnMotorEv+0xa8>
	}
	else if ( percent_ < oldPercent_ )
     e18:	a7 01       	movw	r20, r14
     e1a:	96 01       	movw	r18, r12
     e1c:	c5 01       	movw	r24, r10
     e1e:	b4 01       	movw	r22, r8
     e20:	0e 94 e8 13 	call	0x27d0	; 0x27d0 <__cmpsf2>
     e24:	88 23       	and	r24, r24
     e26:	ac f4       	brge	.+42     	; 0xe52 <_ZN2M29TurnMotorEv+0xa8>
	{
		oldPercent_ -= PERCENT_PR_TICK;
     e28:	20 e0       	ldi	r18, 0x00	; 0
     e2a:	30 e0       	ldi	r19, 0x00	; 0
     e2c:	40 e8       	ldi	r20, 0x80	; 128
     e2e:	5d e3       	ldi	r21, 0x3D	; 61
     e30:	c7 01       	movw	r24, r14
     e32:	b6 01       	movw	r22, r12
     e34:	0e 94 83 13 	call	0x2706	; 0x2706 <__subsf3>
     e38:	ab 01       	movw	r20, r22
     e3a:	bc 01       	movw	r22, r24
     e3c:	4e 87       	std	Y+14, r20	; 0x0e
     e3e:	5f 87       	std	Y+15, r21	; 0x0f
     e40:	68 8b       	std	Y+16, r22	; 0x10
     e42:	79 8b       	std	Y+17, r23	; 0x11
		tmr1Ptr_->setDutyCycleComB( oldPercent_ );
     e44:	8a 81       	ldd	r24, Y+2	; 0x02
     e46:	9b 81       	ldd	r25, Y+3	; 0x03
     e48:	20 d3       	rcall	.+1600   	; 0x148a <_ZN6Timer116setDutyCycleComBEf>
		vTaskDelay( delay_ / portTICK_RATE_MS );
     e4a:	8f 89       	ldd	r24, Y+23	; 0x17
     e4c:	98 8d       	ldd	r25, Y+24	; 0x18
     e4e:	0e 94 19 10 	call	0x2032	; 0x2032 <vTaskDelay>
	}
}
     e52:	df 91       	pop	r29
     e54:	cf 91       	pop	r28
     e56:	ff 90       	pop	r15
     e58:	ef 90       	pop	r14
     e5a:	df 90       	pop	r13
     e5c:	cf 90       	pop	r12
     e5e:	bf 90       	pop	r11
     e60:	af 90       	pop	r10
     e62:	9f 90       	pop	r9
     e64:	8f 90       	pop	r8
     e66:	7f 90       	pop	r7
     e68:	6f 90       	pop	r6
     e6a:	5f 90       	pop	r5
     e6c:	4f 90       	pop	r4
     e6e:	08 95       	ret

00000e70 <_ZN2M2C1EP6Timer1>:
* Author: jespe
*/

#include "M2.h"

M2::M2( Timer1* tmr )
     e70:	cf 93       	push	r28
     e72:	df 93       	push	r29
     e74:	ec 01       	movw	r28, r24
     e76:	cb 01       	movw	r24, r22
     e78:	20 e5       	ldi	r18, 0x50	; 80
     e7a:	32 e0       	ldi	r19, 0x02	; 2
     e7c:	39 83       	std	Y+1, r19	; 0x01
     e7e:	28 83       	st	Y, r18
{
	/* Store timer pointer */
	tmr1Ptr_ = tmr;
     e80:	7b 83       	std	Y+3, r23	; 0x03
     e82:	6a 83       	std	Y+2, r22	; 0x02
	
	/* This value is number of percent to add or subtract pr degree. */
	percentPrDeg = 0.06;
     e84:	4f e8       	ldi	r20, 0x8F	; 143
     e86:	52 ec       	ldi	r21, 0xC2	; 194
     e88:	65 e7       	ldi	r22, 0x75	; 117
     e8a:	7d e3       	ldi	r23, 0x3D	; 61
     e8c:	4e 83       	std	Y+6, r20	; 0x06
     e8e:	5f 83       	std	Y+7, r21	; 0x07
     e90:	68 87       	std	Y+8, r22	; 0x08
     e92:	79 87       	std	Y+9, r23	; 0x09

	/* This value is the lowest duty cycle percentage needed to make motor turn. */
	startpercent_ = 3;
     e94:	40 e0       	ldi	r20, 0x00	; 0
     e96:	50 e0       	ldi	r21, 0x00	; 0
     e98:	60 e4       	ldi	r22, 0x40	; 64
     e9a:	70 e4       	ldi	r23, 0x40	; 64
     e9c:	4a 8b       	std	Y+18, r20	; 0x12
     e9e:	5b 8b       	std	Y+19, r21	; 0x13
     ea0:	6c 8b       	std	Y+20, r22	; 0x14
     ea2:	7d 8b       	std	Y+21, r23	; 0x15

	/* This value is the delay on motor. A lower value makes motors go faster and higher value makes motors go slower. Value is in MS */
	delay_ = 10;
     ea4:	2a e0       	ldi	r18, 0x0A	; 10
     ea6:	30 e0       	ldi	r19, 0x00	; 0
     ea8:	38 8f       	std	Y+24, r19	; 0x18
     eaa:	2f 8b       	std	Y+23, r18	; 0x17

	/* This value is the maximum number of degrees the motor can turn */
	maxDegrees_ = 150;
     eac:	26 e9       	ldi	r18, 0x96	; 150
     eae:	2e 8b       	std	Y+22, r18	; 0x16
	*/
	virtual void SetDegrees( uint8_t degrees )
	{
		if ( maxDegrees_ >= degrees )
		{
			percent_ = percentPrDeg * degrees + startpercent_;
     eb0:	46 e6       	ldi	r20, 0x66	; 102
     eb2:	56 e6       	ldi	r21, 0x66	; 102
     eb4:	66 e0       	ldi	r22, 0x06	; 6
     eb6:	71 e4       	ldi	r23, 0x41	; 65
     eb8:	4a 87       	std	Y+10, r20	; 0x0a
     eba:	5b 87       	std	Y+11, r21	; 0x0b
     ebc:	6c 87       	std	Y+12, r22	; 0x0c
     ebe:	7d 87       	std	Y+13, r23	; 0x0d

	/* Set motor to default startup value */
	SetDegrees( 90 );
	tmr1Ptr_->setDutyCycleComB( percent_ );
     ec0:	e4 d2       	rcall	.+1480   	; 0x148a <_ZN6Timer116setDutyCycleComBEf>
	oldPercent_ = percent_;
     ec2:	8a 85       	ldd	r24, Y+10	; 0x0a
     ec4:	9b 85       	ldd	r25, Y+11	; 0x0b
     ec6:	ac 85       	ldd	r26, Y+12	; 0x0c
     ec8:	bd 85       	ldd	r27, Y+13	; 0x0d
     eca:	8e 87       	std	Y+14, r24	; 0x0e
     ecc:	9f 87       	std	Y+15, r25	; 0x0f
     ece:	a8 8b       	std	Y+16, r26	; 0x10
     ed0:	b9 8b       	std	Y+17, r27	; 0x11
}
     ed2:	df 91       	pop	r29
     ed4:	cf 91       	pop	r28
     ed6:	08 95       	ret

00000ed8 <_ZN2M3D1Ev>:

class Motor
{
//functions
public:
	virtual ~Motor() {};
     ed8:	28 e3       	ldi	r18, 0x38	; 56
     eda:	32 e0       	ldi	r19, 0x02	; 2
     edc:	fc 01       	movw	r30, r24
     ede:	31 83       	std	Z+1, r19	; 0x01
     ee0:	20 83       	st	Z, r18
     ee2:	08 95       	ret

00000ee4 <_ZN2M3D0Ev>:
	SetDegrees( 90 );
	tmr1Ptr_->setDutyCycleComC( percent_ );
	oldPercent_ = percent_;	
}

M3::~M3()
     ee4:	cf 93       	push	r28
     ee6:	df 93       	push	r29
     ee8:	ec 01       	movw	r28, r24
{
}
     eea:	f6 df       	rcall	.-20     	; 0xed8 <_ZN2M3D1Ev>
     eec:	ce 01       	movw	r24, r28
     eee:	58 dc       	rcall	.-1872   	; 0x7a0 <_ZdlPv>
     ef0:	df 91       	pop	r29
     ef2:	cf 91       	pop	r28
     ef4:	08 95       	ret

00000ef6 <_ZN2M39TurnMotorEv>:

void M3::TurnMotor()
{
     ef6:	4f 92       	push	r4
     ef8:	5f 92       	push	r5
     efa:	6f 92       	push	r6
     efc:	7f 92       	push	r7
     efe:	8f 92       	push	r8
     f00:	9f 92       	push	r9
     f02:	af 92       	push	r10
     f04:	bf 92       	push	r11
     f06:	cf 92       	push	r12
     f08:	df 92       	push	r13
     f0a:	ef 92       	push	r14
     f0c:	ff 92       	push	r15
     f0e:	cf 93       	push	r28
     f10:	df 93       	push	r29
     f12:	ec 01       	movw	r28, r24
	if ( percent_ > oldPercent_ + PERCENT_PR_TICK )
     f14:	8a 84       	ldd	r8, Y+10	; 0x0a
     f16:	9b 84       	ldd	r9, Y+11	; 0x0b
     f18:	ac 84       	ldd	r10, Y+12	; 0x0c
     f1a:	bd 84       	ldd	r11, Y+13	; 0x0d
     f1c:	ce 84       	ldd	r12, Y+14	; 0x0e
     f1e:	df 84       	ldd	r13, Y+15	; 0x0f
     f20:	e8 88       	ldd	r14, Y+16	; 0x10
     f22:	f9 88       	ldd	r15, Y+17	; 0x11
     f24:	20 e0       	ldi	r18, 0x00	; 0
     f26:	30 e0       	ldi	r19, 0x00	; 0
     f28:	40 e8       	ldi	r20, 0x80	; 128
     f2a:	5d e3       	ldi	r21, 0x3D	; 61
     f2c:	c7 01       	movw	r24, r14
     f2e:	b6 01       	movw	r22, r12
     f30:	0e 94 84 13 	call	0x2708	; 0x2708 <__addsf3>
     f34:	2b 01       	movw	r4, r22
     f36:	3c 01       	movw	r6, r24
     f38:	9b 01       	movw	r18, r22
     f3a:	ac 01       	movw	r20, r24
     f3c:	c5 01       	movw	r24, r10
     f3e:	b4 01       	movw	r22, r8
     f40:	0e 94 32 15 	call	0x2a64	; 0x2a64 <__gesf2>
     f44:	18 16       	cp	r1, r24
     f46:	74 f4       	brge	.+28     	; 0xf64 <_ZN2M39TurnMotorEv+0x6e>
	{
		oldPercent_ += PERCENT_PR_TICK;
     f48:	4e 86       	std	Y+14, r4	; 0x0e
     f4a:	5f 86       	std	Y+15, r5	; 0x0f
     f4c:	68 8a       	std	Y+16, r6	; 0x10
     f4e:	79 8a       	std	Y+17, r7	; 0x11
		tmr1Ptr_->setDutyCycleComC( oldPercent_ );
     f50:	b3 01       	movw	r22, r6
     f52:	a2 01       	movw	r20, r4
     f54:	8a 81       	ldd	r24, Y+2	; 0x02
     f56:	9b 81       	ldd	r25, Y+3	; 0x03
     f58:	c3 d2       	rcall	.+1414   	; 0x14e0 <_ZN6Timer116setDutyCycleComCEf>
		vTaskDelay( delay_ / portTICK_RATE_MS );
     f5a:	8f 89       	ldd	r24, Y+23	; 0x17
     f5c:	98 8d       	ldd	r25, Y+24	; 0x18
     f5e:	0e 94 19 10 	call	0x2032	; 0x2032 <vTaskDelay>
     f62:	1d c0       	rjmp	.+58     	; 0xf9e <_ZN2M39TurnMotorEv+0xa8>
	}
	else if ( percent_ < oldPercent_ )
     f64:	a7 01       	movw	r20, r14
     f66:	96 01       	movw	r18, r12
     f68:	c5 01       	movw	r24, r10
     f6a:	b4 01       	movw	r22, r8
     f6c:	0e 94 e8 13 	call	0x27d0	; 0x27d0 <__cmpsf2>
     f70:	88 23       	and	r24, r24
     f72:	ac f4       	brge	.+42     	; 0xf9e <_ZN2M39TurnMotorEv+0xa8>
	{
		oldPercent_ -= PERCENT_PR_TICK;
     f74:	20 e0       	ldi	r18, 0x00	; 0
     f76:	30 e0       	ldi	r19, 0x00	; 0
     f78:	40 e8       	ldi	r20, 0x80	; 128
     f7a:	5d e3       	ldi	r21, 0x3D	; 61
     f7c:	c7 01       	movw	r24, r14
     f7e:	b6 01       	movw	r22, r12
     f80:	0e 94 83 13 	call	0x2706	; 0x2706 <__subsf3>
     f84:	ab 01       	movw	r20, r22
     f86:	bc 01       	movw	r22, r24
     f88:	4e 87       	std	Y+14, r20	; 0x0e
     f8a:	5f 87       	std	Y+15, r21	; 0x0f
     f8c:	68 8b       	std	Y+16, r22	; 0x10
     f8e:	79 8b       	std	Y+17, r23	; 0x11
		tmr1Ptr_->setDutyCycleComC( oldPercent_ );
     f90:	8a 81       	ldd	r24, Y+2	; 0x02
     f92:	9b 81       	ldd	r25, Y+3	; 0x03
     f94:	a5 d2       	rcall	.+1354   	; 0x14e0 <_ZN6Timer116setDutyCycleComCEf>
		vTaskDelay( delay_ / portTICK_RATE_MS );
     f96:	8f 89       	ldd	r24, Y+23	; 0x17
     f98:	98 8d       	ldd	r25, Y+24	; 0x18
     f9a:	0e 94 19 10 	call	0x2032	; 0x2032 <vTaskDelay>
	}
}
     f9e:	df 91       	pop	r29
     fa0:	cf 91       	pop	r28
     fa2:	ff 90       	pop	r15
     fa4:	ef 90       	pop	r14
     fa6:	df 90       	pop	r13
     fa8:	cf 90       	pop	r12
     faa:	bf 90       	pop	r11
     fac:	af 90       	pop	r10
     fae:	9f 90       	pop	r9
     fb0:	8f 90       	pop	r8
     fb2:	7f 90       	pop	r7
     fb4:	6f 90       	pop	r6
     fb6:	5f 90       	pop	r5
     fb8:	4f 90       	pop	r4
     fba:	08 95       	ret

00000fbc <_ZN2M3C1EP6Timer1>:
*/

#include "M3.h"


M3::M3( Timer1* tmr )
     fbc:	cf 93       	push	r28
     fbe:	df 93       	push	r29
     fc0:	ec 01       	movw	r28, r24
     fc2:	cb 01       	movw	r24, r22
     fc4:	2c e5       	ldi	r18, 0x5C	; 92
     fc6:	32 e0       	ldi	r19, 0x02	; 2
     fc8:	39 83       	std	Y+1, r19	; 0x01
     fca:	28 83       	st	Y, r18
{
	/* Store timer pointer */
	tmr1Ptr_ = tmr;
     fcc:	7b 83       	std	Y+3, r23	; 0x03
     fce:	6a 83       	std	Y+2, r22	; 0x02
		
	/* This value is number of percent to add or subtract pr degree. */
	percentPrDeg = 0.0555555555555556;
     fd0:	49 e3       	ldi	r20, 0x39	; 57
     fd2:	5e e8       	ldi	r21, 0x8E	; 142
     fd4:	63 e6       	ldi	r22, 0x63	; 99
     fd6:	7d e3       	ldi	r23, 0x3D	; 61
     fd8:	4e 83       	std	Y+6, r20	; 0x06
     fda:	5f 83       	std	Y+7, r21	; 0x07
     fdc:	68 87       	std	Y+8, r22	; 0x08
     fde:	79 87       	std	Y+9, r23	; 0x09
	
	/* This value is the lowest duty cycle percentage needed to make motor turn. */
	startpercent_ = 2.5;
     fe0:	40 e0       	ldi	r20, 0x00	; 0
     fe2:	50 e0       	ldi	r21, 0x00	; 0
     fe4:	60 e2       	ldi	r22, 0x20	; 32
     fe6:	70 e4       	ldi	r23, 0x40	; 64
     fe8:	4a 8b       	std	Y+18, r20	; 0x12
     fea:	5b 8b       	std	Y+19, r21	; 0x13
     fec:	6c 8b       	std	Y+20, r22	; 0x14
     fee:	7d 8b       	std	Y+21, r23	; 0x15

	/* This value is the delay on motor. A lower value makes motors go faster and higher value makes motors go slower. Value is in MS */
	delay_ = 10;
     ff0:	2a e0       	ldi	r18, 0x0A	; 10
     ff2:	30 e0       	ldi	r19, 0x00	; 0
     ff4:	38 8f       	std	Y+24, r19	; 0x18
     ff6:	2f 8b       	std	Y+23, r18	; 0x17
	
	/* This value is the maximum number of degrees the motor can turn */
	maxDegrees_ = 180;
     ff8:	24 eb       	ldi	r18, 0xB4	; 180
     ffa:	2e 8b       	std	Y+22, r18	; 0x16
	*/
	virtual void SetDegrees( uint8_t degrees )
	{
		if ( maxDegrees_ >= degrees )
		{
			percent_ = percentPrDeg * degrees + startpercent_;
     ffc:	40 e0       	ldi	r20, 0x00	; 0
     ffe:	50 e0       	ldi	r21, 0x00	; 0
    1000:	60 ef       	ldi	r22, 0xF0	; 240
    1002:	70 e4       	ldi	r23, 0x40	; 64
    1004:	4a 87       	std	Y+10, r20	; 0x0a
    1006:	5b 87       	std	Y+11, r21	; 0x0b
    1008:	6c 87       	std	Y+12, r22	; 0x0c
    100a:	7d 87       	std	Y+13, r23	; 0x0d
	
	/* Set motor to default startup value */
	SetDegrees( 90 );
	tmr1Ptr_->setDutyCycleComC( percent_ );
    100c:	69 d2       	rcall	.+1234   	; 0x14e0 <_ZN6Timer116setDutyCycleComCEf>
	oldPercent_ = percent_;	
    100e:	8a 85       	ldd	r24, Y+10	; 0x0a
    1010:	9b 85       	ldd	r25, Y+11	; 0x0b
    1012:	ac 85       	ldd	r26, Y+12	; 0x0c
    1014:	bd 85       	ldd	r27, Y+13	; 0x0d
    1016:	8e 87       	std	Y+14, r24	; 0x0e
    1018:	9f 87       	std	Y+15, r25	; 0x0f
    101a:	a8 8b       	std	Y+16, r26	; 0x10
    101c:	b9 8b       	std	Y+17, r27	; 0x11
}
    101e:	df 91       	pop	r29
    1020:	cf 91       	pop	r28
    1022:	08 95       	ret

00001024 <_ZN2M4D1Ev>:

class Motor
{
//functions
public:
	virtual ~Motor() {};
    1024:	28 e3       	ldi	r18, 0x38	; 56
    1026:	32 e0       	ldi	r19, 0x02	; 2
    1028:	fc 01       	movw	r30, r24
    102a:	31 83       	std	Z+1, r19	; 0x01
    102c:	20 83       	st	Z, r18
    102e:	08 95       	ret

00001030 <_ZN2M4D0Ev>:
	SetDegrees( 90 );
	tmr3Ptr_->setDutyCycleComA( percent_ );
	oldPercent_ = percent_;
}

M4::~M4()
    1030:	cf 93       	push	r28
    1032:	df 93       	push	r29
    1034:	ec 01       	movw	r28, r24
{
} 
    1036:	f6 df       	rcall	.-20     	; 0x1024 <_ZN2M4D1Ev>
    1038:	ce 01       	movw	r24, r28
    103a:	b2 db       	rcall	.-2204   	; 0x7a0 <_ZdlPv>
    103c:	df 91       	pop	r29
    103e:	cf 91       	pop	r28
    1040:	08 95       	ret

00001042 <_ZN2M49TurnMotorEv>:

void M4::TurnMotor()
{
    1042:	4f 92       	push	r4
    1044:	5f 92       	push	r5
    1046:	6f 92       	push	r6
    1048:	7f 92       	push	r7
    104a:	8f 92       	push	r8
    104c:	9f 92       	push	r9
    104e:	af 92       	push	r10
    1050:	bf 92       	push	r11
    1052:	cf 92       	push	r12
    1054:	df 92       	push	r13
    1056:	ef 92       	push	r14
    1058:	ff 92       	push	r15
    105a:	cf 93       	push	r28
    105c:	df 93       	push	r29
    105e:	ec 01       	movw	r28, r24
	if ( percent_ > oldPercent_ + PERCENT_PR_TICK )
    1060:	8a 84       	ldd	r8, Y+10	; 0x0a
    1062:	9b 84       	ldd	r9, Y+11	; 0x0b
    1064:	ac 84       	ldd	r10, Y+12	; 0x0c
    1066:	bd 84       	ldd	r11, Y+13	; 0x0d
    1068:	ce 84       	ldd	r12, Y+14	; 0x0e
    106a:	df 84       	ldd	r13, Y+15	; 0x0f
    106c:	e8 88       	ldd	r14, Y+16	; 0x10
    106e:	f9 88       	ldd	r15, Y+17	; 0x11
    1070:	20 e0       	ldi	r18, 0x00	; 0
    1072:	30 e0       	ldi	r19, 0x00	; 0
    1074:	40 e8       	ldi	r20, 0x80	; 128
    1076:	5d e3       	ldi	r21, 0x3D	; 61
    1078:	c7 01       	movw	r24, r14
    107a:	b6 01       	movw	r22, r12
    107c:	0e 94 84 13 	call	0x2708	; 0x2708 <__addsf3>
    1080:	2b 01       	movw	r4, r22
    1082:	3c 01       	movw	r6, r24
    1084:	9b 01       	movw	r18, r22
    1086:	ac 01       	movw	r20, r24
    1088:	c5 01       	movw	r24, r10
    108a:	b4 01       	movw	r22, r8
    108c:	0e 94 32 15 	call	0x2a64	; 0x2a64 <__gesf2>
    1090:	18 16       	cp	r1, r24
    1092:	6c f4       	brge	.+26     	; 0x10ae <_ZN2M49TurnMotorEv+0x6c>
	{
		oldPercent_ += PERCENT_PR_TICK;
    1094:	4e 86       	std	Y+14, r4	; 0x0e
    1096:	5f 86       	std	Y+15, r5	; 0x0f
    1098:	68 8a       	std	Y+16, r6	; 0x10
    109a:	79 8a       	std	Y+17, r7	; 0x11
		tmr3Ptr_->setDutyCycleComA( oldPercent_ );
    109c:	b3 01       	movw	r22, r6
    109e:	a2 01       	movw	r20, r4
    10a0:	8c 81       	ldd	r24, Y+4	; 0x04
    10a2:	9d 81       	ldd	r25, Y+5	; 0x05
    10a4:	6e d2       	rcall	.+1244   	; 0x1582 <_ZN6Timer516setDutyCycleComAEf>
		vTaskDelay( 10 / portTICK_RATE_MS );
    10a6:	8a e0       	ldi	r24, 0x0A	; 10
    10a8:	90 e0       	ldi	r25, 0x00	; 0
    10aa:	c3 d7       	rcall	.+3974   	; 0x2032 <vTaskDelay>
    10ac:	1c c0       	rjmp	.+56     	; 0x10e6 <_ZN2M49TurnMotorEv+0xa4>
	}
	else if ( percent_ < oldPercent_ )
    10ae:	a7 01       	movw	r20, r14
    10b0:	96 01       	movw	r18, r12
    10b2:	c5 01       	movw	r24, r10
    10b4:	b4 01       	movw	r22, r8
    10b6:	0e 94 e8 13 	call	0x27d0	; 0x27d0 <__cmpsf2>
    10ba:	88 23       	and	r24, r24
    10bc:	a4 f4       	brge	.+40     	; 0x10e6 <_ZN2M49TurnMotorEv+0xa4>
	{
		oldPercent_ -= PERCENT_PR_TICK;
    10be:	20 e0       	ldi	r18, 0x00	; 0
    10c0:	30 e0       	ldi	r19, 0x00	; 0
    10c2:	40 e8       	ldi	r20, 0x80	; 128
    10c4:	5d e3       	ldi	r21, 0x3D	; 61
    10c6:	c7 01       	movw	r24, r14
    10c8:	b6 01       	movw	r22, r12
    10ca:	0e 94 83 13 	call	0x2706	; 0x2706 <__subsf3>
    10ce:	ab 01       	movw	r20, r22
    10d0:	bc 01       	movw	r22, r24
    10d2:	4e 87       	std	Y+14, r20	; 0x0e
    10d4:	5f 87       	std	Y+15, r21	; 0x0f
    10d6:	68 8b       	std	Y+16, r22	; 0x10
    10d8:	79 8b       	std	Y+17, r23	; 0x11
		tmr3Ptr_->setDutyCycleComA( oldPercent_ );
    10da:	8c 81       	ldd	r24, Y+4	; 0x04
    10dc:	9d 81       	ldd	r25, Y+5	; 0x05
    10de:	51 d2       	rcall	.+1186   	; 0x1582 <_ZN6Timer516setDutyCycleComAEf>
		vTaskDelay( 10 / portTICK_RATE_MS );
    10e0:	8a e0       	ldi	r24, 0x0A	; 10
    10e2:	90 e0       	ldi	r25, 0x00	; 0
    10e4:	a6 d7       	rcall	.+3916   	; 0x2032 <vTaskDelay>
    10e6:	df 91       	pop	r29
	}
}
    10e8:	cf 91       	pop	r28
    10ea:	ff 90       	pop	r15
    10ec:	ef 90       	pop	r14
    10ee:	df 90       	pop	r13
    10f0:	cf 90       	pop	r12
    10f2:	bf 90       	pop	r11
    10f4:	af 90       	pop	r10
    10f6:	9f 90       	pop	r9
    10f8:	8f 90       	pop	r8
    10fa:	7f 90       	pop	r7
    10fc:	6f 90       	pop	r6
    10fe:	5f 90       	pop	r5
    1100:	4f 90       	pop	r4
    1102:	08 95       	ret

00001104 <_ZN2M4C1EP6Timer5>:
    1104:	cf 93       	push	r28
* Author: jespe
*/

#include "M4.h"

M4::M4( Timer5* tmr )
    1106:	df 93       	push	r29
    1108:	ec 01       	movw	r28, r24
    110a:	cb 01       	movw	r24, r22
    110c:	28 e6       	ldi	r18, 0x68	; 104
    110e:	32 e0       	ldi	r19, 0x02	; 2
    1110:	39 83       	std	Y+1, r19	; 0x01
    1112:	28 83       	st	Y, r18
{
	/* Store timer pointer */
	tmr3Ptr_ = tmr;
    1114:	7d 83       	std	Y+5, r23	; 0x05
    1116:	6c 83       	std	Y+4, r22	; 0x04
	
	/* This value is number of percent to add or subtract pr degree. */
	percentPrDeg = 0.0555555555555556;
    1118:	49 e3       	ldi	r20, 0x39	; 57
    111a:	5e e8       	ldi	r21, 0x8E	; 142
    111c:	63 e6       	ldi	r22, 0x63	; 99
    111e:	7d e3       	ldi	r23, 0x3D	; 61
    1120:	4e 83       	std	Y+6, r20	; 0x06
    1122:	5f 83       	std	Y+7, r21	; 0x07
    1124:	68 87       	std	Y+8, r22	; 0x08
    1126:	79 87       	std	Y+9, r23	; 0x09
	
	/* This value is the lowest duty cycle percentage needed to make motor turn. */
	startpercent_ = 2.5;
    1128:	40 e0       	ldi	r20, 0x00	; 0
    112a:	50 e0       	ldi	r21, 0x00	; 0
    112c:	60 e2       	ldi	r22, 0x20	; 32
    112e:	70 e4       	ldi	r23, 0x40	; 64
    1130:	4a 8b       	std	Y+18, r20	; 0x12
    1132:	5b 8b       	std	Y+19, r21	; 0x13
    1134:	6c 8b       	std	Y+20, r22	; 0x14
    1136:	7d 8b       	std	Y+21, r23	; 0x15
		
	/* This value is the delay on motor. A lower value makes motors go faster and higher value makes motors go slower. Value is in MS */
	delay_ = 5;
    1138:	25 e0       	ldi	r18, 0x05	; 5
    113a:	30 e0       	ldi	r19, 0x00	; 0
    113c:	38 8f       	std	Y+24, r19	; 0x18
    113e:	2f 8b       	std	Y+23, r18	; 0x17
	
	/* This value is the maximum number of degrees the motor can turn */
	maxDegrees_ = 180;
    1140:	24 eb       	ldi	r18, 0xB4	; 180
    1142:	2e 8b       	std	Y+22, r18	; 0x16
	*/
	virtual void SetDegrees( uint8_t degrees )
	{
		if ( maxDegrees_ >= degrees )
		{
			percent_ = percentPrDeg * degrees + startpercent_;
    1144:	40 e0       	ldi	r20, 0x00	; 0
    1146:	50 e0       	ldi	r21, 0x00	; 0
    1148:	60 ef       	ldi	r22, 0xF0	; 240
    114a:	70 e4       	ldi	r23, 0x40	; 64
    114c:	4a 87       	std	Y+10, r20	; 0x0a
    114e:	5b 87       	std	Y+11, r21	; 0x0b
    1150:	6c 87       	std	Y+12, r22	; 0x0c
    1152:	7d 87       	std	Y+13, r23	; 0x0d
	
	/* Set motor to default startup value */
	SetDegrees( 90 );
	tmr3Ptr_->setDutyCycleComA( percent_ );
    1154:	16 d2       	rcall	.+1068   	; 0x1582 <_ZN6Timer516setDutyCycleComAEf>
	oldPercent_ = percent_;
    1156:	8a 85       	ldd	r24, Y+10	; 0x0a
    1158:	9b 85       	ldd	r25, Y+11	; 0x0b
    115a:	ac 85       	ldd	r26, Y+12	; 0x0c
    115c:	bd 85       	ldd	r27, Y+13	; 0x0d
    115e:	8e 87       	std	Y+14, r24	; 0x0e
    1160:	9f 87       	std	Y+15, r25	; 0x0f
    1162:	a8 8b       	std	Y+16, r26	; 0x10
    1164:	b9 8b       	std	Y+17, r27	; 0x11
}
    1166:	df 91       	pop	r29
    1168:	cf 91       	pop	r28
    116a:	08 95       	ret

0000116c <_ZN2M5D1Ev>:

class Motor
{
//functions
public:
	virtual ~Motor() {};
    116c:	28 e3       	ldi	r18, 0x38	; 56
    116e:	32 e0       	ldi	r19, 0x02	; 2
    1170:	fc 01       	movw	r30, r24
    1172:	31 83       	std	Z+1, r19	; 0x01
    1174:	20 83       	st	Z, r18
    1176:	08 95       	ret

00001178 <_ZN2M5D0Ev>:
	SetDegrees( 0 );
	tmr3Ptr_->setDutyCycleComB( percent_ );
	oldPercent_ = percent_;
}

M5::~M5()
    1178:	cf 93       	push	r28
    117a:	df 93       	push	r29
    117c:	ec 01       	movw	r28, r24
{
}
    117e:	f6 df       	rcall	.-20     	; 0x116c <_ZN2M5D1Ev>
    1180:	ce 01       	movw	r24, r28
    1182:	0e db       	rcall	.-2532   	; 0x7a0 <_ZdlPv>
    1184:	df 91       	pop	r29
    1186:	cf 91       	pop	r28
    1188:	08 95       	ret

0000118a <_ZN2M59TurnMotorEv>:

void M5::TurnMotor()
{
    118a:	4f 92       	push	r4
    118c:	5f 92       	push	r5
    118e:	6f 92       	push	r6
    1190:	7f 92       	push	r7
    1192:	8f 92       	push	r8
    1194:	9f 92       	push	r9
    1196:	af 92       	push	r10
    1198:	bf 92       	push	r11
    119a:	cf 92       	push	r12
    119c:	df 92       	push	r13
    119e:	ef 92       	push	r14
    11a0:	ff 92       	push	r15
    11a2:	cf 93       	push	r28
    11a4:	df 93       	push	r29
    11a6:	ec 01       	movw	r28, r24
	if ( percent_ > oldPercent_ + PERCENT_PR_TICK )
    11a8:	8a 84       	ldd	r8, Y+10	; 0x0a
    11aa:	9b 84       	ldd	r9, Y+11	; 0x0b
    11ac:	ac 84       	ldd	r10, Y+12	; 0x0c
    11ae:	bd 84       	ldd	r11, Y+13	; 0x0d
    11b0:	ce 84       	ldd	r12, Y+14	; 0x0e
    11b2:	df 84       	ldd	r13, Y+15	; 0x0f
    11b4:	e8 88       	ldd	r14, Y+16	; 0x10
    11b6:	f9 88       	ldd	r15, Y+17	; 0x11
    11b8:	20 e0       	ldi	r18, 0x00	; 0
    11ba:	30 e0       	ldi	r19, 0x00	; 0
    11bc:	40 e8       	ldi	r20, 0x80	; 128
    11be:	5d e3       	ldi	r21, 0x3D	; 61
    11c0:	c7 01       	movw	r24, r14
    11c2:	b6 01       	movw	r22, r12
    11c4:	0e 94 84 13 	call	0x2708	; 0x2708 <__addsf3>
    11c8:	2b 01       	movw	r4, r22
    11ca:	3c 01       	movw	r6, r24
    11cc:	9b 01       	movw	r18, r22
    11ce:	ac 01       	movw	r20, r24
    11d0:	c5 01       	movw	r24, r10
    11d2:	b4 01       	movw	r22, r8
    11d4:	0e 94 32 15 	call	0x2a64	; 0x2a64 <__gesf2>
    11d8:	18 16       	cp	r1, r24
    11da:	6c f4       	brge	.+26     	; 0x11f6 <_ZN2M59TurnMotorEv+0x6c>
	{
		oldPercent_ += PERCENT_PR_TICK;
    11dc:	4e 86       	std	Y+14, r4	; 0x0e
    11de:	5f 86       	std	Y+15, r5	; 0x0f
    11e0:	68 8a       	std	Y+16, r6	; 0x10
    11e2:	79 8a       	std	Y+17, r7	; 0x11
		tmr3Ptr_->setDutyCycleComB( oldPercent_ );
    11e4:	b3 01       	movw	r22, r6
    11e6:	a2 01       	movw	r20, r4
    11e8:	8c 81       	ldd	r24, Y+4	; 0x04
    11ea:	9d 81       	ldd	r25, Y+5	; 0x05
    11ec:	f5 d1       	rcall	.+1002   	; 0x15d8 <_ZN6Timer516setDutyCycleComBEf>
		vTaskDelay( delay_ / portTICK_RATE_MS );
    11ee:	8f 89       	ldd	r24, Y+23	; 0x17
    11f0:	98 8d       	ldd	r25, Y+24	; 0x18
    11f2:	1f d7       	rcall	.+3646   	; 0x2032 <vTaskDelay>
    11f4:	1c c0       	rjmp	.+56     	; 0x122e <_ZN2M59TurnMotorEv+0xa4>
	}
	else if ( percent_ < oldPercent_ )
    11f6:	a7 01       	movw	r20, r14
    11f8:	96 01       	movw	r18, r12
    11fa:	c5 01       	movw	r24, r10
    11fc:	b4 01       	movw	r22, r8
    11fe:	0e 94 e8 13 	call	0x27d0	; 0x27d0 <__cmpsf2>
    1202:	88 23       	and	r24, r24
    1204:	a4 f4       	brge	.+40     	; 0x122e <_ZN2M59TurnMotorEv+0xa4>
	{
		oldPercent_ -= PERCENT_PR_TICK;
    1206:	20 e0       	ldi	r18, 0x00	; 0
    1208:	30 e0       	ldi	r19, 0x00	; 0
    120a:	40 e8       	ldi	r20, 0x80	; 128
    120c:	5d e3       	ldi	r21, 0x3D	; 61
    120e:	c7 01       	movw	r24, r14
    1210:	b6 01       	movw	r22, r12
    1212:	0e 94 83 13 	call	0x2706	; 0x2706 <__subsf3>
    1216:	ab 01       	movw	r20, r22
    1218:	bc 01       	movw	r22, r24
    121a:	4e 87       	std	Y+14, r20	; 0x0e
    121c:	5f 87       	std	Y+15, r21	; 0x0f
    121e:	68 8b       	std	Y+16, r22	; 0x10
    1220:	79 8b       	std	Y+17, r23	; 0x11
		tmr3Ptr_->setDutyCycleComB( oldPercent_ );
    1222:	8c 81       	ldd	r24, Y+4	; 0x04
    1224:	9d 81       	ldd	r25, Y+5	; 0x05
    1226:	d8 d1       	rcall	.+944    	; 0x15d8 <_ZN6Timer516setDutyCycleComBEf>
		vTaskDelay( delay_ / portTICK_RATE_MS );
    1228:	8f 89       	ldd	r24, Y+23	; 0x17
    122a:	98 8d       	ldd	r25, Y+24	; 0x18
    122c:	02 d7       	rcall	.+3588   	; 0x2032 <vTaskDelay>
    122e:	df 91       	pop	r29
	}
}
    1230:	cf 91       	pop	r28
    1232:	ff 90       	pop	r15
    1234:	ef 90       	pop	r14
    1236:	df 90       	pop	r13
    1238:	cf 90       	pop	r12
    123a:	bf 90       	pop	r11
    123c:	af 90       	pop	r10
    123e:	9f 90       	pop	r9
    1240:	8f 90       	pop	r8
    1242:	7f 90       	pop	r7
    1244:	6f 90       	pop	r6
    1246:	5f 90       	pop	r5
    1248:	4f 90       	pop	r4
    124a:	08 95       	ret

0000124c <_ZN2M5C1EP6Timer5>:
    124c:	cf 93       	push	r28
* Author: jespe
*/

#include "M5.h"

M5::M5( Timer5* tmr )
    124e:	df 93       	push	r29
    1250:	ec 01       	movw	r28, r24
    1252:	cb 01       	movw	r24, r22
    1254:	24 e7       	ldi	r18, 0x74	; 116
    1256:	32 e0       	ldi	r19, 0x02	; 2
    1258:	39 83       	std	Y+1, r19	; 0x01
    125a:	28 83       	st	Y, r18
{
	/* Store timer pointer */
	tmr3Ptr_ = tmr;
    125c:	7d 83       	std	Y+5, r23	; 0x05
    125e:	6c 83       	std	Y+4, r22	; 0x04
	
	/* This value is number of percent to add or subtract pr degree. */
	percentPrDeg = 0.0555555555555556;
    1260:	49 e3       	ldi	r20, 0x39	; 57
    1262:	5e e8       	ldi	r21, 0x8E	; 142
    1264:	63 e6       	ldi	r22, 0x63	; 99
    1266:	7d e3       	ldi	r23, 0x3D	; 61
    1268:	4e 83       	std	Y+6, r20	; 0x06
    126a:	5f 83       	std	Y+7, r21	; 0x07
    126c:	68 87       	std	Y+8, r22	; 0x08
    126e:	79 87       	std	Y+9, r23	; 0x09
	
	/* This value is the lowest duty cycle percentage needed to make motor turn. */
	startpercent_ = 2.5;
    1270:	40 e0       	ldi	r20, 0x00	; 0
    1272:	50 e0       	ldi	r21, 0x00	; 0
    1274:	60 e2       	ldi	r22, 0x20	; 32
    1276:	70 e4       	ldi	r23, 0x40	; 64
    1278:	4a 8b       	std	Y+18, r20	; 0x12
    127a:	5b 8b       	std	Y+19, r21	; 0x13
    127c:	6c 8b       	std	Y+20, r22	; 0x14
    127e:	7d 8b       	std	Y+21, r23	; 0x15
	
	/* This value is the delay on motor. A lower value makes motors go faster and higher value makes motors go slower. Value is in MS */
	delay_ = 1;
    1280:	21 e0       	ldi	r18, 0x01	; 1
    1282:	30 e0       	ldi	r19, 0x00	; 0
    1284:	38 8f       	std	Y+24, r19	; 0x18
    1286:	2f 8b       	std	Y+23, r18	; 0x17
	
	/* This value is the maximum number of degrees the motor can turn */
	maxDegrees_ = 180;
    1288:	24 eb       	ldi	r18, 0xB4	; 180
    128a:	2e 8b       	std	Y+22, r18	; 0x16
	*/
	virtual void SetDegrees( uint8_t degrees )
	{
		if ( maxDegrees_ >= degrees )
		{
			percent_ = percentPrDeg * degrees + startpercent_;
    128c:	4a 87       	std	Y+10, r20	; 0x0a
    128e:	5b 87       	std	Y+11, r21	; 0x0b
    1290:	6c 87       	std	Y+12, r22	; 0x0c
    1292:	7d 87       	std	Y+13, r23	; 0x0d
	
	/* Set motor to default startup value */
	SetDegrees( 0 );
	tmr3Ptr_->setDutyCycleComB( percent_ );
    1294:	a1 d1       	rcall	.+834    	; 0x15d8 <_ZN6Timer516setDutyCycleComBEf>
	oldPercent_ = percent_;
    1296:	8a 85       	ldd	r24, Y+10	; 0x0a
    1298:	9b 85       	ldd	r25, Y+11	; 0x0b
    129a:	ac 85       	ldd	r26, Y+12	; 0x0c
    129c:	bd 85       	ldd	r27, Y+13	; 0x0d
    129e:	8e 87       	std	Y+14, r24	; 0x0e
    12a0:	9f 87       	std	Y+15, r25	; 0x0f
    12a2:	a8 8b       	std	Y+16, r26	; 0x10
    12a4:	b9 8b       	std	Y+17, r27	; 0x11
}
    12a6:	df 91       	pop	r29
    12a8:	cf 91       	pop	r28
    12aa:	08 95       	ret

000012ac <_ZN2M6D1Ev>:

class Motor
{
//functions
public:
	virtual ~Motor() {};
    12ac:	28 e3       	ldi	r18, 0x38	; 56
    12ae:	32 e0       	ldi	r19, 0x02	; 2
    12b0:	fc 01       	movw	r30, r24
    12b2:	31 83       	std	Z+1, r19	; 0x01
    12b4:	20 83       	st	Z, r18
    12b6:	08 95       	ret

000012b8 <_ZN2M6D0Ev>:
	SetDegrees( 0 );
	tmr3Ptr_->setDutyCycleComC( percent_ );
	oldPercent_ = percent_;
}

M6::~M6()
    12b8:	cf 93       	push	r28
    12ba:	df 93       	push	r29
    12bc:	ec 01       	movw	r28, r24
{
}
    12be:	f6 df       	rcall	.-20     	; 0x12ac <_ZN2M6D1Ev>
    12c0:	ce 01       	movw	r24, r28
    12c2:	6e da       	rcall	.-2852   	; 0x7a0 <_ZdlPv>
    12c4:	df 91       	pop	r29
    12c6:	cf 91       	pop	r28
    12c8:	08 95       	ret

000012ca <_ZN2M69TurnMotorEv>:

void M6::TurnMotor()
{
    12ca:	4f 92       	push	r4
    12cc:	5f 92       	push	r5
    12ce:	6f 92       	push	r6
    12d0:	7f 92       	push	r7
    12d2:	8f 92       	push	r8
    12d4:	9f 92       	push	r9
    12d6:	af 92       	push	r10
    12d8:	bf 92       	push	r11
    12da:	cf 92       	push	r12
    12dc:	df 92       	push	r13
    12de:	ef 92       	push	r14
    12e0:	ff 92       	push	r15
    12e2:	cf 93       	push	r28
    12e4:	df 93       	push	r29
    12e6:	ec 01       	movw	r28, r24
	if ( percent_ > oldPercent_ + PERCENT_PR_TICK )
    12e8:	8a 84       	ldd	r8, Y+10	; 0x0a
    12ea:	9b 84       	ldd	r9, Y+11	; 0x0b
    12ec:	ac 84       	ldd	r10, Y+12	; 0x0c
    12ee:	bd 84       	ldd	r11, Y+13	; 0x0d
    12f0:	ce 84       	ldd	r12, Y+14	; 0x0e
    12f2:	df 84       	ldd	r13, Y+15	; 0x0f
    12f4:	e8 88       	ldd	r14, Y+16	; 0x10
    12f6:	f9 88       	ldd	r15, Y+17	; 0x11
    12f8:	20 e0       	ldi	r18, 0x00	; 0
    12fa:	30 e0       	ldi	r19, 0x00	; 0
    12fc:	40 e8       	ldi	r20, 0x80	; 128
    12fe:	5d e3       	ldi	r21, 0x3D	; 61
    1300:	c7 01       	movw	r24, r14
    1302:	b6 01       	movw	r22, r12
    1304:	0e 94 84 13 	call	0x2708	; 0x2708 <__addsf3>
    1308:	2b 01       	movw	r4, r22
    130a:	3c 01       	movw	r6, r24
    130c:	9b 01       	movw	r18, r22
    130e:	ac 01       	movw	r20, r24
    1310:	c5 01       	movw	r24, r10
    1312:	b4 01       	movw	r22, r8
    1314:	0e 94 32 15 	call	0x2a64	; 0x2a64 <__gesf2>
    1318:	18 16       	cp	r1, r24
    131a:	6c f4       	brge	.+26     	; 0x1336 <_ZN2M69TurnMotorEv+0x6c>
	{
		oldPercent_ += 0.0625;
    131c:	4e 86       	std	Y+14, r4	; 0x0e
    131e:	5f 86       	std	Y+15, r5	; 0x0f
    1320:	68 8a       	std	Y+16, r6	; 0x10
    1322:	79 8a       	std	Y+17, r7	; 0x11
		tmr3Ptr_->setDutyCycleComC( oldPercent_ );
    1324:	b3 01       	movw	r22, r6
    1326:	a2 01       	movw	r20, r4
    1328:	8c 81       	ldd	r24, Y+4	; 0x04
    132a:	9d 81       	ldd	r25, Y+5	; 0x05
    132c:	80 d1       	rcall	.+768    	; 0x162e <_ZN6Timer516setDutyCycleComCEf>
		vTaskDelay( delay_ / portTICK_RATE_MS );
    132e:	8f 89       	ldd	r24, Y+23	; 0x17
    1330:	98 8d       	ldd	r25, Y+24	; 0x18
    1332:	7f d6       	rcall	.+3326   	; 0x2032 <vTaskDelay>
    1334:	1c c0       	rjmp	.+56     	; 0x136e <_ZN2M69TurnMotorEv+0xa4>
	}
	else if ( percent_ < oldPercent_ )
    1336:	a7 01       	movw	r20, r14
    1338:	96 01       	movw	r18, r12
    133a:	c5 01       	movw	r24, r10
    133c:	b4 01       	movw	r22, r8
    133e:	0e 94 e8 13 	call	0x27d0	; 0x27d0 <__cmpsf2>
    1342:	88 23       	and	r24, r24
    1344:	a4 f4       	brge	.+40     	; 0x136e <_ZN2M69TurnMotorEv+0xa4>
	{
		oldPercent_ -= 0.0625;
    1346:	20 e0       	ldi	r18, 0x00	; 0
    1348:	30 e0       	ldi	r19, 0x00	; 0
    134a:	40 e8       	ldi	r20, 0x80	; 128
    134c:	5d e3       	ldi	r21, 0x3D	; 61
    134e:	c7 01       	movw	r24, r14
    1350:	b6 01       	movw	r22, r12
    1352:	0e 94 83 13 	call	0x2706	; 0x2706 <__subsf3>
    1356:	ab 01       	movw	r20, r22
    1358:	bc 01       	movw	r22, r24
    135a:	4e 87       	std	Y+14, r20	; 0x0e
    135c:	5f 87       	std	Y+15, r21	; 0x0f
    135e:	68 8b       	std	Y+16, r22	; 0x10
    1360:	79 8b       	std	Y+17, r23	; 0x11
		tmr3Ptr_->setDutyCycleComC( oldPercent_ );
    1362:	8c 81       	ldd	r24, Y+4	; 0x04
    1364:	9d 81       	ldd	r25, Y+5	; 0x05
    1366:	63 d1       	rcall	.+710    	; 0x162e <_ZN6Timer516setDutyCycleComCEf>
		vTaskDelay( delay_ / portTICK_RATE_MS );
    1368:	8f 89       	ldd	r24, Y+23	; 0x17
    136a:	98 8d       	ldd	r25, Y+24	; 0x18
    136c:	62 d6       	rcall	.+3268   	; 0x2032 <vTaskDelay>
    136e:	df 91       	pop	r29
	}
}
    1370:	cf 91       	pop	r28
    1372:	ff 90       	pop	r15
    1374:	ef 90       	pop	r14
    1376:	df 90       	pop	r13
    1378:	cf 90       	pop	r12
    137a:	bf 90       	pop	r11
    137c:	af 90       	pop	r10
    137e:	9f 90       	pop	r9
    1380:	8f 90       	pop	r8
    1382:	7f 90       	pop	r7
    1384:	6f 90       	pop	r6
    1386:	5f 90       	pop	r5
    1388:	4f 90       	pop	r4
    138a:	08 95       	ret

0000138c <_ZN2M6C1EP6Timer5>:
    138c:	cf 93       	push	r28
* Author: jespe
*/

#include "M6.h"

M6::M6( Timer5* tmr )
    138e:	df 93       	push	r29
    1390:	ec 01       	movw	r28, r24
    1392:	cb 01       	movw	r24, r22
    1394:	20 e8       	ldi	r18, 0x80	; 128
    1396:	32 e0       	ldi	r19, 0x02	; 2
    1398:	39 83       	std	Y+1, r19	; 0x01
    139a:	28 83       	st	Y, r18
{
	/* Store timer pointer */
	tmr3Ptr_ = tmr;
    139c:	7d 83       	std	Y+5, r23	; 0x05
    139e:	6c 83       	std	Y+4, r22	; 0x04
	
	/* This value is number of percent to add or subtract pr degree. */
	percentPrDeg = 0.07936507936507;
    13a0:	49 e2       	ldi	r20, 0x29	; 41
    13a2:	5a e8       	ldi	r21, 0x8A	; 138
    13a4:	62 ea       	ldi	r22, 0xA2	; 162
    13a6:	7d e3       	ldi	r23, 0x3D	; 61
    13a8:	4e 83       	std	Y+6, r20	; 0x06
    13aa:	5f 83       	std	Y+7, r21	; 0x07
    13ac:	68 87       	std	Y+8, r22	; 0x08
    13ae:	79 87       	std	Y+9, r23	; 0x09
	
	/* This value is the lowest duty cycle percentage needed to make motor turn. */
	startpercent_ = 2.5;
    13b0:	40 e0       	ldi	r20, 0x00	; 0
    13b2:	50 e0       	ldi	r21, 0x00	; 0
    13b4:	60 e2       	ldi	r22, 0x20	; 32
    13b6:	70 e4       	ldi	r23, 0x40	; 64
    13b8:	4a 8b       	std	Y+18, r20	; 0x12
    13ba:	5b 8b       	std	Y+19, r21	; 0x13
    13bc:	6c 8b       	std	Y+20, r22	; 0x14
    13be:	7d 8b       	std	Y+21, r23	; 0x15
	
	/* This value is the delay on motor. A lower value makes motors go faster and higher value makes motors go slower. Value is in MS */
	delay_ = 1;
    13c0:	21 e0       	ldi	r18, 0x01	; 1
    13c2:	30 e0       	ldi	r19, 0x00	; 0
    13c4:	38 8f       	std	Y+24, r19	; 0x18
    13c6:	2f 8b       	std	Y+23, r18	; 0x17
	
	/* This value is the maximum number of degrees the motor can turn */
	maxDegrees_ = 63;
    13c8:	2f e3       	ldi	r18, 0x3F	; 63
    13ca:	2e 8b       	std	Y+22, r18	; 0x16
	*/
	virtual void SetDegrees( uint8_t degrees )
	{
		if ( maxDegrees_ >= degrees )
		{
			percent_ = percentPrDeg * degrees + startpercent_;
    13cc:	4a 87       	std	Y+10, r20	; 0x0a
    13ce:	5b 87       	std	Y+11, r21	; 0x0b
    13d0:	6c 87       	std	Y+12, r22	; 0x0c
    13d2:	7d 87       	std	Y+13, r23	; 0x0d
	
	/* Set motor to default startup value */
	SetDegrees( 0 );
	tmr3Ptr_->setDutyCycleComC( percent_ );
    13d4:	2c d1       	rcall	.+600    	; 0x162e <_ZN6Timer516setDutyCycleComCEf>
	oldPercent_ = percent_;
    13d6:	8a 85       	ldd	r24, Y+10	; 0x0a
    13d8:	9b 85       	ldd	r25, Y+11	; 0x0b
    13da:	ac 85       	ldd	r26, Y+12	; 0x0c
    13dc:	bd 85       	ldd	r27, Y+13	; 0x0d
    13de:	8e 87       	std	Y+14, r24	; 0x0e
    13e0:	9f 87       	std	Y+15, r25	; 0x0f
    13e2:	a8 8b       	std	Y+16, r26	; 0x10
    13e4:	b9 8b       	std	Y+17, r27	; 0x11
}
    13e6:	df 91       	pop	r29
    13e8:	cf 91       	pop	r28
    13ea:	08 95       	ret

000013ec <_ZN6Timer1C1Ev>:
#include <avr/io.h>

Timer1::Timer1()
{
	// Set all needed ports to outputs
	ROBOTARM_M1_OUT_PORT |= ( 1 << ROBOTARM_M1_OUT_PIN );
    13ec:	84 b1       	in	r24, 0x04	; 4
    13ee:	80 62       	ori	r24, 0x20	; 32
    13f0:	84 b9       	out	0x04, r24	; 4
	ROBOTARM_M2_OUT_PORT |= ( 1 << ROBOTARM_M2_OUT_PIN );
    13f2:	84 b1       	in	r24, 0x04	; 4
    13f4:	80 64       	ori	r24, 0x40	; 64
    13f6:	84 b9       	out	0x04, r24	; 4
	ROBOTARM_M3_OUT_PORT |= ( 1 << ROBOTARM_M3_OUT_PIN );
    13f8:	84 b1       	in	r24, 0x04	; 4
    13fa:	80 68       	ori	r24, 0x80	; 128
    13fc:	84 b9       	out	0x04, r24	; 4
		
	// Set timer to run in PWM, Phase Correct mode with 50 Hz freq. 
	TCCR1A = ( 1 << COM1A1 ) | ( 1 << COM1B1 ) | ( 1 << COM1C1 ) | ( 0 << WGM10 ) | ( 0 << WGM11 );
    13fe:	88 ea       	ldi	r24, 0xA8	; 168
    1400:	80 93 80 00 	sts	0x0080, r24	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
	TCCR1B = ( 1 << WGM13 ) | ( 0 << CS10 )  | ( 1 << CS12 );
    1404:	84 e1       	ldi	r24, 0x14	; 20
    1406:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x700081>
	TCCR1C = 0;
    140a:	10 92 82 00 	sts	0x0082, r1	; 0x800082 <__TEXT_REGION_LENGTH__+0x700082>
	ICR1 = 622;
    140e:	8e e6       	ldi	r24, 0x6E	; 110
    1410:	92 e0       	ldi	r25, 0x02	; 2
    1412:	90 93 87 00 	sts	0x0087, r25	; 0x800087 <__TEXT_REGION_LENGTH__+0x700087>
    1416:	80 93 86 00 	sts	0x0086, r24	; 0x800086 <__TEXT_REGION_LENGTH__+0x700086>
	
	OCR1A = 0;
    141a:	10 92 89 00 	sts	0x0089, r1	; 0x800089 <__TEXT_REGION_LENGTH__+0x700089>
    141e:	10 92 88 00 	sts	0x0088, r1	; 0x800088 <__TEXT_REGION_LENGTH__+0x700088>
	OCR1B = 0;
    1422:	10 92 8b 00 	sts	0x008B, r1	; 0x80008b <__TEXT_REGION_LENGTH__+0x70008b>
    1426:	10 92 8a 00 	sts	0x008A, r1	; 0x80008a <__TEXT_REGION_LENGTH__+0x70008a>
	OCR1C = 0;
    142a:	10 92 8d 00 	sts	0x008D, r1	; 0x80008d <__TEXT_REGION_LENGTH__+0x70008d>
    142e:	10 92 8c 00 	sts	0x008C, r1	; 0x80008c <__TEXT_REGION_LENGTH__+0x70008c>
    1432:	08 95       	ret

00001434 <_ZN6Timer116setDutyCycleComAEf>:
}

void Timer1::setDutyCycleComA( float dutyCycle )
{
    1434:	cf 92       	push	r12
    1436:	df 92       	push	r13
    1438:	ef 92       	push	r14
    143a:	ff 92       	push	r15
    143c:	6a 01       	movw	r12, r20
    143e:	7b 01       	movw	r14, r22
	float percent = ICR1/100;
    1440:	20 91 86 00 	lds	r18, 0x0086	; 0x800086 <__TEXT_REGION_LENGTH__+0x700086>
    1444:	30 91 87 00 	lds	r19, 0x0087	; 0x800087 <__TEXT_REGION_LENGTH__+0x700087>
    1448:	36 95       	lsr	r19
    144a:	27 95       	ror	r18
    144c:	36 95       	lsr	r19
    144e:	27 95       	ror	r18
    1450:	ab e7       	ldi	r26, 0x7B	; 123
    1452:	b4 e1       	ldi	r27, 0x14	; 20
    1454:	0e 94 a1 15 	call	0x2b42	; 0x2b42 <__umulhisi3>
    1458:	96 95       	lsr	r25
    145a:	87 95       	ror	r24
	OCR1A = (uint8_t)percent*dutyCycle;
    145c:	bc 01       	movw	r22, r24
    145e:	77 27       	eor	r23, r23
    1460:	07 2e       	mov	r0, r23
    1462:	00 0c       	add	r0, r0
    1464:	88 0b       	sbc	r24, r24
    1466:	99 0b       	sbc	r25, r25
    1468:	0e 94 82 14 	call	0x2904	; 0x2904 <__floatsisf>
    146c:	a7 01       	movw	r20, r14
    146e:	96 01       	movw	r18, r12
    1470:	0e 94 36 15 	call	0x2a6c	; 0x2a6c <__mulsf3>
    1474:	0e 94 54 14 	call	0x28a8	; 0x28a8 <__fixunssfsi>
    1478:	70 93 89 00 	sts	0x0089, r23	; 0x800089 <__TEXT_REGION_LENGTH__+0x700089>
    147c:	60 93 88 00 	sts	0x0088, r22	; 0x800088 <__TEXT_REGION_LENGTH__+0x700088>
}
    1480:	ff 90       	pop	r15
    1482:	ef 90       	pop	r14
    1484:	df 90       	pop	r13
    1486:	cf 90       	pop	r12
    1488:	08 95       	ret

0000148a <_ZN6Timer116setDutyCycleComBEf>:

void Timer1::setDutyCycleComB( float dutyCycle )
{
    148a:	cf 92       	push	r12
    148c:	df 92       	push	r13
    148e:	ef 92       	push	r14
    1490:	ff 92       	push	r15
    1492:	6a 01       	movw	r12, r20
    1494:	7b 01       	movw	r14, r22
	float percent = ICR1/100;
    1496:	20 91 86 00 	lds	r18, 0x0086	; 0x800086 <__TEXT_REGION_LENGTH__+0x700086>
    149a:	30 91 87 00 	lds	r19, 0x0087	; 0x800087 <__TEXT_REGION_LENGTH__+0x700087>
    149e:	36 95       	lsr	r19
    14a0:	27 95       	ror	r18
    14a2:	36 95       	lsr	r19
    14a4:	27 95       	ror	r18
    14a6:	ab e7       	ldi	r26, 0x7B	; 123
    14a8:	b4 e1       	ldi	r27, 0x14	; 20
    14aa:	0e 94 a1 15 	call	0x2b42	; 0x2b42 <__umulhisi3>
    14ae:	96 95       	lsr	r25
    14b0:	87 95       	ror	r24
	OCR1B = (uint8_t)percent*dutyCycle;
    14b2:	bc 01       	movw	r22, r24
    14b4:	77 27       	eor	r23, r23
    14b6:	07 2e       	mov	r0, r23
    14b8:	00 0c       	add	r0, r0
    14ba:	88 0b       	sbc	r24, r24
    14bc:	99 0b       	sbc	r25, r25
    14be:	0e 94 82 14 	call	0x2904	; 0x2904 <__floatsisf>
    14c2:	a7 01       	movw	r20, r14
    14c4:	96 01       	movw	r18, r12
    14c6:	0e 94 36 15 	call	0x2a6c	; 0x2a6c <__mulsf3>
    14ca:	0e 94 54 14 	call	0x28a8	; 0x28a8 <__fixunssfsi>
    14ce:	70 93 8b 00 	sts	0x008B, r23	; 0x80008b <__TEXT_REGION_LENGTH__+0x70008b>
    14d2:	60 93 8a 00 	sts	0x008A, r22	; 0x80008a <__TEXT_REGION_LENGTH__+0x70008a>
}
    14d6:	ff 90       	pop	r15
    14d8:	ef 90       	pop	r14
    14da:	df 90       	pop	r13
    14dc:	cf 90       	pop	r12
    14de:	08 95       	ret

000014e0 <_ZN6Timer116setDutyCycleComCEf>:

void Timer1::setDutyCycleComC( float dutyCycle )
{
    14e0:	cf 92       	push	r12
    14e2:	df 92       	push	r13
    14e4:	ef 92       	push	r14
    14e6:	ff 92       	push	r15
    14e8:	6a 01       	movw	r12, r20
    14ea:	7b 01       	movw	r14, r22
	float percent = ICR1/100;
    14ec:	20 91 86 00 	lds	r18, 0x0086	; 0x800086 <__TEXT_REGION_LENGTH__+0x700086>
    14f0:	30 91 87 00 	lds	r19, 0x0087	; 0x800087 <__TEXT_REGION_LENGTH__+0x700087>
    14f4:	36 95       	lsr	r19
    14f6:	27 95       	ror	r18
    14f8:	36 95       	lsr	r19
    14fa:	27 95       	ror	r18
    14fc:	ab e7       	ldi	r26, 0x7B	; 123
    14fe:	b4 e1       	ldi	r27, 0x14	; 20
    1500:	0e 94 a1 15 	call	0x2b42	; 0x2b42 <__umulhisi3>
    1504:	96 95       	lsr	r25
    1506:	87 95       	ror	r24
	OCR1C = (uint8_t)percent*dutyCycle;
    1508:	bc 01       	movw	r22, r24
    150a:	77 27       	eor	r23, r23
    150c:	07 2e       	mov	r0, r23
    150e:	00 0c       	add	r0, r0
    1510:	88 0b       	sbc	r24, r24
    1512:	99 0b       	sbc	r25, r25
    1514:	0e 94 82 14 	call	0x2904	; 0x2904 <__floatsisf>
    1518:	a7 01       	movw	r20, r14
    151a:	96 01       	movw	r18, r12
    151c:	0e 94 36 15 	call	0x2a6c	; 0x2a6c <__mulsf3>
    1520:	0e 94 54 14 	call	0x28a8	; 0x28a8 <__fixunssfsi>
    1524:	70 93 8d 00 	sts	0x008D, r23	; 0x80008d <__TEXT_REGION_LENGTH__+0x70008d>
    1528:	60 93 8c 00 	sts	0x008C, r22	; 0x80008c <__TEXT_REGION_LENGTH__+0x70008c>
    152c:	ff 90       	pop	r15
    152e:	ef 90       	pop	r14
    1530:	df 90       	pop	r13
    1532:	cf 90       	pop	r12
    1534:	08 95       	ret

00001536 <_ZN6Timer5C1Ev>:
#include <avr/io.h>

Timer5::Timer5()
{
	// Set all needed ports to outputs
	ROBOTARM_M4_OUT_PORT |= ( 1 << ROBOTARM_M4_OUT_PIN );
    1536:	ea e0       	ldi	r30, 0x0A	; 10
    1538:	f1 e0       	ldi	r31, 0x01	; 1
    153a:	80 81       	ld	r24, Z
    153c:	88 60       	ori	r24, 0x08	; 8
    153e:	80 83       	st	Z, r24
	ROBOTARM_M5_OUT_PORT |= ( 1 << ROBOTARM_M5_OUT_PIN );
    1540:	80 81       	ld	r24, Z
    1542:	80 61       	ori	r24, 0x10	; 16
    1544:	80 83       	st	Z, r24
	ROBOTARM_M6_OUT_PORT |= ( 1 << ROBOTARM_M6_OUT_PIN );
    1546:	80 81       	ld	r24, Z
    1548:	80 62       	ori	r24, 0x20	; 32
    154a:	80 83       	st	Z, r24
	
	// Set timer to run in PWM, Phase Correct mode with 50 Hz freq.
	TCCR5A = ( 1 << COM3A1 ) | ( 1 << COM3B1 ) | ( 1 << COM3C1 ) | ( 0 << WGM30 ) | ( 0 << WGM31 );
    154c:	88 ea       	ldi	r24, 0xA8	; 168
    154e:	80 93 20 01 	sts	0x0120, r24	; 0x800120 <__TEXT_REGION_LENGTH__+0x700120>
	TCCR5B = ( 1 << WGM33 ) | ( 0 << CS30 )  | ( 1 << CS32 );
    1552:	84 e1       	ldi	r24, 0x14	; 20
    1554:	80 93 21 01 	sts	0x0121, r24	; 0x800121 <__TEXT_REGION_LENGTH__+0x700121>
	TCCR5C = 0;
    1558:	10 92 22 01 	sts	0x0122, r1	; 0x800122 <__TEXT_REGION_LENGTH__+0x700122>
	ICR5 = 622;
    155c:	8e e6       	ldi	r24, 0x6E	; 110
    155e:	92 e0       	ldi	r25, 0x02	; 2
    1560:	90 93 27 01 	sts	0x0127, r25	; 0x800127 <__TEXT_REGION_LENGTH__+0x700127>
    1564:	80 93 26 01 	sts	0x0126, r24	; 0x800126 <__TEXT_REGION_LENGTH__+0x700126>
	
	OCR5A = 0;
    1568:	10 92 29 01 	sts	0x0129, r1	; 0x800129 <__TEXT_REGION_LENGTH__+0x700129>
    156c:	10 92 28 01 	sts	0x0128, r1	; 0x800128 <__TEXT_REGION_LENGTH__+0x700128>
	OCR5B = 0;
    1570:	10 92 2b 01 	sts	0x012B, r1	; 0x80012b <__TEXT_REGION_LENGTH__+0x70012b>
    1574:	10 92 2a 01 	sts	0x012A, r1	; 0x80012a <__TEXT_REGION_LENGTH__+0x70012a>
	OCR5C = 0;
    1578:	10 92 2d 01 	sts	0x012D, r1	; 0x80012d <__TEXT_REGION_LENGTH__+0x70012d>
    157c:	10 92 2c 01 	sts	0x012C, r1	; 0x80012c <__TEXT_REGION_LENGTH__+0x70012c>
    1580:	08 95       	ret

00001582 <_ZN6Timer516setDutyCycleComAEf>:
}

void Timer5::setDutyCycleComA( float dutyCycle )
{
    1582:	cf 92       	push	r12
    1584:	df 92       	push	r13
    1586:	ef 92       	push	r14
    1588:	ff 92       	push	r15
    158a:	6a 01       	movw	r12, r20
    158c:	7b 01       	movw	r14, r22
	float percent = ICR5/100;
    158e:	20 91 26 01 	lds	r18, 0x0126	; 0x800126 <__TEXT_REGION_LENGTH__+0x700126>
    1592:	30 91 27 01 	lds	r19, 0x0127	; 0x800127 <__TEXT_REGION_LENGTH__+0x700127>
    1596:	36 95       	lsr	r19
    1598:	27 95       	ror	r18
    159a:	36 95       	lsr	r19
    159c:	27 95       	ror	r18
    159e:	ab e7       	ldi	r26, 0x7B	; 123
    15a0:	b4 e1       	ldi	r27, 0x14	; 20
    15a2:	0e 94 a1 15 	call	0x2b42	; 0x2b42 <__umulhisi3>
    15a6:	96 95       	lsr	r25
    15a8:	87 95       	ror	r24
	OCR5A = (uint8_t)percent*dutyCycle;
    15aa:	bc 01       	movw	r22, r24
    15ac:	77 27       	eor	r23, r23
    15ae:	07 2e       	mov	r0, r23
    15b0:	00 0c       	add	r0, r0
    15b2:	88 0b       	sbc	r24, r24
    15b4:	99 0b       	sbc	r25, r25
    15b6:	0e 94 82 14 	call	0x2904	; 0x2904 <__floatsisf>
    15ba:	a7 01       	movw	r20, r14
    15bc:	96 01       	movw	r18, r12
    15be:	0e 94 36 15 	call	0x2a6c	; 0x2a6c <__mulsf3>
    15c2:	0e 94 54 14 	call	0x28a8	; 0x28a8 <__fixunssfsi>
    15c6:	70 93 29 01 	sts	0x0129, r23	; 0x800129 <__TEXT_REGION_LENGTH__+0x700129>
    15ca:	60 93 28 01 	sts	0x0128, r22	; 0x800128 <__TEXT_REGION_LENGTH__+0x700128>
}
    15ce:	ff 90       	pop	r15
    15d0:	ef 90       	pop	r14
    15d2:	df 90       	pop	r13
    15d4:	cf 90       	pop	r12
    15d6:	08 95       	ret

000015d8 <_ZN6Timer516setDutyCycleComBEf>:

void Timer5::setDutyCycleComB( float dutyCycle )
{
    15d8:	cf 92       	push	r12
    15da:	df 92       	push	r13
    15dc:	ef 92       	push	r14
    15de:	ff 92       	push	r15
    15e0:	6a 01       	movw	r12, r20
    15e2:	7b 01       	movw	r14, r22
	float percent = ICR5/100;
    15e4:	20 91 26 01 	lds	r18, 0x0126	; 0x800126 <__TEXT_REGION_LENGTH__+0x700126>
    15e8:	30 91 27 01 	lds	r19, 0x0127	; 0x800127 <__TEXT_REGION_LENGTH__+0x700127>
    15ec:	36 95       	lsr	r19
    15ee:	27 95       	ror	r18
    15f0:	36 95       	lsr	r19
    15f2:	27 95       	ror	r18
    15f4:	ab e7       	ldi	r26, 0x7B	; 123
    15f6:	b4 e1       	ldi	r27, 0x14	; 20
    15f8:	0e 94 a1 15 	call	0x2b42	; 0x2b42 <__umulhisi3>
    15fc:	96 95       	lsr	r25
    15fe:	87 95       	ror	r24
	OCR5B = (uint8_t)percent*dutyCycle;
    1600:	bc 01       	movw	r22, r24
    1602:	77 27       	eor	r23, r23
    1604:	07 2e       	mov	r0, r23
    1606:	00 0c       	add	r0, r0
    1608:	88 0b       	sbc	r24, r24
    160a:	99 0b       	sbc	r25, r25
    160c:	0e 94 82 14 	call	0x2904	; 0x2904 <__floatsisf>
    1610:	a7 01       	movw	r20, r14
    1612:	96 01       	movw	r18, r12
    1614:	0e 94 36 15 	call	0x2a6c	; 0x2a6c <__mulsf3>
    1618:	0e 94 54 14 	call	0x28a8	; 0x28a8 <__fixunssfsi>
    161c:	70 93 2b 01 	sts	0x012B, r23	; 0x80012b <__TEXT_REGION_LENGTH__+0x70012b>
    1620:	60 93 2a 01 	sts	0x012A, r22	; 0x80012a <__TEXT_REGION_LENGTH__+0x70012a>
}
    1624:	ff 90       	pop	r15
    1626:	ef 90       	pop	r14
    1628:	df 90       	pop	r13
    162a:	cf 90       	pop	r12
    162c:	08 95       	ret

0000162e <_ZN6Timer516setDutyCycleComCEf>:

void Timer5::setDutyCycleComC( float dutyCycle )
{
    162e:	cf 92       	push	r12
    1630:	df 92       	push	r13
    1632:	ef 92       	push	r14
    1634:	ff 92       	push	r15
    1636:	6a 01       	movw	r12, r20
    1638:	7b 01       	movw	r14, r22
	float percent = ICR5/100;
    163a:	20 91 26 01 	lds	r18, 0x0126	; 0x800126 <__TEXT_REGION_LENGTH__+0x700126>
    163e:	30 91 27 01 	lds	r19, 0x0127	; 0x800127 <__TEXT_REGION_LENGTH__+0x700127>
    1642:	36 95       	lsr	r19
    1644:	27 95       	ror	r18
    1646:	36 95       	lsr	r19
    1648:	27 95       	ror	r18
    164a:	ab e7       	ldi	r26, 0x7B	; 123
    164c:	b4 e1       	ldi	r27, 0x14	; 20
    164e:	0e 94 a1 15 	call	0x2b42	; 0x2b42 <__umulhisi3>
    1652:	96 95       	lsr	r25
    1654:	87 95       	ror	r24
	OCR5C = (uint8_t)percent*dutyCycle;
    1656:	bc 01       	movw	r22, r24
    1658:	77 27       	eor	r23, r23
    165a:	07 2e       	mov	r0, r23
    165c:	00 0c       	add	r0, r0
    165e:	88 0b       	sbc	r24, r24
    1660:	99 0b       	sbc	r25, r25
    1662:	0e 94 82 14 	call	0x2904	; 0x2904 <__floatsisf>
    1666:	a7 01       	movw	r20, r14
    1668:	96 01       	movw	r18, r12
    166a:	0e 94 36 15 	call	0x2a6c	; 0x2a6c <__mulsf3>
    166e:	0e 94 54 14 	call	0x28a8	; 0x28a8 <__fixunssfsi>
    1672:	70 93 2d 01 	sts	0x012D, r23	; 0x80012d <__TEXT_REGION_LENGTH__+0x70012d>
    1676:	60 93 2c 01 	sts	0x012C, r22	; 0x80012c <__TEXT_REGION_LENGTH__+0x70012c>
    167a:	ff 90       	pop	r15
    167c:	ef 90       	pop	r14
    167e:	df 90       	pop	r13
    1680:	cf 90       	pop	r12
    1682:	08 95       	ret

00001684 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
    1684:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
    1686:	03 96       	adiw	r24, 0x03	; 3
    1688:	92 83       	std	Z+2, r25	; 0x02
    168a:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    168c:	2f ef       	ldi	r18, 0xFF	; 255
    168e:	3f ef       	ldi	r19, 0xFF	; 255
    1690:	34 83       	std	Z+4, r19	; 0x04
    1692:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
    1694:	96 83       	std	Z+6, r25	; 0x06
    1696:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
    1698:	90 87       	std	Z+8, r25	; 0x08
    169a:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
    169c:	10 82       	st	Z, r1
    169e:	08 95       	ret

000016a0 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    16a0:	fc 01       	movw	r30, r24
    16a2:	11 86       	std	Z+9, r1	; 0x09
    16a4:	10 86       	std	Z+8, r1	; 0x08
    16a6:	08 95       	ret

000016a8 <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
    16a8:	cf 93       	push	r28
    16aa:	df 93       	push	r29
    16ac:	fc 01       	movw	r30, r24
    16ae:	db 01       	movw	r26, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
    16b0:	21 81       	ldd	r18, Z+1	; 0x01
    16b2:	32 81       	ldd	r19, Z+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
    16b4:	e9 01       	movw	r28, r18
    16b6:	8a 81       	ldd	r24, Y+2	; 0x02
    16b8:	9b 81       	ldd	r25, Y+3	; 0x03
    16ba:	13 96       	adiw	r26, 0x03	; 3
    16bc:	9c 93       	st	X, r25
    16be:	8e 93       	st	-X, r24
    16c0:	12 97       	sbiw	r26, 0x02	; 2
	pxNewListItem->pxPrevious = pxList->pxIndex;
    16c2:	81 81       	ldd	r24, Z+1	; 0x01
    16c4:	92 81       	ldd	r25, Z+2	; 0x02
    16c6:	15 96       	adiw	r26, 0x05	; 5
    16c8:	9c 93       	st	X, r25
    16ca:	8e 93       	st	-X, r24
    16cc:	14 97       	sbiw	r26, 0x04	; 4
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    16ce:	8a 81       	ldd	r24, Y+2	; 0x02
    16d0:	9b 81       	ldd	r25, Y+3	; 0x03
    16d2:	ec 01       	movw	r28, r24
    16d4:	7d 83       	std	Y+5, r23	; 0x05
    16d6:	6c 83       	std	Y+4, r22	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
    16d8:	e9 01       	movw	r28, r18
    16da:	7b 83       	std	Y+3, r23	; 0x03
    16dc:	6a 83       	std	Y+2, r22	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
    16de:	72 83       	std	Z+2, r23	; 0x02
    16e0:	61 83       	std	Z+1, r22	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    16e2:	19 96       	adiw	r26, 0x09	; 9
    16e4:	fc 93       	st	X, r31
    16e6:	ee 93       	st	-X, r30
    16e8:	18 97       	sbiw	r26, 0x08	; 8

	( pxList->uxNumberOfItems )++;
    16ea:	80 81       	ld	r24, Z
    16ec:	8f 5f       	subi	r24, 0xFF	; 255
    16ee:	80 83       	st	Z, r24
}
    16f0:	df 91       	pop	r29
    16f2:	cf 91       	pop	r28
    16f4:	08 95       	ret

000016f6 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
    16f6:	cf 93       	push	r28
    16f8:	df 93       	push	r29
    16fa:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
    16fc:	48 81       	ld	r20, Y
    16fe:	59 81       	ldd	r21, Y+1	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    1700:	4f 3f       	cpi	r20, 0xFF	; 255
    1702:	2f ef       	ldi	r18, 0xFF	; 255
    1704:	52 07       	cpc	r21, r18
    1706:	31 f4       	brne	.+12     	; 0x1714 <vListInsert+0x1e>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    1708:	dc 01       	movw	r26, r24
    170a:	17 96       	adiw	r26, 0x07	; 7
    170c:	ed 91       	ld	r30, X+
    170e:	fc 91       	ld	r31, X
    1710:	18 97       	sbiw	r26, 0x08	; 8
    1712:	0d c0       	rjmp	.+26     	; 0x172e <vListInsert+0x38>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    1714:	fc 01       	movw	r30, r24
    1716:	33 96       	adiw	r30, 0x03	; 3
    1718:	03 c0       	rjmp	.+6      	; 0x1720 <vListInsert+0x2a>
    171a:	02 80       	ldd	r0, Z+2	; 0x02
    171c:	f3 81       	ldd	r31, Z+3	; 0x03
    171e:	e0 2d       	mov	r30, r0
    1720:	a2 81       	ldd	r26, Z+2	; 0x02
    1722:	b3 81       	ldd	r27, Z+3	; 0x03
    1724:	2d 91       	ld	r18, X+
    1726:	3c 91       	ld	r19, X
    1728:	42 17       	cp	r20, r18
    172a:	53 07       	cpc	r21, r19
    172c:	b0 f7       	brcc	.-20     	; 0x171a <vListInsert+0x24>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    172e:	a2 81       	ldd	r26, Z+2	; 0x02
    1730:	b3 81       	ldd	r27, Z+3	; 0x03
    1732:	bb 83       	std	Y+3, r27	; 0x03
    1734:	aa 83       	std	Y+2, r26	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    1736:	15 96       	adiw	r26, 0x05	; 5
    1738:	dc 93       	st	X, r29
    173a:	ce 93       	st	-X, r28
    173c:	14 97       	sbiw	r26, 0x04	; 4
	pxNewListItem->pxPrevious = pxIterator;
    173e:	fd 83       	std	Y+5, r31	; 0x05
    1740:	ec 83       	std	Y+4, r30	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    1742:	d3 83       	std	Z+3, r29	; 0x03
    1744:	c2 83       	std	Z+2, r28	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1746:	99 87       	std	Y+9, r25	; 0x09
    1748:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    174a:	fc 01       	movw	r30, r24
    174c:	20 81       	ld	r18, Z
    174e:	2f 5f       	subi	r18, 0xFF	; 255
    1750:	20 83       	st	Z, r18
}
    1752:	df 91       	pop	r29
    1754:	cf 91       	pop	r28
    1756:	08 95       	ret

00001758 <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
    1758:	fc 01       	movw	r30, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    175a:	a2 81       	ldd	r26, Z+2	; 0x02
    175c:	b3 81       	ldd	r27, Z+3	; 0x03
    175e:	84 81       	ldd	r24, Z+4	; 0x04
    1760:	95 81       	ldd	r25, Z+5	; 0x05
    1762:	15 96       	adiw	r26, 0x05	; 5
    1764:	9c 93       	st	X, r25
    1766:	8e 93       	st	-X, r24
    1768:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    176a:	a4 81       	ldd	r26, Z+4	; 0x04
    176c:	b5 81       	ldd	r27, Z+5	; 0x05
    176e:	82 81       	ldd	r24, Z+2	; 0x02
    1770:	93 81       	ldd	r25, Z+3	; 0x03
    1772:	13 96       	adiw	r26, 0x03	; 3
    1774:	9c 93       	st	X, r25
    1776:	8e 93       	st	-X, r24
    1778:	12 97       	sbiw	r26, 0x02	; 2
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    177a:	a0 85       	ldd	r26, Z+8	; 0x08
    177c:	b1 85       	ldd	r27, Z+9	; 0x09

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    177e:	11 96       	adiw	r26, 0x01	; 1
    1780:	8d 91       	ld	r24, X+
    1782:	9c 91       	ld	r25, X
    1784:	12 97       	sbiw	r26, 0x02	; 2
    1786:	e8 17       	cp	r30, r24
    1788:	f9 07       	cpc	r31, r25
    178a:	31 f4       	brne	.+12     	; 0x1798 <vListRemove+0x40>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    178c:	84 81       	ldd	r24, Z+4	; 0x04
    178e:	95 81       	ldd	r25, Z+5	; 0x05
    1790:	12 96       	adiw	r26, 0x02	; 2
    1792:	9c 93       	st	X, r25
    1794:	8e 93       	st	-X, r24
    1796:	11 97       	sbiw	r26, 0x01	; 1
	}

	pxItemToRemove->pvContainer = NULL;
    1798:	11 86       	std	Z+9, r1	; 0x09
    179a:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    179c:	8c 91       	ld	r24, X
    179e:	81 50       	subi	r24, 0x01	; 1
    17a0:	8c 93       	st	X, r24
    17a2:	08 95       	ret

000017a4 <prvSetupTimerInterrupt>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    17a4:	8a ef       	ldi	r24, 0xFA	; 250
    17a6:	87 bd       	out	0x27, r24	; 39
    17a8:	82 e0       	ldi	r24, 0x02	; 2
    17aa:	84 bd       	out	0x24, r24	; 36
    17ac:	93 e0       	ldi	r25, 0x03	; 3
    17ae:	95 bd       	out	0x25, r25	; 37
    17b0:	80 93 6e 00 	sts	0x006E, r24	; 0x80006e <__TEXT_REGION_LENGTH__+0x70006e>
    17b4:	08 95       	ret

000017b6 <pxPortInitialiseStack>:
    17b6:	31 e1       	ldi	r19, 0x11	; 17
    17b8:	fc 01       	movw	r30, r24
    17ba:	30 83       	st	Z, r19
    17bc:	31 97       	sbiw	r30, 0x01	; 1
    17be:	22 e2       	ldi	r18, 0x22	; 34
    17c0:	20 83       	st	Z, r18
    17c2:	31 97       	sbiw	r30, 0x01	; 1
    17c4:	a3 e3       	ldi	r26, 0x33	; 51
    17c6:	a0 83       	st	Z, r26
    17c8:	31 97       	sbiw	r30, 0x01	; 1
    17ca:	60 83       	st	Z, r22
    17cc:	31 97       	sbiw	r30, 0x01	; 1
    17ce:	70 83       	st	Z, r23
    17d0:	31 97       	sbiw	r30, 0x01	; 1
    17d2:	10 82       	st	Z, r1
    17d4:	31 97       	sbiw	r30, 0x01	; 1
    17d6:	10 82       	st	Z, r1
    17d8:	31 97       	sbiw	r30, 0x01	; 1
    17da:	60 e8       	ldi	r22, 0x80	; 128
    17dc:	60 83       	st	Z, r22
    17de:	31 97       	sbiw	r30, 0x01	; 1
    17e0:	10 82       	st	Z, r1
    17e2:	31 97       	sbiw	r30, 0x01	; 1
    17e4:	10 82       	st	Z, r1
    17e6:	31 97       	sbiw	r30, 0x01	; 1
    17e8:	10 82       	st	Z, r1
    17ea:	31 97       	sbiw	r30, 0x01	; 1
    17ec:	62 e0       	ldi	r22, 0x02	; 2
    17ee:	60 83       	st	Z, r22
    17f0:	31 97       	sbiw	r30, 0x01	; 1
    17f2:	63 e0       	ldi	r22, 0x03	; 3
    17f4:	60 83       	st	Z, r22
    17f6:	31 97       	sbiw	r30, 0x01	; 1
    17f8:	64 e0       	ldi	r22, 0x04	; 4
    17fa:	60 83       	st	Z, r22
    17fc:	31 97       	sbiw	r30, 0x01	; 1
    17fe:	65 e0       	ldi	r22, 0x05	; 5
    1800:	60 83       	st	Z, r22
    1802:	31 97       	sbiw	r30, 0x01	; 1
    1804:	66 e0       	ldi	r22, 0x06	; 6
    1806:	60 83       	st	Z, r22
    1808:	31 97       	sbiw	r30, 0x01	; 1
    180a:	67 e0       	ldi	r22, 0x07	; 7
    180c:	60 83       	st	Z, r22
    180e:	31 97       	sbiw	r30, 0x01	; 1
    1810:	68 e0       	ldi	r22, 0x08	; 8
    1812:	60 83       	st	Z, r22
    1814:	31 97       	sbiw	r30, 0x01	; 1
    1816:	69 e0       	ldi	r22, 0x09	; 9
    1818:	60 83       	st	Z, r22
    181a:	31 97       	sbiw	r30, 0x01	; 1
    181c:	60 e1       	ldi	r22, 0x10	; 16
    181e:	60 83       	st	Z, r22
    1820:	31 97       	sbiw	r30, 0x01	; 1
    1822:	30 83       	st	Z, r19
    1824:	31 97       	sbiw	r30, 0x01	; 1
    1826:	32 e1       	ldi	r19, 0x12	; 18
    1828:	30 83       	st	Z, r19
    182a:	31 97       	sbiw	r30, 0x01	; 1
    182c:	33 e1       	ldi	r19, 0x13	; 19
    182e:	30 83       	st	Z, r19
    1830:	31 97       	sbiw	r30, 0x01	; 1
    1832:	34 e1       	ldi	r19, 0x14	; 20
    1834:	30 83       	st	Z, r19
    1836:	31 97       	sbiw	r30, 0x01	; 1
    1838:	35 e1       	ldi	r19, 0x15	; 21
    183a:	30 83       	st	Z, r19
    183c:	31 97       	sbiw	r30, 0x01	; 1
    183e:	36 e1       	ldi	r19, 0x16	; 22
    1840:	30 83       	st	Z, r19
    1842:	31 97       	sbiw	r30, 0x01	; 1
    1844:	37 e1       	ldi	r19, 0x17	; 23
    1846:	30 83       	st	Z, r19
    1848:	31 97       	sbiw	r30, 0x01	; 1
    184a:	38 e1       	ldi	r19, 0x18	; 24
    184c:	30 83       	st	Z, r19
    184e:	31 97       	sbiw	r30, 0x01	; 1
    1850:	39 e1       	ldi	r19, 0x19	; 25
    1852:	30 83       	st	Z, r19
    1854:	31 97       	sbiw	r30, 0x01	; 1
    1856:	30 e2       	ldi	r19, 0x20	; 32
    1858:	30 83       	st	Z, r19
    185a:	31 97       	sbiw	r30, 0x01	; 1
    185c:	31 e2       	ldi	r19, 0x21	; 33
    185e:	30 83       	st	Z, r19
    1860:	31 97       	sbiw	r30, 0x01	; 1
    1862:	20 83       	st	Z, r18
    1864:	31 97       	sbiw	r30, 0x01	; 1
    1866:	23 e2       	ldi	r18, 0x23	; 35
    1868:	20 83       	st	Z, r18
    186a:	31 97       	sbiw	r30, 0x01	; 1
    186c:	40 83       	st	Z, r20
    186e:	31 97       	sbiw	r30, 0x01	; 1
    1870:	50 83       	st	Z, r21
    1872:	31 97       	sbiw	r30, 0x01	; 1
    1874:	26 e2       	ldi	r18, 0x26	; 38
    1876:	20 83       	st	Z, r18
    1878:	31 97       	sbiw	r30, 0x01	; 1
    187a:	27 e2       	ldi	r18, 0x27	; 39
    187c:	20 83       	st	Z, r18
    187e:	31 97       	sbiw	r30, 0x01	; 1
    1880:	28 e2       	ldi	r18, 0x28	; 40
    1882:	20 83       	st	Z, r18
    1884:	31 97       	sbiw	r30, 0x01	; 1
    1886:	29 e2       	ldi	r18, 0x29	; 41
    1888:	20 83       	st	Z, r18
    188a:	31 97       	sbiw	r30, 0x01	; 1
    188c:	20 e3       	ldi	r18, 0x30	; 48
    188e:	20 83       	st	Z, r18
    1890:	31 97       	sbiw	r30, 0x01	; 1
    1892:	21 e3       	ldi	r18, 0x31	; 49
    1894:	20 83       	st	Z, r18
    1896:	89 97       	sbiw	r24, 0x29	; 41
    1898:	08 95       	ret

0000189a <xPortStartScheduler>:
    189a:	84 df       	rcall	.-248    	; 0x17a4 <prvSetupTimerInterrupt>
    189c:	a0 91 27 09 	lds	r26, 0x0927	; 0x800927 <pxCurrentTCB>
    18a0:	b0 91 28 09 	lds	r27, 0x0928	; 0x800928 <pxCurrentTCB+0x1>
    18a4:	cd 91       	ld	r28, X+
    18a6:	cd bf       	out	0x3d, r28	; 61
    18a8:	dd 91       	ld	r29, X+
    18aa:	de bf       	out	0x3e, r29	; 62
    18ac:	ff 91       	pop	r31
    18ae:	ef 91       	pop	r30
    18b0:	df 91       	pop	r29
    18b2:	cf 91       	pop	r28
    18b4:	bf 91       	pop	r27
    18b6:	af 91       	pop	r26
    18b8:	9f 91       	pop	r25
    18ba:	8f 91       	pop	r24
    18bc:	7f 91       	pop	r23
    18be:	6f 91       	pop	r22
    18c0:	5f 91       	pop	r21
    18c2:	4f 91       	pop	r20
    18c4:	3f 91       	pop	r19
    18c6:	2f 91       	pop	r18
    18c8:	1f 91       	pop	r17
    18ca:	0f 91       	pop	r16
    18cc:	ff 90       	pop	r15
    18ce:	ef 90       	pop	r14
    18d0:	df 90       	pop	r13
    18d2:	cf 90       	pop	r12
    18d4:	bf 90       	pop	r11
    18d6:	af 90       	pop	r10
    18d8:	9f 90       	pop	r9
    18da:	8f 90       	pop	r8
    18dc:	7f 90       	pop	r7
    18de:	6f 90       	pop	r6
    18e0:	5f 90       	pop	r5
    18e2:	4f 90       	pop	r4
    18e4:	3f 90       	pop	r3
    18e6:	2f 90       	pop	r2
    18e8:	1f 90       	pop	r1
    18ea:	0f 90       	pop	r0
    18ec:	0c be       	out	0x3c, r0	; 60
    18ee:	0f 90       	pop	r0
    18f0:	0b be       	out	0x3b, r0	; 59
    18f2:	0f 90       	pop	r0
    18f4:	0f be       	out	0x3f, r0	; 63
    18f6:	0f 90       	pop	r0
    18f8:	08 95       	ret
    18fa:	81 e0       	ldi	r24, 0x01	; 1
    18fc:	08 95       	ret

000018fe <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    18fe:	0f 92       	push	r0
    1900:	0f b6       	in	r0, 0x3f	; 63
    1902:	f8 94       	cli
    1904:	0f 92       	push	r0
    1906:	0b b6       	in	r0, 0x3b	; 59
    1908:	0f 92       	push	r0
    190a:	0c b6       	in	r0, 0x3c	; 60
    190c:	0f 92       	push	r0
    190e:	1f 92       	push	r1
    1910:	11 24       	eor	r1, r1
    1912:	2f 92       	push	r2
    1914:	3f 92       	push	r3
    1916:	4f 92       	push	r4
    1918:	5f 92       	push	r5
    191a:	6f 92       	push	r6
    191c:	7f 92       	push	r7
    191e:	8f 92       	push	r8
    1920:	9f 92       	push	r9
    1922:	af 92       	push	r10
    1924:	bf 92       	push	r11
    1926:	cf 92       	push	r12
    1928:	df 92       	push	r13
    192a:	ef 92       	push	r14
    192c:	ff 92       	push	r15
    192e:	0f 93       	push	r16
    1930:	1f 93       	push	r17
    1932:	2f 93       	push	r18
    1934:	3f 93       	push	r19
    1936:	4f 93       	push	r20
    1938:	5f 93       	push	r21
    193a:	6f 93       	push	r22
    193c:	7f 93       	push	r23
    193e:	8f 93       	push	r24
    1940:	9f 93       	push	r25
    1942:	af 93       	push	r26
    1944:	bf 93       	push	r27
    1946:	cf 93       	push	r28
    1948:	df 93       	push	r29
    194a:	ef 93       	push	r30
    194c:	ff 93       	push	r31
    194e:	a0 91 27 09 	lds	r26, 0x0927	; 0x800927 <pxCurrentTCB>
    1952:	b0 91 28 09 	lds	r27, 0x0928	; 0x800928 <pxCurrentTCB+0x1>
    1956:	0d b6       	in	r0, 0x3d	; 61
    1958:	0d 92       	st	X+, r0
    195a:	0e b6       	in	r0, 0x3e	; 62
    195c:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    195e:	86 d3       	rcall	.+1804   	; 0x206c <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1960:	a0 91 27 09 	lds	r26, 0x0927	; 0x800927 <pxCurrentTCB>
    1964:	b0 91 28 09 	lds	r27, 0x0928	; 0x800928 <pxCurrentTCB+0x1>
    1968:	cd 91       	ld	r28, X+
    196a:	cd bf       	out	0x3d, r28	; 61
    196c:	dd 91       	ld	r29, X+
    196e:	de bf       	out	0x3e, r29	; 62
    1970:	ff 91       	pop	r31
    1972:	ef 91       	pop	r30
    1974:	df 91       	pop	r29
    1976:	cf 91       	pop	r28
    1978:	bf 91       	pop	r27
    197a:	af 91       	pop	r26
    197c:	9f 91       	pop	r25
    197e:	8f 91       	pop	r24
    1980:	7f 91       	pop	r23
    1982:	6f 91       	pop	r22
    1984:	5f 91       	pop	r21
    1986:	4f 91       	pop	r20
    1988:	3f 91       	pop	r19
    198a:	2f 91       	pop	r18
    198c:	1f 91       	pop	r17
    198e:	0f 91       	pop	r16
    1990:	ff 90       	pop	r15
    1992:	ef 90       	pop	r14
    1994:	df 90       	pop	r13
    1996:	cf 90       	pop	r12
    1998:	bf 90       	pop	r11
    199a:	af 90       	pop	r10
    199c:	9f 90       	pop	r9
    199e:	8f 90       	pop	r8
    19a0:	7f 90       	pop	r7
    19a2:	6f 90       	pop	r6
    19a4:	5f 90       	pop	r5
    19a6:	4f 90       	pop	r4
    19a8:	3f 90       	pop	r3
    19aa:	2f 90       	pop	r2
    19ac:	1f 90       	pop	r1
    19ae:	0f 90       	pop	r0
    19b0:	0c be       	out	0x3c, r0	; 60
    19b2:	0f 90       	pop	r0
    19b4:	0b be       	out	0x3b, r0	; 59
    19b6:	0f 90       	pop	r0
    19b8:	0f be       	out	0x3f, r0	; 63
    19ba:	0f 90       	pop	r0

	asm volatile ( "ret" );
    19bc:	08 95       	ret

000019be <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    19be:	0f 92       	push	r0
    19c0:	0f b6       	in	r0, 0x3f	; 63
    19c2:	f8 94       	cli
    19c4:	0f 92       	push	r0
    19c6:	0b b6       	in	r0, 0x3b	; 59
    19c8:	0f 92       	push	r0
    19ca:	0c b6       	in	r0, 0x3c	; 60
    19cc:	0f 92       	push	r0
    19ce:	1f 92       	push	r1
    19d0:	11 24       	eor	r1, r1
    19d2:	2f 92       	push	r2
    19d4:	3f 92       	push	r3
    19d6:	4f 92       	push	r4
    19d8:	5f 92       	push	r5
    19da:	6f 92       	push	r6
    19dc:	7f 92       	push	r7
    19de:	8f 92       	push	r8
    19e0:	9f 92       	push	r9
    19e2:	af 92       	push	r10
    19e4:	bf 92       	push	r11
    19e6:	cf 92       	push	r12
    19e8:	df 92       	push	r13
    19ea:	ef 92       	push	r14
    19ec:	ff 92       	push	r15
    19ee:	0f 93       	push	r16
    19f0:	1f 93       	push	r17
    19f2:	2f 93       	push	r18
    19f4:	3f 93       	push	r19
    19f6:	4f 93       	push	r20
    19f8:	5f 93       	push	r21
    19fa:	6f 93       	push	r22
    19fc:	7f 93       	push	r23
    19fe:	8f 93       	push	r24
    1a00:	9f 93       	push	r25
    1a02:	af 93       	push	r26
    1a04:	bf 93       	push	r27
    1a06:	cf 93       	push	r28
    1a08:	df 93       	push	r29
    1a0a:	ef 93       	push	r30
    1a0c:	ff 93       	push	r31
    1a0e:	a0 91 27 09 	lds	r26, 0x0927	; 0x800927 <pxCurrentTCB>
    1a12:	b0 91 28 09 	lds	r27, 0x0928	; 0x800928 <pxCurrentTCB+0x1>
    1a16:	0d b6       	in	r0, 0x3d	; 61
    1a18:	0d 92       	st	X+, r0
    1a1a:	0e b6       	in	r0, 0x3e	; 62
    1a1c:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    1a1e:	f1 d1       	rcall	.+994    	; 0x1e02 <vTaskIncrementTick>
	vTaskSwitchContext();
    1a20:	25 d3       	rcall	.+1610   	; 0x206c <vTaskSwitchContext>
    1a22:	a0 91 27 09 	lds	r26, 0x0927	; 0x800927 <pxCurrentTCB>
	portRESTORE_CONTEXT();
    1a26:	b0 91 28 09 	lds	r27, 0x0928	; 0x800928 <pxCurrentTCB+0x1>
    1a2a:	cd 91       	ld	r28, X+
    1a2c:	cd bf       	out	0x3d, r28	; 61
    1a2e:	dd 91       	ld	r29, X+
    1a30:	de bf       	out	0x3e, r29	; 62
    1a32:	ff 91       	pop	r31
    1a34:	ef 91       	pop	r30
    1a36:	df 91       	pop	r29
    1a38:	cf 91       	pop	r28
    1a3a:	bf 91       	pop	r27
    1a3c:	af 91       	pop	r26
    1a3e:	9f 91       	pop	r25
    1a40:	8f 91       	pop	r24
    1a42:	7f 91       	pop	r23
    1a44:	6f 91       	pop	r22
    1a46:	5f 91       	pop	r21
    1a48:	4f 91       	pop	r20
    1a4a:	3f 91       	pop	r19
    1a4c:	2f 91       	pop	r18
    1a4e:	1f 91       	pop	r17
    1a50:	0f 91       	pop	r16
    1a52:	ff 90       	pop	r15
    1a54:	ef 90       	pop	r14
    1a56:	df 90       	pop	r13
    1a58:	cf 90       	pop	r12
    1a5a:	bf 90       	pop	r11
    1a5c:	af 90       	pop	r10
    1a5e:	9f 90       	pop	r9
    1a60:	8f 90       	pop	r8
    1a62:	7f 90       	pop	r7
    1a64:	6f 90       	pop	r6
    1a66:	5f 90       	pop	r5
    1a68:	4f 90       	pop	r4
    1a6a:	3f 90       	pop	r3
    1a6c:	2f 90       	pop	r2
    1a6e:	1f 90       	pop	r1
    1a70:	0f 90       	pop	r0
    1a72:	0c be       	out	0x3c, r0	; 60
    1a74:	0f 90       	pop	r0
    1a76:	0b be       	out	0x3b, r0	; 59
    1a78:	0f 90       	pop	r0
    1a7a:	0f be       	out	0x3f, r0	; 63
    1a7c:	0f 90       	pop	r0
    1a7e:	08 95       	ret

00001a80 <__vector_21>:
	asm volatile ( "ret" );
    1a80:	9e df       	rcall	.-196    	; 0x19be <vPortYieldFromTick>
//	void SIG_OUTPUT_COMPARE1A( void )
	void TIMER0_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER0_COMPA_vect( void )
	{
		vPortYieldFromTick();
		asm volatile ( "reti" );
    1a82:	18 95       	reti

00001a84 <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    1a84:	cf 93       	push	r28
    1a86:	df 93       	push	r29
    1a88:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
    1a8a:	b5 d1       	rcall	.+874    	; 0x1df6 <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
    1a8c:	20 91 16 03 	lds	r18, 0x0316	; 0x800316 <xNextFreeByte>
    1a90:	30 91 17 03 	lds	r19, 0x0317	; 0x800317 <xNextFreeByte+0x1>
    1a94:	c9 01       	movw	r24, r18
    1a96:	8c 0f       	add	r24, r28
    1a98:	9d 1f       	adc	r25, r29
    1a9a:	8c 3d       	cpi	r24, 0xDC	; 220
    1a9c:	45 e0       	ldi	r20, 0x05	; 5
    1a9e:	94 07       	cpc	r25, r20
    1aa0:	58 f4       	brcc	.+22     	; 0x1ab8 <pvPortMalloc+0x34>
    1aa2:	28 17       	cp	r18, r24
    1aa4:	39 07       	cpc	r19, r25
    1aa6:	58 f4       	brcc	.+22     	; 0x1abe <pvPortMalloc+0x3a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
    1aa8:	e9 01       	movw	r28, r18
    1aaa:	c8 5e       	subi	r28, 0xE8	; 232
    1aac:	dc 4f       	sbci	r29, 0xFC	; 252
			xNextFreeByte += xWantedSize;			
    1aae:	90 93 17 03 	sts	0x0317, r25	; 0x800317 <xNextFreeByte+0x1>
    1ab2:	80 93 16 03 	sts	0x0316, r24	; 0x800316 <xNextFreeByte>
    1ab6:	05 c0       	rjmp	.+10     	; 0x1ac2 <pvPortMalloc+0x3e>
static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL; 
    1ab8:	c0 e0       	ldi	r28, 0x00	; 0
    1aba:	d0 e0       	ldi	r29, 0x00	; 0
    1abc:	02 c0       	rjmp	.+4      	; 0x1ac2 <pvPortMalloc+0x3e>
    1abe:	c0 e0       	ldi	r28, 0x00	; 0
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
			xNextFreeByte += xWantedSize;			
		}	
	}
	xTaskResumeAll();
    1ac0:	d0 e0       	ldi	r29, 0x00	; 0
    1ac2:	46 d2       	rcall	.+1164   	; 0x1f50 <xTaskResumeAll>
		}
	}
	#endif	

	return pvReturn;
}
    1ac4:	ce 01       	movw	r24, r28
    1ac6:	df 91       	pop	r29
    1ac8:	cf 91       	pop	r28
    1aca:	08 95       	ret

00001acc <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    1acc:	08 95       	ret

00001ace <prvIdleTask>:
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
		}
	}
    1ace:	80 91 1e 09 	lds	r24, 0x091E	; 0x80091e <pxReadyTasksLists>
    1ad2:	82 30       	cpi	r24, 0x02	; 2
    1ad4:	e0 f3       	brcs	.-8      	; 0x1ace <prvIdleTask>
    1ad6:	13 df       	rcall	.-474    	; 0x18fe <vPortYield>
    1ad8:	fa cf       	rjmp	.-12     	; 0x1ace <prvIdleTask>

00001ada <prvAllocateTCBAndStack>:
    1ada:	ef 92       	push	r14
    1adc:	ff 92       	push	r15
    1ade:	0f 93       	push	r16
    1ae0:	1f 93       	push	r17
    1ae2:	cf 93       	push	r28
    1ae4:	df 93       	push	r29
    1ae6:	7c 01       	movw	r14, r24
    1ae8:	eb 01       	movw	r28, r22
    1aea:	81 e2       	ldi	r24, 0x21	; 33
    1aec:	90 e0       	ldi	r25, 0x00	; 0
    1aee:	ca df       	rcall	.-108    	; 0x1a84 <pvPortMalloc>
    1af0:	8c 01       	movw	r16, r24
    1af2:	89 2b       	or	r24, r25
    1af4:	a9 f0       	breq	.+42     	; 0x1b20 <prvAllocateTCBAndStack+0x46>
    1af6:	20 97       	sbiw	r28, 0x00	; 0
    1af8:	19 f4       	brne	.+6      	; 0x1b00 <prvAllocateTCBAndStack+0x26>
    1afa:	c7 01       	movw	r24, r14
    1afc:	c3 df       	rcall	.-122    	; 0x1a84 <pvPortMalloc>
    1afe:	01 c0       	rjmp	.+2      	; 0x1b02 <prvAllocateTCBAndStack+0x28>
    1b00:	ce 01       	movw	r24, r28
    1b02:	f8 01       	movw	r30, r16
    1b04:	90 8f       	std	Z+24, r25	; 0x18
    1b06:	87 8b       	std	Z+23, r24	; 0x17
    1b08:	00 97       	sbiw	r24, 0x00	; 0
    1b0a:	29 f4       	brne	.+10     	; 0x1b16 <prvAllocateTCBAndStack+0x3c>
    1b0c:	c8 01       	movw	r24, r16
    1b0e:	de df       	rcall	.-68     	; 0x1acc <vPortFree>
    1b10:	00 e0       	ldi	r16, 0x00	; 0
    1b12:	10 e0       	ldi	r17, 0x00	; 0
    1b14:	05 c0       	rjmp	.+10     	; 0x1b20 <prvAllocateTCBAndStack+0x46>
    1b16:	a7 01       	movw	r20, r14
    1b18:	65 ea       	ldi	r22, 0xA5	; 165
    1b1a:	70 e0       	ldi	r23, 0x00	; 0
    1b1c:	0e 94 d1 16 	call	0x2da2	; 0x2da2 <memset>
    1b20:	c8 01       	movw	r24, r16
    1b22:	df 91       	pop	r29
    1b24:	cf 91       	pop	r28
    1b26:	1f 91       	pop	r17
    1b28:	0f 91       	pop	r16
    1b2a:	ff 90       	pop	r15
    1b2c:	ef 90       	pop	r14
    1b2e:	08 95       	ret

00001b30 <prvInitialiseTCBVariables>:
    1b30:	1f 93       	push	r17
    1b32:	cf 93       	push	r28
    1b34:	df 93       	push	r29
    1b36:	ec 01       	movw	r28, r24
    1b38:	14 2f       	mov	r17, r20
    1b3a:	48 e0       	ldi	r20, 0x08	; 8
    1b3c:	50 e0       	ldi	r21, 0x00	; 0
    1b3e:	49 96       	adiw	r24, 0x19	; 25
    1b40:	0e 94 d8 16 	call	0x2db0	; 0x2db0 <strncpy>
    1b44:	18 a2       	std	Y+32, r1	; 0x20
    1b46:	11 11       	cpse	r17, r1
    1b48:	10 e0       	ldi	r17, 0x00	; 0
    1b4a:	1e 8b       	std	Y+22, r17	; 0x16
    1b4c:	ce 01       	movw	r24, r28
    1b4e:	02 96       	adiw	r24, 0x02	; 2
    1b50:	a7 dd       	rcall	.-1202   	; 0x16a0 <vListInitialiseItem>
    1b52:	ce 01       	movw	r24, r28
    1b54:	0c 96       	adiw	r24, 0x0c	; 12
    1b56:	a4 dd       	rcall	.-1208   	; 0x16a0 <vListInitialiseItem>
    1b58:	d9 87       	std	Y+9, r29	; 0x09
    1b5a:	c8 87       	std	Y+8, r28	; 0x08
    1b5c:	81 e0       	ldi	r24, 0x01	; 1
    1b5e:	90 e0       	ldi	r25, 0x00	; 0
    1b60:	81 1b       	sub	r24, r17
    1b62:	91 09       	sbc	r25, r1
    1b64:	9d 87       	std	Y+13, r25	; 0x0d
    1b66:	8c 87       	std	Y+12, r24	; 0x0c
    1b68:	db 8b       	std	Y+19, r29	; 0x13
    1b6a:	ca 8b       	std	Y+18, r28	; 0x12
    1b6c:	df 91       	pop	r29
    1b6e:	cf 91       	pop	r28
    1b70:	1f 91       	pop	r17
    1b72:	08 95       	ret

00001b74 <prvInitialiseTaskLists>:
    1b74:	cf 93       	push	r28
    1b76:	c0 e0       	ldi	r28, 0x00	; 0
    1b78:	0f c0       	rjmp	.+30     	; 0x1b98 <prvInitialiseTaskLists+0x24>
    1b7a:	8c 2f       	mov	r24, r28
    1b7c:	90 e0       	ldi	r25, 0x00	; 0
    1b7e:	9c 01       	movw	r18, r24
    1b80:	22 0f       	add	r18, r18
    1b82:	33 1f       	adc	r19, r19
    1b84:	22 0f       	add	r18, r18
    1b86:	33 1f       	adc	r19, r19
    1b88:	22 0f       	add	r18, r18
    1b8a:	33 1f       	adc	r19, r19
    1b8c:	82 0f       	add	r24, r18
    1b8e:	93 1f       	adc	r25, r19
    1b90:	82 5e       	subi	r24, 0xE2	; 226
    1b92:	96 4f       	sbci	r25, 0xF6	; 246
    1b94:	77 dd       	rcall	.-1298   	; 0x1684 <vListInitialise>
    1b96:	cf 5f       	subi	r28, 0xFF	; 255
    1b98:	cc 23       	and	r28, r28
    1b9a:	79 f3       	breq	.-34     	; 0x1b7a <prvInitialiseTaskLists+0x6>
    1b9c:	85 e1       	ldi	r24, 0x15	; 21
    1b9e:	99 e0       	ldi	r25, 0x09	; 9
    1ba0:	71 dd       	rcall	.-1310   	; 0x1684 <vListInitialise>
    1ba2:	8c e0       	ldi	r24, 0x0C	; 12
    1ba4:	99 e0       	ldi	r25, 0x09	; 9
    1ba6:	6e dd       	rcall	.-1316   	; 0x1684 <vListInitialise>
    1ba8:	8f ef       	ldi	r24, 0xFF	; 255
    1baa:	98 e0       	ldi	r25, 0x08	; 8
    1bac:	6b dd       	rcall	.-1322   	; 0x1684 <vListInitialise>
    1bae:	85 e1       	ldi	r24, 0x15	; 21
    1bb0:	99 e0       	ldi	r25, 0x09	; 9
    1bb2:	90 93 0b 09 	sts	0x090B, r25	; 0x80090b <pxDelayedTaskList+0x1>
    1bb6:	80 93 0a 09 	sts	0x090A, r24	; 0x80090a <pxDelayedTaskList>
    1bba:	8c e0       	ldi	r24, 0x0C	; 12
    1bbc:	99 e0       	ldi	r25, 0x09	; 9
    1bbe:	90 93 09 09 	sts	0x0909, r25	; 0x800909 <pxOverflowDelayedTaskList+0x1>
    1bc2:	80 93 08 09 	sts	0x0908, r24	; 0x800908 <pxOverflowDelayedTaskList>
    1bc6:	cf 91       	pop	r28
    1bc8:	08 95       	ret

00001bca <prvAddCurrentTaskToDelayedList>:
    1bca:	cf 93       	push	r28
    1bcc:	df 93       	push	r29
    1bce:	ec 01       	movw	r28, r24
    1bd0:	e0 91 27 09 	lds	r30, 0x0927	; 0x800927 <pxCurrentTCB>
    1bd4:	f0 91 28 09 	lds	r31, 0x0928	; 0x800928 <pxCurrentTCB+0x1>
    1bd8:	93 83       	std	Z+3, r25	; 0x03
    1bda:	82 83       	std	Z+2, r24	; 0x02
    1bdc:	80 91 fc 08 	lds	r24, 0x08FC	; 0x8008fc <xTickCount>
    1be0:	90 91 fd 08 	lds	r25, 0x08FD	; 0x8008fd <xTickCount+0x1>
    1be4:	c8 17       	cp	r28, r24
    1be6:	d9 07       	cpc	r29, r25
    1be8:	60 f4       	brcc	.+24     	; 0x1c02 <prvAddCurrentTaskToDelayedList+0x38>
    1bea:	60 91 27 09 	lds	r22, 0x0927	; 0x800927 <pxCurrentTCB>
    1bee:	70 91 28 09 	lds	r23, 0x0928	; 0x800928 <pxCurrentTCB+0x1>
    1bf2:	80 91 08 09 	lds	r24, 0x0908	; 0x800908 <pxOverflowDelayedTaskList>
    1bf6:	90 91 09 09 	lds	r25, 0x0909	; 0x800909 <pxOverflowDelayedTaskList+0x1>
    1bfa:	6e 5f       	subi	r22, 0xFE	; 254
    1bfc:	7f 4f       	sbci	r23, 0xFF	; 255
    1bfe:	7b dd       	rcall	.-1290   	; 0x16f6 <vListInsert>
    1c00:	16 c0       	rjmp	.+44     	; 0x1c2e <prvAddCurrentTaskToDelayedList+0x64>
    1c02:	60 91 27 09 	lds	r22, 0x0927	; 0x800927 <pxCurrentTCB>
    1c06:	70 91 28 09 	lds	r23, 0x0928	; 0x800928 <pxCurrentTCB+0x1>
    1c0a:	80 91 0a 09 	lds	r24, 0x090A	; 0x80090a <pxDelayedTaskList>
    1c0e:	90 91 0b 09 	lds	r25, 0x090B	; 0x80090b <pxDelayedTaskList+0x1>
    1c12:	6e 5f       	subi	r22, 0xFE	; 254
    1c14:	7f 4f       	sbci	r23, 0xFF	; 255
    1c16:	6f dd       	rcall	.-1314   	; 0x16f6 <vListInsert>
    1c18:	80 91 0b 02 	lds	r24, 0x020B	; 0x80020b <xNextTaskUnblockTime>
    1c1c:	90 91 0c 02 	lds	r25, 0x020C	; 0x80020c <xNextTaskUnblockTime+0x1>
    1c20:	c8 17       	cp	r28, r24
    1c22:	d9 07       	cpc	r29, r25
    1c24:	20 f4       	brcc	.+8      	; 0x1c2e <prvAddCurrentTaskToDelayedList+0x64>
    1c26:	d0 93 0c 02 	sts	0x020C, r29	; 0x80020c <xNextTaskUnblockTime+0x1>
    1c2a:	c0 93 0b 02 	sts	0x020B, r28	; 0x80020b <xNextTaskUnblockTime>
    1c2e:	df 91       	pop	r29
    1c30:	cf 91       	pop	r28
    1c32:	08 95       	ret

00001c34 <xTaskGenericCreate>:
    1c34:	2f 92       	push	r2
    1c36:	3f 92       	push	r3
    1c38:	4f 92       	push	r4
    1c3a:	5f 92       	push	r5
    1c3c:	7f 92       	push	r7
    1c3e:	8f 92       	push	r8
    1c40:	9f 92       	push	r9
    1c42:	af 92       	push	r10
    1c44:	bf 92       	push	r11
    1c46:	cf 92       	push	r12
    1c48:	df 92       	push	r13
    1c4a:	ef 92       	push	r14
    1c4c:	ff 92       	push	r15
    1c4e:	0f 93       	push	r16
    1c50:	1f 93       	push	r17
    1c52:	cf 93       	push	r28
    1c54:	df 93       	push	r29
    1c56:	00 d0       	rcall	.+0      	; 0x1c58 <xTaskGenericCreate+0x24>
    1c58:	1f 92       	push	r1
    1c5a:	cd b7       	in	r28, 0x3d	; 61
    1c5c:	de b7       	in	r29, 0x3e	; 62
    1c5e:	9a 83       	std	Y+2, r25	; 0x02
    1c60:	89 83       	std	Y+1, r24	; 0x01
    1c62:	4b 01       	movw	r8, r22
    1c64:	5c 83       	std	Y+4, r21	; 0x04
    1c66:	4b 83       	std	Y+3, r20	; 0x03
    1c68:	19 01       	movw	r2, r18
    1c6a:	70 2e       	mov	r7, r16
    1c6c:	b6 01       	movw	r22, r12
    1c6e:	25 01       	movw	r4, r10
    1c70:	ca 01       	movw	r24, r20
    1c72:	33 df       	rcall	.-410    	; 0x1ada <prvAllocateTCBAndStack>
    1c74:	5c 01       	movw	r10, r24
    1c76:	00 97       	sbiw	r24, 0x00	; 0
    1c78:	09 f4       	brne	.+2      	; 0x1c7c <xTaskGenericCreate+0x48>
    1c7a:	6c c0       	rjmp	.+216    	; 0x1d54 <xTaskGenericCreate+0x120>
    1c7c:	fc 01       	movw	r30, r24
    1c7e:	c7 88       	ldd	r12, Z+23	; 0x17
    1c80:	d0 8c       	ldd	r13, Z+24	; 0x18
    1c82:	8b 81       	ldd	r24, Y+3	; 0x03
    1c84:	9c 81       	ldd	r25, Y+4	; 0x04
    1c86:	01 97       	sbiw	r24, 0x01	; 1
    1c88:	c8 0e       	add	r12, r24
    1c8a:	d9 1e       	adc	r13, r25
    1c8c:	0b 81       	ldd	r16, Y+3	; 0x03
    1c8e:	1c 81       	ldd	r17, Y+4	; 0x04
    1c90:	92 01       	movw	r18, r4
    1c92:	47 2d       	mov	r20, r7
    1c94:	b4 01       	movw	r22, r8
    1c96:	c5 01       	movw	r24, r10
    1c98:	4b df       	rcall	.-362    	; 0x1b30 <prvInitialiseTCBVariables>
    1c9a:	a1 01       	movw	r20, r2
    1c9c:	69 81       	ldd	r22, Y+1	; 0x01
    1c9e:	7a 81       	ldd	r23, Y+2	; 0x02
    1ca0:	c6 01       	movw	r24, r12
    1ca2:	89 dd       	rcall	.-1262   	; 0x17b6 <pxPortInitialiseStack>
    1ca4:	f5 01       	movw	r30, r10
    1ca6:	91 83       	std	Z+1, r25	; 0x01
    1ca8:	80 83       	st	Z, r24
    1caa:	e1 14       	cp	r14, r1
    1cac:	f1 04       	cpc	r15, r1
    1cae:	19 f0       	breq	.+6      	; 0x1cb6 <xTaskGenericCreate+0x82>
    1cb0:	f7 01       	movw	r30, r14
    1cb2:	b1 82       	std	Z+1, r11	; 0x01
    1cb4:	a0 82       	st	Z, r10
    1cb6:	0f b6       	in	r0, 0x3f	; 63
    1cb8:	f8 94       	cli
    1cba:	0f 92       	push	r0
    1cbc:	80 91 fe 08 	lds	r24, 0x08FE	; 0x8008fe <uxCurrentNumberOfTasks>
    1cc0:	8f 5f       	subi	r24, 0xFF	; 255
    1cc2:	80 93 fe 08 	sts	0x08FE, r24	; 0x8008fe <uxCurrentNumberOfTasks>
    1cc6:	80 91 27 09 	lds	r24, 0x0927	; 0x800927 <pxCurrentTCB>
    1cca:	90 91 28 09 	lds	r25, 0x0928	; 0x800928 <pxCurrentTCB+0x1>
    1cce:	89 2b       	or	r24, r25
    1cd0:	51 f4       	brne	.+20     	; 0x1ce6 <xTaskGenericCreate+0xb2>
    1cd2:	b0 92 28 09 	sts	0x0928, r11	; 0x800928 <pxCurrentTCB+0x1>
    1cd6:	a0 92 27 09 	sts	0x0927, r10	; 0x800927 <pxCurrentTCB>
    1cda:	80 91 fe 08 	lds	r24, 0x08FE	; 0x8008fe <uxCurrentNumberOfTasks>
    1cde:	81 30       	cpi	r24, 0x01	; 1
    1ce0:	89 f4       	brne	.+34     	; 0x1d04 <xTaskGenericCreate+0xd0>
    1ce2:	48 df       	rcall	.-368    	; 0x1b74 <prvInitialiseTaskLists>
    1ce4:	0f c0       	rjmp	.+30     	; 0x1d04 <xTaskGenericCreate+0xd0>
    1ce6:	80 91 f9 08 	lds	r24, 0x08F9	; 0x8008f9 <xSchedulerRunning>
    1cea:	81 11       	cpse	r24, r1
    1cec:	0b c0       	rjmp	.+22     	; 0x1d04 <xTaskGenericCreate+0xd0>
    1cee:	e0 91 27 09 	lds	r30, 0x0927	; 0x800927 <pxCurrentTCB>
    1cf2:	f0 91 28 09 	lds	r31, 0x0928	; 0x800928 <pxCurrentTCB+0x1>
    1cf6:	86 89       	ldd	r24, Z+22	; 0x16
    1cf8:	78 16       	cp	r7, r24
    1cfa:	20 f0       	brcs	.+8      	; 0x1d04 <xTaskGenericCreate+0xd0>
    1cfc:	b0 92 28 09 	sts	0x0928, r11	; 0x800928 <pxCurrentTCB+0x1>
    1d00:	a0 92 27 09 	sts	0x0927, r10	; 0x800927 <pxCurrentTCB>
    1d04:	f5 01       	movw	r30, r10
    1d06:	86 89       	ldd	r24, Z+22	; 0x16
    1d08:	90 91 fb 08 	lds	r25, 0x08FB	; 0x8008fb <uxTopUsedPriority>
    1d0c:	98 17       	cp	r25, r24
    1d0e:	10 f4       	brcc	.+4      	; 0x1d14 <xTaskGenericCreate+0xe0>
    1d10:	80 93 fb 08 	sts	0x08FB, r24	; 0x8008fb <uxTopUsedPriority>
    1d14:	90 91 f4 08 	lds	r25, 0x08F4	; 0x8008f4 <uxTCBNumber>
    1d18:	9f 5f       	subi	r25, 0xFF	; 255
    1d1a:	90 93 f4 08 	sts	0x08F4, r25	; 0x8008f4 <uxTCBNumber>
    1d1e:	90 91 fa 08 	lds	r25, 0x08FA	; 0x8008fa <uxTopReadyPriority>
    1d22:	98 17       	cp	r25, r24
    1d24:	10 f4       	brcc	.+4      	; 0x1d2a <xTaskGenericCreate+0xf6>
    1d26:	80 93 fa 08 	sts	0x08FA, r24	; 0x8008fa <uxTopReadyPriority>
    1d2a:	90 e0       	ldi	r25, 0x00	; 0
    1d2c:	b5 01       	movw	r22, r10
    1d2e:	6e 5f       	subi	r22, 0xFE	; 254
    1d30:	7f 4f       	sbci	r23, 0xFF	; 255
    1d32:	9c 01       	movw	r18, r24
    1d34:	22 0f       	add	r18, r18
    1d36:	33 1f       	adc	r19, r19
    1d38:	22 0f       	add	r18, r18
    1d3a:	33 1f       	adc	r19, r19
    1d3c:	22 0f       	add	r18, r18
    1d3e:	33 1f       	adc	r19, r19
    1d40:	82 0f       	add	r24, r18
    1d42:	93 1f       	adc	r25, r19
    1d44:	82 5e       	subi	r24, 0xE2	; 226
    1d46:	96 4f       	sbci	r25, 0xF6	; 246
    1d48:	af dc       	rcall	.-1698   	; 0x16a8 <vListInsertEnd>
    1d4a:	0f 90       	pop	r0
    1d4c:	0f be       	out	0x3f, r0	; 63
    1d4e:	f1 e0       	ldi	r31, 0x01	; 1
    1d50:	f9 83       	std	Y+1, r31	; 0x01
    1d52:	02 c0       	rjmp	.+4      	; 0x1d58 <xTaskGenericCreate+0x124>
    1d54:	8f ef       	ldi	r24, 0xFF	; 255
    1d56:	89 83       	std	Y+1, r24	; 0x01
    1d58:	e9 81       	ldd	r30, Y+1	; 0x01
    1d5a:	e1 30       	cpi	r30, 0x01	; 1
    1d5c:	61 f4       	brne	.+24     	; 0x1d76 <xTaskGenericCreate+0x142>
    1d5e:	80 91 f9 08 	lds	r24, 0x08F9	; 0x8008f9 <xSchedulerRunning>
    1d62:	88 23       	and	r24, r24
    1d64:	41 f0       	breq	.+16     	; 0x1d76 <xTaskGenericCreate+0x142>
    1d66:	e0 91 27 09 	lds	r30, 0x0927	; 0x800927 <pxCurrentTCB>
    1d6a:	f0 91 28 09 	lds	r31, 0x0928	; 0x800928 <pxCurrentTCB+0x1>
    1d6e:	86 89       	ldd	r24, Z+22	; 0x16
    1d70:	87 15       	cp	r24, r7
    1d72:	08 f4       	brcc	.+2      	; 0x1d76 <xTaskGenericCreate+0x142>
    1d74:	c4 dd       	rcall	.-1144   	; 0x18fe <vPortYield>
    1d76:	89 81       	ldd	r24, Y+1	; 0x01
    1d78:	0f 90       	pop	r0
    1d7a:	0f 90       	pop	r0
    1d7c:	0f 90       	pop	r0
    1d7e:	0f 90       	pop	r0
    1d80:	df 91       	pop	r29
    1d82:	cf 91       	pop	r28
    1d84:	1f 91       	pop	r17
    1d86:	0f 91       	pop	r16
    1d88:	ff 90       	pop	r15
    1d8a:	ef 90       	pop	r14
    1d8c:	df 90       	pop	r13
    1d8e:	cf 90       	pop	r12
    1d90:	bf 90       	pop	r11
    1d92:	af 90       	pop	r10
    1d94:	9f 90       	pop	r9
    1d96:	8f 90       	pop	r8
    1d98:	7f 90       	pop	r7
    1d9a:	5f 90       	pop	r5
    1d9c:	4f 90       	pop	r4
    1d9e:	3f 90       	pop	r3
    1da0:	2f 90       	pop	r2
    1da2:	08 95       	ret

00001da4 <vTaskStartScheduler>:
    1da4:	af 92       	push	r10
    1da6:	bf 92       	push	r11
    1da8:	cf 92       	push	r12
    1daa:	df 92       	push	r13
    1dac:	ef 92       	push	r14
    1dae:	ff 92       	push	r15
    1db0:	0f 93       	push	r16
    1db2:	a1 2c       	mov	r10, r1
    1db4:	b1 2c       	mov	r11, r1
    1db6:	c1 2c       	mov	r12, r1
    1db8:	d1 2c       	mov	r13, r1
    1dba:	e1 2c       	mov	r14, r1
    1dbc:	f1 2c       	mov	r15, r1
    1dbe:	00 e0       	ldi	r16, 0x00	; 0
    1dc0:	20 e0       	ldi	r18, 0x00	; 0
    1dc2:	30 e0       	ldi	r19, 0x00	; 0
    1dc4:	45 e5       	ldi	r20, 0x55	; 85
    1dc6:	50 e0       	ldi	r21, 0x00	; 0
    1dc8:	68 e8       	ldi	r22, 0x88	; 136
    1dca:	72 e0       	ldi	r23, 0x02	; 2
    1dcc:	87 e6       	ldi	r24, 0x67	; 103
    1dce:	9d e0       	ldi	r25, 0x0D	; 13
    1dd0:	31 df       	rcall	.-414    	; 0x1c34 <xTaskGenericCreate>
    1dd2:	81 30       	cpi	r24, 0x01	; 1
    1dd4:	41 f4       	brne	.+16     	; 0x1de6 <vTaskStartScheduler+0x42>
    1dd6:	f8 94       	cli
    1dd8:	80 93 f9 08 	sts	0x08F9, r24	; 0x8008f9 <xSchedulerRunning>
    1ddc:	10 92 fd 08 	sts	0x08FD, r1	; 0x8008fd <xTickCount+0x1>
    1de0:	10 92 fc 08 	sts	0x08FC, r1	; 0x8008fc <xTickCount>
    1de4:	5a dd       	rcall	.-1356   	; 0x189a <xPortStartScheduler>
    1de6:	0f 91       	pop	r16
    1de8:	ff 90       	pop	r15
    1dea:	ef 90       	pop	r14
    1dec:	df 90       	pop	r13
    1dee:	cf 90       	pop	r12
    1df0:	bf 90       	pop	r11
    1df2:	af 90       	pop	r10
    1df4:	08 95       	ret

00001df6 <vTaskSuspendAll>:
    1df6:	80 91 f8 08 	lds	r24, 0x08F8	; 0x8008f8 <uxSchedulerSuspended>
    1dfa:	8f 5f       	subi	r24, 0xFF	; 255
    1dfc:	80 93 f8 08 	sts	0x08F8, r24	; 0x8008f8 <uxSchedulerSuspended>
    1e00:	08 95       	ret

00001e02 <vTaskIncrementTick>:
    1e02:	0f 93       	push	r16
    1e04:	1f 93       	push	r17
    1e06:	cf 93       	push	r28
    1e08:	df 93       	push	r29
    1e0a:	80 91 f8 08 	lds	r24, 0x08F8	; 0x8008f8 <uxSchedulerSuspended>
    1e0e:	81 11       	cpse	r24, r1
    1e10:	95 c0       	rjmp	.+298    	; 0x1f3c <vTaskIncrementTick+0x13a>
    1e12:	80 91 fc 08 	lds	r24, 0x08FC	; 0x8008fc <xTickCount>
    1e16:	90 91 fd 08 	lds	r25, 0x08FD	; 0x8008fd <xTickCount+0x1>
    1e1a:	01 96       	adiw	r24, 0x01	; 1
    1e1c:	90 93 fd 08 	sts	0x08FD, r25	; 0x8008fd <xTickCount+0x1>
    1e20:	80 93 fc 08 	sts	0x08FC, r24	; 0x8008fc <xTickCount>
    1e24:	80 91 fc 08 	lds	r24, 0x08FC	; 0x8008fc <xTickCount>
    1e28:	90 91 fd 08 	lds	r25, 0x08FD	; 0x8008fd <xTickCount+0x1>
    1e2c:	89 2b       	or	r24, r25
    1e2e:	99 f5       	brne	.+102    	; 0x1e96 <vTaskIncrementTick+0x94>
    1e30:	80 91 0a 09 	lds	r24, 0x090A	; 0x80090a <pxDelayedTaskList>
    1e34:	90 91 0b 09 	lds	r25, 0x090B	; 0x80090b <pxDelayedTaskList+0x1>
    1e38:	20 91 08 09 	lds	r18, 0x0908	; 0x800908 <pxOverflowDelayedTaskList>
    1e3c:	30 91 09 09 	lds	r19, 0x0909	; 0x800909 <pxOverflowDelayedTaskList+0x1>
    1e40:	30 93 0b 09 	sts	0x090B, r19	; 0x80090b <pxDelayedTaskList+0x1>
    1e44:	20 93 0a 09 	sts	0x090A, r18	; 0x80090a <pxDelayedTaskList>
    1e48:	90 93 09 09 	sts	0x0909, r25	; 0x800909 <pxOverflowDelayedTaskList+0x1>
    1e4c:	80 93 08 09 	sts	0x0908, r24	; 0x800908 <pxOverflowDelayedTaskList>
    1e50:	80 91 f5 08 	lds	r24, 0x08F5	; 0x8008f5 <xNumOfOverflows>
    1e54:	8f 5f       	subi	r24, 0xFF	; 255
    1e56:	80 93 f5 08 	sts	0x08F5, r24	; 0x8008f5 <xNumOfOverflows>
    1e5a:	e0 91 0a 09 	lds	r30, 0x090A	; 0x80090a <pxDelayedTaskList>
    1e5e:	f0 91 0b 09 	lds	r31, 0x090B	; 0x80090b <pxDelayedTaskList+0x1>
    1e62:	80 81       	ld	r24, Z
    1e64:	81 11       	cpse	r24, r1
    1e66:	07 c0       	rjmp	.+14     	; 0x1e76 <vTaskIncrementTick+0x74>
    1e68:	8f ef       	ldi	r24, 0xFF	; 255
    1e6a:	9f ef       	ldi	r25, 0xFF	; 255
    1e6c:	90 93 0c 02 	sts	0x020C, r25	; 0x80020c <xNextTaskUnblockTime+0x1>
    1e70:	80 93 0b 02 	sts	0x020B, r24	; 0x80020b <xNextTaskUnblockTime>
    1e74:	10 c0       	rjmp	.+32     	; 0x1e96 <vTaskIncrementTick+0x94>
    1e76:	e0 91 0a 09 	lds	r30, 0x090A	; 0x80090a <pxDelayedTaskList>
    1e7a:	f0 91 0b 09 	lds	r31, 0x090B	; 0x80090b <pxDelayedTaskList+0x1>
    1e7e:	05 80       	ldd	r0, Z+5	; 0x05
    1e80:	f6 81       	ldd	r31, Z+6	; 0x06
    1e82:	e0 2d       	mov	r30, r0
    1e84:	06 80       	ldd	r0, Z+6	; 0x06
    1e86:	f7 81       	ldd	r31, Z+7	; 0x07
    1e88:	e0 2d       	mov	r30, r0
    1e8a:	82 81       	ldd	r24, Z+2	; 0x02
    1e8c:	93 81       	ldd	r25, Z+3	; 0x03
    1e8e:	90 93 0c 02 	sts	0x020C, r25	; 0x80020c <xNextTaskUnblockTime+0x1>
    1e92:	80 93 0b 02 	sts	0x020B, r24	; 0x80020b <xNextTaskUnblockTime>
    1e96:	20 91 fc 08 	lds	r18, 0x08FC	; 0x8008fc <xTickCount>
    1e9a:	30 91 fd 08 	lds	r19, 0x08FD	; 0x8008fd <xTickCount+0x1>
    1e9e:	80 91 0b 02 	lds	r24, 0x020B	; 0x80020b <xNextTaskUnblockTime>
    1ea2:	90 91 0c 02 	lds	r25, 0x020C	; 0x80020c <xNextTaskUnblockTime+0x1>
    1ea6:	28 17       	cp	r18, r24
    1ea8:	39 07       	cpc	r19, r25
    1eaa:	08 f4       	brcc	.+2      	; 0x1eae <vTaskIncrementTick+0xac>
    1eac:	4c c0       	rjmp	.+152    	; 0x1f46 <vTaskIncrementTick+0x144>
    1eae:	e0 91 0a 09 	lds	r30, 0x090A	; 0x80090a <pxDelayedTaskList>
    1eb2:	f0 91 0b 09 	lds	r31, 0x090B	; 0x80090b <pxDelayedTaskList+0x1>
    1eb6:	80 81       	ld	r24, Z
    1eb8:	81 11       	cpse	r24, r1
    1eba:	07 c0       	rjmp	.+14     	; 0x1eca <vTaskIncrementTick+0xc8>
    1ebc:	8f ef       	ldi	r24, 0xFF	; 255
    1ebe:	9f ef       	ldi	r25, 0xFF	; 255
    1ec0:	90 93 0c 02 	sts	0x020C, r25	; 0x80020c <xNextTaskUnblockTime+0x1>
    1ec4:	80 93 0b 02 	sts	0x020B, r24	; 0x80020b <xNextTaskUnblockTime>
    1ec8:	3e c0       	rjmp	.+124    	; 0x1f46 <vTaskIncrementTick+0x144>
    1eca:	e0 91 0a 09 	lds	r30, 0x090A	; 0x80090a <pxDelayedTaskList>
    1ece:	f0 91 0b 09 	lds	r31, 0x090B	; 0x80090b <pxDelayedTaskList+0x1>
    1ed2:	05 80       	ldd	r0, Z+5	; 0x05
    1ed4:	f6 81       	ldd	r31, Z+6	; 0x06
    1ed6:	e0 2d       	mov	r30, r0
    1ed8:	c6 81       	ldd	r28, Z+6	; 0x06
    1eda:	d7 81       	ldd	r29, Z+7	; 0x07
    1edc:	8a 81       	ldd	r24, Y+2	; 0x02
    1ede:	9b 81       	ldd	r25, Y+3	; 0x03
    1ee0:	20 91 fc 08 	lds	r18, 0x08FC	; 0x8008fc <xTickCount>
    1ee4:	30 91 fd 08 	lds	r19, 0x08FD	; 0x8008fd <xTickCount+0x1>
    1ee8:	28 17       	cp	r18, r24
    1eea:	39 07       	cpc	r19, r25
    1eec:	28 f4       	brcc	.+10     	; 0x1ef8 <vTaskIncrementTick+0xf6>
    1eee:	90 93 0c 02 	sts	0x020C, r25	; 0x80020c <xNextTaskUnblockTime+0x1>
    1ef2:	80 93 0b 02 	sts	0x020B, r24	; 0x80020b <xNextTaskUnblockTime>
    1ef6:	27 c0       	rjmp	.+78     	; 0x1f46 <vTaskIncrementTick+0x144>
    1ef8:	8e 01       	movw	r16, r28
    1efa:	0e 5f       	subi	r16, 0xFE	; 254
    1efc:	1f 4f       	sbci	r17, 0xFF	; 255
    1efe:	c8 01       	movw	r24, r16
    1f00:	2b dc       	rcall	.-1962   	; 0x1758 <vListRemove>
    1f02:	8c 89       	ldd	r24, Y+20	; 0x14
    1f04:	9d 89       	ldd	r25, Y+21	; 0x15
    1f06:	89 2b       	or	r24, r25
    1f08:	19 f0       	breq	.+6      	; 0x1f10 <vTaskIncrementTick+0x10e>
    1f0a:	ce 01       	movw	r24, r28
    1f0c:	0c 96       	adiw	r24, 0x0c	; 12
    1f0e:	24 dc       	rcall	.-1976   	; 0x1758 <vListRemove>
    1f10:	8e 89       	ldd	r24, Y+22	; 0x16
    1f12:	90 91 fa 08 	lds	r25, 0x08FA	; 0x8008fa <uxTopReadyPriority>
    1f16:	98 17       	cp	r25, r24
    1f18:	10 f4       	brcc	.+4      	; 0x1f1e <vTaskIncrementTick+0x11c>
    1f1a:	80 93 fa 08 	sts	0x08FA, r24	; 0x8008fa <uxTopReadyPriority>
    1f1e:	90 e0       	ldi	r25, 0x00	; 0
    1f20:	9c 01       	movw	r18, r24
    1f22:	22 0f       	add	r18, r18
    1f24:	33 1f       	adc	r19, r19
    1f26:	22 0f       	add	r18, r18
    1f28:	33 1f       	adc	r19, r19
    1f2a:	22 0f       	add	r18, r18
    1f2c:	33 1f       	adc	r19, r19
    1f2e:	82 0f       	add	r24, r18
    1f30:	93 1f       	adc	r25, r19
    1f32:	b8 01       	movw	r22, r16
    1f34:	82 5e       	subi	r24, 0xE2	; 226
    1f36:	96 4f       	sbci	r25, 0xF6	; 246
    1f38:	b7 db       	rcall	.-2194   	; 0x16a8 <vListInsertEnd>
    1f3a:	b9 cf       	rjmp	.-142    	; 0x1eae <vTaskIncrementTick+0xac>
    1f3c:	80 91 f7 08 	lds	r24, 0x08F7	; 0x8008f7 <uxMissedTicks>
    1f40:	8f 5f       	subi	r24, 0xFF	; 255
    1f42:	80 93 f7 08 	sts	0x08F7, r24	; 0x8008f7 <uxMissedTicks>
    1f46:	df 91       	pop	r29
    1f48:	cf 91       	pop	r28
    1f4a:	1f 91       	pop	r17
    1f4c:	0f 91       	pop	r16
    1f4e:	08 95       	ret

00001f50 <xTaskResumeAll>:
    1f50:	ff 92       	push	r15
    1f52:	0f 93       	push	r16
    1f54:	1f 93       	push	r17
    1f56:	cf 93       	push	r28
    1f58:	df 93       	push	r29
    1f5a:	0f b6       	in	r0, 0x3f	; 63
    1f5c:	f8 94       	cli
    1f5e:	0f 92       	push	r0
    1f60:	80 91 f8 08 	lds	r24, 0x08F8	; 0x8008f8 <uxSchedulerSuspended>
    1f64:	81 50       	subi	r24, 0x01	; 1
    1f66:	80 93 f8 08 	sts	0x08F8, r24	; 0x8008f8 <uxSchedulerSuspended>
    1f6a:	80 91 f8 08 	lds	r24, 0x08F8	; 0x8008f8 <uxSchedulerSuspended>
    1f6e:	81 11       	cpse	r24, r1
    1f70:	55 c0       	rjmp	.+170    	; 0x201c <xTaskResumeAll+0xcc>
    1f72:	80 91 fe 08 	lds	r24, 0x08FE	; 0x8008fe <uxCurrentNumberOfTasks>
    1f76:	81 11       	cpse	r24, r1
    1f78:	2f c0       	rjmp	.+94     	; 0x1fd8 <xTaskResumeAll+0x88>
    1f7a:	53 c0       	rjmp	.+166    	; 0x2022 <xTaskResumeAll+0xd2>
    1f7c:	e0 91 04 09 	lds	r30, 0x0904	; 0x800904 <xPendingReadyList+0x5>
    1f80:	f0 91 05 09 	lds	r31, 0x0905	; 0x800905 <xPendingReadyList+0x6>
    1f84:	c6 81       	ldd	r28, Z+6	; 0x06
    1f86:	d7 81       	ldd	r29, Z+7	; 0x07
    1f88:	ce 01       	movw	r24, r28
    1f8a:	0c 96       	adiw	r24, 0x0c	; 12
    1f8c:	e5 db       	rcall	.-2102   	; 0x1758 <vListRemove>
    1f8e:	8e 01       	movw	r16, r28
    1f90:	0e 5f       	subi	r16, 0xFE	; 254
    1f92:	1f 4f       	sbci	r17, 0xFF	; 255
    1f94:	c8 01       	movw	r24, r16
    1f96:	e0 db       	rcall	.-2112   	; 0x1758 <vListRemove>
    1f98:	8e 89       	ldd	r24, Y+22	; 0x16
    1f9a:	90 91 fa 08 	lds	r25, 0x08FA	; 0x8008fa <uxTopReadyPriority>
    1f9e:	98 17       	cp	r25, r24
    1fa0:	10 f4       	brcc	.+4      	; 0x1fa6 <xTaskResumeAll+0x56>
    1fa2:	80 93 fa 08 	sts	0x08FA, r24	; 0x8008fa <uxTopReadyPriority>
    1fa6:	90 e0       	ldi	r25, 0x00	; 0
    1fa8:	9c 01       	movw	r18, r24
    1faa:	22 0f       	add	r18, r18
    1fac:	33 1f       	adc	r19, r19
    1fae:	22 0f       	add	r18, r18
    1fb0:	33 1f       	adc	r19, r19
    1fb2:	22 0f       	add	r18, r18
    1fb4:	33 1f       	adc	r19, r19
    1fb6:	82 0f       	add	r24, r18
    1fb8:	93 1f       	adc	r25, r19
    1fba:	b8 01       	movw	r22, r16
    1fbc:	82 5e       	subi	r24, 0xE2	; 226
    1fbe:	96 4f       	sbci	r25, 0xF6	; 246
    1fc0:	73 db       	rcall	.-2330   	; 0x16a8 <vListInsertEnd>
    1fc2:	9e 89       	ldd	r25, Y+22	; 0x16
    1fc4:	e0 91 27 09 	lds	r30, 0x0927	; 0x800927 <pxCurrentTCB>
    1fc8:	f0 91 28 09 	lds	r31, 0x0928	; 0x800928 <pxCurrentTCB+0x1>
    1fcc:	86 89       	ldd	r24, Z+22	; 0x16
    1fce:	98 17       	cp	r25, r24
    1fd0:	20 f0       	brcs	.+8      	; 0x1fda <xTaskResumeAll+0x8a>
    1fd2:	ff 24       	eor	r15, r15
    1fd4:	f3 94       	inc	r15
    1fd6:	01 c0       	rjmp	.+2      	; 0x1fda <xTaskResumeAll+0x8a>
    1fd8:	f1 2c       	mov	r15, r1
    1fda:	80 91 ff 08 	lds	r24, 0x08FF	; 0x8008ff <xPendingReadyList>
    1fde:	81 11       	cpse	r24, r1
    1fe0:	cd cf       	rjmp	.-102    	; 0x1f7c <xTaskResumeAll+0x2c>
    1fe2:	80 91 f7 08 	lds	r24, 0x08F7	; 0x8008f7 <uxMissedTicks>
    1fe6:	81 11       	cpse	r24, r1
    1fe8:	07 c0       	rjmp	.+14     	; 0x1ff8 <xTaskResumeAll+0xa8>
    1fea:	0c c0       	rjmp	.+24     	; 0x2004 <xTaskResumeAll+0xb4>
    1fec:	0a df       	rcall	.-492    	; 0x1e02 <vTaskIncrementTick>
    1fee:	80 91 f7 08 	lds	r24, 0x08F7	; 0x8008f7 <uxMissedTicks>
    1ff2:	81 50       	subi	r24, 0x01	; 1
    1ff4:	80 93 f7 08 	sts	0x08F7, r24	; 0x8008f7 <uxMissedTicks>
    1ff8:	80 91 f7 08 	lds	r24, 0x08F7	; 0x8008f7 <uxMissedTicks>
    1ffc:	81 11       	cpse	r24, r1
    1ffe:	f6 cf       	rjmp	.-20     	; 0x1fec <xTaskResumeAll+0x9c>
    2000:	ff 24       	eor	r15, r15
    2002:	f3 94       	inc	r15
    2004:	81 e0       	ldi	r24, 0x01	; 1
    2006:	f8 16       	cp	r15, r24
    2008:	21 f0       	breq	.+8      	; 0x2012 <xTaskResumeAll+0xc2>
    200a:	80 91 f6 08 	lds	r24, 0x08F6	; 0x8008f6 <xMissedYield>
    200e:	81 30       	cpi	r24, 0x01	; 1
    2010:	39 f4       	brne	.+14     	; 0x2020 <xTaskResumeAll+0xd0>
    2012:	10 92 f6 08 	sts	0x08F6, r1	; 0x8008f6 <xMissedYield>
    2016:	73 dc       	rcall	.-1818   	; 0x18fe <vPortYield>
    2018:	81 e0       	ldi	r24, 0x01	; 1
    201a:	03 c0       	rjmp	.+6      	; 0x2022 <xTaskResumeAll+0xd2>
    201c:	80 e0       	ldi	r24, 0x00	; 0
    201e:	01 c0       	rjmp	.+2      	; 0x2022 <xTaskResumeAll+0xd2>
    2020:	80 e0       	ldi	r24, 0x00	; 0
    2022:	0f 90       	pop	r0
    2024:	0f be       	out	0x3f, r0	; 63
    2026:	df 91       	pop	r29
    2028:	cf 91       	pop	r28
    202a:	1f 91       	pop	r17
    202c:	0f 91       	pop	r16
    202e:	ff 90       	pop	r15
    2030:	08 95       	ret

00002032 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    2032:	cf 93       	push	r28
    2034:	df 93       	push	r29
    2036:	ec 01       	movw	r28, r24
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    2038:	89 2b       	or	r24, r25
    203a:	89 f0       	breq	.+34     	; 0x205e <vTaskDelay+0x2c>
		{
			vTaskSuspendAll();
    203c:	dc de       	rcall	.-584    	; 0x1df6 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    203e:	80 91 fc 08 	lds	r24, 0x08FC	; 0x8008fc <xTickCount>
    2042:	90 91 fd 08 	lds	r25, 0x08FD	; 0x8008fd <xTickCount+0x1>
    2046:	c8 0f       	add	r28, r24
    2048:	d9 1f       	adc	r29, r25

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    204a:	80 91 27 09 	lds	r24, 0x0927	; 0x800927 <pxCurrentTCB>
    204e:	90 91 28 09 	lds	r25, 0x0928	; 0x800928 <pxCurrentTCB+0x1>
    2052:	02 96       	adiw	r24, 0x02	; 2
    2054:	81 db       	rcall	.-2302   	; 0x1758 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    2056:	ce 01       	movw	r24, r28
    2058:	b8 dd       	rcall	.-1168   	; 0x1bca <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    205a:	7a df       	rcall	.-268    	; 0x1f50 <xTaskResumeAll>
    205c:	01 c0       	rjmp	.+2      	; 0x2060 <vTaskDelay+0x2e>
#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    205e:	80 e0       	ldi	r24, 0x00	; 0
			xAlreadyYielded = xTaskResumeAll();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    2060:	81 11       	cpse	r24, r1
    2062:	01 c0       	rjmp	.+2      	; 0x2066 <vTaskDelay+0x34>
		{
			portYIELD_WITHIN_API();
    2064:	4c dc       	rcall	.-1896   	; 0x18fe <vPortYield>
    2066:	df 91       	pop	r29
		}
	}
    2068:	cf 91       	pop	r28
    206a:	08 95       	ret

0000206c <vTaskSwitchContext>:
    206c:	80 91 f8 08 	lds	r24, 0x08F8	; 0x8008f8 <uxSchedulerSuspended>
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    2070:	88 23       	and	r24, r24
    2072:	49 f0       	breq	.+18     	; 0x2086 <vTaskSwitchContext+0x1a>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    2074:	81 e0       	ldi	r24, 0x01	; 1
    2076:	80 93 f6 08 	sts	0x08F6, r24	; 0x8008f6 <xMissedYield>
    207a:	08 95       	ret
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    207c:	80 91 fa 08 	lds	r24, 0x08FA	; 0x8008fa <uxTopReadyPriority>
    2080:	81 50       	subi	r24, 0x01	; 1
    2082:	80 93 fa 08 	sts	0x08FA, r24	; 0x8008fa <uxTopReadyPriority>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    2086:	80 91 fa 08 	lds	r24, 0x08FA	; 0x8008fa <uxTopReadyPriority>
    208a:	90 e0       	ldi	r25, 0x00	; 0
    208c:	fc 01       	movw	r30, r24
    208e:	ee 0f       	add	r30, r30
    2090:	ff 1f       	adc	r31, r31
    2092:	ee 0f       	add	r30, r30
    2094:	ff 1f       	adc	r31, r31
    2096:	ee 0f       	add	r30, r30
    2098:	ff 1f       	adc	r31, r31
    209a:	8e 0f       	add	r24, r30
    209c:	9f 1f       	adc	r25, r31
    209e:	fc 01       	movw	r30, r24
    20a0:	e2 5e       	subi	r30, 0xE2	; 226
    20a2:	f6 4f       	sbci	r31, 0xF6	; 246
    20a4:	80 81       	ld	r24, Z
    20a6:	88 23       	and	r24, r24
    20a8:	49 f3       	breq	.-46     	; 0x207c <vTaskSwitchContext+0x10>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    20aa:	80 91 fa 08 	lds	r24, 0x08FA	; 0x8008fa <uxTopReadyPriority>
    20ae:	90 e0       	ldi	r25, 0x00	; 0
    20b0:	9c 01       	movw	r18, r24
    20b2:	22 0f       	add	r18, r18
    20b4:	33 1f       	adc	r19, r19
    20b6:	22 0f       	add	r18, r18
    20b8:	33 1f       	adc	r19, r19
    20ba:	22 0f       	add	r18, r18
    20bc:	33 1f       	adc	r19, r19
    20be:	28 0f       	add	r18, r24
    20c0:	39 1f       	adc	r19, r25
    20c2:	d9 01       	movw	r26, r18
    20c4:	a2 5e       	subi	r26, 0xE2	; 226
    20c6:	b6 4f       	sbci	r27, 0xF6	; 246
    20c8:	11 96       	adiw	r26, 0x01	; 1
    20ca:	ed 91       	ld	r30, X+
    20cc:	fc 91       	ld	r31, X
    20ce:	12 97       	sbiw	r26, 0x02	; 2
    20d0:	02 80       	ldd	r0, Z+2	; 0x02
    20d2:	f3 81       	ldd	r31, Z+3	; 0x03
    20d4:	e0 2d       	mov	r30, r0
    20d6:	12 96       	adiw	r26, 0x02	; 2
    20d8:	fc 93       	st	X, r31
    20da:	ee 93       	st	-X, r30
    20dc:	11 97       	sbiw	r26, 0x01	; 1
    20de:	2f 5d       	subi	r18, 0xDF	; 223
    20e0:	36 4f       	sbci	r19, 0xF6	; 246
    20e2:	e2 17       	cp	r30, r18
    20e4:	f3 07       	cpc	r31, r19
    20e6:	29 f4       	brne	.+10     	; 0x20f2 <vTaskSwitchContext+0x86>
    20e8:	22 81       	ldd	r18, Z+2	; 0x02
    20ea:	33 81       	ldd	r19, Z+3	; 0x03
    20ec:	fd 01       	movw	r30, r26
    20ee:	32 83       	std	Z+2, r19	; 0x02
    20f0:	21 83       	std	Z+1, r18	; 0x01
    20f2:	fc 01       	movw	r30, r24
    20f4:	ee 0f       	add	r30, r30
    20f6:	ff 1f       	adc	r31, r31
    20f8:	ee 0f       	add	r30, r30
    20fa:	ff 1f       	adc	r31, r31
    20fc:	ee 0f       	add	r30, r30
    20fe:	ff 1f       	adc	r31, r31
    2100:	8e 0f       	add	r24, r30
    2102:	9f 1f       	adc	r25, r31
    2104:	fc 01       	movw	r30, r24
    2106:	e2 5e       	subi	r30, 0xE2	; 226
    2108:	f6 4f       	sbci	r31, 0xF6	; 246
    210a:	01 80       	ldd	r0, Z+1	; 0x01
    210c:	f2 81       	ldd	r31, Z+2	; 0x02
    210e:	e0 2d       	mov	r30, r0
    2110:	86 81       	ldd	r24, Z+6	; 0x06
    2112:	97 81       	ldd	r25, Z+7	; 0x07
    2114:	90 93 28 09 	sts	0x0928, r25	; 0x800928 <pxCurrentTCB+0x1>
    2118:	80 93 27 09 	sts	0x0927, r24	; 0x800927 <pxCurrentTCB>
    211c:	08 95       	ret

0000211e <_Z12WriteCommandj>:
}

void DisplayOff()
{
	// Send command DisplayOff which is 0x28 in HEX.
	WriteCommand(0x28);
    211e:	2b b1       	in	r18, 0x0b	; 11
    2120:	2f 77       	andi	r18, 0x7F	; 127
    2122:	2b b9       	out	0x0b, r18	; 11
    2124:	24 b3       	in	r18, 0x14	; 20
    2126:	2d 7f       	andi	r18, 0xFD	; 253
    2128:	24 bb       	out	0x14, r18	; 20
    212a:	00 00       	nop
    212c:	92 b9       	out	0x02, r25	; 2
    212e:	88 b9       	out	0x08, r24	; 8
    2130:	84 b3       	in	r24, 0x14	; 20
    2132:	8b 7f       	andi	r24, 0xFB	; 251
    2134:	84 bb       	out	0x14, r24	; 20
    2136:	00 00       	nop
    2138:	84 b3       	in	r24, 0x14	; 20
    213a:	84 60       	ori	r24, 0x04	; 4
    213c:	84 bb       	out	0x14, r24	; 20
    213e:	00 00       	nop
    2140:	84 b3       	in	r24, 0x14	; 20
    2142:	82 60       	ori	r24, 0x02	; 2
    2144:	84 bb       	out	0x14, r24	; 20
    2146:	08 95       	ret

00002148 <_Z9WriteDataj>:
    2148:	2b b1       	in	r18, 0x0b	; 11
    214a:	20 68       	ori	r18, 0x80	; 128
    214c:	2b b9       	out	0x0b, r18	; 11
    214e:	24 b3       	in	r18, 0x14	; 20
    2150:	2d 7f       	andi	r18, 0xFD	; 253
    2152:	24 bb       	out	0x14, r18	; 20
    2154:	00 00       	nop
    2156:	92 b9       	out	0x02, r25	; 2
    2158:	88 b9       	out	0x08, r24	; 8
    215a:	84 b3       	in	r24, 0x14	; 20
    215c:	8b 7f       	andi	r24, 0xFB	; 251
    215e:	84 bb       	out	0x14, r24	; 20
    2160:	00 00       	nop
    2162:	84 b3       	in	r24, 0x14	; 20
    2164:	84 60       	ori	r24, 0x04	; 4
    2166:	84 bb       	out	0x14, r24	; 20
    2168:	00 00       	nop
    216a:	84 b3       	in	r24, 0x14	; 20
    216c:	82 60       	ori	r24, 0x02	; 2
    216e:	84 bb       	out	0x14, r24	; 20
    2170:	08 95       	ret

00002172 <_Z9DisplayOnv>:
}

void DisplayOn()
{
	// Send command DisplayOn which is 0x29 in HEX.
	WriteCommand(0x29);
    2172:	89 e2       	ldi	r24, 0x29	; 41
    2174:	90 e0       	ldi	r25, 0x00	; 0
    2176:	d3 cf       	rjmp	.-90     	; 0x211e <_Z12WriteCommandj>
    2178:	08 95       	ret

0000217a <_Z8SleepOutv>:
}

void SleepOut()
{
	// Send command SleepOut which is 0x11 in HEX. 
	WriteCommand(0x11);
    217a:	81 e1       	ldi	r24, 0x11	; 17
    217c:	90 e0       	ldi	r25, 0x00	; 0
    217e:	cf cf       	rjmp	.-98     	; 0x211e <_Z12WriteCommandj>
    2180:	08 95       	ret

00002182 <_Z19MemoryAccessControlh>:
}

void MemoryAccessControl(unsigned char parameter)
{
    2182:	cf 93       	push	r28
    2184:	c8 2f       	mov	r28, r24
	WriteCommand(0x36);
    2186:	86 e3       	ldi	r24, 0x36	; 54
    2188:	90 e0       	ldi	r25, 0x00	; 0
    218a:	c9 df       	rcall	.-110    	; 0x211e <_Z12WriteCommandj>
	WriteData(parameter);
    218c:	8c 2f       	mov	r24, r28
    218e:	90 e0       	ldi	r25, 0x00	; 0
    2190:	db df       	rcall	.-74     	; 0x2148 <_Z9WriteDataj>
}
    2192:	cf 91       	pop	r28
    2194:	08 95       	ret

00002196 <_Z20InterfacePixelFormath>:

void InterfacePixelFormat(unsigned char parameter)
{
    2196:	cf 93       	push	r28
    2198:	c8 2f       	mov	r28, r24
	WriteCommand(0x3A);
    219a:	8a e3       	ldi	r24, 0x3A	; 58
    219c:	90 e0       	ldi	r25, 0x00	; 0
    219e:	bf df       	rcall	.-130    	; 0x211e <_Z12WriteCommandj>
	WriteData(parameter);
    21a0:	8c 2f       	mov	r24, r28
    21a2:	90 e0       	ldi	r25, 0x00	; 0
    21a4:	d1 df       	rcall	.-94     	; 0x2148 <_Z9WriteDataj>
}
    21a6:	cf 91       	pop	r28
    21a8:	08 95       	ret

000021aa <_Z11DisplayInitv>:

// Initializes (resets) the display
void DisplayInit()
{
	// Control pins are outputs
	DDRG |= 0b00000111;
    21aa:	83 b3       	in	r24, 0x13	; 19
    21ac:	87 60       	ori	r24, 0x07	; 7
    21ae:	83 bb       	out	0x13, r24	; 19
	DDRD |= 0b10000000;
    21b0:	8a b1       	in	r24, 0x0a	; 10
    21b2:	80 68       	ori	r24, 0x80	; 128
    21b4:	8a b9       	out	0x0a, r24	; 10
	
	// Data pins are outputs
	DDRA = 0xFF;
    21b6:	8f ef       	ldi	r24, 0xFF	; 255
    21b8:	81 b9       	out	0x01, r24	; 1
	DDRC = 0xFF;
    21ba:	87 b9       	out	0x07, r24	; 7
	
	// All control pins high;
	PORTG |= 0b00000111;
    21bc:	84 b3       	in	r24, 0x14	; 20
    21be:	87 60       	ori	r24, 0x07	; 7
    21c0:	84 bb       	out	0x14, r24	; 20
	PORTD |= 0b10000000;
    21c2:	8b b1       	in	r24, 0x0b	; 11
    21c4:	80 68       	ori	r24, 0x80	; 128
    21c6:	8b b9       	out	0x0b, r24	; 11
	
	// Pull reset pin - Wait min 10 uS
	RST_PORT &= ~(1 << RST_BIT);
    21c8:	84 b3       	in	r24, 0x14	; 20
    21ca:	8e 7f       	andi	r24, 0xFE	; 254
    21cc:	84 bb       	out	0x14, r24	; 20
	vTaskDelay( 500 / portTICK_RATE_MS );
    21ce:	84 ef       	ldi	r24, 0xF4	; 244
    21d0:	91 e0       	ldi	r25, 0x01	; 1
    21d2:	2f df       	rcall	.-418    	; 0x2032 <vTaskDelay>
	RST_PORT |= (1 << RST_BIT);
    21d4:	84 b3       	in	r24, 0x14	; 20
    21d6:	81 60       	ori	r24, 0x01	; 1
    21d8:	84 bb       	out	0x14, r24	; 20
	
	// Wait for display to be rdy
	vTaskDelay( 500 / portTICK_RATE_MS );
    21da:	84 ef       	ldi	r24, 0xF4	; 244
    21dc:	91 e0       	ldi	r25, 0x01	; 1
    21de:	29 df       	rcall	.-430    	; 0x2032 <vTaskDelay>
	
	// Set pixel interface and memoryaccesscontrol
	InterfacePixelFormat(0b00000101);
    21e0:	85 e0       	ldi	r24, 0x05	; 5
    21e2:	d9 df       	rcall	.-78     	; 0x2196 <_Z20InterfacePixelFormath>
	MemoryAccessControl(0b00001000);
    21e4:	88 e0       	ldi	r24, 0x08	; 8
    21e6:	cd df       	rcall	.-102    	; 0x2182 <_Z19MemoryAccessControlh>
	
	// Call sleepout and display on.
	SleepOut();
    21e8:	c8 df       	rcall	.-112    	; 0x217a <_Z8SleepOutv>
    21ea:	c3 cf       	rjmp	.-122    	; 0x2172 <_Z9DisplayOnv>
	DisplayOn();
    21ec:	08 95       	ret

000021ee <_Z11MemoryWritev>:
    21ee:	8c e2       	ldi	r24, 0x2C	; 44
    21f0:	90 e0       	ldi	r25, 0x00	; 0
	WriteData(parameter);
}

void MemoryWrite()
{
	WriteCommand(0x2C);
    21f2:	95 cf       	rjmp	.-214    	; 0x211e <_Z12WriteCommandj>
    21f4:	08 95       	ret

000021f6 <_Z10WritePixelhhh>:
}

// Red 0-31, Green 0-63, Blue 0-31
void WritePixel(unsigned char Red, unsigned char Green, unsigned char Blue)
{
	uint16_t toSend = (Red << 11U) | (Green << 5U) | (Blue);
    21f6:	90 e0       	ldi	r25, 0x00	; 0
    21f8:	98 2f       	mov	r25, r24
    21fa:	88 27       	eor	r24, r24
    21fc:	99 0f       	add	r25, r25
    21fe:	99 0f       	add	r25, r25
    2200:	99 0f       	add	r25, r25
    2202:	20 e2       	ldi	r18, 0x20	; 32
    2204:	62 9f       	mul	r22, r18
    2206:	b0 01       	movw	r22, r0
    2208:	11 24       	eor	r1, r1
    220a:	86 2b       	or	r24, r22
    220c:	97 2b       	or	r25, r23
	WriteData(toSend);
    220e:	84 2b       	or	r24, r20
    2210:	9b cf       	rjmp	.-202    	; 0x2148 <_Z9WriteDataj>
    2212:	08 95       	ret

00002214 <_Z16SetColumnAddressjj>:
}

// Set Column Address (0-239), Start > End
void SetColumnAddress(unsigned int Start, unsigned int End)
{
    2214:	0f 93       	push	r16
    2216:	1f 93       	push	r17
    2218:	cf 93       	push	r28
    221a:	df 93       	push	r29
	if (Start < End)
    221c:	86 17       	cp	r24, r22
    221e:	97 07       	cpc	r25, r23
    2220:	78 f4       	brcc	.+30     	; 0x2240 <_Z16SetColumnAddressjj+0x2c>
    2222:	eb 01       	movw	r28, r22
    2224:	8c 01       	movw	r16, r24
	{
		WriteCommand(0x2A);
    2226:	8a e2       	ldi	r24, 0x2A	; 42
    2228:	90 e0       	ldi	r25, 0x00	; 0
    222a:	79 df       	rcall	.-270    	; 0x211e <_Z12WriteCommandj>
		WriteData(Start >> 8U);
    222c:	81 2f       	mov	r24, r17
    222e:	90 e0       	ldi	r25, 0x00	; 0
    2230:	8b df       	rcall	.-234    	; 0x2148 <_Z9WriteDataj>
		WriteData(Start);
    2232:	c8 01       	movw	r24, r16
    2234:	89 df       	rcall	.-238    	; 0x2148 <_Z9WriteDataj>
		WriteData(End >> 8U);
    2236:	8d 2f       	mov	r24, r29
    2238:	90 e0       	ldi	r25, 0x00	; 0
    223a:	86 df       	rcall	.-244    	; 0x2148 <_Z9WriteDataj>
		WriteData(End);
    223c:	ce 01       	movw	r24, r28
    223e:	84 df       	rcall	.-248    	; 0x2148 <_Z9WriteDataj>
    2240:	df 91       	pop	r29
	}
}
    2242:	cf 91       	pop	r28
    2244:	1f 91       	pop	r17
    2246:	0f 91       	pop	r16
    2248:	08 95       	ret

0000224a <_Z14SetPageAddressjj>:
    224a:	0f 93       	push	r16

// Set Page Address (0-319), Start > End
void SetPageAddress(unsigned int Start, unsigned int End)
{
    224c:	1f 93       	push	r17
    224e:	cf 93       	push	r28
    2250:	df 93       	push	r29
	if (Start < End)
    2252:	86 17       	cp	r24, r22
    2254:	97 07       	cpc	r25, r23
    2256:	78 f4       	brcc	.+30     	; 0x2276 <_Z14SetPageAddressjj+0x2c>
    2258:	eb 01       	movw	r28, r22
    225a:	8c 01       	movw	r16, r24
	{
		WriteCommand(0x2B);
    225c:	8b e2       	ldi	r24, 0x2B	; 43
    225e:	90 e0       	ldi	r25, 0x00	; 0
    2260:	5e df       	rcall	.-324    	; 0x211e <_Z12WriteCommandj>
		WriteData(Start >> 8U);
    2262:	81 2f       	mov	r24, r17
    2264:	90 e0       	ldi	r25, 0x00	; 0
    2266:	70 df       	rcall	.-288    	; 0x2148 <_Z9WriteDataj>
		WriteData(Start);
    2268:	c8 01       	movw	r24, r16
    226a:	6e df       	rcall	.-292    	; 0x2148 <_Z9WriteDataj>
		WriteData(End >> 8U);
    226c:	8d 2f       	mov	r24, r29
    226e:	90 e0       	ldi	r25, 0x00	; 0
    2270:	6b df       	rcall	.-298    	; 0x2148 <_Z9WriteDataj>
		WriteData(End);
    2272:	ce 01       	movw	r24, r28
    2274:	69 df       	rcall	.-302    	; 0x2148 <_Z9WriteDataj>
    2276:	df 91       	pop	r29
	}
}
    2278:	cf 91       	pop	r28
    227a:	1f 91       	pop	r17
    227c:	0f 91       	pop	r16
    227e:	08 95       	ret

00002280 <_Z13FillRectanglejjjjhhh>:
    2280:	6f 92       	push	r6
// Fills rectangle with specified color
// (StartX,StartY) = Upper left corner. X horizontal (0-319) , Y vertical (0-239).
// Height (1-240) is vertical. Width (1-320) is horizontal.
// R-G-B = 5-6-5 bits.
void FillRectangle(unsigned int StartX, unsigned int StartY, unsigned int Width, unsigned int Height, unsigned char Blue, unsigned char Green, unsigned char Red)
{
    2282:	7f 92       	push	r7
    2284:	8f 92       	push	r8
    2286:	9f 92       	push	r9
    2288:	af 92       	push	r10
    228a:	bf 92       	push	r11
    228c:	cf 92       	push	r12
    228e:	ef 92       	push	r14
    2290:	0f 93       	push	r16
    2292:	cf 93       	push	r28
    2294:	df 93       	push	r29
    2296:	5b 01       	movw	r10, r22
    2298:	3a 01       	movw	r6, r20
    229a:	e9 01       	movw	r28, r18
	SetPageAddress(StartX,StartX+Width-1);
    229c:	bc 01       	movw	r22, r24
    229e:	64 0f       	add	r22, r20
    22a0:	75 1f       	adc	r23, r21
    22a2:	61 50       	subi	r22, 0x01	; 1
    22a4:	71 09       	sbc	r23, r1
    22a6:	d1 df       	rcall	.-94     	; 0x224a <_Z14SetPageAddressjj>
	SetColumnAddress(StartY,StartY+Height-1);
    22a8:	b5 01       	movw	r22, r10
    22aa:	6c 0f       	add	r22, r28
    22ac:	7d 1f       	adc	r23, r29
    22ae:	61 50       	subi	r22, 0x01	; 1
    22b0:	71 09       	sbc	r23, r1
    22b2:	c5 01       	movw	r24, r10
	MemoryWrite();
    22b4:	af df       	rcall	.-162    	; 0x2214 <_Z16SetColumnAddressjj>
    22b6:	9b df       	rcall	.-202    	; 0x21ee <_Z11MemoryWritev>
	
	for (uint32_t counter = 0; counter < (uint32_t)Width*Height; counter++)
    22b8:	81 2c       	mov	r8, r1
    22ba:	91 2c       	mov	r9, r1
    22bc:	54 01       	movw	r10, r8
    22be:	93 01       	movw	r18, r6
    22c0:	de 01       	movw	r26, r28
    22c2:	3f d4       	rcall	.+2174   	; 0x2b42 <__umulhisi3>
    22c4:	86 16       	cp	r8, r22
    22c6:	97 06       	cpc	r9, r23
    22c8:	a8 06       	cpc	r10, r24
    22ca:	b9 06       	cpc	r11, r25
	{
		WritePixel(Red,Green,Blue);
    22cc:	50 f4       	brcc	.+20     	; 0x22e2 <_Z13FillRectanglejjjjhhh+0x62>
    22ce:	40 2f       	mov	r20, r16
    22d0:	6e 2d       	mov	r22, r14
    22d2:	8c 2d       	mov	r24, r12
    22d4:	90 df       	rcall	.-224    	; 0x21f6 <_Z10WritePixelhhh>
{
	SetPageAddress(StartX,StartX+Width-1);
	SetColumnAddress(StartY,StartY+Height-1);
	MemoryWrite();
	
	for (uint32_t counter = 0; counter < (uint32_t)Width*Height; counter++)
    22d6:	8f ef       	ldi	r24, 0xFF	; 255
    22d8:	88 1a       	sub	r8, r24
    22da:	98 0a       	sbc	r9, r24
    22dc:	a8 0a       	sbc	r10, r24
    22de:	b8 0a       	sbc	r11, r24
	{
		WritePixel(Red,Green,Blue);
	}
	SleepOut();
    22e0:	ee cf       	rjmp	.-36     	; 0x22be <_Z13FillRectanglejjjjhhh+0x3e>
    22e2:	4b df       	rcall	.-362    	; 0x217a <_Z8SleepOutv>
}
    22e4:	df 91       	pop	r29
    22e6:	cf 91       	pop	r28
    22e8:	0f 91       	pop	r16
    22ea:	ef 90       	pop	r14
    22ec:	cf 90       	pop	r12
    22ee:	bf 90       	pop	r11
    22f0:	af 90       	pop	r10
    22f2:	9f 90       	pop	r9
    22f4:	8f 90       	pop	r8
    22f6:	7f 90       	pop	r7
    22f8:	6f 90       	pop	r6
    22fa:	08 95       	ret

000022fc <_ZN11TouchscreenC1Ev>:
#include "TouchDriver.h"
#include "TFTdriver.h"
#include "ButtonClass.h"


Touchscreen::Touchscreen()
    22fc:	0f 93       	push	r16
    22fe:	1f 93       	push	r17
    2300:	cf 93       	push	r28
    2302:	df 93       	push	r29
    2304:	cd b7       	in	r28, 0x3d	; 61
    2306:	de b7       	in	r29, 0x3e	; 62
    2308:	66 97       	sbiw	r28, 0x16	; 22
    230a:	0f b6       	in	r0, 0x3f	; 63
    230c:	f8 94       	cli
    230e:	de bf       	out	0x3e, r29	; 62
    2310:	0f be       	out	0x3f, r0	; 63
    2312:	cd bf       	out	0x3d, r28	; 61
    2314:	8c 01       	movw	r16, r24
    2316:	36 d1       	rcall	.+620    	; 0x2584 <_ZN11TouchDriverC1Ev>
{
	
	public:
	ButtonClass()
	{
		startX = 0;
    2318:	f8 01       	movw	r30, r16
    231a:	12 82       	std	Z+2, r1	; 0x02
		startY = 0;
    231c:	13 82       	std	Z+3, r1	; 0x03
		height = 0;
    231e:	14 82       	std	Z+4, r1	; 0x04
		width = 0;
    2320:	15 82       	std	Z+5, r1	; 0x05
		colorRed = 0;
    2322:	16 82       	std	Z+6, r1	; 0x06
		colorBlue = 0;
    2324:	17 82       	std	Z+7, r1	; 0x07
		colorGreen = 0;
    2326:	10 86       	std	Z+8, r1	; 0x08
		endX = 0;
    2328:	12 86       	std	Z+10, r1	; 0x0a
    232a:	11 86       	std	Z+9, r1	; 0x09
		endY = 0;
    232c:	13 86       	std	Z+11, r1	; 0x0b
{
	
	public:
	ButtonClass()
	{
		startX = 0;
    232e:	14 86       	std	Z+12, r1	; 0x0c
		startY = 0;
    2330:	15 86       	std	Z+13, r1	; 0x0d
		height = 0;
    2332:	16 86       	std	Z+14, r1	; 0x0e
		width = 0;
    2334:	17 86       	std	Z+15, r1	; 0x0f
		colorRed = 0;
    2336:	10 8a       	std	Z+16, r1	; 0x10
		colorBlue = 0;
    2338:	11 8a       	std	Z+17, r1	; 0x11
		colorGreen = 0;
    233a:	12 8a       	std	Z+18, r1	; 0x12
		endX = 0;
    233c:	14 8a       	std	Z+20, r1	; 0x14
    233e:	13 8a       	std	Z+19, r1	; 0x13
		endY = 0;
    2340:	15 8a       	std	Z+21, r1	; 0x15
{
	TouchDriv = TouchDriver();
    2342:	ce 01       	movw	r24, r28
    2344:	45 96       	adiw	r24, 0x15	; 21
    2346:	1e d1       	rcall	.+572    	; 0x2584 <_ZN11TouchDriverC1Ev>
    2348:	8d 89       	ldd	r24, Y+21	; 0x15
    234a:	9e 89       	ldd	r25, Y+22	; 0x16
    234c:	d8 01       	movw	r26, r16
    234e:	8d 93       	st	X+, r24
    2350:	9d 93       	st	X+, r25
	}
	
	ButtonClass(uint8_t StartX, uint8_t StartY, uint16_t EndX, uint8_t EndY, uint8_t ColorRed, uint8_t ColorBlue, uint8_t ColorGreen)
	{
		startX = StartX;
    2352:	84 e1       	ldi	r24, 0x14	; 20
    2354:	8b 87       	std	Y+11, r24	; 0x0b
		startY = StartY;
    2356:	46 e4       	ldi	r20, 0x46	; 70
    2358:	4c 87       	std	Y+12, r20	; 0x0c
		endX = EndX;
    235a:	88 e7       	ldi	r24, 0x78	; 120
    235c:	90 e0       	ldi	r25, 0x00	; 0
    235e:	9b 8b       	std	Y+19, r25	; 0x13
    2360:	8a 8b       	std	Y+18, r24	; 0x12
		endY = EndY;
    2362:	3a ea       	ldi	r19, 0xAA	; 170
    2364:	3c 8b       	std	Y+20, r19	; 0x14
		width = EndX-StartX;
    2366:	84 e6       	ldi	r24, 0x64	; 100
    2368:	8e 87       	std	Y+14, r24	; 0x0e
		height = EndY-StartY;
    236a:	8d 87       	std	Y+13, r24	; 0x0d
		colorRed = ColorRed;
    236c:	9d e1       	ldi	r25, 0x1D	; 29
    236e:	9f 87       	std	Y+15, r25	; 0x0f
		colorBlue = ColorBlue;
    2370:	9a ee       	ldi	r25, 0xEA	; 234
    2372:	98 8b       	std	Y+16, r25	; 0x10
		colorGreen = ColorGreen;
    2374:	22 e0       	ldi	r18, 0x02	; 2
    2376:	29 8b       	std	Y+17, r18	; 0x11
	
	blueBnt = ButtonClass(20, 70, 120, 170, 29, 234, 2);
    2378:	5a e0       	ldi	r21, 0x0A	; 10
    237a:	fe 01       	movw	r30, r28
    237c:	3b 96       	adiw	r30, 0x0b	; 11
    237e:	01 90       	ld	r0, Z+
    2380:	0d 92       	st	X+, r0
    2382:	5a 95       	dec	r21
    2384:	e1 f7       	brne	.-8      	; 0x237e <_ZN11TouchscreenC1Ev+0x82>
		endY = 0;
	}
	
	ButtonClass(uint8_t StartX, uint8_t StartY, uint16_t EndX, uint8_t EndY, uint8_t ColorRed, uint8_t ColorBlue, uint8_t ColorGreen)
	{
		startX = StartX;
    2386:	58 ec       	ldi	r21, 0xC8	; 200
    2388:	59 83       	std	Y+1, r21	; 0x01
		startY = StartY;
    238a:	4a 83       	std	Y+2, r20	; 0x02
		endX = EndX;
    238c:	4c e2       	ldi	r20, 0x2C	; 44
    238e:	51 e0       	ldi	r21, 0x01	; 1
    2390:	59 87       	std	Y+9, r21	; 0x09
    2392:	48 87       	std	Y+8, r20	; 0x08
		endY = EndY;
    2394:	3a 87       	std	Y+10, r19	; 0x0a
		width = EndX-StartX;
    2396:	8c 83       	std	Y+4, r24	; 0x04
		height = EndY-StartY;
    2398:	8b 83       	std	Y+3, r24	; 0x03
		colorRed = ColorRed;
    239a:	8c e2       	ldi	r24, 0x2C	; 44
    239c:	8d 83       	std	Y+5, r24	; 0x05
		colorBlue = ColorBlue;
    239e:	2e 83       	std	Y+6, r18	; 0x06
		colorGreen = ColorGreen;
    23a0:	9f 83       	std	Y+7, r25	; 0x07
	greenBnt = ButtonClass(200, 70, 300, 170, 44, 2, 234);
    23a2:	8a e0       	ldi	r24, 0x0A	; 10
    23a4:	fe 01       	movw	r30, r28
    23a6:	31 96       	adiw	r30, 0x01	; 1
    23a8:	d8 01       	movw	r26, r16
    23aa:	1c 96       	adiw	r26, 0x0c	; 12
    23ac:	01 90       	ld	r0, Z+
    23ae:	0d 92       	st	X+, r0
    23b0:	8a 95       	dec	r24
	
	DisplayInit();
    23b2:	e1 f7       	brne	.-8      	; 0x23ac <_ZN11TouchscreenC1Ev+0xb0>
    23b4:	fa de       	rcall	.-524    	; 0x21aa <_Z11DisplayInitv>
}
    23b6:	66 96       	adiw	r28, 0x16	; 22
    23b8:	0f b6       	in	r0, 0x3f	; 63
    23ba:	f8 94       	cli
    23bc:	de bf       	out	0x3e, r29	; 62
    23be:	0f be       	out	0x3f, r0	; 63
    23c0:	cd bf       	out	0x3d, r28	; 61
    23c2:	df 91       	pop	r29
    23c4:	cf 91       	pop	r28
    23c6:	1f 91       	pop	r17
    23c8:	0f 91       	pop	r16
    23ca:	08 95       	ret

000023cc <_ZN11Touchscreen12checkButtonsEv>:


uint8_t Touchscreen::checkButtons(void)
{
    23cc:	cf 92       	push	r12
    23ce:	df 92       	push	r13
    23d0:	ef 92       	push	r14
    23d2:	ff 92       	push	r15
    23d4:	0f 93       	push	r16
    23d6:	1f 93       	push	r17
    23d8:	cf 93       	push	r28
    23da:	df 93       	push	r29
    23dc:	1f 92       	push	r1
    23de:	1f 92       	push	r1
    23e0:	cd b7       	in	r28, 0x3d	; 61
    23e2:	de b7       	in	r29, 0x3e	; 62
    23e4:	8c 01       	movw	r16, r24
	uint8_t x = 0;
    23e6:	19 82       	std	Y+1, r1	; 0x01
	uint8_t y = 0;
    23e8:	1a 82       	std	Y+2, r1	; 0x02
	
	TouchDriv.getCoordinates(&x, &y);
    23ea:	ae 01       	movw	r20, r28
    23ec:	4e 5f       	subi	r20, 0xFE	; 254
    23ee:	5f 4f       	sbci	r21, 0xFF	; 255
    23f0:	be 01       	movw	r22, r28
    23f2:	6f 5f       	subi	r22, 0xFF	; 255
    23f4:	7f 4f       	sbci	r23, 0xFF	; 255
    23f6:	63 d1       	rcall	.+710    	; 0x26be <_ZN11TouchDriver14getCoordinatesEPhS0_>
	
	if (x > blueBnt.startX/1.33 && x < blueBnt.endX/1.33 && y > blueBnt.startY && y < blueBnt.endY)
    23f8:	69 81       	ldd	r22, Y+1	; 0x01
    23fa:	70 e0       	ldi	r23, 0x00	; 0
    23fc:	80 e0       	ldi	r24, 0x00	; 0
    23fe:	90 e0       	ldi	r25, 0x00	; 0
    2400:	81 d2       	rcall	.+1282   	; 0x2904 <__floatsisf>
    2402:	6b 01       	movw	r12, r22
    2404:	7c 01       	movw	r14, r24
    2406:	f8 01       	movw	r30, r16
    2408:	62 81       	ldd	r22, Z+2	; 0x02
    240a:	70 e0       	ldi	r23, 0x00	; 0
    240c:	80 e0       	ldi	r24, 0x00	; 0
    240e:	90 e0       	ldi	r25, 0x00	; 0
    2410:	79 d2       	rcall	.+1266   	; 0x2904 <__floatsisf>
    2412:	21 e7       	ldi	r18, 0x71	; 113
    2414:	3d e3       	ldi	r19, 0x3D	; 61
    2416:	4a ea       	ldi	r20, 0xAA	; 170
    2418:	5f e3       	ldi	r21, 0x3F	; 63
    241a:	de d1       	rcall	.+956    	; 0x27d8 <__divsf3>
    241c:	9b 01       	movw	r18, r22
    241e:	ac 01       	movw	r20, r24
    2420:	c7 01       	movw	r24, r14
    2422:	b6 01       	movw	r22, r12
    2424:	1f d3       	rcall	.+1598   	; 0x2a64 <__gesf2>
    2426:	18 16       	cp	r1, r24
    2428:	d4 f4       	brge	.+52     	; 0x245e <_ZN11Touchscreen12checkButtonsEv+0x92>
    242a:	f8 01       	movw	r30, r16
    242c:	61 85       	ldd	r22, Z+9	; 0x09
    242e:	72 85       	ldd	r23, Z+10	; 0x0a
    2430:	80 e0       	ldi	r24, 0x00	; 0
    2432:	90 e0       	ldi	r25, 0x00	; 0
    2434:	65 d2       	rcall	.+1226   	; 0x2900 <__floatunsisf>
    2436:	21 e7       	ldi	r18, 0x71	; 113
    2438:	3d e3       	ldi	r19, 0x3D	; 61
    243a:	4a ea       	ldi	r20, 0xAA	; 170
    243c:	5f e3       	ldi	r21, 0x3F	; 63
    243e:	cc d1       	rcall	.+920    	; 0x27d8 <__divsf3>
    2440:	9b 01       	movw	r18, r22
    2442:	ac 01       	movw	r20, r24
    2444:	c7 01       	movw	r24, r14
    2446:	b6 01       	movw	r22, r12
    2448:	c3 d1       	rcall	.+902    	; 0x27d0 <__cmpsf2>
    244a:	88 23       	and	r24, r24
    244c:	44 f4       	brge	.+16     	; 0x245e <_ZN11Touchscreen12checkButtonsEv+0x92>
    244e:	f8 01       	movw	r30, r16
    2450:	93 81       	ldd	r25, Z+3	; 0x03
    2452:	8a 81       	ldd	r24, Y+2	; 0x02
    2454:	98 17       	cp	r25, r24
    2456:	18 f4       	brcc	.+6      	; 0x245e <_ZN11Touchscreen12checkButtonsEv+0x92>
    2458:	93 85       	ldd	r25, Z+11	; 0x0b
    245a:	89 17       	cp	r24, r25
	{
		return 1;
	}
	else if (x > greenBnt.startX/1.33 && x < greenBnt.endX/1.33 && y > greenBnt.startY && y < greenBnt.endY)
    245c:	70 f1       	brcs	.+92     	; 0x24ba <_ZN11Touchscreen12checkButtonsEv+0xee>
    245e:	f8 01       	movw	r30, r16
    2460:	64 85       	ldd	r22, Z+12	; 0x0c
    2462:	70 e0       	ldi	r23, 0x00	; 0
    2464:	80 e0       	ldi	r24, 0x00	; 0
    2466:	90 e0       	ldi	r25, 0x00	; 0
    2468:	4d d2       	rcall	.+1178   	; 0x2904 <__floatsisf>
    246a:	21 e7       	ldi	r18, 0x71	; 113
    246c:	3d e3       	ldi	r19, 0x3D	; 61
    246e:	4a ea       	ldi	r20, 0xAA	; 170
    2470:	5f e3       	ldi	r21, 0x3F	; 63
    2472:	b2 d1       	rcall	.+868    	; 0x27d8 <__divsf3>
    2474:	9b 01       	movw	r18, r22
    2476:	ac 01       	movw	r20, r24
    2478:	c7 01       	movw	r24, r14
    247a:	b6 01       	movw	r22, r12
    247c:	f3 d2       	rcall	.+1510   	; 0x2a64 <__gesf2>
    247e:	18 16       	cp	r1, r24
    2480:	f4 f4       	brge	.+60     	; 0x24be <_ZN11Touchscreen12checkButtonsEv+0xf2>
    2482:	f8 01       	movw	r30, r16
    2484:	63 89       	ldd	r22, Z+19	; 0x13
    2486:	74 89       	ldd	r23, Z+20	; 0x14
    2488:	80 e0       	ldi	r24, 0x00	; 0
    248a:	90 e0       	ldi	r25, 0x00	; 0
    248c:	39 d2       	rcall	.+1138   	; 0x2900 <__floatunsisf>
    248e:	21 e7       	ldi	r18, 0x71	; 113
    2490:	3d e3       	ldi	r19, 0x3D	; 61
    2492:	4a ea       	ldi	r20, 0xAA	; 170
    2494:	5f e3       	ldi	r21, 0x3F	; 63
    2496:	a0 d1       	rcall	.+832    	; 0x27d8 <__divsf3>
    2498:	9b 01       	movw	r18, r22
    249a:	ac 01       	movw	r20, r24
    249c:	c7 01       	movw	r24, r14
    249e:	b6 01       	movw	r22, r12
    24a0:	97 d1       	rcall	.+814    	; 0x27d0 <__cmpsf2>
    24a2:	88 23       	and	r24, r24
    24a4:	74 f4       	brge	.+28     	; 0x24c2 <_ZN11Touchscreen12checkButtonsEv+0xf6>
    24a6:	f8 01       	movw	r30, r16
    24a8:	95 85       	ldd	r25, Z+13	; 0x0d
    24aa:	8a 81       	ldd	r24, Y+2	; 0x02
    24ac:	98 17       	cp	r25, r24
    24ae:	58 f4       	brcc	.+22     	; 0x24c6 <_ZN11Touchscreen12checkButtonsEv+0xfa>
    24b0:	95 89       	ldd	r25, Z+21	; 0x15
    24b2:	89 17       	cp	r24, r25
    24b4:	50 f0       	brcs	.+20     	; 0x24ca <_ZN11Touchscreen12checkButtonsEv+0xfe>
    24b6:	80 e0       	ldi	r24, 0x00	; 0
	{
		return 2;
	}
	else
	{
		return 0;
    24b8:	09 c0       	rjmp	.+18     	; 0x24cc <_ZN11Touchscreen12checkButtonsEv+0x100>
    24ba:	81 e0       	ldi	r24, 0x01	; 1
	
	TouchDriv.getCoordinates(&x, &y);
	
	if (x > blueBnt.startX/1.33 && x < blueBnt.endX/1.33 && y > blueBnt.startY && y < blueBnt.endY)
	{
		return 1;
    24bc:	07 c0       	rjmp	.+14     	; 0x24cc <_ZN11Touchscreen12checkButtonsEv+0x100>
    24be:	80 e0       	ldi	r24, 0x00	; 0
	{
		return 2;
	}
	else
	{
		return 0;
    24c0:	05 c0       	rjmp	.+10     	; 0x24cc <_ZN11Touchscreen12checkButtonsEv+0x100>
    24c2:	80 e0       	ldi	r24, 0x00	; 0
    24c4:	03 c0       	rjmp	.+6      	; 0x24cc <_ZN11Touchscreen12checkButtonsEv+0x100>
    24c6:	80 e0       	ldi	r24, 0x00	; 0
    24c8:	01 c0       	rjmp	.+2      	; 0x24cc <_ZN11Touchscreen12checkButtonsEv+0x100>
    24ca:	82 e0       	ldi	r24, 0x02	; 2
	{
		return 1;
	}
	else if (x > greenBnt.startX/1.33 && x < greenBnt.endX/1.33 && y > greenBnt.startY && y < greenBnt.endY)
	{
		return 2;
    24cc:	0f 90       	pop	r0
	else
	{
		return 0;
	}
	
}
    24ce:	0f 90       	pop	r0
    24d0:	df 91       	pop	r29
    24d2:	cf 91       	pop	r28
    24d4:	1f 91       	pop	r17
    24d6:	0f 91       	pop	r16
    24d8:	ff 90       	pop	r15
    24da:	ef 90       	pop	r14
    24dc:	df 90       	pop	r13
    24de:	cf 90       	pop	r12
    24e0:	08 95       	ret

000024e2 <_ZN11Touchscreen11clearScreenEv>:
    24e2:	cf 92       	push	r12

void Touchscreen::clearScreen(void)
{
    24e4:	ef 92       	push	r14
    24e6:	0f 93       	push	r16
	// Full Screen White
	FillRectangle(0,0,320,240,255,255,255);
    24e8:	cc 24       	eor	r12, r12
    24ea:	ca 94       	dec	r12
    24ec:	ee 24       	eor	r14, r14
    24ee:	ea 94       	dec	r14
    24f0:	0f ef       	ldi	r16, 0xFF	; 255
    24f2:	20 ef       	ldi	r18, 0xF0	; 240
    24f4:	30 e0       	ldi	r19, 0x00	; 0
    24f6:	40 e4       	ldi	r20, 0x40	; 64
    24f8:	51 e0       	ldi	r21, 0x01	; 1
    24fa:	60 e0       	ldi	r22, 0x00	; 0
    24fc:	70 e0       	ldi	r23, 0x00	; 0
    24fe:	80 e0       	ldi	r24, 0x00	; 0
    2500:	90 e0       	ldi	r25, 0x00	; 0
    2502:	be de       	rcall	.-644    	; 0x2280 <_Z13FillRectanglejjjjhhh>
}
    2504:	0f 91       	pop	r16
    2506:	ef 90       	pop	r14
    2508:	cf 90       	pop	r12
    250a:	08 95       	ret

0000250c <_ZN11Touchscreen23presentButtonsOnDisplayEv>:

void Touchscreen::presentButtonsOnDisplay(void)
{
    250c:	cf 92       	push	r12
    250e:	ef 92       	push	r14
    2510:	0f 93       	push	r16
    2512:	cf 93       	push	r28
    2514:	df 93       	push	r29
    2516:	ec 01       	movw	r28, r24
	
	// Button One
	FillRectangle(blueBnt.startX, blueBnt.startY, blueBnt.width, blueBnt.height, blueBnt.colorRed, blueBnt.colorGreen, blueBnt.colorBlue);
    2518:	cf 80       	ldd	r12, Y+7	; 0x07
    251a:	e8 84       	ldd	r14, Y+8	; 0x08
    251c:	0e 81       	ldd	r16, Y+6	; 0x06
    251e:	2c 81       	ldd	r18, Y+4	; 0x04
    2520:	30 e0       	ldi	r19, 0x00	; 0
    2522:	4d 81       	ldd	r20, Y+5	; 0x05
    2524:	50 e0       	ldi	r21, 0x00	; 0
    2526:	6b 81       	ldd	r22, Y+3	; 0x03
    2528:	70 e0       	ldi	r23, 0x00	; 0
    252a:	8a 81       	ldd	r24, Y+2	; 0x02
    252c:	90 e0       	ldi	r25, 0x00	; 0
    252e:	a8 de       	rcall	.-688    	; 0x2280 <_Z13FillRectanglejjjjhhh>

	// Button Two
	FillRectangle(greenBnt.startX, greenBnt.startY, greenBnt.width, greenBnt.height, greenBnt.colorRed, greenBnt.colorGreen, greenBnt.colorBlue);
    2530:	c9 88       	ldd	r12, Y+17	; 0x11
    2532:	ea 88       	ldd	r14, Y+18	; 0x12
    2534:	08 89       	ldd	r16, Y+16	; 0x10
    2536:	2e 85       	ldd	r18, Y+14	; 0x0e
    2538:	30 e0       	ldi	r19, 0x00	; 0
    253a:	4f 85       	ldd	r20, Y+15	; 0x0f
    253c:	50 e0       	ldi	r21, 0x00	; 0
    253e:	6d 85       	ldd	r22, Y+13	; 0x0d
    2540:	70 e0       	ldi	r23, 0x00	; 0
    2542:	8c 85       	ldd	r24, Y+12	; 0x0c
    2544:	90 e0       	ldi	r25, 0x00	; 0
    2546:	9c de       	rcall	.-712    	; 0x2280 <_Z13FillRectanglejjjjhhh>
}
    2548:	df 91       	pop	r29
    254a:	cf 91       	pop	r28
    254c:	0f 91       	pop	r16
    254e:	ef 90       	pop	r14
    2550:	cf 90       	pop	r12
    2552:	08 95       	ret

00002554 <_ZN11TouchDriver15initTouchDriverEv>:
	/* MODE							= 12bit = High							*/
	/* SER/DFR						= Differential = Low					*/
	/* PD1/PD0						= Device always powered = 11			*/
	/************************************************************************/
	
	dinXByte = 0b10011100;
    2554:	2c e9       	ldi	r18, 0x9C	; 156
    2556:	fc 01       	movw	r30, r24
    2558:	20 83       	st	Z, r18
	dinYByte = 0b11011100;
    255a:	2c ed       	ldi	r18, 0xDC	; 220
    255c:	21 83       	std	Z+1, r18	; 0x01
	
	DDRH |= BIT4;
    255e:	e1 e0       	ldi	r30, 0x01	; 1
    2560:	f1 e0       	ldi	r31, 0x01	; 1
    2562:	80 81       	ld	r24, Z
    2564:	84 60       	ori	r24, 0x04	; 4
    2566:	80 83       	st	Z, r24
	DDRE |= BIT4;
    2568:	8d b1       	in	r24, 0x0d	; 13
    256a:	84 60       	ori	r24, 0x04	; 4
    256c:	8d b9       	out	0x0d, r24	; 13
	DDRG |= BIT6;
    256e:	83 b3       	in	r24, 0x13	; 19
    2570:	86 60       	ori	r24, 0x06	; 6
    2572:	83 bb       	out	0x13, r24	; 19
	
	// Enable Interrupt
	EICRB = 00000010;
    2574:	88 e0       	ldi	r24, 0x08	; 8
    2576:	80 93 6a 00 	sts	0x006A, r24	; 0x80006a <__TEXT_REGION_LENGTH__+0x70006a>
	EIMSK |= 0b00010000;
    257a:	8d b3       	in	r24, 0x1d	; 29
    257c:	80 61       	ori	r24, 0x10	; 16
    257e:	8d bb       	out	0x1d, r24	; 29
	
	sei();
    2580:	78 94       	sei
    2582:	08 95       	ret

00002584 <_ZN11TouchDriverC1Ev>:
/* PE4 = IRQ (Not Used)													*/
/************************************************************************/

TouchDriver::TouchDriver()
{
	initTouchDriver();
    2584:	e7 cf       	rjmp	.-50     	; 0x2554 <_ZN11TouchDriver15initTouchDriverEv>
    2586:	08 95       	ret

00002588 <__vector_5>:
	sei();
	
}

ISR (INT4_vect)
{
    2588:	1f 92       	push	r1
    258a:	0f 92       	push	r0
    258c:	0f b6       	in	r0, 0x3f	; 63
    258e:	0f 92       	push	r0
    2590:	11 24       	eor	r1, r1
	eIntHappend = 0;
    2592:	10 92 0d 02 	sts	0x020D, r1	; 0x80020d <eIntHappend>
}
    2596:	0f 90       	pop	r0
    2598:	0f be       	out	0x3f, r0	; 63
    259a:	0f 90       	pop	r0
    259c:	1f 90       	pop	r1
    259e:	18 95       	reti

000025a0 <_ZN11TouchDriver9readTouchEc>:
}



uint8_t TouchDriver::readTouch(char coord)
{
    25a0:	df 92       	push	r13
    25a2:	ef 92       	push	r14
    25a4:	ff 92       	push	r15
    25a6:	0f 93       	push	r16
    25a8:	1f 93       	push	r17
    25aa:	cf 93       	push	r28
    25ac:	df 93       	push	r29
	uint8_t delayTime = 8;
	uint8_t dinByte = 0;
	
	if (coord == 'X')
    25ae:	68 35       	cpi	r22, 0x58	; 88
    25b0:	19 f4       	brne	.+6      	; 0x25b8 <_ZN11TouchDriver9readTouchEc+0x18>
	{
		dinByte = dinXByte;
    25b2:	fc 01       	movw	r30, r24
    25b4:	d0 80       	ld	r13, Z
    25b6:	05 c0       	rjmp	.+10     	; 0x25c2 <_ZN11TouchDriver9readTouchEc+0x22>
		
	}else if (coord == 'Y')
    25b8:	69 35       	cpi	r22, 0x59	; 89
    25ba:	09 f0       	breq	.+2      	; 0x25be <_ZN11TouchDriver9readTouchEc+0x1e>
    25bc:	77 c0       	rjmp	.+238    	; 0x26ac <_ZN11TouchDriver9readTouchEc+0x10c>
	{
		dinByte = dinYByte;
    25be:	fc 01       	movw	r30, r24
    25c0:	d1 80       	ldd	r13, Z+1	; 0x01
	else{
		return 255;
	}
	
	// ChipSelect Set to 0	
	CS_PORT &= ~CS_PIN;
    25c2:	8e b1       	in	r24, 0x0e	; 14
    25c4:	8b 7f       	andi	r24, 0xFB	; 251
    25c6:	8e b9       	out	0x0e, r24	; 14
	vTaskDelay( delayTime / portTICK_RATE_MS );
    25c8:	88 e0       	ldi	r24, 0x08	; 8
    25ca:	90 e0       	ldi	r25, 0x00	; 0
    25cc:	32 dd       	rcall	.-1436   	; 0x2032 <vTaskDelay>
	uint8_t result = 0;
	
	// DIN byte and pulse DCLK for Read X
	for (int i = 7; i >= 0; i--)
    25ce:	c7 e0       	ldi	r28, 0x07	; 7
    25d0:	d0 e0       	ldi	r29, 0x00	; 0
    25d2:	dd 23       	and	r29, r29
    25d4:	6c f1       	brlt	.+90     	; 0x2630 <_ZN11TouchDriver9readTouchEc+0x90>
	{
		vTaskDelay( delayTime / portTICK_RATE_MS );
    25d6:	88 e0       	ldi	r24, 0x08	; 8
    25d8:	90 e0       	ldi	r25, 0x00	; 0
    25da:	2b dd       	rcall	.-1450   	; 0x2032 <vTaskDelay>
		
		DIN_PORT |= (((dinByte >> i)  & 0x01) << 5);
    25dc:	24 b3       	in	r18, 0x14	; 20
    25de:	8d 2d       	mov	r24, r13
    25e0:	90 e0       	ldi	r25, 0x00	; 0
    25e2:	0c 2e       	mov	r0, r28
    25e4:	02 c0       	rjmp	.+4      	; 0x25ea <_ZN11TouchDriver9readTouchEc+0x4a>
    25e6:	95 95       	asr	r25
    25e8:	87 95       	ror	r24
    25ea:	0a 94       	dec	r0
    25ec:	e2 f7       	brpl	.-8      	; 0x25e6 <_ZN11TouchDriver9readTouchEc+0x46>
    25ee:	81 70       	andi	r24, 0x01	; 1
    25f0:	99 27       	eor	r25, r25
    25f2:	88 0f       	add	r24, r24
    25f4:	99 1f       	adc	r25, r25
    25f6:	82 95       	swap	r24
    25f8:	92 95       	swap	r25
    25fa:	90 7f       	andi	r25, 0xF0	; 240
    25fc:	98 27       	eor	r25, r24
    25fe:	80 7f       	andi	r24, 0xF0	; 240
    2600:	98 27       	eor	r25, r24
    2602:	82 2b       	or	r24, r18
    2604:	84 bb       	out	0x14, r24	; 20
				
		CLK_PORT |= CLK_PIN;
    2606:	68 94       	set
    2608:	ee 24       	eor	r14, r14
    260a:	e1 f8       	bld	r14, 1
    260c:	ff 24       	eor	r15, r15
    260e:	f3 94       	inc	r15
    2610:	f7 01       	movw	r30, r14
    2612:	80 81       	ld	r24, Z
    2614:	84 60       	ori	r24, 0x04	; 4
    2616:	80 83       	st	Z, r24
		vTaskDelay( delayTime / portTICK_RATE_MS );		
    2618:	88 e0       	ldi	r24, 0x08	; 8
    261a:	90 e0       	ldi	r25, 0x00	; 0
    261c:	0a dd       	rcall	.-1516   	; 0x2032 <vTaskDelay>
		
		CLK_PORT &= ~CLK_PIN;
    261e:	f7 01       	movw	r30, r14
    2620:	80 81       	ld	r24, Z
    2622:	8b 7f       	andi	r24, 0xFB	; 251
    2624:	80 83       	st	Z, r24
		DIN_PORT &= ~BIT6;
    2626:	84 b3       	in	r24, 0x14	; 20
    2628:	89 7f       	andi	r24, 0xF9	; 249
    262a:	84 bb       	out	0x14, r24	; 20
	CS_PORT &= ~CS_PIN;
	vTaskDelay( delayTime / portTICK_RATE_MS );
	uint8_t result = 0;
	
	// DIN byte and pulse DCLK for Read X
	for (int i = 7; i >= 0; i--)
    262c:	21 97       	sbiw	r28, 0x01	; 1
    262e:	d1 cf       	rjmp	.-94     	; 0x25d2 <_ZN11TouchDriver9readTouchEc+0x32>
    2630:	0f 2e       	mov	r0, r31
    2632:	f7 e0       	ldi	r31, 0x07	; 7
    2634:	ef 2e       	mov	r14, r31
    2636:	f1 2c       	mov	r15, r1
    2638:	f0 2d       	mov	r31, r0
    263a:	d1 2c       	mov	r13, r1
		DIN_PORT &= ~BIT6;
	}
			
	// Systematically read DOUT
	
	for (int i = 7; i >= 0; i--)
    263c:	ff 20       	and	r15, r15
	{
		vTaskDelay( delayTime / portTICK_RATE_MS );
    263e:	fc f0       	brlt	.+62     	; 0x267e <_ZN11TouchDriver9readTouchEc+0xde>
    2640:	88 e0       	ldi	r24, 0x08	; 8
    2642:	90 e0       	ldi	r25, 0x00	; 0
    2644:	f6 dc       	rcall	.-1556   	; 0x2032 <vTaskDelay>
		
		CLK_PORT |= CLK_PIN;
    2646:	c2 e0       	ldi	r28, 0x02	; 2
    2648:	d1 e0       	ldi	r29, 0x01	; 1
    264a:	98 81       	ld	r25, Y
    264c:	94 60       	ori	r25, 0x04	; 4
		vTaskDelay( delayTime / portTICK_RATE_MS );
    264e:	98 83       	st	Y, r25
    2650:	88 e0       	ldi	r24, 0x08	; 8
    2652:	90 e0       	ldi	r25, 0x00	; 0
    2654:	ee dc       	rcall	.-1572   	; 0x2032 <vTaskDelay>
		
		CLK_PORT &= ~CLK_PIN;
    2656:	98 81       	ld	r25, Y
    2658:	9b 7f       	andi	r25, 0xFB	; 251
    265a:	98 83       	st	Y, r25
		//_delay_us(1); IS THIS NEEDED MIKKEL?
		
		bool temp = (PINE & (1U << 5));
    265c:	8c b1       	in	r24, 0x0c	; 12
		
		// Check this
		result |= (temp << i);
    265e:	85 fb       	bst	r24, 5
    2660:	00 27       	eor	r16, r16
    2662:	00 f9       	bld	r16, 0
    2664:	10 e0       	ldi	r17, 0x00	; 0
    2666:	c8 01       	movw	r24, r16
    2668:	0e 2c       	mov	r0, r14
    266a:	02 c0       	rjmp	.+4      	; 0x2670 <_ZN11TouchDriver9readTouchEc+0xd0>
    266c:	88 0f       	add	r24, r24
    266e:	99 1f       	adc	r25, r25
    2670:	0a 94       	dec	r0
    2672:	e2 f7       	brpl	.-8      	; 0x266c <_ZN11TouchDriver9readTouchEc+0xcc>
    2674:	d8 2a       	or	r13, r24
		DIN_PORT &= ~BIT6;
	}
			
	// Systematically read DOUT
	
	for (int i = 7; i >= 0; i--)
    2676:	f1 e0       	ldi	r31, 0x01	; 1
    2678:	ef 1a       	sub	r14, r31
    267a:	f1 08       	sbc	r15, r1
    267c:	df cf       	rjmp	.-66     	; 0x263c <_ZN11TouchDriver9readTouchEc+0x9c>
    267e:	c7 e0       	ldi	r28, 0x07	; 7
		
		// Check this
		result |= (temp << i);
	}
	
	for (int i = 7; i >= 0; i--)
    2680:	d0 e0       	ldi	r29, 0x00	; 0
    2682:	dd 23       	and	r29, r29
	{
		vTaskDelay( delayTime / portTICK_RATE_MS );		CLK_PORT |= CLK_PIN;
    2684:	6c f0       	brlt	.+26     	; 0x26a0 <_ZN11TouchDriver9readTouchEc+0x100>
    2686:	88 e0       	ldi	r24, 0x08	; 8
    2688:	90 e0       	ldi	r25, 0x00	; 0
    268a:	d3 dc       	rcall	.-1626   	; 0x2032 <vTaskDelay>
    268c:	e2 e0       	ldi	r30, 0x02	; 2
    268e:	f1 e0       	ldi	r31, 0x01	; 1
    2690:	90 81       	ld	r25, Z
    2692:	94 60       	ori	r25, 0x04	; 4
    2694:	90 83       	st	Z, r25
		CLK_PORT &= ~CLK_PIN;
    2696:	90 81       	ld	r25, Z
    2698:	9b 7f       	andi	r25, 0xFB	; 251
    269a:	90 83       	st	Z, r25
		
		// Check this
		result |= (temp << i);
	}
	
	for (int i = 7; i >= 0; i--)
    269c:	21 97       	sbiw	r28, 0x01	; 1
    269e:	f1 cf       	rjmp	.-30     	; 0x2682 <_ZN11TouchDriver9readTouchEc+0xe2>
		vTaskDelay( delayTime / portTICK_RATE_MS );		CLK_PORT |= CLK_PIN;
		CLK_PORT &= ~CLK_PIN;
		// Check this
	}
	
	CS_PORT |= CS_PIN;
    26a0:	8e b1       	in	r24, 0x0e	; 14
    26a2:	84 60       	ori	r24, 0x04	; 4
    26a4:	8e b9       	out	0x0e, r24	; 14
		
	return ~result;
    26a6:	8d 2d       	mov	r24, r13
    26a8:	80 95       	com	r24
    26aa:	01 c0       	rjmp	.+2      	; 0x26ae <_ZN11TouchDriver9readTouchEc+0x10e>
	}else if (coord == 'Y')
	{
		dinByte = dinYByte;
	}
	else{
		return 255;
    26ac:	8f ef       	ldi	r24, 0xFF	; 255
	}
	
	CS_PORT |= CS_PIN;
		
	return ~result;
    26ae:	df 91       	pop	r29
    26b0:	cf 91       	pop	r28
    26b2:	1f 91       	pop	r17
    26b4:	0f 91       	pop	r16
    26b6:	ff 90       	pop	r15
    26b8:	ef 90       	pop	r14
    26ba:	df 90       	pop	r13
    26bc:	08 95       	ret

000026be <_ZN11TouchDriver14getCoordinatesEPhS0_>:
{
	eIntHappend = 0;
}

void TouchDriver::getCoordinates(uint8_t *x_ptr, uint8_t *y_ptr)
{	
    26be:	ef 92       	push	r14
    26c0:	ff 92       	push	r15
    26c2:	0f 93       	push	r16
    26c4:	1f 93       	push	r17
    26c6:	cf 93       	push	r28
    26c8:	df 93       	push	r29
    26ca:	ec 01       	movw	r28, r24
    26cc:	7b 01       	movw	r14, r22
    26ce:	8a 01       	movw	r16, r20
	while(eIntHappend != 0);
    26d0:	80 91 0d 02 	lds	r24, 0x020D	; 0x80020d <eIntHappend>
    26d4:	81 11       	cpse	r24, r1
    26d6:	fc cf       	rjmp	.-8      	; 0x26d0 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x12>
	
	*x_ptr = readTouch('X');
    26d8:	68 e5       	ldi	r22, 0x58	; 88
    26da:	ce 01       	movw	r24, r28
    26dc:	61 df       	rcall	.-318    	; 0x25a0 <_ZN11TouchDriver9readTouchEc>
    26de:	f7 01       	movw	r30, r14
    26e0:	80 83       	st	Z, r24
	*y_ptr = readTouch('Y');
    26e2:	69 e5       	ldi	r22, 0x59	; 89
    26e4:	ce 01       	movw	r24, r28
    26e6:	5c df       	rcall	.-328    	; 0x25a0 <_ZN11TouchDriver9readTouchEc>
    26e8:	f8 01       	movw	r30, r16
    26ea:	80 83       	st	Z, r24
	
	vTaskDelay( 50 / portTICK_RATE_MS );
    26ec:	82 e3       	ldi	r24, 0x32	; 50
    26ee:	90 e0       	ldi	r25, 0x00	; 0
    26f0:	a0 dc       	rcall	.-1728   	; 0x2032 <vTaskDelay>
	eIntHappend = 255;
    26f2:	8f ef       	ldi	r24, 0xFF	; 255
    26f4:	80 93 0d 02 	sts	0x020D, r24	; 0x80020d <eIntHappend>
	
}
    26f8:	df 91       	pop	r29
    26fa:	cf 91       	pop	r28
    26fc:	1f 91       	pop	r17
    26fe:	0f 91       	pop	r16
    2700:	ff 90       	pop	r15
    2702:	ef 90       	pop	r14
    2704:	08 95       	ret

00002706 <__subsf3>:
    2706:	50 58       	subi	r21, 0x80	; 128

00002708 <__addsf3>:
    2708:	bb 27       	eor	r27, r27
    270a:	aa 27       	eor	r26, r26
    270c:	0e d0       	rcall	.+28     	; 0x272a <__addsf3x>
    270e:	70 c1       	rjmp	.+736    	; 0x29f0 <__fp_round>
    2710:	61 d1       	rcall	.+706    	; 0x29d4 <__fp_pscA>
    2712:	30 f0       	brcs	.+12     	; 0x2720 <__addsf3+0x18>
    2714:	66 d1       	rcall	.+716    	; 0x29e2 <__fp_pscB>
    2716:	20 f0       	brcs	.+8      	; 0x2720 <__addsf3+0x18>
    2718:	31 f4       	brne	.+12     	; 0x2726 <__addsf3+0x1e>
    271a:	9f 3f       	cpi	r25, 0xFF	; 255
    271c:	11 f4       	brne	.+4      	; 0x2722 <__addsf3+0x1a>
    271e:	1e f4       	brtc	.+6      	; 0x2726 <__addsf3+0x1e>
    2720:	56 c1       	rjmp	.+684    	; 0x29ce <__fp_nan>
    2722:	0e f4       	brtc	.+2      	; 0x2726 <__addsf3+0x1e>
    2724:	e0 95       	com	r30
    2726:	e7 fb       	bst	r30, 7
    2728:	4c c1       	rjmp	.+664    	; 0x29c2 <__fp_inf>

0000272a <__addsf3x>:
    272a:	e9 2f       	mov	r30, r25
    272c:	72 d1       	rcall	.+740    	; 0x2a12 <__fp_split3>
    272e:	80 f3       	brcs	.-32     	; 0x2710 <__addsf3+0x8>
    2730:	ba 17       	cp	r27, r26
    2732:	62 07       	cpc	r22, r18
    2734:	73 07       	cpc	r23, r19
    2736:	84 07       	cpc	r24, r20
    2738:	95 07       	cpc	r25, r21
    273a:	18 f0       	brcs	.+6      	; 0x2742 <__addsf3x+0x18>
    273c:	71 f4       	brne	.+28     	; 0x275a <__addsf3x+0x30>
    273e:	9e f5       	brtc	.+102    	; 0x27a6 <__addsf3x+0x7c>
    2740:	8a c1       	rjmp	.+788    	; 0x2a56 <__fp_zero>
    2742:	0e f4       	brtc	.+2      	; 0x2746 <__addsf3x+0x1c>
    2744:	e0 95       	com	r30
    2746:	0b 2e       	mov	r0, r27
    2748:	ba 2f       	mov	r27, r26
    274a:	a0 2d       	mov	r26, r0
    274c:	0b 01       	movw	r0, r22
    274e:	b9 01       	movw	r22, r18
    2750:	90 01       	movw	r18, r0
    2752:	0c 01       	movw	r0, r24
    2754:	ca 01       	movw	r24, r20
    2756:	a0 01       	movw	r20, r0
    2758:	11 24       	eor	r1, r1
    275a:	ff 27       	eor	r31, r31
    275c:	59 1b       	sub	r21, r25
    275e:	99 f0       	breq	.+38     	; 0x2786 <__addsf3x+0x5c>
    2760:	59 3f       	cpi	r21, 0xF9	; 249
    2762:	50 f4       	brcc	.+20     	; 0x2778 <__addsf3x+0x4e>
    2764:	50 3e       	cpi	r21, 0xE0	; 224
    2766:	68 f1       	brcs	.+90     	; 0x27c2 <__addsf3x+0x98>
    2768:	1a 16       	cp	r1, r26
    276a:	f0 40       	sbci	r31, 0x00	; 0
    276c:	a2 2f       	mov	r26, r18
    276e:	23 2f       	mov	r18, r19
    2770:	34 2f       	mov	r19, r20
    2772:	44 27       	eor	r20, r20
    2774:	58 5f       	subi	r21, 0xF8	; 248
    2776:	f3 cf       	rjmp	.-26     	; 0x275e <__addsf3x+0x34>
    2778:	46 95       	lsr	r20
    277a:	37 95       	ror	r19
    277c:	27 95       	ror	r18
    277e:	a7 95       	ror	r26
    2780:	f0 40       	sbci	r31, 0x00	; 0
    2782:	53 95       	inc	r21
    2784:	c9 f7       	brne	.-14     	; 0x2778 <__addsf3x+0x4e>
    2786:	7e f4       	brtc	.+30     	; 0x27a6 <__addsf3x+0x7c>
    2788:	1f 16       	cp	r1, r31
    278a:	ba 0b       	sbc	r27, r26
    278c:	62 0b       	sbc	r22, r18
    278e:	73 0b       	sbc	r23, r19
    2790:	84 0b       	sbc	r24, r20
    2792:	ba f0       	brmi	.+46     	; 0x27c2 <__addsf3x+0x98>
    2794:	91 50       	subi	r25, 0x01	; 1
    2796:	a1 f0       	breq	.+40     	; 0x27c0 <__addsf3x+0x96>
    2798:	ff 0f       	add	r31, r31
    279a:	bb 1f       	adc	r27, r27
    279c:	66 1f       	adc	r22, r22
    279e:	77 1f       	adc	r23, r23
    27a0:	88 1f       	adc	r24, r24
    27a2:	c2 f7       	brpl	.-16     	; 0x2794 <__addsf3x+0x6a>
    27a4:	0e c0       	rjmp	.+28     	; 0x27c2 <__addsf3x+0x98>
    27a6:	ba 0f       	add	r27, r26
    27a8:	62 1f       	adc	r22, r18
    27aa:	73 1f       	adc	r23, r19
    27ac:	84 1f       	adc	r24, r20
    27ae:	48 f4       	brcc	.+18     	; 0x27c2 <__addsf3x+0x98>
    27b0:	87 95       	ror	r24
    27b2:	77 95       	ror	r23
    27b4:	67 95       	ror	r22
    27b6:	b7 95       	ror	r27
    27b8:	f7 95       	ror	r31
    27ba:	9e 3f       	cpi	r25, 0xFE	; 254
    27bc:	08 f0       	brcs	.+2      	; 0x27c0 <__addsf3x+0x96>
    27be:	b3 cf       	rjmp	.-154    	; 0x2726 <__addsf3+0x1e>
    27c0:	93 95       	inc	r25
    27c2:	88 0f       	add	r24, r24
    27c4:	08 f0       	brcs	.+2      	; 0x27c8 <__addsf3x+0x9e>
    27c6:	99 27       	eor	r25, r25
    27c8:	ee 0f       	add	r30, r30
    27ca:	97 95       	ror	r25
    27cc:	87 95       	ror	r24
    27ce:	08 95       	ret

000027d0 <__cmpsf2>:
    27d0:	d4 d0       	rcall	.+424    	; 0x297a <__fp_cmp>
    27d2:	08 f4       	brcc	.+2      	; 0x27d6 <__cmpsf2+0x6>
    27d4:	81 e0       	ldi	r24, 0x01	; 1
    27d6:	08 95       	ret

000027d8 <__divsf3>:
    27d8:	0c d0       	rcall	.+24     	; 0x27f2 <__divsf3x>
    27da:	0a c1       	rjmp	.+532    	; 0x29f0 <__fp_round>
    27dc:	02 d1       	rcall	.+516    	; 0x29e2 <__fp_pscB>
    27de:	40 f0       	brcs	.+16     	; 0x27f0 <__divsf3+0x18>
    27e0:	f9 d0       	rcall	.+498    	; 0x29d4 <__fp_pscA>
    27e2:	30 f0       	brcs	.+12     	; 0x27f0 <__divsf3+0x18>
    27e4:	21 f4       	brne	.+8      	; 0x27ee <__divsf3+0x16>
    27e6:	5f 3f       	cpi	r21, 0xFF	; 255
    27e8:	19 f0       	breq	.+6      	; 0x27f0 <__divsf3+0x18>
    27ea:	eb c0       	rjmp	.+470    	; 0x29c2 <__fp_inf>
    27ec:	51 11       	cpse	r21, r1
    27ee:	34 c1       	rjmp	.+616    	; 0x2a58 <__fp_szero>
    27f0:	ee c0       	rjmp	.+476    	; 0x29ce <__fp_nan>

000027f2 <__divsf3x>:
    27f2:	0f d1       	rcall	.+542    	; 0x2a12 <__fp_split3>
    27f4:	98 f3       	brcs	.-26     	; 0x27dc <__divsf3+0x4>

000027f6 <__divsf3_pse>:
    27f6:	99 23       	and	r25, r25
    27f8:	c9 f3       	breq	.-14     	; 0x27ec <__divsf3+0x14>
    27fa:	55 23       	and	r21, r21
    27fc:	b1 f3       	breq	.-20     	; 0x27ea <__divsf3+0x12>
    27fe:	95 1b       	sub	r25, r21
    2800:	55 0b       	sbc	r21, r21
    2802:	bb 27       	eor	r27, r27
    2804:	aa 27       	eor	r26, r26
    2806:	62 17       	cp	r22, r18
    2808:	73 07       	cpc	r23, r19
    280a:	84 07       	cpc	r24, r20
    280c:	38 f0       	brcs	.+14     	; 0x281c <__divsf3_pse+0x26>
    280e:	9f 5f       	subi	r25, 0xFF	; 255
    2810:	5f 4f       	sbci	r21, 0xFF	; 255
    2812:	22 0f       	add	r18, r18
    2814:	33 1f       	adc	r19, r19
    2816:	44 1f       	adc	r20, r20
    2818:	aa 1f       	adc	r26, r26
    281a:	a9 f3       	breq	.-22     	; 0x2806 <__divsf3_pse+0x10>
    281c:	33 d0       	rcall	.+102    	; 0x2884 <__divsf3_pse+0x8e>
    281e:	0e 2e       	mov	r0, r30
    2820:	3a f0       	brmi	.+14     	; 0x2830 <__divsf3_pse+0x3a>
    2822:	e0 e8       	ldi	r30, 0x80	; 128
    2824:	30 d0       	rcall	.+96     	; 0x2886 <__divsf3_pse+0x90>
    2826:	91 50       	subi	r25, 0x01	; 1
    2828:	50 40       	sbci	r21, 0x00	; 0
    282a:	e6 95       	lsr	r30
    282c:	00 1c       	adc	r0, r0
    282e:	ca f7       	brpl	.-14     	; 0x2822 <__divsf3_pse+0x2c>
    2830:	29 d0       	rcall	.+82     	; 0x2884 <__divsf3_pse+0x8e>
    2832:	fe 2f       	mov	r31, r30
    2834:	27 d0       	rcall	.+78     	; 0x2884 <__divsf3_pse+0x8e>
    2836:	66 0f       	add	r22, r22
    2838:	77 1f       	adc	r23, r23
    283a:	88 1f       	adc	r24, r24
    283c:	bb 1f       	adc	r27, r27
    283e:	26 17       	cp	r18, r22
    2840:	37 07       	cpc	r19, r23
    2842:	48 07       	cpc	r20, r24
    2844:	ab 07       	cpc	r26, r27
    2846:	b0 e8       	ldi	r27, 0x80	; 128
    2848:	09 f0       	breq	.+2      	; 0x284c <__divsf3_pse+0x56>
    284a:	bb 0b       	sbc	r27, r27
    284c:	80 2d       	mov	r24, r0
    284e:	bf 01       	movw	r22, r30
    2850:	ff 27       	eor	r31, r31
    2852:	93 58       	subi	r25, 0x83	; 131
    2854:	5f 4f       	sbci	r21, 0xFF	; 255
    2856:	2a f0       	brmi	.+10     	; 0x2862 <__divsf3_pse+0x6c>
    2858:	9e 3f       	cpi	r25, 0xFE	; 254
    285a:	51 05       	cpc	r21, r1
    285c:	68 f0       	brcs	.+26     	; 0x2878 <__divsf3_pse+0x82>
    285e:	b1 c0       	rjmp	.+354    	; 0x29c2 <__fp_inf>
    2860:	fb c0       	rjmp	.+502    	; 0x2a58 <__fp_szero>
    2862:	5f 3f       	cpi	r21, 0xFF	; 255
    2864:	ec f3       	brlt	.-6      	; 0x2860 <__divsf3_pse+0x6a>
    2866:	98 3e       	cpi	r25, 0xE8	; 232
    2868:	dc f3       	brlt	.-10     	; 0x2860 <__divsf3_pse+0x6a>
    286a:	86 95       	lsr	r24
    286c:	77 95       	ror	r23
    286e:	67 95       	ror	r22
    2870:	b7 95       	ror	r27
    2872:	f7 95       	ror	r31
    2874:	9f 5f       	subi	r25, 0xFF	; 255
    2876:	c9 f7       	brne	.-14     	; 0x286a <__divsf3_pse+0x74>
    2878:	88 0f       	add	r24, r24
    287a:	91 1d       	adc	r25, r1
    287c:	96 95       	lsr	r25
    287e:	87 95       	ror	r24
    2880:	97 f9       	bld	r25, 7
    2882:	08 95       	ret
    2884:	e1 e0       	ldi	r30, 0x01	; 1
    2886:	66 0f       	add	r22, r22
    2888:	77 1f       	adc	r23, r23
    288a:	88 1f       	adc	r24, r24
    288c:	bb 1f       	adc	r27, r27
    288e:	62 17       	cp	r22, r18
    2890:	73 07       	cpc	r23, r19
    2892:	84 07       	cpc	r24, r20
    2894:	ba 07       	cpc	r27, r26
    2896:	20 f0       	brcs	.+8      	; 0x28a0 <__divsf3_pse+0xaa>
    2898:	62 1b       	sub	r22, r18
    289a:	73 0b       	sbc	r23, r19
    289c:	84 0b       	sbc	r24, r20
    289e:	ba 0b       	sbc	r27, r26
    28a0:	ee 1f       	adc	r30, r30
    28a2:	88 f7       	brcc	.-30     	; 0x2886 <__divsf3_pse+0x90>
    28a4:	e0 95       	com	r30
    28a6:	08 95       	ret

000028a8 <__fixunssfsi>:
    28a8:	bc d0       	rcall	.+376    	; 0x2a22 <__fp_splitA>
    28aa:	88 f0       	brcs	.+34     	; 0x28ce <__fixunssfsi+0x26>
    28ac:	9f 57       	subi	r25, 0x7F	; 127
    28ae:	90 f0       	brcs	.+36     	; 0x28d4 <__fixunssfsi+0x2c>
    28b0:	b9 2f       	mov	r27, r25
    28b2:	99 27       	eor	r25, r25
    28b4:	b7 51       	subi	r27, 0x17	; 23
    28b6:	a0 f0       	brcs	.+40     	; 0x28e0 <__fixunssfsi+0x38>
    28b8:	d1 f0       	breq	.+52     	; 0x28ee <__fixunssfsi+0x46>
    28ba:	66 0f       	add	r22, r22
    28bc:	77 1f       	adc	r23, r23
    28be:	88 1f       	adc	r24, r24
    28c0:	99 1f       	adc	r25, r25
    28c2:	1a f0       	brmi	.+6      	; 0x28ca <__fixunssfsi+0x22>
    28c4:	ba 95       	dec	r27
    28c6:	c9 f7       	brne	.-14     	; 0x28ba <__fixunssfsi+0x12>
    28c8:	12 c0       	rjmp	.+36     	; 0x28ee <__fixunssfsi+0x46>
    28ca:	b1 30       	cpi	r27, 0x01	; 1
    28cc:	81 f0       	breq	.+32     	; 0x28ee <__fixunssfsi+0x46>
    28ce:	c3 d0       	rcall	.+390    	; 0x2a56 <__fp_zero>
    28d0:	b1 e0       	ldi	r27, 0x01	; 1
    28d2:	08 95       	ret
    28d4:	c0 c0       	rjmp	.+384    	; 0x2a56 <__fp_zero>
    28d6:	67 2f       	mov	r22, r23
    28d8:	78 2f       	mov	r23, r24
    28da:	88 27       	eor	r24, r24
    28dc:	b8 5f       	subi	r27, 0xF8	; 248
    28de:	39 f0       	breq	.+14     	; 0x28ee <__fixunssfsi+0x46>
    28e0:	b9 3f       	cpi	r27, 0xF9	; 249
    28e2:	cc f3       	brlt	.-14     	; 0x28d6 <__fixunssfsi+0x2e>
    28e4:	86 95       	lsr	r24
    28e6:	77 95       	ror	r23
    28e8:	67 95       	ror	r22
    28ea:	b3 95       	inc	r27
    28ec:	d9 f7       	brne	.-10     	; 0x28e4 <__fixunssfsi+0x3c>
    28ee:	3e f4       	brtc	.+14     	; 0x28fe <__fixunssfsi+0x56>
    28f0:	90 95       	com	r25
    28f2:	80 95       	com	r24
    28f4:	70 95       	com	r23
    28f6:	61 95       	neg	r22
    28f8:	7f 4f       	sbci	r23, 0xFF	; 255
    28fa:	8f 4f       	sbci	r24, 0xFF	; 255
    28fc:	9f 4f       	sbci	r25, 0xFF	; 255
    28fe:	08 95       	ret

00002900 <__floatunsisf>:
    2900:	e8 94       	clt
    2902:	09 c0       	rjmp	.+18     	; 0x2916 <__floatsisf+0x12>

00002904 <__floatsisf>:
    2904:	97 fb       	bst	r25, 7
    2906:	3e f4       	brtc	.+14     	; 0x2916 <__floatsisf+0x12>
    2908:	90 95       	com	r25
    290a:	80 95       	com	r24
    290c:	70 95       	com	r23
    290e:	61 95       	neg	r22
    2910:	7f 4f       	sbci	r23, 0xFF	; 255
    2912:	8f 4f       	sbci	r24, 0xFF	; 255
    2914:	9f 4f       	sbci	r25, 0xFF	; 255
    2916:	99 23       	and	r25, r25
    2918:	a9 f0       	breq	.+42     	; 0x2944 <__floatsisf+0x40>
    291a:	f9 2f       	mov	r31, r25
    291c:	96 e9       	ldi	r25, 0x96	; 150
    291e:	bb 27       	eor	r27, r27
    2920:	93 95       	inc	r25
    2922:	f6 95       	lsr	r31
    2924:	87 95       	ror	r24
    2926:	77 95       	ror	r23
    2928:	67 95       	ror	r22
    292a:	b7 95       	ror	r27
    292c:	f1 11       	cpse	r31, r1
    292e:	f8 cf       	rjmp	.-16     	; 0x2920 <__floatsisf+0x1c>
    2930:	fa f4       	brpl	.+62     	; 0x2970 <__floatsisf+0x6c>
    2932:	bb 0f       	add	r27, r27
    2934:	11 f4       	brne	.+4      	; 0x293a <__floatsisf+0x36>
    2936:	60 ff       	sbrs	r22, 0
    2938:	1b c0       	rjmp	.+54     	; 0x2970 <__floatsisf+0x6c>
    293a:	6f 5f       	subi	r22, 0xFF	; 255
    293c:	7f 4f       	sbci	r23, 0xFF	; 255
    293e:	8f 4f       	sbci	r24, 0xFF	; 255
    2940:	9f 4f       	sbci	r25, 0xFF	; 255
    2942:	16 c0       	rjmp	.+44     	; 0x2970 <__floatsisf+0x6c>
    2944:	88 23       	and	r24, r24
    2946:	11 f0       	breq	.+4      	; 0x294c <__floatsisf+0x48>
    2948:	96 e9       	ldi	r25, 0x96	; 150
    294a:	11 c0       	rjmp	.+34     	; 0x296e <__floatsisf+0x6a>
    294c:	77 23       	and	r23, r23
    294e:	21 f0       	breq	.+8      	; 0x2958 <__floatsisf+0x54>
    2950:	9e e8       	ldi	r25, 0x8E	; 142
    2952:	87 2f       	mov	r24, r23
    2954:	76 2f       	mov	r23, r22
    2956:	05 c0       	rjmp	.+10     	; 0x2962 <__floatsisf+0x5e>
    2958:	66 23       	and	r22, r22
    295a:	71 f0       	breq	.+28     	; 0x2978 <__floatsisf+0x74>
    295c:	96 e8       	ldi	r25, 0x86	; 134
    295e:	86 2f       	mov	r24, r22
    2960:	70 e0       	ldi	r23, 0x00	; 0
    2962:	60 e0       	ldi	r22, 0x00	; 0
    2964:	2a f0       	brmi	.+10     	; 0x2970 <__floatsisf+0x6c>
    2966:	9a 95       	dec	r25
    2968:	66 0f       	add	r22, r22
    296a:	77 1f       	adc	r23, r23
    296c:	88 1f       	adc	r24, r24
    296e:	da f7       	brpl	.-10     	; 0x2966 <__floatsisf+0x62>
    2970:	88 0f       	add	r24, r24
    2972:	96 95       	lsr	r25
    2974:	87 95       	ror	r24
    2976:	97 f9       	bld	r25, 7
    2978:	08 95       	ret

0000297a <__fp_cmp>:
    297a:	99 0f       	add	r25, r25
    297c:	00 08       	sbc	r0, r0
    297e:	55 0f       	add	r21, r21
    2980:	aa 0b       	sbc	r26, r26
    2982:	e0 e8       	ldi	r30, 0x80	; 128
    2984:	fe ef       	ldi	r31, 0xFE	; 254
    2986:	16 16       	cp	r1, r22
    2988:	17 06       	cpc	r1, r23
    298a:	e8 07       	cpc	r30, r24
    298c:	f9 07       	cpc	r31, r25
    298e:	c0 f0       	brcs	.+48     	; 0x29c0 <__fp_cmp+0x46>
    2990:	12 16       	cp	r1, r18
    2992:	13 06       	cpc	r1, r19
    2994:	e4 07       	cpc	r30, r20
    2996:	f5 07       	cpc	r31, r21
    2998:	98 f0       	brcs	.+38     	; 0x29c0 <__fp_cmp+0x46>
    299a:	62 1b       	sub	r22, r18
    299c:	73 0b       	sbc	r23, r19
    299e:	84 0b       	sbc	r24, r20
    29a0:	95 0b       	sbc	r25, r21
    29a2:	39 f4       	brne	.+14     	; 0x29b2 <__fp_cmp+0x38>
    29a4:	0a 26       	eor	r0, r26
    29a6:	61 f0       	breq	.+24     	; 0x29c0 <__fp_cmp+0x46>
    29a8:	23 2b       	or	r18, r19
    29aa:	24 2b       	or	r18, r20
    29ac:	25 2b       	or	r18, r21
    29ae:	21 f4       	brne	.+8      	; 0x29b8 <__fp_cmp+0x3e>
    29b0:	08 95       	ret
    29b2:	0a 26       	eor	r0, r26
    29b4:	09 f4       	brne	.+2      	; 0x29b8 <__fp_cmp+0x3e>
    29b6:	a1 40       	sbci	r26, 0x01	; 1
    29b8:	a6 95       	lsr	r26
    29ba:	8f ef       	ldi	r24, 0xFF	; 255
    29bc:	81 1d       	adc	r24, r1
    29be:	81 1d       	adc	r24, r1
    29c0:	08 95       	ret

000029c2 <__fp_inf>:
    29c2:	97 f9       	bld	r25, 7
    29c4:	9f 67       	ori	r25, 0x7F	; 127
    29c6:	80 e8       	ldi	r24, 0x80	; 128
    29c8:	70 e0       	ldi	r23, 0x00	; 0
    29ca:	60 e0       	ldi	r22, 0x00	; 0
    29cc:	08 95       	ret

000029ce <__fp_nan>:
    29ce:	9f ef       	ldi	r25, 0xFF	; 255
    29d0:	80 ec       	ldi	r24, 0xC0	; 192
    29d2:	08 95       	ret

000029d4 <__fp_pscA>:
    29d4:	00 24       	eor	r0, r0
    29d6:	0a 94       	dec	r0
    29d8:	16 16       	cp	r1, r22
    29da:	17 06       	cpc	r1, r23
    29dc:	18 06       	cpc	r1, r24
    29de:	09 06       	cpc	r0, r25
    29e0:	08 95       	ret

000029e2 <__fp_pscB>:
    29e2:	00 24       	eor	r0, r0
    29e4:	0a 94       	dec	r0
    29e6:	12 16       	cp	r1, r18
    29e8:	13 06       	cpc	r1, r19
    29ea:	14 06       	cpc	r1, r20
    29ec:	05 06       	cpc	r0, r21
    29ee:	08 95       	ret

000029f0 <__fp_round>:
    29f0:	09 2e       	mov	r0, r25
    29f2:	03 94       	inc	r0
    29f4:	00 0c       	add	r0, r0
    29f6:	11 f4       	brne	.+4      	; 0x29fc <__fp_round+0xc>
    29f8:	88 23       	and	r24, r24
    29fa:	52 f0       	brmi	.+20     	; 0x2a10 <__fp_round+0x20>
    29fc:	bb 0f       	add	r27, r27
    29fe:	40 f4       	brcc	.+16     	; 0x2a10 <__fp_round+0x20>
    2a00:	bf 2b       	or	r27, r31
    2a02:	11 f4       	brne	.+4      	; 0x2a08 <__fp_round+0x18>
    2a04:	60 ff       	sbrs	r22, 0
    2a06:	04 c0       	rjmp	.+8      	; 0x2a10 <__fp_round+0x20>
    2a08:	6f 5f       	subi	r22, 0xFF	; 255
    2a0a:	7f 4f       	sbci	r23, 0xFF	; 255
    2a0c:	8f 4f       	sbci	r24, 0xFF	; 255
    2a0e:	9f 4f       	sbci	r25, 0xFF	; 255
    2a10:	08 95       	ret

00002a12 <__fp_split3>:
    2a12:	57 fd       	sbrc	r21, 7
    2a14:	90 58       	subi	r25, 0x80	; 128
    2a16:	44 0f       	add	r20, r20
    2a18:	55 1f       	adc	r21, r21
    2a1a:	59 f0       	breq	.+22     	; 0x2a32 <__fp_splitA+0x10>
    2a1c:	5f 3f       	cpi	r21, 0xFF	; 255
    2a1e:	71 f0       	breq	.+28     	; 0x2a3c <__fp_splitA+0x1a>
    2a20:	47 95       	ror	r20

00002a22 <__fp_splitA>:
    2a22:	88 0f       	add	r24, r24
    2a24:	97 fb       	bst	r25, 7
    2a26:	99 1f       	adc	r25, r25
    2a28:	61 f0       	breq	.+24     	; 0x2a42 <__fp_splitA+0x20>
    2a2a:	9f 3f       	cpi	r25, 0xFF	; 255
    2a2c:	79 f0       	breq	.+30     	; 0x2a4c <__fp_splitA+0x2a>
    2a2e:	87 95       	ror	r24
    2a30:	08 95       	ret
    2a32:	12 16       	cp	r1, r18
    2a34:	13 06       	cpc	r1, r19
    2a36:	14 06       	cpc	r1, r20
    2a38:	55 1f       	adc	r21, r21
    2a3a:	f2 cf       	rjmp	.-28     	; 0x2a20 <__fp_split3+0xe>
    2a3c:	46 95       	lsr	r20
    2a3e:	f1 df       	rcall	.-30     	; 0x2a22 <__fp_splitA>
    2a40:	08 c0       	rjmp	.+16     	; 0x2a52 <__fp_splitA+0x30>
    2a42:	16 16       	cp	r1, r22
    2a44:	17 06       	cpc	r1, r23
    2a46:	18 06       	cpc	r1, r24
    2a48:	99 1f       	adc	r25, r25
    2a4a:	f1 cf       	rjmp	.-30     	; 0x2a2e <__fp_splitA+0xc>
    2a4c:	86 95       	lsr	r24
    2a4e:	71 05       	cpc	r23, r1
    2a50:	61 05       	cpc	r22, r1
    2a52:	08 94       	sec
    2a54:	08 95       	ret

00002a56 <__fp_zero>:
    2a56:	e8 94       	clt

00002a58 <__fp_szero>:
    2a58:	bb 27       	eor	r27, r27
    2a5a:	66 27       	eor	r22, r22
    2a5c:	77 27       	eor	r23, r23
    2a5e:	cb 01       	movw	r24, r22
    2a60:	97 f9       	bld	r25, 7
    2a62:	08 95       	ret

00002a64 <__gesf2>:
    2a64:	8a df       	rcall	.-236    	; 0x297a <__fp_cmp>
    2a66:	08 f4       	brcc	.+2      	; 0x2a6a <__gesf2+0x6>
    2a68:	8f ef       	ldi	r24, 0xFF	; 255
    2a6a:	08 95       	ret

00002a6c <__mulsf3>:
    2a6c:	0b d0       	rcall	.+22     	; 0x2a84 <__mulsf3x>
    2a6e:	c0 cf       	rjmp	.-128    	; 0x29f0 <__fp_round>
    2a70:	b1 df       	rcall	.-158    	; 0x29d4 <__fp_pscA>
    2a72:	28 f0       	brcs	.+10     	; 0x2a7e <__mulsf3+0x12>
    2a74:	b6 df       	rcall	.-148    	; 0x29e2 <__fp_pscB>
    2a76:	18 f0       	brcs	.+6      	; 0x2a7e <__mulsf3+0x12>
    2a78:	95 23       	and	r25, r21
    2a7a:	09 f0       	breq	.+2      	; 0x2a7e <__mulsf3+0x12>
    2a7c:	a2 cf       	rjmp	.-188    	; 0x29c2 <__fp_inf>
    2a7e:	a7 cf       	rjmp	.-178    	; 0x29ce <__fp_nan>
    2a80:	11 24       	eor	r1, r1
    2a82:	ea cf       	rjmp	.-44     	; 0x2a58 <__fp_szero>

00002a84 <__mulsf3x>:
    2a84:	c6 df       	rcall	.-116    	; 0x2a12 <__fp_split3>
    2a86:	a0 f3       	brcs	.-24     	; 0x2a70 <__mulsf3+0x4>

00002a88 <__mulsf3_pse>:
    2a88:	95 9f       	mul	r25, r21
    2a8a:	d1 f3       	breq	.-12     	; 0x2a80 <__mulsf3+0x14>
    2a8c:	95 0f       	add	r25, r21
    2a8e:	50 e0       	ldi	r21, 0x00	; 0
    2a90:	55 1f       	adc	r21, r21
    2a92:	62 9f       	mul	r22, r18
    2a94:	f0 01       	movw	r30, r0
    2a96:	72 9f       	mul	r23, r18
    2a98:	bb 27       	eor	r27, r27
    2a9a:	f0 0d       	add	r31, r0
    2a9c:	b1 1d       	adc	r27, r1
    2a9e:	63 9f       	mul	r22, r19
    2aa0:	aa 27       	eor	r26, r26
    2aa2:	f0 0d       	add	r31, r0
    2aa4:	b1 1d       	adc	r27, r1
    2aa6:	aa 1f       	adc	r26, r26
    2aa8:	64 9f       	mul	r22, r20
    2aaa:	66 27       	eor	r22, r22
    2aac:	b0 0d       	add	r27, r0
    2aae:	a1 1d       	adc	r26, r1
    2ab0:	66 1f       	adc	r22, r22
    2ab2:	82 9f       	mul	r24, r18
    2ab4:	22 27       	eor	r18, r18
    2ab6:	b0 0d       	add	r27, r0
    2ab8:	a1 1d       	adc	r26, r1
    2aba:	62 1f       	adc	r22, r18
    2abc:	73 9f       	mul	r23, r19
    2abe:	b0 0d       	add	r27, r0
    2ac0:	a1 1d       	adc	r26, r1
    2ac2:	62 1f       	adc	r22, r18
    2ac4:	83 9f       	mul	r24, r19
    2ac6:	a0 0d       	add	r26, r0
    2ac8:	61 1d       	adc	r22, r1
    2aca:	22 1f       	adc	r18, r18
    2acc:	74 9f       	mul	r23, r20
    2ace:	33 27       	eor	r19, r19
    2ad0:	a0 0d       	add	r26, r0
    2ad2:	61 1d       	adc	r22, r1
    2ad4:	23 1f       	adc	r18, r19
    2ad6:	84 9f       	mul	r24, r20
    2ad8:	60 0d       	add	r22, r0
    2ada:	21 1d       	adc	r18, r1
    2adc:	82 2f       	mov	r24, r18
    2ade:	76 2f       	mov	r23, r22
    2ae0:	6a 2f       	mov	r22, r26
    2ae2:	11 24       	eor	r1, r1
    2ae4:	9f 57       	subi	r25, 0x7F	; 127
    2ae6:	50 40       	sbci	r21, 0x00	; 0
    2ae8:	8a f0       	brmi	.+34     	; 0x2b0c <__mulsf3_pse+0x84>
    2aea:	e1 f0       	breq	.+56     	; 0x2b24 <__mulsf3_pse+0x9c>
    2aec:	88 23       	and	r24, r24
    2aee:	4a f0       	brmi	.+18     	; 0x2b02 <__mulsf3_pse+0x7a>
    2af0:	ee 0f       	add	r30, r30
    2af2:	ff 1f       	adc	r31, r31
    2af4:	bb 1f       	adc	r27, r27
    2af6:	66 1f       	adc	r22, r22
    2af8:	77 1f       	adc	r23, r23
    2afa:	88 1f       	adc	r24, r24
    2afc:	91 50       	subi	r25, 0x01	; 1
    2afe:	50 40       	sbci	r21, 0x00	; 0
    2b00:	a9 f7       	brne	.-22     	; 0x2aec <__mulsf3_pse+0x64>
    2b02:	9e 3f       	cpi	r25, 0xFE	; 254
    2b04:	51 05       	cpc	r21, r1
    2b06:	70 f0       	brcs	.+28     	; 0x2b24 <__mulsf3_pse+0x9c>
    2b08:	5c cf       	rjmp	.-328    	; 0x29c2 <__fp_inf>
    2b0a:	a6 cf       	rjmp	.-180    	; 0x2a58 <__fp_szero>
    2b0c:	5f 3f       	cpi	r21, 0xFF	; 255
    2b0e:	ec f3       	brlt	.-6      	; 0x2b0a <__mulsf3_pse+0x82>
    2b10:	98 3e       	cpi	r25, 0xE8	; 232
    2b12:	dc f3       	brlt	.-10     	; 0x2b0a <__mulsf3_pse+0x82>
    2b14:	86 95       	lsr	r24
    2b16:	77 95       	ror	r23
    2b18:	67 95       	ror	r22
    2b1a:	b7 95       	ror	r27
    2b1c:	f7 95       	ror	r31
    2b1e:	e7 95       	ror	r30
    2b20:	9f 5f       	subi	r25, 0xFF	; 255
    2b22:	c1 f7       	brne	.-16     	; 0x2b14 <__mulsf3_pse+0x8c>
    2b24:	fe 2b       	or	r31, r30
    2b26:	88 0f       	add	r24, r24
    2b28:	91 1d       	adc	r25, r1
    2b2a:	96 95       	lsr	r25
    2b2c:	87 95       	ror	r24
    2b2e:	97 f9       	bld	r25, 7
    2b30:	08 95       	ret

00002b32 <__tablejump2__>:
    2b32:	ee 0f       	add	r30, r30
    2b34:	ff 1f       	adc	r31, r31
    2b36:	88 1f       	adc	r24, r24
    2b38:	8b bf       	out	0x3b, r24	; 59
    2b3a:	07 90       	elpm	r0, Z+
    2b3c:	f6 91       	elpm	r31, Z
    2b3e:	e0 2d       	mov	r30, r0
    2b40:	19 94       	eijmp

00002b42 <__umulhisi3>:
    2b42:	a2 9f       	mul	r26, r18
    2b44:	b0 01       	movw	r22, r0
    2b46:	b3 9f       	mul	r27, r19
    2b48:	c0 01       	movw	r24, r0
    2b4a:	a3 9f       	mul	r26, r19
    2b4c:	70 0d       	add	r23, r0
    2b4e:	81 1d       	adc	r24, r1
    2b50:	11 24       	eor	r1, r1
    2b52:	91 1d       	adc	r25, r1
    2b54:	b2 9f       	mul	r27, r18
    2b56:	70 0d       	add	r23, r0
    2b58:	81 1d       	adc	r24, r1
    2b5a:	11 24       	eor	r1, r1
    2b5c:	91 1d       	adc	r25, r1
    2b5e:	08 95       	ret

00002b60 <malloc>:
    2b60:	0f 93       	push	r16
    2b62:	1f 93       	push	r17
    2b64:	cf 93       	push	r28
    2b66:	df 93       	push	r29
    2b68:	82 30       	cpi	r24, 0x02	; 2
    2b6a:	91 05       	cpc	r25, r1
    2b6c:	10 f4       	brcc	.+4      	; 0x2b72 <malloc+0x12>
    2b6e:	82 e0       	ldi	r24, 0x02	; 2
    2b70:	90 e0       	ldi	r25, 0x00	; 0
    2b72:	e0 91 2b 09 	lds	r30, 0x092B	; 0x80092b <__flp>
    2b76:	f0 91 2c 09 	lds	r31, 0x092C	; 0x80092c <__flp+0x1>
    2b7a:	20 e0       	ldi	r18, 0x00	; 0
    2b7c:	30 e0       	ldi	r19, 0x00	; 0
    2b7e:	a0 e0       	ldi	r26, 0x00	; 0
    2b80:	b0 e0       	ldi	r27, 0x00	; 0
    2b82:	30 97       	sbiw	r30, 0x00	; 0
    2b84:	19 f1       	breq	.+70     	; 0x2bcc <malloc+0x6c>
    2b86:	40 81       	ld	r20, Z
    2b88:	51 81       	ldd	r21, Z+1	; 0x01
    2b8a:	02 81       	ldd	r16, Z+2	; 0x02
    2b8c:	13 81       	ldd	r17, Z+3	; 0x03
    2b8e:	48 17       	cp	r20, r24
    2b90:	59 07       	cpc	r21, r25
    2b92:	c8 f0       	brcs	.+50     	; 0x2bc6 <malloc+0x66>
    2b94:	84 17       	cp	r24, r20
    2b96:	95 07       	cpc	r25, r21
    2b98:	69 f4       	brne	.+26     	; 0x2bb4 <malloc+0x54>
    2b9a:	10 97       	sbiw	r26, 0x00	; 0
    2b9c:	31 f0       	breq	.+12     	; 0x2baa <malloc+0x4a>
    2b9e:	12 96       	adiw	r26, 0x02	; 2
    2ba0:	0c 93       	st	X, r16
    2ba2:	12 97       	sbiw	r26, 0x02	; 2
    2ba4:	13 96       	adiw	r26, 0x03	; 3
    2ba6:	1c 93       	st	X, r17
    2ba8:	27 c0       	rjmp	.+78     	; 0x2bf8 <malloc+0x98>
    2baa:	00 93 2b 09 	sts	0x092B, r16	; 0x80092b <__flp>
    2bae:	10 93 2c 09 	sts	0x092C, r17	; 0x80092c <__flp+0x1>
    2bb2:	22 c0       	rjmp	.+68     	; 0x2bf8 <malloc+0x98>
    2bb4:	21 15       	cp	r18, r1
    2bb6:	31 05       	cpc	r19, r1
    2bb8:	19 f0       	breq	.+6      	; 0x2bc0 <malloc+0x60>
    2bba:	42 17       	cp	r20, r18
    2bbc:	53 07       	cpc	r21, r19
    2bbe:	18 f4       	brcc	.+6      	; 0x2bc6 <malloc+0x66>
    2bc0:	9a 01       	movw	r18, r20
    2bc2:	bd 01       	movw	r22, r26
    2bc4:	ef 01       	movw	r28, r30
    2bc6:	df 01       	movw	r26, r30
    2bc8:	f8 01       	movw	r30, r16
    2bca:	db cf       	rjmp	.-74     	; 0x2b82 <malloc+0x22>
    2bcc:	21 15       	cp	r18, r1
    2bce:	31 05       	cpc	r19, r1
    2bd0:	f9 f0       	breq	.+62     	; 0x2c10 <malloc+0xb0>
    2bd2:	28 1b       	sub	r18, r24
    2bd4:	39 0b       	sbc	r19, r25
    2bd6:	24 30       	cpi	r18, 0x04	; 4
    2bd8:	31 05       	cpc	r19, r1
    2bda:	80 f4       	brcc	.+32     	; 0x2bfc <malloc+0x9c>
    2bdc:	8a 81       	ldd	r24, Y+2	; 0x02
    2bde:	9b 81       	ldd	r25, Y+3	; 0x03
    2be0:	61 15       	cp	r22, r1
    2be2:	71 05       	cpc	r23, r1
    2be4:	21 f0       	breq	.+8      	; 0x2bee <malloc+0x8e>
    2be6:	fb 01       	movw	r30, r22
    2be8:	93 83       	std	Z+3, r25	; 0x03
    2bea:	82 83       	std	Z+2, r24	; 0x02
    2bec:	04 c0       	rjmp	.+8      	; 0x2bf6 <malloc+0x96>
    2bee:	90 93 2c 09 	sts	0x092C, r25	; 0x80092c <__flp+0x1>
    2bf2:	80 93 2b 09 	sts	0x092B, r24	; 0x80092b <__flp>
    2bf6:	fe 01       	movw	r30, r28
    2bf8:	32 96       	adiw	r30, 0x02	; 2
    2bfa:	44 c0       	rjmp	.+136    	; 0x2c84 <malloc+0x124>
    2bfc:	fe 01       	movw	r30, r28
    2bfe:	e2 0f       	add	r30, r18
    2c00:	f3 1f       	adc	r31, r19
    2c02:	81 93       	st	Z+, r24
    2c04:	91 93       	st	Z+, r25
    2c06:	22 50       	subi	r18, 0x02	; 2
    2c08:	31 09       	sbc	r19, r1
    2c0a:	39 83       	std	Y+1, r19	; 0x01
    2c0c:	28 83       	st	Y, r18
    2c0e:	3a c0       	rjmp	.+116    	; 0x2c84 <malloc+0x124>
    2c10:	20 91 29 09 	lds	r18, 0x0929	; 0x800929 <__brkval>
    2c14:	30 91 2a 09 	lds	r19, 0x092A	; 0x80092a <__brkval+0x1>
    2c18:	23 2b       	or	r18, r19
    2c1a:	41 f4       	brne	.+16     	; 0x2c2c <malloc+0xcc>
    2c1c:	20 91 02 02 	lds	r18, 0x0202	; 0x800202 <__malloc_heap_start>
    2c20:	30 91 03 02 	lds	r19, 0x0203	; 0x800203 <__malloc_heap_start+0x1>
    2c24:	30 93 2a 09 	sts	0x092A, r19	; 0x80092a <__brkval+0x1>
    2c28:	20 93 29 09 	sts	0x0929, r18	; 0x800929 <__brkval>
    2c2c:	20 91 00 02 	lds	r18, 0x0200	; 0x800200 <__data_start>
    2c30:	30 91 01 02 	lds	r19, 0x0201	; 0x800201 <__data_start+0x1>
    2c34:	21 15       	cp	r18, r1
    2c36:	31 05       	cpc	r19, r1
    2c38:	41 f4       	brne	.+16     	; 0x2c4a <malloc+0xea>
    2c3a:	2d b7       	in	r18, 0x3d	; 61
    2c3c:	3e b7       	in	r19, 0x3e	; 62
    2c3e:	40 91 04 02 	lds	r20, 0x0204	; 0x800204 <__malloc_margin>
    2c42:	50 91 05 02 	lds	r21, 0x0205	; 0x800205 <__malloc_margin+0x1>
    2c46:	24 1b       	sub	r18, r20
    2c48:	35 0b       	sbc	r19, r21
    2c4a:	e0 91 29 09 	lds	r30, 0x0929	; 0x800929 <__brkval>
    2c4e:	f0 91 2a 09 	lds	r31, 0x092A	; 0x80092a <__brkval+0x1>
    2c52:	e2 17       	cp	r30, r18
    2c54:	f3 07       	cpc	r31, r19
    2c56:	a0 f4       	brcc	.+40     	; 0x2c80 <malloc+0x120>
    2c58:	2e 1b       	sub	r18, r30
    2c5a:	3f 0b       	sbc	r19, r31
    2c5c:	28 17       	cp	r18, r24
    2c5e:	39 07       	cpc	r19, r25
    2c60:	78 f0       	brcs	.+30     	; 0x2c80 <malloc+0x120>
    2c62:	ac 01       	movw	r20, r24
    2c64:	4e 5f       	subi	r20, 0xFE	; 254
    2c66:	5f 4f       	sbci	r21, 0xFF	; 255
    2c68:	24 17       	cp	r18, r20
    2c6a:	35 07       	cpc	r19, r21
    2c6c:	48 f0       	brcs	.+18     	; 0x2c80 <malloc+0x120>
    2c6e:	4e 0f       	add	r20, r30
    2c70:	5f 1f       	adc	r21, r31
    2c72:	50 93 2a 09 	sts	0x092A, r21	; 0x80092a <__brkval+0x1>
    2c76:	40 93 29 09 	sts	0x0929, r20	; 0x800929 <__brkval>
    2c7a:	81 93       	st	Z+, r24
    2c7c:	91 93       	st	Z+, r25
    2c7e:	02 c0       	rjmp	.+4      	; 0x2c84 <malloc+0x124>
    2c80:	e0 e0       	ldi	r30, 0x00	; 0
    2c82:	f0 e0       	ldi	r31, 0x00	; 0
    2c84:	cf 01       	movw	r24, r30
    2c86:	df 91       	pop	r29
    2c88:	cf 91       	pop	r28
    2c8a:	1f 91       	pop	r17
    2c8c:	0f 91       	pop	r16
    2c8e:	08 95       	ret

00002c90 <free>:
    2c90:	cf 93       	push	r28
    2c92:	df 93       	push	r29
    2c94:	00 97       	sbiw	r24, 0x00	; 0
    2c96:	09 f4       	brne	.+2      	; 0x2c9a <free+0xa>
    2c98:	81 c0       	rjmp	.+258    	; 0x2d9c <free+0x10c>
    2c9a:	fc 01       	movw	r30, r24
    2c9c:	32 97       	sbiw	r30, 0x02	; 2
    2c9e:	13 82       	std	Z+3, r1	; 0x03
    2ca0:	12 82       	std	Z+2, r1	; 0x02
    2ca2:	a0 91 2b 09 	lds	r26, 0x092B	; 0x80092b <__flp>
    2ca6:	b0 91 2c 09 	lds	r27, 0x092C	; 0x80092c <__flp+0x1>
    2caa:	10 97       	sbiw	r26, 0x00	; 0
    2cac:	81 f4       	brne	.+32     	; 0x2cce <free+0x3e>
    2cae:	20 81       	ld	r18, Z
    2cb0:	31 81       	ldd	r19, Z+1	; 0x01
    2cb2:	82 0f       	add	r24, r18
    2cb4:	93 1f       	adc	r25, r19
    2cb6:	20 91 29 09 	lds	r18, 0x0929	; 0x800929 <__brkval>
    2cba:	30 91 2a 09 	lds	r19, 0x092A	; 0x80092a <__brkval+0x1>
    2cbe:	28 17       	cp	r18, r24
    2cc0:	39 07       	cpc	r19, r25
    2cc2:	51 f5       	brne	.+84     	; 0x2d18 <free+0x88>
    2cc4:	f0 93 2a 09 	sts	0x092A, r31	; 0x80092a <__brkval+0x1>
    2cc8:	e0 93 29 09 	sts	0x0929, r30	; 0x800929 <__brkval>
    2ccc:	67 c0       	rjmp	.+206    	; 0x2d9c <free+0x10c>
    2cce:	ed 01       	movw	r28, r26
    2cd0:	20 e0       	ldi	r18, 0x00	; 0
    2cd2:	30 e0       	ldi	r19, 0x00	; 0
    2cd4:	ce 17       	cp	r28, r30
    2cd6:	df 07       	cpc	r29, r31
    2cd8:	40 f4       	brcc	.+16     	; 0x2cea <free+0x5a>
    2cda:	4a 81       	ldd	r20, Y+2	; 0x02
    2cdc:	5b 81       	ldd	r21, Y+3	; 0x03
    2cde:	9e 01       	movw	r18, r28
    2ce0:	41 15       	cp	r20, r1
    2ce2:	51 05       	cpc	r21, r1
    2ce4:	f1 f0       	breq	.+60     	; 0x2d22 <free+0x92>
    2ce6:	ea 01       	movw	r28, r20
    2ce8:	f5 cf       	rjmp	.-22     	; 0x2cd4 <free+0x44>
    2cea:	d3 83       	std	Z+3, r29	; 0x03
    2cec:	c2 83       	std	Z+2, r28	; 0x02
    2cee:	40 81       	ld	r20, Z
    2cf0:	51 81       	ldd	r21, Z+1	; 0x01
    2cf2:	84 0f       	add	r24, r20
    2cf4:	95 1f       	adc	r25, r21
    2cf6:	c8 17       	cp	r28, r24
    2cf8:	d9 07       	cpc	r29, r25
    2cfa:	59 f4       	brne	.+22     	; 0x2d12 <free+0x82>
    2cfc:	88 81       	ld	r24, Y
    2cfe:	99 81       	ldd	r25, Y+1	; 0x01
    2d00:	84 0f       	add	r24, r20
    2d02:	95 1f       	adc	r25, r21
    2d04:	02 96       	adiw	r24, 0x02	; 2
    2d06:	91 83       	std	Z+1, r25	; 0x01
    2d08:	80 83       	st	Z, r24
    2d0a:	8a 81       	ldd	r24, Y+2	; 0x02
    2d0c:	9b 81       	ldd	r25, Y+3	; 0x03
    2d0e:	93 83       	std	Z+3, r25	; 0x03
    2d10:	82 83       	std	Z+2, r24	; 0x02
    2d12:	21 15       	cp	r18, r1
    2d14:	31 05       	cpc	r19, r1
    2d16:	29 f4       	brne	.+10     	; 0x2d22 <free+0x92>
    2d18:	f0 93 2c 09 	sts	0x092C, r31	; 0x80092c <__flp+0x1>
    2d1c:	e0 93 2b 09 	sts	0x092B, r30	; 0x80092b <__flp>
    2d20:	3d c0       	rjmp	.+122    	; 0x2d9c <free+0x10c>
    2d22:	e9 01       	movw	r28, r18
    2d24:	fb 83       	std	Y+3, r31	; 0x03
    2d26:	ea 83       	std	Y+2, r30	; 0x02
    2d28:	49 91       	ld	r20, Y+
    2d2a:	59 91       	ld	r21, Y+
    2d2c:	c4 0f       	add	r28, r20
    2d2e:	d5 1f       	adc	r29, r21
    2d30:	ec 17       	cp	r30, r28
    2d32:	fd 07       	cpc	r31, r29
    2d34:	61 f4       	brne	.+24     	; 0x2d4e <free+0xbe>
    2d36:	80 81       	ld	r24, Z
    2d38:	91 81       	ldd	r25, Z+1	; 0x01
    2d3a:	84 0f       	add	r24, r20
    2d3c:	95 1f       	adc	r25, r21
    2d3e:	02 96       	adiw	r24, 0x02	; 2
    2d40:	e9 01       	movw	r28, r18
    2d42:	99 83       	std	Y+1, r25	; 0x01
    2d44:	88 83       	st	Y, r24
    2d46:	82 81       	ldd	r24, Z+2	; 0x02
    2d48:	93 81       	ldd	r25, Z+3	; 0x03
    2d4a:	9b 83       	std	Y+3, r25	; 0x03
    2d4c:	8a 83       	std	Y+2, r24	; 0x02
    2d4e:	e0 e0       	ldi	r30, 0x00	; 0
    2d50:	f0 e0       	ldi	r31, 0x00	; 0
    2d52:	12 96       	adiw	r26, 0x02	; 2
    2d54:	8d 91       	ld	r24, X+
    2d56:	9c 91       	ld	r25, X
    2d58:	13 97       	sbiw	r26, 0x03	; 3
    2d5a:	00 97       	sbiw	r24, 0x00	; 0
    2d5c:	19 f0       	breq	.+6      	; 0x2d64 <free+0xd4>
    2d5e:	fd 01       	movw	r30, r26
    2d60:	dc 01       	movw	r26, r24
    2d62:	f7 cf       	rjmp	.-18     	; 0x2d52 <free+0xc2>
    2d64:	8d 91       	ld	r24, X+
    2d66:	9c 91       	ld	r25, X
    2d68:	11 97       	sbiw	r26, 0x01	; 1
    2d6a:	9d 01       	movw	r18, r26
    2d6c:	2e 5f       	subi	r18, 0xFE	; 254
    2d6e:	3f 4f       	sbci	r19, 0xFF	; 255
    2d70:	82 0f       	add	r24, r18
    2d72:	93 1f       	adc	r25, r19
    2d74:	20 91 29 09 	lds	r18, 0x0929	; 0x800929 <__brkval>
    2d78:	30 91 2a 09 	lds	r19, 0x092A	; 0x80092a <__brkval+0x1>
    2d7c:	28 17       	cp	r18, r24
    2d7e:	39 07       	cpc	r19, r25
    2d80:	69 f4       	brne	.+26     	; 0x2d9c <free+0x10c>
    2d82:	30 97       	sbiw	r30, 0x00	; 0
    2d84:	29 f4       	brne	.+10     	; 0x2d90 <free+0x100>
    2d86:	10 92 2c 09 	sts	0x092C, r1	; 0x80092c <__flp+0x1>
    2d8a:	10 92 2b 09 	sts	0x092B, r1	; 0x80092b <__flp>
    2d8e:	02 c0       	rjmp	.+4      	; 0x2d94 <free+0x104>
    2d90:	13 82       	std	Z+3, r1	; 0x03
    2d92:	12 82       	std	Z+2, r1	; 0x02
    2d94:	b0 93 2a 09 	sts	0x092A, r27	; 0x80092a <__brkval+0x1>
    2d98:	a0 93 29 09 	sts	0x0929, r26	; 0x800929 <__brkval>
    2d9c:	df 91       	pop	r29
    2d9e:	cf 91       	pop	r28
    2da0:	08 95       	ret

00002da2 <memset>:
    2da2:	dc 01       	movw	r26, r24
    2da4:	01 c0       	rjmp	.+2      	; 0x2da8 <memset+0x6>
    2da6:	6d 93       	st	X+, r22
    2da8:	41 50       	subi	r20, 0x01	; 1
    2daa:	50 40       	sbci	r21, 0x00	; 0
    2dac:	e0 f7       	brcc	.-8      	; 0x2da6 <memset+0x4>
    2dae:	08 95       	ret

00002db0 <strncpy>:
    2db0:	fb 01       	movw	r30, r22
    2db2:	dc 01       	movw	r26, r24
    2db4:	41 50       	subi	r20, 0x01	; 1
    2db6:	50 40       	sbci	r21, 0x00	; 0
    2db8:	48 f0       	brcs	.+18     	; 0x2dcc <strncpy+0x1c>
    2dba:	01 90       	ld	r0, Z+
    2dbc:	0d 92       	st	X+, r0
    2dbe:	00 20       	and	r0, r0
    2dc0:	c9 f7       	brne	.-14     	; 0x2db4 <strncpy+0x4>
    2dc2:	01 c0       	rjmp	.+2      	; 0x2dc6 <strncpy+0x16>
    2dc4:	1d 92       	st	X+, r1
    2dc6:	41 50       	subi	r20, 0x01	; 1
    2dc8:	50 40       	sbci	r21, 0x00	; 0
    2dca:	e0 f7       	brcc	.-8      	; 0x2dc4 <strncpy+0x14>
    2dcc:	08 95       	ret

00002dce <__do_global_dtors>:
    2dce:	10 e0       	ldi	r17, 0x00	; 0
    2dd0:	c3 e7       	ldi	r28, 0x73	; 115
    2dd2:	d0 e0       	ldi	r29, 0x00	; 0
    2dd4:	00 e0       	ldi	r16, 0x00	; 0
    2dd6:	05 c0       	rjmp	.+10     	; 0x2de2 <__do_global_dtors+0x14>
    2dd8:	80 2f       	mov	r24, r16
    2dda:	fe 01       	movw	r30, r28
    2ddc:	aa de       	rcall	.-684    	; 0x2b32 <__tablejump2__>
    2dde:	21 96       	adiw	r28, 0x01	; 1
    2de0:	01 1d       	adc	r16, r1
    2de2:	c4 37       	cpi	r28, 0x74	; 116
    2de4:	d1 07       	cpc	r29, r17
    2de6:	80 e0       	ldi	r24, 0x00	; 0
    2de8:	08 07       	cpc	r16, r24
    2dea:	b1 f7       	brne	.-20     	; 0x2dd8 <__do_global_dtors+0xa>
    2dec:	f8 94       	cli

00002dee <__stop_program>:
    2dee:	ff cf       	rjmp	.-2      	; 0x2dee <__stop_program>
