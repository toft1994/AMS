
RobotSorter.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000000be  00800200  00002678  0000270c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002678  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000621  008002be  008002be  000027ca  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000027ca  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  000027fc  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000568  00000000  00000000  0000283c  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00007637  00000000  00000000  00002da4  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000030d0  00000000  00000000  0000a3db  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00003037  00000000  00000000  0000d4ab  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000fb4  00000000  00000000  000104e4  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00001cdb  00000000  00000000  00011498  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000039f7  00000000  00000000  00013173  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000490  00000000  00000000  00016b6a  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	71 c0       	rjmp	.+226    	; 0xe4 <__ctors_end>
       2:	00 00       	nop
       4:	8f c0       	rjmp	.+286    	; 0x124 <__bad_interrupt>
       6:	00 00       	nop
       8:	8d c0       	rjmp	.+282    	; 0x124 <__bad_interrupt>
       a:	00 00       	nop
       c:	8b c0       	rjmp	.+278    	; 0x124 <__bad_interrupt>
       e:	00 00       	nop
      10:	89 c0       	rjmp	.+274    	; 0x124 <__bad_interrupt>
      12:	00 00       	nop
      14:	87 c0       	rjmp	.+270    	; 0x124 <__bad_interrupt>
      16:	00 00       	nop
      18:	85 c0       	rjmp	.+266    	; 0x124 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	83 c0       	rjmp	.+262    	; 0x124 <__bad_interrupt>
      1e:	00 00       	nop
      20:	81 c0       	rjmp	.+258    	; 0x124 <__bad_interrupt>
      22:	00 00       	nop
      24:	7f c0       	rjmp	.+254    	; 0x124 <__bad_interrupt>
      26:	00 00       	nop
      28:	7d c0       	rjmp	.+250    	; 0x124 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	7b c0       	rjmp	.+246    	; 0x124 <__bad_interrupt>
      2e:	00 00       	nop
      30:	79 c0       	rjmp	.+242    	; 0x124 <__bad_interrupt>
      32:	00 00       	nop
      34:	77 c0       	rjmp	.+238    	; 0x124 <__bad_interrupt>
      36:	00 00       	nop
      38:	75 c0       	rjmp	.+234    	; 0x124 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	73 c0       	rjmp	.+230    	; 0x124 <__bad_interrupt>
      3e:	00 00       	nop
      40:	71 c0       	rjmp	.+226    	; 0x124 <__bad_interrupt>
      42:	00 00       	nop
      44:	6f c0       	rjmp	.+222    	; 0x124 <__bad_interrupt>
      46:	00 00       	nop
      48:	6d c0       	rjmp	.+218    	; 0x124 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	6b c0       	rjmp	.+214    	; 0x124 <__bad_interrupt>
      4e:	00 00       	nop
      50:	69 c0       	rjmp	.+210    	; 0x124 <__bad_interrupt>
      52:	00 00       	nop
      54:	67 c0       	rjmp	.+206    	; 0x124 <__bad_interrupt>
      56:	00 00       	nop
      58:	65 c0       	rjmp	.+202    	; 0x124 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	63 c0       	rjmp	.+198    	; 0x124 <__bad_interrupt>
      5e:	00 00       	nop
      60:	61 c0       	rjmp	.+194    	; 0x124 <__bad_interrupt>
      62:	00 00       	nop
      64:	5f c0       	rjmp	.+190    	; 0x124 <__bad_interrupt>
      66:	00 00       	nop
      68:	5d c0       	rjmp	.+186    	; 0x124 <__bad_interrupt>
      6a:	00 00       	nop
      6c:	5b c0       	rjmp	.+182    	; 0x124 <__bad_interrupt>
      6e:	00 00       	nop
      70:	59 c0       	rjmp	.+178    	; 0x124 <__bad_interrupt>
      72:	00 00       	nop
      74:	57 c0       	rjmp	.+174    	; 0x124 <__bad_interrupt>
      76:	00 00       	nop
      78:	55 c0       	rjmp	.+170    	; 0x124 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	53 c0       	rjmp	.+166    	; 0x124 <__bad_interrupt>
      7e:	00 00       	nop
      80:	51 c0       	rjmp	.+162    	; 0x124 <__bad_interrupt>
      82:	00 00       	nop
      84:	4f c0       	rjmp	.+158    	; 0x124 <__bad_interrupt>
      86:	00 00       	nop
      88:	4d c0       	rjmp	.+154    	; 0x124 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	4b c0       	rjmp	.+150    	; 0x124 <__bad_interrupt>
      8e:	00 00       	nop
      90:	49 c0       	rjmp	.+146    	; 0x124 <__bad_interrupt>
      92:	00 00       	nop
      94:	47 c0       	rjmp	.+142    	; 0x124 <__bad_interrupt>
      96:	00 00       	nop
      98:	45 c0       	rjmp	.+138    	; 0x124 <__bad_interrupt>
      9a:	00 00       	nop
      9c:	43 c0       	rjmp	.+134    	; 0x124 <__bad_interrupt>
      9e:	00 00       	nop
      a0:	41 c0       	rjmp	.+130    	; 0x124 <__bad_interrupt>
      a2:	00 00       	nop
      a4:	45 c2       	rjmp	.+1162   	; 0x530 <__vector_41>
      a6:	00 00       	nop
      a8:	3d c0       	rjmp	.+122    	; 0x124 <__bad_interrupt>
      aa:	00 00       	nop
      ac:	3b c0       	rjmp	.+118    	; 0x124 <__bad_interrupt>
      ae:	00 00       	nop
      b0:	39 c0       	rjmp	.+114    	; 0x124 <__bad_interrupt>
      b2:	00 00       	nop
      b4:	18 c2       	rjmp	.+1072   	; 0x4e6 <__vector_45>
      b6:	00 00       	nop
      b8:	35 c0       	rjmp	.+106    	; 0x124 <__bad_interrupt>
      ba:	00 00       	nop
      bc:	0c 94 70 0c 	jmp	0x18e0	; 0x18e0 <__vector_47>
      c0:	31 c0       	rjmp	.+98     	; 0x124 <__bad_interrupt>
      c2:	00 00       	nop
      c4:	2f c0       	rjmp	.+94     	; 0x124 <__bad_interrupt>
      c6:	00 00       	nop
      c8:	2d c0       	rjmp	.+90     	; 0x124 <__bad_interrupt>
      ca:	00 00       	nop
      cc:	2b c0       	rjmp	.+86     	; 0x124 <__bad_interrupt>
      ce:	00 00       	nop
      d0:	29 c0       	rjmp	.+82     	; 0x124 <__bad_interrupt>
      d2:	00 00       	nop
      d4:	27 c0       	rjmp	.+78     	; 0x124 <__bad_interrupt>
      d6:	00 00       	nop
      d8:	25 c0       	rjmp	.+74     	; 0x124 <__bad_interrupt>
      da:	00 00       	nop
      dc:	23 c0       	rjmp	.+70     	; 0x124 <__bad_interrupt>
      de:	00 00       	nop
      e0:	21 c0       	rjmp	.+66     	; 0x124 <__bad_interrupt>
	...

000000e4 <__ctors_end>:
      e4:	11 24       	eor	r1, r1
      e6:	1f be       	out	0x3f, r1	; 63
      e8:	cf ef       	ldi	r28, 0xFF	; 255
      ea:	d1 e2       	ldi	r29, 0x21	; 33
      ec:	de bf       	out	0x3e, r29	; 62
      ee:	cd bf       	out	0x3d, r28	; 61
      f0:	00 e0       	ldi	r16, 0x00	; 0
      f2:	0c bf       	out	0x3c, r16	; 60

000000f4 <__do_copy_data>:
      f4:	12 e0       	ldi	r17, 0x02	; 2
      f6:	a0 e0       	ldi	r26, 0x00	; 0
      f8:	b2 e0       	ldi	r27, 0x02	; 2
      fa:	e8 e7       	ldi	r30, 0x78	; 120
      fc:	f6 e2       	ldi	r31, 0x26	; 38
      fe:	00 e0       	ldi	r16, 0x00	; 0
     100:	0b bf       	out	0x3b, r16	; 59
     102:	02 c0       	rjmp	.+4      	; 0x108 <__do_copy_data+0x14>
     104:	07 90       	elpm	r0, Z+
     106:	0d 92       	st	X+, r0
     108:	ae 3b       	cpi	r26, 0xBE	; 190
     10a:	b1 07       	cpc	r27, r17
     10c:	d9 f7       	brne	.-10     	; 0x104 <__do_copy_data+0x10>

0000010e <__do_clear_bss>:
     10e:	28 e0       	ldi	r18, 0x08	; 8
     110:	ae eb       	ldi	r26, 0xBE	; 190
     112:	b2 e0       	ldi	r27, 0x02	; 2
     114:	01 c0       	rjmp	.+2      	; 0x118 <.do_clear_bss_start>

00000116 <.do_clear_bss_loop>:
     116:	1d 92       	st	X+, r1

00000118 <.do_clear_bss_start>:
     118:	af 3d       	cpi	r26, 0xDF	; 223
     11a:	b2 07       	cpc	r27, r18
     11c:	e1 f7       	brne	.-8      	; 0x116 <.do_clear_bss_loop>
     11e:	43 d3       	rcall	.+1670   	; 0x7a6 <main>
     120:	0c 94 3a 13 	jmp	0x2674	; 0x2674 <_exit>

00000124 <__bad_interrupt>:
     124:	6d cf       	rjmp	.-294    	; 0x0 <__vectors>

00000126 <_ZN5ColorC1Ev>:
}

uint8_t Color::getColorIndex( void )
{
	return _colorIndex;
}
     126:	08 95       	ret

00000128 <_ZN5Color12getRedPeriodEv>:
     128:	fc 01       	movw	r30, r24
     12a:	80 81       	ld	r24, Z
     12c:	91 81       	ldd	r25, Z+1	; 0x01
     12e:	08 95       	ret

00000130 <_ZN5Color13getBluePeriodEv>:
     130:	fc 01       	movw	r30, r24
     132:	82 81       	ldd	r24, Z+2	; 0x02
     134:	93 81       	ldd	r25, Z+3	; 0x03
     136:	08 95       	ret

00000138 <_ZN5Color14getGreenPeriodEv>:
     138:	fc 01       	movw	r30, r24
     13a:	84 81       	ldd	r24, Z+4	; 0x04
     13c:	95 81       	ldd	r25, Z+5	; 0x05
     13e:	08 95       	ret

00000140 <_ZN5Color14getWhitePeriodEv>:
     140:	fc 01       	movw	r30, r24
     142:	86 81       	ldd	r24, Z+6	; 0x06
     144:	97 81       	ldd	r25, Z+7	; 0x07
     146:	08 95       	ret

00000148 <_ZN5Color12setRedPeriodEj>:

void Color::setRedPeriod( uint16_t redPeriod )
{
	_redPeriod = redPeriod;
     148:	fc 01       	movw	r30, r24
     14a:	71 83       	std	Z+1, r23	; 0x01
     14c:	60 83       	st	Z, r22
     14e:	08 95       	ret

00000150 <_ZN5Color13setBluePeriodEj>:
}

void Color::setBluePeriod( uint16_t bluePeriod )
{
	_bluePeriod = bluePeriod;
     150:	fc 01       	movw	r30, r24
     152:	73 83       	std	Z+3, r23	; 0x03
     154:	62 83       	std	Z+2, r22	; 0x02
     156:	08 95       	ret

00000158 <_ZN5Color14setGreenPeriodEj>:
}

void Color::setGreenPeriod( uint16_t greenPeriod )
{
	_greenPeriod = greenPeriod;
     158:	fc 01       	movw	r30, r24
     15a:	75 83       	std	Z+5, r23	; 0x05
     15c:	64 83       	std	Z+4, r22	; 0x04
     15e:	08 95       	ret

00000160 <_ZN5Color14setWhitePeriodEj>:
}

void Color::setWhitePeriod( uint16_t whitePeriod )
{
	_whitePeriod = whitePeriod;
     160:	fc 01       	movw	r30, r24
     162:	77 83       	std	Z+7, r23	; 0x07
     164:	66 83       	std	Z+6, r22	; 0x06
     166:	08 95       	ret

00000168 <_ZN5Color13setColorIndexEh>:
}

void Color::setColorIndex( uint8_t index )
{
	_colorIndex = index;
     168:	fc 01       	movw	r30, r24
     16a:	60 87       	std	Z+8, r22	; 0x08
     16c:	08 95       	ret

0000016e <_ZN11ColorSensor9setFilterE6Filter>:
	}
}

void ColorSensor::setFilter( Filter filter_ )
{
	switch ( filter_ )
     16e:	61 30       	cpi	r22, 0x01	; 1
     170:	31 f0       	breq	.+12     	; 0x17e <_ZN11ColorSensor9setFilterE6Filter+0x10>
     172:	d0 f0       	brcs	.+52     	; 0x1a8 <_ZN11ColorSensor9setFilterE6Filter+0x3a>
     174:	62 30       	cpi	r22, 0x02	; 2
     176:	89 f0       	breq	.+34     	; 0x19a <_ZN11ColorSensor9setFilterE6Filter+0x2c>
     178:	63 30       	cpi	r22, 0x03	; 3
     17a:	41 f0       	breq	.+16     	; 0x18c <_ZN11ColorSensor9setFilterE6Filter+0x1e>
     17c:	08 95       	ret
	{
	case redFilter:
		COLORSENSOR_S2_PORT &= ~( COLORSENSOR_S2_PIN );
     17e:	88 b1       	in	r24, 0x08	; 8
     180:	8b 7f       	andi	r24, 0xFB	; 251
     182:	88 b9       	out	0x08, r24	; 8
		COLORSENSOR_S3_PORT &= ~( COLORSENSOR_S3_PIN );
     184:	88 b1       	in	r24, 0x08	; 8
     186:	87 7f       	andi	r24, 0xF7	; 247
     188:	88 b9       	out	0x08, r24	; 8
		break;
     18a:	08 95       	ret

	case blueFilter:
		COLORSENSOR_S2_PORT &= ~( COLORSENSOR_S2_PIN );
     18c:	88 b1       	in	r24, 0x08	; 8
     18e:	8b 7f       	andi	r24, 0xFB	; 251
     190:	88 b9       	out	0x08, r24	; 8
		COLORSENSOR_S3_PORT |= COLORSENSOR_S3_PIN;
     192:	88 b1       	in	r24, 0x08	; 8
     194:	88 60       	ori	r24, 0x08	; 8
     196:	88 b9       	out	0x08, r24	; 8
		break;
     198:	08 95       	ret

	case greenFilter:
		COLORSENSOR_S2_PORT |= COLORSENSOR_S2_PIN;
     19a:	88 b1       	in	r24, 0x08	; 8
     19c:	84 60       	ori	r24, 0x04	; 4
     19e:	88 b9       	out	0x08, r24	; 8
		COLORSENSOR_S3_PORT |= COLORSENSOR_S3_PIN;
     1a0:	88 b1       	in	r24, 0x08	; 8
     1a2:	88 60       	ori	r24, 0x08	; 8
     1a4:	88 b9       	out	0x08, r24	; 8
		break;
     1a6:	08 95       	ret

	case noFilter:
		COLORSENSOR_S2_PORT |= COLORSENSOR_S2_PIN;
     1a8:	88 b1       	in	r24, 0x08	; 8
     1aa:	84 60       	ori	r24, 0x04	; 4
     1ac:	88 b9       	out	0x08, r24	; 8
		COLORSENSOR_S3_PORT &= ~( COLORSENSOR_S3_PIN );
     1ae:	88 b1       	in	r24, 0x08	; 8
     1b0:	87 7f       	andi	r24, 0xF7	; 247
     1b2:	88 b9       	out	0x08, r24	; 8
     1b4:	08 95       	ret

000001b6 <_ZN11ColorSensor8getColorEv>:
ColorSensor::~ColorSensor()
{	
}

uint8_t ColorSensor::getColor()
{
     1b6:	3f 92       	push	r3
     1b8:	4f 92       	push	r4
     1ba:	5f 92       	push	r5
     1bc:	6f 92       	push	r6
     1be:	7f 92       	push	r7
     1c0:	8f 92       	push	r8
     1c2:	9f 92       	push	r9
     1c4:	af 92       	push	r10
     1c6:	bf 92       	push	r11
     1c8:	cf 92       	push	r12
     1ca:	df 92       	push	r13
     1cc:	ef 92       	push	r14
     1ce:	ff 92       	push	r15
     1d0:	0f 93       	push	r16
     1d2:	1f 93       	push	r17
     1d4:	cf 93       	push	r28
     1d6:	df 93       	push	r29
     1d8:	00 d0       	rcall	.+0      	; 0x1da <_ZN11ColorSensor8getColorEv+0x24>
     1da:	1f 92       	push	r1
     1dc:	cd b7       	in	r28, 0x3d	; 61
     1de:	de b7       	in	r29, 0x3e	; 62
     1e0:	7c 01       	movw	r14, r24
	setFilter( redFilter );
     1e2:	61 e0       	ldi	r22, 0x01	; 1
     1e4:	c4 df       	rcall	.-120    	; 0x16e <_ZN11ColorSensor9setFilterE6Filter>
	uint16_t redPeriod = frequency_.getPeriod();
     1e6:	c7 01       	movw	r24, r14
     1e8:	49 d1       	rcall	.+658    	; 0x47c <_ZN6timer49getPeriodEv>
     1ea:	5c 01       	movw	r10, r24

	setFilter( blueFilter );
     1ec:	63 e0       	ldi	r22, 0x03	; 3
     1ee:	c7 01       	movw	r24, r14
	uint16_t bluePeriod = frequency_.getPeriod();  
     1f0:	be df       	rcall	.-132    	; 0x16e <_ZN11ColorSensor9setFilterE6Filter>
     1f2:	c7 01       	movw	r24, r14
     1f4:	43 d1       	rcall	.+646    	; 0x47c <_ZN6timer49getPeriodEv>

	setFilter( greenFilter );
     1f6:	3c 01       	movw	r6, r24
     1f8:	62 e0       	ldi	r22, 0x02	; 2
     1fa:	c7 01       	movw	r24, r14
	uint16_t greenPeriod = frequency_.getPeriod();
     1fc:	b8 df       	rcall	.-144    	; 0x16e <_ZN11ColorSensor9setFilterE6Filter>
     1fe:	c7 01       	movw	r24, r14
	
	setFilter( noFilter );
     200:	3d d1       	rcall	.+634    	; 0x47c <_ZN6timer49getPeriodEv>
     202:	2c 01       	movw	r4, r24
     204:	60 e0       	ldi	r22, 0x00	; 0
     206:	c7 01       	movw	r24, r14
	uint16_t whitePeriod = frequency_.getPeriod();
     208:	b2 df       	rcall	.-156    	; 0x16e <_ZN11ColorSensor9setFilterE6Filter>
     20a:	c7 01       	movw	r24, r14
     20c:	37 d1       	rcall	.+622    	; 0x47c <_ZN6timer49getPeriodEv>
     20e:	9a 83       	std	Y+2, r25	; 0x02
     210:	89 83       	std	Y+1, r24	; 0x01
	//
	//SendString("NoFilter: ");
	//SendInteger((int)whitePeriod);
	//SendString("\n\r\n\r");
	
	for ( uint8_t index = 0U; index < 10; index++)
     212:	31 2c       	mov	r3, r1
     214:	29 e0       	ldi	r18, 0x09	; 9
     216:	23 15       	cp	r18, r3
     218:	08 f4       	brcc	.+2      	; 0x21c <_ZN11ColorSensor8getColorEv+0x66>
     21a:	51 c0       	rjmp	.+162    	; 0x2be <_ZN11ColorSensor8getColorEv+0x108>
	{
		uint16_t storedRed = _colors[index].getRedPeriod();
     21c:	43 2d       	mov	r20, r3
     21e:	50 e0       	ldi	r21, 0x00	; 0
     220:	ca 01       	movw	r24, r20
     222:	88 0f       	add	r24, r24
     224:	99 1f       	adc	r25, r25
     226:	88 0f       	add	r24, r24
     228:	99 1f       	adc	r25, r25
     22a:	88 0f       	add	r24, r24
     22c:	99 1f       	adc	r25, r25
     22e:	48 0f       	add	r20, r24
     230:	59 1f       	adc	r21, r25
     232:	4f 5f       	subi	r20, 0xFF	; 255
     234:	5f 4f       	sbci	r21, 0xFF	; 255
     236:	4e 0d       	add	r20, r14
     238:	5f 1d       	adc	r21, r15
     23a:	5c 83       	std	Y+4, r21	; 0x04
     23c:	4b 83       	std	Y+3, r20	; 0x03
     23e:	ca 01       	movw	r24, r20
		uint16_t storedBlue = _colors[index].getBluePeriod();
     240:	73 df       	rcall	.-282    	; 0x128 <_ZN5Color12getRedPeriodEv>
     242:	8c 01       	movw	r16, r24
     244:	8b 81       	ldd	r24, Y+3	; 0x03
     246:	9c 81       	ldd	r25, Y+4	; 0x04
		uint16_t storedGreen = _colors[index].getGreenPeriod();		
     248:	73 df       	rcall	.-282    	; 0x130 <_ZN5Color13getBluePeriodEv>
     24a:	6c 01       	movw	r12, r24
     24c:	8b 81       	ldd	r24, Y+3	; 0x03
     24e:	9c 81       	ldd	r25, Y+4	; 0x04
     250:	73 df       	rcall	.-282    	; 0x138 <_ZN5Color14getGreenPeriodEv>
		uint16_t storedWhite = _colors[index].getWhitePeriod();
     252:	4c 01       	movw	r8, r24
     254:	8b 81       	ldd	r24, Y+3	; 0x03
     256:	9c 81       	ldd	r25, Y+4	; 0x04
     258:	73 df       	rcall	.-282    	; 0x140 <_ZN5Color14getWhitePeriodEv>
		
		if ( storedRed + 20 > redPeriod && storedRed - 20 < redPeriod )
     25a:	98 01       	movw	r18, r16
     25c:	2c 5e       	subi	r18, 0xEC	; 236
     25e:	3f 4f       	sbci	r19, 0xFF	; 255
     260:	a2 16       	cp	r10, r18
     262:	b3 06       	cpc	r11, r19
     264:	50 f5       	brcc	.+84     	; 0x2ba <_ZN11ColorSensor8getColorEv+0x104>
     266:	04 51       	subi	r16, 0x14	; 20
     268:	11 09       	sbc	r17, r1
     26a:	0a 15       	cp	r16, r10
     26c:	1b 05       	cpc	r17, r11
     26e:	28 f5       	brcc	.+74     	; 0x2ba <_ZN11ColorSensor8getColorEv+0x104>
		{
			if ( storedBlue + 20 > bluePeriod && storedBlue - 20 < bluePeriod )
     270:	96 01       	movw	r18, r12
     272:	2c 5e       	subi	r18, 0xEC	; 236
     274:	3f 4f       	sbci	r19, 0xFF	; 255
     276:	62 16       	cp	r6, r18
     278:	73 06       	cpc	r7, r19
     27a:	f8 f4       	brcc	.+62     	; 0x2ba <_ZN11ColorSensor8getColorEv+0x104>
     27c:	54 e1       	ldi	r21, 0x14	; 20
     27e:	c5 1a       	sub	r12, r21
     280:	d1 08       	sbc	r13, r1
     282:	c6 14       	cp	r12, r6
     284:	d7 04       	cpc	r13, r7
     286:	c8 f4       	brcc	.+50     	; 0x2ba <_ZN11ColorSensor8getColorEv+0x104>
			{
				if ( storedGreen + 20 > greenPeriod && storedGreen - 20 < greenPeriod )
     288:	94 01       	movw	r18, r8
     28a:	2c 5e       	subi	r18, 0xEC	; 236
     28c:	3f 4f       	sbci	r19, 0xFF	; 255
     28e:	42 16       	cp	r4, r18
     290:	53 06       	cpc	r5, r19
     292:	98 f4       	brcc	.+38     	; 0x2ba <_ZN11ColorSensor8getColorEv+0x104>
     294:	24 e1       	ldi	r18, 0x14	; 20
     296:	82 1a       	sub	r8, r18
     298:	91 08       	sbc	r9, r1
     29a:	84 14       	cp	r8, r4
     29c:	95 04       	cpc	r9, r5
     29e:	68 f4       	brcc	.+26     	; 0x2ba <_ZN11ColorSensor8getColorEv+0x104>
				{
					if ( storedWhite + 100 > whitePeriod && storedWhite - 100 < whitePeriod )
     2a0:	9c 01       	movw	r18, r24
     2a2:	2c 59       	subi	r18, 0x9C	; 156
     2a4:	3f 4f       	sbci	r19, 0xFF	; 255
     2a6:	49 81       	ldd	r20, Y+1	; 0x01
     2a8:	5a 81       	ldd	r21, Y+2	; 0x02
     2aa:	42 17       	cp	r20, r18
     2ac:	53 07       	cpc	r21, r19
     2ae:	28 f4       	brcc	.+10     	; 0x2ba <_ZN11ColorSensor8getColorEv+0x104>
     2b0:	84 56       	subi	r24, 0x64	; 100
     2b2:	91 09       	sbc	r25, r1
     2b4:	84 17       	cp	r24, r20
     2b6:	95 07       	cpc	r25, r21
     2b8:	20 f0       	brcs	.+8      	; 0x2c2 <_ZN11ColorSensor8getColorEv+0x10c>
	//
	//SendString("NoFilter: ");
	//SendInteger((int)whitePeriod);
	//SendString("\n\r\n\r");
	
	for ( uint8_t index = 0U; index < 10; index++)
     2ba:	33 94       	inc	r3
     2bc:	ab cf       	rjmp	.-170    	; 0x214 <_ZN11ColorSensor8getColorEv+0x5e>
				}
			}
		}
	}

	return 255;
     2be:	8f ef       	ldi	r24, 0xFF	; 255
     2c0:	01 c0       	rjmp	.+2      	; 0x2c4 <_ZN11ColorSensor8getColorEv+0x10e>
			{
				if ( storedGreen + 20 > greenPeriod && storedGreen - 20 < greenPeriod )
				{
					if ( storedWhite + 100 > whitePeriod && storedWhite - 100 < whitePeriod )
					{
						return index;
     2c2:	83 2d       	mov	r24, r3
			}
		}
	}

	return 255;
}
     2c4:	0f 90       	pop	r0
     2c6:	0f 90       	pop	r0
     2c8:	0f 90       	pop	r0
     2ca:	0f 90       	pop	r0
     2cc:	df 91       	pop	r29
     2ce:	cf 91       	pop	r28
     2d0:	1f 91       	pop	r17
     2d2:	0f 91       	pop	r16
     2d4:	ff 90       	pop	r15
     2d6:	ef 90       	pop	r14
     2d8:	df 90       	pop	r13
     2da:	cf 90       	pop	r12
     2dc:	bf 90       	pop	r11
     2de:	af 90       	pop	r10
     2e0:	9f 90       	pop	r9
     2e2:	8f 90       	pop	r8
     2e4:	7f 90       	pop	r7
     2e6:	6f 90       	pop	r6
     2e8:	5f 90       	pop	r5
     2ea:	4f 90       	pop	r4
     2ec:	3f 90       	pop	r3
     2ee:	08 95       	ret

000002f0 <_ZN11ColorSensor17addCalibrateColorEh>:

void ColorSensor::addCalibrateColor( uint8_t colorIndex )
{
     2f0:	df 92       	push	r13
     2f2:	ef 92       	push	r14
     2f4:	ff 92       	push	r15
     2f6:	0f 93       	push	r16
     2f8:	1f 93       	push	r17
     2fa:	cf 93       	push	r28
     2fc:	df 93       	push	r29
	if ( colorIndex < 10U )
     2fe:	6a 30       	cpi	r22, 0x0A	; 10
     300:	08 f0       	brcs	.+2      	; 0x304 <_ZN11ColorSensor17addCalibrateColorEh+0x14>
     302:	4a c0       	rjmp	.+148    	; 0x398 <_ZN11ColorSensor17addCalibrateColorEh+0xa8>
     304:	d6 2e       	mov	r13, r22
     306:	ec 01       	movw	r28, r24
	{
		uint16_t period = 0;
		
		// Set all colors
		setFilter( redFilter );
     308:	61 e0       	ldi	r22, 0x01	; 1
     30a:	31 df       	rcall	.-414    	; 0x16e <_ZN11ColorSensor9setFilterE6Filter>

void ColorSensor::addCalibrateColor( uint8_t colorIndex )
{
	if ( colorIndex < 10U )
	{
		uint16_t period = 0;
     30c:	80 e0       	ldi	r24, 0x00	; 0
     30e:	90 e0       	ldi	r25, 0x00	; 0
		
		// Set all colors
		setFilter( redFilter );
		while( period == 0 )
     310:	00 97       	sbiw	r24, 0x00	; 0
     312:	19 f4       	brne	.+6      	; 0x31a <_ZN11ColorSensor17addCalibrateColorEh+0x2a>
		{
			period = frequency_.getPeriod();
     314:	ce 01       	movw	r24, r28
     316:	b2 d0       	rcall	.+356    	; 0x47c <_ZN6timer49getPeriodEv>
	{
		uint16_t period = 0;
		
		// Set all colors
		setFilter( redFilter );
		while( period == 0 )
     318:	fb cf       	rjmp	.-10     	; 0x310 <_ZN11ColorSensor17addCalibrateColorEh+0x20>
		{
			period = frequency_.getPeriod();
		}
		_colors[colorIndex].setRedPeriod( period );
     31a:	2d 2d       	mov	r18, r13
     31c:	30 e0       	ldi	r19, 0x00	; 0
     31e:	79 01       	movw	r14, r18
     320:	ee 0c       	add	r14, r14
     322:	ff 1c       	adc	r15, r15
     324:	ee 0c       	add	r14, r14
     326:	ff 1c       	adc	r15, r15
     328:	ee 0c       	add	r14, r14
     32a:	ff 1c       	adc	r15, r15
     32c:	e2 0e       	add	r14, r18
     32e:	f3 1e       	adc	r15, r19
     330:	2f ef       	ldi	r18, 0xFF	; 255
     332:	e2 1a       	sub	r14, r18
     334:	f2 0a       	sbc	r15, r18
     336:	ec 0e       	add	r14, r28
     338:	fd 1e       	adc	r15, r29
     33a:	bc 01       	movw	r22, r24
     33c:	c7 01       	movw	r24, r14
     33e:	04 df       	rcall	.-504    	; 0x148 <_ZN5Color12setRedPeriodEj>
		period = 0;

		setFilter( blueFilter );
     340:	63 e0       	ldi	r22, 0x03	; 3
     342:	ce 01       	movw	r24, r28
     344:	14 df       	rcall	.-472    	; 0x16e <_ZN11ColorSensor9setFilterE6Filter>
     346:	80 e0       	ldi	r24, 0x00	; 0
		while( period == 0 )
		{
			period = frequency_.getPeriod();
		}
		_colors[colorIndex].setRedPeriod( period );
		period = 0;
     348:	90 e0       	ldi	r25, 0x00	; 0

		setFilter( blueFilter );
		while( period == 0 )
     34a:	00 97       	sbiw	r24, 0x00	; 0
     34c:	19 f4       	brne	.+6      	; 0x354 <_ZN11ColorSensor17addCalibrateColorEh+0x64>
		{
			period = frequency_.getPeriod();
     34e:	ce 01       	movw	r24, r28
     350:	95 d0       	rcall	.+298    	; 0x47c <_ZN6timer49getPeriodEv>
		}
		_colors[colorIndex].setRedPeriod( period );
		period = 0;

		setFilter( blueFilter );
		while( period == 0 )
     352:	fb cf       	rjmp	.-10     	; 0x34a <_ZN11ColorSensor17addCalibrateColorEh+0x5a>
		{
			period = frequency_.getPeriod();
		}
		_colors[colorIndex].setBluePeriod( period );
     354:	bc 01       	movw	r22, r24
     356:	c7 01       	movw	r24, r14
     358:	fb de       	rcall	.-522    	; 0x150 <_ZN5Color13setBluePeriodEj>
		period = 0;
		
		setFilter( greenFilter );
     35a:	62 e0       	ldi	r22, 0x02	; 2
     35c:	ce 01       	movw	r24, r28
     35e:	07 df       	rcall	.-498    	; 0x16e <_ZN11ColorSensor9setFilterE6Filter>
		while( period == 0 )
		{
			period = frequency_.getPeriod();
		}
		_colors[colorIndex].setBluePeriod( period );
		period = 0;
     360:	00 e0       	ldi	r16, 0x00	; 0
     362:	10 e0       	ldi	r17, 0x00	; 0
		
		setFilter( greenFilter );
		while( period == 0 )
     364:	01 15       	cp	r16, r1
     366:	11 05       	cpc	r17, r1
		{
			period = frequency_.getPeriod();
     368:	21 f4       	brne	.+8      	; 0x372 <_ZN11ColorSensor17addCalibrateColorEh+0x82>
     36a:	ce 01       	movw	r24, r28
     36c:	87 d0       	rcall	.+270    	; 0x47c <_ZN6timer49getPeriodEv>
		}
		_colors[colorIndex].setBluePeriod( period );
		period = 0;
		
		setFilter( greenFilter );
		while( period == 0 )
     36e:	8c 01       	movw	r16, r24
		{
			period = frequency_.getPeriod();
		}
		_colors[colorIndex].setGreenPeriod( period );
     370:	f9 cf       	rjmp	.-14     	; 0x364 <_ZN11ColorSensor17addCalibrateColorEh+0x74>
     372:	b8 01       	movw	r22, r16
     374:	c7 01       	movw	r24, r14
		
		setFilter( noFilter );
     376:	f0 de       	rcall	.-544    	; 0x158 <_ZN5Color14setGreenPeriodEj>
     378:	60 e0       	ldi	r22, 0x00	; 0
     37a:	ce 01       	movw	r24, r28
		while( period == 0 )
     37c:	f8 de       	rcall	.-528    	; 0x16e <_ZN11ColorSensor9setFilterE6Filter>
     37e:	01 15       	cp	r16, r1
		{
			period = frequency_.getPeriod();
     380:	11 05       	cpc	r17, r1
     382:	21 f4       	brne	.+8      	; 0x38c <_ZN11ColorSensor17addCalibrateColorEh+0x9c>
     384:	ce 01       	movw	r24, r28
     386:	7a d0       	rcall	.+244    	; 0x47c <_ZN6timer49getPeriodEv>
			period = frequency_.getPeriod();
		}
		_colors[colorIndex].setGreenPeriod( period );
		
		setFilter( noFilter );
		while( period == 0 )
     388:	8c 01       	movw	r16, r24
		{
			period = frequency_.getPeriod();
		}
		_colors[colorIndex].setWhitePeriod( period );
     38a:	f9 cf       	rjmp	.-14     	; 0x37e <_ZN11ColorSensor17addCalibrateColorEh+0x8e>
     38c:	b8 01       	movw	r22, r16
     38e:	c7 01       	movw	r24, r14
     390:	e7 de       	rcall	.-562    	; 0x160 <_ZN5Color14setWhitePeriodEj>
		
		// Set index
		_colors[colorIndex].setColorIndex(colorIndex);
     392:	6d 2d       	mov	r22, r13
     394:	c7 01       	movw	r24, r14
     396:	e8 de       	rcall	.-560    	; 0x168 <_ZN5Color13setColorIndexEh>
     398:	df 91       	pop	r29
	}
	else
	{
		/* Cant add more colors. Increase size of array. */
	}
}
     39a:	cf 91       	pop	r28
     39c:	1f 91       	pop	r17
     39e:	0f 91       	pop	r16
     3a0:	ff 90       	pop	r15
     3a2:	ef 90       	pop	r14
     3a4:	df 90       	pop	r13
     3a6:	08 95       	ret

000003a8 <_ZN11ColorSensor19setFrequencyscalingE16FrequencyScaling>:
     3a8:	61 30       	cpi	r22, 0x01	; 1
	}	
}

void ColorSensor::setFrequencyscaling( FrequencyScaling scaling )
{
	switch (scaling)
     3aa:	69 f0       	breq	.+26     	; 0x3c6 <_ZN11ColorSensor19setFrequencyscalingE16FrequencyScaling+0x1e>
     3ac:	28 f0       	brcs	.+10     	; 0x3b8 <_ZN11ColorSensor19setFrequencyscalingE16FrequencyScaling+0x10>
     3ae:	62 30       	cpi	r22, 0x02	; 2
     3b0:	89 f0       	breq	.+34     	; 0x3d4 <_ZN11ColorSensor19setFrequencyscalingE16FrequencyScaling+0x2c>
     3b2:	63 30       	cpi	r22, 0x03	; 3
     3b4:	b1 f0       	breq	.+44     	; 0x3e2 <_ZN11ColorSensor19setFrequencyscalingE16FrequencyScaling+0x3a>
     3b6:	08 95       	ret
	{
	case powerDown:
		COLORSENSOR_S0_PORT &= ~( COLORSENSOR_S0_PIN );
     3b8:	88 b1       	in	r24, 0x08	; 8
     3ba:	8e 7f       	andi	r24, 0xFE	; 254
     3bc:	88 b9       	out	0x08, r24	; 8
		COLORSENSOR_S1_PORT &= ~( COLORSENSOR_S1_PIN );
     3be:	88 b1       	in	r24, 0x08	; 8
     3c0:	8d 7f       	andi	r24, 0xFD	; 253
     3c2:	88 b9       	out	0x08, r24	; 8
		break;
     3c4:	08 95       	ret

	case twoPercent:
		COLORSENSOR_S0_PORT &= ~( COLORSENSOR_S0_PIN );
     3c6:	88 b1       	in	r24, 0x08	; 8
     3c8:	8e 7f       	andi	r24, 0xFE	; 254
     3ca:	88 b9       	out	0x08, r24	; 8
		COLORSENSOR_S1_PORT |= COLORSENSOR_S1_PIN;
     3cc:	88 b1       	in	r24, 0x08	; 8
     3ce:	82 60       	ori	r24, 0x02	; 2
     3d0:	88 b9       	out	0x08, r24	; 8
		break;
     3d2:	08 95       	ret

	case twentyPercent:
		COLORSENSOR_S0_PORT |= COLORSENSOR_S0_PIN;
     3d4:	88 b1       	in	r24, 0x08	; 8
     3d6:	81 60       	ori	r24, 0x01	; 1
     3d8:	88 b9       	out	0x08, r24	; 8
		COLORSENSOR_S1_PORT &= ~( COLORSENSOR_S1_PIN );
     3da:	88 b1       	in	r24, 0x08	; 8
     3dc:	8d 7f       	andi	r24, 0xFD	; 253
     3de:	88 b9       	out	0x08, r24	; 8
		break;
     3e0:	08 95       	ret

	case hundredPercent:
		COLORSENSOR_S0_PORT |= COLORSENSOR_S0_PIN;
     3e2:	88 b1       	in	r24, 0x08	; 8
     3e4:	81 60       	ori	r24, 0x01	; 1
     3e6:	88 b9       	out	0x08, r24	; 8
		COLORSENSOR_S1_PORT |= COLORSENSOR_S1_PIN;
     3e8:	88 b1       	in	r24, 0x08	; 8
     3ea:	82 60       	ori	r24, 0x02	; 2
     3ec:	88 b9       	out	0x08, r24	; 8
     3ee:	08 95       	ret

000003f0 <_ZN11ColorSensorC1E16FrequencyScaling>:
#include "FreeRTOS.h"
#include "task.h"
#include "portmacro.h"

// default constructor
ColorSensor::ColorSensor( FrequencyScaling scaling )
     3f0:	bf 92       	push	r11
     3f2:	cf 92       	push	r12
     3f4:	df 92       	push	r13
     3f6:	ef 92       	push	r14
     3f8:	ff 92       	push	r15
     3fa:	0f 93       	push	r16
     3fc:	1f 93       	push	r17
     3fe:	cf 93       	push	r28
     400:	df 93       	push	r29
     402:	1f 92       	push	r1
     404:	cd b7       	in	r28, 0x3d	; 61
     406:	de b7       	in	r29, 0x3e	; 62
     408:	6c 01       	movw	r12, r24
     40a:	b6 2e       	mov	r11, r22
     40c:	29 d0       	rcall	.+82     	; 0x460 <_ZN6timer4C1Ev>
     40e:	76 01       	movw	r14, r12
     410:	8f ef       	ldi	r24, 0xFF	; 255
     412:	e8 1a       	sub	r14, r24
     414:	f8 0a       	sbc	r15, r24
     416:	09 e0       	ldi	r16, 0x09	; 9
     418:	10 e0       	ldi	r17, 0x00	; 0
     41a:	0f 3f       	cpi	r16, 0xFF	; 255
     41c:	8f ef       	ldi	r24, 0xFF	; 255
     41e:	18 07       	cpc	r17, r24
     420:	41 f0       	breq	.+16     	; 0x432 <__LOCK_REGION_LENGTH__+0x32>
     422:	c7 01       	movw	r24, r14
     424:	80 de       	rcall	.-768    	; 0x126 <_ZN5ColorC1Ev>
     426:	89 e0       	ldi	r24, 0x09	; 9
     428:	e8 0e       	add	r14, r24
     42a:	f1 1c       	adc	r15, r1
     42c:	01 50       	subi	r16, 0x01	; 1
     42e:	11 09       	sbc	r17, r1
     430:	f4 cf       	rjmp	.-24     	; 0x41a <__LOCK_REGION_LENGTH__+0x1a>
{
	DDRC = 0xFF;
     432:	8f ef       	ldi	r24, 0xFF	; 255
     434:	87 b9       	out	0x07, r24	; 7
	DDRD = 0x00;
     436:	1a b8       	out	0x0a, r1	; 10
	frequency_ = timer4();
     438:	ce 01       	movw	r24, r28
     43a:	01 96       	adiw	r24, 0x01	; 1
     43c:	11 d0       	rcall	.+34     	; 0x460 <_ZN6timer4C1Ev>

	setFilter( noFilter );
     43e:	60 e0       	ldi	r22, 0x00	; 0
     440:	c6 01       	movw	r24, r12
     442:	95 de       	rcall	.-726    	; 0x16e <_ZN11ColorSensor9setFilterE6Filter>
	setFrequencyscaling( scaling );
     444:	6b 2d       	mov	r22, r11
     446:	c6 01       	movw	r24, r12
     448:	af df       	rcall	.-162    	; 0x3a8 <_ZN11ColorSensor19setFrequencyscalingE16FrequencyScaling>
     44a:	0f 90       	pop	r0
}
     44c:	df 91       	pop	r29
     44e:	cf 91       	pop	r28
     450:	1f 91       	pop	r17
     452:	0f 91       	pop	r16
     454:	ff 90       	pop	r15
     456:	ef 90       	pop	r14
     458:	df 90       	pop	r13
     45a:	cf 90       	pop	r12
     45c:	bf 90       	pop	r11
     45e:	08 95       	ret

00000460 <_ZN6timer4C1Ev>:
//volatile float tick = 0.000064;

timer4::timer4()
{
	// Setup timer to normal mode and pre scaler to 1
	TCCR4A = 0U;
     460:	10 92 a0 00 	sts	0x00A0, r1	; 0x8000a0 <__TEXT_REGION_LENGTH__+0x7000a0>
	TCCR4B = ( 1 << ICNC4 ) | ( 1 << ICES4 ) | ( 1 << CS40 );
     464:	81 ec       	ldi	r24, 0xC1	; 193
     466:	80 93 a1 00 	sts	0x00A1, r24	; 0x8000a1 <__TEXT_REGION_LENGTH__+0x7000a1>
	TCCR4C = 0U;
     46a:	10 92 a2 00 	sts	0x00A2, r1	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
	
	// Clear flags and set counter to zero
	TIFR4 = ( 0 << ICF4 ) | ( 0 << TOV4 );
     46e:	19 ba       	out	0x19, r1	; 25
	TCNT4 = 0;        
     470:	10 92 a5 00 	sts	0x00A5, r1	; 0x8000a5 <__TEXT_REGION_LENGTH__+0x7000a5>
     474:	10 92 a4 00 	sts	0x00A4, r1	; 0x8000a4 <__TEXT_REGION_LENGTH__+0x7000a4>

	// Enable global interrupts
    sei();
     478:	78 94       	sei
     47a:	08 95       	ret

0000047c <_ZN6timer49getPeriodEv>:
/* RTOS include */
#include "FreeRTOS.h"
#include "task.h"
#include "portmacro.h"
uint16_t timer4::getPeriod( void )
{
     47c:	cf 93       	push	r28
	// Reset all needed values
	first = true;
     47e:	81 e0       	ldi	r24, 0x01	; 1
     480:	80 93 0a 02 	sts	0x020A, r24	; 0x80020a <first>
	oldValue = 0U;
     484:	10 92 c4 02 	sts	0x02C4, r1	; 0x8002c4 <oldValue>
     488:	10 92 c5 02 	sts	0x02C5, r1	; 0x8002c5 <oldValue+0x1>
     48c:	10 92 c6 02 	sts	0x02C6, r1	; 0x8002c6 <oldValue+0x2>
     490:	10 92 c7 02 	sts	0x02C7, r1	; 0x8002c7 <oldValue+0x3>
	period = 0U;
     494:	10 92 bf 02 	sts	0x02BF, r1	; 0x8002bf <__data_end+0x1>
     498:	10 92 be 02 	sts	0x02BE, r1	; 0x8002be <__data_end>
	timeroverflow = 0;
     49c:	10 92 c0 02 	sts	0x02C0, r1	; 0x8002c0 <timeroverflow>
     4a0:	10 92 c1 02 	sts	0x02C1, r1	; 0x8002c1 <timeroverflow+0x1>
     4a4:	10 92 c2 02 	sts	0x02C2, r1	; 0x8002c2 <timeroverflow+0x2>
     4a8:	10 92 c3 02 	sts	0x02C3, r1	; 0x8002c3 <timeroverflow+0x3>
	
	// Enable interrupt and clear pending
	TIFR4 = ( 0 << ICF4 ) | ( 0 << TOV4 );	
     4ac:	19 ba       	out	0x19, r1	; 25
	TIMSK4 = ( 1 << ICIE4 ) | ( 0 << TOIE4 );	
     4ae:	80 e2       	ldi	r24, 0x20	; 32
     4b0:	80 93 72 00 	sts	0x0072, r24	; 0x800072 <__TEXT_REGION_LENGTH__+0x700072>
	
	// Wait until measurement has been taken
	uint8_t timeout = 0U;
     4b4:	c0 e0       	ldi	r28, 0x00	; 0
	while ( period == 0U )
     4b6:	80 91 be 02 	lds	r24, 0x02BE	; 0x8002be <__data_end>
     4ba:	90 91 bf 02 	lds	r25, 0x02BF	; 0x8002bf <__data_end+0x1>
     4be:	89 2b       	or	r24, r25
     4c0:	61 f4       	brne	.+24     	; 0x4da <_ZN6timer49getPeriodEv+0x5e>
	{
		if ( timeout > 5U )
     4c2:	c6 30       	cpi	r28, 0x06	; 6
     4c4:	20 f0       	brcs	.+8      	; 0x4ce <_ZN6timer49getPeriodEv+0x52>
		{
			// Disable interrupt and clear pending
			TIMSK4 = 0U;
     4c6:	10 92 72 00 	sts	0x0072, r1	; 0x800072 <__TEXT_REGION_LENGTH__+0x700072>
			TIFR4 = 0U;
     4ca:	19 ba       	out	0x19, r1	; 25
			break;
     4cc:	06 c0       	rjmp	.+12     	; 0x4da <_ZN6timer49getPeriodEv+0x5e>
		}
		
		// Delay for timeout
		vTaskDelay( 1 / portTICK_RATE_MS );
     4ce:	81 e0       	ldi	r24, 0x01	; 1
     4d0:	90 e0       	ldi	r25, 0x00	; 0
     4d2:	0e 94 47 0f 	call	0x1e8e	; 0x1e8e <vTaskDelay>

		// Increment timeout
		timeout++;
     4d6:	cf 5f       	subi	r28, 0xFF	; 255
	TIFR4 = ( 0 << ICF4 ) | ( 0 << TOV4 );	
	TIMSK4 = ( 1 << ICIE4 ) | ( 0 << TOIE4 );	
	
	// Wait until measurement has been taken
	uint8_t timeout = 0U;
	while ( period == 0U )
     4d8:	ee cf       	rjmp	.-36     	; 0x4b6 <_ZN6timer49getPeriodEv+0x3a>

		// Increment timeout
		timeout++;
	}
	
	return period;
     4da:	80 91 be 02 	lds	r24, 0x02BE	; 0x8002be <__data_end>
     4de:	90 91 bf 02 	lds	r25, 0x02BF	; 0x8002bf <__data_end+0x1>
}
     4e2:	cf 91       	pop	r28
     4e4:	08 95       	ret

000004e6 <__vector_45>:

ISR(TIMER4_OVF_vect)
{
     4e6:	1f 92       	push	r1
     4e8:	0f 92       	push	r0
     4ea:	0f b6       	in	r0, 0x3f	; 63
     4ec:	0f 92       	push	r0
     4ee:	11 24       	eor	r1, r1
     4f0:	8f 93       	push	r24
     4f2:	9f 93       	push	r25
     4f4:	af 93       	push	r26
     4f6:	bf 93       	push	r27
	timeroverflow++;
     4f8:	80 91 c0 02 	lds	r24, 0x02C0	; 0x8002c0 <timeroverflow>
     4fc:	90 91 c1 02 	lds	r25, 0x02C1	; 0x8002c1 <timeroverflow+0x1>
     500:	a0 91 c2 02 	lds	r26, 0x02C2	; 0x8002c2 <timeroverflow+0x2>
     504:	b0 91 c3 02 	lds	r27, 0x02C3	; 0x8002c3 <timeroverflow+0x3>
     508:	01 96       	adiw	r24, 0x01	; 1
     50a:	a1 1d       	adc	r26, r1
     50c:	b1 1d       	adc	r27, r1
     50e:	80 93 c0 02 	sts	0x02C0, r24	; 0x8002c0 <timeroverflow>
     512:	90 93 c1 02 	sts	0x02C1, r25	; 0x8002c1 <timeroverflow+0x1>
     516:	a0 93 c2 02 	sts	0x02C2, r26	; 0x8002c2 <timeroverflow+0x2>
     51a:	b0 93 c3 02 	sts	0x02C3, r27	; 0x8002c3 <timeroverflow+0x3>
}
     51e:	bf 91       	pop	r27
     520:	af 91       	pop	r26
     522:	9f 91       	pop	r25
     524:	8f 91       	pop	r24
     526:	0f 90       	pop	r0
     528:	0f be       	out	0x3f, r0	; 63
     52a:	0f 90       	pop	r0
     52c:	1f 90       	pop	r1
     52e:	18 95       	reti

00000530 <__vector_41>:

ISR(TIMER4_CAPT_vect)
{
     530:	1f 92       	push	r1
     532:	0f 92       	push	r0
     534:	0f b6       	in	r0, 0x3f	; 63
     536:	0f 92       	push	r0
     538:	11 24       	eor	r1, r1
     53a:	0b b6       	in	r0, 0x3b	; 59
     53c:	0f 92       	push	r0
     53e:	cf 92       	push	r12
     540:	df 92       	push	r13
     542:	ef 92       	push	r14
     544:	ff 92       	push	r15
     546:	0f 93       	push	r16
     548:	1f 93       	push	r17
     54a:	2f 93       	push	r18
     54c:	3f 93       	push	r19
     54e:	4f 93       	push	r20
     550:	5f 93       	push	r21
     552:	6f 93       	push	r22
     554:	7f 93       	push	r23
     556:	8f 93       	push	r24
     558:	9f 93       	push	r25
     55a:	af 93       	push	r26
     55c:	bf 93       	push	r27
     55e:	ef 93       	push	r30
     560:	ff 93       	push	r31
	// Read value of timer
	uint16_t readValue = ICR4;
     562:	60 91 a6 00 	lds	r22, 0x00A6	; 0x8000a6 <__TEXT_REGION_LENGTH__+0x7000a6>
     566:	70 91 a7 00 	lds	r23, 0x00A7	; 0x8000a7 <__TEXT_REGION_LENGTH__+0x7000a7>

	if ( first == true )
     56a:	80 91 0a 02 	lds	r24, 0x020A	; 0x80020a <first>
     56e:	88 23       	and	r24, r24
     570:	b1 f0       	breq	.+44     	; 0x59e <__vector_41+0x6e>
	{
		timeroverflow = 0U;
     572:	10 92 c0 02 	sts	0x02C0, r1	; 0x8002c0 <timeroverflow>
     576:	10 92 c1 02 	sts	0x02C1, r1	; 0x8002c1 <timeroverflow+0x1>
     57a:	10 92 c2 02 	sts	0x02C2, r1	; 0x8002c2 <timeroverflow+0x2>
     57e:	10 92 c3 02 	sts	0x02C3, r1	; 0x8002c3 <timeroverflow+0x3>
		oldValue = readValue;
     582:	cb 01       	movw	r24, r22
     584:	a0 e0       	ldi	r26, 0x00	; 0
     586:	b0 e0       	ldi	r27, 0x00	; 0
     588:	80 93 c4 02 	sts	0x02C4, r24	; 0x8002c4 <oldValue>
     58c:	90 93 c5 02 	sts	0x02C5, r25	; 0x8002c5 <oldValue+0x1>
     590:	a0 93 c6 02 	sts	0x02C6, r26	; 0x8002c6 <oldValue+0x2>
     594:	b0 93 c7 02 	sts	0x02C7, r27	; 0x8002c7 <oldValue+0x3>
		first = false;
     598:	10 92 0a 02 	sts	0x020A, r1	; 0x80020a <first>
		return;
     59c:	7a c0       	rjmp	.+244    	; 0x692 <__vector_41+0x162>
	}
		
	// Disable interrupt and clear pending
	TIMSK4 = 0U;	
     59e:	10 92 72 00 	sts	0x0072, r1	; 0x800072 <__TEXT_REGION_LENGTH__+0x700072>
	TIFR4 = 0U;		
     5a2:	19 ba       	out	0x19, r1	; 25
			
	// Calculate difference
	uint32_t diff = 0U;

	if ( readValue < oldValue )
     5a4:	cb 01       	movw	r24, r22
     5a6:	a0 e0       	ldi	r26, 0x00	; 0
     5a8:	b0 e0       	ldi	r27, 0x00	; 0
     5aa:	00 91 c4 02 	lds	r16, 0x02C4	; 0x8002c4 <oldValue>
     5ae:	10 91 c5 02 	lds	r17, 0x02C5	; 0x8002c5 <oldValue+0x1>
     5b2:	20 91 c6 02 	lds	r18, 0x02C6	; 0x8002c6 <oldValue+0x2>
     5b6:	30 91 c7 02 	lds	r19, 0x02C7	; 0x8002c7 <oldValue+0x3>
     5ba:	80 17       	cp	r24, r16
     5bc:	91 07       	cpc	r25, r17
     5be:	a2 07       	cpc	r26, r18
     5c0:	b3 07       	cpc	r27, r19
     5c2:	80 f5       	brcc	.+96     	; 0x624 <__vector_41+0xf4>
	{
		if ( timeroverflow != 0 )
     5c4:	00 91 c0 02 	lds	r16, 0x02C0	; 0x8002c0 <timeroverflow>
     5c8:	10 91 c1 02 	lds	r17, 0x02C1	; 0x8002c1 <timeroverflow+0x1>
     5cc:	20 91 c2 02 	lds	r18, 0x02C2	; 0x8002c2 <timeroverflow+0x2>
     5d0:	30 91 c3 02 	lds	r19, 0x02C3	; 0x8002c3 <timeroverflow+0x3>
     5d4:	01 2b       	or	r16, r17
     5d6:	02 2b       	or	r16, r18
     5d8:	03 2b       	or	r16, r19
     5da:	a1 f0       	breq	.+40     	; 0x604 <__vector_41+0xd4>
		{
			timeroverflow--;
     5dc:	00 91 c0 02 	lds	r16, 0x02C0	; 0x8002c0 <timeroverflow>
     5e0:	10 91 c1 02 	lds	r17, 0x02C1	; 0x8002c1 <timeroverflow+0x1>
     5e4:	20 91 c2 02 	lds	r18, 0x02C2	; 0x8002c2 <timeroverflow+0x2>
     5e8:	30 91 c3 02 	lds	r19, 0x02C3	; 0x8002c3 <timeroverflow+0x3>
     5ec:	01 50       	subi	r16, 0x01	; 1
     5ee:	11 09       	sbc	r17, r1
     5f0:	21 09       	sbc	r18, r1
     5f2:	31 09       	sbc	r19, r1
     5f4:	00 93 c0 02 	sts	0x02C0, r16	; 0x8002c0 <timeroverflow>
     5f8:	10 93 c1 02 	sts	0x02C1, r17	; 0x8002c1 <timeroverflow+0x1>
     5fc:	20 93 c2 02 	sts	0x02C2, r18	; 0x8002c2 <timeroverflow+0x2>
     600:	30 93 c3 02 	sts	0x02C3, r19	; 0x8002c3 <timeroverflow+0x3>
		}
		diff = ( 0xFFFF - oldValue ) + readValue;
     604:	00 91 c4 02 	lds	r16, 0x02C4	; 0x8002c4 <oldValue>
     608:	10 91 c5 02 	lds	r17, 0x02C5	; 0x8002c5 <oldValue+0x1>
     60c:	20 91 c6 02 	lds	r18, 0x02C6	; 0x8002c6 <oldValue+0x2>
     610:	30 91 c7 02 	lds	r19, 0x02C7	; 0x8002c7 <oldValue+0x3>
     614:	80 1b       	sub	r24, r16
     616:	91 0b       	sbc	r25, r17
     618:	a2 0b       	sbc	r26, r18
     61a:	b3 0b       	sbc	r27, r19
     61c:	01 97       	sbiw	r24, 0x01	; 1
     61e:	af 4f       	sbci	r26, 0xFF	; 255
     620:	bf 4f       	sbci	r27, 0xFF	; 255
     622:	0c c0       	rjmp	.+24     	; 0x63c <__vector_41+0x10c>
	}
	else
	{
		diff = readValue - oldValue;
     624:	00 91 c4 02 	lds	r16, 0x02C4	; 0x8002c4 <oldValue>
     628:	10 91 c5 02 	lds	r17, 0x02C5	; 0x8002c5 <oldValue+0x1>
     62c:	20 91 c6 02 	lds	r18, 0x02C6	; 0x8002c6 <oldValue+0x2>
     630:	30 91 c7 02 	lds	r19, 0x02C7	; 0x8002c7 <oldValue+0x3>
     634:	80 1b       	sub	r24, r16
     636:	91 0b       	sbc	r25, r17
     638:	a2 0b       	sbc	r26, r18
     63a:	b3 0b       	sbc	r27, r19
	}
	
	// Add timeroverflow to total diff
	diff += timeroverflow << 16U;
     63c:	00 91 c0 02 	lds	r16, 0x02C0	; 0x8002c0 <timeroverflow>
     640:	10 91 c1 02 	lds	r17, 0x02C1	; 0x8002c1 <timeroverflow+0x1>
     644:	20 91 c2 02 	lds	r18, 0x02C2	; 0x8002c2 <timeroverflow+0x2>
     648:	30 91 c3 02 	lds	r19, 0x02C3	; 0x8002c3 <timeroverflow+0x3>
     64c:	98 01       	movw	r18, r16
     64e:	11 27       	eor	r17, r17
     650:	00 27       	eor	r16, r16
     652:	bc 01       	movw	r22, r24
     654:	cd 01       	movw	r24, r26
     656:	60 0f       	add	r22, r16
     658:	71 1f       	adc	r23, r17
     65a:	82 1f       	adc	r24, r18
     65c:	93 1f       	adc	r25, r19
	
	// Calculate period
	period = diff * tick * 1000000;
     65e:	c0 90 06 02 	lds	r12, 0x0206	; 0x800206 <tick>
     662:	d0 90 07 02 	lds	r13, 0x0207	; 0x800207 <tick+0x1>
     666:	e0 90 08 02 	lds	r14, 0x0208	; 0x800208 <tick+0x2>
     66a:	f0 90 09 02 	lds	r15, 0x0209	; 0x800209 <tick+0x3>
     66e:	0e 94 b9 10 	call	0x2172	; 0x2172 <__floatunsisf>
     672:	a7 01       	movw	r20, r14
     674:	96 01       	movw	r18, r12
     676:	0e 94 6f 11 	call	0x22de	; 0x22de <__mulsf3>
     67a:	20 e0       	ldi	r18, 0x00	; 0
     67c:	34 e2       	ldi	r19, 0x24	; 36
     67e:	44 e7       	ldi	r20, 0x74	; 116
     680:	59 e4       	ldi	r21, 0x49	; 73
     682:	0e 94 6f 11 	call	0x22de	; 0x22de <__mulsf3>
     686:	0e 94 8d 10 	call	0x211a	; 0x211a <__fixunssfsi>
     68a:	70 93 bf 02 	sts	0x02BF, r23	; 0x8002bf <__data_end+0x1>
     68e:	60 93 be 02 	sts	0x02BE, r22	; 0x8002be <__data_end>
     692:	ff 91       	pop	r31
     694:	ef 91       	pop	r30
     696:	bf 91       	pop	r27
     698:	af 91       	pop	r26
     69a:	9f 91       	pop	r25
     69c:	8f 91       	pop	r24
     69e:	7f 91       	pop	r23
     6a0:	6f 91       	pop	r22
     6a2:	5f 91       	pop	r21
     6a4:	4f 91       	pop	r20
     6a6:	3f 91       	pop	r19
     6a8:	2f 91       	pop	r18
     6aa:	1f 91       	pop	r17
     6ac:	0f 91       	pop	r16
     6ae:	ff 90       	pop	r15
     6b0:	ef 90       	pop	r14
     6b2:	df 90       	pop	r13
     6b4:	cf 90       	pop	r12
     6b6:	0f 90       	pop	r0
     6b8:	0b be       	out	0x3b, r0	; 59
     6ba:	0f 90       	pop	r0
     6bc:	0f be       	out	0x3f, r0	; 63
     6be:	0f 90       	pop	r0
     6c0:	1f 90       	pop	r1
     6c2:	18 95       	reti

000006c4 <_Z9FirstTaskPv>:
void * operator new(size_t size);
void operator delete(void * ptr);

int __cxa_guard_acquire(__guard *g) {return !*(char *)(g);};
void __cxa_guard_release (__guard *g) {*(char *)g = 1;};
void __cxa_guard_abort (__guard *) {};
     6c4:	cf 93       	push	r28
     6c6:	df 93       	push	r29
     6c8:	cd b7       	in	r28, 0x3d	; 61
     6ca:	de b7       	in	r29, 0x3e	; 62
     6cc:	cb 55       	subi	r28, 0x5B	; 91
     6ce:	d1 09       	sbc	r29, r1
     6d0:	0f b6       	in	r0, 0x3f	; 63
     6d2:	f8 94       	cli
     6d4:	de bf       	out	0x3e, r29	; 62
     6d6:	0f be       	out	0x3f, r0	; 63
     6d8:	cd bf       	out	0x3d, r28	; 61
     6da:	8c 01       	movw	r16, r24
     6dc:	2e e4       	ldi	r18, 0x4E	; 78
     6de:	48 e0       	ldi	r20, 0x08	; 8
     6e0:	60 e8       	ldi	r22, 0x80	; 128
     6e2:	75 e2       	ldi	r23, 0x25	; 37
     6e4:	80 e0       	ldi	r24, 0x00	; 0
     6e6:	90 e0       	ldi	r25, 0x00	; 0
     6e8:	0e 94 bd 0f 	call	0x1f7a	; 0x1f7a <_Z8InitUARTmhc>
     6ec:	8d e0       	ldi	r24, 0x0D	; 13
     6ee:	92 e0       	ldi	r25, 0x02	; 2
     6f0:	0e 94 18 10 	call	0x2030	; 0x2030 <_Z10SendStringPc>
     6f4:	62 e0       	ldi	r22, 0x02	; 2
     6f6:	ce 01       	movw	r24, r28
     6f8:	01 96       	adiw	r24, 0x01	; 1
     6fa:	7a de       	rcall	.-780    	; 0x3f0 <_ZN11ColorSensorC1E16FrequencyScaling>
     6fc:	80 e3       	ldi	r24, 0x30	; 48
     6fe:	8f 36       	cpi	r24, 0x6F	; 111
     700:	19 f0       	breq	.+6      	; 0x708 <_Z9FirstTaskPv+0x44>
     702:	0e 94 0a 10 	call	0x2014	; 0x2014 <_Z8ReadCharv>
     706:	fb cf       	rjmp	.-10     	; 0x6fe <_Z9FirstTaskPv+0x3a>
     708:	8b e2       	ldi	r24, 0x2B	; 43
     70a:	92 e0       	ldi	r25, 0x02	; 2
     70c:	0e 94 18 10 	call	0x2030	; 0x2030 <_Z10SendStringPc>
     710:	60 e0       	ldi	r22, 0x00	; 0
     712:	ce 01       	movw	r24, r28
     714:	01 96       	adiw	r24, 0x01	; 1
     716:	ec dd       	rcall	.-1064   	; 0x2f0 <_ZN11ColorSensor17addCalibrateColorEh>
     718:	80 e3       	ldi	r24, 0x30	; 48
     71a:	8f 36       	cpi	r24, 0x6F	; 111
     71c:	19 f0       	breq	.+6      	; 0x724 <_Z9FirstTaskPv+0x60>
     71e:	0e 94 0a 10 	call	0x2014	; 0x2014 <_Z8ReadCharv>
     722:	fb cf       	rjmp	.-10     	; 0x71a <_Z9FirstTaskPv+0x56>
     724:	8a e3       	ldi	r24, 0x3A	; 58
     726:	92 e0       	ldi	r25, 0x02	; 2
     728:	0e 94 18 10 	call	0x2030	; 0x2030 <_Z10SendStringPc>
     72c:	61 e0       	ldi	r22, 0x01	; 1
     72e:	ce 01       	movw	r24, r28
     730:	01 96       	adiw	r24, 0x01	; 1
     732:	de dd       	rcall	.-1092   	; 0x2f0 <_ZN11ColorSensor17addCalibrateColorEh>
     734:	80 e3       	ldi	r24, 0x30	; 48
     736:	8f 36       	cpi	r24, 0x6F	; 111
     738:	19 f0       	breq	.+6      	; 0x740 <_Z9FirstTaskPv+0x7c>
     73a:	0e 94 0a 10 	call	0x2014	; 0x2014 <_Z8ReadCharv>
     73e:	fb cf       	rjmp	.-10     	; 0x736 <_Z9FirstTaskPv+0x72>
     740:	89 e4       	ldi	r24, 0x49	; 73
     742:	92 e0       	ldi	r25, 0x02	; 2
     744:	0e 94 18 10 	call	0x2030	; 0x2030 <_Z10SendStringPc>
     748:	ce 01       	movw	r24, r28
     74a:	01 96       	adiw	r24, 0x01	; 1
     74c:	34 dd       	rcall	.-1432   	; 0x1b6 <_ZN11ColorSensor8getColorEv>
     74e:	88 23       	and	r24, r24
     750:	19 f0       	breq	.+6      	; 0x758 <_Z9FirstTaskPv+0x94>
     752:	81 30       	cpi	r24, 0x01	; 1
     754:	71 f0       	breq	.+28     	; 0x772 <_Z9FirstTaskPv+0xae>
     756:	19 c0       	rjmp	.+50     	; 0x78a <_Z9FirstTaskPv+0xc6>
     758:	c8 01       	movw	r24, r16
     75a:	bb d4       	rcall	.+2422   	; 0x10d2 <_ZN8Robotarm9grabBlockEv>
     75c:	88 e8       	ldi	r24, 0x88	; 136
     75e:	93 e1       	ldi	r25, 0x13	; 19
     760:	0e 94 47 0f 	call	0x1e8e	; 0x1e8e <vTaskDelay>
     764:	c8 01       	movw	r24, r16
     766:	6c d5       	rcall	.+2776   	; 0x1240 <_ZN8Robotarm18moveBlockToZoneOneEv>
     768:	88 e8       	ldi	r24, 0x88	; 136
     76a:	93 e1       	ldi	r25, 0x13	; 19
     76c:	0e 94 47 0f 	call	0x1e8e	; 0x1e8e <vTaskDelay>
     770:	0c c0       	rjmp	.+24     	; 0x78a <_Z9FirstTaskPv+0xc6>
     772:	c8 01       	movw	r24, r16
     774:	ae d4       	rcall	.+2396   	; 0x10d2 <_ZN8Robotarm9grabBlockEv>
     776:	88 e8       	ldi	r24, 0x88	; 136
     778:	93 e1       	ldi	r25, 0x13	; 19
     77a:	0e 94 47 0f 	call	0x1e8e	; 0x1e8e <vTaskDelay>
     77e:	c8 01       	movw	r24, r16
     780:	71 d5       	rcall	.+2786   	; 0x1264 <_ZN8Robotarm18moveBlockToZoneTwoEv>
     782:	88 e8       	ldi	r24, 0x88	; 136
     784:	93 e1       	ldi	r25, 0x13	; 19
     786:	0e 94 47 0f 	call	0x1e8e	; 0x1e8e <vTaskDelay>
     78a:	88 ee       	ldi	r24, 0xE8	; 232
     78c:	93 e0       	ldi	r25, 0x03	; 3
     78e:	0e 94 47 0f 	call	0x1e8e	; 0x1e8e <vTaskDelay>
     792:	da cf       	rjmp	.-76     	; 0x748 <_Z9FirstTaskPv+0x84>

00000794 <__cxa_pure_virtual>:
     794:	ff cf       	rjmp	.-2      	; 0x794 <__cxa_pure_virtual>

00000796 <_Znwj>:

void * operator new(size_t size)
{
	return malloc(size);
     796:	0c 94 03 12 	jmp	0x2406	; 0x2406 <malloc>
}
     79a:	08 95       	ret

0000079c <_ZdlPv>:

void operator delete(void * ptr)
{
	ptr != NULL ? free(ptr) : void(0);
     79c:	00 97       	sbiw	r24, 0x00	; 0
     79e:	11 f0       	breq	.+4      	; 0x7a4 <_ZdlPv+0x8>
     7a0:	0c 94 9b 12 	jmp	0x2536	; 0x2536 <free>
     7a4:	08 95       	ret

000007a6 <main>:
		vTaskDelay(1000/portTICK_RATE_MS);
	}
}

int main(void)
{
     7a6:	cf 93       	push	r28
     7a8:	df 93       	push	r29
     7aa:	cd b7       	in	r28, 0x3d	; 61
     7ac:	de b7       	in	r29, 0x3e	; 62
     7ae:	2e 97       	sbiw	r28, 0x0e	; 14
     7b0:	0f b6       	in	r0, 0x3f	; 63
     7b2:	f8 94       	cli
     7b4:	de bf       	out	0x3e, r29	; 62
     7b6:	0f be       	out	0x3f, r0	; 63
     7b8:	cd bf       	out	0x3d, r28	; 61
	Robotarm arm = Robotarm();
     7ba:	ce 01       	movw	r24, r28
     7bc:	01 96       	adiw	r24, 0x01	; 1
     7be:	2e d4       	rcall	.+2140   	; 0x101c <_ZN8RobotarmC1Ev>
	xTaskCreate(FirstTask,  ( signed char * ) "Task", configMAIN_STACK_SIZE, &arm, tskIDLE_PRIORITY, NULL);
     7c0:	a1 2c       	mov	r10, r1
     7c2:	b1 2c       	mov	r11, r1
     7c4:	c1 2c       	mov	r12, r1
     7c6:	d1 2c       	mov	r13, r1
     7c8:	e1 2c       	mov	r14, r1
     7ca:	f1 2c       	mov	r15, r1
     7cc:	00 e0       	ldi	r16, 0x00	; 0
     7ce:	9e 01       	movw	r18, r28
     7d0:	2f 5f       	subi	r18, 0xFF	; 255
     7d2:	3f 4f       	sbci	r19, 0xFF	; 255
     7d4:	48 ec       	ldi	r20, 0xC8	; 200
     7d6:	50 e0       	ldi	r21, 0x00	; 0
     7d8:	68 e5       	ldi	r22, 0x58	; 88
     7da:	72 e0       	ldi	r23, 0x02	; 2
     7dc:	82 e6       	ldi	r24, 0x62	; 98
     7de:	93 e0       	ldi	r25, 0x03	; 3
     7e0:	0e 94 48 0d 	call	0x1a90	; 0x1a90 <xTaskGenericCreate>
	vTaskStartScheduler();
     7e4:	0e 94 00 0e 	call	0x1c00	; 0x1c00 <vTaskStartScheduler>
     7e8:	ff cf       	rjmp	.-2      	; 0x7e8 <main+0x42>

000007ea <_ZN5Motor10SetDegreesEh>:
	*	 can be used to turn motor at a specific speed set by \ref delay. C
	*	 Note that this function needs to run multiple times to work as intended.
	*    @param uint8_t		sdegrees to turn
	*    @return void
	*/
	virtual void SetDegrees( uint8_t degrees )
     7ea:	cf 92       	push	r12
     7ec:	df 92       	push	r13
     7ee:	ef 92       	push	r14
     7f0:	ff 92       	push	r15
     7f2:	cf 93       	push	r28
     7f4:	df 93       	push	r29
	{
		if ( maxDegrees_ >= degrees )
     7f6:	fc 01       	movw	r30, r24
     7f8:	26 89       	ldd	r18, Z+22	; 0x16
     7fa:	26 17       	cp	r18, r22
     7fc:	c0 f0       	brcs	.+48     	; 0x82e <_ZN5Motor10SetDegreesEh+0x44>
     7fe:	ec 01       	movw	r28, r24
		{
			percent_ = percentPrDeg * degrees + startpercent_;
     800:	c6 80       	ldd	r12, Z+6	; 0x06
     802:	d7 80       	ldd	r13, Z+7	; 0x07
     804:	e0 84       	ldd	r14, Z+8	; 0x08
     806:	f1 84       	ldd	r15, Z+9	; 0x09
     808:	70 e0       	ldi	r23, 0x00	; 0
     80a:	80 e0       	ldi	r24, 0x00	; 0
     80c:	90 e0       	ldi	r25, 0x00	; 0
     80e:	0e 94 bb 10 	call	0x2176	; 0x2176 <__floatsisf>
     812:	a7 01       	movw	r20, r14
     814:	96 01       	movw	r18, r12
     816:	0e 94 6f 11 	call	0x22de	; 0x22de <__mulsf3>
     81a:	2a 89       	ldd	r18, Y+18	; 0x12
     81c:	3b 89       	ldd	r19, Y+19	; 0x13
     81e:	4c 89       	ldd	r20, Y+20	; 0x14
     820:	5d 89       	ldd	r21, Y+21	; 0x15
     822:	0e 94 25 10 	call	0x204a	; 0x204a <__addsf3>
     826:	6a 87       	std	Y+10, r22	; 0x0a
     828:	7b 87       	std	Y+11, r23	; 0x0b
     82a:	8c 87       	std	Y+12, r24	; 0x0c
     82c:	9d 87       	std	Y+13, r25	; 0x0d
		}
	}
     82e:	df 91       	pop	r29
     830:	cf 91       	pop	r28
     832:	ff 90       	pop	r15
     834:	ef 90       	pop	r14
     836:	df 90       	pop	r13
     838:	cf 90       	pop	r12
     83a:	08 95       	ret

0000083c <_ZN2M1D1Ev>:

class Motor
{
//functions
public:
	virtual ~Motor() {};
     83c:	21 e6       	ldi	r18, 0x61	; 97
     83e:	32 e0       	ldi	r19, 0x02	; 2
     840:	fc 01       	movw	r30, r24
     842:	31 83       	std	Z+1, r19	; 0x01
     844:	20 83       	st	Z, r18
     846:	08 95       	ret

00000848 <_ZN2M1D0Ev>:
	SetDegrees( 90 );
	tmr1Ptr_->setDutyCycleComA( percent_ );
	oldPercent_ = percent_;
} 

M1::~M1()
     848:	cf 93       	push	r28
     84a:	df 93       	push	r29
     84c:	ec 01       	movw	r28, r24
{
}
     84e:	f6 df       	rcall	.-20     	; 0x83c <_ZN2M1D1Ev>
     850:	ce 01       	movw	r24, r28
     852:	a4 df       	rcall	.-184    	; 0x79c <_ZdlPv>
     854:	df 91       	pop	r29
     856:	cf 91       	pop	r28
     858:	08 95       	ret

0000085a <_ZN2M19TurnMotorEv>:

void M1::TurnMotor()
{
     85a:	4f 92       	push	r4
     85c:	5f 92       	push	r5
     85e:	6f 92       	push	r6
     860:	7f 92       	push	r7
     862:	8f 92       	push	r8
     864:	9f 92       	push	r9
     866:	af 92       	push	r10
     868:	bf 92       	push	r11
     86a:	cf 92       	push	r12
     86c:	df 92       	push	r13
     86e:	ef 92       	push	r14
     870:	ff 92       	push	r15
     872:	cf 93       	push	r28
     874:	df 93       	push	r29
     876:	ec 01       	movw	r28, r24
	if ( percent_ > oldPercent_ + PERCENT_PR_TICK )
     878:	8a 84       	ldd	r8, Y+10	; 0x0a
     87a:	9b 84       	ldd	r9, Y+11	; 0x0b
     87c:	ac 84       	ldd	r10, Y+12	; 0x0c
     87e:	bd 84       	ldd	r11, Y+13	; 0x0d
     880:	ce 84       	ldd	r12, Y+14	; 0x0e
     882:	df 84       	ldd	r13, Y+15	; 0x0f
     884:	e8 88       	ldd	r14, Y+16	; 0x10
     886:	f9 88       	ldd	r15, Y+17	; 0x11
     888:	20 e0       	ldi	r18, 0x00	; 0
     88a:	30 e0       	ldi	r19, 0x00	; 0
     88c:	40 e8       	ldi	r20, 0x80	; 128
     88e:	5d e3       	ldi	r21, 0x3D	; 61
     890:	c7 01       	movw	r24, r14
     892:	b6 01       	movw	r22, r12
     894:	0e 94 25 10 	call	0x204a	; 0x204a <__addsf3>
     898:	2b 01       	movw	r4, r22
     89a:	3c 01       	movw	r6, r24
     89c:	9b 01       	movw	r18, r22
     89e:	ac 01       	movw	r20, r24
     8a0:	c5 01       	movw	r24, r10
     8a2:	b4 01       	movw	r22, r8
     8a4:	0e 94 6b 11 	call	0x22d6	; 0x22d6 <__gesf2>
     8a8:	18 16       	cp	r1, r24
     8aa:	74 f4       	brge	.+28     	; 0x8c8 <_ZN2M19TurnMotorEv+0x6e>
	{
		oldPercent_ += PERCENT_PR_TICK;
     8ac:	4e 86       	std	Y+14, r4	; 0x0e
     8ae:	5f 86       	std	Y+15, r5	; 0x0f
     8b0:	68 8a       	std	Y+16, r6	; 0x10
     8b2:	79 8a       	std	Y+17, r7	; 0x11
		tmr1Ptr_->setDutyCycleComA( oldPercent_ );
     8b4:	b3 01       	movw	r22, r6
     8b6:	a2 01       	movw	r20, r4
     8b8:	8a 81       	ldd	r24, Y+2	; 0x02
     8ba:	9b 81       	ldd	r25, Y+3	; 0x03
     8bc:	03 d5       	rcall	.+2566   	; 0x12c4 <_ZN6Timer116setDutyCycleComAEf>
		vTaskDelay( delay_ / portTICK_RATE_MS );
     8be:	8f 89       	ldd	r24, Y+23	; 0x17
     8c0:	98 8d       	ldd	r25, Y+24	; 0x18
     8c2:	0e 94 47 0f 	call	0x1e8e	; 0x1e8e <vTaskDelay>
     8c6:	1d c0       	rjmp	.+58     	; 0x902 <_ZN2M19TurnMotorEv+0xa8>
	}
	else if ( percent_ < oldPercent_ )
     8c8:	a7 01       	movw	r20, r14
     8ca:	96 01       	movw	r18, r12
     8cc:	c5 01       	movw	r24, r10
     8ce:	b4 01       	movw	r22, r8
     8d0:	0e 94 89 10 	call	0x2112	; 0x2112 <__cmpsf2>
     8d4:	88 23       	and	r24, r24
     8d6:	ac f4       	brge	.+42     	; 0x902 <_ZN2M19TurnMotorEv+0xa8>
	{
		oldPercent_ -= PERCENT_PR_TICK;
     8d8:	20 e0       	ldi	r18, 0x00	; 0
     8da:	30 e0       	ldi	r19, 0x00	; 0
     8dc:	40 e8       	ldi	r20, 0x80	; 128
     8de:	5d e3       	ldi	r21, 0x3D	; 61
     8e0:	c7 01       	movw	r24, r14
     8e2:	b6 01       	movw	r22, r12
     8e4:	0e 94 24 10 	call	0x2048	; 0x2048 <__subsf3>
     8e8:	ab 01       	movw	r20, r22
     8ea:	bc 01       	movw	r22, r24
     8ec:	4e 87       	std	Y+14, r20	; 0x0e
     8ee:	5f 87       	std	Y+15, r21	; 0x0f
     8f0:	68 8b       	std	Y+16, r22	; 0x10
     8f2:	79 8b       	std	Y+17, r23	; 0x11
		tmr1Ptr_->setDutyCycleComA( oldPercent_ );
     8f4:	8a 81       	ldd	r24, Y+2	; 0x02
     8f6:	9b 81       	ldd	r25, Y+3	; 0x03
     8f8:	e5 d4       	rcall	.+2506   	; 0x12c4 <_ZN6Timer116setDutyCycleComAEf>
		vTaskDelay( delay_ / portTICK_RATE_MS );
     8fa:	8f 89       	ldd	r24, Y+23	; 0x17
     8fc:	98 8d       	ldd	r25, Y+24	; 0x18
     8fe:	0e 94 47 0f 	call	0x1e8e	; 0x1e8e <vTaskDelay>
	}
}
     902:	df 91       	pop	r29
     904:	cf 91       	pop	r28
     906:	ff 90       	pop	r15
     908:	ef 90       	pop	r14
     90a:	df 90       	pop	r13
     90c:	cf 90       	pop	r12
     90e:	bf 90       	pop	r11
     910:	af 90       	pop	r10
     912:	9f 90       	pop	r9
     914:	8f 90       	pop	r8
     916:	7f 90       	pop	r7
     918:	6f 90       	pop	r6
     91a:	5f 90       	pop	r5
     91c:	4f 90       	pop	r4
     91e:	08 95       	ret

00000920 <_ZN2M1C1EP6Timer1>:
* Author: jespe
*/

#include "M1.h"

M1::M1( Timer1* tmr )
     920:	cf 93       	push	r28
     922:	df 93       	push	r29
     924:	ec 01       	movw	r28, r24
     926:	cb 01       	movw	r24, r22
     928:	2d e6       	ldi	r18, 0x6D	; 109
     92a:	32 e0       	ldi	r19, 0x02	; 2
     92c:	39 83       	std	Y+1, r19	; 0x01
     92e:	28 83       	st	Y, r18
{
	/* Store timer pointer */
	tmr1Ptr_ = tmr;
     930:	7b 83       	std	Y+3, r23	; 0x03
     932:	6a 83       	std	Y+2, r22	; 0x02
	
	/* This value is number of percent to add or subtract pr degree. */
	percentPrDeg = 0.0555555555555556;
     934:	49 e3       	ldi	r20, 0x39	; 57
     936:	5e e8       	ldi	r21, 0x8E	; 142
     938:	63 e6       	ldi	r22, 0x63	; 99
     93a:	7d e3       	ldi	r23, 0x3D	; 61
     93c:	4e 83       	std	Y+6, r20	; 0x06
     93e:	5f 83       	std	Y+7, r21	; 0x07
     940:	68 87       	std	Y+8, r22	; 0x08
     942:	79 87       	std	Y+9, r23	; 0x09
	
	/* This value is the lowest duty cycle percentage needed to make motor turn. */
	startpercent_ = 2.5;
     944:	40 e0       	ldi	r20, 0x00	; 0
     946:	50 e0       	ldi	r21, 0x00	; 0
     948:	60 e2       	ldi	r22, 0x20	; 32
     94a:	70 e4       	ldi	r23, 0x40	; 64
     94c:	4a 8b       	std	Y+18, r20	; 0x12
     94e:	5b 8b       	std	Y+19, r21	; 0x13
     950:	6c 8b       	std	Y+20, r22	; 0x14
     952:	7d 8b       	std	Y+21, r23	; 0x15
	
	/* This value is the delay on motor. A lower value makes motors go faster and higher value makes motors go slower. */
	delay_ = 10;
     954:	2a e0       	ldi	r18, 0x0A	; 10
     956:	30 e0       	ldi	r19, 0x00	; 0
     958:	38 8f       	std	Y+24, r19	; 0x18
     95a:	2f 8b       	std	Y+23, r18	; 0x17
	
	/* This value is the maximum number of degrees the motor can turn */
	maxDegrees_ = 180;
     95c:	24 eb       	ldi	r18, 0xB4	; 180
     95e:	2e 8b       	std	Y+22, r18	; 0x16
	*/
	virtual void SetDegrees( uint8_t degrees )
	{
		if ( maxDegrees_ >= degrees )
		{
			percent_ = percentPrDeg * degrees + startpercent_;
     960:	40 e0       	ldi	r20, 0x00	; 0
     962:	50 e0       	ldi	r21, 0x00	; 0
     964:	60 ef       	ldi	r22, 0xF0	; 240
     966:	70 e4       	ldi	r23, 0x40	; 64
     968:	4a 87       	std	Y+10, r20	; 0x0a
     96a:	5b 87       	std	Y+11, r21	; 0x0b
     96c:	6c 87       	std	Y+12, r22	; 0x0c
     96e:	7d 87       	std	Y+13, r23	; 0x0d
	
	/* Set motor to default startup value */
	SetDegrees( 90 );
	tmr1Ptr_->setDutyCycleComA( percent_ );
     970:	a9 d4       	rcall	.+2386   	; 0x12c4 <_ZN6Timer116setDutyCycleComAEf>
	oldPercent_ = percent_;
     972:	8a 85       	ldd	r24, Y+10	; 0x0a
     974:	9b 85       	ldd	r25, Y+11	; 0x0b
     976:	ac 85       	ldd	r26, Y+12	; 0x0c
     978:	bd 85       	ldd	r27, Y+13	; 0x0d
     97a:	8e 87       	std	Y+14, r24	; 0x0e
     97c:	9f 87       	std	Y+15, r25	; 0x0f
     97e:	a8 8b       	std	Y+16, r26	; 0x10
     980:	b9 8b       	std	Y+17, r27	; 0x11
} 
     982:	df 91       	pop	r29
     984:	cf 91       	pop	r28
     986:	08 95       	ret

00000988 <_ZN2M2D1Ev>:

class Motor
{
//functions
public:
	virtual ~Motor() {};
     988:	21 e6       	ldi	r18, 0x61	; 97
     98a:	32 e0       	ldi	r19, 0x02	; 2
     98c:	fc 01       	movw	r30, r24
     98e:	31 83       	std	Z+1, r19	; 0x01
     990:	20 83       	st	Z, r18
     992:	08 95       	ret

00000994 <_ZN2M2D0Ev>:
	SetDegrees( 90 );
	tmr1Ptr_->setDutyCycleComB( percent_ );
	oldPercent_ = percent_;
}

M2::~M2()
     994:	cf 93       	push	r28
     996:	df 93       	push	r29
     998:	ec 01       	movw	r28, r24
{
}
     99a:	f6 df       	rcall	.-20     	; 0x988 <_ZN2M2D1Ev>
     99c:	ce 01       	movw	r24, r28
     99e:	fe de       	rcall	.-516    	; 0x79c <_ZdlPv>
     9a0:	df 91       	pop	r29
     9a2:	cf 91       	pop	r28
     9a4:	08 95       	ret

000009a6 <_ZN2M29TurnMotorEv>:

void M2::TurnMotor()
{
     9a6:	4f 92       	push	r4
     9a8:	5f 92       	push	r5
     9aa:	6f 92       	push	r6
     9ac:	7f 92       	push	r7
     9ae:	8f 92       	push	r8
     9b0:	9f 92       	push	r9
     9b2:	af 92       	push	r10
     9b4:	bf 92       	push	r11
     9b6:	cf 92       	push	r12
     9b8:	df 92       	push	r13
     9ba:	ef 92       	push	r14
     9bc:	ff 92       	push	r15
     9be:	cf 93       	push	r28
     9c0:	df 93       	push	r29
     9c2:	ec 01       	movw	r28, r24
	if ( percent_ > oldPercent_ + PERCENT_PR_TICK )
     9c4:	8a 84       	ldd	r8, Y+10	; 0x0a
     9c6:	9b 84       	ldd	r9, Y+11	; 0x0b
     9c8:	ac 84       	ldd	r10, Y+12	; 0x0c
     9ca:	bd 84       	ldd	r11, Y+13	; 0x0d
     9cc:	ce 84       	ldd	r12, Y+14	; 0x0e
     9ce:	df 84       	ldd	r13, Y+15	; 0x0f
     9d0:	e8 88       	ldd	r14, Y+16	; 0x10
     9d2:	f9 88       	ldd	r15, Y+17	; 0x11
     9d4:	20 e0       	ldi	r18, 0x00	; 0
     9d6:	30 e0       	ldi	r19, 0x00	; 0
     9d8:	40 e8       	ldi	r20, 0x80	; 128
     9da:	5d e3       	ldi	r21, 0x3D	; 61
     9dc:	c7 01       	movw	r24, r14
     9de:	b6 01       	movw	r22, r12
     9e0:	0e 94 25 10 	call	0x204a	; 0x204a <__addsf3>
     9e4:	2b 01       	movw	r4, r22
     9e6:	3c 01       	movw	r6, r24
     9e8:	9b 01       	movw	r18, r22
     9ea:	ac 01       	movw	r20, r24
     9ec:	c5 01       	movw	r24, r10
     9ee:	b4 01       	movw	r22, r8
     9f0:	0e 94 6b 11 	call	0x22d6	; 0x22d6 <__gesf2>
     9f4:	18 16       	cp	r1, r24
     9f6:	74 f4       	brge	.+28     	; 0xa14 <_ZN2M29TurnMotorEv+0x6e>
	{
		oldPercent_ += PERCENT_PR_TICK;
     9f8:	4e 86       	std	Y+14, r4	; 0x0e
     9fa:	5f 86       	std	Y+15, r5	; 0x0f
     9fc:	68 8a       	std	Y+16, r6	; 0x10
     9fe:	79 8a       	std	Y+17, r7	; 0x11
		tmr1Ptr_->setDutyCycleComB( oldPercent_ );
     a00:	b3 01       	movw	r22, r6
     a02:	a2 01       	movw	r20, r4
     a04:	8a 81       	ldd	r24, Y+2	; 0x02
     a06:	9b 81       	ldd	r25, Y+3	; 0x03
     a08:	85 d4       	rcall	.+2314   	; 0x1314 <_ZN6Timer116setDutyCycleComBEf>
		vTaskDelay( delay_ / portTICK_RATE_MS );
     a0a:	8f 89       	ldd	r24, Y+23	; 0x17
     a0c:	98 8d       	ldd	r25, Y+24	; 0x18
     a0e:	0e 94 47 0f 	call	0x1e8e	; 0x1e8e <vTaskDelay>
     a12:	1d c0       	rjmp	.+58     	; 0xa4e <_ZN2M29TurnMotorEv+0xa8>
	}
	else if ( percent_ < oldPercent_ )
     a14:	a7 01       	movw	r20, r14
     a16:	96 01       	movw	r18, r12
     a18:	c5 01       	movw	r24, r10
     a1a:	b4 01       	movw	r22, r8
     a1c:	0e 94 89 10 	call	0x2112	; 0x2112 <__cmpsf2>
     a20:	88 23       	and	r24, r24
     a22:	ac f4       	brge	.+42     	; 0xa4e <_ZN2M29TurnMotorEv+0xa8>
	{
		oldPercent_ -= PERCENT_PR_TICK;
     a24:	20 e0       	ldi	r18, 0x00	; 0
     a26:	30 e0       	ldi	r19, 0x00	; 0
     a28:	40 e8       	ldi	r20, 0x80	; 128
     a2a:	5d e3       	ldi	r21, 0x3D	; 61
     a2c:	c7 01       	movw	r24, r14
     a2e:	b6 01       	movw	r22, r12
     a30:	0e 94 24 10 	call	0x2048	; 0x2048 <__subsf3>
     a34:	ab 01       	movw	r20, r22
     a36:	bc 01       	movw	r22, r24
     a38:	4e 87       	std	Y+14, r20	; 0x0e
     a3a:	5f 87       	std	Y+15, r21	; 0x0f
     a3c:	68 8b       	std	Y+16, r22	; 0x10
     a3e:	79 8b       	std	Y+17, r23	; 0x11
		tmr1Ptr_->setDutyCycleComB( oldPercent_ );
     a40:	8a 81       	ldd	r24, Y+2	; 0x02
     a42:	9b 81       	ldd	r25, Y+3	; 0x03
     a44:	67 d4       	rcall	.+2254   	; 0x1314 <_ZN6Timer116setDutyCycleComBEf>
		vTaskDelay( delay_ / portTICK_RATE_MS );
     a46:	8f 89       	ldd	r24, Y+23	; 0x17
     a48:	98 8d       	ldd	r25, Y+24	; 0x18
     a4a:	0e 94 47 0f 	call	0x1e8e	; 0x1e8e <vTaskDelay>
	}
}
     a4e:	df 91       	pop	r29
     a50:	cf 91       	pop	r28
     a52:	ff 90       	pop	r15
     a54:	ef 90       	pop	r14
     a56:	df 90       	pop	r13
     a58:	cf 90       	pop	r12
     a5a:	bf 90       	pop	r11
     a5c:	af 90       	pop	r10
     a5e:	9f 90       	pop	r9
     a60:	8f 90       	pop	r8
     a62:	7f 90       	pop	r7
     a64:	6f 90       	pop	r6
     a66:	5f 90       	pop	r5
     a68:	4f 90       	pop	r4
     a6a:	08 95       	ret

00000a6c <_ZN2M2C1EP6Timer1>:
* Author: jespe
*/

#include "M2.h"

M2::M2( Timer1* tmr )
     a6c:	cf 93       	push	r28
     a6e:	df 93       	push	r29
     a70:	ec 01       	movw	r28, r24
     a72:	cb 01       	movw	r24, r22
     a74:	29 e7       	ldi	r18, 0x79	; 121
     a76:	32 e0       	ldi	r19, 0x02	; 2
     a78:	39 83       	std	Y+1, r19	; 0x01
     a7a:	28 83       	st	Y, r18
{
	/* Store timer pointer */
	tmr1Ptr_ = tmr;
     a7c:	7b 83       	std	Y+3, r23	; 0x03
     a7e:	6a 83       	std	Y+2, r22	; 0x02
	
	/* This value is number of percent to add or subtract pr degree. */
	percentPrDeg = 0.06;
     a80:	4f e8       	ldi	r20, 0x8F	; 143
     a82:	52 ec       	ldi	r21, 0xC2	; 194
     a84:	65 e7       	ldi	r22, 0x75	; 117
     a86:	7d e3       	ldi	r23, 0x3D	; 61
     a88:	4e 83       	std	Y+6, r20	; 0x06
     a8a:	5f 83       	std	Y+7, r21	; 0x07
     a8c:	68 87       	std	Y+8, r22	; 0x08
     a8e:	79 87       	std	Y+9, r23	; 0x09

	/* This value is the lowest duty cycle percentage needed to make motor turn. */
	startpercent_ = 3;
     a90:	40 e0       	ldi	r20, 0x00	; 0
     a92:	50 e0       	ldi	r21, 0x00	; 0
     a94:	60 e4       	ldi	r22, 0x40	; 64
     a96:	70 e4       	ldi	r23, 0x40	; 64
     a98:	4a 8b       	std	Y+18, r20	; 0x12
     a9a:	5b 8b       	std	Y+19, r21	; 0x13
     a9c:	6c 8b       	std	Y+20, r22	; 0x14
     a9e:	7d 8b       	std	Y+21, r23	; 0x15

	/* This value is the delay on motor. A lower value makes motors go faster and higher value makes motors go slower. Value is in MS */
	delay_ = 10;
     aa0:	2a e0       	ldi	r18, 0x0A	; 10
     aa2:	30 e0       	ldi	r19, 0x00	; 0
     aa4:	38 8f       	std	Y+24, r19	; 0x18
     aa6:	2f 8b       	std	Y+23, r18	; 0x17

	/* This value is the maximum number of degrees the motor can turn */
	maxDegrees_ = 150;
     aa8:	26 e9       	ldi	r18, 0x96	; 150
     aaa:	2e 8b       	std	Y+22, r18	; 0x16
	*/
	virtual void SetDegrees( uint8_t degrees )
	{
		if ( maxDegrees_ >= degrees )
		{
			percent_ = percentPrDeg * degrees + startpercent_;
     aac:	46 e6       	ldi	r20, 0x66	; 102
     aae:	56 e6       	ldi	r21, 0x66	; 102
     ab0:	66 e0       	ldi	r22, 0x06	; 6
     ab2:	71 e4       	ldi	r23, 0x41	; 65
     ab4:	4a 87       	std	Y+10, r20	; 0x0a
     ab6:	5b 87       	std	Y+11, r21	; 0x0b
     ab8:	6c 87       	std	Y+12, r22	; 0x0c
     aba:	7d 87       	std	Y+13, r23	; 0x0d

	/* Set motor to default startup value */
	SetDegrees( 90 );
	tmr1Ptr_->setDutyCycleComB( percent_ );
     abc:	2b d4       	rcall	.+2134   	; 0x1314 <_ZN6Timer116setDutyCycleComBEf>
	oldPercent_ = percent_;
     abe:	8a 85       	ldd	r24, Y+10	; 0x0a
     ac0:	9b 85       	ldd	r25, Y+11	; 0x0b
     ac2:	ac 85       	ldd	r26, Y+12	; 0x0c
     ac4:	bd 85       	ldd	r27, Y+13	; 0x0d
     ac6:	8e 87       	std	Y+14, r24	; 0x0e
     ac8:	9f 87       	std	Y+15, r25	; 0x0f
     aca:	a8 8b       	std	Y+16, r26	; 0x10
     acc:	b9 8b       	std	Y+17, r27	; 0x11
}
     ace:	df 91       	pop	r29
     ad0:	cf 91       	pop	r28
     ad2:	08 95       	ret

00000ad4 <_ZN2M3D1Ev>:

class Motor
{
//functions
public:
	virtual ~Motor() {};
     ad4:	21 e6       	ldi	r18, 0x61	; 97
     ad6:	32 e0       	ldi	r19, 0x02	; 2
     ad8:	fc 01       	movw	r30, r24
     ada:	31 83       	std	Z+1, r19	; 0x01
     adc:	20 83       	st	Z, r18
     ade:	08 95       	ret

00000ae0 <_ZN2M3D0Ev>:
	SetDegrees( 90 );
	tmr1Ptr_->setDutyCycleComC( percent_ );
	oldPercent_ = percent_;	
}

M3::~M3()
     ae0:	cf 93       	push	r28
     ae2:	df 93       	push	r29
     ae4:	ec 01       	movw	r28, r24
{
}
     ae6:	f6 df       	rcall	.-20     	; 0xad4 <_ZN2M3D1Ev>
     ae8:	ce 01       	movw	r24, r28
     aea:	58 de       	rcall	.-848    	; 0x79c <_ZdlPv>
     aec:	df 91       	pop	r29
     aee:	cf 91       	pop	r28
     af0:	08 95       	ret

00000af2 <_ZN2M39TurnMotorEv>:

void M3::TurnMotor()
{
     af2:	4f 92       	push	r4
     af4:	5f 92       	push	r5
     af6:	6f 92       	push	r6
     af8:	7f 92       	push	r7
     afa:	8f 92       	push	r8
     afc:	9f 92       	push	r9
     afe:	af 92       	push	r10
     b00:	bf 92       	push	r11
     b02:	cf 92       	push	r12
     b04:	df 92       	push	r13
     b06:	ef 92       	push	r14
     b08:	ff 92       	push	r15
     b0a:	cf 93       	push	r28
     b0c:	df 93       	push	r29
     b0e:	ec 01       	movw	r28, r24
	if ( percent_ > oldPercent_ + PERCENT_PR_TICK )
     b10:	8a 84       	ldd	r8, Y+10	; 0x0a
     b12:	9b 84       	ldd	r9, Y+11	; 0x0b
     b14:	ac 84       	ldd	r10, Y+12	; 0x0c
     b16:	bd 84       	ldd	r11, Y+13	; 0x0d
     b18:	ce 84       	ldd	r12, Y+14	; 0x0e
     b1a:	df 84       	ldd	r13, Y+15	; 0x0f
     b1c:	e8 88       	ldd	r14, Y+16	; 0x10
     b1e:	f9 88       	ldd	r15, Y+17	; 0x11
     b20:	20 e0       	ldi	r18, 0x00	; 0
     b22:	30 e0       	ldi	r19, 0x00	; 0
     b24:	40 e8       	ldi	r20, 0x80	; 128
     b26:	5d e3       	ldi	r21, 0x3D	; 61
     b28:	c7 01       	movw	r24, r14
     b2a:	b6 01       	movw	r22, r12
     b2c:	0e 94 25 10 	call	0x204a	; 0x204a <__addsf3>
     b30:	2b 01       	movw	r4, r22
     b32:	3c 01       	movw	r6, r24
     b34:	9b 01       	movw	r18, r22
     b36:	ac 01       	movw	r20, r24
     b38:	c5 01       	movw	r24, r10
     b3a:	b4 01       	movw	r22, r8
     b3c:	0e 94 6b 11 	call	0x22d6	; 0x22d6 <__gesf2>
     b40:	18 16       	cp	r1, r24
     b42:	74 f4       	brge	.+28     	; 0xb60 <_ZN2M39TurnMotorEv+0x6e>
	{
		oldPercent_ += PERCENT_PR_TICK;
     b44:	4e 86       	std	Y+14, r4	; 0x0e
     b46:	5f 86       	std	Y+15, r5	; 0x0f
     b48:	68 8a       	std	Y+16, r6	; 0x10
     b4a:	79 8a       	std	Y+17, r7	; 0x11
		tmr1Ptr_->setDutyCycleComC( oldPercent_ );
     b4c:	b3 01       	movw	r22, r6
     b4e:	a2 01       	movw	r20, r4
     b50:	8a 81       	ldd	r24, Y+2	; 0x02
     b52:	9b 81       	ldd	r25, Y+3	; 0x03
     b54:	07 d4       	rcall	.+2062   	; 0x1364 <_ZN6Timer116setDutyCycleComCEf>
		vTaskDelay( delay_ / portTICK_RATE_MS );
     b56:	8f 89       	ldd	r24, Y+23	; 0x17
     b58:	98 8d       	ldd	r25, Y+24	; 0x18
     b5a:	0e 94 47 0f 	call	0x1e8e	; 0x1e8e <vTaskDelay>
     b5e:	1d c0       	rjmp	.+58     	; 0xb9a <_ZN2M39TurnMotorEv+0xa8>
	}
	else if ( percent_ < oldPercent_ )
     b60:	a7 01       	movw	r20, r14
     b62:	96 01       	movw	r18, r12
     b64:	c5 01       	movw	r24, r10
     b66:	b4 01       	movw	r22, r8
     b68:	0e 94 89 10 	call	0x2112	; 0x2112 <__cmpsf2>
     b6c:	88 23       	and	r24, r24
     b6e:	ac f4       	brge	.+42     	; 0xb9a <_ZN2M39TurnMotorEv+0xa8>
	{
		oldPercent_ -= PERCENT_PR_TICK;
     b70:	20 e0       	ldi	r18, 0x00	; 0
     b72:	30 e0       	ldi	r19, 0x00	; 0
     b74:	40 e8       	ldi	r20, 0x80	; 128
     b76:	5d e3       	ldi	r21, 0x3D	; 61
     b78:	c7 01       	movw	r24, r14
     b7a:	b6 01       	movw	r22, r12
     b7c:	0e 94 24 10 	call	0x2048	; 0x2048 <__subsf3>
     b80:	ab 01       	movw	r20, r22
     b82:	bc 01       	movw	r22, r24
     b84:	4e 87       	std	Y+14, r20	; 0x0e
     b86:	5f 87       	std	Y+15, r21	; 0x0f
     b88:	68 8b       	std	Y+16, r22	; 0x10
     b8a:	79 8b       	std	Y+17, r23	; 0x11
		tmr1Ptr_->setDutyCycleComC( oldPercent_ );
     b8c:	8a 81       	ldd	r24, Y+2	; 0x02
     b8e:	9b 81       	ldd	r25, Y+3	; 0x03
     b90:	e9 d3       	rcall	.+2002   	; 0x1364 <_ZN6Timer116setDutyCycleComCEf>
		vTaskDelay( delay_ / portTICK_RATE_MS );
     b92:	8f 89       	ldd	r24, Y+23	; 0x17
     b94:	98 8d       	ldd	r25, Y+24	; 0x18
     b96:	0e 94 47 0f 	call	0x1e8e	; 0x1e8e <vTaskDelay>
	}
}
     b9a:	df 91       	pop	r29
     b9c:	cf 91       	pop	r28
     b9e:	ff 90       	pop	r15
     ba0:	ef 90       	pop	r14
     ba2:	df 90       	pop	r13
     ba4:	cf 90       	pop	r12
     ba6:	bf 90       	pop	r11
     ba8:	af 90       	pop	r10
     baa:	9f 90       	pop	r9
     bac:	8f 90       	pop	r8
     bae:	7f 90       	pop	r7
     bb0:	6f 90       	pop	r6
     bb2:	5f 90       	pop	r5
     bb4:	4f 90       	pop	r4
     bb6:	08 95       	ret

00000bb8 <_ZN2M3C1EP6Timer1>:
*/

#include "M3.h"


M3::M3( Timer1* tmr )
     bb8:	cf 93       	push	r28
     bba:	df 93       	push	r29
     bbc:	ec 01       	movw	r28, r24
     bbe:	cb 01       	movw	r24, r22
     bc0:	25 e8       	ldi	r18, 0x85	; 133
     bc2:	32 e0       	ldi	r19, 0x02	; 2
     bc4:	39 83       	std	Y+1, r19	; 0x01
     bc6:	28 83       	st	Y, r18
{
	/* Store timer pointer */
	tmr1Ptr_ = tmr;
     bc8:	7b 83       	std	Y+3, r23	; 0x03
     bca:	6a 83       	std	Y+2, r22	; 0x02
		
	/* This value is number of percent to add or subtract pr degree. */
	percentPrDeg = 0.0555555555555556;
     bcc:	49 e3       	ldi	r20, 0x39	; 57
     bce:	5e e8       	ldi	r21, 0x8E	; 142
     bd0:	63 e6       	ldi	r22, 0x63	; 99
     bd2:	7d e3       	ldi	r23, 0x3D	; 61
     bd4:	4e 83       	std	Y+6, r20	; 0x06
     bd6:	5f 83       	std	Y+7, r21	; 0x07
     bd8:	68 87       	std	Y+8, r22	; 0x08
     bda:	79 87       	std	Y+9, r23	; 0x09
	
	/* This value is the lowest duty cycle percentage needed to make motor turn. */
	startpercent_ = 2.5;
     bdc:	40 e0       	ldi	r20, 0x00	; 0
     bde:	50 e0       	ldi	r21, 0x00	; 0
     be0:	60 e2       	ldi	r22, 0x20	; 32
     be2:	70 e4       	ldi	r23, 0x40	; 64
     be4:	4a 8b       	std	Y+18, r20	; 0x12
     be6:	5b 8b       	std	Y+19, r21	; 0x13
     be8:	6c 8b       	std	Y+20, r22	; 0x14
     bea:	7d 8b       	std	Y+21, r23	; 0x15

	/* This value is the delay on motor. A lower value makes motors go faster and higher value makes motors go slower. Value is in MS */
	delay_ = 10;
     bec:	2a e0       	ldi	r18, 0x0A	; 10
     bee:	30 e0       	ldi	r19, 0x00	; 0
     bf0:	38 8f       	std	Y+24, r19	; 0x18
     bf2:	2f 8b       	std	Y+23, r18	; 0x17
	
	/* This value is the maximum number of degrees the motor can turn */
	maxDegrees_ = 180;
     bf4:	24 eb       	ldi	r18, 0xB4	; 180
     bf6:	2e 8b       	std	Y+22, r18	; 0x16
	*/
	virtual void SetDegrees( uint8_t degrees )
	{
		if ( maxDegrees_ >= degrees )
		{
			percent_ = percentPrDeg * degrees + startpercent_;
     bf8:	40 e0       	ldi	r20, 0x00	; 0
     bfa:	50 e0       	ldi	r21, 0x00	; 0
     bfc:	60 ef       	ldi	r22, 0xF0	; 240
     bfe:	70 e4       	ldi	r23, 0x40	; 64
     c00:	4a 87       	std	Y+10, r20	; 0x0a
     c02:	5b 87       	std	Y+11, r21	; 0x0b
     c04:	6c 87       	std	Y+12, r22	; 0x0c
     c06:	7d 87       	std	Y+13, r23	; 0x0d
	
	/* Set motor to default startup value */
	SetDegrees( 90 );
	tmr1Ptr_->setDutyCycleComC( percent_ );
     c08:	ad d3       	rcall	.+1882   	; 0x1364 <_ZN6Timer116setDutyCycleComCEf>
	oldPercent_ = percent_;	
     c0a:	8a 85       	ldd	r24, Y+10	; 0x0a
     c0c:	9b 85       	ldd	r25, Y+11	; 0x0b
     c0e:	ac 85       	ldd	r26, Y+12	; 0x0c
     c10:	bd 85       	ldd	r27, Y+13	; 0x0d
     c12:	8e 87       	std	Y+14, r24	; 0x0e
     c14:	9f 87       	std	Y+15, r25	; 0x0f
     c16:	a8 8b       	std	Y+16, r26	; 0x10
     c18:	b9 8b       	std	Y+17, r27	; 0x11
}
     c1a:	df 91       	pop	r29
     c1c:	cf 91       	pop	r28
     c1e:	08 95       	ret

00000c20 <_ZN2M4D1Ev>:

class Motor
{
//functions
public:
	virtual ~Motor() {};
     c20:	21 e6       	ldi	r18, 0x61	; 97
     c22:	32 e0       	ldi	r19, 0x02	; 2
     c24:	fc 01       	movw	r30, r24
     c26:	31 83       	std	Z+1, r19	; 0x01
     c28:	20 83       	st	Z, r18
     c2a:	08 95       	ret

00000c2c <_ZN2M4D0Ev>:
	SetDegrees( 90 );
	tmr3Ptr_->setDutyCycleComA( percent_ );
	oldPercent_ = percent_;
}

M4::~M4()
     c2c:	cf 93       	push	r28
     c2e:	df 93       	push	r29
     c30:	ec 01       	movw	r28, r24
{
} 
     c32:	f6 df       	rcall	.-20     	; 0xc20 <_ZN2M4D1Ev>
     c34:	ce 01       	movw	r24, r28
     c36:	b2 dd       	rcall	.-1180   	; 0x79c <_ZdlPv>
     c38:	df 91       	pop	r29
     c3a:	cf 91       	pop	r28
     c3c:	08 95       	ret

00000c3e <_ZN2M49TurnMotorEv>:

void M4::TurnMotor()
{
     c3e:	4f 92       	push	r4
     c40:	5f 92       	push	r5
     c42:	6f 92       	push	r6
     c44:	7f 92       	push	r7
     c46:	8f 92       	push	r8
     c48:	9f 92       	push	r9
     c4a:	af 92       	push	r10
     c4c:	bf 92       	push	r11
     c4e:	cf 92       	push	r12
     c50:	df 92       	push	r13
     c52:	ef 92       	push	r14
     c54:	ff 92       	push	r15
     c56:	cf 93       	push	r28
     c58:	df 93       	push	r29
     c5a:	ec 01       	movw	r28, r24
	if ( percent_ > oldPercent_ + PERCENT_PR_TICK )
     c5c:	8a 84       	ldd	r8, Y+10	; 0x0a
     c5e:	9b 84       	ldd	r9, Y+11	; 0x0b
     c60:	ac 84       	ldd	r10, Y+12	; 0x0c
     c62:	bd 84       	ldd	r11, Y+13	; 0x0d
     c64:	ce 84       	ldd	r12, Y+14	; 0x0e
     c66:	df 84       	ldd	r13, Y+15	; 0x0f
     c68:	e8 88       	ldd	r14, Y+16	; 0x10
     c6a:	f9 88       	ldd	r15, Y+17	; 0x11
     c6c:	20 e0       	ldi	r18, 0x00	; 0
     c6e:	30 e0       	ldi	r19, 0x00	; 0
     c70:	40 e8       	ldi	r20, 0x80	; 128
     c72:	5d e3       	ldi	r21, 0x3D	; 61
     c74:	c7 01       	movw	r24, r14
     c76:	b6 01       	movw	r22, r12
     c78:	0e 94 25 10 	call	0x204a	; 0x204a <__addsf3>
     c7c:	2b 01       	movw	r4, r22
     c7e:	3c 01       	movw	r6, r24
     c80:	9b 01       	movw	r18, r22
     c82:	ac 01       	movw	r20, r24
     c84:	c5 01       	movw	r24, r10
     c86:	b4 01       	movw	r22, r8
     c88:	0e 94 6b 11 	call	0x22d6	; 0x22d6 <__gesf2>
     c8c:	18 16       	cp	r1, r24
     c8e:	74 f4       	brge	.+28     	; 0xcac <_ZN2M49TurnMotorEv+0x6e>
	{
		oldPercent_ += PERCENT_PR_TICK;
     c90:	4e 86       	std	Y+14, r4	; 0x0e
     c92:	5f 86       	std	Y+15, r5	; 0x0f
     c94:	68 8a       	std	Y+16, r6	; 0x10
     c96:	79 8a       	std	Y+17, r7	; 0x11
		tmr3Ptr_->setDutyCycleComA( oldPercent_ );
     c98:	b3 01       	movw	r22, r6
     c9a:	a2 01       	movw	r20, r4
     c9c:	8c 81       	ldd	r24, Y+4	; 0x04
     c9e:	9d 81       	ldd	r25, Y+5	; 0x05
     ca0:	a7 d3       	rcall	.+1870   	; 0x13f0 <_ZN6Timer316setDutyCycleComAEf>
		vTaskDelay( 10 / portTICK_RATE_MS );
     ca2:	8a e0       	ldi	r24, 0x0A	; 10
     ca4:	90 e0       	ldi	r25, 0x00	; 0
     ca6:	0e 94 47 0f 	call	0x1e8e	; 0x1e8e <vTaskDelay>
     caa:	1d c0       	rjmp	.+58     	; 0xce6 <_ZN2M49TurnMotorEv+0xa8>
	}
	else if ( percent_ < oldPercent_ )
     cac:	a7 01       	movw	r20, r14
     cae:	96 01       	movw	r18, r12
     cb0:	c5 01       	movw	r24, r10
     cb2:	b4 01       	movw	r22, r8
     cb4:	0e 94 89 10 	call	0x2112	; 0x2112 <__cmpsf2>
     cb8:	88 23       	and	r24, r24
     cba:	ac f4       	brge	.+42     	; 0xce6 <_ZN2M49TurnMotorEv+0xa8>
	{
		oldPercent_ -= PERCENT_PR_TICK;
     cbc:	20 e0       	ldi	r18, 0x00	; 0
     cbe:	30 e0       	ldi	r19, 0x00	; 0
     cc0:	40 e8       	ldi	r20, 0x80	; 128
     cc2:	5d e3       	ldi	r21, 0x3D	; 61
     cc4:	c7 01       	movw	r24, r14
     cc6:	b6 01       	movw	r22, r12
     cc8:	0e 94 24 10 	call	0x2048	; 0x2048 <__subsf3>
     ccc:	ab 01       	movw	r20, r22
     cce:	bc 01       	movw	r22, r24
     cd0:	4e 87       	std	Y+14, r20	; 0x0e
     cd2:	5f 87       	std	Y+15, r21	; 0x0f
     cd4:	68 8b       	std	Y+16, r22	; 0x10
     cd6:	79 8b       	std	Y+17, r23	; 0x11
		tmr3Ptr_->setDutyCycleComA( oldPercent_ );
     cd8:	8c 81       	ldd	r24, Y+4	; 0x04
     cda:	9d 81       	ldd	r25, Y+5	; 0x05
     cdc:	89 d3       	rcall	.+1810   	; 0x13f0 <_ZN6Timer316setDutyCycleComAEf>
		vTaskDelay( 10 / portTICK_RATE_MS );
     cde:	8a e0       	ldi	r24, 0x0A	; 10
     ce0:	90 e0       	ldi	r25, 0x00	; 0
     ce2:	0e 94 47 0f 	call	0x1e8e	; 0x1e8e <vTaskDelay>
	}
}
     ce6:	df 91       	pop	r29
     ce8:	cf 91       	pop	r28
     cea:	ff 90       	pop	r15
     cec:	ef 90       	pop	r14
     cee:	df 90       	pop	r13
     cf0:	cf 90       	pop	r12
     cf2:	bf 90       	pop	r11
     cf4:	af 90       	pop	r10
     cf6:	9f 90       	pop	r9
     cf8:	8f 90       	pop	r8
     cfa:	7f 90       	pop	r7
     cfc:	6f 90       	pop	r6
     cfe:	5f 90       	pop	r5
     d00:	4f 90       	pop	r4
     d02:	08 95       	ret

00000d04 <_ZN2M4C1EP6Timer3>:
* Author: jespe
*/

#include "M4.h"

M4::M4( Timer3* tmr )
     d04:	cf 93       	push	r28
     d06:	df 93       	push	r29
     d08:	ec 01       	movw	r28, r24
     d0a:	cb 01       	movw	r24, r22
     d0c:	21 e9       	ldi	r18, 0x91	; 145
     d0e:	32 e0       	ldi	r19, 0x02	; 2
     d10:	39 83       	std	Y+1, r19	; 0x01
     d12:	28 83       	st	Y, r18
{
	/* Store timer pointer */
	tmr3Ptr_ = tmr;
     d14:	7d 83       	std	Y+5, r23	; 0x05
     d16:	6c 83       	std	Y+4, r22	; 0x04
	
	/* This value is number of percent to add or subtract pr degree. */
	percentPrDeg = 0.0555555555555556;
     d18:	49 e3       	ldi	r20, 0x39	; 57
     d1a:	5e e8       	ldi	r21, 0x8E	; 142
     d1c:	63 e6       	ldi	r22, 0x63	; 99
     d1e:	7d e3       	ldi	r23, 0x3D	; 61
     d20:	4e 83       	std	Y+6, r20	; 0x06
     d22:	5f 83       	std	Y+7, r21	; 0x07
     d24:	68 87       	std	Y+8, r22	; 0x08
     d26:	79 87       	std	Y+9, r23	; 0x09
	
	/* This value is the lowest duty cycle percentage needed to make motor turn. */
	startpercent_ = 2.5;
     d28:	40 e0       	ldi	r20, 0x00	; 0
     d2a:	50 e0       	ldi	r21, 0x00	; 0
     d2c:	60 e2       	ldi	r22, 0x20	; 32
     d2e:	70 e4       	ldi	r23, 0x40	; 64
     d30:	4a 8b       	std	Y+18, r20	; 0x12
     d32:	5b 8b       	std	Y+19, r21	; 0x13
     d34:	6c 8b       	std	Y+20, r22	; 0x14
     d36:	7d 8b       	std	Y+21, r23	; 0x15
		
	/* This value is the delay on motor. A lower value makes motors go faster and higher value makes motors go slower. Value is in MS */
	delay_ = 5;
     d38:	25 e0       	ldi	r18, 0x05	; 5
     d3a:	30 e0       	ldi	r19, 0x00	; 0
     d3c:	38 8f       	std	Y+24, r19	; 0x18
     d3e:	2f 8b       	std	Y+23, r18	; 0x17
	
	/* This value is the maximum number of degrees the motor can turn */
	maxDegrees_ = 180;
     d40:	24 eb       	ldi	r18, 0xB4	; 180
     d42:	2e 8b       	std	Y+22, r18	; 0x16
	*/
	virtual void SetDegrees( uint8_t degrees )
	{
		if ( maxDegrees_ >= degrees )
		{
			percent_ = percentPrDeg * degrees + startpercent_;
     d44:	40 e0       	ldi	r20, 0x00	; 0
     d46:	50 e0       	ldi	r21, 0x00	; 0
     d48:	60 ef       	ldi	r22, 0xF0	; 240
     d4a:	70 e4       	ldi	r23, 0x40	; 64
     d4c:	4a 87       	std	Y+10, r20	; 0x0a
     d4e:	5b 87       	std	Y+11, r21	; 0x0b
     d50:	6c 87       	std	Y+12, r22	; 0x0c
     d52:	7d 87       	std	Y+13, r23	; 0x0d
	
	/* Set motor to default startup value */
	SetDegrees( 90 );
	tmr3Ptr_->setDutyCycleComA( percent_ );
     d54:	4d d3       	rcall	.+1690   	; 0x13f0 <_ZN6Timer316setDutyCycleComAEf>
	oldPercent_ = percent_;
     d56:	8a 85       	ldd	r24, Y+10	; 0x0a
     d58:	9b 85       	ldd	r25, Y+11	; 0x0b
     d5a:	ac 85       	ldd	r26, Y+12	; 0x0c
     d5c:	bd 85       	ldd	r27, Y+13	; 0x0d
     d5e:	8e 87       	std	Y+14, r24	; 0x0e
     d60:	9f 87       	std	Y+15, r25	; 0x0f
     d62:	a8 8b       	std	Y+16, r26	; 0x10
     d64:	b9 8b       	std	Y+17, r27	; 0x11
}
     d66:	df 91       	pop	r29
     d68:	cf 91       	pop	r28
     d6a:	08 95       	ret

00000d6c <_ZN2M5D1Ev>:

class Motor
{
//functions
public:
	virtual ~Motor() {};
     d6c:	21 e6       	ldi	r18, 0x61	; 97
     d6e:	32 e0       	ldi	r19, 0x02	; 2
     d70:	fc 01       	movw	r30, r24
     d72:	31 83       	std	Z+1, r19	; 0x01
     d74:	20 83       	st	Z, r18
     d76:	08 95       	ret

00000d78 <_ZN2M5D0Ev>:
	SetDegrees( 0 );
	tmr3Ptr_->setDutyCycleComB( percent_ );
	oldPercent_ = percent_;
}

M5::~M5()
     d78:	cf 93       	push	r28
     d7a:	df 93       	push	r29
     d7c:	ec 01       	movw	r28, r24
{
}
     d7e:	f6 df       	rcall	.-20     	; 0xd6c <_ZN2M5D1Ev>
     d80:	ce 01       	movw	r24, r28
     d82:	0c dd       	rcall	.-1512   	; 0x79c <_ZdlPv>
     d84:	df 91       	pop	r29
     d86:	cf 91       	pop	r28
     d88:	08 95       	ret

00000d8a <_ZN2M59TurnMotorEv>:

void M5::TurnMotor()
{
     d8a:	4f 92       	push	r4
     d8c:	5f 92       	push	r5
     d8e:	6f 92       	push	r6
     d90:	7f 92       	push	r7
     d92:	8f 92       	push	r8
     d94:	9f 92       	push	r9
     d96:	af 92       	push	r10
     d98:	bf 92       	push	r11
     d9a:	cf 92       	push	r12
     d9c:	df 92       	push	r13
     d9e:	ef 92       	push	r14
     da0:	ff 92       	push	r15
     da2:	cf 93       	push	r28
     da4:	df 93       	push	r29
     da6:	ec 01       	movw	r28, r24
	if ( percent_ > oldPercent_ + PERCENT_PR_TICK )
     da8:	8a 84       	ldd	r8, Y+10	; 0x0a
     daa:	9b 84       	ldd	r9, Y+11	; 0x0b
     dac:	ac 84       	ldd	r10, Y+12	; 0x0c
     dae:	bd 84       	ldd	r11, Y+13	; 0x0d
     db0:	ce 84       	ldd	r12, Y+14	; 0x0e
     db2:	df 84       	ldd	r13, Y+15	; 0x0f
     db4:	e8 88       	ldd	r14, Y+16	; 0x10
     db6:	f9 88       	ldd	r15, Y+17	; 0x11
     db8:	20 e0       	ldi	r18, 0x00	; 0
     dba:	30 e0       	ldi	r19, 0x00	; 0
     dbc:	40 e8       	ldi	r20, 0x80	; 128
     dbe:	5d e3       	ldi	r21, 0x3D	; 61
     dc0:	c7 01       	movw	r24, r14
     dc2:	b6 01       	movw	r22, r12
     dc4:	0e 94 25 10 	call	0x204a	; 0x204a <__addsf3>
     dc8:	2b 01       	movw	r4, r22
     dca:	3c 01       	movw	r6, r24
     dcc:	9b 01       	movw	r18, r22
     dce:	ac 01       	movw	r20, r24
     dd0:	c5 01       	movw	r24, r10
     dd2:	b4 01       	movw	r22, r8
     dd4:	0e 94 6b 11 	call	0x22d6	; 0x22d6 <__gesf2>
     dd8:	18 16       	cp	r1, r24
     dda:	74 f4       	brge	.+28     	; 0xdf8 <_ZN2M59TurnMotorEv+0x6e>
	{
		oldPercent_ += PERCENT_PR_TICK;
     ddc:	4e 86       	std	Y+14, r4	; 0x0e
     dde:	5f 86       	std	Y+15, r5	; 0x0f
     de0:	68 8a       	std	Y+16, r6	; 0x10
     de2:	79 8a       	std	Y+17, r7	; 0x11
		tmr3Ptr_->setDutyCycleComB( oldPercent_ );
     de4:	b3 01       	movw	r22, r6
     de6:	a2 01       	movw	r20, r4
     de8:	8c 81       	ldd	r24, Y+4	; 0x04
     dea:	9d 81       	ldd	r25, Y+5	; 0x05
     dec:	28 d3       	rcall	.+1616   	; 0x143e <_ZN6Timer316setDutyCycleComBEf>
		vTaskDelay( delay_ / portTICK_RATE_MS );
     dee:	8f 89       	ldd	r24, Y+23	; 0x17
     df0:	98 8d       	ldd	r25, Y+24	; 0x18
     df2:	0e 94 47 0f 	call	0x1e8e	; 0x1e8e <vTaskDelay>
     df6:	1d c0       	rjmp	.+58     	; 0xe32 <_ZN2M59TurnMotorEv+0xa8>
	}
	else if ( percent_ < oldPercent_ )
     df8:	a7 01       	movw	r20, r14
     dfa:	96 01       	movw	r18, r12
     dfc:	c5 01       	movw	r24, r10
     dfe:	b4 01       	movw	r22, r8
     e00:	0e 94 89 10 	call	0x2112	; 0x2112 <__cmpsf2>
     e04:	88 23       	and	r24, r24
     e06:	ac f4       	brge	.+42     	; 0xe32 <_ZN2M59TurnMotorEv+0xa8>
	{
		oldPercent_ -= PERCENT_PR_TICK;
     e08:	20 e0       	ldi	r18, 0x00	; 0
     e0a:	30 e0       	ldi	r19, 0x00	; 0
     e0c:	40 e8       	ldi	r20, 0x80	; 128
     e0e:	5d e3       	ldi	r21, 0x3D	; 61
     e10:	c7 01       	movw	r24, r14
     e12:	b6 01       	movw	r22, r12
     e14:	0e 94 24 10 	call	0x2048	; 0x2048 <__subsf3>
     e18:	ab 01       	movw	r20, r22
     e1a:	bc 01       	movw	r22, r24
     e1c:	4e 87       	std	Y+14, r20	; 0x0e
     e1e:	5f 87       	std	Y+15, r21	; 0x0f
     e20:	68 8b       	std	Y+16, r22	; 0x10
     e22:	79 8b       	std	Y+17, r23	; 0x11
		tmr3Ptr_->setDutyCycleComB( oldPercent_ );
     e24:	8c 81       	ldd	r24, Y+4	; 0x04
     e26:	9d 81       	ldd	r25, Y+5	; 0x05
     e28:	0a d3       	rcall	.+1556   	; 0x143e <_ZN6Timer316setDutyCycleComBEf>
		vTaskDelay( delay_ / portTICK_RATE_MS );
     e2a:	8f 89       	ldd	r24, Y+23	; 0x17
     e2c:	98 8d       	ldd	r25, Y+24	; 0x18
     e2e:	0e 94 47 0f 	call	0x1e8e	; 0x1e8e <vTaskDelay>
	}
}
     e32:	df 91       	pop	r29
     e34:	cf 91       	pop	r28
     e36:	ff 90       	pop	r15
     e38:	ef 90       	pop	r14
     e3a:	df 90       	pop	r13
     e3c:	cf 90       	pop	r12
     e3e:	bf 90       	pop	r11
     e40:	af 90       	pop	r10
     e42:	9f 90       	pop	r9
     e44:	8f 90       	pop	r8
     e46:	7f 90       	pop	r7
     e48:	6f 90       	pop	r6
     e4a:	5f 90       	pop	r5
     e4c:	4f 90       	pop	r4
     e4e:	08 95       	ret

00000e50 <_ZN2M5C1EP6Timer3>:
* Author: jespe
*/

#include "M5.h"

M5::M5( Timer3* tmr )
     e50:	cf 93       	push	r28
     e52:	df 93       	push	r29
     e54:	ec 01       	movw	r28, r24
     e56:	cb 01       	movw	r24, r22
     e58:	2d e9       	ldi	r18, 0x9D	; 157
     e5a:	32 e0       	ldi	r19, 0x02	; 2
     e5c:	39 83       	std	Y+1, r19	; 0x01
     e5e:	28 83       	st	Y, r18
{
	/* Store timer pointer */
	tmr3Ptr_ = tmr;
     e60:	7d 83       	std	Y+5, r23	; 0x05
     e62:	6c 83       	std	Y+4, r22	; 0x04
	
	/* This value is number of percent to add or subtract pr degree. */
	percentPrDeg = 0.0555555555555556;
     e64:	49 e3       	ldi	r20, 0x39	; 57
     e66:	5e e8       	ldi	r21, 0x8E	; 142
     e68:	63 e6       	ldi	r22, 0x63	; 99
     e6a:	7d e3       	ldi	r23, 0x3D	; 61
     e6c:	4e 83       	std	Y+6, r20	; 0x06
     e6e:	5f 83       	std	Y+7, r21	; 0x07
     e70:	68 87       	std	Y+8, r22	; 0x08
     e72:	79 87       	std	Y+9, r23	; 0x09
	
	/* This value is the lowest duty cycle percentage needed to make motor turn. */
	startpercent_ = 2.5;
     e74:	40 e0       	ldi	r20, 0x00	; 0
     e76:	50 e0       	ldi	r21, 0x00	; 0
     e78:	60 e2       	ldi	r22, 0x20	; 32
     e7a:	70 e4       	ldi	r23, 0x40	; 64
     e7c:	4a 8b       	std	Y+18, r20	; 0x12
     e7e:	5b 8b       	std	Y+19, r21	; 0x13
     e80:	6c 8b       	std	Y+20, r22	; 0x14
     e82:	7d 8b       	std	Y+21, r23	; 0x15
	
	/* This value is the delay on motor. A lower value makes motors go faster and higher value makes motors go slower. Value is in MS */
	delay_ = 1;
     e84:	21 e0       	ldi	r18, 0x01	; 1
     e86:	30 e0       	ldi	r19, 0x00	; 0
     e88:	38 8f       	std	Y+24, r19	; 0x18
     e8a:	2f 8b       	std	Y+23, r18	; 0x17
	
	/* This value is the maximum number of degrees the motor can turn */
	maxDegrees_ = 180;
     e8c:	24 eb       	ldi	r18, 0xB4	; 180
     e8e:	2e 8b       	std	Y+22, r18	; 0x16
	*/
	virtual void SetDegrees( uint8_t degrees )
	{
		if ( maxDegrees_ >= degrees )
		{
			percent_ = percentPrDeg * degrees + startpercent_;
     e90:	4a 87       	std	Y+10, r20	; 0x0a
     e92:	5b 87       	std	Y+11, r21	; 0x0b
     e94:	6c 87       	std	Y+12, r22	; 0x0c
     e96:	7d 87       	std	Y+13, r23	; 0x0d
	
	/* Set motor to default startup value */
	SetDegrees( 0 );
	tmr3Ptr_->setDutyCycleComB( percent_ );
     e98:	d2 d2       	rcall	.+1444   	; 0x143e <_ZN6Timer316setDutyCycleComBEf>
	oldPercent_ = percent_;
     e9a:	8a 85       	ldd	r24, Y+10	; 0x0a
     e9c:	9b 85       	ldd	r25, Y+11	; 0x0b
     e9e:	ac 85       	ldd	r26, Y+12	; 0x0c
     ea0:	bd 85       	ldd	r27, Y+13	; 0x0d
     ea2:	8e 87       	std	Y+14, r24	; 0x0e
     ea4:	9f 87       	std	Y+15, r25	; 0x0f
     ea6:	a8 8b       	std	Y+16, r26	; 0x10
     ea8:	b9 8b       	std	Y+17, r27	; 0x11
}
     eaa:	df 91       	pop	r29
     eac:	cf 91       	pop	r28
     eae:	08 95       	ret

00000eb0 <_ZN2M6D1Ev>:

class Motor
{
//functions
public:
	virtual ~Motor() {};
     eb0:	21 e6       	ldi	r18, 0x61	; 97
     eb2:	32 e0       	ldi	r19, 0x02	; 2
     eb4:	fc 01       	movw	r30, r24
     eb6:	31 83       	std	Z+1, r19	; 0x01
     eb8:	20 83       	st	Z, r18
     eba:	08 95       	ret

00000ebc <_ZN2M6D0Ev>:
	SetDegrees( 0 );
	tmr3Ptr_->setDutyCycleComC( percent_ );
	oldPercent_ = percent_;
}

M6::~M6()
     ebc:	cf 93       	push	r28
     ebe:	df 93       	push	r29
     ec0:	ec 01       	movw	r28, r24
{
}
     ec2:	f6 df       	rcall	.-20     	; 0xeb0 <_ZN2M6D1Ev>
     ec4:	ce 01       	movw	r24, r28
     ec6:	6a dc       	rcall	.-1836   	; 0x79c <_ZdlPv>
     ec8:	df 91       	pop	r29
     eca:	cf 91       	pop	r28
     ecc:	08 95       	ret

00000ece <_ZN2M69TurnMotorEv>:

void M6::TurnMotor()
{
     ece:	4f 92       	push	r4
     ed0:	5f 92       	push	r5
     ed2:	6f 92       	push	r6
     ed4:	7f 92       	push	r7
     ed6:	8f 92       	push	r8
     ed8:	9f 92       	push	r9
     eda:	af 92       	push	r10
     edc:	bf 92       	push	r11
     ede:	cf 92       	push	r12
     ee0:	df 92       	push	r13
     ee2:	ef 92       	push	r14
     ee4:	ff 92       	push	r15
     ee6:	cf 93       	push	r28
     ee8:	df 93       	push	r29
     eea:	ec 01       	movw	r28, r24
	if ( percent_ > oldPercent_ + PERCENT_PR_TICK )
     eec:	8a 84       	ldd	r8, Y+10	; 0x0a
     eee:	9b 84       	ldd	r9, Y+11	; 0x0b
     ef0:	ac 84       	ldd	r10, Y+12	; 0x0c
     ef2:	bd 84       	ldd	r11, Y+13	; 0x0d
     ef4:	ce 84       	ldd	r12, Y+14	; 0x0e
     ef6:	df 84       	ldd	r13, Y+15	; 0x0f
     ef8:	e8 88       	ldd	r14, Y+16	; 0x10
     efa:	f9 88       	ldd	r15, Y+17	; 0x11
     efc:	20 e0       	ldi	r18, 0x00	; 0
     efe:	30 e0       	ldi	r19, 0x00	; 0
     f00:	40 e8       	ldi	r20, 0x80	; 128
     f02:	5d e3       	ldi	r21, 0x3D	; 61
     f04:	c7 01       	movw	r24, r14
     f06:	b6 01       	movw	r22, r12
     f08:	0e 94 25 10 	call	0x204a	; 0x204a <__addsf3>
     f0c:	2b 01       	movw	r4, r22
     f0e:	3c 01       	movw	r6, r24
     f10:	9b 01       	movw	r18, r22
     f12:	ac 01       	movw	r20, r24
     f14:	c5 01       	movw	r24, r10
     f16:	b4 01       	movw	r22, r8
     f18:	0e 94 6b 11 	call	0x22d6	; 0x22d6 <__gesf2>
     f1c:	18 16       	cp	r1, r24
     f1e:	6c f4       	brge	.+26     	; 0xf3a <_ZN2M69TurnMotorEv+0x6c>
	{
		oldPercent_ += 0.0625;
     f20:	4e 86       	std	Y+14, r4	; 0x0e
     f22:	5f 86       	std	Y+15, r5	; 0x0f
     f24:	68 8a       	std	Y+16, r6	; 0x10
     f26:	79 8a       	std	Y+17, r7	; 0x11
		tmr3Ptr_->setDutyCycleComC( oldPercent_ );
     f28:	b3 01       	movw	r22, r6
     f2a:	a2 01       	movw	r20, r4
     f2c:	8c 81       	ldd	r24, Y+4	; 0x04
     f2e:	9d 81       	ldd	r25, Y+5	; 0x05
     f30:	ad d2       	rcall	.+1370   	; 0x148c <_ZN6Timer316setDutyCycleComCEf>
		vTaskDelay( delay_ / portTICK_RATE_MS );
     f32:	8f 89       	ldd	r24, Y+23	; 0x17
     f34:	98 8d       	ldd	r25, Y+24	; 0x18
     f36:	ab d7       	rcall	.+3926   	; 0x1e8e <vTaskDelay>
     f38:	1c c0       	rjmp	.+56     	; 0xf72 <_ZN2M69TurnMotorEv+0xa4>
	}
	else if ( percent_ < oldPercent_ )
     f3a:	a7 01       	movw	r20, r14
     f3c:	96 01       	movw	r18, r12
     f3e:	c5 01       	movw	r24, r10
     f40:	b4 01       	movw	r22, r8
     f42:	0e 94 89 10 	call	0x2112	; 0x2112 <__cmpsf2>
     f46:	88 23       	and	r24, r24
     f48:	a4 f4       	brge	.+40     	; 0xf72 <_ZN2M69TurnMotorEv+0xa4>
	{
		oldPercent_ -= 0.0625;
     f4a:	20 e0       	ldi	r18, 0x00	; 0
     f4c:	30 e0       	ldi	r19, 0x00	; 0
     f4e:	40 e8       	ldi	r20, 0x80	; 128
     f50:	5d e3       	ldi	r21, 0x3D	; 61
     f52:	c7 01       	movw	r24, r14
     f54:	b6 01       	movw	r22, r12
     f56:	0e 94 24 10 	call	0x2048	; 0x2048 <__subsf3>
     f5a:	ab 01       	movw	r20, r22
     f5c:	bc 01       	movw	r22, r24
     f5e:	4e 87       	std	Y+14, r20	; 0x0e
     f60:	5f 87       	std	Y+15, r21	; 0x0f
     f62:	68 8b       	std	Y+16, r22	; 0x10
     f64:	79 8b       	std	Y+17, r23	; 0x11
		tmr3Ptr_->setDutyCycleComC( oldPercent_ );
     f66:	8c 81       	ldd	r24, Y+4	; 0x04
     f68:	9d 81       	ldd	r25, Y+5	; 0x05
     f6a:	90 d2       	rcall	.+1312   	; 0x148c <_ZN6Timer316setDutyCycleComCEf>
		vTaskDelay( delay_ / portTICK_RATE_MS );
     f6c:	8f 89       	ldd	r24, Y+23	; 0x17
     f6e:	98 8d       	ldd	r25, Y+24	; 0x18
     f70:	8e d7       	rcall	.+3868   	; 0x1e8e <vTaskDelay>
	}
}
     f72:	df 91       	pop	r29
     f74:	cf 91       	pop	r28
     f76:	ff 90       	pop	r15
     f78:	ef 90       	pop	r14
     f7a:	df 90       	pop	r13
     f7c:	cf 90       	pop	r12
     f7e:	bf 90       	pop	r11
     f80:	af 90       	pop	r10
     f82:	9f 90       	pop	r9
     f84:	8f 90       	pop	r8
     f86:	7f 90       	pop	r7
     f88:	6f 90       	pop	r6
     f8a:	5f 90       	pop	r5
     f8c:	4f 90       	pop	r4
     f8e:	08 95       	ret

00000f90 <_ZN2M6C1EP6Timer3>:
* Author: jespe
*/

#include "M6.h"

M6::M6( Timer3* tmr )
     f90:	cf 93       	push	r28
     f92:	df 93       	push	r29
     f94:	ec 01       	movw	r28, r24
     f96:	cb 01       	movw	r24, r22
     f98:	29 ea       	ldi	r18, 0xA9	; 169
     f9a:	32 e0       	ldi	r19, 0x02	; 2
     f9c:	39 83       	std	Y+1, r19	; 0x01
     f9e:	28 83       	st	Y, r18
{
	/* Store timer pointer */
	tmr3Ptr_ = tmr;
     fa0:	7d 83       	std	Y+5, r23	; 0x05
     fa2:	6c 83       	std	Y+4, r22	; 0x04
	
	/* This value is number of percent to add or subtract pr degree. */
	percentPrDeg = 0.07936507936507;
     fa4:	49 e2       	ldi	r20, 0x29	; 41
     fa6:	5a e8       	ldi	r21, 0x8A	; 138
     fa8:	62 ea       	ldi	r22, 0xA2	; 162
     faa:	7d e3       	ldi	r23, 0x3D	; 61
     fac:	4e 83       	std	Y+6, r20	; 0x06
     fae:	5f 83       	std	Y+7, r21	; 0x07
     fb0:	68 87       	std	Y+8, r22	; 0x08
     fb2:	79 87       	std	Y+9, r23	; 0x09
	
	/* This value is the lowest duty cycle percentage needed to make motor turn. */
	startpercent_ = 2.5;
     fb4:	40 e0       	ldi	r20, 0x00	; 0
     fb6:	50 e0       	ldi	r21, 0x00	; 0
     fb8:	60 e2       	ldi	r22, 0x20	; 32
     fba:	70 e4       	ldi	r23, 0x40	; 64
     fbc:	4a 8b       	std	Y+18, r20	; 0x12
     fbe:	5b 8b       	std	Y+19, r21	; 0x13
     fc0:	6c 8b       	std	Y+20, r22	; 0x14
     fc2:	7d 8b       	std	Y+21, r23	; 0x15
	
	/* This value is the delay on motor. A lower value makes motors go faster and higher value makes motors go slower. Value is in MS */
	delay_ = 1;
     fc4:	21 e0       	ldi	r18, 0x01	; 1
     fc6:	30 e0       	ldi	r19, 0x00	; 0
     fc8:	38 8f       	std	Y+24, r19	; 0x18
     fca:	2f 8b       	std	Y+23, r18	; 0x17
	
	/* This value is the maximum number of degrees the motor can turn */
	maxDegrees_ = 63;
     fcc:	2f e3       	ldi	r18, 0x3F	; 63
     fce:	2e 8b       	std	Y+22, r18	; 0x16
	*/
	virtual void SetDegrees( uint8_t degrees )
	{
		if ( maxDegrees_ >= degrees )
		{
			percent_ = percentPrDeg * degrees + startpercent_;
     fd0:	4a 87       	std	Y+10, r20	; 0x0a
     fd2:	5b 87       	std	Y+11, r21	; 0x0b
     fd4:	6c 87       	std	Y+12, r22	; 0x0c
     fd6:	7d 87       	std	Y+13, r23	; 0x0d
	
	/* Set motor to default startup value */
	SetDegrees( 0 );
	tmr3Ptr_->setDutyCycleComC( percent_ );
     fd8:	59 d2       	rcall	.+1202   	; 0x148c <_ZN6Timer316setDutyCycleComCEf>
	oldPercent_ = percent_;
     fda:	8a 85       	ldd	r24, Y+10	; 0x0a
     fdc:	9b 85       	ldd	r25, Y+11	; 0x0b
     fde:	ac 85       	ldd	r26, Y+12	; 0x0c
     fe0:	bd 85       	ldd	r27, Y+13	; 0x0d
     fe2:	8e 87       	std	Y+14, r24	; 0x0e
     fe4:	9f 87       	std	Y+15, r25	; 0x0f
     fe6:	a8 8b       	std	Y+16, r26	; 0x10
     fe8:	b9 8b       	std	Y+17, r27	; 0x11
}
     fea:	df 91       	pop	r29
     fec:	cf 91       	pop	r28
     fee:	08 95       	ret

00000ff0 <_ZN8Robotarm14startMotorImplEPv>:
	motors_[3]->SetDegrees(90);
	vTaskDelay( 250 / portTICK_RATE_MS );
}

void Robotarm::startMotorImpl( void *_this )
{
     ff0:	8c 01       	movw	r16, r24
void Robotarm::MotorSpeedController()
{
	while(1)
	{
		/* Move all motors one step. */
		for ( uint8_t i = 0U; i < 6U; i++ )
     ff2:	c0 e0       	ldi	r28, 0x00	; 0
     ff4:	c6 30       	cpi	r28, 0x06	; 6
     ff6:	e8 f7       	brcc	.-6      	; 0xff2 <_ZN8Robotarm14startMotorImplEPv+0x2>
		{
			motors_[i]->TurnMotor();
     ff8:	ec 2f       	mov	r30, r28
     ffa:	f0 e0       	ldi	r31, 0x00	; 0
     ffc:	31 96       	adiw	r30, 0x01	; 1
     ffe:	ee 0f       	add	r30, r30
    1000:	ff 1f       	adc	r31, r31
    1002:	e0 0f       	add	r30, r16
    1004:	f1 1f       	adc	r31, r17
    1006:	80 81       	ld	r24, Z
    1008:	91 81       	ldd	r25, Z+1	; 0x01
    100a:	dc 01       	movw	r26, r24
    100c:	ed 91       	ld	r30, X+
    100e:	fc 91       	ld	r31, X
    1010:	04 80       	ldd	r0, Z+4	; 0x04
    1012:	f5 81       	ldd	r31, Z+5	; 0x05
    1014:	e0 2d       	mov	r30, r0
    1016:	19 95       	eicall
void Robotarm::MotorSpeedController()
{
	while(1)
	{
		/* Move all motors one step. */
		for ( uint8_t i = 0U; i < 6U; i++ )
    1018:	cf 5f       	subi	r28, 0xFF	; 255
    101a:	ec cf       	rjmp	.-40     	; 0xff4 <_ZN8Robotarm14startMotorImplEPv+0x4>

0000101c <_ZN8RobotarmC1Ev>:
/* RTOS include */
#include "FreeRTOS.h"
#include "task.h"
#include "portmacro.h"

Robotarm::Robotarm() : tmr1_(), tmr3_()
    101c:	af 92       	push	r10
    101e:	bf 92       	push	r11
    1020:	cf 92       	push	r12
    1022:	df 92       	push	r13
    1024:	ef 92       	push	r14
    1026:	ff 92       	push	r15
    1028:	0f 93       	push	r16
    102a:	1f 93       	push	r17
    102c:	cf 93       	push	r28
    102e:	df 93       	push	r29
    1030:	ec 01       	movw	r28, r24
    1032:	2a d1       	rcall	.+596    	; 0x1288 <_ZN6Timer1C1Ev>
    1034:	8e 01       	movw	r16, r28
    1036:	0f 5f       	subi	r16, 0xFF	; 255
    1038:	1f 4f       	sbci	r17, 0xFF	; 255
    103a:	c8 01       	movw	r24, r16
    103c:	bb d1       	rcall	.+886    	; 0x13b4 <_ZN6Timer3C1Ev>
{
	/* Create all motor objects */
	motors_[0] = new M1( &tmr1_ );
    103e:	89 e1       	ldi	r24, 0x19	; 25
    1040:	90 e0       	ldi	r25, 0x00	; 0
    1042:	a9 db       	rcall	.-2222   	; 0x796 <_Znwj>
    1044:	7c 01       	movw	r14, r24
    1046:	be 01       	movw	r22, r28
    1048:	6b dc       	rcall	.-1834   	; 0x920 <_ZN2M1C1EP6Timer1>
    104a:	fb 82       	std	Y+3, r15	; 0x03
    104c:	ea 82       	std	Y+2, r14	; 0x02
	motors_[1] = new M2( &tmr1_ );
    104e:	89 e1       	ldi	r24, 0x19	; 25
    1050:	90 e0       	ldi	r25, 0x00	; 0
    1052:	a1 db       	rcall	.-2238   	; 0x796 <_Znwj>
    1054:	7c 01       	movw	r14, r24
    1056:	be 01       	movw	r22, r28
    1058:	09 dd       	rcall	.-1518   	; 0xa6c <_ZN2M2C1EP6Timer1>
    105a:	fd 82       	std	Y+5, r15	; 0x05
    105c:	ec 82       	std	Y+4, r14	; 0x04
	motors_[2] = new M3( &tmr1_ );
    105e:	89 e1       	ldi	r24, 0x19	; 25
    1060:	90 e0       	ldi	r25, 0x00	; 0
    1062:	99 db       	rcall	.-2254   	; 0x796 <_Znwj>
    1064:	7c 01       	movw	r14, r24
    1066:	be 01       	movw	r22, r28
    1068:	a7 dd       	rcall	.-1202   	; 0xbb8 <_ZN2M3C1EP6Timer1>
    106a:	ff 82       	std	Y+7, r15	; 0x07
    106c:	ee 82       	std	Y+6, r14	; 0x06
	motors_[3] = new M4( &tmr3_ );
    106e:	89 e1       	ldi	r24, 0x19	; 25
    1070:	90 e0       	ldi	r25, 0x00	; 0
    1072:	91 db       	rcall	.-2270   	; 0x796 <_Znwj>
    1074:	7c 01       	movw	r14, r24
    1076:	b8 01       	movw	r22, r16
    1078:	45 de       	rcall	.-886    	; 0xd04 <_ZN2M4C1EP6Timer3>
    107a:	f9 86       	std	Y+9, r15	; 0x09
    107c:	e8 86       	std	Y+8, r14	; 0x08
	motors_[4] = new M5( &tmr3_ );
    107e:	89 e1       	ldi	r24, 0x19	; 25
    1080:	90 e0       	ldi	r25, 0x00	; 0
    1082:	89 db       	rcall	.-2286   	; 0x796 <_Znwj>
    1084:	7c 01       	movw	r14, r24
    1086:	b8 01       	movw	r22, r16
    1088:	e3 de       	rcall	.-570    	; 0xe50 <_ZN2M5C1EP6Timer3>
    108a:	fb 86       	std	Y+11, r15	; 0x0b
    108c:	ea 86       	std	Y+10, r14	; 0x0a
	motors_[5] = new M6( &tmr3_ );
    108e:	89 e1       	ldi	r24, 0x19	; 25
    1090:	90 e0       	ldi	r25, 0x00	; 0
    1092:	81 db       	rcall	.-2302   	; 0x796 <_Znwj>
    1094:	7c 01       	movw	r14, r24
    1096:	b8 01       	movw	r22, r16
    1098:	7b df       	rcall	.-266    	; 0xf90 <_ZN2M6C1EP6Timer3>
    109a:	fd 86       	std	Y+13, r15	; 0x0d
    109c:	ec 86       	std	Y+12, r14	; 0x0c
    109e:	a1 2c       	mov	r10, r1
    10a0:	b1 2c       	mov	r11, r1
	
	/* Create task to control motors */
	xTaskCreate(this->startMotorImpl,  ( signed char * ) "Motors", configMAIN_STACK_SIZE, this, tskIDLE_PRIORITY, NULL);
    10a2:	c1 2c       	mov	r12, r1
    10a4:	d1 2c       	mov	r13, r1
    10a6:	e1 2c       	mov	r14, r1
    10a8:	f1 2c       	mov	r15, r1
    10aa:	00 e0       	ldi	r16, 0x00	; 0
    10ac:	9e 01       	movw	r18, r28
    10ae:	48 ec       	ldi	r20, 0xC8	; 200
    10b0:	50 e0       	ldi	r21, 0x00	; 0
    10b2:	61 eb       	ldi	r22, 0xB1	; 177
    10b4:	72 e0       	ldi	r23, 0x02	; 2
    10b6:	88 ef       	ldi	r24, 0xF8	; 248
    10b8:	97 e0       	ldi	r25, 0x07	; 7
    10ba:	ea d4       	rcall	.+2516   	; 0x1a90 <xTaskGenericCreate>
    10bc:	df 91       	pop	r29
    10be:	cf 91       	pop	r28
}
    10c0:	1f 91       	pop	r17
    10c2:	0f 91       	pop	r16
    10c4:	ff 90       	pop	r15
    10c6:	ef 90       	pop	r14
    10c8:	df 90       	pop	r13
    10ca:	cf 90       	pop	r12
    10cc:	bf 90       	pop	r11
    10ce:	af 90       	pop	r10
    10d0:	08 95       	ret

000010d2 <_ZN8Robotarm9grabBlockEv>:
    10d2:	cf 93       	push	r28
    10d4:	df 93       	push	r29

void Robotarm::grabBlock()
{
    10d6:	ec 01       	movw	r28, r24
	motors_[3]->SetDegrees(40);
    10d8:	88 85       	ldd	r24, Y+8	; 0x08
    10da:	99 85       	ldd	r25, Y+9	; 0x09
    10dc:	dc 01       	movw	r26, r24
    10de:	ed 91       	ld	r30, X+
    10e0:	fc 91       	ld	r31, X
    10e2:	06 80       	ldd	r0, Z+6	; 0x06
    10e4:	f7 81       	ldd	r31, Z+7	; 0x07
    10e6:	e0 2d       	mov	r30, r0
    10e8:	68 e2       	ldi	r22, 0x28	; 40
    10ea:	19 95       	eicall
	motors_[4]->SetDegrees(90);
    10ec:	8a 85       	ldd	r24, Y+10	; 0x0a
    10ee:	9b 85       	ldd	r25, Y+11	; 0x0b
    10f0:	dc 01       	movw	r26, r24
    10f2:	ed 91       	ld	r30, X+
    10f4:	fc 91       	ld	r31, X
    10f6:	06 80       	ldd	r0, Z+6	; 0x06
    10f8:	f7 81       	ldd	r31, Z+7	; 0x07
    10fa:	e0 2d       	mov	r30, r0
    10fc:	6a e5       	ldi	r22, 0x5A	; 90
    10fe:	19 95       	eicall
	motors_[0]->SetDegrees(0);
    1100:	8a 81       	ldd	r24, Y+2	; 0x02
    1102:	9b 81       	ldd	r25, Y+3	; 0x03
    1104:	dc 01       	movw	r26, r24
    1106:	ed 91       	ld	r30, X+
    1108:	fc 91       	ld	r31, X
    110a:	06 80       	ldd	r0, Z+6	; 0x06
    110c:	f7 81       	ldd	r31, Z+7	; 0x07
    110e:	e0 2d       	mov	r30, r0
    1110:	60 e0       	ldi	r22, 0x00	; 0
    1112:	19 95       	eicall
	vTaskDelay( 1500 / portTICK_RATE_MS );
    1114:	8c ed       	ldi	r24, 0xDC	; 220
    1116:	95 e0       	ldi	r25, 0x05	; 5
    1118:	ba d6       	rcall	.+3444   	; 0x1e8e <vTaskDelay>
	motors_[1]->SetDegrees(35);
    111a:	8c 81       	ldd	r24, Y+4	; 0x04
    111c:	9d 81       	ldd	r25, Y+5	; 0x05
    111e:	dc 01       	movw	r26, r24
    1120:	ed 91       	ld	r30, X+
    1122:	fc 91       	ld	r31, X
    1124:	06 80       	ldd	r0, Z+6	; 0x06
    1126:	f7 81       	ldd	r31, Z+7	; 0x07
    1128:	e0 2d       	mov	r30, r0
    112a:	63 e2       	ldi	r22, 0x23	; 35
    112c:	19 95       	eicall
	motors_[2]->SetDegrees(63);
    112e:	8e 81       	ldd	r24, Y+6	; 0x06
    1130:	9f 81       	ldd	r25, Y+7	; 0x07
    1132:	dc 01       	movw	r26, r24
    1134:	ed 91       	ld	r30, X+
    1136:	fc 91       	ld	r31, X
    1138:	06 80       	ldd	r0, Z+6	; 0x06
    113a:	f7 81       	ldd	r31, Z+7	; 0x07
    113c:	e0 2d       	mov	r30, r0
    113e:	6f e3       	ldi	r22, 0x3F	; 63
    1140:	19 95       	eicall
	vTaskDelay( 1500 / portTICK_RATE_MS );
    1142:	8c ed       	ldi	r24, 0xDC	; 220
    1144:	95 e0       	ldi	r25, 0x05	; 5
    1146:	a3 d6       	rcall	.+3398   	; 0x1e8e <vTaskDelay>
	motors_[5]->SetDegrees(63);
    1148:	8c 85       	ldd	r24, Y+12	; 0x0c
    114a:	9d 85       	ldd	r25, Y+13	; 0x0d
    114c:	dc 01       	movw	r26, r24
    114e:	ed 91       	ld	r30, X+
    1150:	fc 91       	ld	r31, X
    1152:	06 80       	ldd	r0, Z+6	; 0x06
    1154:	f7 81       	ldd	r31, Z+7	; 0x07
    1156:	e0 2d       	mov	r30, r0
    1158:	6f e3       	ldi	r22, 0x3F	; 63
    115a:	19 95       	eicall
	vTaskDelay( 250 / portTICK_RATE_MS );
    115c:	8a ef       	ldi	r24, 0xFA	; 250
    115e:	90 e0       	ldi	r25, 0x00	; 0
    1160:	96 d6       	rcall	.+3372   	; 0x1e8e <vTaskDelay>
	motors_[1]->SetDegrees(70);
    1162:	8c 81       	ldd	r24, Y+4	; 0x04
    1164:	9d 81       	ldd	r25, Y+5	; 0x05
    1166:	dc 01       	movw	r26, r24
    1168:	ed 91       	ld	r30, X+
    116a:	fc 91       	ld	r31, X
    116c:	06 80       	ldd	r0, Z+6	; 0x06
    116e:	f7 81       	ldd	r31, Z+7	; 0x07
    1170:	e0 2d       	mov	r30, r0
    1172:	66 e4       	ldi	r22, 0x46	; 70
    1174:	19 95       	eicall
	motors_[2]->SetDegrees(70);
    1176:	8e 81       	ldd	r24, Y+6	; 0x06
    1178:	9f 81       	ldd	r25, Y+7	; 0x07
    117a:	dc 01       	movw	r26, r24
    117c:	ed 91       	ld	r30, X+
    117e:	fc 91       	ld	r31, X
    1180:	06 80       	ldd	r0, Z+6	; 0x06
    1182:	f7 81       	ldd	r31, Z+7	; 0x07
    1184:	e0 2d       	mov	r30, r0
    1186:	66 e4       	ldi	r22, 0x46	; 70
    1188:	19 95       	eicall
	motors_[3]->SetDegrees(70);
    118a:	88 85       	ldd	r24, Y+8	; 0x08
    118c:	99 85       	ldd	r25, Y+9	; 0x09
    118e:	dc 01       	movw	r26, r24
    1190:	ed 91       	ld	r30, X+
    1192:	fc 91       	ld	r31, X
    1194:	06 80       	ldd	r0, Z+6	; 0x06
    1196:	f7 81       	ldd	r31, Z+7	; 0x07
    1198:	e0 2d       	mov	r30, r0
    119a:	66 e4       	ldi	r22, 0x46	; 70
    119c:	19 95       	eicall
}
    119e:	df 91       	pop	r29
    11a0:	cf 91       	pop	r28
    11a2:	08 95       	ret

000011a4 <_ZN8Robotarm18ArmDownReleaseItemEv>:
	motors_[0]->SetDegrees(180);
	ArmDownReleaseItem();
}

void Robotarm::ArmDownReleaseItem()
{
    11a4:	cf 93       	push	r28
    11a6:	df 93       	push	r29
    11a8:	ec 01       	movw	r28, r24
	vTaskDelay( 1500 / portTICK_RATE_MS );
    11aa:	8c ed       	ldi	r24, 0xDC	; 220
    11ac:	95 e0       	ldi	r25, 0x05	; 5
    11ae:	6f d6       	rcall	.+3294   	; 0x1e8e <vTaskDelay>
	motors_[1]->SetDegrees(35);
    11b0:	8c 81       	ldd	r24, Y+4	; 0x04
    11b2:	9d 81       	ldd	r25, Y+5	; 0x05
    11b4:	dc 01       	movw	r26, r24
    11b6:	ed 91       	ld	r30, X+
    11b8:	fc 91       	ld	r31, X
    11ba:	06 80       	ldd	r0, Z+6	; 0x06
    11bc:	f7 81       	ldd	r31, Z+7	; 0x07
    11be:	e0 2d       	mov	r30, r0
    11c0:	63 e2       	ldi	r22, 0x23	; 35
    11c2:	19 95       	eicall
	motors_[2]->SetDegrees(40);
    11c4:	8e 81       	ldd	r24, Y+6	; 0x06
    11c6:	9f 81       	ldd	r25, Y+7	; 0x07
    11c8:	dc 01       	movw	r26, r24
    11ca:	ed 91       	ld	r30, X+
    11cc:	fc 91       	ld	r31, X
    11ce:	06 80       	ldd	r0, Z+6	; 0x06
    11d0:	f7 81       	ldd	r31, Z+7	; 0x07
    11d2:	e0 2d       	mov	r30, r0
    11d4:	68 e2       	ldi	r22, 0x28	; 40
    11d6:	19 95       	eicall
	vTaskDelay( 1500 / portTICK_RATE_MS );
    11d8:	8c ed       	ldi	r24, 0xDC	; 220
    11da:	95 e0       	ldi	r25, 0x05	; 5
    11dc:	58 d6       	rcall	.+3248   	; 0x1e8e <vTaskDelay>
	motors_[5]->SetDegrees(0);
    11de:	8c 85       	ldd	r24, Y+12	; 0x0c
    11e0:	9d 85       	ldd	r25, Y+13	; 0x0d
    11e2:	dc 01       	movw	r26, r24
    11e4:	ed 91       	ld	r30, X+
    11e6:	fc 91       	ld	r31, X
    11e8:	06 80       	ldd	r0, Z+6	; 0x06
    11ea:	f7 81       	ldd	r31, Z+7	; 0x07
    11ec:	e0 2d       	mov	r30, r0
    11ee:	60 e0       	ldi	r22, 0x00	; 0
    11f0:	19 95       	eicall
	vTaskDelay( 250 / portTICK_RATE_MS );
    11f2:	8a ef       	ldi	r24, 0xFA	; 250
    11f4:	90 e0       	ldi	r25, 0x00	; 0
    11f6:	4b d6       	rcall	.+3222   	; 0x1e8e <vTaskDelay>
	motors_[1]->SetDegrees(90);
    11f8:	8c 81       	ldd	r24, Y+4	; 0x04
    11fa:	9d 81       	ldd	r25, Y+5	; 0x05
    11fc:	dc 01       	movw	r26, r24
    11fe:	ed 91       	ld	r30, X+
    1200:	fc 91       	ld	r31, X
    1202:	06 80       	ldd	r0, Z+6	; 0x06
    1204:	f7 81       	ldd	r31, Z+7	; 0x07
    1206:	e0 2d       	mov	r30, r0
    1208:	6a e5       	ldi	r22, 0x5A	; 90
    120a:	19 95       	eicall
	motors_[2]->SetDegrees(90);
    120c:	8e 81       	ldd	r24, Y+6	; 0x06
    120e:	9f 81       	ldd	r25, Y+7	; 0x07
    1210:	dc 01       	movw	r26, r24
    1212:	ed 91       	ld	r30, X+
    1214:	fc 91       	ld	r31, X
    1216:	06 80       	ldd	r0, Z+6	; 0x06
    1218:	f7 81       	ldd	r31, Z+7	; 0x07
    121a:	e0 2d       	mov	r30, r0
    121c:	6a e5       	ldi	r22, 0x5A	; 90
    121e:	19 95       	eicall
	motors_[3]->SetDegrees(90);
    1220:	88 85       	ldd	r24, Y+8	; 0x08
    1222:	99 85       	ldd	r25, Y+9	; 0x09
    1224:	dc 01       	movw	r26, r24
    1226:	ed 91       	ld	r30, X+
    1228:	fc 91       	ld	r31, X
    122a:	06 80       	ldd	r0, Z+6	; 0x06
    122c:	f7 81       	ldd	r31, Z+7	; 0x07
    122e:	e0 2d       	mov	r30, r0
    1230:	6a e5       	ldi	r22, 0x5A	; 90
	vTaskDelay( 250 / portTICK_RATE_MS );
    1232:	19 95       	eicall
    1234:	8a ef       	ldi	r24, 0xFA	; 250
    1236:	90 e0       	ldi	r25, 0x00	; 0
    1238:	2a d6       	rcall	.+3156   	; 0x1e8e <vTaskDelay>
}
    123a:	df 91       	pop	r29
    123c:	cf 91       	pop	r28
    123e:	08 95       	ret

00001240 <_ZN8Robotarm18moveBlockToZoneOneEv>:
	motors_[2]->SetDegrees(70);
	motors_[3]->SetDegrees(70);
}

void Robotarm::moveBlockToZoneOne()
{
    1240:	cf 93       	push	r28
    1242:	df 93       	push	r29
    1244:	ec 01       	movw	r28, r24
	motors_[0]->SetDegrees(90);
    1246:	8a 81       	ldd	r24, Y+2	; 0x02
    1248:	9b 81       	ldd	r25, Y+3	; 0x03
    124a:	dc 01       	movw	r26, r24
    124c:	ed 91       	ld	r30, X+
    124e:	fc 91       	ld	r31, X
    1250:	06 80       	ldd	r0, Z+6	; 0x06
    1252:	f7 81       	ldd	r31, Z+7	; 0x07
    1254:	e0 2d       	mov	r30, r0
    1256:	6a e5       	ldi	r22, 0x5A	; 90
    1258:	19 95       	eicall
	ArmDownReleaseItem();
    125a:	ce 01       	movw	r24, r28
    125c:	a3 df       	rcall	.-186    	; 0x11a4 <_ZN8Robotarm18ArmDownReleaseItemEv>
}
    125e:	df 91       	pop	r29
    1260:	cf 91       	pop	r28
    1262:	08 95       	ret

00001264 <_ZN8Robotarm18moveBlockToZoneTwoEv>:

void Robotarm::moveBlockToZoneTwo()
{
    1264:	cf 93       	push	r28
    1266:	df 93       	push	r29
    1268:	ec 01       	movw	r28, r24
	motors_[0]->SetDegrees(135);
    126a:	8a 81       	ldd	r24, Y+2	; 0x02
    126c:	9b 81       	ldd	r25, Y+3	; 0x03
    126e:	dc 01       	movw	r26, r24
    1270:	ed 91       	ld	r30, X+
    1272:	fc 91       	ld	r31, X
    1274:	06 80       	ldd	r0, Z+6	; 0x06
    1276:	f7 81       	ldd	r31, Z+7	; 0x07
    1278:	e0 2d       	mov	r30, r0
    127a:	67 e8       	ldi	r22, 0x87	; 135
    127c:	19 95       	eicall
	ArmDownReleaseItem();
    127e:	ce 01       	movw	r24, r28
    1280:	91 df       	rcall	.-222    	; 0x11a4 <_ZN8Robotarm18ArmDownReleaseItemEv>
}
    1282:	df 91       	pop	r29
    1284:	cf 91       	pop	r28
    1286:	08 95       	ret

00001288 <_ZN6Timer1C1Ev>:
#include <avr/io.h>

Timer1::Timer1()
{
	// Set B5 to output
	DDRB = DDRB | ( 1 << 5 ) | ( 1 << 6 ) | ( 1 << 7 );
    1288:	84 b1       	in	r24, 0x04	; 4
    128a:	80 6e       	ori	r24, 0xE0	; 224
    128c:	84 b9       	out	0x04, r24	; 4
	
	// Set timer to run in PWM, Phase Correct mode with 50 Hz freq. 
	TCCR1A = ( 1 << COM1A1 ) | ( 1 << COM1B1 ) | ( 1 << COM1C1 ) | ( 0 << WGM10 ) | ( 0 << WGM11 );
    128e:	88 ea       	ldi	r24, 0xA8	; 168
    1290:	80 93 80 00 	sts	0x0080, r24	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
	TCCR1B = ( 1 << WGM13 ) | ( 0 << CS10 )  | ( 1 << CS12 );
    1294:	84 e1       	ldi	r24, 0x14	; 20
    1296:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x700081>
	TCCR1C = 0;
    129a:	10 92 82 00 	sts	0x0082, r1	; 0x800082 <__TEXT_REGION_LENGTH__+0x700082>
	ICR1 = 622;
    129e:	8e e6       	ldi	r24, 0x6E	; 110
    12a0:	92 e0       	ldi	r25, 0x02	; 2
    12a2:	90 93 87 00 	sts	0x0087, r25	; 0x800087 <__TEXT_REGION_LENGTH__+0x700087>
    12a6:	80 93 86 00 	sts	0x0086, r24	; 0x800086 <__TEXT_REGION_LENGTH__+0x700086>
	
	OCR1A = 0;
    12aa:	10 92 89 00 	sts	0x0089, r1	; 0x800089 <__TEXT_REGION_LENGTH__+0x700089>
    12ae:	10 92 88 00 	sts	0x0088, r1	; 0x800088 <__TEXT_REGION_LENGTH__+0x700088>
	OCR1B = 0;
    12b2:	10 92 8b 00 	sts	0x008B, r1	; 0x80008b <__TEXT_REGION_LENGTH__+0x70008b>
    12b6:	10 92 8a 00 	sts	0x008A, r1	; 0x80008a <__TEXT_REGION_LENGTH__+0x70008a>
	OCR1C = 0;
    12ba:	10 92 8d 00 	sts	0x008D, r1	; 0x80008d <__TEXT_REGION_LENGTH__+0x70008d>
    12be:	10 92 8c 00 	sts	0x008C, r1	; 0x80008c <__TEXT_REGION_LENGTH__+0x70008c>
    12c2:	08 95       	ret

000012c4 <_ZN6Timer116setDutyCycleComAEf>:
}

void Timer1::setDutyCycleComA( float dutyCycle )
{
    12c4:	cf 92       	push	r12
    12c6:	df 92       	push	r13
    12c8:	ef 92       	push	r14
    12ca:	ff 92       	push	r15
    12cc:	6a 01       	movw	r12, r20
    12ce:	7b 01       	movw	r14, r22
	float percent = ICR1/100;
    12d0:	20 91 86 00 	lds	r18, 0x0086	; 0x800086 <__TEXT_REGION_LENGTH__+0x700086>
    12d4:	30 91 87 00 	lds	r19, 0x0087	; 0x800087 <__TEXT_REGION_LENGTH__+0x700087>
    12d8:	36 95       	lsr	r19
    12da:	27 95       	ror	r18
    12dc:	36 95       	lsr	r19
    12de:	27 95       	ror	r18
    12e0:	ab e7       	ldi	r26, 0x7B	; 123
    12e2:	b4 e1       	ldi	r27, 0x14	; 20
    12e4:	0e 94 f4 11 	call	0x23e8	; 0x23e8 <__umulhisi3>
    12e8:	96 95       	lsr	r25
    12ea:	87 95       	ror	r24
	OCR1A = (uint8_t)percent*dutyCycle;
    12ec:	bc 01       	movw	r22, r24
    12ee:	77 27       	eor	r23, r23
    12f0:	07 2e       	mov	r0, r23
    12f2:	00 0c       	add	r0, r0
    12f4:	88 0b       	sbc	r24, r24
    12f6:	99 0b       	sbc	r25, r25
    12f8:	3e d7       	rcall	.+3708   	; 0x2176 <__floatsisf>
    12fa:	a7 01       	movw	r20, r14
    12fc:	96 01       	movw	r18, r12
    12fe:	ef d7       	rcall	.+4062   	; 0x22de <__mulsf3>
    1300:	0c d7       	rcall	.+3608   	; 0x211a <__fixunssfsi>
    1302:	70 93 89 00 	sts	0x0089, r23	; 0x800089 <__TEXT_REGION_LENGTH__+0x700089>
    1306:	60 93 88 00 	sts	0x0088, r22	; 0x800088 <__TEXT_REGION_LENGTH__+0x700088>
}
    130a:	ff 90       	pop	r15
    130c:	ef 90       	pop	r14
    130e:	df 90       	pop	r13
    1310:	cf 90       	pop	r12
    1312:	08 95       	ret

00001314 <_ZN6Timer116setDutyCycleComBEf>:

void Timer1::setDutyCycleComB( float dutyCycle )
{
    1314:	cf 92       	push	r12
    1316:	df 92       	push	r13
    1318:	ef 92       	push	r14
    131a:	ff 92       	push	r15
    131c:	6a 01       	movw	r12, r20
    131e:	7b 01       	movw	r14, r22
	float percent = ICR1/100;
    1320:	20 91 86 00 	lds	r18, 0x0086	; 0x800086 <__TEXT_REGION_LENGTH__+0x700086>
    1324:	30 91 87 00 	lds	r19, 0x0087	; 0x800087 <__TEXT_REGION_LENGTH__+0x700087>
    1328:	36 95       	lsr	r19
    132a:	27 95       	ror	r18
    132c:	36 95       	lsr	r19
    132e:	27 95       	ror	r18
    1330:	ab e7       	ldi	r26, 0x7B	; 123
    1332:	b4 e1       	ldi	r27, 0x14	; 20
    1334:	0e 94 f4 11 	call	0x23e8	; 0x23e8 <__umulhisi3>
    1338:	96 95       	lsr	r25
    133a:	87 95       	ror	r24
	OCR1B = (uint8_t)percent*dutyCycle;
    133c:	bc 01       	movw	r22, r24
    133e:	77 27       	eor	r23, r23
    1340:	07 2e       	mov	r0, r23
    1342:	00 0c       	add	r0, r0
    1344:	88 0b       	sbc	r24, r24
    1346:	99 0b       	sbc	r25, r25
    1348:	16 d7       	rcall	.+3628   	; 0x2176 <__floatsisf>
    134a:	a7 01       	movw	r20, r14
    134c:	96 01       	movw	r18, r12
    134e:	c7 d7       	rcall	.+3982   	; 0x22de <__mulsf3>
    1350:	e4 d6       	rcall	.+3528   	; 0x211a <__fixunssfsi>
    1352:	70 93 8b 00 	sts	0x008B, r23	; 0x80008b <__TEXT_REGION_LENGTH__+0x70008b>
    1356:	60 93 8a 00 	sts	0x008A, r22	; 0x80008a <__TEXT_REGION_LENGTH__+0x70008a>
}
    135a:	ff 90       	pop	r15
    135c:	ef 90       	pop	r14
    135e:	df 90       	pop	r13
    1360:	cf 90       	pop	r12
    1362:	08 95       	ret

00001364 <_ZN6Timer116setDutyCycleComCEf>:

void Timer1::setDutyCycleComC( float dutyCycle )
{
    1364:	cf 92       	push	r12
    1366:	df 92       	push	r13
    1368:	ef 92       	push	r14
    136a:	ff 92       	push	r15
    136c:	6a 01       	movw	r12, r20
    136e:	7b 01       	movw	r14, r22
	float percent = ICR1/100;
    1370:	20 91 86 00 	lds	r18, 0x0086	; 0x800086 <__TEXT_REGION_LENGTH__+0x700086>
    1374:	30 91 87 00 	lds	r19, 0x0087	; 0x800087 <__TEXT_REGION_LENGTH__+0x700087>
    1378:	36 95       	lsr	r19
    137a:	27 95       	ror	r18
    137c:	36 95       	lsr	r19
    137e:	27 95       	ror	r18
    1380:	ab e7       	ldi	r26, 0x7B	; 123
    1382:	b4 e1       	ldi	r27, 0x14	; 20
    1384:	0e 94 f4 11 	call	0x23e8	; 0x23e8 <__umulhisi3>
    1388:	96 95       	lsr	r25
    138a:	87 95       	ror	r24
	OCR1C = (uint8_t)percent*dutyCycle;
    138c:	bc 01       	movw	r22, r24
    138e:	77 27       	eor	r23, r23
    1390:	07 2e       	mov	r0, r23
    1392:	00 0c       	add	r0, r0
    1394:	88 0b       	sbc	r24, r24
    1396:	99 0b       	sbc	r25, r25
    1398:	ee d6       	rcall	.+3548   	; 0x2176 <__floatsisf>
    139a:	a7 01       	movw	r20, r14
    139c:	96 01       	movw	r18, r12
    139e:	9f d7       	rcall	.+3902   	; 0x22de <__mulsf3>
    13a0:	bc d6       	rcall	.+3448   	; 0x211a <__fixunssfsi>
    13a2:	70 93 8d 00 	sts	0x008D, r23	; 0x80008d <__TEXT_REGION_LENGTH__+0x70008d>
    13a6:	60 93 8c 00 	sts	0x008C, r22	; 0x80008c <__TEXT_REGION_LENGTH__+0x70008c>
    13aa:	ff 90       	pop	r15
    13ac:	ef 90       	pop	r14
    13ae:	df 90       	pop	r13
    13b0:	cf 90       	pop	r12
    13b2:	08 95       	ret

000013b4 <_ZN6Timer3C1Ev>:
#include <avr/io.h>

Timer3::Timer3()
{
	// Set B5 to output
	DDRE = DDRE | ( 1 << 3 ) | ( 1 << 4 ) | ( 1 << 5 );
    13b4:	8d b1       	in	r24, 0x0d	; 13
    13b6:	88 63       	ori	r24, 0x38	; 56
    13b8:	8d b9       	out	0x0d, r24	; 13
	
	// Set timer to run in PWM, Phase Correct mode with 50 Hz freq.
	TCCR3A = ( 1 << COM3A1 ) | ( 1 << COM3B1 ) | ( 1 << COM3C1 ) | ( 0 << WGM30 ) | ( 0 << WGM31 );
    13ba:	88 ea       	ldi	r24, 0xA8	; 168
    13bc:	80 93 90 00 	sts	0x0090, r24	; 0x800090 <__TEXT_REGION_LENGTH__+0x700090>
	TCCR3B = ( 1 << WGM33 ) | ( 0 << CS30 )  | ( 1 << CS32 );
    13c0:	84 e1       	ldi	r24, 0x14	; 20
    13c2:	80 93 91 00 	sts	0x0091, r24	; 0x800091 <__TEXT_REGION_LENGTH__+0x700091>
	TCCR3C = 0;
    13c6:	10 92 92 00 	sts	0x0092, r1	; 0x800092 <__TEXT_REGION_LENGTH__+0x700092>
	ICR3 = 622;
    13ca:	8e e6       	ldi	r24, 0x6E	; 110
    13cc:	92 e0       	ldi	r25, 0x02	; 2
    13ce:	90 93 97 00 	sts	0x0097, r25	; 0x800097 <__TEXT_REGION_LENGTH__+0x700097>
    13d2:	80 93 96 00 	sts	0x0096, r24	; 0x800096 <__TEXT_REGION_LENGTH__+0x700096>
	
	OCR3A = 0;
    13d6:	10 92 99 00 	sts	0x0099, r1	; 0x800099 <__TEXT_REGION_LENGTH__+0x700099>
    13da:	10 92 98 00 	sts	0x0098, r1	; 0x800098 <__TEXT_REGION_LENGTH__+0x700098>
	OCR3B = 0;
    13de:	10 92 9b 00 	sts	0x009B, r1	; 0x80009b <__TEXT_REGION_LENGTH__+0x70009b>
    13e2:	10 92 9a 00 	sts	0x009A, r1	; 0x80009a <__TEXT_REGION_LENGTH__+0x70009a>
	OCR3C = 0;
    13e6:	10 92 9d 00 	sts	0x009D, r1	; 0x80009d <__TEXT_REGION_LENGTH__+0x70009d>
    13ea:	10 92 9c 00 	sts	0x009C, r1	; 0x80009c <__TEXT_REGION_LENGTH__+0x70009c>
    13ee:	08 95       	ret

000013f0 <_ZN6Timer316setDutyCycleComAEf>:
}

void Timer3::setDutyCycleComA( float dutyCycle )
{
    13f0:	cf 92       	push	r12
    13f2:	df 92       	push	r13
    13f4:	ef 92       	push	r14
    13f6:	ff 92       	push	r15
    13f8:	6a 01       	movw	r12, r20
    13fa:	7b 01       	movw	r14, r22
	float percent = ICR3/100;
    13fc:	20 91 96 00 	lds	r18, 0x0096	; 0x800096 <__TEXT_REGION_LENGTH__+0x700096>
    1400:	30 91 97 00 	lds	r19, 0x0097	; 0x800097 <__TEXT_REGION_LENGTH__+0x700097>
    1404:	36 95       	lsr	r19
    1406:	27 95       	ror	r18
    1408:	36 95       	lsr	r19
    140a:	27 95       	ror	r18
    140c:	ab e7       	ldi	r26, 0x7B	; 123
    140e:	b4 e1       	ldi	r27, 0x14	; 20
    1410:	eb d7       	rcall	.+4054   	; 0x23e8 <__umulhisi3>
    1412:	96 95       	lsr	r25
    1414:	87 95       	ror	r24
	OCR3A = (uint8_t)percent*dutyCycle;
    1416:	bc 01       	movw	r22, r24
    1418:	77 27       	eor	r23, r23
    141a:	07 2e       	mov	r0, r23
    141c:	00 0c       	add	r0, r0
    141e:	88 0b       	sbc	r24, r24
    1420:	99 0b       	sbc	r25, r25
    1422:	a9 d6       	rcall	.+3410   	; 0x2176 <__floatsisf>
    1424:	a7 01       	movw	r20, r14
    1426:	96 01       	movw	r18, r12
    1428:	5a d7       	rcall	.+3764   	; 0x22de <__mulsf3>
    142a:	77 d6       	rcall	.+3310   	; 0x211a <__fixunssfsi>
    142c:	70 93 99 00 	sts	0x0099, r23	; 0x800099 <__TEXT_REGION_LENGTH__+0x700099>
    1430:	60 93 98 00 	sts	0x0098, r22	; 0x800098 <__TEXT_REGION_LENGTH__+0x700098>
}
    1434:	ff 90       	pop	r15
    1436:	ef 90       	pop	r14
    1438:	df 90       	pop	r13
    143a:	cf 90       	pop	r12
    143c:	08 95       	ret

0000143e <_ZN6Timer316setDutyCycleComBEf>:

void Timer3::setDutyCycleComB( float dutyCycle )
{
    143e:	cf 92       	push	r12
    1440:	df 92       	push	r13
    1442:	ef 92       	push	r14
    1444:	ff 92       	push	r15
    1446:	6a 01       	movw	r12, r20
    1448:	7b 01       	movw	r14, r22
	float percent = ICR3/100;
    144a:	20 91 96 00 	lds	r18, 0x0096	; 0x800096 <__TEXT_REGION_LENGTH__+0x700096>
    144e:	30 91 97 00 	lds	r19, 0x0097	; 0x800097 <__TEXT_REGION_LENGTH__+0x700097>
    1452:	36 95       	lsr	r19
    1454:	27 95       	ror	r18
    1456:	36 95       	lsr	r19
    1458:	27 95       	ror	r18
    145a:	ab e7       	ldi	r26, 0x7B	; 123
    145c:	b4 e1       	ldi	r27, 0x14	; 20
    145e:	c4 d7       	rcall	.+3976   	; 0x23e8 <__umulhisi3>
    1460:	96 95       	lsr	r25
    1462:	87 95       	ror	r24
	OCR3B = (uint8_t)percent*dutyCycle;
    1464:	bc 01       	movw	r22, r24
    1466:	77 27       	eor	r23, r23
    1468:	07 2e       	mov	r0, r23
    146a:	00 0c       	add	r0, r0
    146c:	88 0b       	sbc	r24, r24
    146e:	99 0b       	sbc	r25, r25
    1470:	82 d6       	rcall	.+3332   	; 0x2176 <__floatsisf>
    1472:	a7 01       	movw	r20, r14
    1474:	96 01       	movw	r18, r12
    1476:	33 d7       	rcall	.+3686   	; 0x22de <__mulsf3>
    1478:	50 d6       	rcall	.+3232   	; 0x211a <__fixunssfsi>
    147a:	70 93 9b 00 	sts	0x009B, r23	; 0x80009b <__TEXT_REGION_LENGTH__+0x70009b>
    147e:	60 93 9a 00 	sts	0x009A, r22	; 0x80009a <__TEXT_REGION_LENGTH__+0x70009a>
}
    1482:	ff 90       	pop	r15
    1484:	ef 90       	pop	r14
    1486:	df 90       	pop	r13
    1488:	cf 90       	pop	r12
    148a:	08 95       	ret

0000148c <_ZN6Timer316setDutyCycleComCEf>:

void Timer3::setDutyCycleComC( float dutyCycle )
{
    148c:	cf 92       	push	r12
    148e:	df 92       	push	r13
    1490:	ef 92       	push	r14
    1492:	ff 92       	push	r15
    1494:	6a 01       	movw	r12, r20
    1496:	7b 01       	movw	r14, r22
	float percent = ICR3/100;
    1498:	20 91 96 00 	lds	r18, 0x0096	; 0x800096 <__TEXT_REGION_LENGTH__+0x700096>
    149c:	30 91 97 00 	lds	r19, 0x0097	; 0x800097 <__TEXT_REGION_LENGTH__+0x700097>
    14a0:	36 95       	lsr	r19
    14a2:	27 95       	ror	r18
    14a4:	36 95       	lsr	r19
    14a6:	27 95       	ror	r18
    14a8:	ab e7       	ldi	r26, 0x7B	; 123
    14aa:	b4 e1       	ldi	r27, 0x14	; 20
    14ac:	9d d7       	rcall	.+3898   	; 0x23e8 <__umulhisi3>
    14ae:	96 95       	lsr	r25
    14b0:	87 95       	ror	r24
	OCR3C = (uint8_t)percent*dutyCycle;
    14b2:	bc 01       	movw	r22, r24
    14b4:	77 27       	eor	r23, r23
    14b6:	07 2e       	mov	r0, r23
    14b8:	00 0c       	add	r0, r0
    14ba:	88 0b       	sbc	r24, r24
    14bc:	99 0b       	sbc	r25, r25
    14be:	5b d6       	rcall	.+3254   	; 0x2176 <__floatsisf>
    14c0:	a7 01       	movw	r20, r14
    14c2:	96 01       	movw	r18, r12
    14c4:	0c d7       	rcall	.+3608   	; 0x22de <__mulsf3>
    14c6:	29 d6       	rcall	.+3154   	; 0x211a <__fixunssfsi>
    14c8:	70 93 9d 00 	sts	0x009D, r23	; 0x80009d <__TEXT_REGION_LENGTH__+0x70009d>
    14cc:	60 93 9c 00 	sts	0x009C, r22	; 0x80009c <__TEXT_REGION_LENGTH__+0x70009c>
    14d0:	ff 90       	pop	r15
    14d2:	ef 90       	pop	r14
    14d4:	df 90       	pop	r13
    14d6:	cf 90       	pop	r12
    14d8:	08 95       	ret

000014da <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
    14da:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
    14dc:	03 96       	adiw	r24, 0x03	; 3
    14de:	92 83       	std	Z+2, r25	; 0x02
    14e0:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    14e2:	2f ef       	ldi	r18, 0xFF	; 255
    14e4:	3f ef       	ldi	r19, 0xFF	; 255
    14e6:	34 83       	std	Z+4, r19	; 0x04
    14e8:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
    14ea:	96 83       	std	Z+6, r25	; 0x06
    14ec:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
    14ee:	90 87       	std	Z+8, r25	; 0x08
    14f0:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
    14f2:	10 82       	st	Z, r1
    14f4:	08 95       	ret

000014f6 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    14f6:	fc 01       	movw	r30, r24
    14f8:	11 86       	std	Z+9, r1	; 0x09
    14fa:	10 86       	std	Z+8, r1	; 0x08
    14fc:	08 95       	ret

000014fe <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
    14fe:	cf 93       	push	r28
    1500:	df 93       	push	r29
    1502:	fc 01       	movw	r30, r24
    1504:	db 01       	movw	r26, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
    1506:	21 81       	ldd	r18, Z+1	; 0x01
    1508:	32 81       	ldd	r19, Z+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
    150a:	e9 01       	movw	r28, r18
    150c:	8a 81       	ldd	r24, Y+2	; 0x02
    150e:	9b 81       	ldd	r25, Y+3	; 0x03
    1510:	13 96       	adiw	r26, 0x03	; 3
    1512:	9c 93       	st	X, r25
    1514:	8e 93       	st	-X, r24
    1516:	12 97       	sbiw	r26, 0x02	; 2
	pxNewListItem->pxPrevious = pxList->pxIndex;
    1518:	81 81       	ldd	r24, Z+1	; 0x01
    151a:	92 81       	ldd	r25, Z+2	; 0x02
    151c:	15 96       	adiw	r26, 0x05	; 5
    151e:	9c 93       	st	X, r25
    1520:	8e 93       	st	-X, r24
    1522:	14 97       	sbiw	r26, 0x04	; 4
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    1524:	8a 81       	ldd	r24, Y+2	; 0x02
    1526:	9b 81       	ldd	r25, Y+3	; 0x03
    1528:	ec 01       	movw	r28, r24
    152a:	7d 83       	std	Y+5, r23	; 0x05
    152c:	6c 83       	std	Y+4, r22	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
    152e:	e9 01       	movw	r28, r18
    1530:	7b 83       	std	Y+3, r23	; 0x03
    1532:	6a 83       	std	Y+2, r22	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
    1534:	72 83       	std	Z+2, r23	; 0x02
    1536:	61 83       	std	Z+1, r22	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1538:	19 96       	adiw	r26, 0x09	; 9
    153a:	fc 93       	st	X, r31
    153c:	ee 93       	st	-X, r30
    153e:	18 97       	sbiw	r26, 0x08	; 8

	( pxList->uxNumberOfItems )++;
    1540:	80 81       	ld	r24, Z
    1542:	8f 5f       	subi	r24, 0xFF	; 255
    1544:	80 83       	st	Z, r24
}
    1546:	df 91       	pop	r29
    1548:	cf 91       	pop	r28
    154a:	08 95       	ret

0000154c <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
    154c:	cf 93       	push	r28
    154e:	df 93       	push	r29
    1550:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
    1552:	48 81       	ld	r20, Y
    1554:	59 81       	ldd	r21, Y+1	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    1556:	4f 3f       	cpi	r20, 0xFF	; 255
    1558:	2f ef       	ldi	r18, 0xFF	; 255
    155a:	52 07       	cpc	r21, r18
    155c:	31 f4       	brne	.+12     	; 0x156a <vListInsert+0x1e>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    155e:	dc 01       	movw	r26, r24
    1560:	17 96       	adiw	r26, 0x07	; 7
    1562:	ed 91       	ld	r30, X+
    1564:	fc 91       	ld	r31, X
    1566:	18 97       	sbiw	r26, 0x08	; 8
    1568:	0d c0       	rjmp	.+26     	; 0x1584 <vListInsert+0x38>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    156a:	fc 01       	movw	r30, r24
    156c:	33 96       	adiw	r30, 0x03	; 3
    156e:	03 c0       	rjmp	.+6      	; 0x1576 <vListInsert+0x2a>
    1570:	02 80       	ldd	r0, Z+2	; 0x02
    1572:	f3 81       	ldd	r31, Z+3	; 0x03
    1574:	e0 2d       	mov	r30, r0
    1576:	a2 81       	ldd	r26, Z+2	; 0x02
    1578:	b3 81       	ldd	r27, Z+3	; 0x03
    157a:	2d 91       	ld	r18, X+
    157c:	3c 91       	ld	r19, X
    157e:	42 17       	cp	r20, r18
    1580:	53 07       	cpc	r21, r19
    1582:	b0 f7       	brcc	.-20     	; 0x1570 <vListInsert+0x24>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    1584:	a2 81       	ldd	r26, Z+2	; 0x02
    1586:	b3 81       	ldd	r27, Z+3	; 0x03
    1588:	bb 83       	std	Y+3, r27	; 0x03
    158a:	aa 83       	std	Y+2, r26	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    158c:	15 96       	adiw	r26, 0x05	; 5
    158e:	dc 93       	st	X, r29
    1590:	ce 93       	st	-X, r28
    1592:	14 97       	sbiw	r26, 0x04	; 4
	pxNewListItem->pxPrevious = pxIterator;
    1594:	fd 83       	std	Y+5, r31	; 0x05
    1596:	ec 83       	std	Y+4, r30	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    1598:	d3 83       	std	Z+3, r29	; 0x03
    159a:	c2 83       	std	Z+2, r28	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    159c:	99 87       	std	Y+9, r25	; 0x09
    159e:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    15a0:	fc 01       	movw	r30, r24
    15a2:	20 81       	ld	r18, Z
    15a4:	2f 5f       	subi	r18, 0xFF	; 255
    15a6:	20 83       	st	Z, r18
}
    15a8:	df 91       	pop	r29
    15aa:	cf 91       	pop	r28
    15ac:	08 95       	ret

000015ae <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
    15ae:	fc 01       	movw	r30, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    15b0:	a2 81       	ldd	r26, Z+2	; 0x02
    15b2:	b3 81       	ldd	r27, Z+3	; 0x03
    15b4:	84 81       	ldd	r24, Z+4	; 0x04
    15b6:	95 81       	ldd	r25, Z+5	; 0x05
    15b8:	15 96       	adiw	r26, 0x05	; 5
    15ba:	9c 93       	st	X, r25
    15bc:	8e 93       	st	-X, r24
    15be:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    15c0:	a4 81       	ldd	r26, Z+4	; 0x04
    15c2:	b5 81       	ldd	r27, Z+5	; 0x05
    15c4:	82 81       	ldd	r24, Z+2	; 0x02
    15c6:	93 81       	ldd	r25, Z+3	; 0x03
    15c8:	13 96       	adiw	r26, 0x03	; 3
    15ca:	9c 93       	st	X, r25
    15cc:	8e 93       	st	-X, r24
    15ce:	12 97       	sbiw	r26, 0x02	; 2
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    15d0:	a0 85       	ldd	r26, Z+8	; 0x08
    15d2:	b1 85       	ldd	r27, Z+9	; 0x09

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    15d4:	11 96       	adiw	r26, 0x01	; 1
    15d6:	8d 91       	ld	r24, X+
    15d8:	9c 91       	ld	r25, X
    15da:	12 97       	sbiw	r26, 0x02	; 2
    15dc:	e8 17       	cp	r30, r24
    15de:	f9 07       	cpc	r31, r25
    15e0:	31 f4       	brne	.+12     	; 0x15ee <vListRemove+0x40>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    15e2:	84 81       	ldd	r24, Z+4	; 0x04
    15e4:	95 81       	ldd	r25, Z+5	; 0x05
    15e6:	12 96       	adiw	r26, 0x02	; 2
    15e8:	9c 93       	st	X, r25
    15ea:	8e 93       	st	-X, r24
    15ec:	11 97       	sbiw	r26, 0x01	; 1
	}

	pxItemToRemove->pvContainer = NULL;
    15ee:	11 86       	std	Z+9, r1	; 0x09
    15f0:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    15f2:	8c 91       	ld	r24, X
    15f4:	81 50       	subi	r24, 0x01	; 1
    15f6:	8c 93       	st	X, r24
    15f8:	08 95       	ret

000015fa <prvSetupTimerInterrupt>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    15fa:	10 92 29 01 	sts	0x0129, r1	; 0x800129 <__TEXT_REGION_LENGTH__+0x700129>
    15fe:	89 ef       	ldi	r24, 0xF9	; 249
    1600:	80 93 28 01 	sts	0x0128, r24	; 0x800128 <__TEXT_REGION_LENGTH__+0x700128>
    1604:	8b e0       	ldi	r24, 0x0B	; 11
    1606:	80 93 21 01 	sts	0x0121, r24	; 0x800121 <__TEXT_REGION_LENGTH__+0x700121>
    160a:	e3 e7       	ldi	r30, 0x73	; 115
    160c:	f0 e0       	ldi	r31, 0x00	; 0
    160e:	80 81       	ld	r24, Z
    1610:	82 60       	ori	r24, 0x02	; 2
    1612:	80 83       	st	Z, r24
    1614:	08 95       	ret

00001616 <pxPortInitialiseStack>:
    1616:	31 e1       	ldi	r19, 0x11	; 17
    1618:	fc 01       	movw	r30, r24
    161a:	30 83       	st	Z, r19
    161c:	31 97       	sbiw	r30, 0x01	; 1
    161e:	22 e2       	ldi	r18, 0x22	; 34
    1620:	20 83       	st	Z, r18
    1622:	31 97       	sbiw	r30, 0x01	; 1
    1624:	a3 e3       	ldi	r26, 0x33	; 51
    1626:	a0 83       	st	Z, r26
    1628:	31 97       	sbiw	r30, 0x01	; 1
    162a:	60 83       	st	Z, r22
    162c:	31 97       	sbiw	r30, 0x01	; 1
    162e:	70 83       	st	Z, r23
    1630:	31 97       	sbiw	r30, 0x01	; 1
    1632:	10 82       	st	Z, r1
    1634:	31 97       	sbiw	r30, 0x01	; 1
    1636:	10 82       	st	Z, r1
    1638:	31 97       	sbiw	r30, 0x01	; 1
    163a:	60 e8       	ldi	r22, 0x80	; 128
    163c:	60 83       	st	Z, r22
    163e:	31 97       	sbiw	r30, 0x01	; 1
    1640:	10 82       	st	Z, r1
    1642:	31 97       	sbiw	r30, 0x01	; 1
    1644:	10 82       	st	Z, r1
    1646:	31 97       	sbiw	r30, 0x01	; 1
    1648:	10 82       	st	Z, r1
    164a:	31 97       	sbiw	r30, 0x01	; 1
    164c:	62 e0       	ldi	r22, 0x02	; 2
    164e:	60 83       	st	Z, r22
    1650:	31 97       	sbiw	r30, 0x01	; 1
    1652:	63 e0       	ldi	r22, 0x03	; 3
    1654:	60 83       	st	Z, r22
    1656:	31 97       	sbiw	r30, 0x01	; 1
    1658:	64 e0       	ldi	r22, 0x04	; 4
    165a:	60 83       	st	Z, r22
    165c:	31 97       	sbiw	r30, 0x01	; 1
    165e:	65 e0       	ldi	r22, 0x05	; 5
    1660:	60 83       	st	Z, r22
    1662:	31 97       	sbiw	r30, 0x01	; 1
    1664:	66 e0       	ldi	r22, 0x06	; 6
    1666:	60 83       	st	Z, r22
    1668:	31 97       	sbiw	r30, 0x01	; 1
    166a:	67 e0       	ldi	r22, 0x07	; 7
    166c:	60 83       	st	Z, r22
    166e:	31 97       	sbiw	r30, 0x01	; 1
    1670:	68 e0       	ldi	r22, 0x08	; 8
    1672:	60 83       	st	Z, r22
    1674:	31 97       	sbiw	r30, 0x01	; 1
    1676:	69 e0       	ldi	r22, 0x09	; 9
    1678:	60 83       	st	Z, r22
    167a:	31 97       	sbiw	r30, 0x01	; 1
    167c:	60 e1       	ldi	r22, 0x10	; 16
    167e:	60 83       	st	Z, r22
    1680:	31 97       	sbiw	r30, 0x01	; 1
    1682:	30 83       	st	Z, r19
    1684:	31 97       	sbiw	r30, 0x01	; 1
    1686:	32 e1       	ldi	r19, 0x12	; 18
    1688:	30 83       	st	Z, r19
    168a:	31 97       	sbiw	r30, 0x01	; 1
    168c:	33 e1       	ldi	r19, 0x13	; 19
    168e:	30 83       	st	Z, r19
    1690:	31 97       	sbiw	r30, 0x01	; 1
    1692:	34 e1       	ldi	r19, 0x14	; 20
    1694:	30 83       	st	Z, r19
    1696:	31 97       	sbiw	r30, 0x01	; 1
    1698:	35 e1       	ldi	r19, 0x15	; 21
    169a:	30 83       	st	Z, r19
    169c:	31 97       	sbiw	r30, 0x01	; 1
    169e:	36 e1       	ldi	r19, 0x16	; 22
    16a0:	30 83       	st	Z, r19
    16a2:	31 97       	sbiw	r30, 0x01	; 1
    16a4:	37 e1       	ldi	r19, 0x17	; 23
    16a6:	30 83       	st	Z, r19
    16a8:	31 97       	sbiw	r30, 0x01	; 1
    16aa:	38 e1       	ldi	r19, 0x18	; 24
    16ac:	30 83       	st	Z, r19
    16ae:	31 97       	sbiw	r30, 0x01	; 1
    16b0:	39 e1       	ldi	r19, 0x19	; 25
    16b2:	30 83       	st	Z, r19
    16b4:	31 97       	sbiw	r30, 0x01	; 1
    16b6:	30 e2       	ldi	r19, 0x20	; 32
    16b8:	30 83       	st	Z, r19
    16ba:	31 97       	sbiw	r30, 0x01	; 1
    16bc:	31 e2       	ldi	r19, 0x21	; 33
    16be:	30 83       	st	Z, r19
    16c0:	31 97       	sbiw	r30, 0x01	; 1
    16c2:	20 83       	st	Z, r18
    16c4:	31 97       	sbiw	r30, 0x01	; 1
    16c6:	23 e2       	ldi	r18, 0x23	; 35
    16c8:	20 83       	st	Z, r18
    16ca:	31 97       	sbiw	r30, 0x01	; 1
    16cc:	40 83       	st	Z, r20
    16ce:	31 97       	sbiw	r30, 0x01	; 1
    16d0:	50 83       	st	Z, r21
    16d2:	31 97       	sbiw	r30, 0x01	; 1
    16d4:	26 e2       	ldi	r18, 0x26	; 38
    16d6:	20 83       	st	Z, r18
    16d8:	31 97       	sbiw	r30, 0x01	; 1
    16da:	27 e2       	ldi	r18, 0x27	; 39
    16dc:	20 83       	st	Z, r18
    16de:	31 97       	sbiw	r30, 0x01	; 1
    16e0:	28 e2       	ldi	r18, 0x28	; 40
    16e2:	20 83       	st	Z, r18
    16e4:	31 97       	sbiw	r30, 0x01	; 1
    16e6:	29 e2       	ldi	r18, 0x29	; 41
    16e8:	20 83       	st	Z, r18
    16ea:	31 97       	sbiw	r30, 0x01	; 1
    16ec:	20 e3       	ldi	r18, 0x30	; 48
    16ee:	20 83       	st	Z, r18
    16f0:	31 97       	sbiw	r30, 0x01	; 1
    16f2:	21 e3       	ldi	r18, 0x31	; 49
    16f4:	20 83       	st	Z, r18
    16f6:	89 97       	sbiw	r24, 0x29	; 41
    16f8:	08 95       	ret

000016fa <xPortStartScheduler>:
    16fa:	7f df       	rcall	.-258    	; 0x15fa <prvSetupTimerInterrupt>
    16fc:	a0 91 d9 08 	lds	r26, 0x08D9	; 0x8008d9 <pxCurrentTCB>
    1700:	b0 91 da 08 	lds	r27, 0x08DA	; 0x8008da <pxCurrentTCB+0x1>
    1704:	cd 91       	ld	r28, X+
    1706:	cd bf       	out	0x3d, r28	; 61
    1708:	dd 91       	ld	r29, X+
    170a:	de bf       	out	0x3e, r29	; 62
    170c:	ff 91       	pop	r31
    170e:	ef 91       	pop	r30
    1710:	df 91       	pop	r29
    1712:	cf 91       	pop	r28
    1714:	bf 91       	pop	r27
    1716:	af 91       	pop	r26
    1718:	9f 91       	pop	r25
    171a:	8f 91       	pop	r24
    171c:	7f 91       	pop	r23
    171e:	6f 91       	pop	r22
    1720:	5f 91       	pop	r21
    1722:	4f 91       	pop	r20
    1724:	3f 91       	pop	r19
    1726:	2f 91       	pop	r18
    1728:	1f 91       	pop	r17
    172a:	0f 91       	pop	r16
    172c:	ff 90       	pop	r15
    172e:	ef 90       	pop	r14
    1730:	df 90       	pop	r13
    1732:	cf 90       	pop	r12
    1734:	bf 90       	pop	r11
    1736:	af 90       	pop	r10
    1738:	9f 90       	pop	r9
    173a:	8f 90       	pop	r8
    173c:	7f 90       	pop	r7
    173e:	6f 90       	pop	r6
    1740:	5f 90       	pop	r5
    1742:	4f 90       	pop	r4
    1744:	3f 90       	pop	r3
    1746:	2f 90       	pop	r2
    1748:	1f 90       	pop	r1
    174a:	0f 90       	pop	r0
    174c:	0c be       	out	0x3c, r0	; 60
    174e:	0f 90       	pop	r0
    1750:	0b be       	out	0x3b, r0	; 59
    1752:	0f 90       	pop	r0
    1754:	0f be       	out	0x3f, r0	; 63
    1756:	0f 90       	pop	r0
    1758:	08 95       	ret
    175a:	81 e0       	ldi	r24, 0x01	; 1
    175c:	08 95       	ret

0000175e <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    175e:	0f 92       	push	r0
    1760:	0f b6       	in	r0, 0x3f	; 63
    1762:	f8 94       	cli
    1764:	0f 92       	push	r0
    1766:	0b b6       	in	r0, 0x3b	; 59
    1768:	0f 92       	push	r0
    176a:	0c b6       	in	r0, 0x3c	; 60
    176c:	0f 92       	push	r0
    176e:	1f 92       	push	r1
    1770:	11 24       	eor	r1, r1
    1772:	2f 92       	push	r2
    1774:	3f 92       	push	r3
    1776:	4f 92       	push	r4
    1778:	5f 92       	push	r5
    177a:	6f 92       	push	r6
    177c:	7f 92       	push	r7
    177e:	8f 92       	push	r8
    1780:	9f 92       	push	r9
    1782:	af 92       	push	r10
    1784:	bf 92       	push	r11
    1786:	cf 92       	push	r12
    1788:	df 92       	push	r13
    178a:	ef 92       	push	r14
    178c:	ff 92       	push	r15
    178e:	0f 93       	push	r16
    1790:	1f 93       	push	r17
    1792:	2f 93       	push	r18
    1794:	3f 93       	push	r19
    1796:	4f 93       	push	r20
    1798:	5f 93       	push	r21
    179a:	6f 93       	push	r22
    179c:	7f 93       	push	r23
    179e:	8f 93       	push	r24
    17a0:	9f 93       	push	r25
    17a2:	af 93       	push	r26
    17a4:	bf 93       	push	r27
    17a6:	cf 93       	push	r28
    17a8:	df 93       	push	r29
    17aa:	ef 93       	push	r30
    17ac:	ff 93       	push	r31
    17ae:	a0 91 d9 08 	lds	r26, 0x08D9	; 0x8008d9 <pxCurrentTCB>
    17b2:	b0 91 da 08 	lds	r27, 0x08DA	; 0x8008da <pxCurrentTCB+0x1>
    17b6:	0d b6       	in	r0, 0x3d	; 61
    17b8:	0d 92       	st	X+, r0
    17ba:	0e b6       	in	r0, 0x3e	; 62
    17bc:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    17be:	84 d3       	rcall	.+1800   	; 0x1ec8 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    17c0:	a0 91 d9 08 	lds	r26, 0x08D9	; 0x8008d9 <pxCurrentTCB>
    17c4:	b0 91 da 08 	lds	r27, 0x08DA	; 0x8008da <pxCurrentTCB+0x1>
    17c8:	cd 91       	ld	r28, X+
    17ca:	cd bf       	out	0x3d, r28	; 61
    17cc:	dd 91       	ld	r29, X+
    17ce:	de bf       	out	0x3e, r29	; 62
    17d0:	ff 91       	pop	r31
    17d2:	ef 91       	pop	r30
    17d4:	df 91       	pop	r29
    17d6:	cf 91       	pop	r28
    17d8:	bf 91       	pop	r27
    17da:	af 91       	pop	r26
    17dc:	9f 91       	pop	r25
    17de:	8f 91       	pop	r24
    17e0:	7f 91       	pop	r23
    17e2:	6f 91       	pop	r22
    17e4:	5f 91       	pop	r21
    17e6:	4f 91       	pop	r20
    17e8:	3f 91       	pop	r19
    17ea:	2f 91       	pop	r18
    17ec:	1f 91       	pop	r17
    17ee:	0f 91       	pop	r16
    17f0:	ff 90       	pop	r15
    17f2:	ef 90       	pop	r14
    17f4:	df 90       	pop	r13
    17f6:	cf 90       	pop	r12
    17f8:	bf 90       	pop	r11
    17fa:	af 90       	pop	r10
    17fc:	9f 90       	pop	r9
    17fe:	8f 90       	pop	r8
    1800:	7f 90       	pop	r7
    1802:	6f 90       	pop	r6
    1804:	5f 90       	pop	r5
    1806:	4f 90       	pop	r4
    1808:	3f 90       	pop	r3
    180a:	2f 90       	pop	r2
    180c:	1f 90       	pop	r1
    180e:	0f 90       	pop	r0
    1810:	0c be       	out	0x3c, r0	; 60
    1812:	0f 90       	pop	r0
    1814:	0b be       	out	0x3b, r0	; 59
    1816:	0f 90       	pop	r0
    1818:	0f be       	out	0x3f, r0	; 63
    181a:	0f 90       	pop	r0

	asm volatile ( "ret" );
    181c:	08 95       	ret

0000181e <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    181e:	0f 92       	push	r0
    1820:	0f b6       	in	r0, 0x3f	; 63
    1822:	f8 94       	cli
    1824:	0f 92       	push	r0
    1826:	0b b6       	in	r0, 0x3b	; 59
    1828:	0f 92       	push	r0
    182a:	0c b6       	in	r0, 0x3c	; 60
    182c:	0f 92       	push	r0
    182e:	1f 92       	push	r1
    1830:	11 24       	eor	r1, r1
    1832:	2f 92       	push	r2
    1834:	3f 92       	push	r3
    1836:	4f 92       	push	r4
    1838:	5f 92       	push	r5
    183a:	6f 92       	push	r6
    183c:	7f 92       	push	r7
    183e:	8f 92       	push	r8
    1840:	9f 92       	push	r9
    1842:	af 92       	push	r10
    1844:	bf 92       	push	r11
    1846:	cf 92       	push	r12
    1848:	df 92       	push	r13
    184a:	ef 92       	push	r14
    184c:	ff 92       	push	r15
    184e:	0f 93       	push	r16
    1850:	1f 93       	push	r17
    1852:	2f 93       	push	r18
    1854:	3f 93       	push	r19
    1856:	4f 93       	push	r20
    1858:	5f 93       	push	r21
    185a:	6f 93       	push	r22
    185c:	7f 93       	push	r23
    185e:	8f 93       	push	r24
    1860:	9f 93       	push	r25
    1862:	af 93       	push	r26
    1864:	bf 93       	push	r27
    1866:	cf 93       	push	r28
    1868:	df 93       	push	r29
    186a:	ef 93       	push	r30
    186c:	ff 93       	push	r31
    186e:	a0 91 d9 08 	lds	r26, 0x08D9	; 0x8008d9 <pxCurrentTCB>
    1872:	b0 91 da 08 	lds	r27, 0x08DA	; 0x8008da <pxCurrentTCB+0x1>
    1876:	0d b6       	in	r0, 0x3d	; 61
    1878:	0d 92       	st	X+, r0
    187a:	0e b6       	in	r0, 0x3e	; 62
    187c:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    187e:	ef d1       	rcall	.+990    	; 0x1c5e <vTaskIncrementTick>
	vTaskSwitchContext();
    1880:	23 d3       	rcall	.+1606   	; 0x1ec8 <vTaskSwitchContext>
    1882:	a0 91 d9 08 	lds	r26, 0x08D9	; 0x8008d9 <pxCurrentTCB>
	portRESTORE_CONTEXT();
    1886:	b0 91 da 08 	lds	r27, 0x08DA	; 0x8008da <pxCurrentTCB+0x1>
    188a:	cd 91       	ld	r28, X+
    188c:	cd bf       	out	0x3d, r28	; 61
    188e:	dd 91       	ld	r29, X+
    1890:	de bf       	out	0x3e, r29	; 62
    1892:	ff 91       	pop	r31
    1894:	ef 91       	pop	r30
    1896:	df 91       	pop	r29
    1898:	cf 91       	pop	r28
    189a:	bf 91       	pop	r27
    189c:	af 91       	pop	r26
    189e:	9f 91       	pop	r25
    18a0:	8f 91       	pop	r24
    18a2:	7f 91       	pop	r23
    18a4:	6f 91       	pop	r22
    18a6:	5f 91       	pop	r21
    18a8:	4f 91       	pop	r20
    18aa:	3f 91       	pop	r19
    18ac:	2f 91       	pop	r18
    18ae:	1f 91       	pop	r17
    18b0:	0f 91       	pop	r16
    18b2:	ff 90       	pop	r15
    18b4:	ef 90       	pop	r14
    18b6:	df 90       	pop	r13
    18b8:	cf 90       	pop	r12
    18ba:	bf 90       	pop	r11
    18bc:	af 90       	pop	r10
    18be:	9f 90       	pop	r9
    18c0:	8f 90       	pop	r8
    18c2:	7f 90       	pop	r7
    18c4:	6f 90       	pop	r6
    18c6:	5f 90       	pop	r5
    18c8:	4f 90       	pop	r4
    18ca:	3f 90       	pop	r3
    18cc:	2f 90       	pop	r2
    18ce:	1f 90       	pop	r1
    18d0:	0f 90       	pop	r0
    18d2:	0c be       	out	0x3c, r0	; 60
    18d4:	0f 90       	pop	r0
    18d6:	0b be       	out	0x3b, r0	; 59
    18d8:	0f 90       	pop	r0
    18da:	0f be       	out	0x3f, r0	; 63
    18dc:	0f 90       	pop	r0
    18de:	08 95       	ret

000018e0 <__vector_47>:
	asm volatile ( "ret" );
    18e0:	9e df       	rcall	.-196    	; 0x181e <vPortYieldFromTick>
//	void SIG_OUTPUT_COMPARE1A( void )
	void TIMER5_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER5_COMPA_vect( void )
	{
		vPortYieldFromTick();
		asm volatile ( "reti" );
    18e2:	18 95       	reti

000018e4 <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    18e4:	cf 93       	push	r28
    18e6:	df 93       	push	r29
    18e8:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
    18ea:	b3 d1       	rcall	.+870    	; 0x1c52 <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
    18ec:	20 91 c8 02 	lds	r18, 0x02C8	; 0x8002c8 <xNextFreeByte>
    18f0:	30 91 c9 02 	lds	r19, 0x02C9	; 0x8002c9 <xNextFreeByte+0x1>
    18f4:	c9 01       	movw	r24, r18
    18f6:	8c 0f       	add	r24, r28
    18f8:	9d 1f       	adc	r25, r29
    18fa:	8c 3d       	cpi	r24, 0xDC	; 220
    18fc:	45 e0       	ldi	r20, 0x05	; 5
    18fe:	94 07       	cpc	r25, r20
    1900:	58 f4       	brcc	.+22     	; 0x1918 <pvPortMalloc+0x34>
    1902:	28 17       	cp	r18, r24
    1904:	39 07       	cpc	r19, r25
    1906:	58 f4       	brcc	.+22     	; 0x191e <pvPortMalloc+0x3a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
    1908:	e9 01       	movw	r28, r18
    190a:	c6 53       	subi	r28, 0x36	; 54
    190c:	dd 4f       	sbci	r29, 0xFD	; 253
			xNextFreeByte += xWantedSize;			
    190e:	90 93 c9 02 	sts	0x02C9, r25	; 0x8002c9 <xNextFreeByte+0x1>
    1912:	80 93 c8 02 	sts	0x02C8, r24	; 0x8002c8 <xNextFreeByte>
    1916:	05 c0       	rjmp	.+10     	; 0x1922 <pvPortMalloc+0x3e>
static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL; 
    1918:	c0 e0       	ldi	r28, 0x00	; 0
    191a:	d0 e0       	ldi	r29, 0x00	; 0
    191c:	02 c0       	rjmp	.+4      	; 0x1922 <pvPortMalloc+0x3e>
    191e:	c0 e0       	ldi	r28, 0x00	; 0
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
			xNextFreeByte += xWantedSize;			
		}	
	}
	xTaskResumeAll();
    1920:	d0 e0       	ldi	r29, 0x00	; 0
    1922:	44 d2       	rcall	.+1160   	; 0x1dac <xTaskResumeAll>
		}
	}
	#endif	

	return pvReturn;
}
    1924:	ce 01       	movw	r24, r28
    1926:	df 91       	pop	r29
    1928:	cf 91       	pop	r28
    192a:	08 95       	ret

0000192c <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    192c:	08 95       	ret

0000192e <prvIdleTask>:
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
		}
	}
    192e:	80 91 d0 08 	lds	r24, 0x08D0	; 0x8008d0 <pxReadyTasksLists>
    1932:	82 30       	cpi	r24, 0x02	; 2
    1934:	e0 f3       	brcs	.-8      	; 0x192e <prvIdleTask>
    1936:	13 df       	rcall	.-474    	; 0x175e <vPortYield>
    1938:	fa cf       	rjmp	.-12     	; 0x192e <prvIdleTask>

0000193a <prvAllocateTCBAndStack>:
    193a:	ef 92       	push	r14
    193c:	ff 92       	push	r15
    193e:	0f 93       	push	r16
    1940:	1f 93       	push	r17
    1942:	cf 93       	push	r28
    1944:	df 93       	push	r29
    1946:	7c 01       	movw	r14, r24
    1948:	eb 01       	movw	r28, r22
    194a:	81 e2       	ldi	r24, 0x21	; 33
    194c:	90 e0       	ldi	r25, 0x00	; 0
    194e:	ca df       	rcall	.-108    	; 0x18e4 <pvPortMalloc>
    1950:	8c 01       	movw	r16, r24
    1952:	89 2b       	or	r24, r25
    1954:	a1 f0       	breq	.+40     	; 0x197e <prvAllocateTCBAndStack+0x44>
    1956:	20 97       	sbiw	r28, 0x00	; 0
    1958:	19 f4       	brne	.+6      	; 0x1960 <prvAllocateTCBAndStack+0x26>
    195a:	c7 01       	movw	r24, r14
    195c:	c3 df       	rcall	.-122    	; 0x18e4 <pvPortMalloc>
    195e:	01 c0       	rjmp	.+2      	; 0x1962 <prvAllocateTCBAndStack+0x28>
    1960:	ce 01       	movw	r24, r28
    1962:	f8 01       	movw	r30, r16
    1964:	90 8f       	std	Z+24, r25	; 0x18
    1966:	87 8b       	std	Z+23, r24	; 0x17
    1968:	00 97       	sbiw	r24, 0x00	; 0
    196a:	29 f4       	brne	.+10     	; 0x1976 <prvAllocateTCBAndStack+0x3c>
    196c:	c8 01       	movw	r24, r16
    196e:	de df       	rcall	.-68     	; 0x192c <vPortFree>
    1970:	00 e0       	ldi	r16, 0x00	; 0
    1972:	10 e0       	ldi	r17, 0x00	; 0
    1974:	04 c0       	rjmp	.+8      	; 0x197e <prvAllocateTCBAndStack+0x44>
    1976:	a7 01       	movw	r20, r14
    1978:	65 ea       	ldi	r22, 0xA5	; 165
    197a:	70 e0       	ldi	r23, 0x00	; 0
    197c:	65 d6       	rcall	.+3274   	; 0x2648 <memset>
    197e:	c8 01       	movw	r24, r16
    1980:	df 91       	pop	r29
    1982:	cf 91       	pop	r28
    1984:	1f 91       	pop	r17
    1986:	0f 91       	pop	r16
    1988:	ff 90       	pop	r15
    198a:	ef 90       	pop	r14
    198c:	08 95       	ret

0000198e <prvInitialiseTCBVariables>:
    198e:	1f 93       	push	r17
    1990:	cf 93       	push	r28
    1992:	df 93       	push	r29
    1994:	ec 01       	movw	r28, r24
    1996:	14 2f       	mov	r17, r20
    1998:	48 e0       	ldi	r20, 0x08	; 8
    199a:	50 e0       	ldi	r21, 0x00	; 0
    199c:	49 96       	adiw	r24, 0x19	; 25
    199e:	5b d6       	rcall	.+3254   	; 0x2656 <strncpy>
    19a0:	18 a2       	std	Y+32, r1	; 0x20
    19a2:	11 11       	cpse	r17, r1
    19a4:	10 e0       	ldi	r17, 0x00	; 0
    19a6:	1e 8b       	std	Y+22, r17	; 0x16
    19a8:	ce 01       	movw	r24, r28
    19aa:	02 96       	adiw	r24, 0x02	; 2
    19ac:	a4 dd       	rcall	.-1208   	; 0x14f6 <vListInitialiseItem>
    19ae:	ce 01       	movw	r24, r28
    19b0:	0c 96       	adiw	r24, 0x0c	; 12
    19b2:	a1 dd       	rcall	.-1214   	; 0x14f6 <vListInitialiseItem>
    19b4:	d9 87       	std	Y+9, r29	; 0x09
    19b6:	c8 87       	std	Y+8, r28	; 0x08
    19b8:	81 e0       	ldi	r24, 0x01	; 1
    19ba:	90 e0       	ldi	r25, 0x00	; 0
    19bc:	81 1b       	sub	r24, r17
    19be:	91 09       	sbc	r25, r1
    19c0:	9d 87       	std	Y+13, r25	; 0x0d
    19c2:	8c 87       	std	Y+12, r24	; 0x0c
    19c4:	db 8b       	std	Y+19, r29	; 0x13
    19c6:	ca 8b       	std	Y+18, r28	; 0x12
    19c8:	df 91       	pop	r29
    19ca:	cf 91       	pop	r28
    19cc:	1f 91       	pop	r17
    19ce:	08 95       	ret

000019d0 <prvInitialiseTaskLists>:
    19d0:	cf 93       	push	r28
    19d2:	c0 e0       	ldi	r28, 0x00	; 0
    19d4:	0f c0       	rjmp	.+30     	; 0x19f4 <prvInitialiseTaskLists+0x24>
    19d6:	8c 2f       	mov	r24, r28
    19d8:	90 e0       	ldi	r25, 0x00	; 0
    19da:	9c 01       	movw	r18, r24
    19dc:	22 0f       	add	r18, r18
    19de:	33 1f       	adc	r19, r19
    19e0:	22 0f       	add	r18, r18
    19e2:	33 1f       	adc	r19, r19
    19e4:	22 0f       	add	r18, r18
    19e6:	33 1f       	adc	r19, r19
    19e8:	82 0f       	add	r24, r18
    19ea:	93 1f       	adc	r25, r19
    19ec:	80 53       	subi	r24, 0x30	; 48
    19ee:	97 4f       	sbci	r25, 0xF7	; 247
    19f0:	74 dd       	rcall	.-1304   	; 0x14da <vListInitialise>
    19f2:	cf 5f       	subi	r28, 0xFF	; 255
    19f4:	cc 23       	and	r28, r28
    19f6:	79 f3       	breq	.-34     	; 0x19d6 <prvInitialiseTaskLists+0x6>
    19f8:	87 ec       	ldi	r24, 0xC7	; 199
    19fa:	98 e0       	ldi	r25, 0x08	; 8
    19fc:	6e dd       	rcall	.-1316   	; 0x14da <vListInitialise>
    19fe:	8e eb       	ldi	r24, 0xBE	; 190
    1a00:	98 e0       	ldi	r25, 0x08	; 8
    1a02:	6b dd       	rcall	.-1322   	; 0x14da <vListInitialise>
    1a04:	81 eb       	ldi	r24, 0xB1	; 177
    1a06:	98 e0       	ldi	r25, 0x08	; 8
    1a08:	68 dd       	rcall	.-1328   	; 0x14da <vListInitialise>
    1a0a:	87 ec       	ldi	r24, 0xC7	; 199
    1a0c:	98 e0       	ldi	r25, 0x08	; 8
    1a0e:	90 93 bd 08 	sts	0x08BD, r25	; 0x8008bd <pxDelayedTaskList+0x1>
    1a12:	80 93 bc 08 	sts	0x08BC, r24	; 0x8008bc <pxDelayedTaskList>
    1a16:	8e eb       	ldi	r24, 0xBE	; 190
    1a18:	98 e0       	ldi	r25, 0x08	; 8
    1a1a:	90 93 bb 08 	sts	0x08BB, r25	; 0x8008bb <pxOverflowDelayedTaskList+0x1>
    1a1e:	80 93 ba 08 	sts	0x08BA, r24	; 0x8008ba <pxOverflowDelayedTaskList>
    1a22:	cf 91       	pop	r28
    1a24:	08 95       	ret

00001a26 <prvAddCurrentTaskToDelayedList>:
    1a26:	cf 93       	push	r28
    1a28:	df 93       	push	r29
    1a2a:	ec 01       	movw	r28, r24
    1a2c:	e0 91 d9 08 	lds	r30, 0x08D9	; 0x8008d9 <pxCurrentTCB>
    1a30:	f0 91 da 08 	lds	r31, 0x08DA	; 0x8008da <pxCurrentTCB+0x1>
    1a34:	93 83       	std	Z+3, r25	; 0x03
    1a36:	82 83       	std	Z+2, r24	; 0x02
    1a38:	80 91 ae 08 	lds	r24, 0x08AE	; 0x8008ae <xTickCount>
    1a3c:	90 91 af 08 	lds	r25, 0x08AF	; 0x8008af <xTickCount+0x1>
    1a40:	c8 17       	cp	r28, r24
    1a42:	d9 07       	cpc	r29, r25
    1a44:	60 f4       	brcc	.+24     	; 0x1a5e <prvAddCurrentTaskToDelayedList+0x38>
    1a46:	60 91 d9 08 	lds	r22, 0x08D9	; 0x8008d9 <pxCurrentTCB>
    1a4a:	70 91 da 08 	lds	r23, 0x08DA	; 0x8008da <pxCurrentTCB+0x1>
    1a4e:	80 91 ba 08 	lds	r24, 0x08BA	; 0x8008ba <pxOverflowDelayedTaskList>
    1a52:	90 91 bb 08 	lds	r25, 0x08BB	; 0x8008bb <pxOverflowDelayedTaskList+0x1>
    1a56:	6e 5f       	subi	r22, 0xFE	; 254
    1a58:	7f 4f       	sbci	r23, 0xFF	; 255
    1a5a:	78 dd       	rcall	.-1296   	; 0x154c <vListInsert>
    1a5c:	16 c0       	rjmp	.+44     	; 0x1a8a <prvAddCurrentTaskToDelayedList+0x64>
    1a5e:	60 91 d9 08 	lds	r22, 0x08D9	; 0x8008d9 <pxCurrentTCB>
    1a62:	70 91 da 08 	lds	r23, 0x08DA	; 0x8008da <pxCurrentTCB+0x1>
    1a66:	80 91 bc 08 	lds	r24, 0x08BC	; 0x8008bc <pxDelayedTaskList>
    1a6a:	90 91 bd 08 	lds	r25, 0x08BD	; 0x8008bd <pxDelayedTaskList+0x1>
    1a6e:	6e 5f       	subi	r22, 0xFE	; 254
    1a70:	7f 4f       	sbci	r23, 0xFF	; 255
    1a72:	6c dd       	rcall	.-1320   	; 0x154c <vListInsert>
    1a74:	80 91 0b 02 	lds	r24, 0x020B	; 0x80020b <xNextTaskUnblockTime>
    1a78:	90 91 0c 02 	lds	r25, 0x020C	; 0x80020c <xNextTaskUnblockTime+0x1>
    1a7c:	c8 17       	cp	r28, r24
    1a7e:	d9 07       	cpc	r29, r25
    1a80:	20 f4       	brcc	.+8      	; 0x1a8a <prvAddCurrentTaskToDelayedList+0x64>
    1a82:	d0 93 0c 02 	sts	0x020C, r29	; 0x80020c <xNextTaskUnblockTime+0x1>
    1a86:	c0 93 0b 02 	sts	0x020B, r28	; 0x80020b <xNextTaskUnblockTime>
    1a8a:	df 91       	pop	r29
    1a8c:	cf 91       	pop	r28
    1a8e:	08 95       	ret

00001a90 <xTaskGenericCreate>:
    1a90:	2f 92       	push	r2
    1a92:	3f 92       	push	r3
    1a94:	4f 92       	push	r4
    1a96:	5f 92       	push	r5
    1a98:	7f 92       	push	r7
    1a9a:	8f 92       	push	r8
    1a9c:	9f 92       	push	r9
    1a9e:	af 92       	push	r10
    1aa0:	bf 92       	push	r11
    1aa2:	cf 92       	push	r12
    1aa4:	df 92       	push	r13
    1aa6:	ef 92       	push	r14
    1aa8:	ff 92       	push	r15
    1aaa:	0f 93       	push	r16
    1aac:	1f 93       	push	r17
    1aae:	cf 93       	push	r28
    1ab0:	df 93       	push	r29
    1ab2:	00 d0       	rcall	.+0      	; 0x1ab4 <xTaskGenericCreate+0x24>
    1ab4:	1f 92       	push	r1
    1ab6:	cd b7       	in	r28, 0x3d	; 61
    1ab8:	de b7       	in	r29, 0x3e	; 62
    1aba:	9a 83       	std	Y+2, r25	; 0x02
    1abc:	89 83       	std	Y+1, r24	; 0x01
    1abe:	4b 01       	movw	r8, r22
    1ac0:	5c 83       	std	Y+4, r21	; 0x04
    1ac2:	4b 83       	std	Y+3, r20	; 0x03
    1ac4:	19 01       	movw	r2, r18
    1ac6:	70 2e       	mov	r7, r16
    1ac8:	b6 01       	movw	r22, r12
    1aca:	25 01       	movw	r4, r10
    1acc:	ca 01       	movw	r24, r20
    1ace:	35 df       	rcall	.-406    	; 0x193a <prvAllocateTCBAndStack>
    1ad0:	5c 01       	movw	r10, r24
    1ad2:	00 97       	sbiw	r24, 0x00	; 0
    1ad4:	09 f4       	brne	.+2      	; 0x1ad8 <xTaskGenericCreate+0x48>
    1ad6:	6c c0       	rjmp	.+216    	; 0x1bb0 <xTaskGenericCreate+0x120>
    1ad8:	fc 01       	movw	r30, r24
    1ada:	c7 88       	ldd	r12, Z+23	; 0x17
    1adc:	d0 8c       	ldd	r13, Z+24	; 0x18
    1ade:	8b 81       	ldd	r24, Y+3	; 0x03
    1ae0:	9c 81       	ldd	r25, Y+4	; 0x04
    1ae2:	01 97       	sbiw	r24, 0x01	; 1
    1ae4:	c8 0e       	add	r12, r24
    1ae6:	d9 1e       	adc	r13, r25
    1ae8:	0b 81       	ldd	r16, Y+3	; 0x03
    1aea:	1c 81       	ldd	r17, Y+4	; 0x04
    1aec:	92 01       	movw	r18, r4
    1aee:	47 2d       	mov	r20, r7
    1af0:	b4 01       	movw	r22, r8
    1af2:	c5 01       	movw	r24, r10
    1af4:	4c df       	rcall	.-360    	; 0x198e <prvInitialiseTCBVariables>
    1af6:	a1 01       	movw	r20, r2
    1af8:	69 81       	ldd	r22, Y+1	; 0x01
    1afa:	7a 81       	ldd	r23, Y+2	; 0x02
    1afc:	c6 01       	movw	r24, r12
    1afe:	8b dd       	rcall	.-1258   	; 0x1616 <pxPortInitialiseStack>
    1b00:	f5 01       	movw	r30, r10
    1b02:	91 83       	std	Z+1, r25	; 0x01
    1b04:	80 83       	st	Z, r24
    1b06:	e1 14       	cp	r14, r1
    1b08:	f1 04       	cpc	r15, r1
    1b0a:	19 f0       	breq	.+6      	; 0x1b12 <xTaskGenericCreate+0x82>
    1b0c:	f7 01       	movw	r30, r14
    1b0e:	b1 82       	std	Z+1, r11	; 0x01
    1b10:	a0 82       	st	Z, r10
    1b12:	0f b6       	in	r0, 0x3f	; 63
    1b14:	f8 94       	cli
    1b16:	0f 92       	push	r0
    1b18:	80 91 b0 08 	lds	r24, 0x08B0	; 0x8008b0 <uxCurrentNumberOfTasks>
    1b1c:	8f 5f       	subi	r24, 0xFF	; 255
    1b1e:	80 93 b0 08 	sts	0x08B0, r24	; 0x8008b0 <uxCurrentNumberOfTasks>
    1b22:	80 91 d9 08 	lds	r24, 0x08D9	; 0x8008d9 <pxCurrentTCB>
    1b26:	90 91 da 08 	lds	r25, 0x08DA	; 0x8008da <pxCurrentTCB+0x1>
    1b2a:	89 2b       	or	r24, r25
    1b2c:	51 f4       	brne	.+20     	; 0x1b42 <xTaskGenericCreate+0xb2>
    1b2e:	b0 92 da 08 	sts	0x08DA, r11	; 0x8008da <pxCurrentTCB+0x1>
    1b32:	a0 92 d9 08 	sts	0x08D9, r10	; 0x8008d9 <pxCurrentTCB>
    1b36:	80 91 b0 08 	lds	r24, 0x08B0	; 0x8008b0 <uxCurrentNumberOfTasks>
    1b3a:	81 30       	cpi	r24, 0x01	; 1
    1b3c:	89 f4       	brne	.+34     	; 0x1b60 <xTaskGenericCreate+0xd0>
    1b3e:	48 df       	rcall	.-368    	; 0x19d0 <prvInitialiseTaskLists>
    1b40:	0f c0       	rjmp	.+30     	; 0x1b60 <xTaskGenericCreate+0xd0>
    1b42:	80 91 ab 08 	lds	r24, 0x08AB	; 0x8008ab <xSchedulerRunning>
    1b46:	81 11       	cpse	r24, r1
    1b48:	0b c0       	rjmp	.+22     	; 0x1b60 <xTaskGenericCreate+0xd0>
    1b4a:	e0 91 d9 08 	lds	r30, 0x08D9	; 0x8008d9 <pxCurrentTCB>
    1b4e:	f0 91 da 08 	lds	r31, 0x08DA	; 0x8008da <pxCurrentTCB+0x1>
    1b52:	86 89       	ldd	r24, Z+22	; 0x16
    1b54:	78 16       	cp	r7, r24
    1b56:	20 f0       	brcs	.+8      	; 0x1b60 <xTaskGenericCreate+0xd0>
    1b58:	b0 92 da 08 	sts	0x08DA, r11	; 0x8008da <pxCurrentTCB+0x1>
    1b5c:	a0 92 d9 08 	sts	0x08D9, r10	; 0x8008d9 <pxCurrentTCB>
    1b60:	f5 01       	movw	r30, r10
    1b62:	86 89       	ldd	r24, Z+22	; 0x16
    1b64:	90 91 ad 08 	lds	r25, 0x08AD	; 0x8008ad <uxTopUsedPriority>
    1b68:	98 17       	cp	r25, r24
    1b6a:	10 f4       	brcc	.+4      	; 0x1b70 <xTaskGenericCreate+0xe0>
    1b6c:	80 93 ad 08 	sts	0x08AD, r24	; 0x8008ad <uxTopUsedPriority>
    1b70:	90 91 a6 08 	lds	r25, 0x08A6	; 0x8008a6 <uxTCBNumber>
    1b74:	9f 5f       	subi	r25, 0xFF	; 255
    1b76:	90 93 a6 08 	sts	0x08A6, r25	; 0x8008a6 <uxTCBNumber>
    1b7a:	90 91 ac 08 	lds	r25, 0x08AC	; 0x8008ac <uxTopReadyPriority>
    1b7e:	98 17       	cp	r25, r24
    1b80:	10 f4       	brcc	.+4      	; 0x1b86 <xTaskGenericCreate+0xf6>
    1b82:	80 93 ac 08 	sts	0x08AC, r24	; 0x8008ac <uxTopReadyPriority>
    1b86:	90 e0       	ldi	r25, 0x00	; 0
    1b88:	b5 01       	movw	r22, r10
    1b8a:	6e 5f       	subi	r22, 0xFE	; 254
    1b8c:	7f 4f       	sbci	r23, 0xFF	; 255
    1b8e:	9c 01       	movw	r18, r24
    1b90:	22 0f       	add	r18, r18
    1b92:	33 1f       	adc	r19, r19
    1b94:	22 0f       	add	r18, r18
    1b96:	33 1f       	adc	r19, r19
    1b98:	22 0f       	add	r18, r18
    1b9a:	33 1f       	adc	r19, r19
    1b9c:	82 0f       	add	r24, r18
    1b9e:	93 1f       	adc	r25, r19
    1ba0:	80 53       	subi	r24, 0x30	; 48
    1ba2:	97 4f       	sbci	r25, 0xF7	; 247
    1ba4:	ac dc       	rcall	.-1704   	; 0x14fe <vListInsertEnd>
    1ba6:	0f 90       	pop	r0
    1ba8:	0f be       	out	0x3f, r0	; 63
    1baa:	f1 e0       	ldi	r31, 0x01	; 1
    1bac:	f9 83       	std	Y+1, r31	; 0x01
    1bae:	02 c0       	rjmp	.+4      	; 0x1bb4 <xTaskGenericCreate+0x124>
    1bb0:	8f ef       	ldi	r24, 0xFF	; 255
    1bb2:	89 83       	std	Y+1, r24	; 0x01
    1bb4:	e9 81       	ldd	r30, Y+1	; 0x01
    1bb6:	e1 30       	cpi	r30, 0x01	; 1
    1bb8:	61 f4       	brne	.+24     	; 0x1bd2 <xTaskGenericCreate+0x142>
    1bba:	80 91 ab 08 	lds	r24, 0x08AB	; 0x8008ab <xSchedulerRunning>
    1bbe:	88 23       	and	r24, r24
    1bc0:	41 f0       	breq	.+16     	; 0x1bd2 <xTaskGenericCreate+0x142>
    1bc2:	e0 91 d9 08 	lds	r30, 0x08D9	; 0x8008d9 <pxCurrentTCB>
    1bc6:	f0 91 da 08 	lds	r31, 0x08DA	; 0x8008da <pxCurrentTCB+0x1>
    1bca:	86 89       	ldd	r24, Z+22	; 0x16
    1bcc:	87 15       	cp	r24, r7
    1bce:	08 f4       	brcc	.+2      	; 0x1bd2 <xTaskGenericCreate+0x142>
    1bd0:	c6 dd       	rcall	.-1140   	; 0x175e <vPortYield>
    1bd2:	89 81       	ldd	r24, Y+1	; 0x01
    1bd4:	0f 90       	pop	r0
    1bd6:	0f 90       	pop	r0
    1bd8:	0f 90       	pop	r0
    1bda:	0f 90       	pop	r0
    1bdc:	df 91       	pop	r29
    1bde:	cf 91       	pop	r28
    1be0:	1f 91       	pop	r17
    1be2:	0f 91       	pop	r16
    1be4:	ff 90       	pop	r15
    1be6:	ef 90       	pop	r14
    1be8:	df 90       	pop	r13
    1bea:	cf 90       	pop	r12
    1bec:	bf 90       	pop	r11
    1bee:	af 90       	pop	r10
    1bf0:	9f 90       	pop	r9
    1bf2:	8f 90       	pop	r8
    1bf4:	7f 90       	pop	r7
    1bf6:	5f 90       	pop	r5
    1bf8:	4f 90       	pop	r4
    1bfa:	3f 90       	pop	r3
    1bfc:	2f 90       	pop	r2
    1bfe:	08 95       	ret

00001c00 <vTaskStartScheduler>:
    1c00:	af 92       	push	r10
    1c02:	bf 92       	push	r11
    1c04:	cf 92       	push	r12
    1c06:	df 92       	push	r13
    1c08:	ef 92       	push	r14
    1c0a:	ff 92       	push	r15
    1c0c:	0f 93       	push	r16
    1c0e:	a1 2c       	mov	r10, r1
    1c10:	b1 2c       	mov	r11, r1
    1c12:	c1 2c       	mov	r12, r1
    1c14:	d1 2c       	mov	r13, r1
    1c16:	e1 2c       	mov	r14, r1
    1c18:	f1 2c       	mov	r15, r1
    1c1a:	00 e0       	ldi	r16, 0x00	; 0
    1c1c:	20 e0       	ldi	r18, 0x00	; 0
    1c1e:	30 e0       	ldi	r19, 0x00	; 0
    1c20:	45 e5       	ldi	r20, 0x55	; 85
    1c22:	50 e0       	ldi	r21, 0x00	; 0
    1c24:	68 eb       	ldi	r22, 0xB8	; 184
    1c26:	72 e0       	ldi	r23, 0x02	; 2
    1c28:	87 e9       	ldi	r24, 0x97	; 151
    1c2a:	9c e0       	ldi	r25, 0x0C	; 12
    1c2c:	31 df       	rcall	.-414    	; 0x1a90 <xTaskGenericCreate>
    1c2e:	81 30       	cpi	r24, 0x01	; 1
    1c30:	41 f4       	brne	.+16     	; 0x1c42 <vTaskStartScheduler+0x42>
    1c32:	f8 94       	cli
    1c34:	80 93 ab 08 	sts	0x08AB, r24	; 0x8008ab <xSchedulerRunning>
    1c38:	10 92 af 08 	sts	0x08AF, r1	; 0x8008af <xTickCount+0x1>
    1c3c:	10 92 ae 08 	sts	0x08AE, r1	; 0x8008ae <xTickCount>
    1c40:	5c dd       	rcall	.-1352   	; 0x16fa <xPortStartScheduler>
    1c42:	0f 91       	pop	r16
    1c44:	ff 90       	pop	r15
    1c46:	ef 90       	pop	r14
    1c48:	df 90       	pop	r13
    1c4a:	cf 90       	pop	r12
    1c4c:	bf 90       	pop	r11
    1c4e:	af 90       	pop	r10
    1c50:	08 95       	ret

00001c52 <vTaskSuspendAll>:
    1c52:	80 91 aa 08 	lds	r24, 0x08AA	; 0x8008aa <uxSchedulerSuspended>
    1c56:	8f 5f       	subi	r24, 0xFF	; 255
    1c58:	80 93 aa 08 	sts	0x08AA, r24	; 0x8008aa <uxSchedulerSuspended>
    1c5c:	08 95       	ret

00001c5e <vTaskIncrementTick>:
    1c5e:	0f 93       	push	r16
    1c60:	1f 93       	push	r17
    1c62:	cf 93       	push	r28
    1c64:	df 93       	push	r29
    1c66:	80 91 aa 08 	lds	r24, 0x08AA	; 0x8008aa <uxSchedulerSuspended>
    1c6a:	81 11       	cpse	r24, r1
    1c6c:	95 c0       	rjmp	.+298    	; 0x1d98 <vTaskIncrementTick+0x13a>
    1c6e:	80 91 ae 08 	lds	r24, 0x08AE	; 0x8008ae <xTickCount>
    1c72:	90 91 af 08 	lds	r25, 0x08AF	; 0x8008af <xTickCount+0x1>
    1c76:	01 96       	adiw	r24, 0x01	; 1
    1c78:	90 93 af 08 	sts	0x08AF, r25	; 0x8008af <xTickCount+0x1>
    1c7c:	80 93 ae 08 	sts	0x08AE, r24	; 0x8008ae <xTickCount>
    1c80:	80 91 ae 08 	lds	r24, 0x08AE	; 0x8008ae <xTickCount>
    1c84:	90 91 af 08 	lds	r25, 0x08AF	; 0x8008af <xTickCount+0x1>
    1c88:	89 2b       	or	r24, r25
    1c8a:	99 f5       	brne	.+102    	; 0x1cf2 <vTaskIncrementTick+0x94>
    1c8c:	80 91 bc 08 	lds	r24, 0x08BC	; 0x8008bc <pxDelayedTaskList>
    1c90:	90 91 bd 08 	lds	r25, 0x08BD	; 0x8008bd <pxDelayedTaskList+0x1>
    1c94:	20 91 ba 08 	lds	r18, 0x08BA	; 0x8008ba <pxOverflowDelayedTaskList>
    1c98:	30 91 bb 08 	lds	r19, 0x08BB	; 0x8008bb <pxOverflowDelayedTaskList+0x1>
    1c9c:	30 93 bd 08 	sts	0x08BD, r19	; 0x8008bd <pxDelayedTaskList+0x1>
    1ca0:	20 93 bc 08 	sts	0x08BC, r18	; 0x8008bc <pxDelayedTaskList>
    1ca4:	90 93 bb 08 	sts	0x08BB, r25	; 0x8008bb <pxOverflowDelayedTaskList+0x1>
    1ca8:	80 93 ba 08 	sts	0x08BA, r24	; 0x8008ba <pxOverflowDelayedTaskList>
    1cac:	80 91 a7 08 	lds	r24, 0x08A7	; 0x8008a7 <xNumOfOverflows>
    1cb0:	8f 5f       	subi	r24, 0xFF	; 255
    1cb2:	80 93 a7 08 	sts	0x08A7, r24	; 0x8008a7 <xNumOfOverflows>
    1cb6:	e0 91 bc 08 	lds	r30, 0x08BC	; 0x8008bc <pxDelayedTaskList>
    1cba:	f0 91 bd 08 	lds	r31, 0x08BD	; 0x8008bd <pxDelayedTaskList+0x1>
    1cbe:	80 81       	ld	r24, Z
    1cc0:	81 11       	cpse	r24, r1
    1cc2:	07 c0       	rjmp	.+14     	; 0x1cd2 <vTaskIncrementTick+0x74>
    1cc4:	8f ef       	ldi	r24, 0xFF	; 255
    1cc6:	9f ef       	ldi	r25, 0xFF	; 255
    1cc8:	90 93 0c 02 	sts	0x020C, r25	; 0x80020c <xNextTaskUnblockTime+0x1>
    1ccc:	80 93 0b 02 	sts	0x020B, r24	; 0x80020b <xNextTaskUnblockTime>
    1cd0:	10 c0       	rjmp	.+32     	; 0x1cf2 <vTaskIncrementTick+0x94>
    1cd2:	e0 91 bc 08 	lds	r30, 0x08BC	; 0x8008bc <pxDelayedTaskList>
    1cd6:	f0 91 bd 08 	lds	r31, 0x08BD	; 0x8008bd <pxDelayedTaskList+0x1>
    1cda:	05 80       	ldd	r0, Z+5	; 0x05
    1cdc:	f6 81       	ldd	r31, Z+6	; 0x06
    1cde:	e0 2d       	mov	r30, r0
    1ce0:	06 80       	ldd	r0, Z+6	; 0x06
    1ce2:	f7 81       	ldd	r31, Z+7	; 0x07
    1ce4:	e0 2d       	mov	r30, r0
    1ce6:	82 81       	ldd	r24, Z+2	; 0x02
    1ce8:	93 81       	ldd	r25, Z+3	; 0x03
    1cea:	90 93 0c 02 	sts	0x020C, r25	; 0x80020c <xNextTaskUnblockTime+0x1>
    1cee:	80 93 0b 02 	sts	0x020B, r24	; 0x80020b <xNextTaskUnblockTime>
    1cf2:	20 91 ae 08 	lds	r18, 0x08AE	; 0x8008ae <xTickCount>
    1cf6:	30 91 af 08 	lds	r19, 0x08AF	; 0x8008af <xTickCount+0x1>
    1cfa:	80 91 0b 02 	lds	r24, 0x020B	; 0x80020b <xNextTaskUnblockTime>
    1cfe:	90 91 0c 02 	lds	r25, 0x020C	; 0x80020c <xNextTaskUnblockTime+0x1>
    1d02:	28 17       	cp	r18, r24
    1d04:	39 07       	cpc	r19, r25
    1d06:	08 f4       	brcc	.+2      	; 0x1d0a <vTaskIncrementTick+0xac>
    1d08:	4c c0       	rjmp	.+152    	; 0x1da2 <vTaskIncrementTick+0x144>
    1d0a:	e0 91 bc 08 	lds	r30, 0x08BC	; 0x8008bc <pxDelayedTaskList>
    1d0e:	f0 91 bd 08 	lds	r31, 0x08BD	; 0x8008bd <pxDelayedTaskList+0x1>
    1d12:	80 81       	ld	r24, Z
    1d14:	81 11       	cpse	r24, r1
    1d16:	07 c0       	rjmp	.+14     	; 0x1d26 <vTaskIncrementTick+0xc8>
    1d18:	8f ef       	ldi	r24, 0xFF	; 255
    1d1a:	9f ef       	ldi	r25, 0xFF	; 255
    1d1c:	90 93 0c 02 	sts	0x020C, r25	; 0x80020c <xNextTaskUnblockTime+0x1>
    1d20:	80 93 0b 02 	sts	0x020B, r24	; 0x80020b <xNextTaskUnblockTime>
    1d24:	3e c0       	rjmp	.+124    	; 0x1da2 <vTaskIncrementTick+0x144>
    1d26:	e0 91 bc 08 	lds	r30, 0x08BC	; 0x8008bc <pxDelayedTaskList>
    1d2a:	f0 91 bd 08 	lds	r31, 0x08BD	; 0x8008bd <pxDelayedTaskList+0x1>
    1d2e:	05 80       	ldd	r0, Z+5	; 0x05
    1d30:	f6 81       	ldd	r31, Z+6	; 0x06
    1d32:	e0 2d       	mov	r30, r0
    1d34:	c6 81       	ldd	r28, Z+6	; 0x06
    1d36:	d7 81       	ldd	r29, Z+7	; 0x07
    1d38:	8a 81       	ldd	r24, Y+2	; 0x02
    1d3a:	9b 81       	ldd	r25, Y+3	; 0x03
    1d3c:	20 91 ae 08 	lds	r18, 0x08AE	; 0x8008ae <xTickCount>
    1d40:	30 91 af 08 	lds	r19, 0x08AF	; 0x8008af <xTickCount+0x1>
    1d44:	28 17       	cp	r18, r24
    1d46:	39 07       	cpc	r19, r25
    1d48:	28 f4       	brcc	.+10     	; 0x1d54 <vTaskIncrementTick+0xf6>
    1d4a:	90 93 0c 02 	sts	0x020C, r25	; 0x80020c <xNextTaskUnblockTime+0x1>
    1d4e:	80 93 0b 02 	sts	0x020B, r24	; 0x80020b <xNextTaskUnblockTime>
    1d52:	27 c0       	rjmp	.+78     	; 0x1da2 <vTaskIncrementTick+0x144>
    1d54:	8e 01       	movw	r16, r28
    1d56:	0e 5f       	subi	r16, 0xFE	; 254
    1d58:	1f 4f       	sbci	r17, 0xFF	; 255
    1d5a:	c8 01       	movw	r24, r16
    1d5c:	28 dc       	rcall	.-1968   	; 0x15ae <vListRemove>
    1d5e:	8c 89       	ldd	r24, Y+20	; 0x14
    1d60:	9d 89       	ldd	r25, Y+21	; 0x15
    1d62:	89 2b       	or	r24, r25
    1d64:	19 f0       	breq	.+6      	; 0x1d6c <vTaskIncrementTick+0x10e>
    1d66:	ce 01       	movw	r24, r28
    1d68:	0c 96       	adiw	r24, 0x0c	; 12
    1d6a:	21 dc       	rcall	.-1982   	; 0x15ae <vListRemove>
    1d6c:	8e 89       	ldd	r24, Y+22	; 0x16
    1d6e:	90 91 ac 08 	lds	r25, 0x08AC	; 0x8008ac <uxTopReadyPriority>
    1d72:	98 17       	cp	r25, r24
    1d74:	10 f4       	brcc	.+4      	; 0x1d7a <vTaskIncrementTick+0x11c>
    1d76:	80 93 ac 08 	sts	0x08AC, r24	; 0x8008ac <uxTopReadyPriority>
    1d7a:	90 e0       	ldi	r25, 0x00	; 0
    1d7c:	9c 01       	movw	r18, r24
    1d7e:	22 0f       	add	r18, r18
    1d80:	33 1f       	adc	r19, r19
    1d82:	22 0f       	add	r18, r18
    1d84:	33 1f       	adc	r19, r19
    1d86:	22 0f       	add	r18, r18
    1d88:	33 1f       	adc	r19, r19
    1d8a:	82 0f       	add	r24, r18
    1d8c:	93 1f       	adc	r25, r19
    1d8e:	b8 01       	movw	r22, r16
    1d90:	80 53       	subi	r24, 0x30	; 48
    1d92:	97 4f       	sbci	r25, 0xF7	; 247
    1d94:	b4 db       	rcall	.-2200   	; 0x14fe <vListInsertEnd>
    1d96:	b9 cf       	rjmp	.-142    	; 0x1d0a <vTaskIncrementTick+0xac>
    1d98:	80 91 a9 08 	lds	r24, 0x08A9	; 0x8008a9 <uxMissedTicks>
    1d9c:	8f 5f       	subi	r24, 0xFF	; 255
    1d9e:	80 93 a9 08 	sts	0x08A9, r24	; 0x8008a9 <uxMissedTicks>
    1da2:	df 91       	pop	r29
    1da4:	cf 91       	pop	r28
    1da6:	1f 91       	pop	r17
    1da8:	0f 91       	pop	r16
    1daa:	08 95       	ret

00001dac <xTaskResumeAll>:
    1dac:	ff 92       	push	r15
    1dae:	0f 93       	push	r16
    1db0:	1f 93       	push	r17
    1db2:	cf 93       	push	r28
    1db4:	df 93       	push	r29
    1db6:	0f b6       	in	r0, 0x3f	; 63
    1db8:	f8 94       	cli
    1dba:	0f 92       	push	r0
    1dbc:	80 91 aa 08 	lds	r24, 0x08AA	; 0x8008aa <uxSchedulerSuspended>
    1dc0:	81 50       	subi	r24, 0x01	; 1
    1dc2:	80 93 aa 08 	sts	0x08AA, r24	; 0x8008aa <uxSchedulerSuspended>
    1dc6:	80 91 aa 08 	lds	r24, 0x08AA	; 0x8008aa <uxSchedulerSuspended>
    1dca:	81 11       	cpse	r24, r1
    1dcc:	55 c0       	rjmp	.+170    	; 0x1e78 <xTaskResumeAll+0xcc>
    1dce:	80 91 b0 08 	lds	r24, 0x08B0	; 0x8008b0 <uxCurrentNumberOfTasks>
    1dd2:	81 11       	cpse	r24, r1
    1dd4:	2f c0       	rjmp	.+94     	; 0x1e34 <xTaskResumeAll+0x88>
    1dd6:	53 c0       	rjmp	.+166    	; 0x1e7e <xTaskResumeAll+0xd2>
    1dd8:	e0 91 b6 08 	lds	r30, 0x08B6	; 0x8008b6 <xPendingReadyList+0x5>
    1ddc:	f0 91 b7 08 	lds	r31, 0x08B7	; 0x8008b7 <xPendingReadyList+0x6>
    1de0:	c6 81       	ldd	r28, Z+6	; 0x06
    1de2:	d7 81       	ldd	r29, Z+7	; 0x07
    1de4:	ce 01       	movw	r24, r28
    1de6:	0c 96       	adiw	r24, 0x0c	; 12
    1de8:	e2 db       	rcall	.-2108   	; 0x15ae <vListRemove>
    1dea:	8e 01       	movw	r16, r28
    1dec:	0e 5f       	subi	r16, 0xFE	; 254
    1dee:	1f 4f       	sbci	r17, 0xFF	; 255
    1df0:	c8 01       	movw	r24, r16
    1df2:	dd db       	rcall	.-2118   	; 0x15ae <vListRemove>
    1df4:	8e 89       	ldd	r24, Y+22	; 0x16
    1df6:	90 91 ac 08 	lds	r25, 0x08AC	; 0x8008ac <uxTopReadyPriority>
    1dfa:	98 17       	cp	r25, r24
    1dfc:	10 f4       	brcc	.+4      	; 0x1e02 <xTaskResumeAll+0x56>
    1dfe:	80 93 ac 08 	sts	0x08AC, r24	; 0x8008ac <uxTopReadyPriority>
    1e02:	90 e0       	ldi	r25, 0x00	; 0
    1e04:	9c 01       	movw	r18, r24
    1e06:	22 0f       	add	r18, r18
    1e08:	33 1f       	adc	r19, r19
    1e0a:	22 0f       	add	r18, r18
    1e0c:	33 1f       	adc	r19, r19
    1e0e:	22 0f       	add	r18, r18
    1e10:	33 1f       	adc	r19, r19
    1e12:	82 0f       	add	r24, r18
    1e14:	93 1f       	adc	r25, r19
    1e16:	b8 01       	movw	r22, r16
    1e18:	80 53       	subi	r24, 0x30	; 48
    1e1a:	97 4f       	sbci	r25, 0xF7	; 247
    1e1c:	70 db       	rcall	.-2336   	; 0x14fe <vListInsertEnd>
    1e1e:	9e 89       	ldd	r25, Y+22	; 0x16
    1e20:	e0 91 d9 08 	lds	r30, 0x08D9	; 0x8008d9 <pxCurrentTCB>
    1e24:	f0 91 da 08 	lds	r31, 0x08DA	; 0x8008da <pxCurrentTCB+0x1>
    1e28:	86 89       	ldd	r24, Z+22	; 0x16
    1e2a:	98 17       	cp	r25, r24
    1e2c:	20 f0       	brcs	.+8      	; 0x1e36 <xTaskResumeAll+0x8a>
    1e2e:	ff 24       	eor	r15, r15
    1e30:	f3 94       	inc	r15
    1e32:	01 c0       	rjmp	.+2      	; 0x1e36 <xTaskResumeAll+0x8a>
    1e34:	f1 2c       	mov	r15, r1
    1e36:	80 91 b1 08 	lds	r24, 0x08B1	; 0x8008b1 <xPendingReadyList>
    1e3a:	81 11       	cpse	r24, r1
    1e3c:	cd cf       	rjmp	.-102    	; 0x1dd8 <xTaskResumeAll+0x2c>
    1e3e:	80 91 a9 08 	lds	r24, 0x08A9	; 0x8008a9 <uxMissedTicks>
    1e42:	81 11       	cpse	r24, r1
    1e44:	07 c0       	rjmp	.+14     	; 0x1e54 <xTaskResumeAll+0xa8>
    1e46:	0c c0       	rjmp	.+24     	; 0x1e60 <xTaskResumeAll+0xb4>
    1e48:	0a df       	rcall	.-492    	; 0x1c5e <vTaskIncrementTick>
    1e4a:	80 91 a9 08 	lds	r24, 0x08A9	; 0x8008a9 <uxMissedTicks>
    1e4e:	81 50       	subi	r24, 0x01	; 1
    1e50:	80 93 a9 08 	sts	0x08A9, r24	; 0x8008a9 <uxMissedTicks>
    1e54:	80 91 a9 08 	lds	r24, 0x08A9	; 0x8008a9 <uxMissedTicks>
    1e58:	81 11       	cpse	r24, r1
    1e5a:	f6 cf       	rjmp	.-20     	; 0x1e48 <xTaskResumeAll+0x9c>
    1e5c:	ff 24       	eor	r15, r15
    1e5e:	f3 94       	inc	r15
    1e60:	81 e0       	ldi	r24, 0x01	; 1
    1e62:	f8 16       	cp	r15, r24
    1e64:	21 f0       	breq	.+8      	; 0x1e6e <xTaskResumeAll+0xc2>
    1e66:	80 91 a8 08 	lds	r24, 0x08A8	; 0x8008a8 <xMissedYield>
    1e6a:	81 30       	cpi	r24, 0x01	; 1
    1e6c:	39 f4       	brne	.+14     	; 0x1e7c <xTaskResumeAll+0xd0>
    1e6e:	10 92 a8 08 	sts	0x08A8, r1	; 0x8008a8 <xMissedYield>
    1e72:	75 dc       	rcall	.-1814   	; 0x175e <vPortYield>
    1e74:	81 e0       	ldi	r24, 0x01	; 1
    1e76:	03 c0       	rjmp	.+6      	; 0x1e7e <xTaskResumeAll+0xd2>
    1e78:	80 e0       	ldi	r24, 0x00	; 0
    1e7a:	01 c0       	rjmp	.+2      	; 0x1e7e <xTaskResumeAll+0xd2>
    1e7c:	80 e0       	ldi	r24, 0x00	; 0
    1e7e:	0f 90       	pop	r0
    1e80:	0f be       	out	0x3f, r0	; 63
    1e82:	df 91       	pop	r29
    1e84:	cf 91       	pop	r28
    1e86:	1f 91       	pop	r17
    1e88:	0f 91       	pop	r16
    1e8a:	ff 90       	pop	r15
    1e8c:	08 95       	ret

00001e8e <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    1e8e:	cf 93       	push	r28
    1e90:	df 93       	push	r29
    1e92:	ec 01       	movw	r28, r24
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    1e94:	89 2b       	or	r24, r25
    1e96:	89 f0       	breq	.+34     	; 0x1eba <vTaskDelay+0x2c>
		{
			vTaskSuspendAll();
    1e98:	dc de       	rcall	.-584    	; 0x1c52 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    1e9a:	80 91 ae 08 	lds	r24, 0x08AE	; 0x8008ae <xTickCount>
    1e9e:	90 91 af 08 	lds	r25, 0x08AF	; 0x8008af <xTickCount+0x1>
    1ea2:	c8 0f       	add	r28, r24
    1ea4:	d9 1f       	adc	r29, r25

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1ea6:	80 91 d9 08 	lds	r24, 0x08D9	; 0x8008d9 <pxCurrentTCB>
    1eaa:	90 91 da 08 	lds	r25, 0x08DA	; 0x8008da <pxCurrentTCB+0x1>
    1eae:	02 96       	adiw	r24, 0x02	; 2
    1eb0:	7e db       	rcall	.-2308   	; 0x15ae <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    1eb2:	ce 01       	movw	r24, r28
    1eb4:	b8 dd       	rcall	.-1168   	; 0x1a26 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    1eb6:	7a df       	rcall	.-268    	; 0x1dac <xTaskResumeAll>
    1eb8:	01 c0       	rjmp	.+2      	; 0x1ebc <vTaskDelay+0x2e>
#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    1eba:	80 e0       	ldi	r24, 0x00	; 0
			xAlreadyYielded = xTaskResumeAll();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    1ebc:	81 11       	cpse	r24, r1
    1ebe:	01 c0       	rjmp	.+2      	; 0x1ec2 <vTaskDelay+0x34>
		{
			portYIELD_WITHIN_API();
    1ec0:	4e dc       	rcall	.-1892   	; 0x175e <vPortYield>
    1ec2:	df 91       	pop	r29
		}
	}
    1ec4:	cf 91       	pop	r28
    1ec6:	08 95       	ret

00001ec8 <vTaskSwitchContext>:
    1ec8:	80 91 aa 08 	lds	r24, 0x08AA	; 0x8008aa <uxSchedulerSuspended>
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    1ecc:	88 23       	and	r24, r24
    1ece:	49 f0       	breq	.+18     	; 0x1ee2 <vTaskSwitchContext+0x1a>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    1ed0:	81 e0       	ldi	r24, 0x01	; 1
    1ed2:	80 93 a8 08 	sts	0x08A8, r24	; 0x8008a8 <xMissedYield>
    1ed6:	08 95       	ret
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    1ed8:	80 91 ac 08 	lds	r24, 0x08AC	; 0x8008ac <uxTopReadyPriority>
    1edc:	81 50       	subi	r24, 0x01	; 1
    1ede:	80 93 ac 08 	sts	0x08AC, r24	; 0x8008ac <uxTopReadyPriority>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    1ee2:	80 91 ac 08 	lds	r24, 0x08AC	; 0x8008ac <uxTopReadyPriority>
    1ee6:	90 e0       	ldi	r25, 0x00	; 0
    1ee8:	fc 01       	movw	r30, r24
    1eea:	ee 0f       	add	r30, r30
    1eec:	ff 1f       	adc	r31, r31
    1eee:	ee 0f       	add	r30, r30
    1ef0:	ff 1f       	adc	r31, r31
    1ef2:	ee 0f       	add	r30, r30
    1ef4:	ff 1f       	adc	r31, r31
    1ef6:	8e 0f       	add	r24, r30
    1ef8:	9f 1f       	adc	r25, r31
    1efa:	fc 01       	movw	r30, r24
    1efc:	e0 53       	subi	r30, 0x30	; 48
    1efe:	f7 4f       	sbci	r31, 0xF7	; 247
    1f00:	80 81       	ld	r24, Z
    1f02:	88 23       	and	r24, r24
    1f04:	49 f3       	breq	.-46     	; 0x1ed8 <vTaskSwitchContext+0x10>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    1f06:	80 91 ac 08 	lds	r24, 0x08AC	; 0x8008ac <uxTopReadyPriority>
    1f0a:	90 e0       	ldi	r25, 0x00	; 0
    1f0c:	9c 01       	movw	r18, r24
    1f0e:	22 0f       	add	r18, r18
    1f10:	33 1f       	adc	r19, r19
    1f12:	22 0f       	add	r18, r18
    1f14:	33 1f       	adc	r19, r19
    1f16:	22 0f       	add	r18, r18
    1f18:	33 1f       	adc	r19, r19
    1f1a:	28 0f       	add	r18, r24
    1f1c:	39 1f       	adc	r19, r25
    1f1e:	d9 01       	movw	r26, r18
    1f20:	a0 53       	subi	r26, 0x30	; 48
    1f22:	b7 4f       	sbci	r27, 0xF7	; 247
    1f24:	11 96       	adiw	r26, 0x01	; 1
    1f26:	ed 91       	ld	r30, X+
    1f28:	fc 91       	ld	r31, X
    1f2a:	12 97       	sbiw	r26, 0x02	; 2
    1f2c:	02 80       	ldd	r0, Z+2	; 0x02
    1f2e:	f3 81       	ldd	r31, Z+3	; 0x03
    1f30:	e0 2d       	mov	r30, r0
    1f32:	12 96       	adiw	r26, 0x02	; 2
    1f34:	fc 93       	st	X, r31
    1f36:	ee 93       	st	-X, r30
    1f38:	11 97       	sbiw	r26, 0x01	; 1
    1f3a:	2d 52       	subi	r18, 0x2D	; 45
    1f3c:	37 4f       	sbci	r19, 0xF7	; 247
    1f3e:	e2 17       	cp	r30, r18
    1f40:	f3 07       	cpc	r31, r19
    1f42:	29 f4       	brne	.+10     	; 0x1f4e <vTaskSwitchContext+0x86>
    1f44:	22 81       	ldd	r18, Z+2	; 0x02
    1f46:	33 81       	ldd	r19, Z+3	; 0x03
    1f48:	fd 01       	movw	r30, r26
    1f4a:	32 83       	std	Z+2, r19	; 0x02
    1f4c:	21 83       	std	Z+1, r18	; 0x01
    1f4e:	fc 01       	movw	r30, r24
    1f50:	ee 0f       	add	r30, r30
    1f52:	ff 1f       	adc	r31, r31
    1f54:	ee 0f       	add	r30, r30
    1f56:	ff 1f       	adc	r31, r31
    1f58:	ee 0f       	add	r30, r30
    1f5a:	ff 1f       	adc	r31, r31
    1f5c:	8e 0f       	add	r24, r30
    1f5e:	9f 1f       	adc	r25, r31
    1f60:	fc 01       	movw	r30, r24
    1f62:	e0 53       	subi	r30, 0x30	; 48
    1f64:	f7 4f       	sbci	r31, 0xF7	; 247
    1f66:	01 80       	ldd	r0, Z+1	; 0x01
    1f68:	f2 81       	ldd	r31, Z+2	; 0x02
    1f6a:	e0 2d       	mov	r30, r0
    1f6c:	86 81       	ldd	r24, Z+6	; 0x06
    1f6e:	97 81       	ldd	r25, Z+7	; 0x07
    1f70:	90 93 da 08 	sts	0x08DA, r25	; 0x8008da <pxCurrentTCB+0x1>
    1f74:	80 93 d9 08 	sts	0x08D9, r24	; 0x8008d9 <pxCurrentTCB>
    1f78:	08 95       	ret

00001f7a <_Z8InitUARTmhc>:
  Returns value <> 0 (TRUE), if the UART HAS received a new character.
*************************************************************************/
unsigned char CharReady()
{
   return UCSR0A & (1<<7);
}
    1f7a:	0f 93       	push	r16
    1f7c:	1f 93       	push	r17
    1f7e:	52 2f       	mov	r21, r18
    1f80:	8b 01       	movw	r16, r22
    1f82:	9c 01       	movw	r18, r24
    1f84:	0c 52       	subi	r16, 0x2C	; 44
    1f86:	11 40       	sbci	r17, 0x01	; 1
    1f88:	21 09       	sbc	r18, r1
    1f8a:	31 09       	sbc	r19, r1
    1f8c:	05 3d       	cpi	r16, 0xD5	; 213
    1f8e:	10 4c       	sbci	r17, 0xC0	; 192
    1f90:	21 40       	sbci	r18, 0x01	; 1
    1f92:	31 05       	cpc	r19, r1
    1f94:	e0 f5       	brcc	.+120    	; 0x200e <_Z8InitUARTmhc+0x94>
    1f96:	45 30       	cpi	r20, 0x05	; 5
    1f98:	d0 f1       	brcs	.+116    	; 0x200e <_Z8InitUARTmhc+0x94>
    1f9a:	49 30       	cpi	r20, 0x09	; 9
    1f9c:	c0 f5       	brcc	.+112    	; 0x200e <_Z8InitUARTmhc+0x94>
    1f9e:	20 e2       	ldi	r18, 0x20	; 32
    1fa0:	20 93 c0 00 	sts	0x00C0, r18	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7000c0>
    1fa4:	28 e1       	ldi	r18, 0x18	; 24
    1fa6:	20 93 c1 00 	sts	0x00C1, r18	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7000c1>
    1faa:	45 50       	subi	r20, 0x05	; 5
    1fac:	44 0f       	add	r20, r20
    1fae:	40 93 c2 00 	sts	0x00C2, r20	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7000c2>
    1fb2:	55 34       	cpi	r21, 0x45	; 69
    1fb4:	31 f4       	brne	.+12     	; 0x1fc2 <_Z8InitUARTmhc+0x48>
    1fb6:	e2 ec       	ldi	r30, 0xC2	; 194
    1fb8:	f0 e0       	ldi	r31, 0x00	; 0
    1fba:	20 81       	ld	r18, Z
    1fbc:	20 62       	ori	r18, 0x20	; 32
    1fbe:	20 83       	st	Z, r18
    1fc0:	07 c0       	rjmp	.+14     	; 0x1fd0 <_Z8InitUARTmhc+0x56>
    1fc2:	5f 34       	cpi	r21, 0x4F	; 79
    1fc4:	29 f4       	brne	.+10     	; 0x1fd0 <_Z8InitUARTmhc+0x56>
    1fc6:	e2 ec       	ldi	r30, 0xC2	; 194
    1fc8:	f0 e0       	ldi	r31, 0x00	; 0
    1fca:	20 81       	ld	r18, Z
    1fcc:	20 63       	ori	r18, 0x30	; 48
    1fce:	20 83       	st	Z, r18
    1fd0:	dc 01       	movw	r26, r24
    1fd2:	cb 01       	movw	r24, r22
    1fd4:	88 0f       	add	r24, r24
    1fd6:	99 1f       	adc	r25, r25
    1fd8:	aa 1f       	adc	r26, r26
    1fda:	bb 1f       	adc	r27, r27
    1fdc:	88 0f       	add	r24, r24
    1fde:	99 1f       	adc	r25, r25
    1fe0:	aa 1f       	adc	r26, r26
    1fe2:	bb 1f       	adc	r27, r27
    1fe4:	9c 01       	movw	r18, r24
    1fe6:	ad 01       	movw	r20, r26
    1fe8:	22 0f       	add	r18, r18
    1fea:	33 1f       	adc	r19, r19
    1fec:	44 1f       	adc	r20, r20
    1fee:	55 1f       	adc	r21, r21
    1ff0:	22 0f       	add	r18, r18
    1ff2:	33 1f       	adc	r19, r19
    1ff4:	44 1f       	adc	r20, r20
    1ff6:	55 1f       	adc	r21, r21
    1ff8:	60 e0       	ldi	r22, 0x00	; 0
    1ffa:	74 e2       	ldi	r23, 0x24	; 36
    1ffc:	84 ef       	ldi	r24, 0xF4	; 244
    1ffe:	90 e0       	ldi	r25, 0x00	; 0
    2000:	d1 d1       	rcall	.+930    	; 0x23a4 <__udivmodsi4>
    2002:	21 50       	subi	r18, 0x01	; 1
    2004:	31 09       	sbc	r19, r1
    2006:	30 93 c5 00 	sts	0x00C5, r19	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7000c5>
    200a:	20 93 c4 00 	sts	0x00C4, r18	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7000c4>
    200e:	1f 91       	pop	r17
    2010:	0f 91       	pop	r16
    2012:	08 95       	ret

00002014 <_Z8ReadCharv>:
Then this character is returned.
*************************************************************************/
char ReadChar()
{
  // Wait for new character received
  while ( (UCSR0A & (1<<7)) == 0 )
    2014:	80 91 c0 00 	lds	r24, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7000c0>
    2018:	88 23       	and	r24, r24
    201a:	e4 f7       	brge	.-8      	; 0x2014 <_Z8ReadCharv>
  {}                        
  // Then return it
  return UDR0;
    201c:	80 91 c6 00 	lds	r24, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7000c6>
}
    2020:	08 95       	ret

00002022 <_Z8SendCharc>:
	Tegn : Character for sending. 
*************************************************************************/
void SendChar(char Tegn)
{
  // Wait for transmitter register empty (ready for new character)
  while ( (UCSR0A & (1<<5)) == 0 )
    2022:	90 91 c0 00 	lds	r25, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7000c0>
    2026:	95 ff       	sbrs	r25, 5
    2028:	fc cf       	rjmp	.-8      	; 0x2022 <_Z8SendCharc>
  {}
  // Then send the character
  UDR0 = Tegn;
    202a:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7000c6>
    202e:	08 95       	ret

00002030 <_Z10SendStringPc>:
Sends 0 terminated string.
Parameter:
   Streng: Pointer to the string. 
*************************************************************************/
void SendString(char* Streng)
{
    2030:	cf 93       	push	r28
    2032:	df 93       	push	r29
    2034:	ec 01       	movw	r28, r24
  // Repeat until zero-termination
  while (*Streng != 0)
    2036:	88 81       	ld	r24, Y
    2038:	88 23       	and	r24, r24
    203a:	19 f0       	breq	.+6      	; 0x2042 <_Z10SendStringPc+0x12>
  {
    // Send the character pointed to by "Streng"
    SendChar(*Streng);
    203c:	f2 df       	rcall	.-28     	; 0x2022 <_Z8SendCharc>
    // Advance the pointer one step
    Streng++;
    203e:	21 96       	adiw	r28, 0x01	; 1
   Streng: Pointer to the string. 
*************************************************************************/
void SendString(char* Streng)
{
  // Repeat until zero-termination
  while (*Streng != 0)
    2040:	fa cf       	rjmp	.-12     	; 0x2036 <_Z10SendStringPc+0x6>
    // Send the character pointed to by "Streng"
    SendChar(*Streng);
    // Advance the pointer one step
    Streng++;
  }
}
    2042:	df 91       	pop	r29
    2044:	cf 91       	pop	r28
    2046:	08 95       	ret

00002048 <__subsf3>:
    2048:	50 58       	subi	r21, 0x80	; 128

0000204a <__addsf3>:
    204a:	bb 27       	eor	r27, r27
    204c:	aa 27       	eor	r26, r26
    204e:	0e d0       	rcall	.+28     	; 0x206c <__addsf3x>
    2050:	08 c1       	rjmp	.+528    	; 0x2262 <__fp_round>
    2052:	f9 d0       	rcall	.+498    	; 0x2246 <__fp_pscA>
    2054:	30 f0       	brcs	.+12     	; 0x2062 <__addsf3+0x18>
    2056:	fe d0       	rcall	.+508    	; 0x2254 <__fp_pscB>
    2058:	20 f0       	brcs	.+8      	; 0x2062 <__addsf3+0x18>
    205a:	31 f4       	brne	.+12     	; 0x2068 <__addsf3+0x1e>
    205c:	9f 3f       	cpi	r25, 0xFF	; 255
    205e:	11 f4       	brne	.+4      	; 0x2064 <__addsf3+0x1a>
    2060:	1e f4       	brtc	.+6      	; 0x2068 <__addsf3+0x1e>
    2062:	ee c0       	rjmp	.+476    	; 0x2240 <__fp_nan>
    2064:	0e f4       	brtc	.+2      	; 0x2068 <__addsf3+0x1e>
    2066:	e0 95       	com	r30
    2068:	e7 fb       	bst	r30, 7
    206a:	e4 c0       	rjmp	.+456    	; 0x2234 <__fp_inf>

0000206c <__addsf3x>:
    206c:	e9 2f       	mov	r30, r25
    206e:	0a d1       	rcall	.+532    	; 0x2284 <__fp_split3>
    2070:	80 f3       	brcs	.-32     	; 0x2052 <__addsf3+0x8>
    2072:	ba 17       	cp	r27, r26
    2074:	62 07       	cpc	r22, r18
    2076:	73 07       	cpc	r23, r19
    2078:	84 07       	cpc	r24, r20
    207a:	95 07       	cpc	r25, r21
    207c:	18 f0       	brcs	.+6      	; 0x2084 <__addsf3x+0x18>
    207e:	71 f4       	brne	.+28     	; 0x209c <__addsf3x+0x30>
    2080:	9e f5       	brtc	.+102    	; 0x20e8 <__addsf3x+0x7c>
    2082:	22 c1       	rjmp	.+580    	; 0x22c8 <__fp_zero>
    2084:	0e f4       	brtc	.+2      	; 0x2088 <__addsf3x+0x1c>
    2086:	e0 95       	com	r30
    2088:	0b 2e       	mov	r0, r27
    208a:	ba 2f       	mov	r27, r26
    208c:	a0 2d       	mov	r26, r0
    208e:	0b 01       	movw	r0, r22
    2090:	b9 01       	movw	r22, r18
    2092:	90 01       	movw	r18, r0
    2094:	0c 01       	movw	r0, r24
    2096:	ca 01       	movw	r24, r20
    2098:	a0 01       	movw	r20, r0
    209a:	11 24       	eor	r1, r1
    209c:	ff 27       	eor	r31, r31
    209e:	59 1b       	sub	r21, r25
    20a0:	99 f0       	breq	.+38     	; 0x20c8 <__addsf3x+0x5c>
    20a2:	59 3f       	cpi	r21, 0xF9	; 249
    20a4:	50 f4       	brcc	.+20     	; 0x20ba <__addsf3x+0x4e>
    20a6:	50 3e       	cpi	r21, 0xE0	; 224
    20a8:	68 f1       	brcs	.+90     	; 0x2104 <__addsf3x+0x98>
    20aa:	1a 16       	cp	r1, r26
    20ac:	f0 40       	sbci	r31, 0x00	; 0
    20ae:	a2 2f       	mov	r26, r18
    20b0:	23 2f       	mov	r18, r19
    20b2:	34 2f       	mov	r19, r20
    20b4:	44 27       	eor	r20, r20
    20b6:	58 5f       	subi	r21, 0xF8	; 248
    20b8:	f3 cf       	rjmp	.-26     	; 0x20a0 <__addsf3x+0x34>
    20ba:	46 95       	lsr	r20
    20bc:	37 95       	ror	r19
    20be:	27 95       	ror	r18
    20c0:	a7 95       	ror	r26
    20c2:	f0 40       	sbci	r31, 0x00	; 0
    20c4:	53 95       	inc	r21
    20c6:	c9 f7       	brne	.-14     	; 0x20ba <__addsf3x+0x4e>
    20c8:	7e f4       	brtc	.+30     	; 0x20e8 <__addsf3x+0x7c>
    20ca:	1f 16       	cp	r1, r31
    20cc:	ba 0b       	sbc	r27, r26
    20ce:	62 0b       	sbc	r22, r18
    20d0:	73 0b       	sbc	r23, r19
    20d2:	84 0b       	sbc	r24, r20
    20d4:	ba f0       	brmi	.+46     	; 0x2104 <__addsf3x+0x98>
    20d6:	91 50       	subi	r25, 0x01	; 1
    20d8:	a1 f0       	breq	.+40     	; 0x2102 <__addsf3x+0x96>
    20da:	ff 0f       	add	r31, r31
    20dc:	bb 1f       	adc	r27, r27
    20de:	66 1f       	adc	r22, r22
    20e0:	77 1f       	adc	r23, r23
    20e2:	88 1f       	adc	r24, r24
    20e4:	c2 f7       	brpl	.-16     	; 0x20d6 <__addsf3x+0x6a>
    20e6:	0e c0       	rjmp	.+28     	; 0x2104 <__addsf3x+0x98>
    20e8:	ba 0f       	add	r27, r26
    20ea:	62 1f       	adc	r22, r18
    20ec:	73 1f       	adc	r23, r19
    20ee:	84 1f       	adc	r24, r20
    20f0:	48 f4       	brcc	.+18     	; 0x2104 <__addsf3x+0x98>
    20f2:	87 95       	ror	r24
    20f4:	77 95       	ror	r23
    20f6:	67 95       	ror	r22
    20f8:	b7 95       	ror	r27
    20fa:	f7 95       	ror	r31
    20fc:	9e 3f       	cpi	r25, 0xFE	; 254
    20fe:	08 f0       	brcs	.+2      	; 0x2102 <__addsf3x+0x96>
    2100:	b3 cf       	rjmp	.-154    	; 0x2068 <__addsf3+0x1e>
    2102:	93 95       	inc	r25
    2104:	88 0f       	add	r24, r24
    2106:	08 f0       	brcs	.+2      	; 0x210a <__addsf3x+0x9e>
    2108:	99 27       	eor	r25, r25
    210a:	ee 0f       	add	r30, r30
    210c:	97 95       	ror	r25
    210e:	87 95       	ror	r24
    2110:	08 95       	ret

00002112 <__cmpsf2>:
    2112:	6c d0       	rcall	.+216    	; 0x21ec <__fp_cmp>
    2114:	08 f4       	brcc	.+2      	; 0x2118 <__cmpsf2+0x6>
    2116:	81 e0       	ldi	r24, 0x01	; 1
    2118:	08 95       	ret

0000211a <__fixunssfsi>:
    211a:	bc d0       	rcall	.+376    	; 0x2294 <__fp_splitA>
    211c:	88 f0       	brcs	.+34     	; 0x2140 <__fixunssfsi+0x26>
    211e:	9f 57       	subi	r25, 0x7F	; 127
    2120:	90 f0       	brcs	.+36     	; 0x2146 <__fixunssfsi+0x2c>
    2122:	b9 2f       	mov	r27, r25
    2124:	99 27       	eor	r25, r25
    2126:	b7 51       	subi	r27, 0x17	; 23
    2128:	a0 f0       	brcs	.+40     	; 0x2152 <__fixunssfsi+0x38>
    212a:	d1 f0       	breq	.+52     	; 0x2160 <__fixunssfsi+0x46>
    212c:	66 0f       	add	r22, r22
    212e:	77 1f       	adc	r23, r23
    2130:	88 1f       	adc	r24, r24
    2132:	99 1f       	adc	r25, r25
    2134:	1a f0       	brmi	.+6      	; 0x213c <__fixunssfsi+0x22>
    2136:	ba 95       	dec	r27
    2138:	c9 f7       	brne	.-14     	; 0x212c <__fixunssfsi+0x12>
    213a:	12 c0       	rjmp	.+36     	; 0x2160 <__fixunssfsi+0x46>
    213c:	b1 30       	cpi	r27, 0x01	; 1
    213e:	81 f0       	breq	.+32     	; 0x2160 <__fixunssfsi+0x46>
    2140:	c3 d0       	rcall	.+390    	; 0x22c8 <__fp_zero>
    2142:	b1 e0       	ldi	r27, 0x01	; 1
    2144:	08 95       	ret
    2146:	c0 c0       	rjmp	.+384    	; 0x22c8 <__fp_zero>
    2148:	67 2f       	mov	r22, r23
    214a:	78 2f       	mov	r23, r24
    214c:	88 27       	eor	r24, r24
    214e:	b8 5f       	subi	r27, 0xF8	; 248
    2150:	39 f0       	breq	.+14     	; 0x2160 <__fixunssfsi+0x46>
    2152:	b9 3f       	cpi	r27, 0xF9	; 249
    2154:	cc f3       	brlt	.-14     	; 0x2148 <__fixunssfsi+0x2e>
    2156:	86 95       	lsr	r24
    2158:	77 95       	ror	r23
    215a:	67 95       	ror	r22
    215c:	b3 95       	inc	r27
    215e:	d9 f7       	brne	.-10     	; 0x2156 <__fixunssfsi+0x3c>
    2160:	3e f4       	brtc	.+14     	; 0x2170 <__fixunssfsi+0x56>
    2162:	90 95       	com	r25
    2164:	80 95       	com	r24
    2166:	70 95       	com	r23
    2168:	61 95       	neg	r22
    216a:	7f 4f       	sbci	r23, 0xFF	; 255
    216c:	8f 4f       	sbci	r24, 0xFF	; 255
    216e:	9f 4f       	sbci	r25, 0xFF	; 255
    2170:	08 95       	ret

00002172 <__floatunsisf>:
    2172:	e8 94       	clt
    2174:	09 c0       	rjmp	.+18     	; 0x2188 <__floatsisf+0x12>

00002176 <__floatsisf>:
    2176:	97 fb       	bst	r25, 7
    2178:	3e f4       	brtc	.+14     	; 0x2188 <__floatsisf+0x12>
    217a:	90 95       	com	r25
    217c:	80 95       	com	r24
    217e:	70 95       	com	r23
    2180:	61 95       	neg	r22
    2182:	7f 4f       	sbci	r23, 0xFF	; 255
    2184:	8f 4f       	sbci	r24, 0xFF	; 255
    2186:	9f 4f       	sbci	r25, 0xFF	; 255
    2188:	99 23       	and	r25, r25
    218a:	a9 f0       	breq	.+42     	; 0x21b6 <__floatsisf+0x40>
    218c:	f9 2f       	mov	r31, r25
    218e:	96 e9       	ldi	r25, 0x96	; 150
    2190:	bb 27       	eor	r27, r27
    2192:	93 95       	inc	r25
    2194:	f6 95       	lsr	r31
    2196:	87 95       	ror	r24
    2198:	77 95       	ror	r23
    219a:	67 95       	ror	r22
    219c:	b7 95       	ror	r27
    219e:	f1 11       	cpse	r31, r1
    21a0:	f8 cf       	rjmp	.-16     	; 0x2192 <__floatsisf+0x1c>
    21a2:	fa f4       	brpl	.+62     	; 0x21e2 <__floatsisf+0x6c>
    21a4:	bb 0f       	add	r27, r27
    21a6:	11 f4       	brne	.+4      	; 0x21ac <__floatsisf+0x36>
    21a8:	60 ff       	sbrs	r22, 0
    21aa:	1b c0       	rjmp	.+54     	; 0x21e2 <__floatsisf+0x6c>
    21ac:	6f 5f       	subi	r22, 0xFF	; 255
    21ae:	7f 4f       	sbci	r23, 0xFF	; 255
    21b0:	8f 4f       	sbci	r24, 0xFF	; 255
    21b2:	9f 4f       	sbci	r25, 0xFF	; 255
    21b4:	16 c0       	rjmp	.+44     	; 0x21e2 <__floatsisf+0x6c>
    21b6:	88 23       	and	r24, r24
    21b8:	11 f0       	breq	.+4      	; 0x21be <__floatsisf+0x48>
    21ba:	96 e9       	ldi	r25, 0x96	; 150
    21bc:	11 c0       	rjmp	.+34     	; 0x21e0 <__floatsisf+0x6a>
    21be:	77 23       	and	r23, r23
    21c0:	21 f0       	breq	.+8      	; 0x21ca <__floatsisf+0x54>
    21c2:	9e e8       	ldi	r25, 0x8E	; 142
    21c4:	87 2f       	mov	r24, r23
    21c6:	76 2f       	mov	r23, r22
    21c8:	05 c0       	rjmp	.+10     	; 0x21d4 <__floatsisf+0x5e>
    21ca:	66 23       	and	r22, r22
    21cc:	71 f0       	breq	.+28     	; 0x21ea <__floatsisf+0x74>
    21ce:	96 e8       	ldi	r25, 0x86	; 134
    21d0:	86 2f       	mov	r24, r22
    21d2:	70 e0       	ldi	r23, 0x00	; 0
    21d4:	60 e0       	ldi	r22, 0x00	; 0
    21d6:	2a f0       	brmi	.+10     	; 0x21e2 <__floatsisf+0x6c>
    21d8:	9a 95       	dec	r25
    21da:	66 0f       	add	r22, r22
    21dc:	77 1f       	adc	r23, r23
    21de:	88 1f       	adc	r24, r24
    21e0:	da f7       	brpl	.-10     	; 0x21d8 <__floatsisf+0x62>
    21e2:	88 0f       	add	r24, r24
    21e4:	96 95       	lsr	r25
    21e6:	87 95       	ror	r24
    21e8:	97 f9       	bld	r25, 7
    21ea:	08 95       	ret

000021ec <__fp_cmp>:
    21ec:	99 0f       	add	r25, r25
    21ee:	00 08       	sbc	r0, r0
    21f0:	55 0f       	add	r21, r21
    21f2:	aa 0b       	sbc	r26, r26
    21f4:	e0 e8       	ldi	r30, 0x80	; 128
    21f6:	fe ef       	ldi	r31, 0xFE	; 254
    21f8:	16 16       	cp	r1, r22
    21fa:	17 06       	cpc	r1, r23
    21fc:	e8 07       	cpc	r30, r24
    21fe:	f9 07       	cpc	r31, r25
    2200:	c0 f0       	brcs	.+48     	; 0x2232 <__stack+0x33>
    2202:	12 16       	cp	r1, r18
    2204:	13 06       	cpc	r1, r19
    2206:	e4 07       	cpc	r30, r20
    2208:	f5 07       	cpc	r31, r21
    220a:	98 f0       	brcs	.+38     	; 0x2232 <__stack+0x33>
    220c:	62 1b       	sub	r22, r18
    220e:	73 0b       	sbc	r23, r19
    2210:	84 0b       	sbc	r24, r20
    2212:	95 0b       	sbc	r25, r21
    2214:	39 f4       	brne	.+14     	; 0x2224 <__stack+0x25>
    2216:	0a 26       	eor	r0, r26
    2218:	61 f0       	breq	.+24     	; 0x2232 <__stack+0x33>
    221a:	23 2b       	or	r18, r19
    221c:	24 2b       	or	r18, r20
    221e:	25 2b       	or	r18, r21
    2220:	21 f4       	brne	.+8      	; 0x222a <__stack+0x2b>
    2222:	08 95       	ret
    2224:	0a 26       	eor	r0, r26
    2226:	09 f4       	brne	.+2      	; 0x222a <__stack+0x2b>
    2228:	a1 40       	sbci	r26, 0x01	; 1
    222a:	a6 95       	lsr	r26
    222c:	8f ef       	ldi	r24, 0xFF	; 255
    222e:	81 1d       	adc	r24, r1
    2230:	81 1d       	adc	r24, r1
    2232:	08 95       	ret

00002234 <__fp_inf>:
    2234:	97 f9       	bld	r25, 7
    2236:	9f 67       	ori	r25, 0x7F	; 127
    2238:	80 e8       	ldi	r24, 0x80	; 128
    223a:	70 e0       	ldi	r23, 0x00	; 0
    223c:	60 e0       	ldi	r22, 0x00	; 0
    223e:	08 95       	ret

00002240 <__fp_nan>:
    2240:	9f ef       	ldi	r25, 0xFF	; 255
    2242:	80 ec       	ldi	r24, 0xC0	; 192
    2244:	08 95       	ret

00002246 <__fp_pscA>:
    2246:	00 24       	eor	r0, r0
    2248:	0a 94       	dec	r0
    224a:	16 16       	cp	r1, r22
    224c:	17 06       	cpc	r1, r23
    224e:	18 06       	cpc	r1, r24
    2250:	09 06       	cpc	r0, r25
    2252:	08 95       	ret

00002254 <__fp_pscB>:
    2254:	00 24       	eor	r0, r0
    2256:	0a 94       	dec	r0
    2258:	12 16       	cp	r1, r18
    225a:	13 06       	cpc	r1, r19
    225c:	14 06       	cpc	r1, r20
    225e:	05 06       	cpc	r0, r21
    2260:	08 95       	ret

00002262 <__fp_round>:
    2262:	09 2e       	mov	r0, r25
    2264:	03 94       	inc	r0
    2266:	00 0c       	add	r0, r0
    2268:	11 f4       	brne	.+4      	; 0x226e <__fp_round+0xc>
    226a:	88 23       	and	r24, r24
    226c:	52 f0       	brmi	.+20     	; 0x2282 <__fp_round+0x20>
    226e:	bb 0f       	add	r27, r27
    2270:	40 f4       	brcc	.+16     	; 0x2282 <__fp_round+0x20>
    2272:	bf 2b       	or	r27, r31
    2274:	11 f4       	brne	.+4      	; 0x227a <__fp_round+0x18>
    2276:	60 ff       	sbrs	r22, 0
    2278:	04 c0       	rjmp	.+8      	; 0x2282 <__fp_round+0x20>
    227a:	6f 5f       	subi	r22, 0xFF	; 255
    227c:	7f 4f       	sbci	r23, 0xFF	; 255
    227e:	8f 4f       	sbci	r24, 0xFF	; 255
    2280:	9f 4f       	sbci	r25, 0xFF	; 255
    2282:	08 95       	ret

00002284 <__fp_split3>:
    2284:	57 fd       	sbrc	r21, 7
    2286:	90 58       	subi	r25, 0x80	; 128
    2288:	44 0f       	add	r20, r20
    228a:	55 1f       	adc	r21, r21
    228c:	59 f0       	breq	.+22     	; 0x22a4 <__fp_splitA+0x10>
    228e:	5f 3f       	cpi	r21, 0xFF	; 255
    2290:	71 f0       	breq	.+28     	; 0x22ae <__fp_splitA+0x1a>
    2292:	47 95       	ror	r20

00002294 <__fp_splitA>:
    2294:	88 0f       	add	r24, r24
    2296:	97 fb       	bst	r25, 7
    2298:	99 1f       	adc	r25, r25
    229a:	61 f0       	breq	.+24     	; 0x22b4 <__fp_splitA+0x20>
    229c:	9f 3f       	cpi	r25, 0xFF	; 255
    229e:	79 f0       	breq	.+30     	; 0x22be <__fp_splitA+0x2a>
    22a0:	87 95       	ror	r24
    22a2:	08 95       	ret
    22a4:	12 16       	cp	r1, r18
    22a6:	13 06       	cpc	r1, r19
    22a8:	14 06       	cpc	r1, r20
    22aa:	55 1f       	adc	r21, r21
    22ac:	f2 cf       	rjmp	.-28     	; 0x2292 <__fp_split3+0xe>
    22ae:	46 95       	lsr	r20
    22b0:	f1 df       	rcall	.-30     	; 0x2294 <__fp_splitA>
    22b2:	08 c0       	rjmp	.+16     	; 0x22c4 <__fp_splitA+0x30>
    22b4:	16 16       	cp	r1, r22
    22b6:	17 06       	cpc	r1, r23
    22b8:	18 06       	cpc	r1, r24
    22ba:	99 1f       	adc	r25, r25
    22bc:	f1 cf       	rjmp	.-30     	; 0x22a0 <__fp_splitA+0xc>
    22be:	86 95       	lsr	r24
    22c0:	71 05       	cpc	r23, r1
    22c2:	61 05       	cpc	r22, r1
    22c4:	08 94       	sec
    22c6:	08 95       	ret

000022c8 <__fp_zero>:
    22c8:	e8 94       	clt

000022ca <__fp_szero>:
    22ca:	bb 27       	eor	r27, r27
    22cc:	66 27       	eor	r22, r22
    22ce:	77 27       	eor	r23, r23
    22d0:	cb 01       	movw	r24, r22
    22d2:	97 f9       	bld	r25, 7
    22d4:	08 95       	ret

000022d6 <__gesf2>:
    22d6:	8a df       	rcall	.-236    	; 0x21ec <__fp_cmp>
    22d8:	08 f4       	brcc	.+2      	; 0x22dc <__gesf2+0x6>
    22da:	8f ef       	ldi	r24, 0xFF	; 255
    22dc:	08 95       	ret

000022de <__mulsf3>:
    22de:	0b d0       	rcall	.+22     	; 0x22f6 <__mulsf3x>
    22e0:	c0 cf       	rjmp	.-128    	; 0x2262 <__fp_round>
    22e2:	b1 df       	rcall	.-158    	; 0x2246 <__fp_pscA>
    22e4:	28 f0       	brcs	.+10     	; 0x22f0 <__mulsf3+0x12>
    22e6:	b6 df       	rcall	.-148    	; 0x2254 <__fp_pscB>
    22e8:	18 f0       	brcs	.+6      	; 0x22f0 <__mulsf3+0x12>
    22ea:	95 23       	and	r25, r21
    22ec:	09 f0       	breq	.+2      	; 0x22f0 <__mulsf3+0x12>
    22ee:	a2 cf       	rjmp	.-188    	; 0x2234 <__fp_inf>
    22f0:	a7 cf       	rjmp	.-178    	; 0x2240 <__fp_nan>
    22f2:	11 24       	eor	r1, r1
    22f4:	ea cf       	rjmp	.-44     	; 0x22ca <__fp_szero>

000022f6 <__mulsf3x>:
    22f6:	c6 df       	rcall	.-116    	; 0x2284 <__fp_split3>
    22f8:	a0 f3       	brcs	.-24     	; 0x22e2 <__mulsf3+0x4>

000022fa <__mulsf3_pse>:
    22fa:	95 9f       	mul	r25, r21
    22fc:	d1 f3       	breq	.-12     	; 0x22f2 <__mulsf3+0x14>
    22fe:	95 0f       	add	r25, r21
    2300:	50 e0       	ldi	r21, 0x00	; 0
    2302:	55 1f       	adc	r21, r21
    2304:	62 9f       	mul	r22, r18
    2306:	f0 01       	movw	r30, r0
    2308:	72 9f       	mul	r23, r18
    230a:	bb 27       	eor	r27, r27
    230c:	f0 0d       	add	r31, r0
    230e:	b1 1d       	adc	r27, r1
    2310:	63 9f       	mul	r22, r19
    2312:	aa 27       	eor	r26, r26
    2314:	f0 0d       	add	r31, r0
    2316:	b1 1d       	adc	r27, r1
    2318:	aa 1f       	adc	r26, r26
    231a:	64 9f       	mul	r22, r20
    231c:	66 27       	eor	r22, r22
    231e:	b0 0d       	add	r27, r0
    2320:	a1 1d       	adc	r26, r1
    2322:	66 1f       	adc	r22, r22
    2324:	82 9f       	mul	r24, r18
    2326:	22 27       	eor	r18, r18
    2328:	b0 0d       	add	r27, r0
    232a:	a1 1d       	adc	r26, r1
    232c:	62 1f       	adc	r22, r18
    232e:	73 9f       	mul	r23, r19
    2330:	b0 0d       	add	r27, r0
    2332:	a1 1d       	adc	r26, r1
    2334:	62 1f       	adc	r22, r18
    2336:	83 9f       	mul	r24, r19
    2338:	a0 0d       	add	r26, r0
    233a:	61 1d       	adc	r22, r1
    233c:	22 1f       	adc	r18, r18
    233e:	74 9f       	mul	r23, r20
    2340:	33 27       	eor	r19, r19
    2342:	a0 0d       	add	r26, r0
    2344:	61 1d       	adc	r22, r1
    2346:	23 1f       	adc	r18, r19
    2348:	84 9f       	mul	r24, r20
    234a:	60 0d       	add	r22, r0
    234c:	21 1d       	adc	r18, r1
    234e:	82 2f       	mov	r24, r18
    2350:	76 2f       	mov	r23, r22
    2352:	6a 2f       	mov	r22, r26
    2354:	11 24       	eor	r1, r1
    2356:	9f 57       	subi	r25, 0x7F	; 127
    2358:	50 40       	sbci	r21, 0x00	; 0
    235a:	8a f0       	brmi	.+34     	; 0x237e <__mulsf3_pse+0x84>
    235c:	e1 f0       	breq	.+56     	; 0x2396 <__mulsf3_pse+0x9c>
    235e:	88 23       	and	r24, r24
    2360:	4a f0       	brmi	.+18     	; 0x2374 <__mulsf3_pse+0x7a>
    2362:	ee 0f       	add	r30, r30
    2364:	ff 1f       	adc	r31, r31
    2366:	bb 1f       	adc	r27, r27
    2368:	66 1f       	adc	r22, r22
    236a:	77 1f       	adc	r23, r23
    236c:	88 1f       	adc	r24, r24
    236e:	91 50       	subi	r25, 0x01	; 1
    2370:	50 40       	sbci	r21, 0x00	; 0
    2372:	a9 f7       	brne	.-22     	; 0x235e <__mulsf3_pse+0x64>
    2374:	9e 3f       	cpi	r25, 0xFE	; 254
    2376:	51 05       	cpc	r21, r1
    2378:	70 f0       	brcs	.+28     	; 0x2396 <__mulsf3_pse+0x9c>
    237a:	5c cf       	rjmp	.-328    	; 0x2234 <__fp_inf>
    237c:	a6 cf       	rjmp	.-180    	; 0x22ca <__fp_szero>
    237e:	5f 3f       	cpi	r21, 0xFF	; 255
    2380:	ec f3       	brlt	.-6      	; 0x237c <__mulsf3_pse+0x82>
    2382:	98 3e       	cpi	r25, 0xE8	; 232
    2384:	dc f3       	brlt	.-10     	; 0x237c <__mulsf3_pse+0x82>
    2386:	86 95       	lsr	r24
    2388:	77 95       	ror	r23
    238a:	67 95       	ror	r22
    238c:	b7 95       	ror	r27
    238e:	f7 95       	ror	r31
    2390:	e7 95       	ror	r30
    2392:	9f 5f       	subi	r25, 0xFF	; 255
    2394:	c1 f7       	brne	.-16     	; 0x2386 <__mulsf3_pse+0x8c>
    2396:	fe 2b       	or	r31, r30
    2398:	88 0f       	add	r24, r24
    239a:	91 1d       	adc	r25, r1
    239c:	96 95       	lsr	r25
    239e:	87 95       	ror	r24
    23a0:	97 f9       	bld	r25, 7
    23a2:	08 95       	ret

000023a4 <__udivmodsi4>:
    23a4:	a1 e2       	ldi	r26, 0x21	; 33
    23a6:	1a 2e       	mov	r1, r26
    23a8:	aa 1b       	sub	r26, r26
    23aa:	bb 1b       	sub	r27, r27
    23ac:	fd 01       	movw	r30, r26
    23ae:	0d c0       	rjmp	.+26     	; 0x23ca <__udivmodsi4_ep>

000023b0 <__udivmodsi4_loop>:
    23b0:	aa 1f       	adc	r26, r26
    23b2:	bb 1f       	adc	r27, r27
    23b4:	ee 1f       	adc	r30, r30
    23b6:	ff 1f       	adc	r31, r31
    23b8:	a2 17       	cp	r26, r18
    23ba:	b3 07       	cpc	r27, r19
    23bc:	e4 07       	cpc	r30, r20
    23be:	f5 07       	cpc	r31, r21
    23c0:	20 f0       	brcs	.+8      	; 0x23ca <__udivmodsi4_ep>
    23c2:	a2 1b       	sub	r26, r18
    23c4:	b3 0b       	sbc	r27, r19
    23c6:	e4 0b       	sbc	r30, r20
    23c8:	f5 0b       	sbc	r31, r21

000023ca <__udivmodsi4_ep>:
    23ca:	66 1f       	adc	r22, r22
    23cc:	77 1f       	adc	r23, r23
    23ce:	88 1f       	adc	r24, r24
    23d0:	99 1f       	adc	r25, r25
    23d2:	1a 94       	dec	r1
    23d4:	69 f7       	brne	.-38     	; 0x23b0 <__udivmodsi4_loop>
    23d6:	60 95       	com	r22
    23d8:	70 95       	com	r23
    23da:	80 95       	com	r24
    23dc:	90 95       	com	r25
    23de:	9b 01       	movw	r18, r22
    23e0:	ac 01       	movw	r20, r24
    23e2:	bd 01       	movw	r22, r26
    23e4:	cf 01       	movw	r24, r30
    23e6:	08 95       	ret

000023e8 <__umulhisi3>:
    23e8:	a2 9f       	mul	r26, r18
    23ea:	b0 01       	movw	r22, r0
    23ec:	b3 9f       	mul	r27, r19
    23ee:	c0 01       	movw	r24, r0
    23f0:	a3 9f       	mul	r26, r19
    23f2:	70 0d       	add	r23, r0
    23f4:	81 1d       	adc	r24, r1
    23f6:	11 24       	eor	r1, r1
    23f8:	91 1d       	adc	r25, r1
    23fa:	b2 9f       	mul	r27, r18
    23fc:	70 0d       	add	r23, r0
    23fe:	81 1d       	adc	r24, r1
    2400:	11 24       	eor	r1, r1
    2402:	91 1d       	adc	r25, r1
    2404:	08 95       	ret

00002406 <malloc>:
    2406:	0f 93       	push	r16
    2408:	1f 93       	push	r17
    240a:	cf 93       	push	r28
    240c:	df 93       	push	r29
    240e:	82 30       	cpi	r24, 0x02	; 2
    2410:	91 05       	cpc	r25, r1
    2412:	10 f4       	brcc	.+4      	; 0x2418 <malloc+0x12>
    2414:	82 e0       	ldi	r24, 0x02	; 2
    2416:	90 e0       	ldi	r25, 0x00	; 0
    2418:	e0 91 dd 08 	lds	r30, 0x08DD	; 0x8008dd <__flp>
    241c:	f0 91 de 08 	lds	r31, 0x08DE	; 0x8008de <__flp+0x1>
    2420:	20 e0       	ldi	r18, 0x00	; 0
    2422:	30 e0       	ldi	r19, 0x00	; 0
    2424:	a0 e0       	ldi	r26, 0x00	; 0
    2426:	b0 e0       	ldi	r27, 0x00	; 0
    2428:	30 97       	sbiw	r30, 0x00	; 0
    242a:	19 f1       	breq	.+70     	; 0x2472 <malloc+0x6c>
    242c:	40 81       	ld	r20, Z
    242e:	51 81       	ldd	r21, Z+1	; 0x01
    2430:	02 81       	ldd	r16, Z+2	; 0x02
    2432:	13 81       	ldd	r17, Z+3	; 0x03
    2434:	48 17       	cp	r20, r24
    2436:	59 07       	cpc	r21, r25
    2438:	c8 f0       	brcs	.+50     	; 0x246c <malloc+0x66>
    243a:	84 17       	cp	r24, r20
    243c:	95 07       	cpc	r25, r21
    243e:	69 f4       	brne	.+26     	; 0x245a <malloc+0x54>
    2440:	10 97       	sbiw	r26, 0x00	; 0
    2442:	31 f0       	breq	.+12     	; 0x2450 <malloc+0x4a>
    2444:	12 96       	adiw	r26, 0x02	; 2
    2446:	0c 93       	st	X, r16
    2448:	12 97       	sbiw	r26, 0x02	; 2
    244a:	13 96       	adiw	r26, 0x03	; 3
    244c:	1c 93       	st	X, r17
    244e:	27 c0       	rjmp	.+78     	; 0x249e <malloc+0x98>
    2450:	00 93 dd 08 	sts	0x08DD, r16	; 0x8008dd <__flp>
    2454:	10 93 de 08 	sts	0x08DE, r17	; 0x8008de <__flp+0x1>
    2458:	22 c0       	rjmp	.+68     	; 0x249e <malloc+0x98>
    245a:	21 15       	cp	r18, r1
    245c:	31 05       	cpc	r19, r1
    245e:	19 f0       	breq	.+6      	; 0x2466 <malloc+0x60>
    2460:	42 17       	cp	r20, r18
    2462:	53 07       	cpc	r21, r19
    2464:	18 f4       	brcc	.+6      	; 0x246c <malloc+0x66>
    2466:	9a 01       	movw	r18, r20
    2468:	bd 01       	movw	r22, r26
    246a:	ef 01       	movw	r28, r30
    246c:	df 01       	movw	r26, r30
    246e:	f8 01       	movw	r30, r16
    2470:	db cf       	rjmp	.-74     	; 0x2428 <malloc+0x22>
    2472:	21 15       	cp	r18, r1
    2474:	31 05       	cpc	r19, r1
    2476:	f9 f0       	breq	.+62     	; 0x24b6 <malloc+0xb0>
    2478:	28 1b       	sub	r18, r24
    247a:	39 0b       	sbc	r19, r25
    247c:	24 30       	cpi	r18, 0x04	; 4
    247e:	31 05       	cpc	r19, r1
    2480:	80 f4       	brcc	.+32     	; 0x24a2 <malloc+0x9c>
    2482:	8a 81       	ldd	r24, Y+2	; 0x02
    2484:	9b 81       	ldd	r25, Y+3	; 0x03
    2486:	61 15       	cp	r22, r1
    2488:	71 05       	cpc	r23, r1
    248a:	21 f0       	breq	.+8      	; 0x2494 <malloc+0x8e>
    248c:	fb 01       	movw	r30, r22
    248e:	93 83       	std	Z+3, r25	; 0x03
    2490:	82 83       	std	Z+2, r24	; 0x02
    2492:	04 c0       	rjmp	.+8      	; 0x249c <malloc+0x96>
    2494:	90 93 de 08 	sts	0x08DE, r25	; 0x8008de <__flp+0x1>
    2498:	80 93 dd 08 	sts	0x08DD, r24	; 0x8008dd <__flp>
    249c:	fe 01       	movw	r30, r28
    249e:	32 96       	adiw	r30, 0x02	; 2
    24a0:	44 c0       	rjmp	.+136    	; 0x252a <malloc+0x124>
    24a2:	fe 01       	movw	r30, r28
    24a4:	e2 0f       	add	r30, r18
    24a6:	f3 1f       	adc	r31, r19
    24a8:	81 93       	st	Z+, r24
    24aa:	91 93       	st	Z+, r25
    24ac:	22 50       	subi	r18, 0x02	; 2
    24ae:	31 09       	sbc	r19, r1
    24b0:	39 83       	std	Y+1, r19	; 0x01
    24b2:	28 83       	st	Y, r18
    24b4:	3a c0       	rjmp	.+116    	; 0x252a <malloc+0x124>
    24b6:	20 91 db 08 	lds	r18, 0x08DB	; 0x8008db <__brkval>
    24ba:	30 91 dc 08 	lds	r19, 0x08DC	; 0x8008dc <__brkval+0x1>
    24be:	23 2b       	or	r18, r19
    24c0:	41 f4       	brne	.+16     	; 0x24d2 <malloc+0xcc>
    24c2:	20 91 02 02 	lds	r18, 0x0202	; 0x800202 <__malloc_heap_start>
    24c6:	30 91 03 02 	lds	r19, 0x0203	; 0x800203 <__malloc_heap_start+0x1>
    24ca:	30 93 dc 08 	sts	0x08DC, r19	; 0x8008dc <__brkval+0x1>
    24ce:	20 93 db 08 	sts	0x08DB, r18	; 0x8008db <__brkval>
    24d2:	20 91 00 02 	lds	r18, 0x0200	; 0x800200 <__data_start>
    24d6:	30 91 01 02 	lds	r19, 0x0201	; 0x800201 <__data_start+0x1>
    24da:	21 15       	cp	r18, r1
    24dc:	31 05       	cpc	r19, r1
    24de:	41 f4       	brne	.+16     	; 0x24f0 <malloc+0xea>
    24e0:	2d b7       	in	r18, 0x3d	; 61
    24e2:	3e b7       	in	r19, 0x3e	; 62
    24e4:	40 91 04 02 	lds	r20, 0x0204	; 0x800204 <__malloc_margin>
    24e8:	50 91 05 02 	lds	r21, 0x0205	; 0x800205 <__malloc_margin+0x1>
    24ec:	24 1b       	sub	r18, r20
    24ee:	35 0b       	sbc	r19, r21
    24f0:	e0 91 db 08 	lds	r30, 0x08DB	; 0x8008db <__brkval>
    24f4:	f0 91 dc 08 	lds	r31, 0x08DC	; 0x8008dc <__brkval+0x1>
    24f8:	e2 17       	cp	r30, r18
    24fa:	f3 07       	cpc	r31, r19
    24fc:	a0 f4       	brcc	.+40     	; 0x2526 <malloc+0x120>
    24fe:	2e 1b       	sub	r18, r30
    2500:	3f 0b       	sbc	r19, r31
    2502:	28 17       	cp	r18, r24
    2504:	39 07       	cpc	r19, r25
    2506:	78 f0       	brcs	.+30     	; 0x2526 <malloc+0x120>
    2508:	ac 01       	movw	r20, r24
    250a:	4e 5f       	subi	r20, 0xFE	; 254
    250c:	5f 4f       	sbci	r21, 0xFF	; 255
    250e:	24 17       	cp	r18, r20
    2510:	35 07       	cpc	r19, r21
    2512:	48 f0       	brcs	.+18     	; 0x2526 <malloc+0x120>
    2514:	4e 0f       	add	r20, r30
    2516:	5f 1f       	adc	r21, r31
    2518:	50 93 dc 08 	sts	0x08DC, r21	; 0x8008dc <__brkval+0x1>
    251c:	40 93 db 08 	sts	0x08DB, r20	; 0x8008db <__brkval>
    2520:	81 93       	st	Z+, r24
    2522:	91 93       	st	Z+, r25
    2524:	02 c0       	rjmp	.+4      	; 0x252a <malloc+0x124>
    2526:	e0 e0       	ldi	r30, 0x00	; 0
    2528:	f0 e0       	ldi	r31, 0x00	; 0
    252a:	cf 01       	movw	r24, r30
    252c:	df 91       	pop	r29
    252e:	cf 91       	pop	r28
    2530:	1f 91       	pop	r17
    2532:	0f 91       	pop	r16
    2534:	08 95       	ret

00002536 <free>:
    2536:	cf 93       	push	r28
    2538:	df 93       	push	r29
    253a:	00 97       	sbiw	r24, 0x00	; 0
    253c:	09 f4       	brne	.+2      	; 0x2540 <free+0xa>
    253e:	81 c0       	rjmp	.+258    	; 0x2642 <free+0x10c>
    2540:	fc 01       	movw	r30, r24
    2542:	32 97       	sbiw	r30, 0x02	; 2
    2544:	13 82       	std	Z+3, r1	; 0x03
    2546:	12 82       	std	Z+2, r1	; 0x02
    2548:	a0 91 dd 08 	lds	r26, 0x08DD	; 0x8008dd <__flp>
    254c:	b0 91 de 08 	lds	r27, 0x08DE	; 0x8008de <__flp+0x1>
    2550:	10 97       	sbiw	r26, 0x00	; 0
    2552:	81 f4       	brne	.+32     	; 0x2574 <free+0x3e>
    2554:	20 81       	ld	r18, Z
    2556:	31 81       	ldd	r19, Z+1	; 0x01
    2558:	82 0f       	add	r24, r18
    255a:	93 1f       	adc	r25, r19
    255c:	20 91 db 08 	lds	r18, 0x08DB	; 0x8008db <__brkval>
    2560:	30 91 dc 08 	lds	r19, 0x08DC	; 0x8008dc <__brkval+0x1>
    2564:	28 17       	cp	r18, r24
    2566:	39 07       	cpc	r19, r25
    2568:	51 f5       	brne	.+84     	; 0x25be <free+0x88>
    256a:	f0 93 dc 08 	sts	0x08DC, r31	; 0x8008dc <__brkval+0x1>
    256e:	e0 93 db 08 	sts	0x08DB, r30	; 0x8008db <__brkval>
    2572:	67 c0       	rjmp	.+206    	; 0x2642 <free+0x10c>
    2574:	ed 01       	movw	r28, r26
    2576:	20 e0       	ldi	r18, 0x00	; 0
    2578:	30 e0       	ldi	r19, 0x00	; 0
    257a:	ce 17       	cp	r28, r30
    257c:	df 07       	cpc	r29, r31
    257e:	40 f4       	brcc	.+16     	; 0x2590 <free+0x5a>
    2580:	4a 81       	ldd	r20, Y+2	; 0x02
    2582:	5b 81       	ldd	r21, Y+3	; 0x03
    2584:	9e 01       	movw	r18, r28
    2586:	41 15       	cp	r20, r1
    2588:	51 05       	cpc	r21, r1
    258a:	f1 f0       	breq	.+60     	; 0x25c8 <free+0x92>
    258c:	ea 01       	movw	r28, r20
    258e:	f5 cf       	rjmp	.-22     	; 0x257a <free+0x44>
    2590:	d3 83       	std	Z+3, r29	; 0x03
    2592:	c2 83       	std	Z+2, r28	; 0x02
    2594:	40 81       	ld	r20, Z
    2596:	51 81       	ldd	r21, Z+1	; 0x01
    2598:	84 0f       	add	r24, r20
    259a:	95 1f       	adc	r25, r21
    259c:	c8 17       	cp	r28, r24
    259e:	d9 07       	cpc	r29, r25
    25a0:	59 f4       	brne	.+22     	; 0x25b8 <free+0x82>
    25a2:	88 81       	ld	r24, Y
    25a4:	99 81       	ldd	r25, Y+1	; 0x01
    25a6:	84 0f       	add	r24, r20
    25a8:	95 1f       	adc	r25, r21
    25aa:	02 96       	adiw	r24, 0x02	; 2
    25ac:	91 83       	std	Z+1, r25	; 0x01
    25ae:	80 83       	st	Z, r24
    25b0:	8a 81       	ldd	r24, Y+2	; 0x02
    25b2:	9b 81       	ldd	r25, Y+3	; 0x03
    25b4:	93 83       	std	Z+3, r25	; 0x03
    25b6:	82 83       	std	Z+2, r24	; 0x02
    25b8:	21 15       	cp	r18, r1
    25ba:	31 05       	cpc	r19, r1
    25bc:	29 f4       	brne	.+10     	; 0x25c8 <free+0x92>
    25be:	f0 93 de 08 	sts	0x08DE, r31	; 0x8008de <__flp+0x1>
    25c2:	e0 93 dd 08 	sts	0x08DD, r30	; 0x8008dd <__flp>
    25c6:	3d c0       	rjmp	.+122    	; 0x2642 <free+0x10c>
    25c8:	e9 01       	movw	r28, r18
    25ca:	fb 83       	std	Y+3, r31	; 0x03
    25cc:	ea 83       	std	Y+2, r30	; 0x02
    25ce:	49 91       	ld	r20, Y+
    25d0:	59 91       	ld	r21, Y+
    25d2:	c4 0f       	add	r28, r20
    25d4:	d5 1f       	adc	r29, r21
    25d6:	ec 17       	cp	r30, r28
    25d8:	fd 07       	cpc	r31, r29
    25da:	61 f4       	brne	.+24     	; 0x25f4 <free+0xbe>
    25dc:	80 81       	ld	r24, Z
    25de:	91 81       	ldd	r25, Z+1	; 0x01
    25e0:	84 0f       	add	r24, r20
    25e2:	95 1f       	adc	r25, r21
    25e4:	02 96       	adiw	r24, 0x02	; 2
    25e6:	e9 01       	movw	r28, r18
    25e8:	99 83       	std	Y+1, r25	; 0x01
    25ea:	88 83       	st	Y, r24
    25ec:	82 81       	ldd	r24, Z+2	; 0x02
    25ee:	93 81       	ldd	r25, Z+3	; 0x03
    25f0:	9b 83       	std	Y+3, r25	; 0x03
    25f2:	8a 83       	std	Y+2, r24	; 0x02
    25f4:	e0 e0       	ldi	r30, 0x00	; 0
    25f6:	f0 e0       	ldi	r31, 0x00	; 0
    25f8:	12 96       	adiw	r26, 0x02	; 2
    25fa:	8d 91       	ld	r24, X+
    25fc:	9c 91       	ld	r25, X
    25fe:	13 97       	sbiw	r26, 0x03	; 3
    2600:	00 97       	sbiw	r24, 0x00	; 0
    2602:	19 f0       	breq	.+6      	; 0x260a <free+0xd4>
    2604:	fd 01       	movw	r30, r26
    2606:	dc 01       	movw	r26, r24
    2608:	f7 cf       	rjmp	.-18     	; 0x25f8 <free+0xc2>
    260a:	8d 91       	ld	r24, X+
    260c:	9c 91       	ld	r25, X
    260e:	11 97       	sbiw	r26, 0x01	; 1
    2610:	9d 01       	movw	r18, r26
    2612:	2e 5f       	subi	r18, 0xFE	; 254
    2614:	3f 4f       	sbci	r19, 0xFF	; 255
    2616:	82 0f       	add	r24, r18
    2618:	93 1f       	adc	r25, r19
    261a:	20 91 db 08 	lds	r18, 0x08DB	; 0x8008db <__brkval>
    261e:	30 91 dc 08 	lds	r19, 0x08DC	; 0x8008dc <__brkval+0x1>
    2622:	28 17       	cp	r18, r24
    2624:	39 07       	cpc	r19, r25
    2626:	69 f4       	brne	.+26     	; 0x2642 <free+0x10c>
    2628:	30 97       	sbiw	r30, 0x00	; 0
    262a:	29 f4       	brne	.+10     	; 0x2636 <free+0x100>
    262c:	10 92 de 08 	sts	0x08DE, r1	; 0x8008de <__flp+0x1>
    2630:	10 92 dd 08 	sts	0x08DD, r1	; 0x8008dd <__flp>
    2634:	02 c0       	rjmp	.+4      	; 0x263a <free+0x104>
    2636:	13 82       	std	Z+3, r1	; 0x03
    2638:	12 82       	std	Z+2, r1	; 0x02
    263a:	b0 93 dc 08 	sts	0x08DC, r27	; 0x8008dc <__brkval+0x1>
    263e:	a0 93 db 08 	sts	0x08DB, r26	; 0x8008db <__brkval>
    2642:	df 91       	pop	r29
    2644:	cf 91       	pop	r28
    2646:	08 95       	ret

00002648 <memset>:
    2648:	dc 01       	movw	r26, r24
    264a:	01 c0       	rjmp	.+2      	; 0x264e <memset+0x6>
    264c:	6d 93       	st	X+, r22
    264e:	41 50       	subi	r20, 0x01	; 1
    2650:	50 40       	sbci	r21, 0x00	; 0
    2652:	e0 f7       	brcc	.-8      	; 0x264c <memset+0x4>
    2654:	08 95       	ret

00002656 <strncpy>:
    2656:	fb 01       	movw	r30, r22
    2658:	dc 01       	movw	r26, r24
    265a:	41 50       	subi	r20, 0x01	; 1
    265c:	50 40       	sbci	r21, 0x00	; 0
    265e:	48 f0       	brcs	.+18     	; 0x2672 <strncpy+0x1c>
    2660:	01 90       	ld	r0, Z+
    2662:	0d 92       	st	X+, r0
    2664:	00 20       	and	r0, r0
    2666:	c9 f7       	brne	.-14     	; 0x265a <strncpy+0x4>
    2668:	01 c0       	rjmp	.+2      	; 0x266c <strncpy+0x16>
    266a:	1d 92       	st	X+, r1
    266c:	41 50       	subi	r20, 0x01	; 1
    266e:	50 40       	sbci	r21, 0x00	; 0
    2670:	e0 f7       	brcc	.-8      	; 0x266a <strncpy+0x14>
    2672:	08 95       	ret

00002674 <_exit>:
    2674:	f8 94       	cli

00002676 <__stop_program>:
    2676:	ff cf       	rjmp	.-2      	; 0x2676 <__stop_program>
