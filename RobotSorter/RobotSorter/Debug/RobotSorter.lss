
RobotSorter.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000000fa  00800200  00003eba  00003f4e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00003eba  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000fea  008002fa  008002fa  00004048  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00004048  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00004078  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000006f0  00000000  00000000  000040b8  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000b689  00000000  00000000  000047a8  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00003ab6  00000000  00000000  0000fe31  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00005db0  00000000  00000000  000138e7  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001364  00000000  00000000  00019698  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000025de  00000000  00000000  0001a9fc  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000088dc  00000000  00000000  0001cfda  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000e78  00000000  00000000  000258b6  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	73 c0       	rjmp	.+230    	; 0xe8 <__dtors_end>
       2:	00 00       	nop
       4:	a1 c0       	rjmp	.+322    	; 0x148 <__bad_interrupt>
       6:	00 00       	nop
       8:	9f c0       	rjmp	.+318    	; 0x148 <__bad_interrupt>
       a:	00 00       	nop
       c:	9d c0       	rjmp	.+314    	; 0x148 <__bad_interrupt>
       e:	00 00       	nop
      10:	9b c0       	rjmp	.+310    	; 0x148 <__bad_interrupt>
      12:	00 00       	nop
      14:	0c 94 01 16 	jmp	0x2c02	; 0x2c02 <__vector_5>
      18:	97 c0       	rjmp	.+302    	; 0x148 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	95 c0       	rjmp	.+298    	; 0x148 <__bad_interrupt>
      1e:	00 00       	nop
      20:	93 c0       	rjmp	.+294    	; 0x148 <__bad_interrupt>
      22:	00 00       	nop
      24:	91 c0       	rjmp	.+290    	; 0x148 <__bad_interrupt>
      26:	00 00       	nop
      28:	8f c0       	rjmp	.+286    	; 0x148 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	8d c0       	rjmp	.+282    	; 0x148 <__bad_interrupt>
      2e:	00 00       	nop
      30:	8b c0       	rjmp	.+278    	; 0x148 <__bad_interrupt>
      32:	00 00       	nop
      34:	89 c0       	rjmp	.+274    	; 0x148 <__bad_interrupt>
      36:	00 00       	nop
      38:	87 c0       	rjmp	.+270    	; 0x148 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	85 c0       	rjmp	.+266    	; 0x148 <__bad_interrupt>
      3e:	00 00       	nop
      40:	83 c0       	rjmp	.+262    	; 0x148 <__bad_interrupt>
      42:	00 00       	nop
      44:	81 c0       	rjmp	.+258    	; 0x148 <__bad_interrupt>
      46:	00 00       	nop
      48:	7f c0       	rjmp	.+254    	; 0x148 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	7d c0       	rjmp	.+250    	; 0x148 <__bad_interrupt>
      4e:	00 00       	nop
      50:	7b c0       	rjmp	.+246    	; 0x148 <__bad_interrupt>
      52:	00 00       	nop
      54:	0c 94 be 0f 	jmp	0x1f7c	; 0x1f7c <__vector_21>
      58:	77 c0       	rjmp	.+238    	; 0x148 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	75 c0       	rjmp	.+234    	; 0x148 <__bad_interrupt>
      5e:	00 00       	nop
      60:	73 c0       	rjmp	.+230    	; 0x148 <__bad_interrupt>
      62:	00 00       	nop
      64:	71 c0       	rjmp	.+226    	; 0x148 <__bad_interrupt>
      66:	00 00       	nop
      68:	6f c0       	rjmp	.+222    	; 0x148 <__bad_interrupt>
      6a:	00 00       	nop
      6c:	6d c0       	rjmp	.+218    	; 0x148 <__bad_interrupt>
      6e:	00 00       	nop
      70:	6b c0       	rjmp	.+214    	; 0x148 <__bad_interrupt>
      72:	00 00       	nop
      74:	69 c0       	rjmp	.+210    	; 0x148 <__bad_interrupt>
      76:	00 00       	nop
      78:	67 c0       	rjmp	.+206    	; 0x148 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	65 c0       	rjmp	.+202    	; 0x148 <__bad_interrupt>
      7e:	00 00       	nop
      80:	63 c0       	rjmp	.+198    	; 0x148 <__bad_interrupt>
      82:	00 00       	nop
      84:	61 c0       	rjmp	.+194    	; 0x148 <__bad_interrupt>
      86:	00 00       	nop
      88:	5f c0       	rjmp	.+190    	; 0x148 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	5d c0       	rjmp	.+186    	; 0x148 <__bad_interrupt>
      8e:	00 00       	nop
      90:	5b c0       	rjmp	.+182    	; 0x148 <__bad_interrupt>
      92:	00 00       	nop
      94:	59 c0       	rjmp	.+178    	; 0x148 <__bad_interrupt>
      96:	00 00       	nop
      98:	57 c0       	rjmp	.+174    	; 0x148 <__bad_interrupt>
      9a:	00 00       	nop
      9c:	55 c0       	rjmp	.+170    	; 0x148 <__bad_interrupt>
      9e:	00 00       	nop
      a0:	53 c0       	rjmp	.+166    	; 0x148 <__bad_interrupt>
      a2:	00 00       	nop
      a4:	29 c2       	rjmp	.+1106   	; 0x4f8 <__vector_41>
      a6:	00 00       	nop
      a8:	4f c0       	rjmp	.+158    	; 0x148 <__bad_interrupt>
      aa:	00 00       	nop
      ac:	4d c0       	rjmp	.+154    	; 0x148 <__bad_interrupt>
      ae:	00 00       	nop
      b0:	4b c0       	rjmp	.+150    	; 0x148 <__bad_interrupt>
      b2:	00 00       	nop
      b4:	fc c1       	rjmp	.+1016   	; 0x4ae <__vector_45>
      b6:	00 00       	nop
      b8:	47 c0       	rjmp	.+142    	; 0x148 <__bad_interrupt>
      ba:	00 00       	nop
      bc:	45 c0       	rjmp	.+138    	; 0x148 <__bad_interrupt>
      be:	00 00       	nop
      c0:	43 c0       	rjmp	.+134    	; 0x148 <__bad_interrupt>
      c2:	00 00       	nop
      c4:	41 c0       	rjmp	.+130    	; 0x148 <__bad_interrupt>
      c6:	00 00       	nop
      c8:	3f c0       	rjmp	.+126    	; 0x148 <__bad_interrupt>
      ca:	00 00       	nop
      cc:	3d c0       	rjmp	.+122    	; 0x148 <__bad_interrupt>
      ce:	00 00       	nop
      d0:	3b c0       	rjmp	.+118    	; 0x148 <__bad_interrupt>
      d2:	00 00       	nop
      d4:	39 c0       	rjmp	.+114    	; 0x148 <__bad_interrupt>
      d6:	00 00       	nop
      d8:	37 c0       	rjmp	.+110    	; 0x148 <__bad_interrupt>
      da:	00 00       	nop
      dc:	35 c0       	rjmp	.+106    	; 0x148 <__bad_interrupt>
      de:	00 00       	nop
      e0:	33 c0       	rjmp	.+102    	; 0x148 <__bad_interrupt>
	...

000000e4 <__ctors_start>:
      e4:	7e 04       	cpc	r7, r14

000000e6 <__ctors_end>:
      e6:	81 04       	cpc	r8, r1

000000e8 <__dtors_end>:
      e8:	11 24       	eor	r1, r1
      ea:	1f be       	out	0x3f, r1	; 63
      ec:	cf ef       	ldi	r28, 0xFF	; 255
      ee:	d1 e2       	ldi	r29, 0x21	; 33
      f0:	de bf       	out	0x3e, r29	; 62
      f2:	cd bf       	out	0x3d, r28	; 61
      f4:	00 e0       	ldi	r16, 0x00	; 0
      f6:	0c bf       	out	0x3c, r16	; 60

000000f8 <__do_copy_data>:
      f8:	12 e0       	ldi	r17, 0x02	; 2
      fa:	a0 e0       	ldi	r26, 0x00	; 0
      fc:	b2 e0       	ldi	r27, 0x02	; 2
      fe:	ea eb       	ldi	r30, 0xBA	; 186
     100:	fe e3       	ldi	r31, 0x3E	; 62
     102:	00 e0       	ldi	r16, 0x00	; 0
     104:	0b bf       	out	0x3b, r16	; 59
     106:	02 c0       	rjmp	.+4      	; 0x10c <__do_copy_data+0x14>
     108:	07 90       	elpm	r0, Z+
     10a:	0d 92       	st	X+, r0
     10c:	aa 3f       	cpi	r26, 0xFA	; 250
     10e:	b1 07       	cpc	r27, r17
     110:	d9 f7       	brne	.-10     	; 0x108 <__do_copy_data+0x10>

00000112 <__do_clear_bss>:
     112:	22 e1       	ldi	r18, 0x12	; 18
     114:	aa ef       	ldi	r26, 0xFA	; 250
     116:	b2 e0       	ldi	r27, 0x02	; 2
     118:	01 c0       	rjmp	.+2      	; 0x11c <.do_clear_bss_start>

0000011a <.do_clear_bss_loop>:
     11a:	1d 92       	st	X+, r1

0000011c <.do_clear_bss_start>:
     11c:	a4 3e       	cpi	r26, 0xE4	; 228
     11e:	b2 07       	cpc	r27, r18
     120:	e1 f7       	brne	.-8      	; 0x11a <.do_clear_bss_loop>

00000122 <__do_global_ctors>:
     122:	10 e0       	ldi	r17, 0x00	; 0
     124:	c3 e7       	ldi	r28, 0x73	; 115
     126:	d0 e0       	ldi	r29, 0x00	; 0
     128:	00 e0       	ldi	r16, 0x00	; 0
     12a:	06 c0       	rjmp	.+12     	; 0x138 <__do_global_ctors+0x16>
     12c:	21 97       	sbiw	r28, 0x01	; 1
     12e:	01 09       	sbc	r16, r1
     130:	80 2f       	mov	r24, r16
     132:	fe 01       	movw	r30, r28
     134:	0e 94 0d 1e 	call	0x3c1a	; 0x3c1a <__tablejump2__>
     138:	c2 37       	cpi	r28, 0x72	; 114
     13a:	d1 07       	cpc	r29, r17
     13c:	80 e0       	ldi	r24, 0x00	; 0
     13e:	08 07       	cpc	r16, r24
     140:	a9 f7       	brne	.-22     	; 0x12c <__do_global_ctors+0xa>
     142:	b0 d3       	rcall	.+1888   	; 0x8a4 <main>
     144:	0c 94 4c 1f 	jmp	0x3e98	; 0x3e98 <__do_global_dtors>

00000148 <__bad_interrupt>:
     148:	5b cf       	rjmp	.-330    	; 0x0 <__vectors>

0000014a <_ZN5ColorC1Ev>:
}

uint8_t Color::getColorIndex( void )
{
	return _colorIndex;
}
     14a:	fc 01       	movw	r30, r24
     14c:	11 82       	std	Z+1, r1	; 0x01
     14e:	10 82       	st	Z, r1
     150:	13 82       	std	Z+3, r1	; 0x03
     152:	12 82       	std	Z+2, r1	; 0x02
     154:	15 82       	std	Z+5, r1	; 0x05
     156:	14 82       	std	Z+4, r1	; 0x04
     158:	17 82       	std	Z+7, r1	; 0x07
     15a:	16 82       	std	Z+6, r1	; 0x06
     15c:	8f ef       	ldi	r24, 0xFF	; 255
     15e:	80 87       	std	Z+8, r24	; 0x08
     160:	08 95       	ret

00000162 <_ZN5Color12getRedPeriodEv>:
     162:	fc 01       	movw	r30, r24
     164:	80 81       	ld	r24, Z
     166:	91 81       	ldd	r25, Z+1	; 0x01
     168:	08 95       	ret

0000016a <_ZN5Color13getBluePeriodEv>:
     16a:	fc 01       	movw	r30, r24
     16c:	82 81       	ldd	r24, Z+2	; 0x02
     16e:	93 81       	ldd	r25, Z+3	; 0x03
     170:	08 95       	ret

00000172 <_ZN5Color14getGreenPeriodEv>:
     172:	fc 01       	movw	r30, r24
     174:	84 81       	ldd	r24, Z+4	; 0x04
     176:	95 81       	ldd	r25, Z+5	; 0x05
     178:	08 95       	ret

0000017a <_ZN5Color14getWhitePeriodEv>:
     17a:	fc 01       	movw	r30, r24
     17c:	86 81       	ldd	r24, Z+6	; 0x06
     17e:	97 81       	ldd	r25, Z+7	; 0x07
     180:	08 95       	ret

00000182 <_ZN5Color12setRedPeriodEj>:

void Color::setRedPeriod( uint16_t redPeriod )
{
	_redPeriod = redPeriod;
     182:	fc 01       	movw	r30, r24
     184:	71 83       	std	Z+1, r23	; 0x01
     186:	60 83       	st	Z, r22
     188:	08 95       	ret

0000018a <_ZN5Color13setBluePeriodEj>:
}

void Color::setBluePeriod( uint16_t bluePeriod )
{
	_bluePeriod = bluePeriod;
     18a:	fc 01       	movw	r30, r24
     18c:	73 83       	std	Z+3, r23	; 0x03
     18e:	62 83       	std	Z+2, r22	; 0x02
     190:	08 95       	ret

00000192 <_ZN5Color14setGreenPeriodEj>:
}

void Color::setGreenPeriod( uint16_t greenPeriod )
{
	_greenPeriod = greenPeriod;
     192:	fc 01       	movw	r30, r24
     194:	75 83       	std	Z+5, r23	; 0x05
     196:	64 83       	std	Z+4, r22	; 0x04
     198:	08 95       	ret

0000019a <_ZN5Color14setWhitePeriodEj>:
}

void Color::setWhitePeriod( uint16_t whitePeriod )
{
	_whitePeriod = whitePeriod;
     19a:	fc 01       	movw	r30, r24
     19c:	77 83       	std	Z+7, r23	; 0x07
     19e:	66 83       	std	Z+6, r22	; 0x06
     1a0:	08 95       	ret

000001a2 <_ZN5Color13setColorIndexEh>:
}

void Color::setColorIndex( uint8_t index )
{
	_colorIndex = index;
     1a2:	fc 01       	movw	r30, r24
     1a4:	60 87       	std	Z+8, r22	; 0x08
     1a6:	08 95       	ret

000001a8 <_ZN11ColorSensorC1E16FrequencyScaling>:
}

// default destructor
ColorSensor::~ColorSensor()
{	
}
     1a8:	df 92       	push	r13
     1aa:	ef 92       	push	r14
     1ac:	ff 92       	push	r15
     1ae:	0f 93       	push	r16
     1b0:	1f 93       	push	r17
     1b2:	cf 93       	push	r28
     1b4:	df 93       	push	r29
     1b6:	1f 92       	push	r1
     1b8:	cd b7       	in	r28, 0x3d	; 61
     1ba:	de b7       	in	r29, 0x3e	; 62
     1bc:	7c 01       	movw	r14, r24
     1be:	d6 2e       	mov	r13, r22
     1c0:	1f d1       	rcall	.+574    	; 0x400 <_ZN6Timer4C1Ev>
     1c2:	87 01       	movw	r16, r14
     1c4:	0f 5f       	subi	r16, 0xFF	; 255
     1c6:	1f 4f       	sbci	r17, 0xFF	; 255
     1c8:	8b e5       	ldi	r24, 0x5B	; 91
     1ca:	e8 0e       	add	r14, r24
     1cc:	f1 1c       	adc	r15, r1
     1ce:	c8 01       	movw	r24, r16
     1d0:	bc df       	rcall	.-136    	; 0x14a <_ZN5ColorC1Ev>
     1d2:	07 5f       	subi	r16, 0xF7	; 247
     1d4:	1f 4f       	sbci	r17, 0xFF	; 255
     1d6:	0e 15       	cp	r16, r14
     1d8:	1f 05       	cpc	r17, r15
     1da:	c9 f7       	brne	.-14     	; 0x1ce <_ZN11ColorSensorC1E16FrequencyScaling+0x26>
     1dc:	ce 01       	movw	r24, r28
     1de:	01 96       	adiw	r24, 0x01	; 1
     1e0:	0f d1       	rcall	.+542    	; 0x400 <_ZN6Timer4C1Ev>
     1e2:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
     1e6:	81 60       	ori	r24, 0x01	; 1
     1e8:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
     1ec:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
     1f0:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
     1f4:	81 e0       	ldi	r24, 0x01	; 1
     1f6:	d8 16       	cp	r13, r24
     1f8:	d1 f0       	breq	.+52     	; 0x22e <_ZN11ColorSensorC1E16FrequencyScaling+0x86>
     1fa:	d8 16       	cp	r13, r24
     1fc:	c0 f0       	brcs	.+48     	; 0x22e <_ZN11ColorSensorC1E16FrequencyScaling+0x86>
     1fe:	82 e0       	ldi	r24, 0x02	; 2
     200:	d8 16       	cp	r13, r24
     202:	19 f0       	breq	.+6      	; 0x20a <_ZN11ColorSensorC1E16FrequencyScaling+0x62>
     204:	83 e0       	ldi	r24, 0x03	; 3
     206:	d8 12       	cpse	r13, r24
     208:	09 c0       	rjmp	.+18     	; 0x21c <_ZN11ColorSensorC1E16FrequencyScaling+0x74>
     20a:	80 91 05 01 	lds	r24, 0x0105	; 0x800105 <__TEXT_REGION_LENGTH__+0x700105>
     20e:	81 60       	ori	r24, 0x01	; 1
     210:	80 93 05 01 	sts	0x0105, r24	; 0x800105 <__TEXT_REGION_LENGTH__+0x700105>
     214:	80 91 05 01 	lds	r24, 0x0105	; 0x800105 <__TEXT_REGION_LENGTH__+0x700105>
     218:	80 93 05 01 	sts	0x0105, r24	; 0x800105 <__TEXT_REGION_LENGTH__+0x700105>
     21c:	0f 90       	pop	r0
     21e:	df 91       	pop	r29
     220:	cf 91       	pop	r28
     222:	1f 91       	pop	r17
     224:	0f 91       	pop	r16
     226:	ff 90       	pop	r15
     228:	ef 90       	pop	r14
     22a:	df 90       	pop	r13
     22c:	08 95       	ret
     22e:	80 91 05 01 	lds	r24, 0x0105	; 0x800105 <__TEXT_REGION_LENGTH__+0x700105>
     232:	8e 7f       	andi	r24, 0xFE	; 254
     234:	80 93 05 01 	sts	0x0105, r24	; 0x800105 <__TEXT_REGION_LENGTH__+0x700105>
     238:	80 91 05 01 	lds	r24, 0x0105	; 0x800105 <__TEXT_REGION_LENGTH__+0x700105>
     23c:	80 93 05 01 	sts	0x0105, r24	; 0x800105 <__TEXT_REGION_LENGTH__+0x700105>
     240:	ed cf       	rjmp	.-38     	; 0x21c <_ZN11ColorSensorC1E16FrequencyScaling+0x74>

00000242 <_ZN11ColorSensor8getColorEv>:

uint8_t ColorSensor::getColor()
{
     242:	8f 92       	push	r8
     244:	9f 92       	push	r9
     246:	af 92       	push	r10
     248:	bf 92       	push	r11
     24a:	cf 92       	push	r12
     24c:	df 92       	push	r13
     24e:	ef 92       	push	r14
     250:	ff 92       	push	r15
     252:	1f 93       	push	r17
     254:	cf 93       	push	r28
     256:	df 93       	push	r29
     258:	ec 01       	movw	r28, r24
void ColorSensor::setFilter( Filter filter_ )
{
	switch ( filter_ )
	{
	case redFilter:
		COLORSENSOR_S2_PORT &= ~( COLORSENSOR_S2_PIN );
     25a:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
     25e:	8e 7f       	andi	r24, 0xFE	; 254
     260:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
		COLORSENSOR_S3_PORT &= ~( COLORSENSOR_S3_PIN );
     264:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
     268:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
{
	uint8_t result = 255;
	
	// Get period values from all filters
	setFilter( redFilter );
	uint16_t redPeriod = frequency_.getPeriod();
     26c:	ce 01       	movw	r24, r28
     26e:	e7 d0       	rcall	.+462    	; 0x43e <_ZN6Timer49getPeriodEv>
     270:	7c 01       	movw	r14, r24
		COLORSENSOR_S2_PORT &= ~( COLORSENSOR_S2_PIN );
		COLORSENSOR_S3_PORT &= ~( COLORSENSOR_S3_PIN );
		break;

	case blueFilter:
		COLORSENSOR_S2_PORT &= ~( COLORSENSOR_S2_PIN );
     272:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
     276:	8e 7f       	andi	r24, 0xFE	; 254
     278:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
		COLORSENSOR_S3_PORT |= COLORSENSOR_S3_PIN;
     27c:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
     280:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
	// Get period values from all filters
	setFilter( redFilter );
	uint16_t redPeriod = frequency_.getPeriod();

	setFilter( blueFilter );
	uint16_t bluePeriod = frequency_.getPeriod();  
     284:	ce 01       	movw	r24, r28
     286:	db d0       	rcall	.+438    	; 0x43e <_ZN6Timer49getPeriodEv>
     288:	6c 01       	movw	r12, r24
		COLORSENSOR_S2_PORT &= ~( COLORSENSOR_S2_PIN );
		COLORSENSOR_S3_PORT |= COLORSENSOR_S3_PIN;
		break;

	case greenFilter:
		COLORSENSOR_S2_PORT |= COLORSENSOR_S2_PIN;
     28a:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
     28e:	81 60       	ori	r24, 0x01	; 1
     290:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
		COLORSENSOR_S3_PORT |= COLORSENSOR_S3_PIN;
     294:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
     298:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>

	setFilter( blueFilter );
	uint16_t bluePeriod = frequency_.getPeriod();  

	setFilter( greenFilter );
	uint16_t greenPeriod = frequency_.getPeriod();
     29c:	ce 01       	movw	r24, r28
     29e:	cf d0       	rcall	.+414    	; 0x43e <_ZN6Timer49getPeriodEv>
     2a0:	5c 01       	movw	r10, r24
		COLORSENSOR_S2_PORT |= COLORSENSOR_S2_PIN;
		COLORSENSOR_S3_PORT |= COLORSENSOR_S3_PIN;
		break;

	case noFilter:
		COLORSENSOR_S2_PORT |= COLORSENSOR_S2_PIN;
     2a2:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
     2a6:	81 60       	ori	r24, 0x01	; 1
     2a8:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
		COLORSENSOR_S3_PORT &= ~( COLORSENSOR_S3_PIN );
     2ac:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
     2b0:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>

	setFilter( greenFilter );
	uint16_t greenPeriod = frequency_.getPeriod();
	
	setFilter( noFilter );
	uint16_t whitePeriod = frequency_.getPeriod();
     2b4:	ce 01       	movw	r24, r28
     2b6:	c3 d0       	rcall	.+390    	; 0x43e <_ZN6Timer49getPeriodEv>
     2b8:	4c 01       	movw	r8, r24
     2ba:	21 96       	adiw	r28, 0x01	; 1
	
	// Check all stored colors against read values	
	for ( uint8_t index = 0U; index < 10; index++)
     2bc:	10 e0       	ldi	r17, 0x00	; 0
     2be:	04 c0       	rjmp	.+8      	; 0x2c8 <_ZN11ColorSensor8getColorEv+0x86>
     2c0:	1f 5f       	subi	r17, 0xFF	; 255
     2c2:	29 96       	adiw	r28, 0x09	; 9
     2c4:	1a 30       	cpi	r17, 0x0A	; 10
	{		
		if ( _colors[index].getRedPeriod() + 5 > redPeriod && _colors[index].getRedPeriod() - 5 < redPeriod )
     2c6:	89 f1       	breq	.+98     	; 0x32a <_ZN11ColorSensor8getColorEv+0xe8>
     2c8:	ce 01       	movw	r24, r28
     2ca:	4b df       	rcall	.-362    	; 0x162 <_ZN5Color12getRedPeriodEv>
     2cc:	05 96       	adiw	r24, 0x05	; 5
     2ce:	e8 16       	cp	r14, r24
     2d0:	f9 06       	cpc	r15, r25
     2d2:	b0 f7       	brcc	.-20     	; 0x2c0 <_ZN11ColorSensor8getColorEv+0x7e>
     2d4:	ce 01       	movw	r24, r28
     2d6:	45 df       	rcall	.-374    	; 0x162 <_ZN5Color12getRedPeriodEv>
     2d8:	05 97       	sbiw	r24, 0x05	; 5
     2da:	8e 15       	cp	r24, r14
     2dc:	9f 05       	cpc	r25, r15
		{
 			if ( _colors[index].getBluePeriod() + 5 > bluePeriod && _colors[index].getBluePeriod() - 5 < bluePeriod )
     2de:	80 f7       	brcc	.-32     	; 0x2c0 <_ZN11ColorSensor8getColorEv+0x7e>
     2e0:	ce 01       	movw	r24, r28
     2e2:	43 df       	rcall	.-378    	; 0x16a <_ZN5Color13getBluePeriodEv>
     2e4:	05 96       	adiw	r24, 0x05	; 5
     2e6:	c8 16       	cp	r12, r24
     2e8:	d9 06       	cpc	r13, r25
     2ea:	50 f7       	brcc	.-44     	; 0x2c0 <_ZN11ColorSensor8getColorEv+0x7e>
     2ec:	ce 01       	movw	r24, r28
     2ee:	3d df       	rcall	.-390    	; 0x16a <_ZN5Color13getBluePeriodEv>
     2f0:	05 97       	sbiw	r24, 0x05	; 5
     2f2:	8c 15       	cp	r24, r12
     2f4:	9d 05       	cpc	r25, r13
			{
				if ( _colors[index].getGreenPeriod() + 5 > greenPeriod && _colors[index].getGreenPeriod() - 5 < greenPeriod )
     2f6:	20 f7       	brcc	.-56     	; 0x2c0 <_ZN11ColorSensor8getColorEv+0x7e>
     2f8:	ce 01       	movw	r24, r28
     2fa:	3b df       	rcall	.-394    	; 0x172 <_ZN5Color14getGreenPeriodEv>
     2fc:	05 96       	adiw	r24, 0x05	; 5
     2fe:	a8 16       	cp	r10, r24
     300:	b9 06       	cpc	r11, r25
     302:	f0 f6       	brcc	.-68     	; 0x2c0 <_ZN11ColorSensor8getColorEv+0x7e>
     304:	ce 01       	movw	r24, r28
     306:	35 df       	rcall	.-406    	; 0x172 <_ZN5Color14getGreenPeriodEv>
     308:	05 97       	sbiw	r24, 0x05	; 5
     30a:	8a 15       	cp	r24, r10
     30c:	9b 05       	cpc	r25, r11
				{
					if ( _colors[index].getWhitePeriod() + 2 > whitePeriod && _colors[index].getWhitePeriod() - 2 < whitePeriod )
     30e:	c0 f6       	brcc	.-80     	; 0x2c0 <_ZN11ColorSensor8getColorEv+0x7e>
     310:	ce 01       	movw	r24, r28
     312:	33 df       	rcall	.-410    	; 0x17a <_ZN5Color14getWhitePeriodEv>
     314:	02 96       	adiw	r24, 0x02	; 2
     316:	88 16       	cp	r8, r24
     318:	99 06       	cpc	r9, r25
     31a:	90 f6       	brcc	.-92     	; 0x2c0 <_ZN11ColorSensor8getColorEv+0x7e>
     31c:	ce 01       	movw	r24, r28
     31e:	2d df       	rcall	.-422    	; 0x17a <_ZN5Color14getWhitePeriodEv>
     320:	02 97       	sbiw	r24, 0x02	; 2
     322:	88 15       	cp	r24, r8
     324:	99 05       	cpc	r25, r9
     326:	60 f6       	brcc	.-104    	; 0x2c0 <_ZN11ColorSensor8getColorEv+0x7e>
     328:	01 c0       	rjmp	.+2      	; 0x32c <_ZN11ColorSensor8getColorEv+0xea>
     32a:	1f ef       	ldi	r17, 0xFF	; 255
{	
}

uint8_t ColorSensor::getColor()
{
	uint8_t result = 255;
     32c:	81 2f       	mov	r24, r17
		}
	}
	
	// Return value
	return result;
}
     32e:	df 91       	pop	r29
     330:	cf 91       	pop	r28
     332:	1f 91       	pop	r17
     334:	ff 90       	pop	r15
     336:	ef 90       	pop	r14
     338:	df 90       	pop	r13
     33a:	cf 90       	pop	r12
     33c:	bf 90       	pop	r11
     33e:	af 90       	pop	r10
     340:	9f 90       	pop	r9
     342:	8f 90       	pop	r8
     344:	08 95       	ret

00000346 <_ZN11ColorSensor17addCalibrateColorEh>:
     346:	ff 92       	push	r15

void ColorSensor::addCalibrateColor( uint8_t colorIndex )
{
     348:	0f 93       	push	r16
     34a:	1f 93       	push	r17
     34c:	cf 93       	push	r28
     34e:	df 93       	push	r29
	if ( colorIndex < 10U )
     350:	6a 30       	cpi	r22, 0x0A	; 10
     352:	30 f0       	brcs	.+12     	; 0x360 <_ZN11ColorSensor17addCalibrateColorEh+0x1a>
	}
	else
	{
		/* Cant add more colors. Increase size of array. */
	}
}
     354:	df 91       	pop	r29
     356:	cf 91       	pop	r28
     358:	1f 91       	pop	r17
     35a:	0f 91       	pop	r16
     35c:	ff 90       	pop	r15
     35e:	08 95       	ret
     360:	f6 2e       	mov	r15, r22
     362:	8c 01       	movw	r16, r24
void ColorSensor::setFilter( Filter filter_ )
{
	switch ( filter_ )
	{
	case redFilter:
		COLORSENSOR_S2_PORT &= ~( COLORSENSOR_S2_PIN );
     364:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
     368:	8e 7f       	andi	r24, 0xFE	; 254
     36a:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
		COLORSENSOR_S3_PORT &= ~( COLORSENSOR_S3_PIN );
     36e:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
     372:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
{
	if ( colorIndex < 10U )
	{	
		// Set all colors
		setFilter( redFilter );
		_colors[colorIndex].setRedPeriod( frequency_.getPeriod() );
     376:	c8 01       	movw	r24, r16
     378:	62 d0       	rcall	.+196    	; 0x43e <_ZN6Timer49getPeriodEv>
     37a:	2f 2d       	mov	r18, r15
     37c:	30 e0       	ldi	r19, 0x00	; 0
     37e:	e9 01       	movw	r28, r18
     380:	cc 0f       	add	r28, r28
     382:	dd 1f       	adc	r29, r29
     384:	cc 0f       	add	r28, r28
     386:	dd 1f       	adc	r29, r29
     388:	cc 0f       	add	r28, r28
     38a:	dd 1f       	adc	r29, r29
     38c:	c2 0f       	add	r28, r18
     38e:	d3 1f       	adc	r29, r19
     390:	21 96       	adiw	r28, 0x01	; 1
     392:	c0 0f       	add	r28, r16
     394:	d1 1f       	adc	r29, r17
     396:	bc 01       	movw	r22, r24
     398:	ce 01       	movw	r24, r28
     39a:	f3 de       	rcall	.-538    	; 0x182 <_ZN5Color12setRedPeriodEj>
		COLORSENSOR_S2_PORT &= ~( COLORSENSOR_S2_PIN );
		COLORSENSOR_S3_PORT &= ~( COLORSENSOR_S3_PIN );
		break;

	case blueFilter:
		COLORSENSOR_S2_PORT &= ~( COLORSENSOR_S2_PIN );
     39c:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
     3a0:	8e 7f       	andi	r24, 0xFE	; 254
     3a2:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
		COLORSENSOR_S3_PORT |= COLORSENSOR_S3_PIN;
     3a6:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
     3aa:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
		// Set all colors
		setFilter( redFilter );
		_colors[colorIndex].setRedPeriod( frequency_.getPeriod() );

		setFilter( blueFilter );
		_colors[colorIndex].setBluePeriod( frequency_.getPeriod() );
     3ae:	c8 01       	movw	r24, r16
     3b0:	46 d0       	rcall	.+140    	; 0x43e <_ZN6Timer49getPeriodEv>
     3b2:	bc 01       	movw	r22, r24
     3b4:	ce 01       	movw	r24, r28
     3b6:	e9 de       	rcall	.-558    	; 0x18a <_ZN5Color13setBluePeriodEj>
		COLORSENSOR_S2_PORT &= ~( COLORSENSOR_S2_PIN );
		COLORSENSOR_S3_PORT |= COLORSENSOR_S3_PIN;
		break;

	case greenFilter:
		COLORSENSOR_S2_PORT |= COLORSENSOR_S2_PIN;
     3b8:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
     3bc:	81 60       	ori	r24, 0x01	; 1
     3be:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
		COLORSENSOR_S3_PORT |= COLORSENSOR_S3_PIN;
     3c2:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
     3c6:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>

		setFilter( blueFilter );
		_colors[colorIndex].setBluePeriod( frequency_.getPeriod() );
		
		setFilter( greenFilter );
		_colors[colorIndex].setGreenPeriod( frequency_.getPeriod() );
     3ca:	c8 01       	movw	r24, r16
     3cc:	38 d0       	rcall	.+112    	; 0x43e <_ZN6Timer49getPeriodEv>
     3ce:	bc 01       	movw	r22, r24
     3d0:	ce 01       	movw	r24, r28
     3d2:	df de       	rcall	.-578    	; 0x192 <_ZN5Color14setGreenPeriodEj>
		COLORSENSOR_S2_PORT |= COLORSENSOR_S2_PIN;
		COLORSENSOR_S3_PORT |= COLORSENSOR_S3_PIN;
		break;

	case noFilter:
		COLORSENSOR_S2_PORT |= COLORSENSOR_S2_PIN;
     3d4:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
     3d8:	81 60       	ori	r24, 0x01	; 1
     3da:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
		COLORSENSOR_S3_PORT &= ~( COLORSENSOR_S3_PIN );
     3de:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
		
		setFilter( greenFilter );
		_colors[colorIndex].setGreenPeriod( frequency_.getPeriod() );
		
		setFilter( noFilter );
		_colors[colorIndex].setWhitePeriod( frequency_.getPeriod() );
     3e2:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
     3e6:	c8 01       	movw	r24, r16
     3e8:	2a d0       	rcall	.+84     	; 0x43e <_ZN6Timer49getPeriodEv>
     3ea:	bc 01       	movw	r22, r24
     3ec:	ce 01       	movw	r24, r28
				
		// Set index
		_colors[colorIndex].setColorIndex( colorIndex );
     3ee:	d5 de       	rcall	.-598    	; 0x19a <_ZN5Color14setWhitePeriodEj>
     3f0:	6f 2d       	mov	r22, r15
	}
	else
	{
		/* Cant add more colors. Increase size of array. */
	}
}
     3f2:	ce 01       	movw	r24, r28
     3f4:	df 91       	pop	r29
     3f6:	cf 91       	pop	r28
     3f8:	1f 91       	pop	r17
     3fa:	0f 91       	pop	r16
		
		setFilter( noFilter );
		_colors[colorIndex].setWhitePeriod( frequency_.getPeriod() );
				
		// Set index
		_colors[colorIndex].setColorIndex( colorIndex );
     3fc:	ff 90       	pop	r15
     3fe:	d1 ce       	rjmp	.-606    	; 0x1a2 <_ZN5Color13setColorIndexEh>

00000400 <_ZN6Timer4C1Ev>:
//volatile float tick = 0.000064;

Timer4::Timer4()
{
	// Set ports to the right values.
	COLORSENSOR_S0_PORT |= ( 1 << COLORSENSOR_S0_PIN );
     400:	e5 e0       	ldi	r30, 0x05	; 5
     402:	f1 e0       	ldi	r31, 0x01	; 1
     404:	80 81       	ld	r24, Z
     406:	82 60       	ori	r24, 0x02	; 2
     408:	80 83       	st	Z, r24
	COLORSENSOR_S1_PORT |= ( 1 << COLORSENSOR_S1_PIN );
     40a:	80 81       	ld	r24, Z
     40c:	81 60       	ori	r24, 0x01	; 1
     40e:	80 83       	st	Z, r24
	COLORSENSOR_S2_PORT |= ( 1 << COLORSENSOR_S2_PIN );
     410:	e2 e0       	ldi	r30, 0x02	; 2
     412:	f1 e0       	ldi	r31, 0x01	; 1
     414:	80 81       	ld	r24, Z
     416:	82 60       	ori	r24, 0x02	; 2
     418:	80 83       	st	Z, r24
	COLORSENSOR_S3_PORT |= ( 1 << COLORSENSOR_S3_PIN );
     41a:	80 81       	ld	r24, Z
     41c:	81 60       	ori	r24, 0x01	; 1
     41e:	80 83       	st	Z, r24
	
	// Setup timer to normal mode and pre scaler to 64
	TCCR4A = 0U;
     420:	10 92 a0 00 	sts	0x00A0, r1	; 0x8000a0 <__TEXT_REGION_LENGTH__+0x7000a0>
	TCCR4B = ( 1 << ICNC4 ) | ( 1 << ICES4 ) | ( 1 << CS40 ) | ( 1 << CS41 );
     424:	83 ec       	ldi	r24, 0xC3	; 195
     426:	80 93 a1 00 	sts	0x00A1, r24	; 0x8000a1 <__TEXT_REGION_LENGTH__+0x7000a1>
	TCCR4C = 0U;
     42a:	10 92 a2 00 	sts	0x00A2, r1	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
	
	// Clear flags and set counter to zero
	TIFR4 = ( 1 << ICF4 ) | ( 1 << TOV4 );
     42e:	81 e2       	ldi	r24, 0x21	; 33
     430:	89 bb       	out	0x19, r24	; 25
	TCNT4 = 0;        
     432:	10 92 a5 00 	sts	0x00A5, r1	; 0x8000a5 <__TEXT_REGION_LENGTH__+0x7000a5>
     436:	10 92 a4 00 	sts	0x00A4, r1	; 0x8000a4 <__TEXT_REGION_LENGTH__+0x7000a4>

	// Enable global interrupts
    sei();
     43a:	78 94       	sei
     43c:	08 95       	ret

0000043e <_ZN6Timer49getPeriodEv>:
}

uint16_t Timer4::getPeriod( void )
{
	// Reset all needed values
	first = true;
     43e:	81 e0       	ldi	r24, 0x01	; 1
     440:	80 93 0a 02 	sts	0x020A, r24	; 0x80020a <first>
	oldValue = 0U;
     444:	10 92 01 03 	sts	0x0301, r1	; 0x800301 <oldValue+0x1>
     448:	10 92 00 03 	sts	0x0300, r1	; 0x800300 <oldValue>
	period = 0U;
     44c:	10 92 fb 02 	sts	0x02FB, r1	; 0x8002fb <__data_end+0x1>
     450:	10 92 fa 02 	sts	0x02FA, r1	; 0x8002fa <__data_end>
	timeroverflow = 0;
     454:	10 92 fc 02 	sts	0x02FC, r1	; 0x8002fc <timeroverflow>
     458:	10 92 fd 02 	sts	0x02FD, r1	; 0x8002fd <timeroverflow+0x1>
     45c:	10 92 fe 02 	sts	0x02FE, r1	; 0x8002fe <timeroverflow+0x2>
     460:	10 92 ff 02 	sts	0x02FF, r1	; 0x8002ff <timeroverflow+0x3>
	
	// Enable interrupt and clear pending
	TIFR4 = ( 1 << ICF4 ) | ( 1 << TOV4 );
     464:	81 e2       	ldi	r24, 0x21	; 33
     466:	89 bb       	out	0x19, r24	; 25
	TIMSK4 = ( 1 << ICIE4 ) | ( 1 << TOIE4 );	
     468:	80 93 72 00 	sts	0x0072, r24	; 0x800072 <__TEXT_REGION_LENGTH__+0x700072>
     46c:	0c c0       	rjmp	.+24     	; 0x486 <_ZN6Timer49getPeriodEv+0x48>
	
	// Wait until measurement has been taken
	while ( period == 0U )
	{
		if ( timeroverflow > 10U )
     46e:	80 91 fc 02 	lds	r24, 0x02FC	; 0x8002fc <timeroverflow>
     472:	90 91 fd 02 	lds	r25, 0x02FD	; 0x8002fd <timeroverflow+0x1>
     476:	a0 91 fe 02 	lds	r26, 0x02FE	; 0x8002fe <timeroverflow+0x2>
     47a:	b0 91 ff 02 	lds	r27, 0x02FF	; 0x8002ff <timeroverflow+0x3>
     47e:	0b 97       	sbiw	r24, 0x0b	; 11
     480:	a1 05       	cpc	r26, r1
     482:	b1 05       	cpc	r27, r1
     484:	58 f4       	brcc	.+22     	; 0x49c <_ZN6Timer49getPeriodEv+0x5e>
	// Enable interrupt and clear pending
	TIFR4 = ( 1 << ICF4 ) | ( 1 << TOV4 );
	TIMSK4 = ( 1 << ICIE4 ) | ( 1 << TOIE4 );	
	
	// Wait until measurement has been taken
	while ( period == 0U )
     486:	80 91 fa 02 	lds	r24, 0x02FA	; 0x8002fa <__data_end>
     48a:	90 91 fb 02 	lds	r25, 0x02FB	; 0x8002fb <__data_end+0x1>
     48e:	89 2b       	or	r24, r25
     490:	71 f3       	breq	.-36     	; 0x46e <_ZN6Timer49getPeriodEv+0x30>
			TIFR4 = ( 1 << ICF4 ) | ( 1 << TOV4 );
			break;
		}
	}
	
	return period;
     492:	80 91 fa 02 	lds	r24, 0x02FA	; 0x8002fa <__data_end>
     496:	90 91 fb 02 	lds	r25, 0x02FB	; 0x8002fb <__data_end+0x1>
}
     49a:	08 95       	ret
	while ( period == 0U )
	{
		if ( timeroverflow > 10U )
		{
			// Error - Disable interrupt and clear pending
			TIMSK4 = 0U;
     49c:	10 92 72 00 	sts	0x0072, r1	; 0x800072 <__TEXT_REGION_LENGTH__+0x700072>
			TIFR4 = ( 1 << ICF4 ) | ( 1 << TOV4 );
     4a0:	81 e2       	ldi	r24, 0x21	; 33
     4a2:	89 bb       	out	0x19, r24	; 25
			break;
		}
	}
	
	return period;
     4a4:	80 91 fa 02 	lds	r24, 0x02FA	; 0x8002fa <__data_end>
     4a8:	90 91 fb 02 	lds	r25, 0x02FB	; 0x8002fb <__data_end+0x1>
}
     4ac:	08 95       	ret

000004ae <__vector_45>:

ISR(TIMER4_OVF_vect)
{
     4ae:	1f 92       	push	r1
     4b0:	0f 92       	push	r0
     4b2:	0f b6       	in	r0, 0x3f	; 63
     4b4:	0f 92       	push	r0
     4b6:	11 24       	eor	r1, r1
     4b8:	8f 93       	push	r24
     4ba:	9f 93       	push	r25
     4bc:	af 93       	push	r26
     4be:	bf 93       	push	r27
	timeroverflow++;
     4c0:	80 91 fc 02 	lds	r24, 0x02FC	; 0x8002fc <timeroverflow>
     4c4:	90 91 fd 02 	lds	r25, 0x02FD	; 0x8002fd <timeroverflow+0x1>
     4c8:	a0 91 fe 02 	lds	r26, 0x02FE	; 0x8002fe <timeroverflow+0x2>
     4cc:	b0 91 ff 02 	lds	r27, 0x02FF	; 0x8002ff <timeroverflow+0x3>
     4d0:	01 96       	adiw	r24, 0x01	; 1
     4d2:	a1 1d       	adc	r26, r1
     4d4:	b1 1d       	adc	r27, r1
     4d6:	80 93 fc 02 	sts	0x02FC, r24	; 0x8002fc <timeroverflow>
     4da:	90 93 fd 02 	sts	0x02FD, r25	; 0x8002fd <timeroverflow+0x1>
     4de:	a0 93 fe 02 	sts	0x02FE, r26	; 0x8002fe <timeroverflow+0x2>
     4e2:	b0 93 ff 02 	sts	0x02FF, r27	; 0x8002ff <timeroverflow+0x3>
}
     4e6:	bf 91       	pop	r27
     4e8:	af 91       	pop	r26
     4ea:	9f 91       	pop	r25
     4ec:	8f 91       	pop	r24
     4ee:	0f 90       	pop	r0
     4f0:	0f be       	out	0x3f, r0	; 63
     4f2:	0f 90       	pop	r0
     4f4:	1f 90       	pop	r1
     4f6:	18 95       	reti

000004f8 <__vector_41>:

ISR(TIMER4_CAPT_vect)
{
     4f8:	1f 92       	push	r1
     4fa:	0f 92       	push	r0
     4fc:	0f b6       	in	r0, 0x3f	; 63
     4fe:	0f 92       	push	r0
     500:	11 24       	eor	r1, r1
     502:	0b b6       	in	r0, 0x3b	; 59
     504:	0f 92       	push	r0
     506:	cf 92       	push	r12
     508:	df 92       	push	r13
     50a:	ef 92       	push	r14
     50c:	ff 92       	push	r15
     50e:	0f 93       	push	r16
     510:	1f 93       	push	r17
     512:	2f 93       	push	r18
     514:	3f 93       	push	r19
     516:	4f 93       	push	r20
     518:	5f 93       	push	r21
     51a:	6f 93       	push	r22
     51c:	7f 93       	push	r23
     51e:	8f 93       	push	r24
     520:	9f 93       	push	r25
     522:	af 93       	push	r26
     524:	bf 93       	push	r27
     526:	ef 93       	push	r30
     528:	ff 93       	push	r31
	// Read value of timer
	uint16_t readValue = ICR4;
     52a:	60 91 a6 00 	lds	r22, 0x00A6	; 0x8000a6 <__TEXT_REGION_LENGTH__+0x7000a6>
     52e:	70 91 a7 00 	lds	r23, 0x00A7	; 0x8000a7 <__TEXT_REGION_LENGTH__+0x7000a7>

	if ( first == true )
     532:	80 91 0a 02 	lds	r24, 0x020A	; 0x80020a <first>
     536:	81 11       	cpse	r24, r1
     538:	9b c0       	rjmp	.+310    	; 0x670 <__vector_41+0x178>
		first = false;
		return;
	}
	
	// Check if overflow is pending
	if ( TIFR4 & ( 1 << TOV4 ))
     53a:	c8 9b       	sbis	0x19, 0	; 25
     53c:	13 c0       	rjmp	.+38     	; 0x564 <__vector_41+0x6c>
	{
		timeroverflow++;
     53e:	80 91 fc 02 	lds	r24, 0x02FC	; 0x8002fc <timeroverflow>
     542:	90 91 fd 02 	lds	r25, 0x02FD	; 0x8002fd <timeroverflow+0x1>
     546:	a0 91 fe 02 	lds	r26, 0x02FE	; 0x8002fe <timeroverflow+0x2>
     54a:	b0 91 ff 02 	lds	r27, 0x02FF	; 0x8002ff <timeroverflow+0x3>
     54e:	01 96       	adiw	r24, 0x01	; 1
     550:	a1 1d       	adc	r26, r1
     552:	b1 1d       	adc	r27, r1
     554:	80 93 fc 02 	sts	0x02FC, r24	; 0x8002fc <timeroverflow>
     558:	90 93 fd 02 	sts	0x02FD, r25	; 0x8002fd <timeroverflow+0x1>
     55c:	a0 93 fe 02 	sts	0x02FE, r26	; 0x8002fe <timeroverflow+0x2>
     560:	b0 93 ff 02 	sts	0x02FF, r27	; 0x8002ff <timeroverflow+0x3>
	}
		
	// Disable interrupt and clear pending
	TIMSK4 = 0U;	
     564:	10 92 72 00 	sts	0x0072, r1	; 0x800072 <__TEXT_REGION_LENGTH__+0x700072>
	TIFR4 = ( 1 << ICF4 ) | ( 1 << TOV4 );		
     568:	81 e2       	ldi	r24, 0x21	; 33
     56a:	89 bb       	out	0x19, r24	; 25
			
	// Calculate difference
	uint32_t diff = 0U;

	if ( readValue < oldValue )
     56c:	80 91 00 03 	lds	r24, 0x0300	; 0x800300 <oldValue>
     570:	90 91 01 03 	lds	r25, 0x0301	; 0x800301 <oldValue+0x1>
     574:	68 17       	cp	r22, r24
     576:	79 07       	cpc	r23, r25
     578:	08 f4       	brcc	.+2      	; 0x57c <__vector_41+0x84>
     57a:	4f c0       	rjmp	.+158    	; 0x61a <__vector_41+0x122>
		}
		diff = ( 0xFFFF - oldValue ) + readValue;
	}
	else
	{
		diff = readValue - oldValue;
     57c:	80 91 00 03 	lds	r24, 0x0300	; 0x800300 <oldValue>
     580:	90 91 01 03 	lds	r25, 0x0301	; 0x800301 <oldValue+0x1>
     584:	68 1b       	sub	r22, r24
     586:	79 0b       	sbc	r23, r25
     588:	cb 01       	movw	r24, r22
     58a:	a0 e0       	ldi	r26, 0x00	; 0
     58c:	b0 e0       	ldi	r27, 0x00	; 0
	}
	
	// Add timeroverflow to total diff
	diff += timeroverflow << 16U;
     58e:	40 91 fc 02 	lds	r20, 0x02FC	; 0x8002fc <timeroverflow>
     592:	50 91 fd 02 	lds	r21, 0x02FD	; 0x8002fd <timeroverflow+0x1>
     596:	60 91 fe 02 	lds	r22, 0x02FE	; 0x8002fe <timeroverflow+0x2>
     59a:	70 91 ff 02 	lds	r23, 0x02FF	; 0x8002ff <timeroverflow+0x3>
	
	// Calculate period
	period = diff * tick * 1000000;
     59e:	c0 90 06 02 	lds	r12, 0x0206	; 0x800206 <tick>
     5a2:	d0 90 07 02 	lds	r13, 0x0207	; 0x800207 <tick+0x1>
     5a6:	e0 90 08 02 	lds	r14, 0x0208	; 0x800208 <tick+0x2>
     5aa:	f0 90 09 02 	lds	r15, 0x0209	; 0x800209 <tick+0x3>
     5ae:	ba 01       	movw	r22, r20
     5b0:	55 27       	eor	r21, r21
     5b2:	44 27       	eor	r20, r20
     5b4:	8a 01       	movw	r16, r20
     5b6:	9b 01       	movw	r18, r22
     5b8:	08 0f       	add	r16, r24
     5ba:	19 1f       	adc	r17, r25
     5bc:	2a 1f       	adc	r18, r26
     5be:	3b 1f       	adc	r19, r27
     5c0:	c9 01       	movw	r24, r18
     5c2:	b8 01       	movw	r22, r16
     5c4:	0e 94 e5 1c 	call	0x39ca	; 0x39ca <__floatunsisf>
     5c8:	a7 01       	movw	r20, r14
     5ca:	96 01       	movw	r18, r12
     5cc:	0e 94 9b 1d 	call	0x3b36	; 0x3b36 <__mulsf3>
     5d0:	20 e0       	ldi	r18, 0x00	; 0
     5d2:	34 e2       	ldi	r19, 0x24	; 36
     5d4:	44 e7       	ldi	r20, 0x74	; 116
     5d6:	59 e4       	ldi	r21, 0x49	; 73
     5d8:	0e 94 9b 1d 	call	0x3b36	; 0x3b36 <__mulsf3>
     5dc:	0e 94 b9 1c 	call	0x3972	; 0x3972 <__fixunssfsi>
     5e0:	70 93 fb 02 	sts	0x02FB, r23	; 0x8002fb <__data_end+0x1>
     5e4:	60 93 fa 02 	sts	0x02FA, r22	; 0x8002fa <__data_end>
     5e8:	ff 91       	pop	r31
     5ea:	ef 91       	pop	r30
     5ec:	bf 91       	pop	r27
     5ee:	af 91       	pop	r26
     5f0:	9f 91       	pop	r25
     5f2:	8f 91       	pop	r24
     5f4:	7f 91       	pop	r23
     5f6:	6f 91       	pop	r22
     5f8:	5f 91       	pop	r21
     5fa:	4f 91       	pop	r20
     5fc:	3f 91       	pop	r19
     5fe:	2f 91       	pop	r18
     600:	1f 91       	pop	r17
     602:	0f 91       	pop	r16
     604:	ff 90       	pop	r15
     606:	ef 90       	pop	r14
     608:	df 90       	pop	r13
     60a:	cf 90       	pop	r12
     60c:	0f 90       	pop	r0
     60e:	0b be       	out	0x3b, r0	; 59
     610:	0f 90       	pop	r0
     612:	0f be       	out	0x3f, r0	; 63
     614:	0f 90       	pop	r0
     616:	1f 90       	pop	r1
     618:	18 95       	reti
	// Calculate difference
	uint32_t diff = 0U;

	if ( readValue < oldValue )
	{
		if ( timeroverflow != 0 )
     61a:	80 91 fc 02 	lds	r24, 0x02FC	; 0x8002fc <timeroverflow>
     61e:	90 91 fd 02 	lds	r25, 0x02FD	; 0x8002fd <timeroverflow+0x1>
     622:	a0 91 fe 02 	lds	r26, 0x02FE	; 0x8002fe <timeroverflow+0x2>
     626:	b0 91 ff 02 	lds	r27, 0x02FF	; 0x8002ff <timeroverflow+0x3>
     62a:	89 2b       	or	r24, r25
     62c:	8a 2b       	or	r24, r26
     62e:	8b 2b       	or	r24, r27
     630:	99 f0       	breq	.+38     	; 0x658 <__vector_41+0x160>
		{
			timeroverflow--;
     632:	80 91 fc 02 	lds	r24, 0x02FC	; 0x8002fc <timeroverflow>
     636:	90 91 fd 02 	lds	r25, 0x02FD	; 0x8002fd <timeroverflow+0x1>
     63a:	a0 91 fe 02 	lds	r26, 0x02FE	; 0x8002fe <timeroverflow+0x2>
     63e:	b0 91 ff 02 	lds	r27, 0x02FF	; 0x8002ff <timeroverflow+0x3>
     642:	01 97       	sbiw	r24, 0x01	; 1
     644:	a1 09       	sbc	r26, r1
     646:	b1 09       	sbc	r27, r1
     648:	80 93 fc 02 	sts	0x02FC, r24	; 0x8002fc <timeroverflow>
     64c:	90 93 fd 02 	sts	0x02FD, r25	; 0x8002fd <timeroverflow+0x1>
     650:	a0 93 fe 02 	sts	0x02FE, r26	; 0x8002fe <timeroverflow+0x2>
     654:	b0 93 ff 02 	sts	0x02FF, r27	; 0x8002ff <timeroverflow+0x3>
		}
		diff = ( 0xFFFF - oldValue ) + readValue;
     658:	80 91 00 03 	lds	r24, 0x0300	; 0x800300 <oldValue>
     65c:	90 91 01 03 	lds	r25, 0x0301	; 0x800301 <oldValue+0x1>
     660:	61 50       	subi	r22, 0x01	; 1
     662:	71 09       	sbc	r23, r1
     664:	68 1b       	sub	r22, r24
     666:	79 0b       	sbc	r23, r25
     668:	cb 01       	movw	r24, r22
     66a:	a0 e0       	ldi	r26, 0x00	; 0
     66c:	b0 e0       	ldi	r27, 0x00	; 0
     66e:	8f cf       	rjmp	.-226    	; 0x58e <__vector_41+0x96>
	// Read value of timer
	uint16_t readValue = ICR4;

	if ( first == true )
	{
		timeroverflow = 0U;
     670:	10 92 fc 02 	sts	0x02FC, r1	; 0x8002fc <timeroverflow>
     674:	10 92 fd 02 	sts	0x02FD, r1	; 0x8002fd <timeroverflow+0x1>
     678:	10 92 fe 02 	sts	0x02FE, r1	; 0x8002fe <timeroverflow+0x2>
     67c:	10 92 ff 02 	sts	0x02FF, r1	; 0x8002ff <timeroverflow+0x3>
		oldValue = readValue;
     680:	70 93 01 03 	sts	0x0301, r23	; 0x800301 <oldValue+0x1>
     684:	60 93 00 03 	sts	0x0300, r22	; 0x800300 <oldValue>
		first = false;
     688:	10 92 0a 02 	sts	0x020A, r1	; 0x80020a <first>
		return;
     68c:	ad cf       	rjmp	.-166    	; 0x5e8 <__vector_41+0xf0>

0000068e <_ZN6KeyPadC1Ev>:
/* RTOS include */
#include "FreeRTOS.h"
#include "task.h"
#include "portmacro.h"

 KeyPad::KeyPad()
     68e:	08 95       	ret

00000690 <_ZN6KeyPadD1Ev>:
{
}

KeyPad::~KeyPad()
     690:	08 95       	ret

00000692 <_ZN6KeyPad12readKeyboardEv>:
{
}

char KeyPad::readKeyboard(){
     692:	cf 93       	push	r28
	
	uint8_t read_byte = 0; // Bytes to contain pressed char
	DDRK = 0b11110000; // Configure for Columns to be output and row to be input
     694:	80 ef       	ldi	r24, 0xF0	; 240
     696:	80 93 07 01 	sts	0x0107, r24	; 0x800107 <__TEXT_REGION_LENGTH__+0x700107>
	PORTK = 0b11110000; // Set Columns output to be high!
     69a:	80 93 08 01 	sts	0x0108, r24	; 0x800108 <__TEXT_REGION_LENGTH__+0x700108>
	
	vTaskDelay(8/portTICK_RATE_MS);	// Delays for allowing Pins to switch state from input to output and reverse
     69e:	88 e0       	ldi	r24, 0x08	; 8
     6a0:	90 e0       	ldi	r25, 0x00	; 0
     6a2:	0e 94 97 12 	call	0x252e	; 0x252e <vTaskDelay>
	
	while( (PINK & 0b00001111) == 0 );	// Wait for key pressed
     6a6:	80 91 06 01 	lds	r24, 0x0106	; 0x800106 <__TEXT_REGION_LENGTH__+0x700106>
     6aa:	8f 70       	andi	r24, 0x0F	; 15
     6ac:	e1 f3       	breq	.-8      	; 0x6a6 <_ZN6KeyPad12readKeyboardEv+0x14>
	
	read_byte = (PINK & 0b00001111); // Get row of pressed key
     6ae:	c0 91 06 01 	lds	r28, 0x0106	; 0x800106 <__TEXT_REGION_LENGTH__+0x700106>
	
	DDRK = 0b00001111; // Switch Columns to be input and row to be output
     6b2:	8f e0       	ldi	r24, 0x0F	; 15
     6b4:	80 93 07 01 	sts	0x0107, r24	; 0x800107 <__TEXT_REGION_LENGTH__+0x700107>
	PORTK = 0b00001111; // Set Row outputs to be high!
     6b8:	80 93 08 01 	sts	0x0108, r24	; 0x800108 <__TEXT_REGION_LENGTH__+0x700108>
	
	vTaskDelay(8/portTICK_RATE_MS);
     6bc:	88 e0       	ldi	r24, 0x08	; 8
     6be:	90 e0       	ldi	r25, 0x00	; 0
     6c0:	0e 94 97 12 	call	0x252e	; 0x252e <vTaskDelay>
	
	char pressed_key = findKey(read_byte | (PINK & 0b11110000));
     6c4:	e0 91 06 01 	lds	r30, 0x0106	; 0x800106 <__TEXT_REGION_LENGTH__+0x700106>
     6c8:	e0 7f       	andi	r30, 0xF0	; 240
     6ca:	cf 70       	andi	r28, 0x0F	; 15
     6cc:	ec 2b       	or	r30, r28
     6ce:	e1 51       	subi	r30, 0x11	; 17
     6d0:	e8 37       	cpi	r30, 0x78	; 120
     6d2:	38 f0       	brcs	.+14     	; 0x6e2 <_ZN6KeyPad12readKeyboardEv+0x50>
     6d4:	85 e4       	ldi	r24, 0x45	; 69

	// Wait for no key pressed anymore
	while((PINK & 0b11110000) != 0);
     6d6:	90 91 06 01 	lds	r25, 0x0106	; 0x800106 <__TEXT_REGION_LENGTH__+0x700106>
     6da:	90 7f       	andi	r25, 0xF0	; 240
     6dc:	e1 f7       	brne	.-8      	; 0x6d6 <_ZN6KeyPad12readKeyboardEv+0x44>

	return pressed_key;
}
     6de:	cf 91       	pop	r28
     6e0:	08 95       	ret
     6e2:	f0 e0       	ldi	r31, 0x00	; 0
     6e4:	e2 5f       	subi	r30, 0xF2	; 242
     6e6:	fd 4f       	sbci	r31, 0xFD	; 253
     6e8:	80 81       	ld	r24, Z
     6ea:	f5 cf       	rjmp	.-22     	; 0x6d6 <_ZN6KeyPad12readKeyboardEv+0x44>

000006ec <_ZN14LoginInterfaceC1Ev>:
#include <stdlib.h>
#include <avr/io.h>
#include "KeyPad.h"
#include "LoginInterface.h"

 LoginInterface::LoginInterface()
     6ec:	0f 93       	push	r16
     6ee:	1f 93       	push	r17
     6f0:	cf 93       	push	r28
     6f2:	df 93       	push	r29
     6f4:	1f 92       	push	r1
     6f6:	cd b7       	in	r28, 0x3d	; 61
     6f8:	de b7       	in	r29, 0x3e	; 62
     6fa:	8c 01       	movw	r16, r24
     6fc:	c8 df       	rcall	.-112    	; 0x68e <_ZN6KeyPadC1Ev>
 {
	 keypad = KeyPad();
     6fe:	ce 01       	movw	r24, r28
     700:	01 96       	adiw	r24, 0x01	; 1
     702:	c5 df       	rcall	.-118    	; 0x68e <_ZN6KeyPadC1Ev>
     704:	ce 01       	movw	r24, r28
     706:	01 96       	adiw	r24, 0x01	; 1
     708:	c3 df       	rcall	.-122    	; 0x690 <_ZN6KeyPadD1Ev>
	 // ASCII Used since static declaration is not supported before STD c++ 11
	 passWord[0] = 49; // 1
     70a:	81 e3       	ldi	r24, 0x31	; 49
     70c:	f8 01       	movw	r30, r16
     70e:	81 83       	std	Z+1, r24	; 0x01
	 passWord[1] = 52; // 4
     710:	84 e3       	ldi	r24, 0x34	; 52
     712:	82 83       	std	Z+2, r24	; 0x02
	 passWord[2] = 55; // 7
     714:	87 e3       	ldi	r24, 0x37	; 55
     716:	83 83       	std	Z+3, r24	; 0x03
	 passWord[3] = 50; // 2
     718:	82 e3       	ldi	r24, 0x32	; 50
     71a:	84 83       	std	Z+4, r24	; 0x04
	 stateOfMachine = 'L';
     71c:	8c e4       	ldi	r24, 0x4C	; 76
     71e:	85 83       	std	Z+5, r24	; 0x05
 }
     720:	0f 90       	pop	r0
     722:	df 91       	pop	r29
     724:	cf 91       	pop	r28
     726:	1f 91       	pop	r17
     728:	0f 91       	pop	r16
     72a:	08 95       	ret

0000072c <_ZN14LoginInterfaceD1Ev>:
 
 LoginInterface::~LoginInterface()
     72c:	b1 cf       	rjmp	.-158    	; 0x690 <_ZN6KeyPadD1Ev>

0000072e <_ZN14LoginInterface10checkLoginEv>:
 {
 }
 
 void LoginInterface::checkLogin()
 {
     72e:	ef 92       	push	r14
     730:	ff 92       	push	r15
     732:	1f 93       	push	r17
     734:	cf 93       	push	r28
     736:	df 93       	push	r29
     738:	00 d0       	rcall	.+0      	; 0x73a <_ZN14LoginInterface10checkLoginEv+0xc>
     73a:	1f 92       	push	r1
     73c:	cd b7       	in	r28, 0x3d	; 61
     73e:	de b7       	in	r29, 0x3e	; 62
     740:	7c 01       	movw	r14, r24
	 uint8_t userPressed = 0;
     742:	10 e0       	ldi	r17, 0x00	; 0
     744:	01 c0       	rjmp	.+2      	; 0x748 <_ZN14LoginInterface10checkLoginEv+0x1a>
		 char buf = keypad.readKeyboard();
		 
		 // If star is pressed.. Reset Keys pressed
		 if (buf == 42)
		 {
			 userPressed = 0;
     746:	10 e0       	ldi	r17, 0x00	; 0
	 uint8_t userPressed = 0;
	 volatile uint8_t userPass[4];
	 
	 while(userPressed < 4)
	 {
		 char buf = keypad.readKeyboard();
     748:	c7 01       	movw	r24, r14
     74a:	a3 df       	rcall	.-186    	; 0x692 <_ZN6KeyPad12readKeyboardEv>
		 
		 // If star is pressed.. Reset Keys pressed
		 if (buf == 42)
     74c:	8a 32       	cpi	r24, 0x2A	; 42
     74e:	d9 f3       	breq	.-10     	; 0x746 <_ZN14LoginInterface10checkLoginEv+0x18>
		 {
			 userPressed = 0;
		 }else
		 {
			 // Put key pressed into array
			 userPass[userPressed] = buf;
     750:	e1 e0       	ldi	r30, 0x01	; 1
     752:	f0 e0       	ldi	r31, 0x00	; 0
     754:	ec 0f       	add	r30, r28
     756:	fd 1f       	adc	r31, r29
     758:	e1 0f       	add	r30, r17
     75a:	f1 1d       	adc	r31, r1
     75c:	80 83       	st	Z, r24
			 userPressed++; 
     75e:	1f 5f       	subi	r17, 0xFF	; 255
 void LoginInterface::checkLogin()
 {
	 uint8_t userPressed = 0;
	 volatile uint8_t userPass[4];
	 
	 while(userPressed < 4)
     760:	14 30       	cpi	r17, 0x04	; 4
     762:	91 f7       	brne	.-28     	; 0x748 <_ZN14LoginInterface10checkLoginEv+0x1a>
	 
	 bool all_okay = true;
	 // Check each of the entries in array if they match password
	 for (uint8_t i = 0; i < 4; i++)
	 {
		 if (userPass[i] != passWord[i])
     764:	99 81       	ldd	r25, Y+1	; 0x01
     766:	f7 01       	movw	r30, r14
     768:	81 81       	ldd	r24, Z+1	; 0x01
     76a:	98 17       	cp	r25, r24
     76c:	19 f1       	breq	.+70     	; 0x7b4 <_ZN14LoginInterface10checkLoginEv+0x86>
	 switch(state){
		 case 'U':
			stateOfMachine = 'U';
			break;
		 case 'L':
			stateOfMachine = 'L';
     76e:	8c e4       	ldi	r24, 0x4C	; 76
     770:	85 83       	std	Z+5, r24	; 0x05
	 for (uint8_t i = 0; i < 4; i++)
	 {
		 if (userPass[i] != passWord[i])
		 {
			 setstateOfMachine('L');
			 all_okay = false;
     772:	80 e0       	ldi	r24, 0x00	; 0
	 
	 bool all_okay = true;
	 // Check each of the entries in array if they match password
	 for (uint8_t i = 0; i < 4; i++)
	 {
		 if (userPass[i] != passWord[i])
     774:	2a 81       	ldd	r18, Y+2	; 0x02
     776:	f7 01       	movw	r30, r14
     778:	92 81       	ldd	r25, Z+2	; 0x02
     77a:	29 17       	cp	r18, r25
     77c:	19 f0       	breq	.+6      	; 0x784 <_ZN14LoginInterface10checkLoginEv+0x56>
	 switch(state){
		 case 'U':
			stateOfMachine = 'U';
			break;
		 case 'L':
			stateOfMachine = 'L';
     77e:	8c e4       	ldi	r24, 0x4C	; 76
     780:	85 83       	std	Z+5, r24	; 0x05
	 for (uint8_t i = 0; i < 4; i++)
	 {
		 if (userPass[i] != passWord[i])
		 {
			 setstateOfMachine('L');
			 all_okay = false;
     782:	80 e0       	ldi	r24, 0x00	; 0
	 
	 bool all_okay = true;
	 // Check each of the entries in array if they match password
	 for (uint8_t i = 0; i < 4; i++)
	 {
		 if (userPass[i] != passWord[i])
     784:	2b 81       	ldd	r18, Y+3	; 0x03
     786:	f7 01       	movw	r30, r14
     788:	93 81       	ldd	r25, Z+3	; 0x03
     78a:	29 17       	cp	r18, r25
     78c:	a9 f0       	breq	.+42     	; 0x7b8 <_ZN14LoginInterface10checkLoginEv+0x8a>
	 switch(state){
		 case 'U':
			stateOfMachine = 'U';
			break;
		 case 'L':
			stateOfMachine = 'L';
     78e:	8c e4       	ldi	r24, 0x4C	; 76
     790:	85 83       	std	Z+5, r24	; 0x05
	 
	 bool all_okay = true;
	 // Check each of the entries in array if they match password
	 for (uint8_t i = 0; i < 4; i++)
	 {
		 if (userPass[i] != passWord[i])
     792:	8c 81       	ldd	r24, Y+4	; 0x04
     794:	94 81       	ldd	r25, Z+4	; 0x04
     796:	98 17       	cp	r25, r24
     798:	19 f0       	breq	.+6      	; 0x7a0 <_ZN14LoginInterface10checkLoginEv+0x72>
	 switch(state){
		 case 'U':
			stateOfMachine = 'U';
			break;
		 case 'L':
			stateOfMachine = 'L';
     79a:	8c e4       	ldi	r24, 0x4C	; 76
     79c:	f7 01       	movw	r30, r14
     79e:	85 83       	std	Z+5, r24	; 0x05
		 }else
		 {
			 setstateOfMachine('L');
		 }
	 }
 }
     7a0:	0f 90       	pop	r0
     7a2:	0f 90       	pop	r0
     7a4:	0f 90       	pop	r0
     7a6:	0f 90       	pop	r0
     7a8:	df 91       	pop	r29
     7aa:	cf 91       	pop	r28
     7ac:	1f 91       	pop	r17
     7ae:	ff 90       	pop	r15
     7b0:	ef 90       	pop	r14
     7b2:	08 95       	ret
	 
	 bool all_okay = true;
	 // Check each of the entries in array if they match password
	 for (uint8_t i = 0; i < 4; i++)
	 {
		 if (userPass[i] != passWord[i])
     7b4:	81 e0       	ldi	r24, 0x01	; 1
     7b6:	de cf       	rjmp	.-68     	; 0x774 <_ZN14LoginInterface10checkLoginEv+0x46>
     7b8:	2c 81       	ldd	r18, Y+4	; 0x04
     7ba:	f7 01       	movw	r30, r14
     7bc:	94 81       	ldd	r25, Z+4	; 0x04
     7be:	29 13       	cpse	r18, r25
     7c0:	ec cf       	rjmp	.-40     	; 0x79a <_ZN14LoginInterface10checkLoginEv+0x6c>
		 }
	 }
	 // If state is locked unlock it
	 // If state is unlocked lock it
	 
	 if (all_okay)
     7c2:	88 23       	and	r24, r24
     7c4:	69 f3       	breq	.-38     	; 0x7a0 <_ZN14LoginInterface10checkLoginEv+0x72>
	 {
		 if (getstateOfMachine() == 'L')
     7c6:	f7 01       	movw	r30, r14
     7c8:	85 81       	ldd	r24, Z+5	; 0x05
     7ca:	8c 34       	cpi	r24, 0x4C	; 76
     7cc:	31 f7       	brne	.-52     	; 0x79a <_ZN14LoginInterface10checkLoginEv+0x6c>
 void LoginInterface::setstateOfMachine(char state)
 {
	 
	 switch(state){
		 case 'U':
			stateOfMachine = 'U';
     7ce:	85 e5       	ldi	r24, 0x55	; 85
     7d0:	85 83       	std	Z+5, r24	; 0x05
     7d2:	e6 cf       	rjmp	.-52     	; 0x7a0 <_ZN14LoginInterface10checkLoginEv+0x72>

000007d4 <_ZN14LoginInterface17getstateOfMachineEv>:
 
 // Set and get Method for stateOfMachine
 char LoginInterface::getstateOfMachine()
 {
	 return stateOfMachine;
 }
     7d4:	fc 01       	movw	r30, r24
     7d6:	85 81       	ldd	r24, Z+5	; 0x05
     7d8:	08 95       	ret

000007da <_Z11LoginKeyPadPv>:
void * operator new(size_t size);
void operator delete(void * ptr);

int __cxa_guard_acquire(__guard *g) {return !*(char *)(g);};
void __cxa_guard_release (__guard *g) {*(char *)g = 1;};
void __cxa_guard_abort (__guard *) {};
     7da:	83 e0       	ldi	r24, 0x03	; 3
     7dc:	93 e0       	ldi	r25, 0x03	; 3
     7de:	a7 df       	rcall	.-178    	; 0x72e <_ZN14LoginInterface10checkLoginEv>
     7e0:	fc cf       	rjmp	.-8      	; 0x7da <_Z11LoginKeyPadPv>

000007e2 <_Z10DisplayArmPv>:
     7e2:	cf 93       	push	r28
     7e4:	df 93       	push	r29
     7e6:	cd b7       	in	r28, 0x3d	; 61
     7e8:	de b7       	in	r29, 0x3e	; 62
     7ea:	ce 57       	subi	r28, 0x7E	; 126
     7ec:	d1 09       	sbc	r29, r1
     7ee:	0f b6       	in	r0, 0x3f	; 63
     7f0:	f8 94       	cli
     7f2:	de bf       	out	0x3e, r29	; 62
     7f4:	0f be       	out	0x3f, r0	; 63
     7f6:	cd bf       	out	0x3d, r28	; 61
     7f8:	8c 01       	movw	r16, r24
     7fa:	62 e0       	ldi	r22, 0x02	; 2
     7fc:	ce 01       	movw	r24, r28
     7fe:	01 96       	adiw	r24, 0x01	; 1
     800:	d3 dc       	rcall	.-1626   	; 0x1a8 <_ZN11ColorSensorC1E16FrequencyScaling>
     802:	ce 01       	movw	r24, r28
     804:	84 5a       	subi	r24, 0xA4	; 164
     806:	9f 4f       	sbci	r25, 0xFF	; 255
     808:	0e 94 3b 14 	call	0x2876	; 0x2876 <_ZN11TouchscreenC1Ev>
     80c:	ce 01       	movw	r24, r28
     80e:	84 5a       	subi	r24, 0xA4	; 164
     810:	9f 4f       	sbci	r25, 0xFF	; 255
     812:	0e 94 a1 15 	call	0x2b42	; 0x2b42 <_ZN11Touchscreen11clearScreenEv>
     816:	83 e0       	ldi	r24, 0x03	; 3
     818:	93 e0       	ldi	r25, 0x03	; 3
     81a:	dc df       	rcall	.-72     	; 0x7d4 <_ZN14LoginInterface17getstateOfMachineEv>
     81c:	85 35       	cpi	r24, 0x55	; 85
     81e:	b1 f7       	brne	.-20     	; 0x80c <_Z10DisplayArmPv+0x2a>
     820:	ce 01       	movw	r24, r28
     822:	84 5a       	subi	r24, 0xA4	; 164
     824:	9f 4f       	sbci	r25, 0xFF	; 255
     826:	0e 94 b6 15 	call	0x2b6c	; 0x2b6c <_ZN11Touchscreen23presentButtonsOnDisplayEv>
     82a:	ce 01       	movw	r24, r28
     82c:	84 5a       	subi	r24, 0xA4	; 164
     82e:	9f 4f       	sbci	r25, 0xFF	; 255
     830:	0e 94 19 15 	call	0x2a32	; 0x2a32 <_ZN11Touchscreen12checkButtonsEv>
     834:	81 30       	cpi	r24, 0x01	; 1
     836:	81 f0       	breq	.+32     	; 0x858 <_Z10DisplayArmPv+0x76>
     838:	82 30       	cpi	r24, 0x02	; 2
     83a:	69 f7       	brne	.-38     	; 0x816 <_Z10DisplayArmPv+0x34>
     83c:	ce 01       	movw	r24, r28
     83e:	01 96       	adiw	r24, 0x01	; 1
     840:	00 dd       	rcall	.-1536   	; 0x242 <_ZN11ColorSensor8getColorEv>
     842:	8f 3f       	cpi	r24, 0xFF	; 255
     844:	a1 f0       	breq	.+40     	; 0x86e <_Z10DisplayArmPv+0x8c>
     846:	68 2f       	mov	r22, r24
     848:	c8 01       	movw	r24, r16
     84a:	b7 d3       	rcall	.+1902   	; 0xfba <_ZN8Robotarm8MoveItemEh>
     84c:	83 e0       	ldi	r24, 0x03	; 3
     84e:	93 e0       	ldi	r25, 0x03	; 3
     850:	c1 df       	rcall	.-126    	; 0x7d4 <_ZN14LoginInterface17getstateOfMachineEv>
     852:	85 35       	cpi	r24, 0x55	; 85
     854:	29 f3       	breq	.-54     	; 0x820 <_Z10DisplayArmPv+0x3e>
     856:	da cf       	rjmp	.-76     	; 0x80c <_Z10DisplayArmPv+0x2a>
     858:	60 91 02 03 	lds	r22, 0x0302	; 0x800302 <colorIndex>
     85c:	ce 01       	movw	r24, r28
     85e:	01 96       	adiw	r24, 0x01	; 1
     860:	72 dd       	rcall	.-1308   	; 0x346 <_ZN11ColorSensor17addCalibrateColorEh>
     862:	80 91 02 03 	lds	r24, 0x0302	; 0x800302 <colorIndex>
     866:	8f 5f       	subi	r24, 0xFF	; 255
     868:	80 93 02 03 	sts	0x0302, r24	; 0x800302 <colorIndex>
     86c:	d4 cf       	rjmp	.-88     	; 0x816 <_Z10DisplayArmPv+0x34>
     86e:	ce 01       	movw	r24, r28
     870:	84 5a       	subi	r24, 0xA4	; 164
     872:	9f 4f       	sbci	r25, 0xFF	; 255
     874:	0e 94 da 15 	call	0x2bb4	; 0x2bb4 <_ZN11Touchscreen17flashRedOnDisplayEv>
     878:	88 ee       	ldi	r24, 0xE8	; 232
     87a:	93 e0       	ldi	r25, 0x03	; 3
     87c:	0e 94 97 12 	call	0x252e	; 0x252e <vTaskDelay>
     880:	ce 01       	movw	r24, r28
     882:	84 5a       	subi	r24, 0xA4	; 164
     884:	9f 4f       	sbci	r25, 0xFF	; 255
     886:	0e 94 a1 15 	call	0x2b42	; 0x2b42 <_ZN11Touchscreen11clearScreenEv>
     88a:	ce 01       	movw	r24, r28
     88c:	84 5a       	subi	r24, 0xA4	; 164
     88e:	9f 4f       	sbci	r25, 0xFF	; 255
     890:	0e 94 b6 15 	call	0x2b6c	; 0x2b6c <_ZN11Touchscreen23presentButtonsOnDisplayEv>
     894:	c0 cf       	rjmp	.-128    	; 0x816 <_Z10DisplayArmPv+0x34>

00000896 <_Znwj>:

void * operator new(size_t size)
{
	return malloc(size);
     896:	0c 94 15 1e 	jmp	0x3c2a	; 0x3c2a <malloc>

0000089a <_ZdlPv>:
}

void operator delete(void * ptr)
{
	ptr != NULL ? free(ptr) : void(0);
     89a:	00 97       	sbiw	r24, 0x00	; 0
     89c:	11 f0       	breq	.+4      	; 0x8a2 <_ZdlPv+0x8>
     89e:	0c 94 ad 1e 	jmp	0x3d5a	; 0x3d5a <free>
     8a2:	08 95       	ret

000008a4 <main>:
		}
	}
}

int main(void)
{		
     8a4:	cf 93       	push	r28
     8a6:	df 93       	push	r29
     8a8:	cd b7       	in	r28, 0x3d	; 61
     8aa:	de b7       	in	r29, 0x3e	; 62
     8ac:	2e 97       	sbiw	r28, 0x0e	; 14
     8ae:	0f b6       	in	r0, 0x3f	; 63
     8b0:	f8 94       	cli
     8b2:	de bf       	out	0x3e, r29	; 62
     8b4:	0f be       	out	0x3f, r0	; 63
     8b6:	cd bf       	out	0x3d, r28	; 61
	Robotarm arm = Robotarm();
     8b8:	ce 01       	movw	r24, r28
     8ba:	01 96       	adiw	r24, 0x01	; 1
     8bc:	59 d0       	rcall	.+178    	; 0x970 <_ZN8RobotarmC1Ev>
	xTaskCreate(LoginKeyPad,  ( signed char * ) "Keypad Task", configMAIN_STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL);
     8be:	a1 2c       	mov	r10, r1
     8c0:	b1 2c       	mov	r11, r1
     8c2:	c1 2c       	mov	r12, r1
     8c4:	d1 2c       	mov	r13, r1
     8c6:	e1 2c       	mov	r14, r1
     8c8:	f1 2c       	mov	r15, r1
     8ca:	00 e0       	ldi	r16, 0x00	; 0
     8cc:	20 e0       	ldi	r18, 0x00	; 0
     8ce:	30 e0       	ldi	r19, 0x00	; 0
     8d0:	48 e5       	ldi	r20, 0x58	; 88
     8d2:	52 e0       	ldi	r21, 0x02	; 2
     8d4:	66 e8       	ldi	r22, 0x86	; 134
     8d6:	72 e0       	ldi	r23, 0x02	; 2
     8d8:	8d ee       	ldi	r24, 0xED	; 237
     8da:	93 e0       	ldi	r25, 0x03	; 3
     8dc:	0e 94 98 10 	call	0x2130	; 0x2130 <xTaskGenericCreate>
	xTaskCreate(DisplayArm,  ( signed char * ) "Display + Arm Task", configMAIN_STACK_SIZE, &arm, tskIDLE_PRIORITY, NULL);
     8e0:	9e 01       	movw	r18, r28
     8e2:	2f 5f       	subi	r18, 0xFF	; 255
     8e4:	3f 4f       	sbci	r19, 0xFF	; 255
     8e6:	48 e5       	ldi	r20, 0x58	; 88
     8e8:	52 e0       	ldi	r21, 0x02	; 2
     8ea:	62 e9       	ldi	r22, 0x92	; 146
     8ec:	72 e0       	ldi	r23, 0x02	; 2
     8ee:	81 ef       	ldi	r24, 0xF1	; 241
     8f0:	93 e0       	ldi	r25, 0x03	; 3
     8f2:	0e 94 98 10 	call	0x2130	; 0x2130 <xTaskGenericCreate>
	vTaskStartScheduler();
     8f6:	0e 94 50 11 	call	0x22a0	; 0x22a0 <vTaskStartScheduler>
     8fa:	ff cf       	rjmp	.-2      	; 0x8fa <main+0x56>

000008fc <_GLOBAL__sub_I___cxa_pure_virtual>:

/* This file is needed to be able to use new and delete operators */
#include "CPlusPlusSpecific.h"

/* Create shared objects */
LoginInterface Login = LoginInterface();
     8fc:	83 e0       	ldi	r24, 0x03	; 3
     8fe:	93 e0       	ldi	r25, 0x03	; 3
     900:	f5 ce       	rjmp	.-534    	; 0x6ec <_ZN14LoginInterfaceC1Ev>

00000902 <_GLOBAL__sub_D___cxa_pure_virtual>:
     902:	83 e0       	ldi	r24, 0x03	; 3
     904:	93 e0       	ldi	r25, 0x03	; 3
     906:	12 cf       	rjmp	.-476    	; 0x72c <_ZN14LoginInterfaceD1Ev>

00000908 <_ZN5Motor10SetDegreesEh>:
	*	 can be used to turn motor at a specific speed set by \ref delay. C
	*	 Note that this function needs to run multiple times to work as intended.
	*    @param uint8_t	degrees to turn
	*    @return void Nothing
	*/
	virtual void SetDegrees( uint8_t degrees )
     908:	cf 93       	push	r28
     90a:	df 93       	push	r29
	{
		if ( maxDegrees_ >= degrees )
     90c:	fc 01       	movw	r30, r24
     90e:	26 89       	ldd	r18, Z+22	; 0x16
     910:	26 17       	cp	r18, r22
     912:	b0 f0       	brcs	.+44     	; 0x940 <_ZN5Motor10SetDegreesEh+0x38>
     914:	ec 01       	movw	r28, r24
		{
			percent_ = percentPrDeg * degrees + startpercent_;
     916:	70 e0       	ldi	r23, 0x00	; 0
     918:	80 e0       	ldi	r24, 0x00	; 0
     91a:	90 e0       	ldi	r25, 0x00	; 0
     91c:	0e 94 e7 1c 	call	0x39ce	; 0x39ce <__floatsisf>
     920:	2e 81       	ldd	r18, Y+6	; 0x06
     922:	3f 81       	ldd	r19, Y+7	; 0x07
     924:	48 85       	ldd	r20, Y+8	; 0x08
     926:	59 85       	ldd	r21, Y+9	; 0x09
     928:	0e 94 9b 1d 	call	0x3b36	; 0x3b36 <__mulsf3>
     92c:	2a 89       	ldd	r18, Y+18	; 0x12
     92e:	3b 89       	ldd	r19, Y+19	; 0x13
     930:	4c 89       	ldd	r20, Y+20	; 0x14
     932:	5d 89       	ldd	r21, Y+21	; 0x15
     934:	0e 94 e9 1b 	call	0x37d2	; 0x37d2 <__addsf3>
     938:	6a 87       	std	Y+10, r22	; 0x0a
     93a:	7b 87       	std	Y+11, r23	; 0x0b
     93c:	8c 87       	std	Y+12, r24	; 0x0c
     93e:	9d 87       	std	Y+13, r25	; 0x0d
		}
	}
     940:	df 91       	pop	r29
     942:	cf 91       	pop	r28
     944:	08 95       	ret

00000946 <_ZN8Robotarm14startMotorImplEPv>:
{
	vTaskDelay( 1500 / portTICK_RATE_MS );
	motors_[1]->SetDegrees(35);
	motors_[2]->SetDegrees(40);
	vTaskDelay( 1500 / portTICK_RATE_MS );
	motors_[5]->SetDegrees(0);
     946:	8c 01       	movw	r16, r24
     948:	0e 5f       	subi	r16, 0xFE	; 254
     94a:	1f 4f       	sbci	r17, 0xFF	; 255
     94c:	9c 01       	movw	r18, r24
     94e:	22 5f       	subi	r18, 0xF2	; 242
     950:	3f 4f       	sbci	r19, 0xFF	; 255
     952:	79 01       	movw	r14, r18
     954:	e8 01       	movw	r28, r16
     956:	89 91       	ld	r24, Y+
     958:	99 91       	ld	r25, Y+
     95a:	dc 01       	movw	r26, r24
     95c:	ed 91       	ld	r30, X+
     95e:	fc 91       	ld	r31, X
     960:	04 80       	ldd	r0, Z+4	; 0x04
     962:	f5 81       	ldd	r31, Z+5	; 0x05
     964:	e0 2d       	mov	r30, r0
     966:	19 95       	eicall
     968:	ec 16       	cp	r14, r28
     96a:	fd 06       	cpc	r15, r29
     96c:	99 f3       	breq	.-26     	; 0x954 <_ZN8Robotarm14startMotorImplEPv+0xe>
     96e:	f3 cf       	rjmp	.-26     	; 0x956 <_ZN8Robotarm14startMotorImplEPv+0x10>

00000970 <_ZN8RobotarmC1Ev>:
     970:	af 92       	push	r10
     972:	bf 92       	push	r11
     974:	cf 92       	push	r12
     976:	df 92       	push	r13
     978:	ef 92       	push	r14
     97a:	ff 92       	push	r15
     97c:	0f 93       	push	r16
     97e:	1f 93       	push	r17
     980:	cf 93       	push	r28
     982:	df 93       	push	r29
     984:	ec 01       	movw	r28, r24
     986:	c2 d7       	rcall	.+3972   	; 0x190c <_ZN6Timer1C1Ev>
     988:	8e 01       	movw	r16, r28
     98a:	0f 5f       	subi	r16, 0xFF	; 255
     98c:	1f 4f       	sbci	r17, 0xFF	; 255
     98e:	c8 01       	movw	r24, r16
     990:	0e 94 1f 0d 	call	0x1a3e	; 0x1a3e <_ZN6Timer5C1Ev>
     994:	89 e1       	ldi	r24, 0x19	; 25
     996:	90 e0       	ldi	r25, 0x00	; 0
     998:	7e df       	rcall	.-260    	; 0x896 <_Znwj>
     99a:	7c 01       	movw	r14, r24
     99c:	be 01       	movw	r22, r28
     99e:	6d d4       	rcall	.+2266   	; 0x127a <_ZN2M1C1EP6Timer1>
     9a0:	fb 82       	std	Y+3, r15	; 0x03
     9a2:	ea 82       	std	Y+2, r14	; 0x02
     9a4:	89 e1       	ldi	r24, 0x19	; 25
     9a6:	90 e0       	ldi	r25, 0x00	; 0
     9a8:	76 df       	rcall	.-276    	; 0x896 <_Znwj>
     9aa:	7c 01       	movw	r14, r24
     9ac:	be 01       	movw	r22, r28
     9ae:	05 d5       	rcall	.+2570   	; 0x13ba <_ZN2M2C1EP6Timer1>
     9b0:	fd 82       	std	Y+5, r15	; 0x05
     9b2:	ec 82       	std	Y+4, r14	; 0x04
     9b4:	89 e1       	ldi	r24, 0x19	; 25
     9b6:	90 e0       	ldi	r25, 0x00	; 0
     9b8:	6e df       	rcall	.-292    	; 0x896 <_Znwj>
     9ba:	7c 01       	movw	r14, r24
     9bc:	be 01       	movw	r22, r28
     9be:	9d d5       	rcall	.+2874   	; 0x14fa <_ZN2M3C1EP6Timer1>
     9c0:	ff 82       	std	Y+7, r15	; 0x07
     9c2:	ee 82       	std	Y+6, r14	; 0x06
     9c4:	89 e1       	ldi	r24, 0x19	; 25
     9c6:	90 e0       	ldi	r25, 0x00	; 0
     9c8:	66 df       	rcall	.-308    	; 0x896 <_Znwj>
     9ca:	7c 01       	movw	r14, r24
     9cc:	b8 01       	movw	r22, r16
     9ce:	34 d6       	rcall	.+3176   	; 0x1638 <_ZN2M4C1EP6Timer5>
     9d0:	f9 86       	std	Y+9, r15	; 0x09
     9d2:	e8 86       	std	Y+8, r14	; 0x08
     9d4:	89 e1       	ldi	r24, 0x19	; 25
     9d6:	90 e0       	ldi	r25, 0x00	; 0
     9d8:	5e df       	rcall	.-324    	; 0x896 <_Znwj>
     9da:	7c 01       	movw	r14, r24
     9dc:	b8 01       	movw	r22, r16
     9de:	cb d6       	rcall	.+3478   	; 0x1776 <_ZN2M5C1EP6Timer5>
     9e0:	fb 86       	std	Y+11, r15	; 0x0b
     9e2:	ea 86       	std	Y+10, r14	; 0x0a
     9e4:	89 e1       	ldi	r24, 0x19	; 25
     9e6:	90 e0       	ldi	r25, 0x00	; 0
     9e8:	56 df       	rcall	.-340    	; 0x896 <_Znwj>
     9ea:	7c 01       	movw	r14, r24
     9ec:	b8 01       	movw	r22, r16
     9ee:	5e d7       	rcall	.+3772   	; 0x18ac <_ZN2M6C1EP6Timer5>
     9f0:	fd 86       	std	Y+13, r15	; 0x0d
     9f2:	ec 86       	std	Y+12, r14	; 0x0c
     9f4:	a1 2c       	mov	r10, r1
     9f6:	b1 2c       	mov	r11, r1
     9f8:	c1 2c       	mov	r12, r1
     9fa:	d1 2c       	mov	r13, r1
     9fc:	e1 2c       	mov	r14, r1
     9fe:	f1 2c       	mov	r15, r1
     a00:	00 e0       	ldi	r16, 0x00	; 0
     a02:	9e 01       	movw	r18, r28
     a04:	48 e5       	ldi	r20, 0x58	; 88
     a06:	52 e0       	ldi	r21, 0x02	; 2
     a08:	65 ea       	ldi	r22, 0xA5	; 165
     a0a:	72 e0       	ldi	r23, 0x02	; 2
     a0c:	83 ea       	ldi	r24, 0xA3	; 163
     a0e:	94 e0       	ldi	r25, 0x04	; 4
     a10:	0e 94 98 10 	call	0x2130	; 0x2130 <xTaskGenericCreate>
     a14:	df 91       	pop	r29
     a16:	cf 91       	pop	r28
     a18:	1f 91       	pop	r17
     a1a:	0f 91       	pop	r16
     a1c:	ff 90       	pop	r15
     a1e:	ef 90       	pop	r14
     a20:	df 90       	pop	r13
     a22:	cf 90       	pop	r12
     a24:	bf 90       	pop	r11
     a26:	af 90       	pop	r10
     a28:	08 95       	ret

00000a2a <_ZN8Robotarm9grabBlockEv>:
     a2a:	0f 93       	push	r16
     a2c:	1f 93       	push	r17
     a2e:	cf 93       	push	r28
     a30:	df 93       	push	r29
     a32:	ec 01       	movw	r28, r24
     a34:	08 85       	ldd	r16, Y+8	; 0x08
     a36:	19 85       	ldd	r17, Y+9	; 0x09
     a38:	d8 01       	movw	r26, r16
     a3a:	ed 91       	ld	r30, X+
     a3c:	fc 91       	ld	r31, X
     a3e:	06 80       	ldd	r0, Z+6	; 0x06
     a40:	f7 81       	ldd	r31, Z+7	; 0x07
     a42:	e0 2d       	mov	r30, r0
     a44:	b4 e0       	ldi	r27, 0x04	; 4
     a46:	e4 38       	cpi	r30, 0x84	; 132
     a48:	fb 07       	cpc	r31, r27
     a4a:	09 f0       	breq	.+2      	; 0xa4e <_ZN8Robotarm9grabBlockEv+0x24>
     a4c:	6b c1       	rjmp	.+726    	; 0xd24 <_ZN8Robotarm9grabBlockEv+0x2fa>
     a4e:	f8 01       	movw	r30, r16
     a50:	86 89       	ldd	r24, Z+22	; 0x16
     a52:	88 32       	cpi	r24, 0x28	; 40
     a54:	c0 f0       	brcs	.+48     	; 0xa86 <_ZN8Robotarm9grabBlockEv+0x5c>
     a56:	20 e0       	ldi	r18, 0x00	; 0
     a58:	30 e0       	ldi	r19, 0x00	; 0
     a5a:	40 e2       	ldi	r20, 0x20	; 32
     a5c:	52 e4       	ldi	r21, 0x42	; 66
     a5e:	66 81       	ldd	r22, Z+6	; 0x06
     a60:	77 81       	ldd	r23, Z+7	; 0x07
     a62:	80 85       	ldd	r24, Z+8	; 0x08
     a64:	91 85       	ldd	r25, Z+9	; 0x09
     a66:	0e 94 9b 1d 	call	0x3b36	; 0x3b36 <__mulsf3>
     a6a:	d8 01       	movw	r26, r16
     a6c:	52 96       	adiw	r26, 0x12	; 18
     a6e:	2d 91       	ld	r18, X+
     a70:	3d 91       	ld	r19, X+
     a72:	4d 91       	ld	r20, X+
     a74:	5c 91       	ld	r21, X
     a76:	55 97       	sbiw	r26, 0x15	; 21
     a78:	0e 94 e9 1b 	call	0x37d2	; 0x37d2 <__addsf3>
     a7c:	f8 01       	movw	r30, r16
     a7e:	62 87       	std	Z+10, r22	; 0x0a
     a80:	73 87       	std	Z+11, r23	; 0x0b
     a82:	84 87       	std	Z+12, r24	; 0x0c
     a84:	95 87       	std	Z+13, r25	; 0x0d
     a86:	0a 85       	ldd	r16, Y+10	; 0x0a
     a88:	1b 85       	ldd	r17, Y+11	; 0x0b
     a8a:	d8 01       	movw	r26, r16
     a8c:	ed 91       	ld	r30, X+
     a8e:	fc 91       	ld	r31, X
     a90:	06 80       	ldd	r0, Z+6	; 0x06
     a92:	f7 81       	ldd	r31, Z+7	; 0x07
     a94:	e0 2d       	mov	r30, r0
     a96:	b4 e0       	ldi	r27, 0x04	; 4
     a98:	e4 38       	cpi	r30, 0x84	; 132
     a9a:	fb 07       	cpc	r31, r27
     a9c:	09 f0       	breq	.+2      	; 0xaa0 <_ZN8Robotarm9grabBlockEv+0x76>
     a9e:	52 c1       	rjmp	.+676    	; 0xd44 <_ZN8Robotarm9grabBlockEv+0x31a>
     aa0:	f8 01       	movw	r30, r16
     aa2:	86 89       	ldd	r24, Z+22	; 0x16
     aa4:	8a 35       	cpi	r24, 0x5A	; 90
     aa6:	c0 f0       	brcs	.+48     	; 0xad8 <_ZN8Robotarm9grabBlockEv+0xae>
     aa8:	20 e0       	ldi	r18, 0x00	; 0
     aaa:	30 e0       	ldi	r19, 0x00	; 0
     aac:	44 eb       	ldi	r20, 0xB4	; 180
     aae:	52 e4       	ldi	r21, 0x42	; 66
     ab0:	66 81       	ldd	r22, Z+6	; 0x06
     ab2:	77 81       	ldd	r23, Z+7	; 0x07
     ab4:	80 85       	ldd	r24, Z+8	; 0x08
     ab6:	91 85       	ldd	r25, Z+9	; 0x09
     ab8:	0e 94 9b 1d 	call	0x3b36	; 0x3b36 <__mulsf3>
     abc:	d8 01       	movw	r26, r16
     abe:	52 96       	adiw	r26, 0x12	; 18
     ac0:	2d 91       	ld	r18, X+
     ac2:	3d 91       	ld	r19, X+
     ac4:	4d 91       	ld	r20, X+
     ac6:	5c 91       	ld	r21, X
     ac8:	55 97       	sbiw	r26, 0x15	; 21
     aca:	0e 94 e9 1b 	call	0x37d2	; 0x37d2 <__addsf3>
     ace:	f8 01       	movw	r30, r16
     ad0:	62 87       	std	Z+10, r22	; 0x0a
     ad2:	73 87       	std	Z+11, r23	; 0x0b
     ad4:	84 87       	std	Z+12, r24	; 0x0c
     ad6:	95 87       	std	Z+13, r25	; 0x0d
     ad8:	0a 81       	ldd	r16, Y+2	; 0x02
     ada:	1b 81       	ldd	r17, Y+3	; 0x03
     adc:	d8 01       	movw	r26, r16
     ade:	ed 91       	ld	r30, X+
     ae0:	fc 91       	ld	r31, X
     ae2:	06 80       	ldd	r0, Z+6	; 0x06
     ae4:	f7 81       	ldd	r31, Z+7	; 0x07
     ae6:	e0 2d       	mov	r30, r0
     ae8:	b4 e0       	ldi	r27, 0x04	; 4
     aea:	e4 38       	cpi	r30, 0x84	; 132
     aec:	fb 07       	cpc	r31, r27
     aee:	09 f0       	breq	.+2      	; 0xaf2 <_ZN8Robotarm9grabBlockEv+0xc8>
     af0:	21 c1       	rjmp	.+578    	; 0xd34 <_ZN8Robotarm9grabBlockEv+0x30a>
     af2:	20 e0       	ldi	r18, 0x00	; 0
     af4:	30 e0       	ldi	r19, 0x00	; 0
     af6:	a9 01       	movw	r20, r18
     af8:	f8 01       	movw	r30, r16
     afa:	66 81       	ldd	r22, Z+6	; 0x06
     afc:	77 81       	ldd	r23, Z+7	; 0x07
     afe:	80 85       	ldd	r24, Z+8	; 0x08
     b00:	91 85       	ldd	r25, Z+9	; 0x09
     b02:	0e 94 9b 1d 	call	0x3b36	; 0x3b36 <__mulsf3>
     b06:	d8 01       	movw	r26, r16
     b08:	52 96       	adiw	r26, 0x12	; 18
     b0a:	2d 91       	ld	r18, X+
     b0c:	3d 91       	ld	r19, X+
     b0e:	4d 91       	ld	r20, X+
     b10:	5c 91       	ld	r21, X
     b12:	55 97       	sbiw	r26, 0x15	; 21
     b14:	0e 94 e9 1b 	call	0x37d2	; 0x37d2 <__addsf3>
     b18:	f8 01       	movw	r30, r16
     b1a:	62 87       	std	Z+10, r22	; 0x0a
     b1c:	73 87       	std	Z+11, r23	; 0x0b
     b1e:	84 87       	std	Z+12, r24	; 0x0c
     b20:	95 87       	std	Z+13, r25	; 0x0d
     b22:	8c ed       	ldi	r24, 0xDC	; 220
     b24:	95 e0       	ldi	r25, 0x05	; 5
     b26:	0e 94 97 12 	call	0x252e	; 0x252e <vTaskDelay>
     b2a:	0c 81       	ldd	r16, Y+4	; 0x04
     b2c:	1d 81       	ldd	r17, Y+5	; 0x05
     b2e:	d8 01       	movw	r26, r16
     b30:	ed 91       	ld	r30, X+
     b32:	fc 91       	ld	r31, X
     b34:	06 80       	ldd	r0, Z+6	; 0x06
     b36:	f7 81       	ldd	r31, Z+7	; 0x07
     b38:	e0 2d       	mov	r30, r0
     b3a:	b4 e0       	ldi	r27, 0x04	; 4
     b3c:	e4 38       	cpi	r30, 0x84	; 132
     b3e:	fb 07       	cpc	r31, r27
     b40:	09 f0       	breq	.+2      	; 0xb44 <_ZN8Robotarm9grabBlockEv+0x11a>
     b42:	f4 c0       	rjmp	.+488    	; 0xd2c <_ZN8Robotarm9grabBlockEv+0x302>
     b44:	f8 01       	movw	r30, r16
     b46:	86 89       	ldd	r24, Z+22	; 0x16
     b48:	83 32       	cpi	r24, 0x23	; 35
     b4a:	c0 f0       	brcs	.+48     	; 0xb7c <_ZN8Robotarm9grabBlockEv+0x152>
     b4c:	20 e0       	ldi	r18, 0x00	; 0
     b4e:	30 e0       	ldi	r19, 0x00	; 0
     b50:	4c e0       	ldi	r20, 0x0C	; 12
     b52:	52 e4       	ldi	r21, 0x42	; 66
     b54:	66 81       	ldd	r22, Z+6	; 0x06
     b56:	77 81       	ldd	r23, Z+7	; 0x07
     b58:	80 85       	ldd	r24, Z+8	; 0x08
     b5a:	91 85       	ldd	r25, Z+9	; 0x09
     b5c:	0e 94 9b 1d 	call	0x3b36	; 0x3b36 <__mulsf3>
     b60:	d8 01       	movw	r26, r16
     b62:	52 96       	adiw	r26, 0x12	; 18
     b64:	2d 91       	ld	r18, X+
     b66:	3d 91       	ld	r19, X+
     b68:	4d 91       	ld	r20, X+
     b6a:	5c 91       	ld	r21, X
     b6c:	55 97       	sbiw	r26, 0x15	; 21
     b6e:	0e 94 e9 1b 	call	0x37d2	; 0x37d2 <__addsf3>
     b72:	f8 01       	movw	r30, r16
     b74:	62 87       	std	Z+10, r22	; 0x0a
     b76:	73 87       	std	Z+11, r23	; 0x0b
     b78:	84 87       	std	Z+12, r24	; 0x0c
     b7a:	95 87       	std	Z+13, r25	; 0x0d
     b7c:	0e 81       	ldd	r16, Y+6	; 0x06
     b7e:	1f 81       	ldd	r17, Y+7	; 0x07
     b80:	d8 01       	movw	r26, r16
     b82:	ed 91       	ld	r30, X+
     b84:	fc 91       	ld	r31, X
     b86:	06 80       	ldd	r0, Z+6	; 0x06
     b88:	f7 81       	ldd	r31, Z+7	; 0x07
     b8a:	e0 2d       	mov	r30, r0
     b8c:	b4 e0       	ldi	r27, 0x04	; 4
     b8e:	e4 38       	cpi	r30, 0x84	; 132
     b90:	fb 07       	cpc	r31, r27
     b92:	09 f0       	breq	.+2      	; 0xb96 <_ZN8Robotarm9grabBlockEv+0x16c>
     b94:	d3 c0       	rjmp	.+422    	; 0xd3c <_ZN8Robotarm9grabBlockEv+0x312>
     b96:	f8 01       	movw	r30, r16
     b98:	86 89       	ldd	r24, Z+22	; 0x16
     b9a:	8f 33       	cpi	r24, 0x3F	; 63
     b9c:	c0 f0       	brcs	.+48     	; 0xbce <_ZN8Robotarm9grabBlockEv+0x1a4>
     b9e:	20 e0       	ldi	r18, 0x00	; 0
     ba0:	30 e0       	ldi	r19, 0x00	; 0
     ba2:	4c e7       	ldi	r20, 0x7C	; 124
     ba4:	52 e4       	ldi	r21, 0x42	; 66
     ba6:	66 81       	ldd	r22, Z+6	; 0x06
     ba8:	77 81       	ldd	r23, Z+7	; 0x07
     baa:	80 85       	ldd	r24, Z+8	; 0x08
     bac:	91 85       	ldd	r25, Z+9	; 0x09
     bae:	0e 94 9b 1d 	call	0x3b36	; 0x3b36 <__mulsf3>
     bb2:	d8 01       	movw	r26, r16
     bb4:	52 96       	adiw	r26, 0x12	; 18
     bb6:	2d 91       	ld	r18, X+
     bb8:	3d 91       	ld	r19, X+
     bba:	4d 91       	ld	r20, X+
     bbc:	5c 91       	ld	r21, X
     bbe:	55 97       	sbiw	r26, 0x15	; 21
     bc0:	0e 94 e9 1b 	call	0x37d2	; 0x37d2 <__addsf3>
     bc4:	f8 01       	movw	r30, r16
     bc6:	62 87       	std	Z+10, r22	; 0x0a
     bc8:	73 87       	std	Z+11, r23	; 0x0b
     bca:	84 87       	std	Z+12, r24	; 0x0c
     bcc:	95 87       	std	Z+13, r25	; 0x0d
     bce:	8c ed       	ldi	r24, 0xDC	; 220
     bd0:	95 e0       	ldi	r25, 0x05	; 5
     bd2:	0e 94 97 12 	call	0x252e	; 0x252e <vTaskDelay>
     bd6:	0c 85       	ldd	r16, Y+12	; 0x0c
     bd8:	1d 85       	ldd	r17, Y+13	; 0x0d
     bda:	d8 01       	movw	r26, r16
     bdc:	ed 91       	ld	r30, X+
     bde:	fc 91       	ld	r31, X
     be0:	06 80       	ldd	r0, Z+6	; 0x06
     be2:	f7 81       	ldd	r31, Z+7	; 0x07
     be4:	e0 2d       	mov	r30, r0
     be6:	b4 e0       	ldi	r27, 0x04	; 4
     be8:	e4 38       	cpi	r30, 0x84	; 132
     bea:	fb 07       	cpc	r31, r27
     bec:	09 f0       	breq	.+2      	; 0xbf0 <_ZN8Robotarm9grabBlockEv+0x1c6>
     bee:	b2 c0       	rjmp	.+356    	; 0xd54 <_ZN8Robotarm9grabBlockEv+0x32a>
     bf0:	f8 01       	movw	r30, r16
     bf2:	86 89       	ldd	r24, Z+22	; 0x16
     bf4:	8f 33       	cpi	r24, 0x3F	; 63
     bf6:	c0 f0       	brcs	.+48     	; 0xc28 <_ZN8Robotarm9grabBlockEv+0x1fe>
     bf8:	20 e0       	ldi	r18, 0x00	; 0
     bfa:	30 e0       	ldi	r19, 0x00	; 0
     bfc:	4c e7       	ldi	r20, 0x7C	; 124
     bfe:	52 e4       	ldi	r21, 0x42	; 66
     c00:	66 81       	ldd	r22, Z+6	; 0x06
     c02:	77 81       	ldd	r23, Z+7	; 0x07
     c04:	80 85       	ldd	r24, Z+8	; 0x08
     c06:	91 85       	ldd	r25, Z+9	; 0x09
     c08:	0e 94 9b 1d 	call	0x3b36	; 0x3b36 <__mulsf3>
     c0c:	d8 01       	movw	r26, r16
     c0e:	52 96       	adiw	r26, 0x12	; 18
     c10:	2d 91       	ld	r18, X+
     c12:	3d 91       	ld	r19, X+
     c14:	4d 91       	ld	r20, X+
     c16:	5c 91       	ld	r21, X
     c18:	55 97       	sbiw	r26, 0x15	; 21
     c1a:	0e 94 e9 1b 	call	0x37d2	; 0x37d2 <__addsf3>
     c1e:	f8 01       	movw	r30, r16
     c20:	62 87       	std	Z+10, r22	; 0x0a
     c22:	73 87       	std	Z+11, r23	; 0x0b
     c24:	84 87       	std	Z+12, r24	; 0x0c
     c26:	95 87       	std	Z+13, r25	; 0x0d
     c28:	8a ef       	ldi	r24, 0xFA	; 250
     c2a:	90 e0       	ldi	r25, 0x00	; 0
     c2c:	0e 94 97 12 	call	0x252e	; 0x252e <vTaskDelay>
     c30:	0c 81       	ldd	r16, Y+4	; 0x04
     c32:	1d 81       	ldd	r17, Y+5	; 0x05
     c34:	d8 01       	movw	r26, r16
     c36:	ed 91       	ld	r30, X+
     c38:	fc 91       	ld	r31, X
     c3a:	06 80       	ldd	r0, Z+6	; 0x06
     c3c:	f7 81       	ldd	r31, Z+7	; 0x07
     c3e:	e0 2d       	mov	r30, r0
     c40:	b4 e0       	ldi	r27, 0x04	; 4
     c42:	e4 38       	cpi	r30, 0x84	; 132
     c44:	fb 07       	cpc	r31, r27
     c46:	09 f0       	breq	.+2      	; 0xc4a <_ZN8Robotarm9grabBlockEv+0x220>
     c48:	81 c0       	rjmp	.+258    	; 0xd4c <_ZN8Robotarm9grabBlockEv+0x322>
     c4a:	f8 01       	movw	r30, r16
     c4c:	86 89       	ldd	r24, Z+22	; 0x16
     c4e:	86 34       	cpi	r24, 0x46	; 70
     c50:	c0 f0       	brcs	.+48     	; 0xc82 <_ZN8Robotarm9grabBlockEv+0x258>
     c52:	20 e0       	ldi	r18, 0x00	; 0
     c54:	30 e0       	ldi	r19, 0x00	; 0
     c56:	4c e8       	ldi	r20, 0x8C	; 140
     c58:	52 e4       	ldi	r21, 0x42	; 66
     c5a:	66 81       	ldd	r22, Z+6	; 0x06
     c5c:	77 81       	ldd	r23, Z+7	; 0x07
     c5e:	80 85       	ldd	r24, Z+8	; 0x08
     c60:	91 85       	ldd	r25, Z+9	; 0x09
     c62:	0e 94 9b 1d 	call	0x3b36	; 0x3b36 <__mulsf3>
     c66:	d8 01       	movw	r26, r16
     c68:	52 96       	adiw	r26, 0x12	; 18
     c6a:	2d 91       	ld	r18, X+
     c6c:	3d 91       	ld	r19, X+
     c6e:	4d 91       	ld	r20, X+
     c70:	5c 91       	ld	r21, X
     c72:	55 97       	sbiw	r26, 0x15	; 21
     c74:	0e 94 e9 1b 	call	0x37d2	; 0x37d2 <__addsf3>
     c78:	f8 01       	movw	r30, r16
     c7a:	62 87       	std	Z+10, r22	; 0x0a
     c7c:	73 87       	std	Z+11, r23	; 0x0b
     c7e:	84 87       	std	Z+12, r24	; 0x0c
     c80:	95 87       	std	Z+13, r25	; 0x0d
     c82:	0e 81       	ldd	r16, Y+6	; 0x06
     c84:	1f 81       	ldd	r17, Y+7	; 0x07
     c86:	d8 01       	movw	r26, r16
     c88:	ed 91       	ld	r30, X+
     c8a:	fc 91       	ld	r31, X
     c8c:	06 80       	ldd	r0, Z+6	; 0x06
     c8e:	f7 81       	ldd	r31, Z+7	; 0x07
     c90:	e0 2d       	mov	r30, r0
     c92:	b4 e0       	ldi	r27, 0x04	; 4
     c94:	e4 38       	cpi	r30, 0x84	; 132
     c96:	fb 07       	cpc	r31, r27
     c98:	09 f0       	breq	.+2      	; 0xc9c <_ZN8Robotarm9grabBlockEv+0x272>
     c9a:	67 c0       	rjmp	.+206    	; 0xd6a <_ZN8Robotarm9grabBlockEv+0x340>
     c9c:	f8 01       	movw	r30, r16
     c9e:	86 89       	ldd	r24, Z+22	; 0x16
     ca0:	86 34       	cpi	r24, 0x46	; 70
     ca2:	c0 f0       	brcs	.+48     	; 0xcd4 <_ZN8Robotarm9grabBlockEv+0x2aa>
     ca4:	20 e0       	ldi	r18, 0x00	; 0
     ca6:	30 e0       	ldi	r19, 0x00	; 0
     ca8:	4c e8       	ldi	r20, 0x8C	; 140
     caa:	52 e4       	ldi	r21, 0x42	; 66
     cac:	66 81       	ldd	r22, Z+6	; 0x06
     cae:	77 81       	ldd	r23, Z+7	; 0x07
     cb0:	80 85       	ldd	r24, Z+8	; 0x08
     cb2:	91 85       	ldd	r25, Z+9	; 0x09
     cb4:	0e 94 9b 1d 	call	0x3b36	; 0x3b36 <__mulsf3>
     cb8:	d8 01       	movw	r26, r16
     cba:	52 96       	adiw	r26, 0x12	; 18
     cbc:	2d 91       	ld	r18, X+
     cbe:	3d 91       	ld	r19, X+
     cc0:	4d 91       	ld	r20, X+
     cc2:	5c 91       	ld	r21, X
     cc4:	55 97       	sbiw	r26, 0x15	; 21
     cc6:	0e 94 e9 1b 	call	0x37d2	; 0x37d2 <__addsf3>
     cca:	f8 01       	movw	r30, r16
     ccc:	62 87       	std	Z+10, r22	; 0x0a
     cce:	73 87       	std	Z+11, r23	; 0x0b
     cd0:	84 87       	std	Z+12, r24	; 0x0c
     cd2:	95 87       	std	Z+13, r25	; 0x0d
     cd4:	08 84       	ldd	r0, Y+8	; 0x08
     cd6:	d9 85       	ldd	r29, Y+9	; 0x09
     cd8:	c0 2d       	mov	r28, r0
     cda:	e8 81       	ld	r30, Y
     cdc:	f9 81       	ldd	r31, Y+1	; 0x01
     cde:	06 80       	ldd	r0, Z+6	; 0x06
     ce0:	f7 81       	ldd	r31, Z+7	; 0x07
     ce2:	e0 2d       	mov	r30, r0
     ce4:	84 e0       	ldi	r24, 0x04	; 4
     ce6:	e4 38       	cpi	r30, 0x84	; 132
     ce8:	f8 07       	cpc	r31, r24
     cea:	c1 f5       	brne	.+112    	; 0xd5c <_ZN8Robotarm9grabBlockEv+0x332>
     cec:	8e 89       	ldd	r24, Y+22	; 0x16
     cee:	86 34       	cpi	r24, 0x46	; 70
     cf0:	a0 f0       	brcs	.+40     	; 0xd1a <_ZN8Robotarm9grabBlockEv+0x2f0>
     cf2:	20 e0       	ldi	r18, 0x00	; 0
     cf4:	30 e0       	ldi	r19, 0x00	; 0
     cf6:	4c e8       	ldi	r20, 0x8C	; 140
     cf8:	52 e4       	ldi	r21, 0x42	; 66
     cfa:	6e 81       	ldd	r22, Y+6	; 0x06
     cfc:	7f 81       	ldd	r23, Y+7	; 0x07
     cfe:	88 85       	ldd	r24, Y+8	; 0x08
     d00:	99 85       	ldd	r25, Y+9	; 0x09
     d02:	0e 94 9b 1d 	call	0x3b36	; 0x3b36 <__mulsf3>
     d06:	2a 89       	ldd	r18, Y+18	; 0x12
     d08:	3b 89       	ldd	r19, Y+19	; 0x13
     d0a:	4c 89       	ldd	r20, Y+20	; 0x14
     d0c:	5d 89       	ldd	r21, Y+21	; 0x15
     d0e:	0e 94 e9 1b 	call	0x37d2	; 0x37d2 <__addsf3>
     d12:	6a 87       	std	Y+10, r22	; 0x0a
     d14:	7b 87       	std	Y+11, r23	; 0x0b
     d16:	8c 87       	std	Y+12, r24	; 0x0c
     d18:	9d 87       	std	Y+13, r25	; 0x0d
     d1a:	df 91       	pop	r29
     d1c:	cf 91       	pop	r28
     d1e:	1f 91       	pop	r17
     d20:	0f 91       	pop	r16
     d22:	08 95       	ret
     d24:	68 e2       	ldi	r22, 0x28	; 40
     d26:	c8 01       	movw	r24, r16
     d28:	19 95       	eicall
     d2a:	ad ce       	rjmp	.-678    	; 0xa86 <_ZN8Robotarm9grabBlockEv+0x5c>
     d2c:	63 e2       	ldi	r22, 0x23	; 35
     d2e:	c8 01       	movw	r24, r16
     d30:	19 95       	eicall
     d32:	24 cf       	rjmp	.-440    	; 0xb7c <_ZN8Robotarm9grabBlockEv+0x152>
     d34:	60 e0       	ldi	r22, 0x00	; 0
     d36:	c8 01       	movw	r24, r16
     d38:	19 95       	eicall
     d3a:	f3 ce       	rjmp	.-538    	; 0xb22 <_ZN8Robotarm9grabBlockEv+0xf8>
     d3c:	6f e3       	ldi	r22, 0x3F	; 63
     d3e:	c8 01       	movw	r24, r16
     d40:	19 95       	eicall
     d42:	45 cf       	rjmp	.-374    	; 0xbce <_ZN8Robotarm9grabBlockEv+0x1a4>
     d44:	6a e5       	ldi	r22, 0x5A	; 90
     d46:	c8 01       	movw	r24, r16
     d48:	19 95       	eicall
     d4a:	c6 ce       	rjmp	.-628    	; 0xad8 <_ZN8Robotarm9grabBlockEv+0xae>
     d4c:	66 e4       	ldi	r22, 0x46	; 70
     d4e:	c8 01       	movw	r24, r16
     d50:	19 95       	eicall
     d52:	97 cf       	rjmp	.-210    	; 0xc82 <_ZN8Robotarm9grabBlockEv+0x258>
     d54:	6f e3       	ldi	r22, 0x3F	; 63
     d56:	c8 01       	movw	r24, r16
     d58:	19 95       	eicall
     d5a:	66 cf       	rjmp	.-308    	; 0xc28 <_ZN8Robotarm9grabBlockEv+0x1fe>
     d5c:	66 e4       	ldi	r22, 0x46	; 70
     d5e:	ce 01       	movw	r24, r28
     d60:	df 91       	pop	r29
     d62:	cf 91       	pop	r28
     d64:	1f 91       	pop	r17
     d66:	0f 91       	pop	r16
     d68:	19 94       	eijmp
     d6a:	66 e4       	ldi	r22, 0x46	; 70
     d6c:	c8 01       	movw	r24, r16
     d6e:	19 95       	eicall
     d70:	b1 cf       	rjmp	.-158    	; 0xcd4 <_ZN8Robotarm9grabBlockEv+0x2aa>

00000d72 <_ZN8Robotarm18ArmDownReleaseItemEv>:
	motors_[0]->SetDegrees(180);
	ArmDownReleaseItem();
}

void Robotarm::ArmDownReleaseItem()
{
     d72:	0f 93       	push	r16
     d74:	1f 93       	push	r17
     d76:	cf 93       	push	r28
     d78:	df 93       	push	r29
     d7a:	ec 01       	movw	r28, r24
	vTaskDelay( 1500 / portTICK_RATE_MS );
     d7c:	8c ed       	ldi	r24, 0xDC	; 220
     d7e:	95 e0       	ldi	r25, 0x05	; 5
     d80:	0e 94 97 12 	call	0x252e	; 0x252e <vTaskDelay>
	motors_[1]->SetDegrees(35);
     d84:	0c 81       	ldd	r16, Y+4	; 0x04
     d86:	1d 81       	ldd	r17, Y+5	; 0x05
     d88:	d8 01       	movw	r26, r16
     d8a:	ed 91       	ld	r30, X+
     d8c:	fc 91       	ld	r31, X
     d8e:	06 80       	ldd	r0, Z+6	; 0x06
     d90:	f7 81       	ldd	r31, Z+7	; 0x07
     d92:	e0 2d       	mov	r30, r0
     d94:	b4 e0       	ldi	r27, 0x04	; 4
     d96:	e4 38       	cpi	r30, 0x84	; 132
     d98:	fb 07       	cpc	r31, r27
     d9a:	09 f0       	breq	.+2      	; 0xd9e <_ZN8Robotarm18ArmDownReleaseItemEv+0x2c>
     d9c:	f3 c0       	rjmp	.+486    	; 0xf84 <_ZN8Robotarm18ArmDownReleaseItemEv+0x212>
	*    @param uint8_t	degrees to turn
	*    @return void Nothing
	*/
	virtual void SetDegrees( uint8_t degrees )
	{
		if ( maxDegrees_ >= degrees )
     d9e:	f8 01       	movw	r30, r16
     da0:	86 89       	ldd	r24, Z+22	; 0x16
     da2:	83 32       	cpi	r24, 0x23	; 35
     da4:	c0 f0       	brcs	.+48     	; 0xdd6 <_ZN8Robotarm18ArmDownReleaseItemEv+0x64>
		{
			percent_ = percentPrDeg * degrees + startpercent_;
     da6:	20 e0       	ldi	r18, 0x00	; 0
     da8:	30 e0       	ldi	r19, 0x00	; 0
     daa:	4c e0       	ldi	r20, 0x0C	; 12
     dac:	52 e4       	ldi	r21, 0x42	; 66
     dae:	66 81       	ldd	r22, Z+6	; 0x06
     db0:	77 81       	ldd	r23, Z+7	; 0x07
     db2:	80 85       	ldd	r24, Z+8	; 0x08
     db4:	91 85       	ldd	r25, Z+9	; 0x09
     db6:	0e 94 9b 1d 	call	0x3b36	; 0x3b36 <__mulsf3>
     dba:	d8 01       	movw	r26, r16
     dbc:	52 96       	adiw	r26, 0x12	; 18
     dbe:	2d 91       	ld	r18, X+
     dc0:	3d 91       	ld	r19, X+
     dc2:	4d 91       	ld	r20, X+
     dc4:	5c 91       	ld	r21, X
     dc6:	55 97       	sbiw	r26, 0x15	; 21
     dc8:	0e 94 e9 1b 	call	0x37d2	; 0x37d2 <__addsf3>
     dcc:	f8 01       	movw	r30, r16
     dce:	62 87       	std	Z+10, r22	; 0x0a
     dd0:	73 87       	std	Z+11, r23	; 0x0b
     dd2:	84 87       	std	Z+12, r24	; 0x0c
     dd4:	95 87       	std	Z+13, r25	; 0x0d
	motors_[2]->SetDegrees(40);
     dd6:	0e 81       	ldd	r16, Y+6	; 0x06
     dd8:	1f 81       	ldd	r17, Y+7	; 0x07
     dda:	d8 01       	movw	r26, r16
     ddc:	ed 91       	ld	r30, X+
     dde:	fc 91       	ld	r31, X
     de0:	06 80       	ldd	r0, Z+6	; 0x06
     de2:	f7 81       	ldd	r31, Z+7	; 0x07
     de4:	e0 2d       	mov	r30, r0
     de6:	b4 e0       	ldi	r27, 0x04	; 4
     de8:	e4 38       	cpi	r30, 0x84	; 132
     dea:	fb 07       	cpc	r31, r27
     dec:	09 f0       	breq	.+2      	; 0xdf0 <_ZN8Robotarm18ArmDownReleaseItemEv+0x7e>
     dee:	c6 c0       	rjmp	.+396    	; 0xf7c <_ZN8Robotarm18ArmDownReleaseItemEv+0x20a>
	*    @param uint8_t	degrees to turn
	*    @return void Nothing
	*/
	virtual void SetDegrees( uint8_t degrees )
	{
		if ( maxDegrees_ >= degrees )
     df0:	f8 01       	movw	r30, r16
     df2:	86 89       	ldd	r24, Z+22	; 0x16
     df4:	88 32       	cpi	r24, 0x28	; 40
     df6:	c0 f0       	brcs	.+48     	; 0xe28 <_ZN8Robotarm18ArmDownReleaseItemEv+0xb6>
		{
			percent_ = percentPrDeg * degrees + startpercent_;
     df8:	20 e0       	ldi	r18, 0x00	; 0
     dfa:	30 e0       	ldi	r19, 0x00	; 0
     dfc:	40 e2       	ldi	r20, 0x20	; 32
     dfe:	52 e4       	ldi	r21, 0x42	; 66
     e00:	66 81       	ldd	r22, Z+6	; 0x06
     e02:	77 81       	ldd	r23, Z+7	; 0x07
     e04:	80 85       	ldd	r24, Z+8	; 0x08
     e06:	91 85       	ldd	r25, Z+9	; 0x09
     e08:	0e 94 9b 1d 	call	0x3b36	; 0x3b36 <__mulsf3>
     e0c:	d8 01       	movw	r26, r16
     e0e:	52 96       	adiw	r26, 0x12	; 18
     e10:	2d 91       	ld	r18, X+
     e12:	3d 91       	ld	r19, X+
     e14:	4d 91       	ld	r20, X+
     e16:	5c 91       	ld	r21, X
     e18:	55 97       	sbiw	r26, 0x15	; 21
     e1a:	0e 94 e9 1b 	call	0x37d2	; 0x37d2 <__addsf3>
     e1e:	f8 01       	movw	r30, r16
     e20:	62 87       	std	Z+10, r22	; 0x0a
     e22:	73 87       	std	Z+11, r23	; 0x0b
     e24:	84 87       	std	Z+12, r24	; 0x0c
     e26:	95 87       	std	Z+13, r25	; 0x0d
	vTaskDelay( 1500 / portTICK_RATE_MS );
     e28:	8c ed       	ldi	r24, 0xDC	; 220
     e2a:	95 e0       	ldi	r25, 0x05	; 5
     e2c:	0e 94 97 12 	call	0x252e	; 0x252e <vTaskDelay>
	motors_[5]->SetDegrees(0);
     e30:	0c 85       	ldd	r16, Y+12	; 0x0c
     e32:	1d 85       	ldd	r17, Y+13	; 0x0d
     e34:	d8 01       	movw	r26, r16
     e36:	ed 91       	ld	r30, X+
     e38:	fc 91       	ld	r31, X
     e3a:	06 80       	ldd	r0, Z+6	; 0x06
     e3c:	f7 81       	ldd	r31, Z+7	; 0x07
     e3e:	e0 2d       	mov	r30, r0
     e40:	b4 e0       	ldi	r27, 0x04	; 4
     e42:	e4 38       	cpi	r30, 0x84	; 132
     e44:	fb 07       	cpc	r31, r27
     e46:	09 f0       	breq	.+2      	; 0xe4a <_ZN8Robotarm18ArmDownReleaseItemEv+0xd8>
     e48:	b4 c0       	rjmp	.+360    	; 0xfb2 <_ZN8Robotarm18ArmDownReleaseItemEv+0x240>
     e4a:	20 e0       	ldi	r18, 0x00	; 0
     e4c:	30 e0       	ldi	r19, 0x00	; 0
     e4e:	a9 01       	movw	r20, r18
     e50:	f8 01       	movw	r30, r16
     e52:	66 81       	ldd	r22, Z+6	; 0x06
     e54:	77 81       	ldd	r23, Z+7	; 0x07
     e56:	80 85       	ldd	r24, Z+8	; 0x08
     e58:	91 85       	ldd	r25, Z+9	; 0x09
     e5a:	0e 94 9b 1d 	call	0x3b36	; 0x3b36 <__mulsf3>
     e5e:	d8 01       	movw	r26, r16
     e60:	52 96       	adiw	r26, 0x12	; 18
     e62:	2d 91       	ld	r18, X+
     e64:	3d 91       	ld	r19, X+
     e66:	4d 91       	ld	r20, X+
     e68:	5c 91       	ld	r21, X
     e6a:	55 97       	sbiw	r26, 0x15	; 21
     e6c:	0e 94 e9 1b 	call	0x37d2	; 0x37d2 <__addsf3>
     e70:	f8 01       	movw	r30, r16
     e72:	62 87       	std	Z+10, r22	; 0x0a
     e74:	73 87       	std	Z+11, r23	; 0x0b
     e76:	84 87       	std	Z+12, r24	; 0x0c
     e78:	95 87       	std	Z+13, r25	; 0x0d
	vTaskDelay( 250 / portTICK_RATE_MS );
     e7a:	8a ef       	ldi	r24, 0xFA	; 250
     e7c:	90 e0       	ldi	r25, 0x00	; 0
     e7e:	0e 94 97 12 	call	0x252e	; 0x252e <vTaskDelay>
	motors_[1]->SetDegrees(90);
     e82:	0c 81       	ldd	r16, Y+4	; 0x04
     e84:	1d 81       	ldd	r17, Y+5	; 0x05
     e86:	d8 01       	movw	r26, r16
     e88:	ed 91       	ld	r30, X+
     e8a:	fc 91       	ld	r31, X
     e8c:	06 80       	ldd	r0, Z+6	; 0x06
     e8e:	f7 81       	ldd	r31, Z+7	; 0x07
     e90:	e0 2d       	mov	r30, r0
     e92:	b4 e0       	ldi	r27, 0x04	; 4
     e94:	e4 38       	cpi	r30, 0x84	; 132
     e96:	fb 07       	cpc	r31, r27
     e98:	09 f0       	breq	.+2      	; 0xe9c <_ZN8Robotarm18ArmDownReleaseItemEv+0x12a>
     e9a:	87 c0       	rjmp	.+270    	; 0xfaa <_ZN8Robotarm18ArmDownReleaseItemEv+0x238>
	*    @param uint8_t	degrees to turn
	*    @return void Nothing
	*/
	virtual void SetDegrees( uint8_t degrees )
	{
		if ( maxDegrees_ >= degrees )
     e9c:	f8 01       	movw	r30, r16
     e9e:	86 89       	ldd	r24, Z+22	; 0x16
     ea0:	8a 35       	cpi	r24, 0x5A	; 90
     ea2:	c0 f0       	brcs	.+48     	; 0xed4 <_ZN8Robotarm18ArmDownReleaseItemEv+0x162>
		{
			percent_ = percentPrDeg * degrees + startpercent_;
     ea4:	20 e0       	ldi	r18, 0x00	; 0
     ea6:	30 e0       	ldi	r19, 0x00	; 0
     ea8:	44 eb       	ldi	r20, 0xB4	; 180
     eaa:	52 e4       	ldi	r21, 0x42	; 66
     eac:	66 81       	ldd	r22, Z+6	; 0x06
     eae:	77 81       	ldd	r23, Z+7	; 0x07
     eb0:	80 85       	ldd	r24, Z+8	; 0x08
     eb2:	91 85       	ldd	r25, Z+9	; 0x09
     eb4:	0e 94 9b 1d 	call	0x3b36	; 0x3b36 <__mulsf3>
     eb8:	d8 01       	movw	r26, r16
     eba:	52 96       	adiw	r26, 0x12	; 18
     ebc:	2d 91       	ld	r18, X+
     ebe:	3d 91       	ld	r19, X+
     ec0:	4d 91       	ld	r20, X+
     ec2:	5c 91       	ld	r21, X
     ec4:	55 97       	sbiw	r26, 0x15	; 21
     ec6:	0e 94 e9 1b 	call	0x37d2	; 0x37d2 <__addsf3>
     eca:	f8 01       	movw	r30, r16
     ecc:	62 87       	std	Z+10, r22	; 0x0a
     ece:	73 87       	std	Z+11, r23	; 0x0b
     ed0:	84 87       	std	Z+12, r24	; 0x0c
     ed2:	95 87       	std	Z+13, r25	; 0x0d
	motors_[2]->SetDegrees(90);
     ed4:	0e 81       	ldd	r16, Y+6	; 0x06
     ed6:	1f 81       	ldd	r17, Y+7	; 0x07
     ed8:	d8 01       	movw	r26, r16
     eda:	ed 91       	ld	r30, X+
     edc:	fc 91       	ld	r31, X
     ede:	06 80       	ldd	r0, Z+6	; 0x06
     ee0:	f7 81       	ldd	r31, Z+7	; 0x07
     ee2:	e0 2d       	mov	r30, r0
     ee4:	b4 e0       	ldi	r27, 0x04	; 4
     ee6:	e4 38       	cpi	r30, 0x84	; 132
     ee8:	fb 07       	cpc	r31, r27
     eea:	09 f0       	breq	.+2      	; 0xeee <_ZN8Robotarm18ArmDownReleaseItemEv+0x17c>
     eec:	5a c0       	rjmp	.+180    	; 0xfa2 <_ZN8Robotarm18ArmDownReleaseItemEv+0x230>
	*    @param uint8_t	degrees to turn
	*    @return void Nothing
	*/
	virtual void SetDegrees( uint8_t degrees )
	{
		if ( maxDegrees_ >= degrees )
     eee:	f8 01       	movw	r30, r16
     ef0:	86 89       	ldd	r24, Z+22	; 0x16
     ef2:	8a 35       	cpi	r24, 0x5A	; 90
     ef4:	c0 f0       	brcs	.+48     	; 0xf26 <_ZN8Robotarm18ArmDownReleaseItemEv+0x1b4>
		{
			percent_ = percentPrDeg * degrees + startpercent_;
     ef6:	20 e0       	ldi	r18, 0x00	; 0
     ef8:	30 e0       	ldi	r19, 0x00	; 0
     efa:	44 eb       	ldi	r20, 0xB4	; 180
     efc:	52 e4       	ldi	r21, 0x42	; 66
     efe:	66 81       	ldd	r22, Z+6	; 0x06
     f00:	77 81       	ldd	r23, Z+7	; 0x07
     f02:	80 85       	ldd	r24, Z+8	; 0x08
     f04:	91 85       	ldd	r25, Z+9	; 0x09
     f06:	0e 94 9b 1d 	call	0x3b36	; 0x3b36 <__mulsf3>
     f0a:	d8 01       	movw	r26, r16
     f0c:	52 96       	adiw	r26, 0x12	; 18
     f0e:	2d 91       	ld	r18, X+
     f10:	3d 91       	ld	r19, X+
     f12:	4d 91       	ld	r20, X+
     f14:	5c 91       	ld	r21, X
     f16:	55 97       	sbiw	r26, 0x15	; 21
     f18:	0e 94 e9 1b 	call	0x37d2	; 0x37d2 <__addsf3>
     f1c:	f8 01       	movw	r30, r16
     f1e:	62 87       	std	Z+10, r22	; 0x0a
     f20:	73 87       	std	Z+11, r23	; 0x0b
     f22:	84 87       	std	Z+12, r24	; 0x0c
     f24:	95 87       	std	Z+13, r25	; 0x0d
	motors_[3]->SetDegrees(90);
     f26:	08 84       	ldd	r0, Y+8	; 0x08
     f28:	d9 85       	ldd	r29, Y+9	; 0x09
     f2a:	c0 2d       	mov	r28, r0
     f2c:	e8 81       	ld	r30, Y
     f2e:	f9 81       	ldd	r31, Y+1	; 0x01
     f30:	06 80       	ldd	r0, Z+6	; 0x06
     f32:	f7 81       	ldd	r31, Z+7	; 0x07
     f34:	e0 2d       	mov	r30, r0
     f36:	84 e0       	ldi	r24, 0x04	; 4
     f38:	e4 38       	cpi	r30, 0x84	; 132
     f3a:	f8 07       	cpc	r31, r24
     f3c:	39 f5       	brne	.+78     	; 0xf8c <_ZN8Robotarm18ArmDownReleaseItemEv+0x21a>
	*    @param uint8_t	degrees to turn
	*    @return void Nothing
	*/
	virtual void SetDegrees( uint8_t degrees )
	{
		if ( maxDegrees_ >= degrees )
     f3e:	8e 89       	ldd	r24, Y+22	; 0x16
     f40:	8a 35       	cpi	r24, 0x5A	; 90
     f42:	a0 f0       	brcs	.+40     	; 0xf6c <_ZN8Robotarm18ArmDownReleaseItemEv+0x1fa>
		{
			percent_ = percentPrDeg * degrees + startpercent_;
     f44:	20 e0       	ldi	r18, 0x00	; 0
     f46:	30 e0       	ldi	r19, 0x00	; 0
     f48:	44 eb       	ldi	r20, 0xB4	; 180
     f4a:	52 e4       	ldi	r21, 0x42	; 66
     f4c:	6e 81       	ldd	r22, Y+6	; 0x06
     f4e:	7f 81       	ldd	r23, Y+7	; 0x07
     f50:	88 85       	ldd	r24, Y+8	; 0x08
     f52:	99 85       	ldd	r25, Y+9	; 0x09
     f54:	0e 94 9b 1d 	call	0x3b36	; 0x3b36 <__mulsf3>
     f58:	2a 89       	ldd	r18, Y+18	; 0x12
     f5a:	3b 89       	ldd	r19, Y+19	; 0x13
     f5c:	4c 89       	ldd	r20, Y+20	; 0x14
     f5e:	5d 89       	ldd	r21, Y+21	; 0x15
     f60:	0e 94 e9 1b 	call	0x37d2	; 0x37d2 <__addsf3>
     f64:	6a 87       	std	Y+10, r22	; 0x0a
     f66:	7b 87       	std	Y+11, r23	; 0x0b
     f68:	8c 87       	std	Y+12, r24	; 0x0c
     f6a:	9d 87       	std	Y+13, r25	; 0x0d
	vTaskDelay( 250 / portTICK_RATE_MS );
     f6c:	8a ef       	ldi	r24, 0xFA	; 250
     f6e:	90 e0       	ldi	r25, 0x00	; 0
}
     f70:	df 91       	pop	r29
     f72:	cf 91       	pop	r28
     f74:	1f 91       	pop	r17
     f76:	0f 91       	pop	r16
	motors_[5]->SetDegrees(0);
	vTaskDelay( 250 / portTICK_RATE_MS );
	motors_[1]->SetDegrees(90);
	motors_[2]->SetDegrees(90);
	motors_[3]->SetDegrees(90);
	vTaskDelay( 250 / portTICK_RATE_MS );
     f78:	0c 94 97 12 	jmp	0x252e	; 0x252e <vTaskDelay>

void Robotarm::ArmDownReleaseItem()
{
	vTaskDelay( 1500 / portTICK_RATE_MS );
	motors_[1]->SetDegrees(35);
	motors_[2]->SetDegrees(40);
     f7c:	68 e2       	ldi	r22, 0x28	; 40
     f7e:	c8 01       	movw	r24, r16
     f80:	19 95       	eicall
     f82:	52 cf       	rjmp	.-348    	; 0xe28 <_ZN8Robotarm18ArmDownReleaseItemEv+0xb6>
}

void Robotarm::ArmDownReleaseItem()
{
	vTaskDelay( 1500 / portTICK_RATE_MS );
	motors_[1]->SetDegrees(35);
     f84:	63 e2       	ldi	r22, 0x23	; 35
     f86:	c8 01       	movw	r24, r16
     f88:	19 95       	eicall
     f8a:	25 cf       	rjmp	.-438    	; 0xdd6 <_ZN8Robotarm18ArmDownReleaseItemEv+0x64>
	vTaskDelay( 1500 / portTICK_RATE_MS );
	motors_[5]->SetDegrees(0);
	vTaskDelay( 250 / portTICK_RATE_MS );
	motors_[1]->SetDegrees(90);
	motors_[2]->SetDegrees(90);
	motors_[3]->SetDegrees(90);
     f8c:	6a e5       	ldi	r22, 0x5A	; 90
     f8e:	ce 01       	movw	r24, r28
     f90:	19 95       	eicall
	vTaskDelay( 250 / portTICK_RATE_MS );
     f92:	8a ef       	ldi	r24, 0xFA	; 250
     f94:	90 e0       	ldi	r25, 0x00	; 0
}
     f96:	df 91       	pop	r29
     f98:	cf 91       	pop	r28
     f9a:	1f 91       	pop	r17
     f9c:	0f 91       	pop	r16
	motors_[5]->SetDegrees(0);
	vTaskDelay( 250 / portTICK_RATE_MS );
	motors_[1]->SetDegrees(90);
	motors_[2]->SetDegrees(90);
	motors_[3]->SetDegrees(90);
	vTaskDelay( 250 / portTICK_RATE_MS );
     f9e:	0c 94 97 12 	jmp	0x252e	; 0x252e <vTaskDelay>
	motors_[2]->SetDegrees(40);
	vTaskDelay( 1500 / portTICK_RATE_MS );
	motors_[5]->SetDegrees(0);
	vTaskDelay( 250 / portTICK_RATE_MS );
	motors_[1]->SetDegrees(90);
	motors_[2]->SetDegrees(90);
     fa2:	6a e5       	ldi	r22, 0x5A	; 90
     fa4:	c8 01       	movw	r24, r16
     fa6:	19 95       	eicall
     fa8:	be cf       	rjmp	.-132    	; 0xf26 <_ZN8Robotarm18ArmDownReleaseItemEv+0x1b4>
	motors_[1]->SetDegrees(35);
	motors_[2]->SetDegrees(40);
	vTaskDelay( 1500 / portTICK_RATE_MS );
	motors_[5]->SetDegrees(0);
	vTaskDelay( 250 / portTICK_RATE_MS );
	motors_[1]->SetDegrees(90);
     faa:	6a e5       	ldi	r22, 0x5A	; 90
     fac:	c8 01       	movw	r24, r16
     fae:	19 95       	eicall
     fb0:	91 cf       	rjmp	.-222    	; 0xed4 <_ZN8Robotarm18ArmDownReleaseItemEv+0x162>
{
	vTaskDelay( 1500 / portTICK_RATE_MS );
	motors_[1]->SetDegrees(35);
	motors_[2]->SetDegrees(40);
	vTaskDelay( 1500 / portTICK_RATE_MS );
	motors_[5]->SetDegrees(0);
     fb2:	60 e0       	ldi	r22, 0x00	; 0
     fb4:	c8 01       	movw	r24, r16
     fb6:	19 95       	eicall
     fb8:	60 cf       	rjmp	.-320    	; 0xe7a <_ZN8Robotarm18ArmDownReleaseItemEv+0x108>

00000fba <_ZN8Robotarm8MoveItemEh>:
	/* Create task to control motors */
	xTaskCreate(this->startMotorImpl,  ( signed char * ) "Motors", configMAIN_STACK_SIZE, this, tskIDLE_PRIORITY, NULL);
}

void Robotarm::MoveItem( uint8_t color )
{
     fba:	0f 93       	push	r16
     fbc:	1f 93       	push	r17
     fbe:	cf 93       	push	r28
     fc0:	df 93       	push	r29
     fc2:	ec 01       	movw	r28, r24
	switch ( color )
     fc4:	62 30       	cpi	r22, 0x02	; 2
     fc6:	09 f4       	brne	.+2      	; 0xfca <_ZN8Robotarm8MoveItemEh+0x10>
     fc8:	b9 c0       	rjmp	.+370    	; 0x113c <_ZN8Robotarm8MoveItemEh+0x182>
     fca:	18 f1       	brcs	.+70     	; 0x1012 <_ZN8Robotarm8MoveItemEh+0x58>
     fcc:	64 30       	cpi	r22, 0x04	; 4
     fce:	09 f4       	brne	.+2      	; 0xfd2 <_ZN8Robotarm8MoveItemEh+0x18>
     fd0:	5e c0       	rjmp	.+188    	; 0x108e <_ZN8Robotarm8MoveItemEh+0xd4>
     fd2:	08 f4       	brcc	.+2      	; 0xfd6 <_ZN8Robotarm8MoveItemEh+0x1c>
     fd4:	98 c0       	rjmp	.+304    	; 0x1106 <_ZN8Robotarm8MoveItemEh+0x14c>
     fd6:	65 30       	cpi	r22, 0x05	; 5
     fd8:	09 f0       	breq	.+2      	; 0xfdc <_ZN8Robotarm8MoveItemEh+0x22>
     fda:	74 c0       	rjmp	.+232    	; 0x10c4 <_ZN8Robotarm8MoveItemEh+0x10a>
		moveBlockToZoneFive();
		vTaskDelay( 500 / portTICK_RATE_MS );
		break;
		
		case 5U:
		grabBlock();
     fdc:	26 dd       	rcall	.-1460   	; 0xa2a <_ZN8Robotarm9grabBlockEv>
		vTaskDelay( 500 / portTICK_RATE_MS );
     fde:	84 ef       	ldi	r24, 0xF4	; 244
     fe0:	91 e0       	ldi	r25, 0x01	; 1
     fe2:	0e 94 97 12 	call	0x252e	; 0x252e <vTaskDelay>
	ArmDownReleaseItem();
}

void Robotarm::moveBlockToZoneSix()
{
	motors_[0]->SetDegrees(180);
     fe6:	0a 81       	ldd	r16, Y+2	; 0x02
     fe8:	1b 81       	ldd	r17, Y+3	; 0x03
     fea:	d8 01       	movw	r26, r16
     fec:	ed 91       	ld	r30, X+
     fee:	fc 91       	ld	r31, X
     ff0:	06 80       	ldd	r0, Z+6	; 0x06
     ff2:	f7 81       	ldd	r31, Z+7	; 0x07
     ff4:	e0 2d       	mov	r30, r0
     ff6:	b4 e0       	ldi	r27, 0x04	; 4
     ff8:	e4 38       	cpi	r30, 0x84	; 132
     ffa:	fb 07       	cpc	r31, r27
     ffc:	09 f0       	breq	.+2      	; 0x1000 <_ZN8Robotarm8MoveItemEh+0x46>
     ffe:	c9 c0       	rjmp	.+402    	; 0x1192 <_ZN8Robotarm8MoveItemEh+0x1d8>
	*    @param uint8_t	degrees to turn
	*    @return void Nothing
	*/
	virtual void SetDegrees( uint8_t degrees )
	{
		if ( maxDegrees_ >= degrees )
    1000:	f8 01       	movw	r30, r16
    1002:	86 89       	ldd	r24, Z+22	; 0x16
    1004:	84 3b       	cpi	r24, 0xB4	; 180
    1006:	c8 f1       	brcs	.+114    	; 0x107a <_ZN8Robotarm8MoveItemEh+0xc0>
		{
			percent_ = percentPrDeg * degrees + startpercent_;
    1008:	20 e0       	ldi	r18, 0x00	; 0
    100a:	30 e0       	ldi	r19, 0x00	; 0
    100c:	44 e3       	ldi	r20, 0x34	; 52
    100e:	53 e4       	ldi	r21, 0x43	; 67
    1010:	20 c0       	rjmp	.+64     	; 0x1052 <_ZN8Robotarm8MoveItemEh+0x98>
	xTaskCreate(this->startMotorImpl,  ( signed char * ) "Motors", configMAIN_STACK_SIZE, this, tskIDLE_PRIORITY, NULL);
}

void Robotarm::MoveItem( uint8_t color )
{
	switch ( color )
    1012:	66 23       	and	r22, r22
    1014:	09 f4       	brne	.+2      	; 0x1018 <_ZN8Robotarm8MoveItemEh+0x5e>
    1016:	5b c0       	rjmp	.+182    	; 0x10ce <_ZN8Robotarm8MoveItemEh+0x114>
    1018:	61 30       	cpi	r22, 0x01	; 1
    101a:	09 f0       	breq	.+2      	; 0x101e <_ZN8Robotarm8MoveItemEh+0x64>
		moveBlockToZoneOne();
		vTaskDelay( 500 / portTICK_RATE_MS );
		break;
		
		case 1U:
		grabBlock();
    101c:	53 c0       	rjmp	.+166    	; 0x10c4 <_ZN8Robotarm8MoveItemEh+0x10a>
    101e:	05 dd       	rcall	.-1526   	; 0xa2a <_ZN8Robotarm9grabBlockEv>
		vTaskDelay( 500 / portTICK_RATE_MS );
    1020:	84 ef       	ldi	r24, 0xF4	; 244
    1022:	91 e0       	ldi	r25, 0x01	; 1
    1024:	0e 94 97 12 	call	0x252e	; 0x252e <vTaskDelay>
	ArmDownReleaseItem();
}

void Robotarm::moveBlockToZoneTwo()
{
	motors_[0]->SetDegrees(68);
    1028:	0a 81       	ldd	r16, Y+2	; 0x02
    102a:	1b 81       	ldd	r17, Y+3	; 0x03
    102c:	d8 01       	movw	r26, r16
    102e:	ed 91       	ld	r30, X+
    1030:	fc 91       	ld	r31, X
    1032:	06 80       	ldd	r0, Z+6	; 0x06
    1034:	f7 81       	ldd	r31, Z+7	; 0x07
    1036:	e0 2d       	mov	r30, r0
    1038:	b4 e0       	ldi	r27, 0x04	; 4
    103a:	e4 38       	cpi	r30, 0x84	; 132
    103c:	fb 07       	cpc	r31, r27
    103e:	09 f0       	breq	.+2      	; 0x1042 <_ZN8Robotarm8MoveItemEh+0x88>
    1040:	98 c0       	rjmp	.+304    	; 0x1172 <_ZN8Robotarm8MoveItemEh+0x1b8>
	*    @param uint8_t	degrees to turn
	*    @return void Nothing
	*/
	virtual void SetDegrees( uint8_t degrees )
	{
		if ( maxDegrees_ >= degrees )
    1042:	f8 01       	movw	r30, r16
    1044:	86 89       	ldd	r24, Z+22	; 0x16
    1046:	84 34       	cpi	r24, 0x44	; 68
    1048:	c0 f0       	brcs	.+48     	; 0x107a <_ZN8Robotarm8MoveItemEh+0xc0>
		{
			percent_ = percentPrDeg * degrees + startpercent_;
    104a:	20 e0       	ldi	r18, 0x00	; 0
    104c:	30 e0       	ldi	r19, 0x00	; 0
    104e:	48 e8       	ldi	r20, 0x88	; 136
    1050:	52 e4       	ldi	r21, 0x42	; 66
    1052:	66 81       	ldd	r22, Z+6	; 0x06
    1054:	77 81       	ldd	r23, Z+7	; 0x07
    1056:	80 85       	ldd	r24, Z+8	; 0x08
    1058:	91 85       	ldd	r25, Z+9	; 0x09
    105a:	0e 94 9b 1d 	call	0x3b36	; 0x3b36 <__mulsf3>
    105e:	d8 01       	movw	r26, r16
    1060:	52 96       	adiw	r26, 0x12	; 18
    1062:	2d 91       	ld	r18, X+
    1064:	3d 91       	ld	r19, X+
    1066:	4d 91       	ld	r20, X+
    1068:	5c 91       	ld	r21, X
    106a:	55 97       	sbiw	r26, 0x15	; 21
    106c:	0e 94 e9 1b 	call	0x37d2	; 0x37d2 <__addsf3>
    1070:	f8 01       	movw	r30, r16
    1072:	62 87       	std	Z+10, r22	; 0x0a
    1074:	73 87       	std	Z+11, r23	; 0x0b
    1076:	84 87       	std	Z+12, r24	; 0x0c
}

void Robotarm::moveBlockToZoneOne()
{
	motors_[0]->SetDegrees(40);
	ArmDownReleaseItem();
    1078:	95 87       	std	Z+13, r25	; 0x0d
    107a:	ce 01       	movw	r24, r28
    107c:	7a de       	rcall	.-780    	; 0xd72 <_ZN8Robotarm18ArmDownReleaseItemEv>
	{
		case 0U:
		grabBlock();
		vTaskDelay( 500 / portTICK_RATE_MS ); // This might not be needed!!! it can be added in Robotarm!!!! we will seeee later
		moveBlockToZoneOne();
		vTaskDelay( 500 / portTICK_RATE_MS );
    107e:	84 ef       	ldi	r24, 0xF4	; 244
    1080:	91 e0       	ldi	r25, 0x01	; 1
		break;
		
		default:
		break;
	}
}
    1082:	df 91       	pop	r29
    1084:	cf 91       	pop	r28
    1086:	1f 91       	pop	r17
	{
		case 0U:
		grabBlock();
		vTaskDelay( 500 / portTICK_RATE_MS ); // This might not be needed!!! it can be added in Robotarm!!!! we will seeee later
		moveBlockToZoneOne();
		vTaskDelay( 500 / portTICK_RATE_MS );
    1088:	0f 91       	pop	r16
    108a:	0c 94 97 12 	jmp	0x252e	; 0x252e <vTaskDelay>
		moveBlockToZoneFour();
		vTaskDelay( 500 / portTICK_RATE_MS );
		break;
		
		case 4U:
		grabBlock();
    108e:	cd dc       	rcall	.-1638   	; 0xa2a <_ZN8Robotarm9grabBlockEv>
		vTaskDelay( 500 / portTICK_RATE_MS );
    1090:	84 ef       	ldi	r24, 0xF4	; 244
    1092:	91 e0       	ldi	r25, 0x01	; 1
    1094:	0e 94 97 12 	call	0x252e	; 0x252e <vTaskDelay>
	ArmDownReleaseItem();
}

void Robotarm::moveBlockToZoneFive()
{
	motors_[0]->SetDegrees(152);
    1098:	0a 81       	ldd	r16, Y+2	; 0x02
    109a:	1b 81       	ldd	r17, Y+3	; 0x03
    109c:	d8 01       	movw	r26, r16
    109e:	ed 91       	ld	r30, X+
    10a0:	fc 91       	ld	r31, X
    10a2:	06 80       	ldd	r0, Z+6	; 0x06
    10a4:	f7 81       	ldd	r31, Z+7	; 0x07
    10a6:	e0 2d       	mov	r30, r0
    10a8:	b4 e0       	ldi	r27, 0x04	; 4
    10aa:	e4 38       	cpi	r30, 0x84	; 132
    10ac:	fb 07       	cpc	r31, r27
    10ae:	09 f0       	breq	.+2      	; 0x10b2 <_ZN8Robotarm8MoveItemEh+0xf8>
    10b0:	74 c0       	rjmp	.+232    	; 0x119a <_ZN8Robotarm8MoveItemEh+0x1e0>
	*    @param uint8_t	degrees to turn
	*    @return void Nothing
	*/
	virtual void SetDegrees( uint8_t degrees )
	{
		if ( maxDegrees_ >= degrees )
    10b2:	f8 01       	movw	r30, r16
    10b4:	86 89       	ldd	r24, Z+22	; 0x16
    10b6:	88 39       	cpi	r24, 0x98	; 152
    10b8:	00 f3       	brcs	.-64     	; 0x107a <_ZN8Robotarm8MoveItemEh+0xc0>
		{
			percent_ = percentPrDeg * degrees + startpercent_;
    10ba:	20 e0       	ldi	r18, 0x00	; 0
    10bc:	30 e0       	ldi	r19, 0x00	; 0
    10be:	48 e1       	ldi	r20, 0x18	; 24
    10c0:	53 e4       	ldi	r21, 0x43	; 67
    10c2:	c7 cf       	rjmp	.-114    	; 0x1052 <_ZN8Robotarm8MoveItemEh+0x98>
		break;
		
		default:
		break;
	}
}
    10c4:	df 91       	pop	r29
    10c6:	cf 91       	pop	r28
    10c8:	1f 91       	pop	r17
    10ca:	0f 91       	pop	r16
void Robotarm::MoveItem( uint8_t color )
{
	switch ( color )
	{
		case 0U:
		grabBlock();
    10cc:	08 95       	ret
    10ce:	ad dc       	rcall	.-1702   	; 0xa2a <_ZN8Robotarm9grabBlockEv>
		vTaskDelay( 500 / portTICK_RATE_MS ); // This might not be needed!!! it can be added in Robotarm!!!! we will seeee later
    10d0:	84 ef       	ldi	r24, 0xF4	; 244
    10d2:	91 e0       	ldi	r25, 0x01	; 1
    10d4:	0e 94 97 12 	call	0x252e	; 0x252e <vTaskDelay>
	motors_[3]->SetDegrees(70);
}

void Robotarm::moveBlockToZoneOne()
{
	motors_[0]->SetDegrees(40);
    10d8:	0a 81       	ldd	r16, Y+2	; 0x02
    10da:	1b 81       	ldd	r17, Y+3	; 0x03
    10dc:	d8 01       	movw	r26, r16
    10de:	ed 91       	ld	r30, X+
    10e0:	fc 91       	ld	r31, X
    10e2:	06 80       	ldd	r0, Z+6	; 0x06
    10e4:	f7 81       	ldd	r31, Z+7	; 0x07
    10e6:	e0 2d       	mov	r30, r0
    10e8:	b4 e0       	ldi	r27, 0x04	; 4
    10ea:	e4 38       	cpi	r30, 0x84	; 132
    10ec:	fb 07       	cpc	r31, r27
    10ee:	09 f0       	breq	.+2      	; 0x10f2 <_ZN8Robotarm8MoveItemEh+0x138>
    10f0:	4c c0       	rjmp	.+152    	; 0x118a <_ZN8Robotarm8MoveItemEh+0x1d0>
	*    @param uint8_t	degrees to turn
	*    @return void Nothing
	*/
	virtual void SetDegrees( uint8_t degrees )
	{
		if ( maxDegrees_ >= degrees )
    10f2:	f8 01       	movw	r30, r16
    10f4:	86 89       	ldd	r24, Z+22	; 0x16
    10f6:	88 32       	cpi	r24, 0x28	; 40
    10f8:	08 f4       	brcc	.+2      	; 0x10fc <_ZN8Robotarm8MoveItemEh+0x142>
    10fa:	bf cf       	rjmp	.-130    	; 0x107a <_ZN8Robotarm8MoveItemEh+0xc0>
		{
			percent_ = percentPrDeg * degrees + startpercent_;
    10fc:	20 e0       	ldi	r18, 0x00	; 0
    10fe:	30 e0       	ldi	r19, 0x00	; 0
    1100:	40 e2       	ldi	r20, 0x20	; 32
    1102:	52 e4       	ldi	r21, 0x42	; 66
		moveBlockToZoneThree();
		vTaskDelay( 500 / portTICK_RATE_MS );
		break;
		
		case 3U:
		grabBlock();
    1104:	a6 cf       	rjmp	.-180    	; 0x1052 <_ZN8Robotarm8MoveItemEh+0x98>
    1106:	91 dc       	rcall	.-1758   	; 0xa2a <_ZN8Robotarm9grabBlockEv>
		vTaskDelay( 500 / portTICK_RATE_MS );
    1108:	84 ef       	ldi	r24, 0xF4	; 244
    110a:	91 e0       	ldi	r25, 0x01	; 1
    110c:	0e 94 97 12 	call	0x252e	; 0x252e <vTaskDelay>
	ArmDownReleaseItem();
}

void Robotarm::moveBlockToZoneFour()
{
	motors_[0]->SetDegrees(124);
    1110:	0a 81       	ldd	r16, Y+2	; 0x02
    1112:	1b 81       	ldd	r17, Y+3	; 0x03
    1114:	d8 01       	movw	r26, r16
    1116:	ed 91       	ld	r30, X+
    1118:	fc 91       	ld	r31, X
    111a:	06 80       	ldd	r0, Z+6	; 0x06
    111c:	f7 81       	ldd	r31, Z+7	; 0x07
    111e:	e0 2d       	mov	r30, r0
    1120:	b4 e0       	ldi	r27, 0x04	; 4
    1122:	e4 38       	cpi	r30, 0x84	; 132
    1124:	fb 07       	cpc	r31, r27
    1126:	69 f5       	brne	.+90     	; 0x1182 <_ZN8Robotarm8MoveItemEh+0x1c8>
	*    @param uint8_t	degrees to turn
	*    @return void Nothing
	*/
	virtual void SetDegrees( uint8_t degrees )
	{
		if ( maxDegrees_ >= degrees )
    1128:	f8 01       	movw	r30, r16
    112a:	86 89       	ldd	r24, Z+22	; 0x16
    112c:	8c 37       	cpi	r24, 0x7C	; 124
    112e:	08 f4       	brcc	.+2      	; 0x1132 <_ZN8Robotarm8MoveItemEh+0x178>
		{
			percent_ = percentPrDeg * degrees + startpercent_;
    1130:	a4 cf       	rjmp	.-184    	; 0x107a <_ZN8Robotarm8MoveItemEh+0xc0>
    1132:	20 e0       	ldi	r18, 0x00	; 0
    1134:	30 e0       	ldi	r19, 0x00	; 0
    1136:	48 ef       	ldi	r20, 0xF8	; 248
    1138:	52 e4       	ldi	r21, 0x42	; 66
		moveBlockToZoneTwo();
		vTaskDelay( 500 / portTICK_RATE_MS );
		break;
		
		case 2U:
		grabBlock();
    113a:	8b cf       	rjmp	.-234    	; 0x1052 <_ZN8Robotarm8MoveItemEh+0x98>
    113c:	76 dc       	rcall	.-1812   	; 0xa2a <_ZN8Robotarm9grabBlockEv>
		vTaskDelay( 500 / portTICK_RATE_MS );
    113e:	84 ef       	ldi	r24, 0xF4	; 244
    1140:	91 e0       	ldi	r25, 0x01	; 1
    1142:	0e 94 97 12 	call	0x252e	; 0x252e <vTaskDelay>
	ArmDownReleaseItem();
}

void Robotarm::moveBlockToZoneThree()
{
	motors_[0]->SetDegrees(96);
    1146:	0a 81       	ldd	r16, Y+2	; 0x02
    1148:	1b 81       	ldd	r17, Y+3	; 0x03
    114a:	d8 01       	movw	r26, r16
    114c:	ed 91       	ld	r30, X+
    114e:	fc 91       	ld	r31, X
    1150:	06 80       	ldd	r0, Z+6	; 0x06
    1152:	f7 81       	ldd	r31, Z+7	; 0x07
    1154:	e0 2d       	mov	r30, r0
    1156:	b4 e0       	ldi	r27, 0x04	; 4
    1158:	e4 38       	cpi	r30, 0x84	; 132
    115a:	fb 07       	cpc	r31, r27
    115c:	71 f4       	brne	.+28     	; 0x117a <_ZN8Robotarm8MoveItemEh+0x1c0>
	*    @param uint8_t	degrees to turn
	*    @return void Nothing
	*/
	virtual void SetDegrees( uint8_t degrees )
	{
		if ( maxDegrees_ >= degrees )
    115e:	f8 01       	movw	r30, r16
    1160:	86 89       	ldd	r24, Z+22	; 0x16
    1162:	80 36       	cpi	r24, 0x60	; 96
    1164:	08 f4       	brcc	.+2      	; 0x1168 <_ZN8Robotarm8MoveItemEh+0x1ae>
    1166:	89 cf       	rjmp	.-238    	; 0x107a <_ZN8Robotarm8MoveItemEh+0xc0>
		{
			percent_ = percentPrDeg * degrees + startpercent_;
    1168:	20 e0       	ldi	r18, 0x00	; 0
    116a:	30 e0       	ldi	r19, 0x00	; 0
    116c:	40 ec       	ldi	r20, 0xC0	; 192
    116e:	52 e4       	ldi	r21, 0x42	; 66
    1170:	70 cf       	rjmp	.-288    	; 0x1052 <_ZN8Robotarm8MoveItemEh+0x98>
	ArmDownReleaseItem();
}

void Robotarm::moveBlockToZoneTwo()
{
	motors_[0]->SetDegrees(68);
    1172:	64 e4       	ldi	r22, 0x44	; 68
    1174:	c8 01       	movw	r24, r16
    1176:	19 95       	eicall
    1178:	80 cf       	rjmp	.-256    	; 0x107a <_ZN8Robotarm8MoveItemEh+0xc0>
	ArmDownReleaseItem();
}

void Robotarm::moveBlockToZoneThree()
{
	motors_[0]->SetDegrees(96);
    117a:	60 e6       	ldi	r22, 0x60	; 96
    117c:	c8 01       	movw	r24, r16
    117e:	19 95       	eicall
    1180:	7c cf       	rjmp	.-264    	; 0x107a <_ZN8Robotarm8MoveItemEh+0xc0>
	ArmDownReleaseItem();
}

void Robotarm::moveBlockToZoneFour()
{
	motors_[0]->SetDegrees(124);
    1182:	6c e7       	ldi	r22, 0x7C	; 124
    1184:	c8 01       	movw	r24, r16
    1186:	19 95       	eicall
    1188:	78 cf       	rjmp	.-272    	; 0x107a <_ZN8Robotarm8MoveItemEh+0xc0>
	motors_[3]->SetDegrees(70);
}

void Robotarm::moveBlockToZoneOne()
{
	motors_[0]->SetDegrees(40);
    118a:	68 e2       	ldi	r22, 0x28	; 40
    118c:	c8 01       	movw	r24, r16
    118e:	19 95       	eicall
    1190:	74 cf       	rjmp	.-280    	; 0x107a <_ZN8Robotarm8MoveItemEh+0xc0>
	ArmDownReleaseItem();
}

void Robotarm::moveBlockToZoneSix()
{
	motors_[0]->SetDegrees(180);
    1192:	64 eb       	ldi	r22, 0xB4	; 180
    1194:	c8 01       	movw	r24, r16
    1196:	19 95       	eicall
    1198:	70 cf       	rjmp	.-288    	; 0x107a <_ZN8Robotarm8MoveItemEh+0xc0>
	ArmDownReleaseItem();
}

void Robotarm::moveBlockToZoneFive()
{
	motors_[0]->SetDegrees(152);
    119a:	68 e9       	ldi	r22, 0x98	; 152
    119c:	c8 01       	movw	r24, r16
    119e:	19 95       	eicall
    11a0:	6c cf       	rjmp	.-296    	; 0x107a <_ZN8Robotarm8MoveItemEh+0xc0>

000011a2 <_ZN2M1D1Ev>:
	SetDegrees( 90 );
	tmr1Ptr_->setDutyCycleComA( percent_ );
	oldPercent_ = percent_;
} 

M1::~M1()
    11a2:	08 95       	ret

000011a4 <_ZN2M1D0Ev>:
{
}
    11a4:	7a cb       	rjmp	.-2316   	; 0x89a <_ZdlPv>

000011a6 <_ZN2M19TurnMotorEv>:

void M1::TurnMotor()
{
    11a6:	4f 92       	push	r4
    11a8:	5f 92       	push	r5
    11aa:	6f 92       	push	r6
    11ac:	7f 92       	push	r7
    11ae:	8f 92       	push	r8
    11b0:	9f 92       	push	r9
    11b2:	af 92       	push	r10
    11b4:	bf 92       	push	r11
    11b6:	cf 92       	push	r12
    11b8:	df 92       	push	r13
    11ba:	ef 92       	push	r14
    11bc:	ff 92       	push	r15
    11be:	cf 93       	push	r28
    11c0:	df 93       	push	r29
    11c2:	ec 01       	movw	r28, r24
	if ( percent_ > oldPercent_ + PERCENT_PR_TICK )
    11c4:	8a 84       	ldd	r8, Y+10	; 0x0a
    11c6:	9b 84       	ldd	r9, Y+11	; 0x0b
    11c8:	ac 84       	ldd	r10, Y+12	; 0x0c
    11ca:	bd 84       	ldd	r11, Y+13	; 0x0d
    11cc:	ce 84       	ldd	r12, Y+14	; 0x0e
    11ce:	df 84       	ldd	r13, Y+15	; 0x0f
    11d0:	e8 88       	ldd	r14, Y+16	; 0x10
    11d2:	f9 88       	ldd	r15, Y+17	; 0x11
    11d4:	20 e0       	ldi	r18, 0x00	; 0
    11d6:	30 e0       	ldi	r19, 0x00	; 0
    11d8:	40 e8       	ldi	r20, 0x80	; 128
    11da:	5d e3       	ldi	r21, 0x3D	; 61
    11dc:	c7 01       	movw	r24, r14
    11de:	b6 01       	movw	r22, r12
    11e0:	0e 94 e9 1b 	call	0x37d2	; 0x37d2 <__addsf3>
    11e4:	2b 01       	movw	r4, r22
    11e6:	3c 01       	movw	r6, r24
    11e8:	9b 01       	movw	r18, r22
    11ea:	ac 01       	movw	r20, r24
    11ec:	c5 01       	movw	r24, r10
    11ee:	b4 01       	movw	r22, r8
    11f0:	0e 94 97 1d 	call	0x3b2e	; 0x3b2e <__gesf2>
    11f4:	18 16       	cp	r1, r24
    11f6:	d4 f1       	brlt	.+116    	; 0x126c <_ZN2M19TurnMotorEv+0xc6>
	{
		oldPercent_ += PERCENT_PR_TICK;
		tmr1Ptr_->setDutyCycleComA( oldPercent_ );
		vTaskDelay( delay_ / portTICK_RATE_MS );
	}
	else if ( percent_ < oldPercent_ )
    11f8:	a7 01       	movw	r20, r14
    11fa:	96 01       	movw	r18, r12
    11fc:	c5 01       	movw	r24, r10
    11fe:	b4 01       	movw	r22, r8
    1200:	0e 94 4d 1c 	call	0x389a	; 0x389a <__cmpsf2>
    1204:	87 fd       	sbrc	r24, 7
    1206:	0f c0       	rjmp	.+30     	; 0x1226 <_ZN2M19TurnMotorEv+0x80>
	{
		oldPercent_ -= PERCENT_PR_TICK;
		tmr1Ptr_->setDutyCycleComA( oldPercent_ );
		vTaskDelay( delay_ / portTICK_RATE_MS );
	}
}
    1208:	df 91       	pop	r29
    120a:	cf 91       	pop	r28
    120c:	ff 90       	pop	r15
    120e:	ef 90       	pop	r14
    1210:	df 90       	pop	r13
    1212:	cf 90       	pop	r12
    1214:	bf 90       	pop	r11
    1216:	af 90       	pop	r10
    1218:	9f 90       	pop	r9
    121a:	8f 90       	pop	r8
    121c:	7f 90       	pop	r7
    121e:	6f 90       	pop	r6
    1220:	5f 90       	pop	r5
    1222:	4f 90       	pop	r4
    1224:	08 95       	ret
		tmr1Ptr_->setDutyCycleComA( oldPercent_ );
		vTaskDelay( delay_ / portTICK_RATE_MS );
	}
	else if ( percent_ < oldPercent_ )
	{
		oldPercent_ -= PERCENT_PR_TICK;
    1226:	20 e0       	ldi	r18, 0x00	; 0
    1228:	30 e0       	ldi	r19, 0x00	; 0
    122a:	40 e8       	ldi	r20, 0x80	; 128
    122c:	5d e3       	ldi	r21, 0x3D	; 61
    122e:	c7 01       	movw	r24, r14
    1230:	b6 01       	movw	r22, r12
    1232:	0e 94 e8 1b 	call	0x37d0	; 0x37d0 <__subsf3>
    1236:	ab 01       	movw	r20, r22
    1238:	bc 01       	movw	r22, r24
    123a:	4e 87       	std	Y+14, r20	; 0x0e
    123c:	5f 87       	std	Y+15, r21	; 0x0f
    123e:	68 8b       	std	Y+16, r22	; 0x10
    1240:	79 8b       	std	Y+17, r23	; 0x11
		tmr1Ptr_->setDutyCycleComA( oldPercent_ );
    1242:	8a 81       	ldd	r24, Y+2	; 0x02
    1244:	9b 81       	ldd	r25, Y+3	; 0x03
    1246:	80 d3       	rcall	.+1792   	; 0x1948 <_ZN6Timer116setDutyCycleComAEf>
		vTaskDelay( delay_ / portTICK_RATE_MS );
    1248:	8f 89       	ldd	r24, Y+23	; 0x17
    124a:	98 8d       	ldd	r25, Y+24	; 0x18
	}
}
    124c:	df 91       	pop	r29
    124e:	cf 91       	pop	r28
    1250:	ff 90       	pop	r15
    1252:	ef 90       	pop	r14
    1254:	df 90       	pop	r13
    1256:	cf 90       	pop	r12
    1258:	bf 90       	pop	r11
    125a:	af 90       	pop	r10
    125c:	9f 90       	pop	r9
    125e:	8f 90       	pop	r8
    1260:	7f 90       	pop	r7
    1262:	6f 90       	pop	r6
    1264:	5f 90       	pop	r5
    1266:	4f 90       	pop	r4
	}
	else if ( percent_ < oldPercent_ )
	{
		oldPercent_ -= PERCENT_PR_TICK;
		tmr1Ptr_->setDutyCycleComA( oldPercent_ );
		vTaskDelay( delay_ / portTICK_RATE_MS );
    1268:	0c 94 97 12 	jmp	0x252e	; 0x252e <vTaskDelay>

void M1::TurnMotor()
{
	if ( percent_ > oldPercent_ + PERCENT_PR_TICK )
	{
		oldPercent_ += PERCENT_PR_TICK;
    126c:	4e 86       	std	Y+14, r4	; 0x0e
    126e:	5f 86       	std	Y+15, r5	; 0x0f
    1270:	68 8a       	std	Y+16, r6	; 0x10
    1272:	79 8a       	std	Y+17, r7	; 0x11
		tmr1Ptr_->setDutyCycleComA( oldPercent_ );
    1274:	b3 01       	movw	r22, r6
    1276:	a2 01       	movw	r20, r4
    1278:	e4 cf       	rjmp	.-56     	; 0x1242 <_ZN2M19TurnMotorEv+0x9c>

0000127a <_ZN2M1C1EP6Timer1>:
* Author: jespe
*/

#include "M1.h"

M1::M1( Timer1* tmr )
    127a:	cf 93       	push	r28
    127c:	df 93       	push	r29
    127e:	ec 01       	movw	r28, r24
    1280:	cb 01       	movw	r24, r22
    1282:	20 eb       	ldi	r18, 0xB0	; 176
    1284:	32 e0       	ldi	r19, 0x02	; 2
    1286:	39 83       	std	Y+1, r19	; 0x01
    1288:	28 83       	st	Y, r18
{
	/* Store timer pointer */
	tmr1Ptr_ = tmr;
    128a:	7b 83       	std	Y+3, r23	; 0x03
    128c:	6a 83       	std	Y+2, r22	; 0x02
	
	/* This value is number of percent to add or subtract pr degree. */
	percentPrDeg = 0.0555555555555556;
    128e:	49 e3       	ldi	r20, 0x39	; 57
    1290:	5e e8       	ldi	r21, 0x8E	; 142
    1292:	63 e6       	ldi	r22, 0x63	; 99
    1294:	7d e3       	ldi	r23, 0x3D	; 61
    1296:	4e 83       	std	Y+6, r20	; 0x06
    1298:	5f 83       	std	Y+7, r21	; 0x07
    129a:	68 87       	std	Y+8, r22	; 0x08
    129c:	79 87       	std	Y+9, r23	; 0x09
	
	/* This value is the lowest duty cycle percentage needed to make motor turn. */
	startpercent_ = 2.5;
    129e:	40 e0       	ldi	r20, 0x00	; 0
    12a0:	50 e0       	ldi	r21, 0x00	; 0
    12a2:	60 e2       	ldi	r22, 0x20	; 32
    12a4:	70 e4       	ldi	r23, 0x40	; 64
    12a6:	4a 8b       	std	Y+18, r20	; 0x12
    12a8:	5b 8b       	std	Y+19, r21	; 0x13
    12aa:	6c 8b       	std	Y+20, r22	; 0x14
    12ac:	7d 8b       	std	Y+21, r23	; 0x15
	
	/* This value is the delay on motor. A lower value makes motors go faster and higher value makes motors go slower. */
	delay_ = 10;
    12ae:	2a e0       	ldi	r18, 0x0A	; 10
    12b0:	30 e0       	ldi	r19, 0x00	; 0
    12b2:	38 8f       	std	Y+24, r19	; 0x18
    12b4:	2f 8b       	std	Y+23, r18	; 0x17
	
	/* This value is the maximum number of degrees the motor can turn */
	maxDegrees_ = 180;
    12b6:	24 eb       	ldi	r18, 0xB4	; 180
    12b8:	2e 8b       	std	Y+22, r18	; 0x16
    12ba:	40 e0       	ldi	r20, 0x00	; 0
    12bc:	50 e0       	ldi	r21, 0x00	; 0
    12be:	60 ef       	ldi	r22, 0xF0	; 240
    12c0:	70 e4       	ldi	r23, 0x40	; 64
    12c2:	4a 87       	std	Y+10, r20	; 0x0a
    12c4:	5b 87       	std	Y+11, r21	; 0x0b
    12c6:	6c 87       	std	Y+12, r22	; 0x0c
    12c8:	7d 87       	std	Y+13, r23	; 0x0d
	
	/* Set motor to default startup value */
	SetDegrees( 90 );
	tmr1Ptr_->setDutyCycleComA( percent_ );
    12ca:	3e d3       	rcall	.+1660   	; 0x1948 <_ZN6Timer116setDutyCycleComAEf>
	oldPercent_ = percent_;
    12cc:	8a 85       	ldd	r24, Y+10	; 0x0a
    12ce:	9b 85       	ldd	r25, Y+11	; 0x0b
    12d0:	ac 85       	ldd	r26, Y+12	; 0x0c
    12d2:	bd 85       	ldd	r27, Y+13	; 0x0d
    12d4:	8e 87       	std	Y+14, r24	; 0x0e
    12d6:	9f 87       	std	Y+15, r25	; 0x0f
    12d8:	a8 8b       	std	Y+16, r26	; 0x10
    12da:	b9 8b       	std	Y+17, r27	; 0x11
} 
    12dc:	df 91       	pop	r29
    12de:	cf 91       	pop	r28
    12e0:	08 95       	ret

000012e2 <_ZN2M2D1Ev>:
	SetDegrees( 90 );
	tmr1Ptr_->setDutyCycleComB( percent_ );
	oldPercent_ = percent_;
}

M2::~M2()
    12e2:	08 95       	ret

000012e4 <_ZN2M2D0Ev>:
{
}
    12e4:	da ca       	rjmp	.-2636   	; 0x89a <_ZdlPv>

000012e6 <_ZN2M29TurnMotorEv>:

void M2::TurnMotor()
{
    12e6:	4f 92       	push	r4
    12e8:	5f 92       	push	r5
    12ea:	6f 92       	push	r6
    12ec:	7f 92       	push	r7
    12ee:	8f 92       	push	r8
    12f0:	9f 92       	push	r9
    12f2:	af 92       	push	r10
    12f4:	bf 92       	push	r11
    12f6:	cf 92       	push	r12
    12f8:	df 92       	push	r13
    12fa:	ef 92       	push	r14
    12fc:	ff 92       	push	r15
    12fe:	cf 93       	push	r28
    1300:	df 93       	push	r29
    1302:	ec 01       	movw	r28, r24
	if ( percent_ > oldPercent_ + PERCENT_PR_TICK )
    1304:	8a 84       	ldd	r8, Y+10	; 0x0a
    1306:	9b 84       	ldd	r9, Y+11	; 0x0b
    1308:	ac 84       	ldd	r10, Y+12	; 0x0c
    130a:	bd 84       	ldd	r11, Y+13	; 0x0d
    130c:	ce 84       	ldd	r12, Y+14	; 0x0e
    130e:	df 84       	ldd	r13, Y+15	; 0x0f
    1310:	e8 88       	ldd	r14, Y+16	; 0x10
    1312:	f9 88       	ldd	r15, Y+17	; 0x11
    1314:	20 e0       	ldi	r18, 0x00	; 0
    1316:	30 e0       	ldi	r19, 0x00	; 0
    1318:	40 e8       	ldi	r20, 0x80	; 128
    131a:	5d e3       	ldi	r21, 0x3D	; 61
    131c:	c7 01       	movw	r24, r14
    131e:	b6 01       	movw	r22, r12
    1320:	0e 94 e9 1b 	call	0x37d2	; 0x37d2 <__addsf3>
    1324:	2b 01       	movw	r4, r22
    1326:	3c 01       	movw	r6, r24
    1328:	9b 01       	movw	r18, r22
    132a:	ac 01       	movw	r20, r24
    132c:	c5 01       	movw	r24, r10
    132e:	b4 01       	movw	r22, r8
    1330:	0e 94 97 1d 	call	0x3b2e	; 0x3b2e <__gesf2>
    1334:	18 16       	cp	r1, r24
    1336:	d4 f1       	brlt	.+116    	; 0x13ac <_ZN2M29TurnMotorEv+0xc6>
	{
		oldPercent_ += PERCENT_PR_TICK;
		tmr1Ptr_->setDutyCycleComB( oldPercent_ );
		vTaskDelay( delay_ / portTICK_RATE_MS );
	}
	else if ( percent_ < oldPercent_ )
    1338:	a7 01       	movw	r20, r14
    133a:	96 01       	movw	r18, r12
    133c:	c5 01       	movw	r24, r10
    133e:	b4 01       	movw	r22, r8
    1340:	0e 94 4d 1c 	call	0x389a	; 0x389a <__cmpsf2>
    1344:	87 fd       	sbrc	r24, 7
    1346:	0f c0       	rjmp	.+30     	; 0x1366 <_ZN2M29TurnMotorEv+0x80>
	{
		oldPercent_ -= PERCENT_PR_TICK;
		tmr1Ptr_->setDutyCycleComB( oldPercent_ );
		vTaskDelay( delay_ / portTICK_RATE_MS );
	}
}
    1348:	df 91       	pop	r29
    134a:	cf 91       	pop	r28
    134c:	ff 90       	pop	r15
    134e:	ef 90       	pop	r14
    1350:	df 90       	pop	r13
    1352:	cf 90       	pop	r12
    1354:	bf 90       	pop	r11
    1356:	af 90       	pop	r10
    1358:	9f 90       	pop	r9
    135a:	8f 90       	pop	r8
    135c:	7f 90       	pop	r7
    135e:	6f 90       	pop	r6
    1360:	5f 90       	pop	r5
    1362:	4f 90       	pop	r4
    1364:	08 95       	ret
		tmr1Ptr_->setDutyCycleComB( oldPercent_ );
		vTaskDelay( delay_ / portTICK_RATE_MS );
	}
	else if ( percent_ < oldPercent_ )
	{
		oldPercent_ -= PERCENT_PR_TICK;
    1366:	20 e0       	ldi	r18, 0x00	; 0
    1368:	30 e0       	ldi	r19, 0x00	; 0
    136a:	40 e8       	ldi	r20, 0x80	; 128
    136c:	5d e3       	ldi	r21, 0x3D	; 61
    136e:	c7 01       	movw	r24, r14
    1370:	b6 01       	movw	r22, r12
    1372:	0e 94 e8 1b 	call	0x37d0	; 0x37d0 <__subsf3>
    1376:	ab 01       	movw	r20, r22
    1378:	bc 01       	movw	r22, r24
    137a:	4e 87       	std	Y+14, r20	; 0x0e
    137c:	5f 87       	std	Y+15, r21	; 0x0f
    137e:	68 8b       	std	Y+16, r22	; 0x10
    1380:	79 8b       	std	Y+17, r23	; 0x11
		tmr1Ptr_->setDutyCycleComB( oldPercent_ );
    1382:	8a 81       	ldd	r24, Y+2	; 0x02
    1384:	9b 81       	ldd	r25, Y+3	; 0x03
    1386:	09 d3       	rcall	.+1554   	; 0x199a <_ZN6Timer116setDutyCycleComBEf>
		vTaskDelay( delay_ / portTICK_RATE_MS );
    1388:	8f 89       	ldd	r24, Y+23	; 0x17
    138a:	98 8d       	ldd	r25, Y+24	; 0x18
	}
}
    138c:	df 91       	pop	r29
    138e:	cf 91       	pop	r28
    1390:	ff 90       	pop	r15
    1392:	ef 90       	pop	r14
    1394:	df 90       	pop	r13
    1396:	cf 90       	pop	r12
    1398:	bf 90       	pop	r11
    139a:	af 90       	pop	r10
    139c:	9f 90       	pop	r9
    139e:	8f 90       	pop	r8
    13a0:	7f 90       	pop	r7
    13a2:	6f 90       	pop	r6
    13a4:	5f 90       	pop	r5
    13a6:	4f 90       	pop	r4
	}
	else if ( percent_ < oldPercent_ )
	{
		oldPercent_ -= PERCENT_PR_TICK;
		tmr1Ptr_->setDutyCycleComB( oldPercent_ );
		vTaskDelay( delay_ / portTICK_RATE_MS );
    13a8:	0c 94 97 12 	jmp	0x252e	; 0x252e <vTaskDelay>

void M2::TurnMotor()
{
	if ( percent_ > oldPercent_ + PERCENT_PR_TICK )
	{
		oldPercent_ += PERCENT_PR_TICK;
    13ac:	4e 86       	std	Y+14, r4	; 0x0e
    13ae:	5f 86       	std	Y+15, r5	; 0x0f
    13b0:	68 8a       	std	Y+16, r6	; 0x10
    13b2:	79 8a       	std	Y+17, r7	; 0x11
		tmr1Ptr_->setDutyCycleComB( oldPercent_ );
    13b4:	b3 01       	movw	r22, r6
    13b6:	a2 01       	movw	r20, r4
    13b8:	e4 cf       	rjmp	.-56     	; 0x1382 <_ZN2M29TurnMotorEv+0x9c>

000013ba <_ZN2M2C1EP6Timer1>:
* Author: jespe
*/

#include "M2.h"

M2::M2( Timer1* tmr )
    13ba:	cf 93       	push	r28
    13bc:	df 93       	push	r29
    13be:	ec 01       	movw	r28, r24
    13c0:	cb 01       	movw	r24, r22
    13c2:	2c eb       	ldi	r18, 0xBC	; 188
    13c4:	32 e0       	ldi	r19, 0x02	; 2
    13c6:	39 83       	std	Y+1, r19	; 0x01
    13c8:	28 83       	st	Y, r18
{
	/* Store timer pointer */
	tmr1Ptr_ = tmr;
    13ca:	7b 83       	std	Y+3, r23	; 0x03
    13cc:	6a 83       	std	Y+2, r22	; 0x02
	
	/* This value is number of percent to add or subtract pr degree. */
	percentPrDeg = 0.06;
    13ce:	4f e8       	ldi	r20, 0x8F	; 143
    13d0:	52 ec       	ldi	r21, 0xC2	; 194
    13d2:	65 e7       	ldi	r22, 0x75	; 117
    13d4:	7d e3       	ldi	r23, 0x3D	; 61
    13d6:	4e 83       	std	Y+6, r20	; 0x06
    13d8:	5f 83       	std	Y+7, r21	; 0x07
    13da:	68 87       	std	Y+8, r22	; 0x08
    13dc:	79 87       	std	Y+9, r23	; 0x09

	/* This value is the lowest duty cycle percentage needed to make motor turn. */
	startpercent_ = 3;
    13de:	40 e0       	ldi	r20, 0x00	; 0
    13e0:	50 e0       	ldi	r21, 0x00	; 0
    13e2:	60 e4       	ldi	r22, 0x40	; 64
    13e4:	70 e4       	ldi	r23, 0x40	; 64
    13e6:	4a 8b       	std	Y+18, r20	; 0x12
    13e8:	5b 8b       	std	Y+19, r21	; 0x13
    13ea:	6c 8b       	std	Y+20, r22	; 0x14
    13ec:	7d 8b       	std	Y+21, r23	; 0x15

	/* This value is the delay on motor. A lower value makes motors go faster and higher value makes motors go slower. Value is in MS */
	delay_ = 10;
    13ee:	2a e0       	ldi	r18, 0x0A	; 10
    13f0:	30 e0       	ldi	r19, 0x00	; 0
    13f2:	38 8f       	std	Y+24, r19	; 0x18
    13f4:	2f 8b       	std	Y+23, r18	; 0x17

	/* This value is the maximum number of degrees the motor can turn */
	maxDegrees_ = 150;
    13f6:	26 e9       	ldi	r18, 0x96	; 150
    13f8:	2e 8b       	std	Y+22, r18	; 0x16
    13fa:	46 e6       	ldi	r20, 0x66	; 102
    13fc:	56 e6       	ldi	r21, 0x66	; 102
    13fe:	66 e0       	ldi	r22, 0x06	; 6
    1400:	71 e4       	ldi	r23, 0x41	; 65
    1402:	4a 87       	std	Y+10, r20	; 0x0a
    1404:	5b 87       	std	Y+11, r21	; 0x0b
    1406:	6c 87       	std	Y+12, r22	; 0x0c
    1408:	7d 87       	std	Y+13, r23	; 0x0d

	/* Set motor to default startup value */
	SetDegrees( 90 );
	tmr1Ptr_->setDutyCycleComB( percent_ );
    140a:	c7 d2       	rcall	.+1422   	; 0x199a <_ZN6Timer116setDutyCycleComBEf>
	oldPercent_ = percent_;
    140c:	8a 85       	ldd	r24, Y+10	; 0x0a
    140e:	9b 85       	ldd	r25, Y+11	; 0x0b
    1410:	ac 85       	ldd	r26, Y+12	; 0x0c
    1412:	bd 85       	ldd	r27, Y+13	; 0x0d
    1414:	8e 87       	std	Y+14, r24	; 0x0e
    1416:	9f 87       	std	Y+15, r25	; 0x0f
    1418:	a8 8b       	std	Y+16, r26	; 0x10
    141a:	b9 8b       	std	Y+17, r27	; 0x11
}
    141c:	df 91       	pop	r29
    141e:	cf 91       	pop	r28
    1420:	08 95       	ret

00001422 <_ZN2M3D1Ev>:
	SetDegrees( 90 );
	tmr1Ptr_->setDutyCycleComC( percent_ );
	oldPercent_ = percent_;	
}

M3::~M3()
    1422:	08 95       	ret

00001424 <_ZN2M3D0Ev>:
{
}
    1424:	3a ca       	rjmp	.-2956   	; 0x89a <_ZdlPv>

00001426 <_ZN2M39TurnMotorEv>:

void M3::TurnMotor()
{
    1426:	4f 92       	push	r4
    1428:	5f 92       	push	r5
    142a:	6f 92       	push	r6
    142c:	7f 92       	push	r7
    142e:	8f 92       	push	r8
    1430:	9f 92       	push	r9
    1432:	af 92       	push	r10
    1434:	bf 92       	push	r11
    1436:	cf 92       	push	r12
    1438:	df 92       	push	r13
    143a:	ef 92       	push	r14
    143c:	ff 92       	push	r15
    143e:	cf 93       	push	r28
    1440:	df 93       	push	r29
    1442:	ec 01       	movw	r28, r24
	if ( percent_ > oldPercent_ + PERCENT_PR_TICK )
    1444:	8a 84       	ldd	r8, Y+10	; 0x0a
    1446:	9b 84       	ldd	r9, Y+11	; 0x0b
    1448:	ac 84       	ldd	r10, Y+12	; 0x0c
    144a:	bd 84       	ldd	r11, Y+13	; 0x0d
    144c:	ce 84       	ldd	r12, Y+14	; 0x0e
    144e:	df 84       	ldd	r13, Y+15	; 0x0f
    1450:	e8 88       	ldd	r14, Y+16	; 0x10
    1452:	f9 88       	ldd	r15, Y+17	; 0x11
    1454:	20 e0       	ldi	r18, 0x00	; 0
    1456:	30 e0       	ldi	r19, 0x00	; 0
    1458:	40 e8       	ldi	r20, 0x80	; 128
    145a:	5d e3       	ldi	r21, 0x3D	; 61
    145c:	c7 01       	movw	r24, r14
    145e:	b6 01       	movw	r22, r12
    1460:	0e 94 e9 1b 	call	0x37d2	; 0x37d2 <__addsf3>
    1464:	2b 01       	movw	r4, r22
    1466:	3c 01       	movw	r6, r24
    1468:	9b 01       	movw	r18, r22
    146a:	ac 01       	movw	r20, r24
    146c:	c5 01       	movw	r24, r10
    146e:	b4 01       	movw	r22, r8
    1470:	0e 94 97 1d 	call	0x3b2e	; 0x3b2e <__gesf2>
    1474:	18 16       	cp	r1, r24
    1476:	d4 f1       	brlt	.+116    	; 0x14ec <_ZN2M39TurnMotorEv+0xc6>
	{
		oldPercent_ += PERCENT_PR_TICK;
		tmr1Ptr_->setDutyCycleComC( oldPercent_ );
		vTaskDelay( delay_ / portTICK_RATE_MS );
	}
	else if ( percent_ < oldPercent_ )
    1478:	a7 01       	movw	r20, r14
    147a:	96 01       	movw	r18, r12
    147c:	c5 01       	movw	r24, r10
    147e:	b4 01       	movw	r22, r8
    1480:	0e 94 4d 1c 	call	0x389a	; 0x389a <__cmpsf2>
    1484:	87 fd       	sbrc	r24, 7
    1486:	0f c0       	rjmp	.+30     	; 0x14a6 <_ZN2M39TurnMotorEv+0x80>
	{
		oldPercent_ -= PERCENT_PR_TICK;
		tmr1Ptr_->setDutyCycleComC( oldPercent_ );
		vTaskDelay( delay_ / portTICK_RATE_MS );
	}
}
    1488:	df 91       	pop	r29
    148a:	cf 91       	pop	r28
    148c:	ff 90       	pop	r15
    148e:	ef 90       	pop	r14
    1490:	df 90       	pop	r13
    1492:	cf 90       	pop	r12
    1494:	bf 90       	pop	r11
    1496:	af 90       	pop	r10
    1498:	9f 90       	pop	r9
    149a:	8f 90       	pop	r8
    149c:	7f 90       	pop	r7
    149e:	6f 90       	pop	r6
    14a0:	5f 90       	pop	r5
    14a2:	4f 90       	pop	r4
    14a4:	08 95       	ret
		tmr1Ptr_->setDutyCycleComC( oldPercent_ );
		vTaskDelay( delay_ / portTICK_RATE_MS );
	}
	else if ( percent_ < oldPercent_ )
	{
		oldPercent_ -= PERCENT_PR_TICK;
    14a6:	20 e0       	ldi	r18, 0x00	; 0
    14a8:	30 e0       	ldi	r19, 0x00	; 0
    14aa:	40 e8       	ldi	r20, 0x80	; 128
    14ac:	5d e3       	ldi	r21, 0x3D	; 61
    14ae:	c7 01       	movw	r24, r14
    14b0:	b6 01       	movw	r22, r12
    14b2:	0e 94 e8 1b 	call	0x37d0	; 0x37d0 <__subsf3>
    14b6:	ab 01       	movw	r20, r22
    14b8:	bc 01       	movw	r22, r24
    14ba:	4e 87       	std	Y+14, r20	; 0x0e
    14bc:	5f 87       	std	Y+15, r21	; 0x0f
    14be:	68 8b       	std	Y+16, r22	; 0x10
    14c0:	79 8b       	std	Y+17, r23	; 0x11
		tmr1Ptr_->setDutyCycleComC( oldPercent_ );
    14c2:	8a 81       	ldd	r24, Y+2	; 0x02
    14c4:	9b 81       	ldd	r25, Y+3	; 0x03
    14c6:	92 d2       	rcall	.+1316   	; 0x19ec <_ZN6Timer116setDutyCycleComCEf>
		vTaskDelay( delay_ / portTICK_RATE_MS );
    14c8:	8f 89       	ldd	r24, Y+23	; 0x17
    14ca:	98 8d       	ldd	r25, Y+24	; 0x18
	}
}
    14cc:	df 91       	pop	r29
    14ce:	cf 91       	pop	r28
    14d0:	ff 90       	pop	r15
    14d2:	ef 90       	pop	r14
    14d4:	df 90       	pop	r13
    14d6:	cf 90       	pop	r12
    14d8:	bf 90       	pop	r11
    14da:	af 90       	pop	r10
    14dc:	9f 90       	pop	r9
    14de:	8f 90       	pop	r8
    14e0:	7f 90       	pop	r7
    14e2:	6f 90       	pop	r6
    14e4:	5f 90       	pop	r5
    14e6:	4f 90       	pop	r4
	}
	else if ( percent_ < oldPercent_ )
	{
		oldPercent_ -= PERCENT_PR_TICK;
		tmr1Ptr_->setDutyCycleComC( oldPercent_ );
		vTaskDelay( delay_ / portTICK_RATE_MS );
    14e8:	0c 94 97 12 	jmp	0x252e	; 0x252e <vTaskDelay>

void M3::TurnMotor()
{
	if ( percent_ > oldPercent_ + PERCENT_PR_TICK )
	{
		oldPercent_ += PERCENT_PR_TICK;
    14ec:	4e 86       	std	Y+14, r4	; 0x0e
    14ee:	5f 86       	std	Y+15, r5	; 0x0f
    14f0:	68 8a       	std	Y+16, r6	; 0x10
    14f2:	79 8a       	std	Y+17, r7	; 0x11
		tmr1Ptr_->setDutyCycleComC( oldPercent_ );
    14f4:	b3 01       	movw	r22, r6
    14f6:	a2 01       	movw	r20, r4
    14f8:	e4 cf       	rjmp	.-56     	; 0x14c2 <_ZN2M39TurnMotorEv+0x9c>

000014fa <_ZN2M3C1EP6Timer1>:
*/

#include "M3.h"


M3::M3( Timer1* tmr )
    14fa:	cf 93       	push	r28
    14fc:	df 93       	push	r29
    14fe:	ec 01       	movw	r28, r24
    1500:	cb 01       	movw	r24, r22
    1502:	28 ec       	ldi	r18, 0xC8	; 200
    1504:	32 e0       	ldi	r19, 0x02	; 2
    1506:	39 83       	std	Y+1, r19	; 0x01
    1508:	28 83       	st	Y, r18
{
	/* Store timer pointer */
	tmr1Ptr_ = tmr;
    150a:	7b 83       	std	Y+3, r23	; 0x03
    150c:	6a 83       	std	Y+2, r22	; 0x02
		
	/* This value is number of percent to add or subtract pr degree. */
	percentPrDeg = 0.0555555555555556;
    150e:	49 e3       	ldi	r20, 0x39	; 57
    1510:	5e e8       	ldi	r21, 0x8E	; 142
    1512:	63 e6       	ldi	r22, 0x63	; 99
    1514:	7d e3       	ldi	r23, 0x3D	; 61
    1516:	4e 83       	std	Y+6, r20	; 0x06
    1518:	5f 83       	std	Y+7, r21	; 0x07
    151a:	68 87       	std	Y+8, r22	; 0x08
    151c:	79 87       	std	Y+9, r23	; 0x09
	
	/* This value is the lowest duty cycle percentage needed to make motor turn. */
	startpercent_ = 2.5;
    151e:	40 e0       	ldi	r20, 0x00	; 0
    1520:	50 e0       	ldi	r21, 0x00	; 0
    1522:	60 e2       	ldi	r22, 0x20	; 32
    1524:	70 e4       	ldi	r23, 0x40	; 64
    1526:	4a 8b       	std	Y+18, r20	; 0x12
    1528:	5b 8b       	std	Y+19, r21	; 0x13
    152a:	6c 8b       	std	Y+20, r22	; 0x14
    152c:	7d 8b       	std	Y+21, r23	; 0x15

	/* This value is the delay on motor. A lower value makes motors go faster and higher value makes motors go slower. Value is in MS */
	delay_ = 10;
    152e:	2a e0       	ldi	r18, 0x0A	; 10
    1530:	30 e0       	ldi	r19, 0x00	; 0
    1532:	38 8f       	std	Y+24, r19	; 0x18
    1534:	2f 8b       	std	Y+23, r18	; 0x17
	
	/* This value is the maximum number of degrees the motor can turn */
	maxDegrees_ = 180;
    1536:	24 eb       	ldi	r18, 0xB4	; 180
    1538:	2e 8b       	std	Y+22, r18	; 0x16
    153a:	40 e0       	ldi	r20, 0x00	; 0
    153c:	50 e0       	ldi	r21, 0x00	; 0
    153e:	60 ef       	ldi	r22, 0xF0	; 240
    1540:	70 e4       	ldi	r23, 0x40	; 64
    1542:	4a 87       	std	Y+10, r20	; 0x0a
    1544:	5b 87       	std	Y+11, r21	; 0x0b
    1546:	6c 87       	std	Y+12, r22	; 0x0c
    1548:	7d 87       	std	Y+13, r23	; 0x0d
	
	/* Set motor to default startup value */
	SetDegrees( 90 );
	tmr1Ptr_->setDutyCycleComC( percent_ );
    154a:	50 d2       	rcall	.+1184   	; 0x19ec <_ZN6Timer116setDutyCycleComCEf>
	oldPercent_ = percent_;	
    154c:	8a 85       	ldd	r24, Y+10	; 0x0a
    154e:	9b 85       	ldd	r25, Y+11	; 0x0b
    1550:	ac 85       	ldd	r26, Y+12	; 0x0c
    1552:	bd 85       	ldd	r27, Y+13	; 0x0d
    1554:	8e 87       	std	Y+14, r24	; 0x0e
    1556:	9f 87       	std	Y+15, r25	; 0x0f
    1558:	a8 8b       	std	Y+16, r26	; 0x10
    155a:	b9 8b       	std	Y+17, r27	; 0x11
}
    155c:	df 91       	pop	r29
    155e:	cf 91       	pop	r28
    1560:	08 95       	ret

00001562 <_ZN2M4D1Ev>:
	SetDegrees( 90 );
	tmr3Ptr_->setDutyCycleComA( percent_ );
	oldPercent_ = percent_;
}

M4::~M4()
    1562:	08 95       	ret

00001564 <_ZN2M4D0Ev>:
{
} 
    1564:	9a c9       	rjmp	.-3276   	; 0x89a <_ZdlPv>

00001566 <_ZN2M49TurnMotorEv>:

void M4::TurnMotor()
{
    1566:	4f 92       	push	r4
    1568:	5f 92       	push	r5
    156a:	6f 92       	push	r6
    156c:	7f 92       	push	r7
    156e:	8f 92       	push	r8
    1570:	9f 92       	push	r9
    1572:	af 92       	push	r10
    1574:	bf 92       	push	r11
    1576:	cf 92       	push	r12
    1578:	df 92       	push	r13
    157a:	ef 92       	push	r14
    157c:	ff 92       	push	r15
    157e:	cf 93       	push	r28
    1580:	df 93       	push	r29
    1582:	ec 01       	movw	r28, r24
	if ( percent_ > oldPercent_ + PERCENT_PR_TICK )
    1584:	8a 84       	ldd	r8, Y+10	; 0x0a
    1586:	9b 84       	ldd	r9, Y+11	; 0x0b
    1588:	ac 84       	ldd	r10, Y+12	; 0x0c
    158a:	bd 84       	ldd	r11, Y+13	; 0x0d
    158c:	ce 84       	ldd	r12, Y+14	; 0x0e
    158e:	df 84       	ldd	r13, Y+15	; 0x0f
    1590:	e8 88       	ldd	r14, Y+16	; 0x10
    1592:	f9 88       	ldd	r15, Y+17	; 0x11
    1594:	20 e0       	ldi	r18, 0x00	; 0
    1596:	30 e0       	ldi	r19, 0x00	; 0
    1598:	40 e8       	ldi	r20, 0x80	; 128
    159a:	5d e3       	ldi	r21, 0x3D	; 61
    159c:	c7 01       	movw	r24, r14
    159e:	b6 01       	movw	r22, r12
    15a0:	0e 94 e9 1b 	call	0x37d2	; 0x37d2 <__addsf3>
    15a4:	2b 01       	movw	r4, r22
    15a6:	3c 01       	movw	r6, r24
    15a8:	9b 01       	movw	r18, r22
    15aa:	ac 01       	movw	r20, r24
    15ac:	c5 01       	movw	r24, r10
    15ae:	b4 01       	movw	r22, r8
    15b0:	0e 94 97 1d 	call	0x3b2e	; 0x3b2e <__gesf2>
    15b4:	18 16       	cp	r1, r24
    15b6:	cc f1       	brlt	.+114    	; 0x162a <_ZN2M49TurnMotorEv+0xc4>
	{
		oldPercent_ += PERCENT_PR_TICK;
		tmr3Ptr_->setDutyCycleComA( oldPercent_ );
		vTaskDelay( 10 / portTICK_RATE_MS );
	}
	else if ( percent_ < oldPercent_ )
    15b8:	a7 01       	movw	r20, r14
    15ba:	96 01       	movw	r18, r12
    15bc:	c5 01       	movw	r24, r10
    15be:	b4 01       	movw	r22, r8
    15c0:	0e 94 4d 1c 	call	0x389a	; 0x389a <__cmpsf2>
    15c4:	87 fd       	sbrc	r24, 7
    15c6:	0f c0       	rjmp	.+30     	; 0x15e6 <_ZN2M49TurnMotorEv+0x80>
	{
		oldPercent_ -= PERCENT_PR_TICK;
		tmr3Ptr_->setDutyCycleComA( oldPercent_ );
		vTaskDelay( 10 / portTICK_RATE_MS );
	}
}
    15c8:	df 91       	pop	r29
    15ca:	cf 91       	pop	r28
    15cc:	ff 90       	pop	r15
    15ce:	ef 90       	pop	r14
    15d0:	df 90       	pop	r13
    15d2:	cf 90       	pop	r12
    15d4:	bf 90       	pop	r11
    15d6:	af 90       	pop	r10
    15d8:	9f 90       	pop	r9
    15da:	8f 90       	pop	r8
    15dc:	7f 90       	pop	r7
    15de:	6f 90       	pop	r6
    15e0:	5f 90       	pop	r5
    15e2:	4f 90       	pop	r4
    15e4:	08 95       	ret
		tmr3Ptr_->setDutyCycleComA( oldPercent_ );
		vTaskDelay( 10 / portTICK_RATE_MS );
	}
	else if ( percent_ < oldPercent_ )
	{
		oldPercent_ -= PERCENT_PR_TICK;
    15e6:	20 e0       	ldi	r18, 0x00	; 0
    15e8:	30 e0       	ldi	r19, 0x00	; 0
    15ea:	40 e8       	ldi	r20, 0x80	; 128
    15ec:	5d e3       	ldi	r21, 0x3D	; 61
    15ee:	c7 01       	movw	r24, r14
    15f0:	b6 01       	movw	r22, r12
    15f2:	0e 94 e8 1b 	call	0x37d0	; 0x37d0 <__subsf3>
    15f6:	ab 01       	movw	r20, r22
    15f8:	bc 01       	movw	r22, r24
    15fa:	4e 87       	std	Y+14, r20	; 0x0e
    15fc:	5f 87       	std	Y+15, r21	; 0x0f
    15fe:	68 8b       	std	Y+16, r22	; 0x10
    1600:	79 8b       	std	Y+17, r23	; 0x11
		tmr3Ptr_->setDutyCycleComA( oldPercent_ );
    1602:	8c 81       	ldd	r24, Y+4	; 0x04
    1604:	9d 81       	ldd	r25, Y+5	; 0x05
    1606:	41 d2       	rcall	.+1154   	; 0x1a8a <_ZN6Timer516setDutyCycleComAEf>
		vTaskDelay( 10 / portTICK_RATE_MS );
    1608:	8a e0       	ldi	r24, 0x0A	; 10
    160a:	90 e0       	ldi	r25, 0x00	; 0
	}
}
    160c:	df 91       	pop	r29
    160e:	cf 91       	pop	r28
    1610:	ff 90       	pop	r15
    1612:	ef 90       	pop	r14
    1614:	df 90       	pop	r13
    1616:	cf 90       	pop	r12
    1618:	bf 90       	pop	r11
    161a:	af 90       	pop	r10
    161c:	9f 90       	pop	r9
    161e:	8f 90       	pop	r8
    1620:	7f 90       	pop	r7
    1622:	6f 90       	pop	r6
    1624:	5f 90       	pop	r5
	}
	else if ( percent_ < oldPercent_ )
	{
		oldPercent_ -= PERCENT_PR_TICK;
		tmr3Ptr_->setDutyCycleComA( oldPercent_ );
		vTaskDelay( 10 / portTICK_RATE_MS );
    1626:	4f 90       	pop	r4
    1628:	82 c7       	rjmp	.+3844   	; 0x252e <vTaskDelay>

void M4::TurnMotor()
{
	if ( percent_ > oldPercent_ + PERCENT_PR_TICK )
	{
		oldPercent_ += PERCENT_PR_TICK;
    162a:	4e 86       	std	Y+14, r4	; 0x0e
    162c:	5f 86       	std	Y+15, r5	; 0x0f
    162e:	68 8a       	std	Y+16, r6	; 0x10
    1630:	79 8a       	std	Y+17, r7	; 0x11
		tmr3Ptr_->setDutyCycleComA( oldPercent_ );
    1632:	b3 01       	movw	r22, r6
    1634:	a2 01       	movw	r20, r4
    1636:	e5 cf       	rjmp	.-54     	; 0x1602 <_ZN2M49TurnMotorEv+0x9c>

00001638 <_ZN2M4C1EP6Timer5>:
* Author: jespe
*/

#include "M4.h"

M4::M4( Timer5* tmr )
    1638:	cf 93       	push	r28
    163a:	df 93       	push	r29
    163c:	ec 01       	movw	r28, r24
    163e:	cb 01       	movw	r24, r22
    1640:	24 ed       	ldi	r18, 0xD4	; 212
    1642:	32 e0       	ldi	r19, 0x02	; 2
    1644:	39 83       	std	Y+1, r19	; 0x01
    1646:	28 83       	st	Y, r18
{
	/* Store timer pointer */
	tmr3Ptr_ = tmr;
    1648:	7d 83       	std	Y+5, r23	; 0x05
    164a:	6c 83       	std	Y+4, r22	; 0x04
	
	/* This value is number of percent to add or subtract pr degree. */
	percentPrDeg = 0.0555555555555556;
    164c:	49 e3       	ldi	r20, 0x39	; 57
    164e:	5e e8       	ldi	r21, 0x8E	; 142
    1650:	63 e6       	ldi	r22, 0x63	; 99
    1652:	7d e3       	ldi	r23, 0x3D	; 61
    1654:	4e 83       	std	Y+6, r20	; 0x06
    1656:	5f 83       	std	Y+7, r21	; 0x07
    1658:	68 87       	std	Y+8, r22	; 0x08
    165a:	79 87       	std	Y+9, r23	; 0x09
	
	/* This value is the lowest duty cycle percentage needed to make motor turn. */
	startpercent_ = 2.5;
    165c:	40 e0       	ldi	r20, 0x00	; 0
    165e:	50 e0       	ldi	r21, 0x00	; 0
    1660:	60 e2       	ldi	r22, 0x20	; 32
    1662:	70 e4       	ldi	r23, 0x40	; 64
    1664:	4a 8b       	std	Y+18, r20	; 0x12
    1666:	5b 8b       	std	Y+19, r21	; 0x13
    1668:	6c 8b       	std	Y+20, r22	; 0x14
    166a:	7d 8b       	std	Y+21, r23	; 0x15
		
	/* This value is the delay on motor. A lower value makes motors go faster and higher value makes motors go slower. Value is in MS */
	delay_ = 5;
    166c:	25 e0       	ldi	r18, 0x05	; 5
    166e:	30 e0       	ldi	r19, 0x00	; 0
    1670:	38 8f       	std	Y+24, r19	; 0x18
    1672:	2f 8b       	std	Y+23, r18	; 0x17
	
	/* This value is the maximum number of degrees the motor can turn */
	maxDegrees_ = 180;
    1674:	24 eb       	ldi	r18, 0xB4	; 180
    1676:	2e 8b       	std	Y+22, r18	; 0x16
    1678:	40 e0       	ldi	r20, 0x00	; 0
    167a:	50 e0       	ldi	r21, 0x00	; 0
    167c:	60 ef       	ldi	r22, 0xF0	; 240
    167e:	70 e4       	ldi	r23, 0x40	; 64
    1680:	4a 87       	std	Y+10, r20	; 0x0a
    1682:	5b 87       	std	Y+11, r21	; 0x0b
    1684:	6c 87       	std	Y+12, r22	; 0x0c
    1686:	7d 87       	std	Y+13, r23	; 0x0d
	
	/* Set motor to default startup value */
	SetDegrees( 90 );
	tmr3Ptr_->setDutyCycleComA( percent_ );
    1688:	00 d2       	rcall	.+1024   	; 0x1a8a <_ZN6Timer516setDutyCycleComAEf>
	oldPercent_ = percent_;
    168a:	8a 85       	ldd	r24, Y+10	; 0x0a
    168c:	9b 85       	ldd	r25, Y+11	; 0x0b
    168e:	ac 85       	ldd	r26, Y+12	; 0x0c
    1690:	bd 85       	ldd	r27, Y+13	; 0x0d
    1692:	8e 87       	std	Y+14, r24	; 0x0e
    1694:	9f 87       	std	Y+15, r25	; 0x0f
    1696:	a8 8b       	std	Y+16, r26	; 0x10
    1698:	b9 8b       	std	Y+17, r27	; 0x11
}
    169a:	df 91       	pop	r29
    169c:	cf 91       	pop	r28
    169e:	08 95       	ret

000016a0 <_ZN2M5D1Ev>:
	SetDegrees( 0 );
	tmr3Ptr_->setDutyCycleComB( percent_ );
	oldPercent_ = percent_;
}

M5::~M5()
    16a0:	08 95       	ret

000016a2 <_ZN2M5D0Ev>:
{
}
    16a2:	fb c8       	rjmp	.-3594   	; 0x89a <_ZdlPv>

000016a4 <_ZN2M59TurnMotorEv>:

void M5::TurnMotor()
{
    16a4:	4f 92       	push	r4
    16a6:	5f 92       	push	r5
    16a8:	6f 92       	push	r6
    16aa:	7f 92       	push	r7
    16ac:	8f 92       	push	r8
    16ae:	9f 92       	push	r9
    16b0:	af 92       	push	r10
    16b2:	bf 92       	push	r11
    16b4:	cf 92       	push	r12
    16b6:	df 92       	push	r13
    16b8:	ef 92       	push	r14
    16ba:	ff 92       	push	r15
    16bc:	cf 93       	push	r28
    16be:	df 93       	push	r29
    16c0:	ec 01       	movw	r28, r24
	if ( percent_ > oldPercent_ + PERCENT_PR_TICK )
    16c2:	8a 84       	ldd	r8, Y+10	; 0x0a
    16c4:	9b 84       	ldd	r9, Y+11	; 0x0b
    16c6:	ac 84       	ldd	r10, Y+12	; 0x0c
    16c8:	bd 84       	ldd	r11, Y+13	; 0x0d
    16ca:	ce 84       	ldd	r12, Y+14	; 0x0e
    16cc:	df 84       	ldd	r13, Y+15	; 0x0f
    16ce:	e8 88       	ldd	r14, Y+16	; 0x10
    16d0:	f9 88       	ldd	r15, Y+17	; 0x11
    16d2:	20 e0       	ldi	r18, 0x00	; 0
    16d4:	30 e0       	ldi	r19, 0x00	; 0
    16d6:	40 e8       	ldi	r20, 0x80	; 128
    16d8:	5d e3       	ldi	r21, 0x3D	; 61
    16da:	c7 01       	movw	r24, r14
    16dc:	b6 01       	movw	r22, r12
    16de:	0e 94 e9 1b 	call	0x37d2	; 0x37d2 <__addsf3>
    16e2:	2b 01       	movw	r4, r22
    16e4:	3c 01       	movw	r6, r24
    16e6:	9b 01       	movw	r18, r22
    16e8:	ac 01       	movw	r20, r24
    16ea:	c5 01       	movw	r24, r10
    16ec:	b4 01       	movw	r22, r8
    16ee:	0e 94 97 1d 	call	0x3b2e	; 0x3b2e <__gesf2>
    16f2:	18 16       	cp	r1, r24
    16f4:	cc f1       	brlt	.+114    	; 0x1768 <_ZN2M59TurnMotorEv+0xc4>
	{
		oldPercent_ += PERCENT_PR_TICK;
		tmr3Ptr_->setDutyCycleComB( oldPercent_ );
		vTaskDelay( delay_ / portTICK_RATE_MS );
	}
	else if ( percent_ < oldPercent_ )
    16f6:	a7 01       	movw	r20, r14
    16f8:	96 01       	movw	r18, r12
    16fa:	c5 01       	movw	r24, r10
    16fc:	b4 01       	movw	r22, r8
    16fe:	0e 94 4d 1c 	call	0x389a	; 0x389a <__cmpsf2>
    1702:	87 fd       	sbrc	r24, 7
    1704:	0f c0       	rjmp	.+30     	; 0x1724 <_ZN2M59TurnMotorEv+0x80>
	{
		oldPercent_ -= PERCENT_PR_TICK;
		tmr3Ptr_->setDutyCycleComB( oldPercent_ );
		vTaskDelay( delay_ / portTICK_RATE_MS );
	}
}
    1706:	df 91       	pop	r29
    1708:	cf 91       	pop	r28
    170a:	ff 90       	pop	r15
    170c:	ef 90       	pop	r14
    170e:	df 90       	pop	r13
    1710:	cf 90       	pop	r12
    1712:	bf 90       	pop	r11
    1714:	af 90       	pop	r10
    1716:	9f 90       	pop	r9
    1718:	8f 90       	pop	r8
    171a:	7f 90       	pop	r7
    171c:	6f 90       	pop	r6
    171e:	5f 90       	pop	r5
    1720:	4f 90       	pop	r4
    1722:	08 95       	ret
		tmr3Ptr_->setDutyCycleComB( oldPercent_ );
		vTaskDelay( delay_ / portTICK_RATE_MS );
	}
	else if ( percent_ < oldPercent_ )
	{
		oldPercent_ -= PERCENT_PR_TICK;
    1724:	20 e0       	ldi	r18, 0x00	; 0
    1726:	30 e0       	ldi	r19, 0x00	; 0
    1728:	40 e8       	ldi	r20, 0x80	; 128
    172a:	5d e3       	ldi	r21, 0x3D	; 61
    172c:	c7 01       	movw	r24, r14
    172e:	b6 01       	movw	r22, r12
    1730:	0e 94 e8 1b 	call	0x37d0	; 0x37d0 <__subsf3>
    1734:	ab 01       	movw	r20, r22
    1736:	bc 01       	movw	r22, r24
    1738:	4e 87       	std	Y+14, r20	; 0x0e
    173a:	5f 87       	std	Y+15, r21	; 0x0f
    173c:	68 8b       	std	Y+16, r22	; 0x10
    173e:	79 8b       	std	Y+17, r23	; 0x11
		tmr3Ptr_->setDutyCycleComB( oldPercent_ );
    1740:	8c 81       	ldd	r24, Y+4	; 0x04
    1742:	9d 81       	ldd	r25, Y+5	; 0x05
    1744:	cb d1       	rcall	.+918    	; 0x1adc <_ZN6Timer516setDutyCycleComBEf>
		vTaskDelay( delay_ / portTICK_RATE_MS );
    1746:	8f 89       	ldd	r24, Y+23	; 0x17
    1748:	98 8d       	ldd	r25, Y+24	; 0x18
	}
}
    174a:	df 91       	pop	r29
    174c:	cf 91       	pop	r28
    174e:	ff 90       	pop	r15
    1750:	ef 90       	pop	r14
    1752:	df 90       	pop	r13
    1754:	cf 90       	pop	r12
    1756:	bf 90       	pop	r11
    1758:	af 90       	pop	r10
    175a:	9f 90       	pop	r9
    175c:	8f 90       	pop	r8
    175e:	7f 90       	pop	r7
    1760:	6f 90       	pop	r6
    1762:	5f 90       	pop	r5
	}
	else if ( percent_ < oldPercent_ )
	{
		oldPercent_ -= PERCENT_PR_TICK;
		tmr3Ptr_->setDutyCycleComB( oldPercent_ );
		vTaskDelay( delay_ / portTICK_RATE_MS );
    1764:	4f 90       	pop	r4
    1766:	e3 c6       	rjmp	.+3526   	; 0x252e <vTaskDelay>

void M5::TurnMotor()
{
	if ( percent_ > oldPercent_ + PERCENT_PR_TICK )
	{
		oldPercent_ += PERCENT_PR_TICK;
    1768:	4e 86       	std	Y+14, r4	; 0x0e
    176a:	5f 86       	std	Y+15, r5	; 0x0f
    176c:	68 8a       	std	Y+16, r6	; 0x10
    176e:	79 8a       	std	Y+17, r7	; 0x11
		tmr3Ptr_->setDutyCycleComB( oldPercent_ );
    1770:	b3 01       	movw	r22, r6
    1772:	a2 01       	movw	r20, r4
    1774:	e5 cf       	rjmp	.-54     	; 0x1740 <_ZN2M59TurnMotorEv+0x9c>

00001776 <_ZN2M5C1EP6Timer5>:
* Author: jespe
*/

#include "M5.h"

M5::M5( Timer5* tmr )
    1776:	cf 93       	push	r28
    1778:	df 93       	push	r29
    177a:	ec 01       	movw	r28, r24
    177c:	cb 01       	movw	r24, r22
    177e:	20 ee       	ldi	r18, 0xE0	; 224
    1780:	32 e0       	ldi	r19, 0x02	; 2
    1782:	39 83       	std	Y+1, r19	; 0x01
    1784:	28 83       	st	Y, r18
{
	/* Store timer pointer */
	tmr3Ptr_ = tmr;
    1786:	7d 83       	std	Y+5, r23	; 0x05
    1788:	6c 83       	std	Y+4, r22	; 0x04
	
	/* This value is number of percent to add or subtract pr degree. */
	percentPrDeg = 0.0555555555555556;
    178a:	49 e3       	ldi	r20, 0x39	; 57
    178c:	5e e8       	ldi	r21, 0x8E	; 142
    178e:	63 e6       	ldi	r22, 0x63	; 99
    1790:	7d e3       	ldi	r23, 0x3D	; 61
    1792:	4e 83       	std	Y+6, r20	; 0x06
    1794:	5f 83       	std	Y+7, r21	; 0x07
    1796:	68 87       	std	Y+8, r22	; 0x08
    1798:	79 87       	std	Y+9, r23	; 0x09
	
	/* This value is the lowest duty cycle percentage needed to make motor turn. */
	startpercent_ = 2.5;
    179a:	40 e0       	ldi	r20, 0x00	; 0
    179c:	50 e0       	ldi	r21, 0x00	; 0
    179e:	60 e2       	ldi	r22, 0x20	; 32
    17a0:	70 e4       	ldi	r23, 0x40	; 64
    17a2:	4a 8b       	std	Y+18, r20	; 0x12
    17a4:	5b 8b       	std	Y+19, r21	; 0x13
    17a6:	6c 8b       	std	Y+20, r22	; 0x14
    17a8:	7d 8b       	std	Y+21, r23	; 0x15
	
	/* This value is the delay on motor. A lower value makes motors go faster and higher value makes motors go slower. Value is in MS */
	delay_ = 1;
    17aa:	21 e0       	ldi	r18, 0x01	; 1
    17ac:	30 e0       	ldi	r19, 0x00	; 0
    17ae:	38 8f       	std	Y+24, r19	; 0x18
    17b0:	2f 8b       	std	Y+23, r18	; 0x17
	
	/* This value is the maximum number of degrees the motor can turn */
	maxDegrees_ = 180;
    17b2:	24 eb       	ldi	r18, 0xB4	; 180
    17b4:	2e 8b       	std	Y+22, r18	; 0x16
    17b6:	4a 87       	std	Y+10, r20	; 0x0a
    17b8:	5b 87       	std	Y+11, r21	; 0x0b
    17ba:	6c 87       	std	Y+12, r22	; 0x0c
    17bc:	7d 87       	std	Y+13, r23	; 0x0d
	
	/* Set motor to default startup value */
	SetDegrees( 0 );
	tmr3Ptr_->setDutyCycleComB( percent_ );
    17be:	8e d1       	rcall	.+796    	; 0x1adc <_ZN6Timer516setDutyCycleComBEf>
	oldPercent_ = percent_;
    17c0:	8a 85       	ldd	r24, Y+10	; 0x0a
    17c2:	9b 85       	ldd	r25, Y+11	; 0x0b
    17c4:	ac 85       	ldd	r26, Y+12	; 0x0c
    17c6:	bd 85       	ldd	r27, Y+13	; 0x0d
    17c8:	8e 87       	std	Y+14, r24	; 0x0e
    17ca:	9f 87       	std	Y+15, r25	; 0x0f
    17cc:	a8 8b       	std	Y+16, r26	; 0x10
    17ce:	b9 8b       	std	Y+17, r27	; 0x11
}
    17d0:	df 91       	pop	r29
    17d2:	cf 91       	pop	r28
    17d4:	08 95       	ret

000017d6 <_ZN2M6D1Ev>:
	SetDegrees( 0 );
	tmr3Ptr_->setDutyCycleComC( percent_ );
	oldPercent_ = percent_;
}

M6::~M6()
    17d6:	08 95       	ret

000017d8 <_ZN2M6D0Ev>:
{
}
    17d8:	60 c8       	rjmp	.-3904   	; 0x89a <_ZdlPv>

000017da <_ZN2M69TurnMotorEv>:

void M6::TurnMotor()
{
    17da:	4f 92       	push	r4
    17dc:	5f 92       	push	r5
    17de:	6f 92       	push	r6
    17e0:	7f 92       	push	r7
    17e2:	8f 92       	push	r8
    17e4:	9f 92       	push	r9
    17e6:	af 92       	push	r10
    17e8:	bf 92       	push	r11
    17ea:	cf 92       	push	r12
    17ec:	df 92       	push	r13
    17ee:	ef 92       	push	r14
    17f0:	ff 92       	push	r15
    17f2:	cf 93       	push	r28
    17f4:	df 93       	push	r29
    17f6:	ec 01       	movw	r28, r24
	if ( percent_ > oldPercent_ + PERCENT_PR_TICK )
    17f8:	8a 84       	ldd	r8, Y+10	; 0x0a
    17fa:	9b 84       	ldd	r9, Y+11	; 0x0b
    17fc:	ac 84       	ldd	r10, Y+12	; 0x0c
    17fe:	bd 84       	ldd	r11, Y+13	; 0x0d
    1800:	ce 84       	ldd	r12, Y+14	; 0x0e
    1802:	df 84       	ldd	r13, Y+15	; 0x0f
    1804:	e8 88       	ldd	r14, Y+16	; 0x10
    1806:	f9 88       	ldd	r15, Y+17	; 0x11
    1808:	20 e0       	ldi	r18, 0x00	; 0
    180a:	30 e0       	ldi	r19, 0x00	; 0
    180c:	40 e8       	ldi	r20, 0x80	; 128
    180e:	5d e3       	ldi	r21, 0x3D	; 61
    1810:	c7 01       	movw	r24, r14
    1812:	b6 01       	movw	r22, r12
    1814:	0e 94 e9 1b 	call	0x37d2	; 0x37d2 <__addsf3>
    1818:	2b 01       	movw	r4, r22
    181a:	3c 01       	movw	r6, r24
    181c:	9b 01       	movw	r18, r22
    181e:	ac 01       	movw	r20, r24
    1820:	c5 01       	movw	r24, r10
    1822:	b4 01       	movw	r22, r8
    1824:	0e 94 97 1d 	call	0x3b2e	; 0x3b2e <__gesf2>
    1828:	18 16       	cp	r1, r24
    182a:	cc f1       	brlt	.+114    	; 0x189e <_ZN2M69TurnMotorEv+0xc4>
	{
		oldPercent_ += 0.0625;
		tmr3Ptr_->setDutyCycleComC( oldPercent_ );
		vTaskDelay( delay_ / portTICK_RATE_MS );
	}
	else if ( percent_ < oldPercent_ )
    182c:	a7 01       	movw	r20, r14
    182e:	96 01       	movw	r18, r12
    1830:	c5 01       	movw	r24, r10
    1832:	b4 01       	movw	r22, r8
    1834:	0e 94 4d 1c 	call	0x389a	; 0x389a <__cmpsf2>
    1838:	87 fd       	sbrc	r24, 7
    183a:	0f c0       	rjmp	.+30     	; 0x185a <_ZN2M69TurnMotorEv+0x80>
	{
		oldPercent_ -= 0.0625;
		tmr3Ptr_->setDutyCycleComC( oldPercent_ );
		vTaskDelay( delay_ / portTICK_RATE_MS );
	}
}
    183c:	df 91       	pop	r29
    183e:	cf 91       	pop	r28
    1840:	ff 90       	pop	r15
    1842:	ef 90       	pop	r14
    1844:	df 90       	pop	r13
    1846:	cf 90       	pop	r12
    1848:	bf 90       	pop	r11
    184a:	af 90       	pop	r10
    184c:	9f 90       	pop	r9
    184e:	8f 90       	pop	r8
    1850:	7f 90       	pop	r7
    1852:	6f 90       	pop	r6
    1854:	5f 90       	pop	r5
    1856:	4f 90       	pop	r4
    1858:	08 95       	ret
		tmr3Ptr_->setDutyCycleComC( oldPercent_ );
		vTaskDelay( delay_ / portTICK_RATE_MS );
	}
	else if ( percent_ < oldPercent_ )
	{
		oldPercent_ -= 0.0625;
    185a:	20 e0       	ldi	r18, 0x00	; 0
    185c:	30 e0       	ldi	r19, 0x00	; 0
    185e:	40 e8       	ldi	r20, 0x80	; 128
    1860:	5d e3       	ldi	r21, 0x3D	; 61
    1862:	c7 01       	movw	r24, r14
    1864:	b6 01       	movw	r22, r12
    1866:	0e 94 e8 1b 	call	0x37d0	; 0x37d0 <__subsf3>
    186a:	ab 01       	movw	r20, r22
    186c:	bc 01       	movw	r22, r24
    186e:	4e 87       	std	Y+14, r20	; 0x0e
    1870:	5f 87       	std	Y+15, r21	; 0x0f
    1872:	68 8b       	std	Y+16, r22	; 0x10
    1874:	79 8b       	std	Y+17, r23	; 0x11
		tmr3Ptr_->setDutyCycleComC( oldPercent_ );
    1876:	8c 81       	ldd	r24, Y+4	; 0x04
    1878:	9d 81       	ldd	r25, Y+5	; 0x05
    187a:	59 d1       	rcall	.+690    	; 0x1b2e <_ZN6Timer516setDutyCycleComCEf>
		vTaskDelay( delay_ / portTICK_RATE_MS );
    187c:	8f 89       	ldd	r24, Y+23	; 0x17
    187e:	98 8d       	ldd	r25, Y+24	; 0x18
	}
}
    1880:	df 91       	pop	r29
    1882:	cf 91       	pop	r28
    1884:	ff 90       	pop	r15
    1886:	ef 90       	pop	r14
    1888:	df 90       	pop	r13
    188a:	cf 90       	pop	r12
    188c:	bf 90       	pop	r11
    188e:	af 90       	pop	r10
    1890:	9f 90       	pop	r9
    1892:	8f 90       	pop	r8
    1894:	7f 90       	pop	r7
    1896:	6f 90       	pop	r6
    1898:	5f 90       	pop	r5
	}
	else if ( percent_ < oldPercent_ )
	{
		oldPercent_ -= 0.0625;
		tmr3Ptr_->setDutyCycleComC( oldPercent_ );
		vTaskDelay( delay_ / portTICK_RATE_MS );
    189a:	4f 90       	pop	r4
    189c:	48 c6       	rjmp	.+3216   	; 0x252e <vTaskDelay>

void M6::TurnMotor()
{
	if ( percent_ > oldPercent_ + PERCENT_PR_TICK )
	{
		oldPercent_ += 0.0625;
    189e:	4e 86       	std	Y+14, r4	; 0x0e
    18a0:	5f 86       	std	Y+15, r5	; 0x0f
    18a2:	68 8a       	std	Y+16, r6	; 0x10
    18a4:	79 8a       	std	Y+17, r7	; 0x11
		tmr3Ptr_->setDutyCycleComC( oldPercent_ );
    18a6:	b3 01       	movw	r22, r6
    18a8:	a2 01       	movw	r20, r4
    18aa:	e5 cf       	rjmp	.-54     	; 0x1876 <_ZN2M69TurnMotorEv+0x9c>

000018ac <_ZN2M6C1EP6Timer5>:
* Author: jespe
*/

#include "M6.h"

M6::M6( Timer5* tmr )
    18ac:	cf 93       	push	r28
    18ae:	df 93       	push	r29
    18b0:	ec 01       	movw	r28, r24
    18b2:	cb 01       	movw	r24, r22
    18b4:	2c ee       	ldi	r18, 0xEC	; 236
    18b6:	32 e0       	ldi	r19, 0x02	; 2
    18b8:	39 83       	std	Y+1, r19	; 0x01
    18ba:	28 83       	st	Y, r18
{
	/* Store timer pointer */
	tmr3Ptr_ = tmr;
    18bc:	7d 83       	std	Y+5, r23	; 0x05
    18be:	6c 83       	std	Y+4, r22	; 0x04
	
	/* This value is number of percent to add or subtract pr degree. */
	percentPrDeg = 0.07936507936507;
    18c0:	49 e2       	ldi	r20, 0x29	; 41
    18c2:	5a e8       	ldi	r21, 0x8A	; 138
    18c4:	62 ea       	ldi	r22, 0xA2	; 162
    18c6:	7d e3       	ldi	r23, 0x3D	; 61
    18c8:	4e 83       	std	Y+6, r20	; 0x06
    18ca:	5f 83       	std	Y+7, r21	; 0x07
    18cc:	68 87       	std	Y+8, r22	; 0x08
    18ce:	79 87       	std	Y+9, r23	; 0x09
	
	/* This value is the lowest duty cycle percentage needed to make motor turn. */
	startpercent_ = 2.5;
    18d0:	40 e0       	ldi	r20, 0x00	; 0
    18d2:	50 e0       	ldi	r21, 0x00	; 0
    18d4:	60 e2       	ldi	r22, 0x20	; 32
    18d6:	70 e4       	ldi	r23, 0x40	; 64
    18d8:	4a 8b       	std	Y+18, r20	; 0x12
    18da:	5b 8b       	std	Y+19, r21	; 0x13
    18dc:	6c 8b       	std	Y+20, r22	; 0x14
    18de:	7d 8b       	std	Y+21, r23	; 0x15
	
	/* This value is the delay on motor. A lower value makes motors go faster and higher value makes motors go slower. Value is in MS */
	delay_ = 1;
    18e0:	21 e0       	ldi	r18, 0x01	; 1
    18e2:	30 e0       	ldi	r19, 0x00	; 0
    18e4:	38 8f       	std	Y+24, r19	; 0x18
    18e6:	2f 8b       	std	Y+23, r18	; 0x17
	
	/* This value is the maximum number of degrees the motor can turn */
	maxDegrees_ = 63;
    18e8:	2f e3       	ldi	r18, 0x3F	; 63
    18ea:	2e 8b       	std	Y+22, r18	; 0x16
    18ec:	4a 87       	std	Y+10, r20	; 0x0a
    18ee:	5b 87       	std	Y+11, r21	; 0x0b
    18f0:	6c 87       	std	Y+12, r22	; 0x0c
    18f2:	7d 87       	std	Y+13, r23	; 0x0d
	
	/* Set motor to default startup value */
	SetDegrees( 0 );
	tmr3Ptr_->setDutyCycleComC( percent_ );
    18f4:	1c d1       	rcall	.+568    	; 0x1b2e <_ZN6Timer516setDutyCycleComCEf>
	oldPercent_ = percent_;
    18f6:	8a 85       	ldd	r24, Y+10	; 0x0a
    18f8:	9b 85       	ldd	r25, Y+11	; 0x0b
    18fa:	ac 85       	ldd	r26, Y+12	; 0x0c
    18fc:	bd 85       	ldd	r27, Y+13	; 0x0d
    18fe:	8e 87       	std	Y+14, r24	; 0x0e
    1900:	9f 87       	std	Y+15, r25	; 0x0f
    1902:	a8 8b       	std	Y+16, r26	; 0x10
    1904:	b9 8b       	std	Y+17, r27	; 0x11
}
    1906:	df 91       	pop	r29
    1908:	cf 91       	pop	r28
    190a:	08 95       	ret

0000190c <_ZN6Timer1C1Ev>:
#include <avr/io.h>

Timer1::Timer1()
{
	// Set all needed ports to outputs
	ROBOTARM_M1_OUT_PORT |= ( 1 << ROBOTARM_M1_OUT_PIN );
    190c:	25 9a       	sbi	0x04, 5	; 4
	ROBOTARM_M2_OUT_PORT |= ( 1 << ROBOTARM_M2_OUT_PIN );
    190e:	26 9a       	sbi	0x04, 6	; 4
	ROBOTARM_M3_OUT_PORT |= ( 1 << ROBOTARM_M3_OUT_PIN );
    1910:	27 9a       	sbi	0x04, 7	; 4
		
	// Set timer to run in PWM, Phase Correct mode with 50 Hz freq. 
	TCCR1A = ( 1 << COM1A1 ) | ( 1 << COM1B1 ) | ( 1 << COM1C1 ) | ( 0 << WGM10 ) | ( 0 << WGM11 );
    1912:	88 ea       	ldi	r24, 0xA8	; 168
    1914:	80 93 80 00 	sts	0x0080, r24	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
	TCCR1B = ( 1 << WGM13 ) | ( 0 << CS10 )  | ( 1 << CS12 );
    1918:	84 e1       	ldi	r24, 0x14	; 20
    191a:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x700081>
	TCCR1C = 0;
    191e:	10 92 82 00 	sts	0x0082, r1	; 0x800082 <__TEXT_REGION_LENGTH__+0x700082>
	ICR1 = 622;
    1922:	8e e6       	ldi	r24, 0x6E	; 110
    1924:	92 e0       	ldi	r25, 0x02	; 2
    1926:	90 93 87 00 	sts	0x0087, r25	; 0x800087 <__TEXT_REGION_LENGTH__+0x700087>
    192a:	80 93 86 00 	sts	0x0086, r24	; 0x800086 <__TEXT_REGION_LENGTH__+0x700086>
	
	OCR1A = 0;
    192e:	10 92 89 00 	sts	0x0089, r1	; 0x800089 <__TEXT_REGION_LENGTH__+0x700089>
    1932:	10 92 88 00 	sts	0x0088, r1	; 0x800088 <__TEXT_REGION_LENGTH__+0x700088>
	OCR1B = 0;
    1936:	10 92 8b 00 	sts	0x008B, r1	; 0x80008b <__TEXT_REGION_LENGTH__+0x70008b>
    193a:	10 92 8a 00 	sts	0x008A, r1	; 0x80008a <__TEXT_REGION_LENGTH__+0x70008a>
	OCR1C = 0;
    193e:	10 92 8d 00 	sts	0x008D, r1	; 0x80008d <__TEXT_REGION_LENGTH__+0x70008d>
    1942:	10 92 8c 00 	sts	0x008C, r1	; 0x80008c <__TEXT_REGION_LENGTH__+0x70008c>
    1946:	08 95       	ret

00001948 <_ZN6Timer116setDutyCycleComAEf>:
}

void Timer1::setDutyCycleComA( float dutyCycle )
{
    1948:	cf 92       	push	r12
    194a:	df 92       	push	r13
    194c:	ef 92       	push	r14
    194e:	ff 92       	push	r15
    1950:	6a 01       	movw	r12, r20
    1952:	7b 01       	movw	r14, r22
	float percent = ICR1/100;
    1954:	20 91 86 00 	lds	r18, 0x0086	; 0x800086 <__TEXT_REGION_LENGTH__+0x700086>
    1958:	30 91 87 00 	lds	r19, 0x0087	; 0x800087 <__TEXT_REGION_LENGTH__+0x700087>
	OCR1A = (uint8_t)percent*dutyCycle;
    195c:	36 95       	lsr	r19
    195e:	27 95       	ror	r18
    1960:	36 95       	lsr	r19
    1962:	27 95       	ror	r18
    1964:	ab e7       	ldi	r26, 0x7B	; 123
    1966:	b4 e1       	ldi	r27, 0x14	; 20
    1968:	0e 94 fe 1d 	call	0x3bfc	; 0x3bfc <__umulhisi3>
    196c:	96 95       	lsr	r25
    196e:	87 95       	ror	r24
    1970:	68 2f       	mov	r22, r24
    1972:	70 e0       	ldi	r23, 0x00	; 0
    1974:	80 e0       	ldi	r24, 0x00	; 0
    1976:	90 e0       	ldi	r25, 0x00	; 0
    1978:	0e 94 e7 1c 	call	0x39ce	; 0x39ce <__floatsisf>
    197c:	a7 01       	movw	r20, r14
    197e:	96 01       	movw	r18, r12
    1980:	0e 94 9b 1d 	call	0x3b36	; 0x3b36 <__mulsf3>
    1984:	0e 94 b9 1c 	call	0x3972	; 0x3972 <__fixunssfsi>
    1988:	70 93 89 00 	sts	0x0089, r23	; 0x800089 <__TEXT_REGION_LENGTH__+0x700089>
    198c:	60 93 88 00 	sts	0x0088, r22	; 0x800088 <__TEXT_REGION_LENGTH__+0x700088>
}
    1990:	ff 90       	pop	r15
    1992:	ef 90       	pop	r14
    1994:	df 90       	pop	r13
    1996:	cf 90       	pop	r12
    1998:	08 95       	ret

0000199a <_ZN6Timer116setDutyCycleComBEf>:

void Timer1::setDutyCycleComB( float dutyCycle )
{
    199a:	cf 92       	push	r12
    199c:	df 92       	push	r13
    199e:	ef 92       	push	r14
    19a0:	ff 92       	push	r15
    19a2:	6a 01       	movw	r12, r20
    19a4:	7b 01       	movw	r14, r22
	float percent = ICR1/100;
    19a6:	20 91 86 00 	lds	r18, 0x0086	; 0x800086 <__TEXT_REGION_LENGTH__+0x700086>
    19aa:	30 91 87 00 	lds	r19, 0x0087	; 0x800087 <__TEXT_REGION_LENGTH__+0x700087>
	OCR1B = (uint8_t)percent*dutyCycle;
    19ae:	36 95       	lsr	r19
    19b0:	27 95       	ror	r18
    19b2:	36 95       	lsr	r19
    19b4:	27 95       	ror	r18
    19b6:	ab e7       	ldi	r26, 0x7B	; 123
    19b8:	b4 e1       	ldi	r27, 0x14	; 20
    19ba:	0e 94 fe 1d 	call	0x3bfc	; 0x3bfc <__umulhisi3>
    19be:	96 95       	lsr	r25
    19c0:	87 95       	ror	r24
    19c2:	68 2f       	mov	r22, r24
    19c4:	70 e0       	ldi	r23, 0x00	; 0
    19c6:	80 e0       	ldi	r24, 0x00	; 0
    19c8:	90 e0       	ldi	r25, 0x00	; 0
    19ca:	0e 94 e7 1c 	call	0x39ce	; 0x39ce <__floatsisf>
    19ce:	a7 01       	movw	r20, r14
    19d0:	96 01       	movw	r18, r12
    19d2:	0e 94 9b 1d 	call	0x3b36	; 0x3b36 <__mulsf3>
    19d6:	0e 94 b9 1c 	call	0x3972	; 0x3972 <__fixunssfsi>
    19da:	70 93 8b 00 	sts	0x008B, r23	; 0x80008b <__TEXT_REGION_LENGTH__+0x70008b>
    19de:	60 93 8a 00 	sts	0x008A, r22	; 0x80008a <__TEXT_REGION_LENGTH__+0x70008a>
}
    19e2:	ff 90       	pop	r15
    19e4:	ef 90       	pop	r14
    19e6:	df 90       	pop	r13
    19e8:	cf 90       	pop	r12
    19ea:	08 95       	ret

000019ec <_ZN6Timer116setDutyCycleComCEf>:

void Timer1::setDutyCycleComC( float dutyCycle )
{
    19ec:	cf 92       	push	r12
    19ee:	df 92       	push	r13
    19f0:	ef 92       	push	r14
    19f2:	ff 92       	push	r15
    19f4:	6a 01       	movw	r12, r20
    19f6:	7b 01       	movw	r14, r22
	float percent = ICR1/100;
    19f8:	20 91 86 00 	lds	r18, 0x0086	; 0x800086 <__TEXT_REGION_LENGTH__+0x700086>
    19fc:	30 91 87 00 	lds	r19, 0x0087	; 0x800087 <__TEXT_REGION_LENGTH__+0x700087>
	OCR1C = (uint8_t)percent*dutyCycle;
    1a00:	36 95       	lsr	r19
    1a02:	27 95       	ror	r18
    1a04:	36 95       	lsr	r19
    1a06:	27 95       	ror	r18
    1a08:	ab e7       	ldi	r26, 0x7B	; 123
    1a0a:	b4 e1       	ldi	r27, 0x14	; 20
    1a0c:	0e 94 fe 1d 	call	0x3bfc	; 0x3bfc <__umulhisi3>
    1a10:	96 95       	lsr	r25
    1a12:	87 95       	ror	r24
    1a14:	68 2f       	mov	r22, r24
    1a16:	70 e0       	ldi	r23, 0x00	; 0
    1a18:	80 e0       	ldi	r24, 0x00	; 0
    1a1a:	90 e0       	ldi	r25, 0x00	; 0
    1a1c:	0e 94 e7 1c 	call	0x39ce	; 0x39ce <__floatsisf>
    1a20:	a7 01       	movw	r20, r14
    1a22:	96 01       	movw	r18, r12
    1a24:	0e 94 9b 1d 	call	0x3b36	; 0x3b36 <__mulsf3>
    1a28:	0e 94 b9 1c 	call	0x3972	; 0x3972 <__fixunssfsi>
    1a2c:	70 93 8d 00 	sts	0x008D, r23	; 0x80008d <__TEXT_REGION_LENGTH__+0x70008d>
    1a30:	60 93 8c 00 	sts	0x008C, r22	; 0x80008c <__TEXT_REGION_LENGTH__+0x70008c>
    1a34:	ff 90       	pop	r15
    1a36:	ef 90       	pop	r14
    1a38:	df 90       	pop	r13
    1a3a:	cf 90       	pop	r12
    1a3c:	08 95       	ret

00001a3e <_ZN6Timer5C1Ev>:
#include <avr/io.h>

Timer5::Timer5()
{
	// Set all needed ports to outputs
	ROBOTARM_M4_OUT_PORT |= ( 1 << ROBOTARM_M4_OUT_PIN );
    1a3e:	ea e0       	ldi	r30, 0x0A	; 10
    1a40:	f1 e0       	ldi	r31, 0x01	; 1
    1a42:	80 81       	ld	r24, Z
    1a44:	88 60       	ori	r24, 0x08	; 8
    1a46:	80 83       	st	Z, r24
	ROBOTARM_M5_OUT_PORT |= ( 1 << ROBOTARM_M5_OUT_PIN );
    1a48:	80 81       	ld	r24, Z
    1a4a:	80 61       	ori	r24, 0x10	; 16
    1a4c:	80 83       	st	Z, r24
	ROBOTARM_M6_OUT_PORT |= ( 1 << ROBOTARM_M6_OUT_PIN );
    1a4e:	80 81       	ld	r24, Z
    1a50:	80 62       	ori	r24, 0x20	; 32
    1a52:	80 83       	st	Z, r24
	
	// Set timer to run in PWM, Phase Correct mode with 50 Hz freq.
	TCCR5A = ( 1 << COM3A1 ) | ( 1 << COM3B1 ) | ( 1 << COM3C1 ) | ( 0 << WGM30 ) | ( 0 << WGM31 );
    1a54:	88 ea       	ldi	r24, 0xA8	; 168
    1a56:	80 93 20 01 	sts	0x0120, r24	; 0x800120 <__TEXT_REGION_LENGTH__+0x700120>
	TCCR5B = ( 1 << WGM33 ) | ( 0 << CS30 )  | ( 1 << CS32 );
    1a5a:	84 e1       	ldi	r24, 0x14	; 20
    1a5c:	80 93 21 01 	sts	0x0121, r24	; 0x800121 <__TEXT_REGION_LENGTH__+0x700121>
	TCCR5C = 0;
    1a60:	10 92 22 01 	sts	0x0122, r1	; 0x800122 <__TEXT_REGION_LENGTH__+0x700122>
	ICR5 = 622;
    1a64:	8e e6       	ldi	r24, 0x6E	; 110
    1a66:	92 e0       	ldi	r25, 0x02	; 2
    1a68:	90 93 27 01 	sts	0x0127, r25	; 0x800127 <__TEXT_REGION_LENGTH__+0x700127>
    1a6c:	80 93 26 01 	sts	0x0126, r24	; 0x800126 <__TEXT_REGION_LENGTH__+0x700126>
	
	OCR5A = 0;
    1a70:	10 92 29 01 	sts	0x0129, r1	; 0x800129 <__TEXT_REGION_LENGTH__+0x700129>
    1a74:	10 92 28 01 	sts	0x0128, r1	; 0x800128 <__TEXT_REGION_LENGTH__+0x700128>
	OCR5B = 0;
    1a78:	10 92 2b 01 	sts	0x012B, r1	; 0x80012b <__TEXT_REGION_LENGTH__+0x70012b>
    1a7c:	10 92 2a 01 	sts	0x012A, r1	; 0x80012a <__TEXT_REGION_LENGTH__+0x70012a>
	OCR5C = 0;
    1a80:	10 92 2d 01 	sts	0x012D, r1	; 0x80012d <__TEXT_REGION_LENGTH__+0x70012d>
    1a84:	10 92 2c 01 	sts	0x012C, r1	; 0x80012c <__TEXT_REGION_LENGTH__+0x70012c>
    1a88:	08 95       	ret

00001a8a <_ZN6Timer516setDutyCycleComAEf>:
}

void Timer5::setDutyCycleComA( float dutyCycle )
{
    1a8a:	cf 92       	push	r12
    1a8c:	df 92       	push	r13
    1a8e:	ef 92       	push	r14
    1a90:	ff 92       	push	r15
    1a92:	6a 01       	movw	r12, r20
    1a94:	7b 01       	movw	r14, r22
	float percent = ICR5/100;
    1a96:	20 91 26 01 	lds	r18, 0x0126	; 0x800126 <__TEXT_REGION_LENGTH__+0x700126>
    1a9a:	30 91 27 01 	lds	r19, 0x0127	; 0x800127 <__TEXT_REGION_LENGTH__+0x700127>
	OCR5A = (uint8_t)percent*dutyCycle;
    1a9e:	36 95       	lsr	r19
    1aa0:	27 95       	ror	r18
    1aa2:	36 95       	lsr	r19
    1aa4:	27 95       	ror	r18
    1aa6:	ab e7       	ldi	r26, 0x7B	; 123
    1aa8:	b4 e1       	ldi	r27, 0x14	; 20
    1aaa:	0e 94 fe 1d 	call	0x3bfc	; 0x3bfc <__umulhisi3>
    1aae:	96 95       	lsr	r25
    1ab0:	87 95       	ror	r24
    1ab2:	68 2f       	mov	r22, r24
    1ab4:	70 e0       	ldi	r23, 0x00	; 0
    1ab6:	80 e0       	ldi	r24, 0x00	; 0
    1ab8:	90 e0       	ldi	r25, 0x00	; 0
    1aba:	0e 94 e7 1c 	call	0x39ce	; 0x39ce <__floatsisf>
    1abe:	a7 01       	movw	r20, r14
    1ac0:	96 01       	movw	r18, r12
    1ac2:	0e 94 9b 1d 	call	0x3b36	; 0x3b36 <__mulsf3>
    1ac6:	0e 94 b9 1c 	call	0x3972	; 0x3972 <__fixunssfsi>
    1aca:	70 93 29 01 	sts	0x0129, r23	; 0x800129 <__TEXT_REGION_LENGTH__+0x700129>
    1ace:	60 93 28 01 	sts	0x0128, r22	; 0x800128 <__TEXT_REGION_LENGTH__+0x700128>
}
    1ad2:	ff 90       	pop	r15
    1ad4:	ef 90       	pop	r14
    1ad6:	df 90       	pop	r13
    1ad8:	cf 90       	pop	r12
    1ada:	08 95       	ret

00001adc <_ZN6Timer516setDutyCycleComBEf>:

void Timer5::setDutyCycleComB( float dutyCycle )
{
    1adc:	cf 92       	push	r12
    1ade:	df 92       	push	r13
    1ae0:	ef 92       	push	r14
    1ae2:	ff 92       	push	r15
    1ae4:	6a 01       	movw	r12, r20
    1ae6:	7b 01       	movw	r14, r22
	float percent = ICR5/100;
    1ae8:	20 91 26 01 	lds	r18, 0x0126	; 0x800126 <__TEXT_REGION_LENGTH__+0x700126>
    1aec:	30 91 27 01 	lds	r19, 0x0127	; 0x800127 <__TEXT_REGION_LENGTH__+0x700127>
	OCR5B = (uint8_t)percent*dutyCycle;
    1af0:	36 95       	lsr	r19
    1af2:	27 95       	ror	r18
    1af4:	36 95       	lsr	r19
    1af6:	27 95       	ror	r18
    1af8:	ab e7       	ldi	r26, 0x7B	; 123
    1afa:	b4 e1       	ldi	r27, 0x14	; 20
    1afc:	0e 94 fe 1d 	call	0x3bfc	; 0x3bfc <__umulhisi3>
    1b00:	96 95       	lsr	r25
    1b02:	87 95       	ror	r24
    1b04:	68 2f       	mov	r22, r24
    1b06:	70 e0       	ldi	r23, 0x00	; 0
    1b08:	80 e0       	ldi	r24, 0x00	; 0
    1b0a:	90 e0       	ldi	r25, 0x00	; 0
    1b0c:	0e 94 e7 1c 	call	0x39ce	; 0x39ce <__floatsisf>
    1b10:	a7 01       	movw	r20, r14
    1b12:	96 01       	movw	r18, r12
    1b14:	0e 94 9b 1d 	call	0x3b36	; 0x3b36 <__mulsf3>
    1b18:	0e 94 b9 1c 	call	0x3972	; 0x3972 <__fixunssfsi>
    1b1c:	70 93 2b 01 	sts	0x012B, r23	; 0x80012b <__TEXT_REGION_LENGTH__+0x70012b>
    1b20:	60 93 2a 01 	sts	0x012A, r22	; 0x80012a <__TEXT_REGION_LENGTH__+0x70012a>
}
    1b24:	ff 90       	pop	r15
    1b26:	ef 90       	pop	r14
    1b28:	df 90       	pop	r13
    1b2a:	cf 90       	pop	r12
    1b2c:	08 95       	ret

00001b2e <_ZN6Timer516setDutyCycleComCEf>:

void Timer5::setDutyCycleComC( float dutyCycle )
{
    1b2e:	cf 92       	push	r12
    1b30:	df 92       	push	r13
    1b32:	ef 92       	push	r14
    1b34:	ff 92       	push	r15
    1b36:	6a 01       	movw	r12, r20
    1b38:	7b 01       	movw	r14, r22
	float percent = ICR5/100;
    1b3a:	20 91 26 01 	lds	r18, 0x0126	; 0x800126 <__TEXT_REGION_LENGTH__+0x700126>
    1b3e:	30 91 27 01 	lds	r19, 0x0127	; 0x800127 <__TEXT_REGION_LENGTH__+0x700127>
	OCR5C = (uint8_t)percent*dutyCycle;
    1b42:	36 95       	lsr	r19
    1b44:	27 95       	ror	r18
    1b46:	36 95       	lsr	r19
    1b48:	27 95       	ror	r18
    1b4a:	ab e7       	ldi	r26, 0x7B	; 123
    1b4c:	b4 e1       	ldi	r27, 0x14	; 20
    1b4e:	0e 94 fe 1d 	call	0x3bfc	; 0x3bfc <__umulhisi3>
    1b52:	96 95       	lsr	r25
    1b54:	87 95       	ror	r24
    1b56:	68 2f       	mov	r22, r24
    1b58:	70 e0       	ldi	r23, 0x00	; 0
    1b5a:	80 e0       	ldi	r24, 0x00	; 0
    1b5c:	90 e0       	ldi	r25, 0x00	; 0
    1b5e:	0e 94 e7 1c 	call	0x39ce	; 0x39ce <__floatsisf>
    1b62:	a7 01       	movw	r20, r14
    1b64:	96 01       	movw	r18, r12
    1b66:	0e 94 9b 1d 	call	0x3b36	; 0x3b36 <__mulsf3>
    1b6a:	0e 94 b9 1c 	call	0x3972	; 0x3972 <__fixunssfsi>
    1b6e:	70 93 2d 01 	sts	0x012D, r23	; 0x80012d <__TEXT_REGION_LENGTH__+0x70012d>
    1b72:	60 93 2c 01 	sts	0x012C, r22	; 0x80012c <__TEXT_REGION_LENGTH__+0x70012c>
    1b76:	ff 90       	pop	r15
    1b78:	ef 90       	pop	r14
    1b7a:	df 90       	pop	r13
    1b7c:	cf 90       	pop	r12
    1b7e:	08 95       	ret

00001b80 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
    1b80:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
    1b82:	03 96       	adiw	r24, 0x03	; 3
    1b84:	92 83       	std	Z+2, r25	; 0x02
    1b86:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    1b88:	2f ef       	ldi	r18, 0xFF	; 255
    1b8a:	3f ef       	ldi	r19, 0xFF	; 255
    1b8c:	34 83       	std	Z+4, r19	; 0x04
    1b8e:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
    1b90:	96 83       	std	Z+6, r25	; 0x06
    1b92:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
    1b94:	90 87       	std	Z+8, r25	; 0x08
    1b96:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
    1b98:	10 82       	st	Z, r1
    1b9a:	08 95       	ret

00001b9c <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    1b9c:	fc 01       	movw	r30, r24
    1b9e:	11 86       	std	Z+9, r1	; 0x09
    1ba0:	10 86       	std	Z+8, r1	; 0x08
    1ba2:	08 95       	ret

00001ba4 <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
    1ba4:	cf 93       	push	r28
    1ba6:	df 93       	push	r29
    1ba8:	fc 01       	movw	r30, r24
    1baa:	db 01       	movw	r26, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
    1bac:	21 81       	ldd	r18, Z+1	; 0x01
    1bae:	32 81       	ldd	r19, Z+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
    1bb0:	e9 01       	movw	r28, r18
    1bb2:	8a 81       	ldd	r24, Y+2	; 0x02
    1bb4:	9b 81       	ldd	r25, Y+3	; 0x03
    1bb6:	13 96       	adiw	r26, 0x03	; 3
    1bb8:	9c 93       	st	X, r25
    1bba:	8e 93       	st	-X, r24
    1bbc:	12 97       	sbiw	r26, 0x02	; 2
	pxNewListItem->pxPrevious = pxList->pxIndex;
    1bbe:	81 81       	ldd	r24, Z+1	; 0x01
    1bc0:	92 81       	ldd	r25, Z+2	; 0x02
    1bc2:	15 96       	adiw	r26, 0x05	; 5
    1bc4:	9c 93       	st	X, r25
    1bc6:	8e 93       	st	-X, r24
    1bc8:	14 97       	sbiw	r26, 0x04	; 4
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    1bca:	8a 81       	ldd	r24, Y+2	; 0x02
    1bcc:	9b 81       	ldd	r25, Y+3	; 0x03
    1bce:	ec 01       	movw	r28, r24
    1bd0:	7d 83       	std	Y+5, r23	; 0x05
    1bd2:	6c 83       	std	Y+4, r22	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
    1bd4:	e9 01       	movw	r28, r18
    1bd6:	7b 83       	std	Y+3, r23	; 0x03
    1bd8:	6a 83       	std	Y+2, r22	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
    1bda:	72 83       	std	Z+2, r23	; 0x02
    1bdc:	61 83       	std	Z+1, r22	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1bde:	19 96       	adiw	r26, 0x09	; 9
    1be0:	fc 93       	st	X, r31
    1be2:	ee 93       	st	-X, r30
    1be4:	18 97       	sbiw	r26, 0x08	; 8

	( pxList->uxNumberOfItems )++;
    1be6:	80 81       	ld	r24, Z
    1be8:	8f 5f       	subi	r24, 0xFF	; 255
    1bea:	80 83       	st	Z, r24
}
    1bec:	df 91       	pop	r29
    1bee:	cf 91       	pop	r28
    1bf0:	08 95       	ret

00001bf2 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
    1bf2:	cf 93       	push	r28
    1bf4:	df 93       	push	r29
    1bf6:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
    1bf8:	48 81       	ld	r20, Y
    1bfa:	59 81       	ldd	r21, Y+1	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    1bfc:	4f 3f       	cpi	r20, 0xFF	; 255
    1bfe:	2f ef       	ldi	r18, 0xFF	; 255
    1c00:	52 07       	cpc	r21, r18
    1c02:	31 f4       	brne	.+12     	; 0x1c10 <vListInsert+0x1e>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    1c04:	dc 01       	movw	r26, r24
    1c06:	17 96       	adiw	r26, 0x07	; 7
    1c08:	ed 91       	ld	r30, X+
    1c0a:	fc 91       	ld	r31, X
    1c0c:	18 97       	sbiw	r26, 0x08	; 8
    1c0e:	0d c0       	rjmp	.+26     	; 0x1c2a <vListInsert+0x38>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    1c10:	fc 01       	movw	r30, r24
    1c12:	33 96       	adiw	r30, 0x03	; 3
    1c14:	03 c0       	rjmp	.+6      	; 0x1c1c <vListInsert+0x2a>
    1c16:	02 80       	ldd	r0, Z+2	; 0x02
    1c18:	f3 81       	ldd	r31, Z+3	; 0x03
    1c1a:	e0 2d       	mov	r30, r0
    1c1c:	a2 81       	ldd	r26, Z+2	; 0x02
    1c1e:	b3 81       	ldd	r27, Z+3	; 0x03
    1c20:	2d 91       	ld	r18, X+
    1c22:	3c 91       	ld	r19, X
    1c24:	42 17       	cp	r20, r18
    1c26:	53 07       	cpc	r21, r19
    1c28:	b0 f7       	brcc	.-20     	; 0x1c16 <vListInsert+0x24>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    1c2a:	a2 81       	ldd	r26, Z+2	; 0x02
    1c2c:	b3 81       	ldd	r27, Z+3	; 0x03
    1c2e:	bb 83       	std	Y+3, r27	; 0x03
    1c30:	aa 83       	std	Y+2, r26	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    1c32:	15 96       	adiw	r26, 0x05	; 5
    1c34:	dc 93       	st	X, r29
    1c36:	ce 93       	st	-X, r28
    1c38:	14 97       	sbiw	r26, 0x04	; 4
	pxNewListItem->pxPrevious = pxIterator;
    1c3a:	fd 83       	std	Y+5, r31	; 0x05
    1c3c:	ec 83       	std	Y+4, r30	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    1c3e:	d3 83       	std	Z+3, r29	; 0x03
    1c40:	c2 83       	std	Z+2, r28	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1c42:	99 87       	std	Y+9, r25	; 0x09
    1c44:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    1c46:	fc 01       	movw	r30, r24
    1c48:	20 81       	ld	r18, Z
    1c4a:	2f 5f       	subi	r18, 0xFF	; 255
    1c4c:	20 83       	st	Z, r18
}
    1c4e:	df 91       	pop	r29
    1c50:	cf 91       	pop	r28
    1c52:	08 95       	ret

00001c54 <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
    1c54:	fc 01       	movw	r30, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    1c56:	a2 81       	ldd	r26, Z+2	; 0x02
    1c58:	b3 81       	ldd	r27, Z+3	; 0x03
    1c5a:	84 81       	ldd	r24, Z+4	; 0x04
    1c5c:	95 81       	ldd	r25, Z+5	; 0x05
    1c5e:	15 96       	adiw	r26, 0x05	; 5
    1c60:	9c 93       	st	X, r25
    1c62:	8e 93       	st	-X, r24
    1c64:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    1c66:	a4 81       	ldd	r26, Z+4	; 0x04
    1c68:	b5 81       	ldd	r27, Z+5	; 0x05
    1c6a:	82 81       	ldd	r24, Z+2	; 0x02
    1c6c:	93 81       	ldd	r25, Z+3	; 0x03
    1c6e:	13 96       	adiw	r26, 0x03	; 3
    1c70:	9c 93       	st	X, r25
    1c72:	8e 93       	st	-X, r24
    1c74:	12 97       	sbiw	r26, 0x02	; 2
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    1c76:	a0 85       	ldd	r26, Z+8	; 0x08
    1c78:	b1 85       	ldd	r27, Z+9	; 0x09

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    1c7a:	11 96       	adiw	r26, 0x01	; 1
    1c7c:	8d 91       	ld	r24, X+
    1c7e:	9c 91       	ld	r25, X
    1c80:	12 97       	sbiw	r26, 0x02	; 2
    1c82:	e8 17       	cp	r30, r24
    1c84:	f9 07       	cpc	r31, r25
    1c86:	31 f4       	brne	.+12     	; 0x1c94 <vListRemove+0x40>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    1c88:	84 81       	ldd	r24, Z+4	; 0x04
    1c8a:	95 81       	ldd	r25, Z+5	; 0x05
    1c8c:	12 96       	adiw	r26, 0x02	; 2
    1c8e:	9c 93       	st	X, r25
    1c90:	8e 93       	st	-X, r24
    1c92:	11 97       	sbiw	r26, 0x01	; 1
	}

	pxItemToRemove->pvContainer = NULL;
    1c94:	11 86       	std	Z+9, r1	; 0x09
    1c96:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    1c98:	8c 91       	ld	r24, X
    1c9a:	81 50       	subi	r24, 0x01	; 1
    1c9c:	8c 93       	st	X, r24
    1c9e:	08 95       	ret

00001ca0 <prvSetupTimerInterrupt>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    1ca0:	8a ef       	ldi	r24, 0xFA	; 250
    1ca2:	87 bd       	out	0x27, r24	; 39
    1ca4:	82 e0       	ldi	r24, 0x02	; 2
    1ca6:	84 bd       	out	0x24, r24	; 36
    1ca8:	93 e0       	ldi	r25, 0x03	; 3
    1caa:	95 bd       	out	0x25, r25	; 37
    1cac:	80 93 6e 00 	sts	0x006E, r24	; 0x80006e <__TEXT_REGION_LENGTH__+0x70006e>
    1cb0:	08 95       	ret

00001cb2 <pxPortInitialiseStack>:
    1cb2:	31 e1       	ldi	r19, 0x11	; 17
    1cb4:	fc 01       	movw	r30, r24
    1cb6:	30 83       	st	Z, r19
    1cb8:	31 97       	sbiw	r30, 0x01	; 1
    1cba:	22 e2       	ldi	r18, 0x22	; 34
    1cbc:	20 83       	st	Z, r18
    1cbe:	31 97       	sbiw	r30, 0x01	; 1
    1cc0:	a3 e3       	ldi	r26, 0x33	; 51
    1cc2:	a0 83       	st	Z, r26
    1cc4:	31 97       	sbiw	r30, 0x01	; 1
    1cc6:	60 83       	st	Z, r22
    1cc8:	31 97       	sbiw	r30, 0x01	; 1
    1cca:	70 83       	st	Z, r23
    1ccc:	31 97       	sbiw	r30, 0x01	; 1
    1cce:	10 82       	st	Z, r1
    1cd0:	31 97       	sbiw	r30, 0x01	; 1
    1cd2:	10 82       	st	Z, r1
    1cd4:	31 97       	sbiw	r30, 0x01	; 1
    1cd6:	60 e8       	ldi	r22, 0x80	; 128
    1cd8:	60 83       	st	Z, r22
    1cda:	31 97       	sbiw	r30, 0x01	; 1
    1cdc:	10 82       	st	Z, r1
    1cde:	31 97       	sbiw	r30, 0x01	; 1
    1ce0:	10 82       	st	Z, r1
    1ce2:	31 97       	sbiw	r30, 0x01	; 1
    1ce4:	10 82       	st	Z, r1
    1ce6:	31 97       	sbiw	r30, 0x01	; 1
    1ce8:	62 e0       	ldi	r22, 0x02	; 2
    1cea:	60 83       	st	Z, r22
    1cec:	31 97       	sbiw	r30, 0x01	; 1
    1cee:	63 e0       	ldi	r22, 0x03	; 3
    1cf0:	60 83       	st	Z, r22
    1cf2:	31 97       	sbiw	r30, 0x01	; 1
    1cf4:	64 e0       	ldi	r22, 0x04	; 4
    1cf6:	60 83       	st	Z, r22
    1cf8:	31 97       	sbiw	r30, 0x01	; 1
    1cfa:	65 e0       	ldi	r22, 0x05	; 5
    1cfc:	60 83       	st	Z, r22
    1cfe:	31 97       	sbiw	r30, 0x01	; 1
    1d00:	66 e0       	ldi	r22, 0x06	; 6
    1d02:	60 83       	st	Z, r22
    1d04:	31 97       	sbiw	r30, 0x01	; 1
    1d06:	67 e0       	ldi	r22, 0x07	; 7
    1d08:	60 83       	st	Z, r22
    1d0a:	31 97       	sbiw	r30, 0x01	; 1
    1d0c:	68 e0       	ldi	r22, 0x08	; 8
    1d0e:	60 83       	st	Z, r22
    1d10:	31 97       	sbiw	r30, 0x01	; 1
    1d12:	69 e0       	ldi	r22, 0x09	; 9
    1d14:	60 83       	st	Z, r22
    1d16:	31 97       	sbiw	r30, 0x01	; 1
    1d18:	60 e1       	ldi	r22, 0x10	; 16
    1d1a:	60 83       	st	Z, r22
    1d1c:	31 97       	sbiw	r30, 0x01	; 1
    1d1e:	30 83       	st	Z, r19
    1d20:	31 97       	sbiw	r30, 0x01	; 1
    1d22:	32 e1       	ldi	r19, 0x12	; 18
    1d24:	30 83       	st	Z, r19
    1d26:	31 97       	sbiw	r30, 0x01	; 1
    1d28:	33 e1       	ldi	r19, 0x13	; 19
    1d2a:	30 83       	st	Z, r19
    1d2c:	31 97       	sbiw	r30, 0x01	; 1
    1d2e:	34 e1       	ldi	r19, 0x14	; 20
    1d30:	30 83       	st	Z, r19
    1d32:	31 97       	sbiw	r30, 0x01	; 1
    1d34:	35 e1       	ldi	r19, 0x15	; 21
    1d36:	30 83       	st	Z, r19
    1d38:	31 97       	sbiw	r30, 0x01	; 1
    1d3a:	36 e1       	ldi	r19, 0x16	; 22
    1d3c:	30 83       	st	Z, r19
    1d3e:	31 97       	sbiw	r30, 0x01	; 1
    1d40:	37 e1       	ldi	r19, 0x17	; 23
    1d42:	30 83       	st	Z, r19
    1d44:	31 97       	sbiw	r30, 0x01	; 1
    1d46:	38 e1       	ldi	r19, 0x18	; 24
    1d48:	30 83       	st	Z, r19
    1d4a:	31 97       	sbiw	r30, 0x01	; 1
    1d4c:	39 e1       	ldi	r19, 0x19	; 25
    1d4e:	30 83       	st	Z, r19
    1d50:	31 97       	sbiw	r30, 0x01	; 1
    1d52:	30 e2       	ldi	r19, 0x20	; 32
    1d54:	30 83       	st	Z, r19
    1d56:	31 97       	sbiw	r30, 0x01	; 1
    1d58:	31 e2       	ldi	r19, 0x21	; 33
    1d5a:	30 83       	st	Z, r19
    1d5c:	31 97       	sbiw	r30, 0x01	; 1
    1d5e:	20 83       	st	Z, r18
    1d60:	31 97       	sbiw	r30, 0x01	; 1
    1d62:	23 e2       	ldi	r18, 0x23	; 35
    1d64:	20 83       	st	Z, r18
    1d66:	31 97       	sbiw	r30, 0x01	; 1
    1d68:	40 83       	st	Z, r20
    1d6a:	31 97       	sbiw	r30, 0x01	; 1
    1d6c:	50 83       	st	Z, r21
    1d6e:	31 97       	sbiw	r30, 0x01	; 1
    1d70:	26 e2       	ldi	r18, 0x26	; 38
    1d72:	20 83       	st	Z, r18
    1d74:	31 97       	sbiw	r30, 0x01	; 1
    1d76:	27 e2       	ldi	r18, 0x27	; 39
    1d78:	20 83       	st	Z, r18
    1d7a:	31 97       	sbiw	r30, 0x01	; 1
    1d7c:	28 e2       	ldi	r18, 0x28	; 40
    1d7e:	20 83       	st	Z, r18
    1d80:	31 97       	sbiw	r30, 0x01	; 1
    1d82:	29 e2       	ldi	r18, 0x29	; 41
    1d84:	20 83       	st	Z, r18
    1d86:	31 97       	sbiw	r30, 0x01	; 1
    1d88:	20 e3       	ldi	r18, 0x30	; 48
    1d8a:	20 83       	st	Z, r18
    1d8c:	31 97       	sbiw	r30, 0x01	; 1
    1d8e:	21 e3       	ldi	r18, 0x31	; 49
    1d90:	20 83       	st	Z, r18
    1d92:	89 97       	sbiw	r24, 0x29	; 41
    1d94:	08 95       	ret

00001d96 <xPortStartScheduler>:
    1d96:	84 df       	rcall	.-248    	; 0x1ca0 <prvSetupTimerInterrupt>
    1d98:	a0 91 de 12 	lds	r26, 0x12DE	; 0x8012de <pxCurrentTCB>
    1d9c:	b0 91 df 12 	lds	r27, 0x12DF	; 0x8012df <pxCurrentTCB+0x1>
    1da0:	cd 91       	ld	r28, X+
    1da2:	cd bf       	out	0x3d, r28	; 61
    1da4:	dd 91       	ld	r29, X+
    1da6:	de bf       	out	0x3e, r29	; 62
    1da8:	ff 91       	pop	r31
    1daa:	ef 91       	pop	r30
    1dac:	df 91       	pop	r29
    1dae:	cf 91       	pop	r28
    1db0:	bf 91       	pop	r27
    1db2:	af 91       	pop	r26
    1db4:	9f 91       	pop	r25
    1db6:	8f 91       	pop	r24
    1db8:	7f 91       	pop	r23
    1dba:	6f 91       	pop	r22
    1dbc:	5f 91       	pop	r21
    1dbe:	4f 91       	pop	r20
    1dc0:	3f 91       	pop	r19
    1dc2:	2f 91       	pop	r18
    1dc4:	1f 91       	pop	r17
    1dc6:	0f 91       	pop	r16
    1dc8:	ff 90       	pop	r15
    1dca:	ef 90       	pop	r14
    1dcc:	df 90       	pop	r13
    1dce:	cf 90       	pop	r12
    1dd0:	bf 90       	pop	r11
    1dd2:	af 90       	pop	r10
    1dd4:	9f 90       	pop	r9
    1dd6:	8f 90       	pop	r8
    1dd8:	7f 90       	pop	r7
    1dda:	6f 90       	pop	r6
    1ddc:	5f 90       	pop	r5
    1dde:	4f 90       	pop	r4
    1de0:	3f 90       	pop	r3
    1de2:	2f 90       	pop	r2
    1de4:	1f 90       	pop	r1
    1de6:	0f 90       	pop	r0
    1de8:	0c be       	out	0x3c, r0	; 60
    1dea:	0f 90       	pop	r0
    1dec:	0b be       	out	0x3b, r0	; 59
    1dee:	0f 90       	pop	r0
    1df0:	0f be       	out	0x3f, r0	; 63
    1df2:	0f 90       	pop	r0
    1df4:	08 95       	ret
    1df6:	81 e0       	ldi	r24, 0x01	; 1
    1df8:	08 95       	ret

00001dfa <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    1dfa:	0f 92       	push	r0
    1dfc:	0f b6       	in	r0, 0x3f	; 63
    1dfe:	f8 94       	cli
    1e00:	0f 92       	push	r0
    1e02:	0b b6       	in	r0, 0x3b	; 59
    1e04:	0f 92       	push	r0
    1e06:	0c b6       	in	r0, 0x3c	; 60
    1e08:	0f 92       	push	r0
    1e0a:	1f 92       	push	r1
    1e0c:	11 24       	eor	r1, r1
    1e0e:	2f 92       	push	r2
    1e10:	3f 92       	push	r3
    1e12:	4f 92       	push	r4
    1e14:	5f 92       	push	r5
    1e16:	6f 92       	push	r6
    1e18:	7f 92       	push	r7
    1e1a:	8f 92       	push	r8
    1e1c:	9f 92       	push	r9
    1e1e:	af 92       	push	r10
    1e20:	bf 92       	push	r11
    1e22:	cf 92       	push	r12
    1e24:	df 92       	push	r13
    1e26:	ef 92       	push	r14
    1e28:	ff 92       	push	r15
    1e2a:	0f 93       	push	r16
    1e2c:	1f 93       	push	r17
    1e2e:	2f 93       	push	r18
    1e30:	3f 93       	push	r19
    1e32:	4f 93       	push	r20
    1e34:	5f 93       	push	r21
    1e36:	6f 93       	push	r22
    1e38:	7f 93       	push	r23
    1e3a:	8f 93       	push	r24
    1e3c:	9f 93       	push	r25
    1e3e:	af 93       	push	r26
    1e40:	bf 93       	push	r27
    1e42:	cf 93       	push	r28
    1e44:	df 93       	push	r29
    1e46:	ef 93       	push	r30
    1e48:	ff 93       	push	r31
    1e4a:	a0 91 de 12 	lds	r26, 0x12DE	; 0x8012de <pxCurrentTCB>
    1e4e:	b0 91 df 12 	lds	r27, 0x12DF	; 0x8012df <pxCurrentTCB+0x1>
    1e52:	0d b6       	in	r0, 0x3d	; 61
    1e54:	0d 92       	st	X+, r0
    1e56:	0e b6       	in	r0, 0x3e	; 62
    1e58:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    1e5a:	86 d3       	rcall	.+1804   	; 0x2568 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1e5c:	a0 91 de 12 	lds	r26, 0x12DE	; 0x8012de <pxCurrentTCB>
    1e60:	b0 91 df 12 	lds	r27, 0x12DF	; 0x8012df <pxCurrentTCB+0x1>
    1e64:	cd 91       	ld	r28, X+
    1e66:	cd bf       	out	0x3d, r28	; 61
    1e68:	dd 91       	ld	r29, X+
    1e6a:	de bf       	out	0x3e, r29	; 62
    1e6c:	ff 91       	pop	r31
    1e6e:	ef 91       	pop	r30
    1e70:	df 91       	pop	r29
    1e72:	cf 91       	pop	r28
    1e74:	bf 91       	pop	r27
    1e76:	af 91       	pop	r26
    1e78:	9f 91       	pop	r25
    1e7a:	8f 91       	pop	r24
    1e7c:	7f 91       	pop	r23
    1e7e:	6f 91       	pop	r22
    1e80:	5f 91       	pop	r21
    1e82:	4f 91       	pop	r20
    1e84:	3f 91       	pop	r19
    1e86:	2f 91       	pop	r18
    1e88:	1f 91       	pop	r17
    1e8a:	0f 91       	pop	r16
    1e8c:	ff 90       	pop	r15
    1e8e:	ef 90       	pop	r14
    1e90:	df 90       	pop	r13
    1e92:	cf 90       	pop	r12
    1e94:	bf 90       	pop	r11
    1e96:	af 90       	pop	r10
    1e98:	9f 90       	pop	r9
    1e9a:	8f 90       	pop	r8
    1e9c:	7f 90       	pop	r7
    1e9e:	6f 90       	pop	r6
    1ea0:	5f 90       	pop	r5
    1ea2:	4f 90       	pop	r4
    1ea4:	3f 90       	pop	r3
    1ea6:	2f 90       	pop	r2
    1ea8:	1f 90       	pop	r1
    1eaa:	0f 90       	pop	r0
    1eac:	0c be       	out	0x3c, r0	; 60
    1eae:	0f 90       	pop	r0
    1eb0:	0b be       	out	0x3b, r0	; 59
    1eb2:	0f 90       	pop	r0
    1eb4:	0f be       	out	0x3f, r0	; 63
    1eb6:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1eb8:	08 95       	ret

00001eba <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    1eba:	0f 92       	push	r0
    1ebc:	0f b6       	in	r0, 0x3f	; 63
    1ebe:	f8 94       	cli
    1ec0:	0f 92       	push	r0
    1ec2:	0b b6       	in	r0, 0x3b	; 59
    1ec4:	0f 92       	push	r0
    1ec6:	0c b6       	in	r0, 0x3c	; 60
    1ec8:	0f 92       	push	r0
    1eca:	1f 92       	push	r1
    1ecc:	11 24       	eor	r1, r1
    1ece:	2f 92       	push	r2
    1ed0:	3f 92       	push	r3
    1ed2:	4f 92       	push	r4
    1ed4:	5f 92       	push	r5
    1ed6:	6f 92       	push	r6
    1ed8:	7f 92       	push	r7
    1eda:	8f 92       	push	r8
    1edc:	9f 92       	push	r9
    1ede:	af 92       	push	r10
    1ee0:	bf 92       	push	r11
    1ee2:	cf 92       	push	r12
    1ee4:	df 92       	push	r13
    1ee6:	ef 92       	push	r14
    1ee8:	ff 92       	push	r15
    1eea:	0f 93       	push	r16
    1eec:	1f 93       	push	r17
    1eee:	2f 93       	push	r18
    1ef0:	3f 93       	push	r19
    1ef2:	4f 93       	push	r20
    1ef4:	5f 93       	push	r21
    1ef6:	6f 93       	push	r22
    1ef8:	7f 93       	push	r23
    1efa:	8f 93       	push	r24
    1efc:	9f 93       	push	r25
    1efe:	af 93       	push	r26
    1f00:	bf 93       	push	r27
    1f02:	cf 93       	push	r28
    1f04:	df 93       	push	r29
    1f06:	ef 93       	push	r30
    1f08:	ff 93       	push	r31
    1f0a:	a0 91 de 12 	lds	r26, 0x12DE	; 0x8012de <pxCurrentTCB>
    1f0e:	b0 91 df 12 	lds	r27, 0x12DF	; 0x8012df <pxCurrentTCB+0x1>
    1f12:	0d b6       	in	r0, 0x3d	; 61
    1f14:	0d 92       	st	X+, r0
    1f16:	0e b6       	in	r0, 0x3e	; 62
    1f18:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    1f1a:	f1 d1       	rcall	.+994    	; 0x22fe <vTaskIncrementTick>
	vTaskSwitchContext();
    1f1c:	25 d3       	rcall	.+1610   	; 0x2568 <vTaskSwitchContext>
    1f1e:	a0 91 de 12 	lds	r26, 0x12DE	; 0x8012de <pxCurrentTCB>
	portRESTORE_CONTEXT();
    1f22:	b0 91 df 12 	lds	r27, 0x12DF	; 0x8012df <pxCurrentTCB+0x1>
    1f26:	cd 91       	ld	r28, X+
    1f28:	cd bf       	out	0x3d, r28	; 61
    1f2a:	dd 91       	ld	r29, X+
    1f2c:	de bf       	out	0x3e, r29	; 62
    1f2e:	ff 91       	pop	r31
    1f30:	ef 91       	pop	r30
    1f32:	df 91       	pop	r29
    1f34:	cf 91       	pop	r28
    1f36:	bf 91       	pop	r27
    1f38:	af 91       	pop	r26
    1f3a:	9f 91       	pop	r25
    1f3c:	8f 91       	pop	r24
    1f3e:	7f 91       	pop	r23
    1f40:	6f 91       	pop	r22
    1f42:	5f 91       	pop	r21
    1f44:	4f 91       	pop	r20
    1f46:	3f 91       	pop	r19
    1f48:	2f 91       	pop	r18
    1f4a:	1f 91       	pop	r17
    1f4c:	0f 91       	pop	r16
    1f4e:	ff 90       	pop	r15
    1f50:	ef 90       	pop	r14
    1f52:	df 90       	pop	r13
    1f54:	cf 90       	pop	r12
    1f56:	bf 90       	pop	r11
    1f58:	af 90       	pop	r10
    1f5a:	9f 90       	pop	r9
    1f5c:	8f 90       	pop	r8
    1f5e:	7f 90       	pop	r7
    1f60:	6f 90       	pop	r6
    1f62:	5f 90       	pop	r5
    1f64:	4f 90       	pop	r4
    1f66:	3f 90       	pop	r3
    1f68:	2f 90       	pop	r2
    1f6a:	1f 90       	pop	r1
    1f6c:	0f 90       	pop	r0
    1f6e:	0c be       	out	0x3c, r0	; 60
    1f70:	0f 90       	pop	r0
    1f72:	0b be       	out	0x3b, r0	; 59
    1f74:	0f 90       	pop	r0
    1f76:	0f be       	out	0x3f, r0	; 63
    1f78:	0f 90       	pop	r0
    1f7a:	08 95       	ret

00001f7c <__vector_21>:
	asm volatile ( "ret" );
    1f7c:	9e df       	rcall	.-196    	; 0x1eba <vPortYieldFromTick>
//	void SIG_OUTPUT_COMPARE1A( void )
	void TIMER0_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER0_COMPA_vect( void )
	{
		vPortYieldFromTick();
		asm volatile ( "reti" );
    1f7e:	18 95       	reti

00001f80 <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    1f80:	cf 93       	push	r28
    1f82:	df 93       	push	r29
    1f84:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
    1f86:	b5 d1       	rcall	.+874    	; 0x22f2 <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
    1f88:	20 91 09 03 	lds	r18, 0x0309	; 0x800309 <xNextFreeByte>
    1f8c:	30 91 0a 03 	lds	r19, 0x030A	; 0x80030a <xNextFreeByte+0x1>
    1f90:	c9 01       	movw	r24, r18
    1f92:	8c 0f       	add	r24, r28
    1f94:	9d 1f       	adc	r25, r29
    1f96:	80 3a       	cpi	r24, 0xA0	; 160
    1f98:	4f e0       	ldi	r20, 0x0F	; 15
    1f9a:	94 07       	cpc	r25, r20
    1f9c:	58 f4       	brcc	.+22     	; 0x1fb4 <pvPortMalloc+0x34>
    1f9e:	28 17       	cp	r18, r24
    1fa0:	39 07       	cpc	r19, r25
    1fa2:	58 f4       	brcc	.+22     	; 0x1fba <pvPortMalloc+0x3a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
    1fa4:	e9 01       	movw	r28, r18
    1fa6:	c5 5f       	subi	r28, 0xF5	; 245
    1fa8:	dc 4f       	sbci	r29, 0xFC	; 252
			xNextFreeByte += xWantedSize;			
    1faa:	90 93 0a 03 	sts	0x030A, r25	; 0x80030a <xNextFreeByte+0x1>
    1fae:	80 93 09 03 	sts	0x0309, r24	; 0x800309 <xNextFreeByte>
    1fb2:	05 c0       	rjmp	.+10     	; 0x1fbe <pvPortMalloc+0x3e>
static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL; 
    1fb4:	c0 e0       	ldi	r28, 0x00	; 0
    1fb6:	d0 e0       	ldi	r29, 0x00	; 0
    1fb8:	02 c0       	rjmp	.+4      	; 0x1fbe <pvPortMalloc+0x3e>
    1fba:	c0 e0       	ldi	r28, 0x00	; 0
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
			xNextFreeByte += xWantedSize;			
		}	
	}
	xTaskResumeAll();
    1fbc:	d0 e0       	ldi	r29, 0x00	; 0
    1fbe:	46 d2       	rcall	.+1164   	; 0x244c <xTaskResumeAll>
		}
	}
	#endif	

	return pvReturn;
}
    1fc0:	ce 01       	movw	r24, r28
    1fc2:	df 91       	pop	r29
    1fc4:	cf 91       	pop	r28
    1fc6:	08 95       	ret

00001fc8 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    1fc8:	08 95       	ret

00001fca <prvIdleTask>:
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
		}
	}
    1fca:	80 91 d5 12 	lds	r24, 0x12D5	; 0x8012d5 <pxReadyTasksLists>
    1fce:	82 30       	cpi	r24, 0x02	; 2
    1fd0:	e0 f3       	brcs	.-8      	; 0x1fca <prvIdleTask>
    1fd2:	13 df       	rcall	.-474    	; 0x1dfa <vPortYield>
    1fd4:	fa cf       	rjmp	.-12     	; 0x1fca <prvIdleTask>

00001fd6 <prvAllocateTCBAndStack>:
    1fd6:	ef 92       	push	r14
    1fd8:	ff 92       	push	r15
    1fda:	0f 93       	push	r16
    1fdc:	1f 93       	push	r17
    1fde:	cf 93       	push	r28
    1fe0:	df 93       	push	r29
    1fe2:	7c 01       	movw	r14, r24
    1fe4:	eb 01       	movw	r28, r22
    1fe6:	81 e2       	ldi	r24, 0x21	; 33
    1fe8:	90 e0       	ldi	r25, 0x00	; 0
    1fea:	ca df       	rcall	.-108    	; 0x1f80 <pvPortMalloc>
    1fec:	8c 01       	movw	r16, r24
    1fee:	89 2b       	or	r24, r25
    1ff0:	a9 f0       	breq	.+42     	; 0x201c <prvAllocateTCBAndStack+0x46>
    1ff2:	20 97       	sbiw	r28, 0x00	; 0
    1ff4:	19 f4       	brne	.+6      	; 0x1ffc <prvAllocateTCBAndStack+0x26>
    1ff6:	c7 01       	movw	r24, r14
    1ff8:	c3 df       	rcall	.-122    	; 0x1f80 <pvPortMalloc>
    1ffa:	01 c0       	rjmp	.+2      	; 0x1ffe <prvAllocateTCBAndStack+0x28>
    1ffc:	ce 01       	movw	r24, r28
    1ffe:	f8 01       	movw	r30, r16
    2000:	90 8f       	std	Z+24, r25	; 0x18
    2002:	87 8b       	std	Z+23, r24	; 0x17
    2004:	00 97       	sbiw	r24, 0x00	; 0
    2006:	29 f4       	brne	.+10     	; 0x2012 <prvAllocateTCBAndStack+0x3c>
    2008:	c8 01       	movw	r24, r16
    200a:	de df       	rcall	.-68     	; 0x1fc8 <vPortFree>
    200c:	00 e0       	ldi	r16, 0x00	; 0
    200e:	10 e0       	ldi	r17, 0x00	; 0
    2010:	05 c0       	rjmp	.+10     	; 0x201c <prvAllocateTCBAndStack+0x46>
    2012:	a7 01       	movw	r20, r14
    2014:	65 ea       	ldi	r22, 0xA5	; 165
    2016:	70 e0       	ldi	r23, 0x00	; 0
    2018:	0e 94 36 1f 	call	0x3e6c	; 0x3e6c <memset>
    201c:	c8 01       	movw	r24, r16
    201e:	df 91       	pop	r29
    2020:	cf 91       	pop	r28
    2022:	1f 91       	pop	r17
    2024:	0f 91       	pop	r16
    2026:	ff 90       	pop	r15
    2028:	ef 90       	pop	r14
    202a:	08 95       	ret

0000202c <prvInitialiseTCBVariables>:
    202c:	1f 93       	push	r17
    202e:	cf 93       	push	r28
    2030:	df 93       	push	r29
    2032:	ec 01       	movw	r28, r24
    2034:	14 2f       	mov	r17, r20
    2036:	48 e0       	ldi	r20, 0x08	; 8
    2038:	50 e0       	ldi	r21, 0x00	; 0
    203a:	49 96       	adiw	r24, 0x19	; 25
    203c:	0e 94 3d 1f 	call	0x3e7a	; 0x3e7a <strncpy>
    2040:	18 a2       	std	Y+32, r1	; 0x20
    2042:	11 11       	cpse	r17, r1
    2044:	10 e0       	ldi	r17, 0x00	; 0
    2046:	1e 8b       	std	Y+22, r17	; 0x16
    2048:	ce 01       	movw	r24, r28
    204a:	02 96       	adiw	r24, 0x02	; 2
    204c:	a7 dd       	rcall	.-1202   	; 0x1b9c <vListInitialiseItem>
    204e:	ce 01       	movw	r24, r28
    2050:	0c 96       	adiw	r24, 0x0c	; 12
    2052:	a4 dd       	rcall	.-1208   	; 0x1b9c <vListInitialiseItem>
    2054:	d9 87       	std	Y+9, r29	; 0x09
    2056:	c8 87       	std	Y+8, r28	; 0x08
    2058:	81 e0       	ldi	r24, 0x01	; 1
    205a:	90 e0       	ldi	r25, 0x00	; 0
    205c:	81 1b       	sub	r24, r17
    205e:	91 09       	sbc	r25, r1
    2060:	9d 87       	std	Y+13, r25	; 0x0d
    2062:	8c 87       	std	Y+12, r24	; 0x0c
    2064:	db 8b       	std	Y+19, r29	; 0x13
    2066:	ca 8b       	std	Y+18, r28	; 0x12
    2068:	df 91       	pop	r29
    206a:	cf 91       	pop	r28
    206c:	1f 91       	pop	r17
    206e:	08 95       	ret

00002070 <prvInitialiseTaskLists>:
    2070:	cf 93       	push	r28
    2072:	c0 e0       	ldi	r28, 0x00	; 0
    2074:	0f c0       	rjmp	.+30     	; 0x2094 <prvInitialiseTaskLists+0x24>
    2076:	8c 2f       	mov	r24, r28
    2078:	90 e0       	ldi	r25, 0x00	; 0
    207a:	9c 01       	movw	r18, r24
    207c:	22 0f       	add	r18, r18
    207e:	33 1f       	adc	r19, r19
    2080:	22 0f       	add	r18, r18
    2082:	33 1f       	adc	r19, r19
    2084:	22 0f       	add	r18, r18
    2086:	33 1f       	adc	r19, r19
    2088:	82 0f       	add	r24, r18
    208a:	93 1f       	adc	r25, r19
    208c:	8b 52       	subi	r24, 0x2B	; 43
    208e:	9d 4e       	sbci	r25, 0xED	; 237
    2090:	77 dd       	rcall	.-1298   	; 0x1b80 <vListInitialise>
    2092:	cf 5f       	subi	r28, 0xFF	; 255
    2094:	cc 23       	and	r28, r28
    2096:	79 f3       	breq	.-34     	; 0x2076 <prvInitialiseTaskLists+0x6>
    2098:	8c ec       	ldi	r24, 0xCC	; 204
    209a:	92 e1       	ldi	r25, 0x12	; 18
    209c:	71 dd       	rcall	.-1310   	; 0x1b80 <vListInitialise>
    209e:	83 ec       	ldi	r24, 0xC3	; 195
    20a0:	92 e1       	ldi	r25, 0x12	; 18
    20a2:	6e dd       	rcall	.-1316   	; 0x1b80 <vListInitialise>
    20a4:	86 eb       	ldi	r24, 0xB6	; 182
    20a6:	92 e1       	ldi	r25, 0x12	; 18
    20a8:	6b dd       	rcall	.-1322   	; 0x1b80 <vListInitialise>
    20aa:	8c ec       	ldi	r24, 0xCC	; 204
    20ac:	92 e1       	ldi	r25, 0x12	; 18
    20ae:	90 93 c2 12 	sts	0x12C2, r25	; 0x8012c2 <pxDelayedTaskList+0x1>
    20b2:	80 93 c1 12 	sts	0x12C1, r24	; 0x8012c1 <pxDelayedTaskList>
    20b6:	83 ec       	ldi	r24, 0xC3	; 195
    20b8:	92 e1       	ldi	r25, 0x12	; 18
    20ba:	90 93 c0 12 	sts	0x12C0, r25	; 0x8012c0 <pxOverflowDelayedTaskList+0x1>
    20be:	80 93 bf 12 	sts	0x12BF, r24	; 0x8012bf <pxOverflowDelayedTaskList>
    20c2:	cf 91       	pop	r28
    20c4:	08 95       	ret

000020c6 <prvAddCurrentTaskToDelayedList>:
    20c6:	cf 93       	push	r28
    20c8:	df 93       	push	r29
    20ca:	ec 01       	movw	r28, r24
    20cc:	e0 91 de 12 	lds	r30, 0x12DE	; 0x8012de <pxCurrentTCB>
    20d0:	f0 91 df 12 	lds	r31, 0x12DF	; 0x8012df <pxCurrentTCB+0x1>
    20d4:	93 83       	std	Z+3, r25	; 0x03
    20d6:	82 83       	std	Z+2, r24	; 0x02
    20d8:	80 91 b3 12 	lds	r24, 0x12B3	; 0x8012b3 <xTickCount>
    20dc:	90 91 b4 12 	lds	r25, 0x12B4	; 0x8012b4 <xTickCount+0x1>
    20e0:	c8 17       	cp	r28, r24
    20e2:	d9 07       	cpc	r29, r25
    20e4:	60 f4       	brcc	.+24     	; 0x20fe <prvAddCurrentTaskToDelayedList+0x38>
    20e6:	60 91 de 12 	lds	r22, 0x12DE	; 0x8012de <pxCurrentTCB>
    20ea:	70 91 df 12 	lds	r23, 0x12DF	; 0x8012df <pxCurrentTCB+0x1>
    20ee:	80 91 bf 12 	lds	r24, 0x12BF	; 0x8012bf <pxOverflowDelayedTaskList>
    20f2:	90 91 c0 12 	lds	r25, 0x12C0	; 0x8012c0 <pxOverflowDelayedTaskList+0x1>
    20f6:	6e 5f       	subi	r22, 0xFE	; 254
    20f8:	7f 4f       	sbci	r23, 0xFF	; 255
    20fa:	7b dd       	rcall	.-1290   	; 0x1bf2 <vListInsert>
    20fc:	16 c0       	rjmp	.+44     	; 0x212a <prvAddCurrentTaskToDelayedList+0x64>
    20fe:	60 91 de 12 	lds	r22, 0x12DE	; 0x8012de <pxCurrentTCB>
    2102:	70 91 df 12 	lds	r23, 0x12DF	; 0x8012df <pxCurrentTCB+0x1>
    2106:	80 91 c1 12 	lds	r24, 0x12C1	; 0x8012c1 <pxDelayedTaskList>
    210a:	90 91 c2 12 	lds	r25, 0x12C2	; 0x8012c2 <pxDelayedTaskList+0x1>
    210e:	6e 5f       	subi	r22, 0xFE	; 254
    2110:	7f 4f       	sbci	r23, 0xFF	; 255
    2112:	6f dd       	rcall	.-1314   	; 0x1bf2 <vListInsert>
    2114:	80 91 0b 02 	lds	r24, 0x020B	; 0x80020b <xNextTaskUnblockTime>
    2118:	90 91 0c 02 	lds	r25, 0x020C	; 0x80020c <xNextTaskUnblockTime+0x1>
    211c:	c8 17       	cp	r28, r24
    211e:	d9 07       	cpc	r29, r25
    2120:	20 f4       	brcc	.+8      	; 0x212a <prvAddCurrentTaskToDelayedList+0x64>
    2122:	d0 93 0c 02 	sts	0x020C, r29	; 0x80020c <xNextTaskUnblockTime+0x1>
    2126:	c0 93 0b 02 	sts	0x020B, r28	; 0x80020b <xNextTaskUnblockTime>
    212a:	df 91       	pop	r29
    212c:	cf 91       	pop	r28
    212e:	08 95       	ret

00002130 <xTaskGenericCreate>:
    2130:	2f 92       	push	r2
    2132:	3f 92       	push	r3
    2134:	4f 92       	push	r4
    2136:	5f 92       	push	r5
    2138:	7f 92       	push	r7
    213a:	8f 92       	push	r8
    213c:	9f 92       	push	r9
    213e:	af 92       	push	r10
    2140:	bf 92       	push	r11
    2142:	cf 92       	push	r12
    2144:	df 92       	push	r13
    2146:	ef 92       	push	r14
    2148:	ff 92       	push	r15
    214a:	0f 93       	push	r16
    214c:	1f 93       	push	r17
    214e:	cf 93       	push	r28
    2150:	df 93       	push	r29
    2152:	00 d0       	rcall	.+0      	; 0x2154 <xTaskGenericCreate+0x24>
    2154:	1f 92       	push	r1
    2156:	cd b7       	in	r28, 0x3d	; 61
    2158:	de b7       	in	r29, 0x3e	; 62
    215a:	9a 83       	std	Y+2, r25	; 0x02
    215c:	89 83       	std	Y+1, r24	; 0x01
    215e:	4b 01       	movw	r8, r22
    2160:	5c 83       	std	Y+4, r21	; 0x04
    2162:	4b 83       	std	Y+3, r20	; 0x03
    2164:	19 01       	movw	r2, r18
    2166:	70 2e       	mov	r7, r16
    2168:	b6 01       	movw	r22, r12
    216a:	25 01       	movw	r4, r10
    216c:	ca 01       	movw	r24, r20
    216e:	33 df       	rcall	.-410    	; 0x1fd6 <prvAllocateTCBAndStack>
    2170:	5c 01       	movw	r10, r24
    2172:	00 97       	sbiw	r24, 0x00	; 0
    2174:	09 f4       	brne	.+2      	; 0x2178 <xTaskGenericCreate+0x48>
    2176:	6c c0       	rjmp	.+216    	; 0x2250 <__stack+0x51>
    2178:	fc 01       	movw	r30, r24
    217a:	c7 88       	ldd	r12, Z+23	; 0x17
    217c:	d0 8c       	ldd	r13, Z+24	; 0x18
    217e:	8b 81       	ldd	r24, Y+3	; 0x03
    2180:	9c 81       	ldd	r25, Y+4	; 0x04
    2182:	01 97       	sbiw	r24, 0x01	; 1
    2184:	c8 0e       	add	r12, r24
    2186:	d9 1e       	adc	r13, r25
    2188:	0b 81       	ldd	r16, Y+3	; 0x03
    218a:	1c 81       	ldd	r17, Y+4	; 0x04
    218c:	92 01       	movw	r18, r4
    218e:	47 2d       	mov	r20, r7
    2190:	b4 01       	movw	r22, r8
    2192:	c5 01       	movw	r24, r10
    2194:	4b df       	rcall	.-362    	; 0x202c <prvInitialiseTCBVariables>
    2196:	a1 01       	movw	r20, r2
    2198:	69 81       	ldd	r22, Y+1	; 0x01
    219a:	7a 81       	ldd	r23, Y+2	; 0x02
    219c:	c6 01       	movw	r24, r12
    219e:	89 dd       	rcall	.-1262   	; 0x1cb2 <pxPortInitialiseStack>
    21a0:	f5 01       	movw	r30, r10
    21a2:	91 83       	std	Z+1, r25	; 0x01
    21a4:	80 83       	st	Z, r24
    21a6:	e1 14       	cp	r14, r1
    21a8:	f1 04       	cpc	r15, r1
    21aa:	19 f0       	breq	.+6      	; 0x21b2 <xTaskGenericCreate+0x82>
    21ac:	f7 01       	movw	r30, r14
    21ae:	b1 82       	std	Z+1, r11	; 0x01
    21b0:	a0 82       	st	Z, r10
    21b2:	0f b6       	in	r0, 0x3f	; 63
    21b4:	f8 94       	cli
    21b6:	0f 92       	push	r0
    21b8:	80 91 b5 12 	lds	r24, 0x12B5	; 0x8012b5 <uxCurrentNumberOfTasks>
    21bc:	8f 5f       	subi	r24, 0xFF	; 255
    21be:	80 93 b5 12 	sts	0x12B5, r24	; 0x8012b5 <uxCurrentNumberOfTasks>
    21c2:	80 91 de 12 	lds	r24, 0x12DE	; 0x8012de <pxCurrentTCB>
    21c6:	90 91 df 12 	lds	r25, 0x12DF	; 0x8012df <pxCurrentTCB+0x1>
    21ca:	89 2b       	or	r24, r25
    21cc:	51 f4       	brne	.+20     	; 0x21e2 <xTaskGenericCreate+0xb2>
    21ce:	b0 92 df 12 	sts	0x12DF, r11	; 0x8012df <pxCurrentTCB+0x1>
    21d2:	a0 92 de 12 	sts	0x12DE, r10	; 0x8012de <pxCurrentTCB>
    21d6:	80 91 b5 12 	lds	r24, 0x12B5	; 0x8012b5 <uxCurrentNumberOfTasks>
    21da:	81 30       	cpi	r24, 0x01	; 1
    21dc:	89 f4       	brne	.+34     	; 0x2200 <__stack+0x1>
    21de:	48 df       	rcall	.-368    	; 0x2070 <prvInitialiseTaskLists>
    21e0:	0f c0       	rjmp	.+30     	; 0x2200 <__stack+0x1>
    21e2:	80 91 b0 12 	lds	r24, 0x12B0	; 0x8012b0 <xSchedulerRunning>
    21e6:	81 11       	cpse	r24, r1
    21e8:	0b c0       	rjmp	.+22     	; 0x2200 <__stack+0x1>
    21ea:	e0 91 de 12 	lds	r30, 0x12DE	; 0x8012de <pxCurrentTCB>
    21ee:	f0 91 df 12 	lds	r31, 0x12DF	; 0x8012df <pxCurrentTCB+0x1>
    21f2:	86 89       	ldd	r24, Z+22	; 0x16
    21f4:	78 16       	cp	r7, r24
    21f6:	20 f0       	brcs	.+8      	; 0x2200 <__stack+0x1>
    21f8:	b0 92 df 12 	sts	0x12DF, r11	; 0x8012df <pxCurrentTCB+0x1>
    21fc:	a0 92 de 12 	sts	0x12DE, r10	; 0x8012de <pxCurrentTCB>
    2200:	f5 01       	movw	r30, r10
    2202:	86 89       	ldd	r24, Z+22	; 0x16
    2204:	90 91 b2 12 	lds	r25, 0x12B2	; 0x8012b2 <uxTopUsedPriority>
    2208:	98 17       	cp	r25, r24
    220a:	10 f4       	brcc	.+4      	; 0x2210 <__stack+0x11>
    220c:	80 93 b2 12 	sts	0x12B2, r24	; 0x8012b2 <uxTopUsedPriority>
    2210:	90 91 ab 12 	lds	r25, 0x12AB	; 0x8012ab <uxTCBNumber>
    2214:	9f 5f       	subi	r25, 0xFF	; 255
    2216:	90 93 ab 12 	sts	0x12AB, r25	; 0x8012ab <uxTCBNumber>
    221a:	90 91 b1 12 	lds	r25, 0x12B1	; 0x8012b1 <uxTopReadyPriority>
    221e:	98 17       	cp	r25, r24
    2220:	10 f4       	brcc	.+4      	; 0x2226 <__stack+0x27>
    2222:	80 93 b1 12 	sts	0x12B1, r24	; 0x8012b1 <uxTopReadyPriority>
    2226:	90 e0       	ldi	r25, 0x00	; 0
    2228:	b5 01       	movw	r22, r10
    222a:	6e 5f       	subi	r22, 0xFE	; 254
    222c:	7f 4f       	sbci	r23, 0xFF	; 255
    222e:	9c 01       	movw	r18, r24
    2230:	22 0f       	add	r18, r18
    2232:	33 1f       	adc	r19, r19
    2234:	22 0f       	add	r18, r18
    2236:	33 1f       	adc	r19, r19
    2238:	22 0f       	add	r18, r18
    223a:	33 1f       	adc	r19, r19
    223c:	82 0f       	add	r24, r18
    223e:	93 1f       	adc	r25, r19
    2240:	8b 52       	subi	r24, 0x2B	; 43
    2242:	9d 4e       	sbci	r25, 0xED	; 237
    2244:	af dc       	rcall	.-1698   	; 0x1ba4 <vListInsertEnd>
    2246:	0f 90       	pop	r0
    2248:	0f be       	out	0x3f, r0	; 63
    224a:	f1 e0       	ldi	r31, 0x01	; 1
    224c:	f9 83       	std	Y+1, r31	; 0x01
    224e:	02 c0       	rjmp	.+4      	; 0x2254 <__stack+0x55>
    2250:	8f ef       	ldi	r24, 0xFF	; 255
    2252:	89 83       	std	Y+1, r24	; 0x01
    2254:	e9 81       	ldd	r30, Y+1	; 0x01
    2256:	e1 30       	cpi	r30, 0x01	; 1
    2258:	61 f4       	brne	.+24     	; 0x2272 <__stack+0x73>
    225a:	80 91 b0 12 	lds	r24, 0x12B0	; 0x8012b0 <xSchedulerRunning>
    225e:	88 23       	and	r24, r24
    2260:	41 f0       	breq	.+16     	; 0x2272 <__stack+0x73>
    2262:	e0 91 de 12 	lds	r30, 0x12DE	; 0x8012de <pxCurrentTCB>
    2266:	f0 91 df 12 	lds	r31, 0x12DF	; 0x8012df <pxCurrentTCB+0x1>
    226a:	86 89       	ldd	r24, Z+22	; 0x16
    226c:	87 15       	cp	r24, r7
    226e:	08 f4       	brcc	.+2      	; 0x2272 <__stack+0x73>
    2270:	c4 dd       	rcall	.-1144   	; 0x1dfa <vPortYield>
    2272:	89 81       	ldd	r24, Y+1	; 0x01
    2274:	0f 90       	pop	r0
    2276:	0f 90       	pop	r0
    2278:	0f 90       	pop	r0
    227a:	0f 90       	pop	r0
    227c:	df 91       	pop	r29
    227e:	cf 91       	pop	r28
    2280:	1f 91       	pop	r17
    2282:	0f 91       	pop	r16
    2284:	ff 90       	pop	r15
    2286:	ef 90       	pop	r14
    2288:	df 90       	pop	r13
    228a:	cf 90       	pop	r12
    228c:	bf 90       	pop	r11
    228e:	af 90       	pop	r10
    2290:	9f 90       	pop	r9
    2292:	8f 90       	pop	r8
    2294:	7f 90       	pop	r7
    2296:	5f 90       	pop	r5
    2298:	4f 90       	pop	r4
    229a:	3f 90       	pop	r3
    229c:	2f 90       	pop	r2
    229e:	08 95       	ret

000022a0 <vTaskStartScheduler>:
    22a0:	af 92       	push	r10
    22a2:	bf 92       	push	r11
    22a4:	cf 92       	push	r12
    22a6:	df 92       	push	r13
    22a8:	ef 92       	push	r14
    22aa:	ff 92       	push	r15
    22ac:	0f 93       	push	r16
    22ae:	a1 2c       	mov	r10, r1
    22b0:	b1 2c       	mov	r11, r1
    22b2:	c1 2c       	mov	r12, r1
    22b4:	d1 2c       	mov	r13, r1
    22b6:	e1 2c       	mov	r14, r1
    22b8:	f1 2c       	mov	r15, r1
    22ba:	00 e0       	ldi	r16, 0x00	; 0
    22bc:	20 e0       	ldi	r18, 0x00	; 0
    22be:	30 e0       	ldi	r19, 0x00	; 0
    22c0:	45 e5       	ldi	r20, 0x55	; 85
    22c2:	50 e0       	ldi	r21, 0x00	; 0
    22c4:	64 ef       	ldi	r22, 0xF4	; 244
    22c6:	72 e0       	ldi	r23, 0x02	; 2
    22c8:	85 ee       	ldi	r24, 0xE5	; 229
    22ca:	9f e0       	ldi	r25, 0x0F	; 15
    22cc:	31 df       	rcall	.-414    	; 0x2130 <xTaskGenericCreate>
    22ce:	81 30       	cpi	r24, 0x01	; 1
    22d0:	41 f4       	brne	.+16     	; 0x22e2 <vTaskStartScheduler+0x42>
    22d2:	f8 94       	cli
    22d4:	80 93 b0 12 	sts	0x12B0, r24	; 0x8012b0 <xSchedulerRunning>
    22d8:	10 92 b4 12 	sts	0x12B4, r1	; 0x8012b4 <xTickCount+0x1>
    22dc:	10 92 b3 12 	sts	0x12B3, r1	; 0x8012b3 <xTickCount>
    22e0:	5a dd       	rcall	.-1356   	; 0x1d96 <xPortStartScheduler>
    22e2:	0f 91       	pop	r16
    22e4:	ff 90       	pop	r15
    22e6:	ef 90       	pop	r14
    22e8:	df 90       	pop	r13
    22ea:	cf 90       	pop	r12
    22ec:	bf 90       	pop	r11
    22ee:	af 90       	pop	r10
    22f0:	08 95       	ret

000022f2 <vTaskSuspendAll>:
    22f2:	80 91 af 12 	lds	r24, 0x12AF	; 0x8012af <uxSchedulerSuspended>
    22f6:	8f 5f       	subi	r24, 0xFF	; 255
    22f8:	80 93 af 12 	sts	0x12AF, r24	; 0x8012af <uxSchedulerSuspended>
    22fc:	08 95       	ret

000022fe <vTaskIncrementTick>:
    22fe:	0f 93       	push	r16
    2300:	1f 93       	push	r17
    2302:	cf 93       	push	r28
    2304:	df 93       	push	r29
    2306:	80 91 af 12 	lds	r24, 0x12AF	; 0x8012af <uxSchedulerSuspended>
    230a:	81 11       	cpse	r24, r1
    230c:	95 c0       	rjmp	.+298    	; 0x2438 <vTaskIncrementTick+0x13a>
    230e:	80 91 b3 12 	lds	r24, 0x12B3	; 0x8012b3 <xTickCount>
    2312:	90 91 b4 12 	lds	r25, 0x12B4	; 0x8012b4 <xTickCount+0x1>
    2316:	01 96       	adiw	r24, 0x01	; 1
    2318:	90 93 b4 12 	sts	0x12B4, r25	; 0x8012b4 <xTickCount+0x1>
    231c:	80 93 b3 12 	sts	0x12B3, r24	; 0x8012b3 <xTickCount>
    2320:	80 91 b3 12 	lds	r24, 0x12B3	; 0x8012b3 <xTickCount>
    2324:	90 91 b4 12 	lds	r25, 0x12B4	; 0x8012b4 <xTickCount+0x1>
    2328:	89 2b       	or	r24, r25
    232a:	99 f5       	brne	.+102    	; 0x2392 <vTaskIncrementTick+0x94>
    232c:	80 91 c1 12 	lds	r24, 0x12C1	; 0x8012c1 <pxDelayedTaskList>
    2330:	90 91 c2 12 	lds	r25, 0x12C2	; 0x8012c2 <pxDelayedTaskList+0x1>
    2334:	20 91 bf 12 	lds	r18, 0x12BF	; 0x8012bf <pxOverflowDelayedTaskList>
    2338:	30 91 c0 12 	lds	r19, 0x12C0	; 0x8012c0 <pxOverflowDelayedTaskList+0x1>
    233c:	30 93 c2 12 	sts	0x12C2, r19	; 0x8012c2 <pxDelayedTaskList+0x1>
    2340:	20 93 c1 12 	sts	0x12C1, r18	; 0x8012c1 <pxDelayedTaskList>
    2344:	90 93 c0 12 	sts	0x12C0, r25	; 0x8012c0 <pxOverflowDelayedTaskList+0x1>
    2348:	80 93 bf 12 	sts	0x12BF, r24	; 0x8012bf <pxOverflowDelayedTaskList>
    234c:	80 91 ac 12 	lds	r24, 0x12AC	; 0x8012ac <xNumOfOverflows>
    2350:	8f 5f       	subi	r24, 0xFF	; 255
    2352:	80 93 ac 12 	sts	0x12AC, r24	; 0x8012ac <xNumOfOverflows>
    2356:	e0 91 c1 12 	lds	r30, 0x12C1	; 0x8012c1 <pxDelayedTaskList>
    235a:	f0 91 c2 12 	lds	r31, 0x12C2	; 0x8012c2 <pxDelayedTaskList+0x1>
    235e:	80 81       	ld	r24, Z
    2360:	81 11       	cpse	r24, r1
    2362:	07 c0       	rjmp	.+14     	; 0x2372 <vTaskIncrementTick+0x74>
    2364:	8f ef       	ldi	r24, 0xFF	; 255
    2366:	9f ef       	ldi	r25, 0xFF	; 255
    2368:	90 93 0c 02 	sts	0x020C, r25	; 0x80020c <xNextTaskUnblockTime+0x1>
    236c:	80 93 0b 02 	sts	0x020B, r24	; 0x80020b <xNextTaskUnblockTime>
    2370:	10 c0       	rjmp	.+32     	; 0x2392 <vTaskIncrementTick+0x94>
    2372:	e0 91 c1 12 	lds	r30, 0x12C1	; 0x8012c1 <pxDelayedTaskList>
    2376:	f0 91 c2 12 	lds	r31, 0x12C2	; 0x8012c2 <pxDelayedTaskList+0x1>
    237a:	05 80       	ldd	r0, Z+5	; 0x05
    237c:	f6 81       	ldd	r31, Z+6	; 0x06
    237e:	e0 2d       	mov	r30, r0
    2380:	06 80       	ldd	r0, Z+6	; 0x06
    2382:	f7 81       	ldd	r31, Z+7	; 0x07
    2384:	e0 2d       	mov	r30, r0
    2386:	82 81       	ldd	r24, Z+2	; 0x02
    2388:	93 81       	ldd	r25, Z+3	; 0x03
    238a:	90 93 0c 02 	sts	0x020C, r25	; 0x80020c <xNextTaskUnblockTime+0x1>
    238e:	80 93 0b 02 	sts	0x020B, r24	; 0x80020b <xNextTaskUnblockTime>
    2392:	20 91 b3 12 	lds	r18, 0x12B3	; 0x8012b3 <xTickCount>
    2396:	30 91 b4 12 	lds	r19, 0x12B4	; 0x8012b4 <xTickCount+0x1>
    239a:	80 91 0b 02 	lds	r24, 0x020B	; 0x80020b <xNextTaskUnblockTime>
    239e:	90 91 0c 02 	lds	r25, 0x020C	; 0x80020c <xNextTaskUnblockTime+0x1>
    23a2:	28 17       	cp	r18, r24
    23a4:	39 07       	cpc	r19, r25
    23a6:	08 f4       	brcc	.+2      	; 0x23aa <vTaskIncrementTick+0xac>
    23a8:	4c c0       	rjmp	.+152    	; 0x2442 <vTaskIncrementTick+0x144>
    23aa:	e0 91 c1 12 	lds	r30, 0x12C1	; 0x8012c1 <pxDelayedTaskList>
    23ae:	f0 91 c2 12 	lds	r31, 0x12C2	; 0x8012c2 <pxDelayedTaskList+0x1>
    23b2:	80 81       	ld	r24, Z
    23b4:	81 11       	cpse	r24, r1
    23b6:	07 c0       	rjmp	.+14     	; 0x23c6 <vTaskIncrementTick+0xc8>
    23b8:	8f ef       	ldi	r24, 0xFF	; 255
    23ba:	9f ef       	ldi	r25, 0xFF	; 255
    23bc:	90 93 0c 02 	sts	0x020C, r25	; 0x80020c <xNextTaskUnblockTime+0x1>
    23c0:	80 93 0b 02 	sts	0x020B, r24	; 0x80020b <xNextTaskUnblockTime>
    23c4:	3e c0       	rjmp	.+124    	; 0x2442 <vTaskIncrementTick+0x144>
    23c6:	e0 91 c1 12 	lds	r30, 0x12C1	; 0x8012c1 <pxDelayedTaskList>
    23ca:	f0 91 c2 12 	lds	r31, 0x12C2	; 0x8012c2 <pxDelayedTaskList+0x1>
    23ce:	05 80       	ldd	r0, Z+5	; 0x05
    23d0:	f6 81       	ldd	r31, Z+6	; 0x06
    23d2:	e0 2d       	mov	r30, r0
    23d4:	c6 81       	ldd	r28, Z+6	; 0x06
    23d6:	d7 81       	ldd	r29, Z+7	; 0x07
    23d8:	8a 81       	ldd	r24, Y+2	; 0x02
    23da:	9b 81       	ldd	r25, Y+3	; 0x03
    23dc:	20 91 b3 12 	lds	r18, 0x12B3	; 0x8012b3 <xTickCount>
    23e0:	30 91 b4 12 	lds	r19, 0x12B4	; 0x8012b4 <xTickCount+0x1>
    23e4:	28 17       	cp	r18, r24
    23e6:	39 07       	cpc	r19, r25
    23e8:	28 f4       	brcc	.+10     	; 0x23f4 <vTaskIncrementTick+0xf6>
    23ea:	90 93 0c 02 	sts	0x020C, r25	; 0x80020c <xNextTaskUnblockTime+0x1>
    23ee:	80 93 0b 02 	sts	0x020B, r24	; 0x80020b <xNextTaskUnblockTime>
    23f2:	27 c0       	rjmp	.+78     	; 0x2442 <vTaskIncrementTick+0x144>
    23f4:	8e 01       	movw	r16, r28
    23f6:	0e 5f       	subi	r16, 0xFE	; 254
    23f8:	1f 4f       	sbci	r17, 0xFF	; 255
    23fa:	c8 01       	movw	r24, r16
    23fc:	2b dc       	rcall	.-1962   	; 0x1c54 <vListRemove>
    23fe:	8c 89       	ldd	r24, Y+20	; 0x14
    2400:	9d 89       	ldd	r25, Y+21	; 0x15
    2402:	89 2b       	or	r24, r25
    2404:	19 f0       	breq	.+6      	; 0x240c <vTaskIncrementTick+0x10e>
    2406:	ce 01       	movw	r24, r28
    2408:	0c 96       	adiw	r24, 0x0c	; 12
    240a:	24 dc       	rcall	.-1976   	; 0x1c54 <vListRemove>
    240c:	8e 89       	ldd	r24, Y+22	; 0x16
    240e:	90 91 b1 12 	lds	r25, 0x12B1	; 0x8012b1 <uxTopReadyPriority>
    2412:	98 17       	cp	r25, r24
    2414:	10 f4       	brcc	.+4      	; 0x241a <vTaskIncrementTick+0x11c>
    2416:	80 93 b1 12 	sts	0x12B1, r24	; 0x8012b1 <uxTopReadyPriority>
    241a:	90 e0       	ldi	r25, 0x00	; 0
    241c:	9c 01       	movw	r18, r24
    241e:	22 0f       	add	r18, r18
    2420:	33 1f       	adc	r19, r19
    2422:	22 0f       	add	r18, r18
    2424:	33 1f       	adc	r19, r19
    2426:	22 0f       	add	r18, r18
    2428:	33 1f       	adc	r19, r19
    242a:	82 0f       	add	r24, r18
    242c:	93 1f       	adc	r25, r19
    242e:	b8 01       	movw	r22, r16
    2430:	8b 52       	subi	r24, 0x2B	; 43
    2432:	9d 4e       	sbci	r25, 0xED	; 237
    2434:	b7 db       	rcall	.-2194   	; 0x1ba4 <vListInsertEnd>
    2436:	b9 cf       	rjmp	.-142    	; 0x23aa <vTaskIncrementTick+0xac>
    2438:	80 91 ae 12 	lds	r24, 0x12AE	; 0x8012ae <uxMissedTicks>
    243c:	8f 5f       	subi	r24, 0xFF	; 255
    243e:	80 93 ae 12 	sts	0x12AE, r24	; 0x8012ae <uxMissedTicks>
    2442:	df 91       	pop	r29
    2444:	cf 91       	pop	r28
    2446:	1f 91       	pop	r17
    2448:	0f 91       	pop	r16
    244a:	08 95       	ret

0000244c <xTaskResumeAll>:
    244c:	ff 92       	push	r15
    244e:	0f 93       	push	r16
    2450:	1f 93       	push	r17
    2452:	cf 93       	push	r28
    2454:	df 93       	push	r29
    2456:	0f b6       	in	r0, 0x3f	; 63
    2458:	f8 94       	cli
    245a:	0f 92       	push	r0
    245c:	80 91 af 12 	lds	r24, 0x12AF	; 0x8012af <uxSchedulerSuspended>
    2460:	81 50       	subi	r24, 0x01	; 1
    2462:	80 93 af 12 	sts	0x12AF, r24	; 0x8012af <uxSchedulerSuspended>
    2466:	80 91 af 12 	lds	r24, 0x12AF	; 0x8012af <uxSchedulerSuspended>
    246a:	81 11       	cpse	r24, r1
    246c:	55 c0       	rjmp	.+170    	; 0x2518 <xTaskResumeAll+0xcc>
    246e:	80 91 b5 12 	lds	r24, 0x12B5	; 0x8012b5 <uxCurrentNumberOfTasks>
    2472:	81 11       	cpse	r24, r1
    2474:	2f c0       	rjmp	.+94     	; 0x24d4 <xTaskResumeAll+0x88>
    2476:	53 c0       	rjmp	.+166    	; 0x251e <xTaskResumeAll+0xd2>
    2478:	e0 91 bb 12 	lds	r30, 0x12BB	; 0x8012bb <xPendingReadyList+0x5>
    247c:	f0 91 bc 12 	lds	r31, 0x12BC	; 0x8012bc <xPendingReadyList+0x6>
    2480:	c6 81       	ldd	r28, Z+6	; 0x06
    2482:	d7 81       	ldd	r29, Z+7	; 0x07
    2484:	ce 01       	movw	r24, r28
    2486:	0c 96       	adiw	r24, 0x0c	; 12
    2488:	e5 db       	rcall	.-2102   	; 0x1c54 <vListRemove>
    248a:	8e 01       	movw	r16, r28
    248c:	0e 5f       	subi	r16, 0xFE	; 254
    248e:	1f 4f       	sbci	r17, 0xFF	; 255
    2490:	c8 01       	movw	r24, r16
    2492:	e0 db       	rcall	.-2112   	; 0x1c54 <vListRemove>
    2494:	8e 89       	ldd	r24, Y+22	; 0x16
    2496:	90 91 b1 12 	lds	r25, 0x12B1	; 0x8012b1 <uxTopReadyPriority>
    249a:	98 17       	cp	r25, r24
    249c:	10 f4       	brcc	.+4      	; 0x24a2 <xTaskResumeAll+0x56>
    249e:	80 93 b1 12 	sts	0x12B1, r24	; 0x8012b1 <uxTopReadyPriority>
    24a2:	90 e0       	ldi	r25, 0x00	; 0
    24a4:	9c 01       	movw	r18, r24
    24a6:	22 0f       	add	r18, r18
    24a8:	33 1f       	adc	r19, r19
    24aa:	22 0f       	add	r18, r18
    24ac:	33 1f       	adc	r19, r19
    24ae:	22 0f       	add	r18, r18
    24b0:	33 1f       	adc	r19, r19
    24b2:	82 0f       	add	r24, r18
    24b4:	93 1f       	adc	r25, r19
    24b6:	b8 01       	movw	r22, r16
    24b8:	8b 52       	subi	r24, 0x2B	; 43
    24ba:	9d 4e       	sbci	r25, 0xED	; 237
    24bc:	73 db       	rcall	.-2330   	; 0x1ba4 <vListInsertEnd>
    24be:	9e 89       	ldd	r25, Y+22	; 0x16
    24c0:	e0 91 de 12 	lds	r30, 0x12DE	; 0x8012de <pxCurrentTCB>
    24c4:	f0 91 df 12 	lds	r31, 0x12DF	; 0x8012df <pxCurrentTCB+0x1>
    24c8:	86 89       	ldd	r24, Z+22	; 0x16
    24ca:	98 17       	cp	r25, r24
    24cc:	20 f0       	brcs	.+8      	; 0x24d6 <xTaskResumeAll+0x8a>
    24ce:	ff 24       	eor	r15, r15
    24d0:	f3 94       	inc	r15
    24d2:	01 c0       	rjmp	.+2      	; 0x24d6 <xTaskResumeAll+0x8a>
    24d4:	f1 2c       	mov	r15, r1
    24d6:	80 91 b6 12 	lds	r24, 0x12B6	; 0x8012b6 <xPendingReadyList>
    24da:	81 11       	cpse	r24, r1
    24dc:	cd cf       	rjmp	.-102    	; 0x2478 <xTaskResumeAll+0x2c>
    24de:	80 91 ae 12 	lds	r24, 0x12AE	; 0x8012ae <uxMissedTicks>
    24e2:	81 11       	cpse	r24, r1
    24e4:	07 c0       	rjmp	.+14     	; 0x24f4 <xTaskResumeAll+0xa8>
    24e6:	0c c0       	rjmp	.+24     	; 0x2500 <xTaskResumeAll+0xb4>
    24e8:	0a df       	rcall	.-492    	; 0x22fe <vTaskIncrementTick>
    24ea:	80 91 ae 12 	lds	r24, 0x12AE	; 0x8012ae <uxMissedTicks>
    24ee:	81 50       	subi	r24, 0x01	; 1
    24f0:	80 93 ae 12 	sts	0x12AE, r24	; 0x8012ae <uxMissedTicks>
    24f4:	80 91 ae 12 	lds	r24, 0x12AE	; 0x8012ae <uxMissedTicks>
    24f8:	81 11       	cpse	r24, r1
    24fa:	f6 cf       	rjmp	.-20     	; 0x24e8 <xTaskResumeAll+0x9c>
    24fc:	ff 24       	eor	r15, r15
    24fe:	f3 94       	inc	r15
    2500:	81 e0       	ldi	r24, 0x01	; 1
    2502:	f8 16       	cp	r15, r24
    2504:	21 f0       	breq	.+8      	; 0x250e <xTaskResumeAll+0xc2>
    2506:	80 91 ad 12 	lds	r24, 0x12AD	; 0x8012ad <xMissedYield>
    250a:	81 30       	cpi	r24, 0x01	; 1
    250c:	39 f4       	brne	.+14     	; 0x251c <xTaskResumeAll+0xd0>
    250e:	10 92 ad 12 	sts	0x12AD, r1	; 0x8012ad <xMissedYield>
    2512:	73 dc       	rcall	.-1818   	; 0x1dfa <vPortYield>
    2514:	81 e0       	ldi	r24, 0x01	; 1
    2516:	03 c0       	rjmp	.+6      	; 0x251e <xTaskResumeAll+0xd2>
    2518:	80 e0       	ldi	r24, 0x00	; 0
    251a:	01 c0       	rjmp	.+2      	; 0x251e <xTaskResumeAll+0xd2>
    251c:	80 e0       	ldi	r24, 0x00	; 0
    251e:	0f 90       	pop	r0
    2520:	0f be       	out	0x3f, r0	; 63
    2522:	df 91       	pop	r29
    2524:	cf 91       	pop	r28
    2526:	1f 91       	pop	r17
    2528:	0f 91       	pop	r16
    252a:	ff 90       	pop	r15
    252c:	08 95       	ret

0000252e <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    252e:	cf 93       	push	r28
    2530:	df 93       	push	r29
    2532:	ec 01       	movw	r28, r24
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    2534:	89 2b       	or	r24, r25
    2536:	89 f0       	breq	.+34     	; 0x255a <vTaskDelay+0x2c>
		{
			vTaskSuspendAll();
    2538:	dc de       	rcall	.-584    	; 0x22f2 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    253a:	80 91 b3 12 	lds	r24, 0x12B3	; 0x8012b3 <xTickCount>
    253e:	90 91 b4 12 	lds	r25, 0x12B4	; 0x8012b4 <xTickCount+0x1>
    2542:	c8 0f       	add	r28, r24
    2544:	d9 1f       	adc	r29, r25

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2546:	80 91 de 12 	lds	r24, 0x12DE	; 0x8012de <pxCurrentTCB>
    254a:	90 91 df 12 	lds	r25, 0x12DF	; 0x8012df <pxCurrentTCB+0x1>
    254e:	02 96       	adiw	r24, 0x02	; 2
    2550:	81 db       	rcall	.-2302   	; 0x1c54 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    2552:	ce 01       	movw	r24, r28
    2554:	b8 dd       	rcall	.-1168   	; 0x20c6 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    2556:	7a df       	rcall	.-268    	; 0x244c <xTaskResumeAll>
    2558:	01 c0       	rjmp	.+2      	; 0x255c <vTaskDelay+0x2e>
#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    255a:	80 e0       	ldi	r24, 0x00	; 0
			xAlreadyYielded = xTaskResumeAll();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    255c:	81 11       	cpse	r24, r1
    255e:	01 c0       	rjmp	.+2      	; 0x2562 <vTaskDelay+0x34>
		{
			portYIELD_WITHIN_API();
    2560:	4c dc       	rcall	.-1896   	; 0x1dfa <vPortYield>
    2562:	df 91       	pop	r29
		}
	}
    2564:	cf 91       	pop	r28
    2566:	08 95       	ret

00002568 <vTaskSwitchContext>:
    2568:	80 91 af 12 	lds	r24, 0x12AF	; 0x8012af <uxSchedulerSuspended>
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    256c:	88 23       	and	r24, r24
    256e:	49 f0       	breq	.+18     	; 0x2582 <vTaskSwitchContext+0x1a>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    2570:	81 e0       	ldi	r24, 0x01	; 1
    2572:	80 93 ad 12 	sts	0x12AD, r24	; 0x8012ad <xMissedYield>
    2576:	08 95       	ret
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    2578:	80 91 b1 12 	lds	r24, 0x12B1	; 0x8012b1 <uxTopReadyPriority>
    257c:	81 50       	subi	r24, 0x01	; 1
    257e:	80 93 b1 12 	sts	0x12B1, r24	; 0x8012b1 <uxTopReadyPriority>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    2582:	80 91 b1 12 	lds	r24, 0x12B1	; 0x8012b1 <uxTopReadyPriority>
    2586:	90 e0       	ldi	r25, 0x00	; 0
    2588:	fc 01       	movw	r30, r24
    258a:	ee 0f       	add	r30, r30
    258c:	ff 1f       	adc	r31, r31
    258e:	ee 0f       	add	r30, r30
    2590:	ff 1f       	adc	r31, r31
    2592:	ee 0f       	add	r30, r30
    2594:	ff 1f       	adc	r31, r31
    2596:	8e 0f       	add	r24, r30
    2598:	9f 1f       	adc	r25, r31
    259a:	fc 01       	movw	r30, r24
    259c:	eb 52       	subi	r30, 0x2B	; 43
    259e:	fd 4e       	sbci	r31, 0xED	; 237
    25a0:	80 81       	ld	r24, Z
    25a2:	88 23       	and	r24, r24
    25a4:	49 f3       	breq	.-46     	; 0x2578 <vTaskSwitchContext+0x10>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    25a6:	80 91 b1 12 	lds	r24, 0x12B1	; 0x8012b1 <uxTopReadyPriority>
    25aa:	90 e0       	ldi	r25, 0x00	; 0
    25ac:	9c 01       	movw	r18, r24
    25ae:	22 0f       	add	r18, r18
    25b0:	33 1f       	adc	r19, r19
    25b2:	22 0f       	add	r18, r18
    25b4:	33 1f       	adc	r19, r19
    25b6:	22 0f       	add	r18, r18
    25b8:	33 1f       	adc	r19, r19
    25ba:	28 0f       	add	r18, r24
    25bc:	39 1f       	adc	r19, r25
    25be:	d9 01       	movw	r26, r18
    25c0:	ab 52       	subi	r26, 0x2B	; 43
    25c2:	bd 4e       	sbci	r27, 0xED	; 237
    25c4:	11 96       	adiw	r26, 0x01	; 1
    25c6:	ed 91       	ld	r30, X+
    25c8:	fc 91       	ld	r31, X
    25ca:	12 97       	sbiw	r26, 0x02	; 2
    25cc:	02 80       	ldd	r0, Z+2	; 0x02
    25ce:	f3 81       	ldd	r31, Z+3	; 0x03
    25d0:	e0 2d       	mov	r30, r0
    25d2:	12 96       	adiw	r26, 0x02	; 2
    25d4:	fc 93       	st	X, r31
    25d6:	ee 93       	st	-X, r30
    25d8:	11 97       	sbiw	r26, 0x01	; 1
    25da:	28 52       	subi	r18, 0x28	; 40
    25dc:	3d 4e       	sbci	r19, 0xED	; 237
    25de:	e2 17       	cp	r30, r18
    25e0:	f3 07       	cpc	r31, r19
    25e2:	29 f4       	brne	.+10     	; 0x25ee <vTaskSwitchContext+0x86>
    25e4:	22 81       	ldd	r18, Z+2	; 0x02
    25e6:	33 81       	ldd	r19, Z+3	; 0x03
    25e8:	fd 01       	movw	r30, r26
    25ea:	32 83       	std	Z+2, r19	; 0x02
    25ec:	21 83       	std	Z+1, r18	; 0x01
    25ee:	fc 01       	movw	r30, r24
    25f0:	ee 0f       	add	r30, r30
    25f2:	ff 1f       	adc	r31, r31
    25f4:	ee 0f       	add	r30, r30
    25f6:	ff 1f       	adc	r31, r31
    25f8:	ee 0f       	add	r30, r30
    25fa:	ff 1f       	adc	r31, r31
    25fc:	8e 0f       	add	r24, r30
    25fe:	9f 1f       	adc	r25, r31
    2600:	fc 01       	movw	r30, r24
    2602:	eb 52       	subi	r30, 0x2B	; 43
    2604:	fd 4e       	sbci	r31, 0xED	; 237
    2606:	01 80       	ldd	r0, Z+1	; 0x01
    2608:	f2 81       	ldd	r31, Z+2	; 0x02
    260a:	e0 2d       	mov	r30, r0
    260c:	86 81       	ldd	r24, Z+6	; 0x06
    260e:	97 81       	ldd	r25, Z+7	; 0x07
    2610:	90 93 df 12 	sts	0x12DF, r25	; 0x8012df <pxCurrentTCB+0x1>
    2614:	80 93 de 12 	sts	0x12DE, r24	; 0x8012de <pxCurrentTCB>
    2618:	08 95       	ret

0000261a <_Z11DisplayInitv>:
	_NOP();
	WR_PORT |= (1 << WR_BIT);
	_NOP();
	
	// Set chip select to low
	CS_PORT_Dispay |= (1 << CS_BIT);
    261a:	83 b3       	in	r24, 0x13	; 19
    261c:	87 60       	ori	r24, 0x07	; 7
    261e:	83 bb       	out	0x13, r24	; 19
    2620:	57 9a       	sbi	0x0a, 7	; 10
    2622:	8f ef       	ldi	r24, 0xFF	; 255
    2624:	81 b9       	out	0x01, r24	; 1
    2626:	87 b9       	out	0x07, r24	; 7
    2628:	84 b3       	in	r24, 0x14	; 20
    262a:	87 60       	ori	r24, 0x07	; 7
    262c:	84 bb       	out	0x14, r24	; 20
    262e:	5f 9a       	sbi	0x0b, 7	; 11
    2630:	a0 98       	cbi	0x14, 0	; 20
    2632:	2f ef       	ldi	r18, 0xFF	; 255
    2634:	89 e6       	ldi	r24, 0x69	; 105
    2636:	98 e1       	ldi	r25, 0x18	; 24
    2638:	21 50       	subi	r18, 0x01	; 1
    263a:	80 40       	sbci	r24, 0x00	; 0
    263c:	90 40       	sbci	r25, 0x00	; 0
    263e:	e1 f7       	brne	.-8      	; 0x2638 <_Z11DisplayInitv+0x1e>
    2640:	00 c0       	rjmp	.+0      	; 0x2642 <_Z11DisplayInitv+0x28>
    2642:	00 00       	nop
    2644:	a0 9a       	sbi	0x14, 0	; 20
    2646:	2f ef       	ldi	r18, 0xFF	; 255
    2648:	89 e6       	ldi	r24, 0x69	; 105
    264a:	98 e1       	ldi	r25, 0x18	; 24
    264c:	21 50       	subi	r18, 0x01	; 1
    264e:	80 40       	sbci	r24, 0x00	; 0
    2650:	90 40       	sbci	r25, 0x00	; 0
    2652:	e1 f7       	brne	.-8      	; 0x264c <_Z11DisplayInitv+0x32>
    2654:	00 c0       	rjmp	.+0      	; 0x2656 <_Z11DisplayInitv+0x3c>
    2656:	00 00       	nop
    2658:	5f 98       	cbi	0x0b, 7	; 11
    265a:	a1 98       	cbi	0x14, 1	; 20
    265c:	00 00       	nop
    265e:	12 b8       	out	0x02, r1	; 2
    2660:	8a e3       	ldi	r24, 0x3A	; 58
    2662:	88 b9       	out	0x08, r24	; 8
    2664:	a2 98       	cbi	0x14, 2	; 20
    2666:	00 00       	nop
    2668:	a2 9a       	sbi	0x14, 2	; 20
    266a:	00 00       	nop
    266c:	a1 9a       	sbi	0x14, 1	; 20
    266e:	5f 9a       	sbi	0x0b, 7	; 11
    2670:	a1 98       	cbi	0x14, 1	; 20
    2672:	00 00       	nop
    2674:	12 b8       	out	0x02, r1	; 2
    2676:	85 e0       	ldi	r24, 0x05	; 5
    2678:	88 b9       	out	0x08, r24	; 8
    267a:	a2 98       	cbi	0x14, 2	; 20
    267c:	00 00       	nop
    267e:	a2 9a       	sbi	0x14, 2	; 20
    2680:	00 00       	nop
    2682:	a1 9a       	sbi	0x14, 1	; 20
    2684:	5f 98       	cbi	0x0b, 7	; 11
    2686:	a1 98       	cbi	0x14, 1	; 20
    2688:	00 00       	nop
    268a:	12 b8       	out	0x02, r1	; 2
    268c:	86 e3       	ldi	r24, 0x36	; 54
    268e:	88 b9       	out	0x08, r24	; 8
    2690:	a2 98       	cbi	0x14, 2	; 20
    2692:	00 00       	nop
    2694:	a2 9a       	sbi	0x14, 2	; 20
    2696:	00 00       	nop
    2698:	a1 9a       	sbi	0x14, 1	; 20
    269a:	5f 9a       	sbi	0x0b, 7	; 11
    269c:	a1 98       	cbi	0x14, 1	; 20
    269e:	00 00       	nop
    26a0:	12 b8       	out	0x02, r1	; 2
    26a2:	88 e0       	ldi	r24, 0x08	; 8
    26a4:	88 b9       	out	0x08, r24	; 8
    26a6:	a2 98       	cbi	0x14, 2	; 20
    26a8:	00 00       	nop
    26aa:	a2 9a       	sbi	0x14, 2	; 20
    26ac:	00 00       	nop
    26ae:	a1 9a       	sbi	0x14, 1	; 20
    26b0:	5f 98       	cbi	0x0b, 7	; 11
    26b2:	a1 98       	cbi	0x14, 1	; 20
    26b4:	00 00       	nop
    26b6:	12 b8       	out	0x02, r1	; 2
    26b8:	81 e1       	ldi	r24, 0x11	; 17
    26ba:	88 b9       	out	0x08, r24	; 8
    26bc:	a2 98       	cbi	0x14, 2	; 20
    26be:	00 00       	nop
    26c0:	a2 9a       	sbi	0x14, 2	; 20
    26c2:	00 00       	nop
    26c4:	a1 9a       	sbi	0x14, 1	; 20
    26c6:	5f 98       	cbi	0x0b, 7	; 11
    26c8:	a1 98       	cbi	0x14, 1	; 20
    26ca:	00 00       	nop
    26cc:	12 b8       	out	0x02, r1	; 2
    26ce:	89 e2       	ldi	r24, 0x29	; 41
    26d0:	88 b9       	out	0x08, r24	; 8
    26d2:	a2 98       	cbi	0x14, 2	; 20
    26d4:	00 00       	nop
    26d6:	a2 9a       	sbi	0x14, 2	; 20
    26d8:	00 00       	nop
    26da:	a1 9a       	sbi	0x14, 1	; 20
    26dc:	08 95       	ret

000026de <_Z13FillRectanglejjjjhhh>:
// Fills rectangle with specified color
// (StartX,StartY) = Upper left corner. X horizontal (0-319) , Y vertical (0-239).
// Height (1-240) is vertical. Width (1-320) is horizontal.
// R-G-B = 5-6-5 bits.
void FillRectangle(unsigned int StartX, unsigned int StartY, unsigned int Width, unsigned int Height, unsigned char Blue, unsigned char Green, unsigned char Red)
{
    26de:	cf 92       	push	r12
    26e0:	df 92       	push	r13
    26e2:	ef 92       	push	r14
    26e4:	0f 93       	push	r16
	SetPageAddress(StartX,StartX+Width-1);
    26e6:	fa 01       	movw	r30, r20
    26e8:	31 97       	sbiw	r30, 0x01	; 1
    26ea:	e8 0f       	add	r30, r24
    26ec:	f9 1f       	adc	r31, r25
}

// Set Page Address (0-319), Start > End
void SetPageAddress(unsigned int Start, unsigned int End)
{
	if (Start < End)
    26ee:	8e 17       	cp	r24, r30
    26f0:	9f 07       	cpc	r25, r31
    26f2:	08 f4       	brcc	.+2      	; 0x26f6 <_Z13FillRectanglejjjjhhh+0x18>
    26f4:	51 c0       	rjmp	.+162    	; 0x2798 <_Z13FillRectanglejjjjhhh+0xba>
// Height (1-240) is vertical. Width (1-320) is horizontal.
// R-G-B = 5-6-5 bits.
void FillRectangle(unsigned int StartX, unsigned int StartY, unsigned int Width, unsigned int Height, unsigned char Blue, unsigned char Green, unsigned char Red)
{
	SetPageAddress(StartX,StartX+Width-1);
	SetColumnAddress(StartY,StartY+Height-1);
    26f6:	c9 01       	movw	r24, r18
    26f8:	01 97       	sbiw	r24, 0x01	; 1
    26fa:	86 0f       	add	r24, r22
    26fc:	97 1f       	adc	r25, r23
}

// Set Column Address (0-239), Start > End
void SetColumnAddress(unsigned int Start, unsigned int End)
{
	if (Start < End)
    26fe:	68 17       	cp	r22, r24
    2700:	79 07       	cpc	r23, r25
    2702:	08 f4       	brcc	.+2      	; 0x2706 <_Z13FillRectanglejjjjhhh+0x28>
    2704:	84 c0       	rjmp	.+264    	; 0x280e <_Z13FillRectanglejjjjhhh+0x130>

// ILI 9341 data sheet, page 238
void WriteCommand(unsigned int command)
{
	// Set DC port to command
	DC_PORT &= ~(1 << DC_BIT);
    2706:	5f 98       	cbi	0x0b, 7	; 11
	
	// Set chip select to high - Then wait min 15 ns for chip select setup.
	CS_PORT_Dispay &= ~(1 << CS_BIT);	
    2708:	a1 98       	cbi	0x14, 1	; 20
	_NOP();
    270a:	00 00       	nop
	
	// Set databus
	DATA_PORT_HIGH = command >> 8U;
    270c:	12 b8       	out	0x02, r1	; 2
	DATA_PORT_LOW = command;
    270e:	8c e2       	ldi	r24, 0x2C	; 44
    2710:	88 b9       	out	0x08, r24	; 8
	
	//Set WR port to 0 to start transmission - wait 15 nano sec - Set WR port to 1 to end transmission. 
	WR_PORT &= ~(1 << WR_BIT);
    2712:	a2 98       	cbi	0x14, 2	; 20
	_NOP();
    2714:	00 00       	nop
	WR_PORT |= (1 << WR_BIT);
    2716:	a2 9a       	sbi	0x14, 2	; 20
	_NOP();
    2718:	00 00       	nop
	
	// Set chip select to low
	CS_PORT_Dispay |= (1 << CS_BIT);
    271a:	a1 9a       	sbi	0x14, 1	; 20
{
	SetPageAddress(StartX,StartX+Width-1);
	SetColumnAddress(StartY,StartY+Height-1);
	MemoryWrite();
	
	for (uint32_t counter = 0; counter < (uint32_t)Width*Height; counter++)
    271c:	da 01       	movw	r26, r20
    271e:	0e 94 fe 1d 	call	0x3bfc	; 0x3bfc <__umulhisi3>
    2722:	ab 01       	movw	r20, r22
    2724:	bc 01       	movw	r22, r24
    2726:	41 15       	cp	r20, r1
    2728:	51 05       	cpc	r21, r1
    272a:	61 05       	cpc	r22, r1
    272c:	71 05       	cpc	r23, r1
    272e:	21 f1       	breq	.+72     	; 0x2778 <_Z13FillRectanglejjjjhhh+0x9a>
    2730:	20 e2       	ldi	r18, 0x20	; 32
    2732:	e2 9e       	mul	r14, r18
    2734:	c0 01       	movw	r24, r0
    2736:	11 24       	eor	r1, r1
    2738:	80 2b       	or	r24, r16
    273a:	d1 2c       	mov	r13, r1
    273c:	dc 2c       	mov	r13, r12
    273e:	cc 24       	eor	r12, r12
    2740:	dd 0c       	add	r13, r13
    2742:	dd 0c       	add	r13, r13
    2744:	dd 0c       	add	r13, r13
    2746:	8c 29       	or	r24, r12
    2748:	9d 29       	or	r25, r13
    274a:	29 2f       	mov	r18, r25
    274c:	c8 2e       	mov	r12, r24
    274e:	80 e0       	ldi	r24, 0x00	; 0
    2750:	90 e0       	ldi	r25, 0x00	; 0
    2752:	dc 01       	movw	r26, r24

// ILI 9341 data sheet, page 238
void WriteData(unsigned int data)
{
	// Set DC port to data
	DC_PORT |= (1 << DC_BIT);
    2754:	5f 9a       	sbi	0x0b, 7	; 11
	
	// Set chip select to high - Then wait min 15 ns for chip select setup. 
	CS_PORT_Dispay &= ~(1 << CS_BIT);
    2756:	a1 98       	cbi	0x14, 1	; 20
	_NOP();
    2758:	00 00       	nop
		
	// Set databus
	DATA_PORT_HIGH = data >> 8U;
    275a:	22 b9       	out	0x02, r18	; 2
	DATA_PORT_LOW = data;
    275c:	c8 b8       	out	0x08, r12	; 8
	
	//Set WR port to 0 to start transmission - wait 15 nano sec - Set WR port to 1 to end transmission.
	WR_PORT &= ~(1 << WR_BIT);
    275e:	a2 98       	cbi	0x14, 2	; 20
	_NOP();
    2760:	00 00       	nop
	WR_PORT |= (1 << WR_BIT);
    2762:	a2 9a       	sbi	0x14, 2	; 20
	_NOP();
    2764:	00 00       	nop
	
	// Set chip select to low
	CS_PORT_Dispay |= (1 << CS_BIT);
    2766:	a1 9a       	sbi	0x14, 1	; 20
{
	SetPageAddress(StartX,StartX+Width-1);
	SetColumnAddress(StartY,StartY+Height-1);
	MemoryWrite();
	
	for (uint32_t counter = 0; counter < (uint32_t)Width*Height; counter++)
    2768:	01 96       	adiw	r24, 0x01	; 1
    276a:	a1 1d       	adc	r26, r1
    276c:	b1 1d       	adc	r27, r1
    276e:	84 17       	cp	r24, r20
    2770:	95 07       	cpc	r25, r21
    2772:	a6 07       	cpc	r26, r22
    2774:	b7 07       	cpc	r27, r23
    2776:	71 f7       	brne	.-36     	; 0x2754 <_Z13FillRectanglejjjjhhh+0x76>

// ILI 9341 data sheet, page 238
void WriteCommand(unsigned int command)
{
	// Set DC port to command
	DC_PORT &= ~(1 << DC_BIT);
    2778:	5f 98       	cbi	0x0b, 7	; 11
	
	// Set chip select to high - Then wait min 15 ns for chip select setup.
	CS_PORT_Dispay &= ~(1 << CS_BIT);	
    277a:	a1 98       	cbi	0x14, 1	; 20
	_NOP();
    277c:	00 00       	nop
	
	// Set databus
	DATA_PORT_HIGH = command >> 8U;
    277e:	12 b8       	out	0x02, r1	; 2
	DATA_PORT_LOW = command;
    2780:	81 e1       	ldi	r24, 0x11	; 17
    2782:	88 b9       	out	0x08, r24	; 8
	
	//Set WR port to 0 to start transmission - wait 15 nano sec - Set WR port to 1 to end transmission. 
	WR_PORT &= ~(1 << WR_BIT);
    2784:	a2 98       	cbi	0x14, 2	; 20
	_NOP();
    2786:	00 00       	nop
	WR_PORT |= (1 << WR_BIT);
    2788:	a2 9a       	sbi	0x14, 2	; 20
	_NOP();
    278a:	00 00       	nop
	
	// Set chip select to low
	CS_PORT_Dispay |= (1 << CS_BIT);
    278c:	a1 9a       	sbi	0x14, 1	; 20
	for (uint32_t counter = 0; counter < (uint32_t)Width*Height; counter++)
	{
		WritePixel(Red,Green,Blue);
	}
	SleepOut();
}
    278e:	0f 91       	pop	r16
    2790:	ef 90       	pop	r14
    2792:	df 90       	pop	r13
    2794:	cf 90       	pop	r12
    2796:	08 95       	ret

// ILI 9341 data sheet, page 238
void WriteCommand(unsigned int command)
{
	// Set DC port to command
	DC_PORT &= ~(1 << DC_BIT);
    2798:	5f 98       	cbi	0x0b, 7	; 11
	
	// Set chip select to high - Then wait min 15 ns for chip select setup.
	CS_PORT_Dispay &= ~(1 << CS_BIT);	
    279a:	a1 98       	cbi	0x14, 1	; 20
	_NOP();
    279c:	00 00       	nop
	
	// Set databus
	DATA_PORT_HIGH = command >> 8U;
    279e:	12 b8       	out	0x02, r1	; 2
	DATA_PORT_LOW = command;
    27a0:	ab e2       	ldi	r26, 0x2B	; 43
    27a2:	a8 b9       	out	0x08, r26	; 8
	
	//Set WR port to 0 to start transmission - wait 15 nano sec - Set WR port to 1 to end transmission. 
	WR_PORT &= ~(1 << WR_BIT);
    27a4:	a2 98       	cbi	0x14, 2	; 20
	_NOP();
    27a6:	00 00       	nop
	WR_PORT |= (1 << WR_BIT);
    27a8:	a2 9a       	sbi	0x14, 2	; 20
	_NOP();
    27aa:	00 00       	nop
	
	// Set chip select to low
	CS_PORT_Dispay |= (1 << CS_BIT);
    27ac:	a1 9a       	sbi	0x14, 1	; 20

// ILI 9341 data sheet, page 238
void WriteData(unsigned int data)
{
	// Set DC port to data
	DC_PORT |= (1 << DC_BIT);
    27ae:	5f 9a       	sbi	0x0b, 7	; 11
	
	// Set chip select to high - Then wait min 15 ns for chip select setup. 
	CS_PORT_Dispay &= ~(1 << CS_BIT);
    27b0:	a1 98       	cbi	0x14, 1	; 20
	_NOP();
    27b2:	00 00       	nop
		
	// Set databus
	DATA_PORT_HIGH = data >> 8U;
    27b4:	12 b8       	out	0x02, r1	; 2
	DATA_PORT_LOW = data;
    27b6:	98 b9       	out	0x08, r25	; 8
	
	//Set WR port to 0 to start transmission - wait 15 nano sec - Set WR port to 1 to end transmission.
	WR_PORT &= ~(1 << WR_BIT);
    27b8:	a2 98       	cbi	0x14, 2	; 20
	_NOP();
    27ba:	00 00       	nop
	WR_PORT |= (1 << WR_BIT);
    27bc:	a2 9a       	sbi	0x14, 2	; 20
	_NOP();
    27be:	00 00       	nop
	
	// Set chip select to low
	CS_PORT_Dispay |= (1 << CS_BIT);
    27c0:	a1 9a       	sbi	0x14, 1	; 20

// ILI 9341 data sheet, page 238
void WriteData(unsigned int data)
{
	// Set DC port to data
	DC_PORT |= (1 << DC_BIT);
    27c2:	5f 9a       	sbi	0x0b, 7	; 11
	
	// Set chip select to high - Then wait min 15 ns for chip select setup. 
	CS_PORT_Dispay &= ~(1 << CS_BIT);
    27c4:	a1 98       	cbi	0x14, 1	; 20
	_NOP();
    27c6:	00 00       	nop
		
	// Set databus
	DATA_PORT_HIGH = data >> 8U;
    27c8:	92 b9       	out	0x02, r25	; 2
	DATA_PORT_LOW = data;
    27ca:	88 b9       	out	0x08, r24	; 8
	
	//Set WR port to 0 to start transmission - wait 15 nano sec - Set WR port to 1 to end transmission.
	WR_PORT &= ~(1 << WR_BIT);
    27cc:	a2 98       	cbi	0x14, 2	; 20
	_NOP();
    27ce:	00 00       	nop
	WR_PORT |= (1 << WR_BIT);
    27d0:	a2 9a       	sbi	0x14, 2	; 20
	_NOP();
    27d2:	00 00       	nop
	
	// Set chip select to low
	CS_PORT_Dispay |= (1 << CS_BIT);
    27d4:	a1 9a       	sbi	0x14, 1	; 20

// ILI 9341 data sheet, page 238
void WriteData(unsigned int data)
{
	// Set DC port to data
	DC_PORT |= (1 << DC_BIT);
    27d6:	5f 9a       	sbi	0x0b, 7	; 11
	
	// Set chip select to high - Then wait min 15 ns for chip select setup. 
	CS_PORT_Dispay &= ~(1 << CS_BIT);
    27d8:	a1 98       	cbi	0x14, 1	; 20
	_NOP();
    27da:	00 00       	nop
		
	// Set databus
	DATA_PORT_HIGH = data >> 8U;
    27dc:	12 b8       	out	0x02, r1	; 2
	DATA_PORT_LOW = data;
    27de:	f8 b9       	out	0x08, r31	; 8
	
	//Set WR port to 0 to start transmission - wait 15 nano sec - Set WR port to 1 to end transmission.
	WR_PORT &= ~(1 << WR_BIT);
    27e0:	a2 98       	cbi	0x14, 2	; 20
	_NOP();
    27e2:	00 00       	nop
	WR_PORT |= (1 << WR_BIT);
    27e4:	a2 9a       	sbi	0x14, 2	; 20
	_NOP();
    27e6:	00 00       	nop
	
	// Set chip select to low
	CS_PORT_Dispay |= (1 << CS_BIT);
    27e8:	a1 9a       	sbi	0x14, 1	; 20

// ILI 9341 data sheet, page 238
void WriteData(unsigned int data)
{
	// Set DC port to data
	DC_PORT |= (1 << DC_BIT);
    27ea:	5f 9a       	sbi	0x0b, 7	; 11
	
	// Set chip select to high - Then wait min 15 ns for chip select setup. 
	CS_PORT_Dispay &= ~(1 << CS_BIT);
    27ec:	a1 98       	cbi	0x14, 1	; 20
	_NOP();
    27ee:	00 00       	nop
		
	// Set databus
	DATA_PORT_HIGH = data >> 8U;
    27f0:	f2 b9       	out	0x02, r31	; 2
	DATA_PORT_LOW = data;
    27f2:	e8 b9       	out	0x08, r30	; 8
	
	//Set WR port to 0 to start transmission - wait 15 nano sec - Set WR port to 1 to end transmission.
	WR_PORT &= ~(1 << WR_BIT);
    27f4:	a2 98       	cbi	0x14, 2	; 20
	_NOP();
    27f6:	00 00       	nop
	WR_PORT |= (1 << WR_BIT);
    27f8:	a2 9a       	sbi	0x14, 2	; 20
	_NOP();
    27fa:	00 00       	nop
	
	// Set chip select to low
	CS_PORT_Dispay |= (1 << CS_BIT);
    27fc:	a1 9a       	sbi	0x14, 1	; 20
// Height (1-240) is vertical. Width (1-320) is horizontal.
// R-G-B = 5-6-5 bits.
void FillRectangle(unsigned int StartX, unsigned int StartY, unsigned int Width, unsigned int Height, unsigned char Blue, unsigned char Green, unsigned char Red)
{
	SetPageAddress(StartX,StartX+Width-1);
	SetColumnAddress(StartY,StartY+Height-1);
    27fe:	c9 01       	movw	r24, r18
    2800:	01 97       	sbiw	r24, 0x01	; 1
    2802:	86 0f       	add	r24, r22
    2804:	97 1f       	adc	r25, r23
}

// Set Column Address (0-239), Start > End
void SetColumnAddress(unsigned int Start, unsigned int End)
{
	if (Start < End)
    2806:	68 17       	cp	r22, r24
    2808:	79 07       	cpc	r23, r25
    280a:	08 f0       	brcs	.+2      	; 0x280e <_Z13FillRectanglejjjjhhh+0x130>
    280c:	7c cf       	rjmp	.-264    	; 0x2706 <_Z13FillRectanglejjjjhhh+0x28>

// ILI 9341 data sheet, page 238
void WriteCommand(unsigned int command)
{
	// Set DC port to command
	DC_PORT &= ~(1 << DC_BIT);
    280e:	5f 98       	cbi	0x0b, 7	; 11
	
	// Set chip select to high - Then wait min 15 ns for chip select setup.
	CS_PORT_Dispay &= ~(1 << CS_BIT);	
    2810:	a1 98       	cbi	0x14, 1	; 20
	_NOP();
    2812:	00 00       	nop
	
	// Set databus
	DATA_PORT_HIGH = command >> 8U;
    2814:	12 b8       	out	0x02, r1	; 2
	DATA_PORT_LOW = command;
    2816:	ea e2       	ldi	r30, 0x2A	; 42
    2818:	e8 b9       	out	0x08, r30	; 8
	
	//Set WR port to 0 to start transmission - wait 15 nano sec - Set WR port to 1 to end transmission. 
	WR_PORT &= ~(1 << WR_BIT);
    281a:	a2 98       	cbi	0x14, 2	; 20
	_NOP();
    281c:	00 00       	nop
	WR_PORT |= (1 << WR_BIT);
    281e:	a2 9a       	sbi	0x14, 2	; 20
	_NOP();
    2820:	00 00       	nop
	
	// Set chip select to low
	CS_PORT_Dispay |= (1 << CS_BIT);
    2822:	a1 9a       	sbi	0x14, 1	; 20

// ILI 9341 data sheet, page 238
void WriteData(unsigned int data)
{
	// Set DC port to data
	DC_PORT |= (1 << DC_BIT);
    2824:	5f 9a       	sbi	0x0b, 7	; 11
	
	// Set chip select to high - Then wait min 15 ns for chip select setup. 
	CS_PORT_Dispay &= ~(1 << CS_BIT);
    2826:	a1 98       	cbi	0x14, 1	; 20
	_NOP();
    2828:	00 00       	nop
		
	// Set databus
	DATA_PORT_HIGH = data >> 8U;
    282a:	12 b8       	out	0x02, r1	; 2
	DATA_PORT_LOW = data;
    282c:	78 b9       	out	0x08, r23	; 8
	
	//Set WR port to 0 to start transmission - wait 15 nano sec - Set WR port to 1 to end transmission.
	WR_PORT &= ~(1 << WR_BIT);
    282e:	a2 98       	cbi	0x14, 2	; 20
	_NOP();
    2830:	00 00       	nop
	WR_PORT |= (1 << WR_BIT);
    2832:	a2 9a       	sbi	0x14, 2	; 20
	_NOP();
    2834:	00 00       	nop
	
	// Set chip select to low
	CS_PORT_Dispay |= (1 << CS_BIT);
    2836:	a1 9a       	sbi	0x14, 1	; 20

// ILI 9341 data sheet, page 238
void WriteData(unsigned int data)
{
	// Set DC port to data
	DC_PORT |= (1 << DC_BIT);
    2838:	5f 9a       	sbi	0x0b, 7	; 11
	
	// Set chip select to high - Then wait min 15 ns for chip select setup. 
	CS_PORT_Dispay &= ~(1 << CS_BIT);
    283a:	a1 98       	cbi	0x14, 1	; 20
	_NOP();
    283c:	00 00       	nop
		
	// Set databus
	DATA_PORT_HIGH = data >> 8U;
    283e:	72 b9       	out	0x02, r23	; 2
	DATA_PORT_LOW = data;
    2840:	68 b9       	out	0x08, r22	; 8
	
	//Set WR port to 0 to start transmission - wait 15 nano sec - Set WR port to 1 to end transmission.
	WR_PORT &= ~(1 << WR_BIT);
    2842:	a2 98       	cbi	0x14, 2	; 20
	_NOP();
    2844:	00 00       	nop
	WR_PORT |= (1 << WR_BIT);
    2846:	a2 9a       	sbi	0x14, 2	; 20
	_NOP();
    2848:	00 00       	nop
	
	// Set chip select to low
	CS_PORT_Dispay |= (1 << CS_BIT);
    284a:	a1 9a       	sbi	0x14, 1	; 20

// ILI 9341 data sheet, page 238
void WriteData(unsigned int data)
{
	// Set DC port to data
	DC_PORT |= (1 << DC_BIT);
    284c:	5f 9a       	sbi	0x0b, 7	; 11
	
	// Set chip select to high - Then wait min 15 ns for chip select setup. 
	CS_PORT_Dispay &= ~(1 << CS_BIT);
    284e:	a1 98       	cbi	0x14, 1	; 20
	_NOP();
    2850:	00 00       	nop
		
	// Set databus
	DATA_PORT_HIGH = data >> 8U;
    2852:	12 b8       	out	0x02, r1	; 2
	DATA_PORT_LOW = data;
    2854:	98 b9       	out	0x08, r25	; 8
	
	//Set WR port to 0 to start transmission - wait 15 nano sec - Set WR port to 1 to end transmission.
	WR_PORT &= ~(1 << WR_BIT);
    2856:	a2 98       	cbi	0x14, 2	; 20
	_NOP();
    2858:	00 00       	nop
	WR_PORT |= (1 << WR_BIT);
    285a:	a2 9a       	sbi	0x14, 2	; 20
	_NOP();
    285c:	00 00       	nop
	
	// Set chip select to low
	CS_PORT_Dispay |= (1 << CS_BIT);
    285e:	a1 9a       	sbi	0x14, 1	; 20

// ILI 9341 data sheet, page 238
void WriteData(unsigned int data)
{
	// Set DC port to data
	DC_PORT |= (1 << DC_BIT);
    2860:	5f 9a       	sbi	0x0b, 7	; 11
	
	// Set chip select to high - Then wait min 15 ns for chip select setup. 
	CS_PORT_Dispay &= ~(1 << CS_BIT);
    2862:	a1 98       	cbi	0x14, 1	; 20
	_NOP();
    2864:	00 00       	nop
		
	// Set databus
	DATA_PORT_HIGH = data >> 8U;
    2866:	92 b9       	out	0x02, r25	; 2
	DATA_PORT_LOW = data;
    2868:	88 b9       	out	0x08, r24	; 8
	
	//Set WR port to 0 to start transmission - wait 15 nano sec - Set WR port to 1 to end transmission.
	WR_PORT &= ~(1 << WR_BIT);
    286a:	a2 98       	cbi	0x14, 2	; 20
	_NOP();
    286c:	00 00       	nop
	WR_PORT |= (1 << WR_BIT);
    286e:	a2 9a       	sbi	0x14, 2	; 20
	_NOP();
    2870:	00 00       	nop
	
	// Set chip select to low
	CS_PORT_Dispay |= (1 << CS_BIT);
    2872:	a1 9a       	sbi	0x14, 1	; 20
    2874:	48 cf       	rjmp	.-368    	; 0x2706 <_Z13FillRectanglejjjjhhh+0x28>

00002876 <_ZN11TouchscreenC1Ev>:
	flashRed = ButtonClass(0,0,320,240,255,0,0);
	
	DisplayInit();
}

Touchscreen::~Touchscreen()
    2876:	0f 93       	push	r16
    2878:	1f 93       	push	r17
    287a:	cf 93       	push	r28
    287c:	df 93       	push	r29
    287e:	1f 92       	push	r1
    2880:	1f 92       	push	r1
    2882:	cd b7       	in	r28, 0x3d	; 61
    2884:	de b7       	in	r29, 0x3e	; 62
    2886:	8c 01       	movw	r16, r24
    2888:	a9 d1       	rcall	.+850    	; 0x2bdc <_ZN11TouchDriverC1Ev>
    288a:	d8 01       	movw	r26, r16
    288c:	12 96       	adiw	r26, 0x02	; 2
    288e:	1c 92       	st	X, r1
    2890:	12 97       	sbiw	r26, 0x02	; 2
    2892:	13 96       	adiw	r26, 0x03	; 3
    2894:	1c 92       	st	X, r1
    2896:	13 97       	sbiw	r26, 0x03	; 3
    2898:	14 96       	adiw	r26, 0x04	; 4
    289a:	1c 92       	st	X, r1
    289c:	14 97       	sbiw	r26, 0x04	; 4
    289e:	16 96       	adiw	r26, 0x06	; 6
    28a0:	1c 92       	st	X, r1
    28a2:	1e 92       	st	-X, r1
    28a4:	15 97       	sbiw	r26, 0x05	; 5
    28a6:	17 96       	adiw	r26, 0x07	; 7
    28a8:	1c 92       	st	X, r1
    28aa:	17 97       	sbiw	r26, 0x07	; 7
    28ac:	18 96       	adiw	r26, 0x08	; 8
    28ae:	1c 92       	st	X, r1
    28b0:	18 97       	sbiw	r26, 0x08	; 8
    28b2:	19 96       	adiw	r26, 0x09	; 9
    28b4:	1c 92       	st	X, r1
    28b6:	19 97       	sbiw	r26, 0x09	; 9
    28b8:	1b 96       	adiw	r26, 0x0b	; 11
    28ba:	1c 92       	st	X, r1
    28bc:	1e 92       	st	-X, r1
    28be:	1a 97       	sbiw	r26, 0x0a	; 10
    28c0:	1c 96       	adiw	r26, 0x0c	; 12
    28c2:	1c 92       	st	X, r1
    28c4:	1c 97       	sbiw	r26, 0x0c	; 12
    28c6:	1d 96       	adiw	r26, 0x0d	; 13
    28c8:	1c 92       	st	X, r1
    28ca:	1d 97       	sbiw	r26, 0x0d	; 13
    28cc:	1e 96       	adiw	r26, 0x0e	; 14
    28ce:	1c 92       	st	X, r1
    28d0:	1e 97       	sbiw	r26, 0x0e	; 14
    28d2:	1f 96       	adiw	r26, 0x0f	; 15
    28d4:	1c 92       	st	X, r1
    28d6:	1f 97       	sbiw	r26, 0x0f	; 15
    28d8:	51 96       	adiw	r26, 0x11	; 17
    28da:	1c 92       	st	X, r1
    28dc:	1e 92       	st	-X, r1
    28de:	50 97       	sbiw	r26, 0x10	; 16
    28e0:	52 96       	adiw	r26, 0x12	; 18
    28e2:	1c 92       	st	X, r1
    28e4:	52 97       	sbiw	r26, 0x12	; 18
    28e6:	53 96       	adiw	r26, 0x13	; 19
    28e8:	1c 92       	st	X, r1
    28ea:	53 97       	sbiw	r26, 0x13	; 19
    28ec:	54 96       	adiw	r26, 0x14	; 20
    28ee:	1c 92       	st	X, r1
    28f0:	54 97       	sbiw	r26, 0x14	; 20
    28f2:	56 96       	adiw	r26, 0x16	; 22
    28f4:	1c 92       	st	X, r1
    28f6:	1e 92       	st	-X, r1
    28f8:	55 97       	sbiw	r26, 0x15	; 21
    28fa:	57 96       	adiw	r26, 0x17	; 23
    28fc:	1c 92       	st	X, r1
    28fe:	57 97       	sbiw	r26, 0x17	; 23
    2900:	58 96       	adiw	r26, 0x18	; 24
    2902:	1c 92       	st	X, r1
    2904:	58 97       	sbiw	r26, 0x18	; 24
    2906:	59 96       	adiw	r26, 0x19	; 25
    2908:	1c 92       	st	X, r1
    290a:	59 97       	sbiw	r26, 0x19	; 25
    290c:	5a 96       	adiw	r26, 0x1a	; 26
    290e:	1c 92       	st	X, r1
    2910:	5a 97       	sbiw	r26, 0x1a	; 26
    2912:	5c 96       	adiw	r26, 0x1c	; 28
    2914:	1c 92       	st	X, r1
    2916:	1e 92       	st	-X, r1
    2918:	5b 97       	sbiw	r26, 0x1b	; 27
    291a:	5d 96       	adiw	r26, 0x1d	; 29
    291c:	1c 92       	st	X, r1
    291e:	5d 97       	sbiw	r26, 0x1d	; 29
    2920:	5e 96       	adiw	r26, 0x1e	; 30
    2922:	1c 92       	st	X, r1
    2924:	5e 97       	sbiw	r26, 0x1e	; 30
    2926:	5f 96       	adiw	r26, 0x1f	; 31
    2928:	1c 92       	st	X, r1
    292a:	5f 97       	sbiw	r26, 0x1f	; 31
    292c:	91 96       	adiw	r26, 0x21	; 33
    292e:	1c 92       	st	X, r1
    2930:	1e 92       	st	-X, r1
    2932:	90 97       	sbiw	r26, 0x20	; 32
    2934:	92 96       	adiw	r26, 0x22	; 34
    2936:	1c 92       	st	X, r1
    2938:	ce 01       	movw	r24, r28
    293a:	01 96       	adiw	r24, 0x01	; 1
    293c:	4f d1       	rcall	.+670    	; 0x2bdc <_ZN11TouchDriverC1Ev>
    293e:	89 81       	ldd	r24, Y+1	; 0x01
    2940:	9a 81       	ldd	r25, Y+2	; 0x02
    2942:	f8 01       	movw	r30, r16
    2944:	91 83       	std	Z+1, r25	; 0x01
    2946:	80 83       	st	Z, r24
    2948:	ce 01       	movw	r24, r28
    294a:	01 96       	adiw	r24, 0x01	; 1
    294c:	59 d1       	rcall	.+690    	; 0x2c00 <_ZN11TouchDriverD1Ev>
    294e:	84 e1       	ldi	r24, 0x14	; 20
    2950:	d8 01       	movw	r26, r16
    2952:	12 96       	adiw	r26, 0x02	; 2
    2954:	8c 93       	st	X, r24
    2956:	12 97       	sbiw	r26, 0x02	; 2
    2958:	66 e4       	ldi	r22, 0x46	; 70
    295a:	13 96       	adiw	r26, 0x03	; 3
    295c:	6c 93       	st	X, r22
    295e:	13 97       	sbiw	r26, 0x03	; 3
    2960:	34 e6       	ldi	r19, 0x64	; 100
    2962:	14 96       	adiw	r26, 0x04	; 4
    2964:	3c 93       	st	X, r19
    2966:	14 97       	sbiw	r26, 0x04	; 4
    2968:	44 e6       	ldi	r20, 0x64	; 100
    296a:	50 e0       	ldi	r21, 0x00	; 0
    296c:	16 96       	adiw	r26, 0x06	; 6
    296e:	5c 93       	st	X, r21
    2970:	4e 93       	st	-X, r20
    2972:	15 97       	sbiw	r26, 0x05	; 5
    2974:	8d e1       	ldi	r24, 0x1D	; 29
    2976:	17 96       	adiw	r26, 0x07	; 7
    2978:	8c 93       	st	X, r24
    297a:	17 97       	sbiw	r26, 0x07	; 7
    297c:	9a ee       	ldi	r25, 0xEA	; 234
    297e:	18 96       	adiw	r26, 0x08	; 8
    2980:	9c 93       	st	X, r25
    2982:	18 97       	sbiw	r26, 0x08	; 8
    2984:	22 e0       	ldi	r18, 0x02	; 2
    2986:	19 96       	adiw	r26, 0x09	; 9
    2988:	2c 93       	st	X, r18
    298a:	19 97       	sbiw	r26, 0x09	; 9
    298c:	e8 e7       	ldi	r30, 0x78	; 120
    298e:	f0 e0       	ldi	r31, 0x00	; 0
    2990:	1b 96       	adiw	r26, 0x0b	; 11
    2992:	fc 93       	st	X, r31
    2994:	ee 93       	st	-X, r30
    2996:	1a 97       	sbiw	r26, 0x0a	; 10
    2998:	8a ea       	ldi	r24, 0xAA	; 170
    299a:	1c 96       	adiw	r26, 0x0c	; 12
    299c:	8c 93       	st	X, r24
    299e:	1c 97       	sbiw	r26, 0x0c	; 12
    29a0:	78 ec       	ldi	r23, 0xC8	; 200
    29a2:	1d 96       	adiw	r26, 0x0d	; 13
    29a4:	7c 93       	st	X, r23
    29a6:	1d 97       	sbiw	r26, 0x0d	; 13
    29a8:	1e 96       	adiw	r26, 0x0e	; 14
    29aa:	6c 93       	st	X, r22
    29ac:	1e 97       	sbiw	r26, 0x0e	; 14
    29ae:	1f 96       	adiw	r26, 0x0f	; 15
    29b0:	3c 93       	st	X, r19
    29b2:	1f 97       	sbiw	r26, 0x0f	; 15
    29b4:	51 96       	adiw	r26, 0x11	; 17
    29b6:	5c 93       	st	X, r21
    29b8:	4e 93       	st	-X, r20
    29ba:	50 97       	sbiw	r26, 0x10	; 16
    29bc:	3c e2       	ldi	r19, 0x2C	; 44
    29be:	52 96       	adiw	r26, 0x12	; 18
    29c0:	3c 93       	st	X, r19
    29c2:	52 97       	sbiw	r26, 0x12	; 18
    29c4:	53 96       	adiw	r26, 0x13	; 19
    29c6:	2c 93       	st	X, r18
    29c8:	53 97       	sbiw	r26, 0x13	; 19
    29ca:	54 96       	adiw	r26, 0x14	; 20
    29cc:	9c 93       	st	X, r25
    29ce:	54 97       	sbiw	r26, 0x14	; 20
    29d0:	2c e2       	ldi	r18, 0x2C	; 44
    29d2:	31 e0       	ldi	r19, 0x01	; 1
    29d4:	56 96       	adiw	r26, 0x16	; 22
    29d6:	3c 93       	st	X, r19
    29d8:	2e 93       	st	-X, r18
    29da:	55 97       	sbiw	r26, 0x15	; 21
    29dc:	57 96       	adiw	r26, 0x17	; 23
    29de:	8c 93       	st	X, r24
    29e0:	57 97       	sbiw	r26, 0x17	; 23
    29e2:	58 96       	adiw	r26, 0x18	; 24
    29e4:	1c 92       	st	X, r1
    29e6:	58 97       	sbiw	r26, 0x18	; 24
    29e8:	59 96       	adiw	r26, 0x19	; 25
    29ea:	1c 92       	st	X, r1
    29ec:	59 97       	sbiw	r26, 0x19	; 25
    29ee:	80 ef       	ldi	r24, 0xF0	; 240
    29f0:	5a 96       	adiw	r26, 0x1a	; 26
    29f2:	8c 93       	st	X, r24
    29f4:	5a 97       	sbiw	r26, 0x1a	; 26
    29f6:	20 e4       	ldi	r18, 0x40	; 64
    29f8:	31 e0       	ldi	r19, 0x01	; 1
    29fa:	5c 96       	adiw	r26, 0x1c	; 28
    29fc:	3c 93       	st	X, r19
    29fe:	2e 93       	st	-X, r18
    2a00:	5b 97       	sbiw	r26, 0x1b	; 27
    2a02:	9f ef       	ldi	r25, 0xFF	; 255
    2a04:	5d 96       	adiw	r26, 0x1d	; 29
    2a06:	9c 93       	st	X, r25
    2a08:	5d 97       	sbiw	r26, 0x1d	; 29
    2a0a:	5e 96       	adiw	r26, 0x1e	; 30
    2a0c:	1c 92       	st	X, r1
    2a0e:	5e 97       	sbiw	r26, 0x1e	; 30
    2a10:	5f 96       	adiw	r26, 0x1f	; 31
    2a12:	1c 92       	st	X, r1
    2a14:	5f 97       	sbiw	r26, 0x1f	; 31
    2a16:	91 96       	adiw	r26, 0x21	; 33
    2a18:	3c 93       	st	X, r19
    2a1a:	2e 93       	st	-X, r18
    2a1c:	90 97       	sbiw	r26, 0x20	; 32
    2a1e:	92 96       	adiw	r26, 0x22	; 34
    2a20:	8c 93       	st	X, r24
    2a22:	fb dd       	rcall	.-1034   	; 0x261a <_Z11DisplayInitv>
    2a24:	0f 90       	pop	r0
    2a26:	0f 90       	pop	r0
    2a28:	df 91       	pop	r29
    2a2a:	cf 91       	pop	r28
    2a2c:	1f 91       	pop	r17
    2a2e:	0f 91       	pop	r16
    2a30:	08 95       	ret

00002a32 <_ZN11Touchscreen12checkButtonsEv>:
{
}

uint8_t Touchscreen::checkButtons(void)
{
    2a32:	cf 92       	push	r12
    2a34:	df 92       	push	r13
    2a36:	ef 92       	push	r14
    2a38:	ff 92       	push	r15
    2a3a:	0f 93       	push	r16
    2a3c:	1f 93       	push	r17
    2a3e:	cf 93       	push	r28
    2a40:	df 93       	push	r29
    2a42:	1f 92       	push	r1
    2a44:	1f 92       	push	r1
    2a46:	cd b7       	in	r28, 0x3d	; 61
    2a48:	de b7       	in	r29, 0x3e	; 62
    2a4a:	8c 01       	movw	r16, r24
	uint8_t x = 0;
    2a4c:	1a 82       	std	Y+2, r1	; 0x02
	uint8_t y = 0;
    2a4e:	19 82       	std	Y+1, r1	; 0x01
	
	// receive x and y by call by reference
	TouchDriv.getCoordinates(&x, &y);
    2a50:	ae 01       	movw	r20, r28
    2a52:	4f 5f       	subi	r20, 0xFF	; 255
    2a54:	5f 4f       	sbci	r21, 0xFF	; 255
    2a56:	be 01       	movw	r22, r28
    2a58:	6e 5f       	subi	r22, 0xFE	; 254
    2a5a:	7f 4f       	sbci	r23, 0xFF	; 255
    2a5c:	de d0       	rcall	.+444    	; 0x2c1a <_ZN11TouchDriver14getCoordinatesEPhS0_>
		
	// Check if touch is in between buttons on display. 1.33 is the scaling factor between touch and display.
	// Max Touch Res is 255 while display is 320
	if (x > blueBnt.startX/1.33 && x < blueBnt.endX/1.33 && y > blueBnt.startY && y < blueBnt.endY)
    2a5e:	6a 81       	ldd	r22, Y+2	; 0x02
    2a60:	70 e0       	ldi	r23, 0x00	; 0
    2a62:	80 e0       	ldi	r24, 0x00	; 0
    2a64:	90 e0       	ldi	r25, 0x00	; 0
    2a66:	b3 d7       	rcall	.+3942   	; 0x39ce <__floatsisf>
    2a68:	6b 01       	movw	r12, r22
    2a6a:	7c 01       	movw	r14, r24
    2a6c:	f8 01       	movw	r30, r16
    2a6e:	62 81       	ldd	r22, Z+2	; 0x02
    2a70:	70 e0       	ldi	r23, 0x00	; 0
    2a72:	80 e0       	ldi	r24, 0x00	; 0
    2a74:	90 e0       	ldi	r25, 0x00	; 0
    2a76:	ab d7       	rcall	.+3926   	; 0x39ce <__floatsisf>
    2a78:	21 e7       	ldi	r18, 0x71	; 113
    2a7a:	3d e3       	ldi	r19, 0x3D	; 61
    2a7c:	4a ea       	ldi	r20, 0xAA	; 170
    2a7e:	5f e3       	ldi	r21, 0x3F	; 63
    2a80:	10 d7       	rcall	.+3616   	; 0x38a2 <__divsf3>
    2a82:	9b 01       	movw	r18, r22
    2a84:	ac 01       	movw	r20, r24
    2a86:	c7 01       	movw	r24, r14
    2a88:	b6 01       	movw	r22, r12
    2a8a:	0e 94 97 1d 	call	0x3b2e	; 0x3b2e <__gesf2>
    2a8e:	18 16       	cp	r1, r24
    2a90:	dc f4       	brge	.+54     	; 0x2ac8 <_ZN11Touchscreen12checkButtonsEv+0x96>
    2a92:	f8 01       	movw	r30, r16
    2a94:	62 85       	ldd	r22, Z+10	; 0x0a
    2a96:	73 85       	ldd	r23, Z+11	; 0x0b
    2a98:	80 e0       	ldi	r24, 0x00	; 0
    2a9a:	90 e0       	ldi	r25, 0x00	; 0
    2a9c:	96 d7       	rcall	.+3884   	; 0x39ca <__floatunsisf>
    2a9e:	21 e7       	ldi	r18, 0x71	; 113
    2aa0:	3d e3       	ldi	r19, 0x3D	; 61
    2aa2:	4a ea       	ldi	r20, 0xAA	; 170
    2aa4:	5f e3       	ldi	r21, 0x3F	; 63
    2aa6:	fd d6       	rcall	.+3578   	; 0x38a2 <__divsf3>
    2aa8:	9b 01       	movw	r18, r22
    2aaa:	ac 01       	movw	r20, r24
    2aac:	c7 01       	movw	r24, r14
    2aae:	b6 01       	movw	r22, r12
    2ab0:	f4 d6       	rcall	.+3560   	; 0x389a <__cmpsf2>
    2ab2:	87 ff       	sbrs	r24, 7
    2ab4:	09 c0       	rjmp	.+18     	; 0x2ac8 <_ZN11Touchscreen12checkButtonsEv+0x96>
    2ab6:	89 81       	ldd	r24, Y+1	; 0x01
    2ab8:	f8 01       	movw	r30, r16
    2aba:	93 81       	ldd	r25, Z+3	; 0x03
    2abc:	98 17       	cp	r25, r24
    2abe:	20 f4       	brcc	.+8      	; 0x2ac8 <_ZN11Touchscreen12checkButtonsEv+0x96>
    2ac0:	94 85       	ldd	r25, Z+12	; 0x0c
    2ac2:	89 17       	cp	r24, r25
    2ac4:	08 f4       	brcc	.+2      	; 0x2ac8 <_ZN11Touchscreen12checkButtonsEv+0x96>
	{
		return 1;
	}
	else if (x > greenBnt.startX/1.33 && x < greenBnt.endX/1.33 && y > greenBnt.startY && y < greenBnt.endY)
    2ac6:	3b c0       	rjmp	.+118    	; 0x2b3e <_ZN11Touchscreen12checkButtonsEv+0x10c>
    2ac8:	f8 01       	movw	r30, r16
    2aca:	65 85       	ldd	r22, Z+13	; 0x0d
    2acc:	70 e0       	ldi	r23, 0x00	; 0
    2ace:	80 e0       	ldi	r24, 0x00	; 0
    2ad0:	90 e0       	ldi	r25, 0x00	; 0
    2ad2:	7d d7       	rcall	.+3834   	; 0x39ce <__floatsisf>
    2ad4:	21 e7       	ldi	r18, 0x71	; 113
    2ad6:	3d e3       	ldi	r19, 0x3D	; 61
    2ad8:	4a ea       	ldi	r20, 0xAA	; 170
    2ada:	5f e3       	ldi	r21, 0x3F	; 63
    2adc:	e2 d6       	rcall	.+3524   	; 0x38a2 <__divsf3>
    2ade:	9b 01       	movw	r18, r22
    2ae0:	ac 01       	movw	r20, r24
    2ae2:	c7 01       	movw	r24, r14
    2ae4:	b6 01       	movw	r22, r12
    2ae6:	0e 94 97 1d 	call	0x3b2e	; 0x3b2e <__gesf2>
    2aea:	18 16       	cp	r1, r24
    2aec:	e4 f4       	brge	.+56     	; 0x2b26 <_ZN11Touchscreen12checkButtonsEv+0xf4>
    2aee:	f8 01       	movw	r30, r16
    2af0:	65 89       	ldd	r22, Z+21	; 0x15
    2af2:	76 89       	ldd	r23, Z+22	; 0x16
    2af4:	80 e0       	ldi	r24, 0x00	; 0
    2af6:	90 e0       	ldi	r25, 0x00	; 0
    2af8:	68 d7       	rcall	.+3792   	; 0x39ca <__floatunsisf>
    2afa:	21 e7       	ldi	r18, 0x71	; 113
    2afc:	3d e3       	ldi	r19, 0x3D	; 61
    2afe:	4a ea       	ldi	r20, 0xAA	; 170
    2b00:	5f e3       	ldi	r21, 0x3F	; 63
    2b02:	cf d6       	rcall	.+3486   	; 0x38a2 <__divsf3>
    2b04:	9b 01       	movw	r18, r22
    2b06:	ac 01       	movw	r20, r24
    2b08:	c7 01       	movw	r24, r14
    2b0a:	b6 01       	movw	r22, r12
    2b0c:	c6 d6       	rcall	.+3468   	; 0x389a <__cmpsf2>
    2b0e:	87 ff       	sbrs	r24, 7
    2b10:	0a c0       	rjmp	.+20     	; 0x2b26 <_ZN11Touchscreen12checkButtonsEv+0xf4>
    2b12:	89 81       	ldd	r24, Y+1	; 0x01
    2b14:	f8 01       	movw	r30, r16
    2b16:	96 85       	ldd	r25, Z+14	; 0x0e
    2b18:	98 17       	cp	r25, r24
    2b1a:	28 f4       	brcc	.+10     	; 0x2b26 <_ZN11Touchscreen12checkButtonsEv+0xf4>
    2b1c:	97 89       	ldd	r25, Z+23	; 0x17
    2b1e:	89 17       	cp	r24, r25
    2b20:	10 f4       	brcc	.+4      	; 0x2b26 <_ZN11Touchscreen12checkButtonsEv+0xf4>
	{
		return 2;
    2b22:	82 e0       	ldi	r24, 0x02	; 2
    2b24:	01 c0       	rjmp	.+2      	; 0x2b28 <_ZN11Touchscreen12checkButtonsEv+0xf6>
	}
	else
	{
		return 0;
    2b26:	80 e0       	ldi	r24, 0x00	; 0
	}
	
}
    2b28:	0f 90       	pop	r0
    2b2a:	0f 90       	pop	r0
    2b2c:	df 91       	pop	r29
    2b2e:	cf 91       	pop	r28
    2b30:	1f 91       	pop	r17
    2b32:	0f 91       	pop	r16
    2b34:	ff 90       	pop	r15
    2b36:	ef 90       	pop	r14
    2b38:	df 90       	pop	r13
    2b3a:	cf 90       	pop	r12
    2b3c:	08 95       	ret
		
	// Check if touch is in between buttons on display. 1.33 is the scaling factor between touch and display.
	// Max Touch Res is 255 while display is 320
	if (x > blueBnt.startX/1.33 && x < blueBnt.endX/1.33 && y > blueBnt.startY && y < blueBnt.endY)
	{
		return 1;
    2b3e:	81 e0       	ldi	r24, 0x01	; 1
    2b40:	f3 cf       	rjmp	.-26     	; 0x2b28 <_ZN11Touchscreen12checkButtonsEv+0xf6>

00002b42 <_ZN11Touchscreen11clearScreenEv>:
	}
	
}

void Touchscreen::clearScreen(void)
{
    2b42:	cf 92       	push	r12
    2b44:	ef 92       	push	r14
    2b46:	0f 93       	push	r16
	// Full Screen White
	FillRectangle(0,0,320,240,255,255,255);
    2b48:	cc 24       	eor	r12, r12
    2b4a:	ca 94       	dec	r12
    2b4c:	ee 24       	eor	r14, r14
    2b4e:	ea 94       	dec	r14
    2b50:	0f ef       	ldi	r16, 0xFF	; 255
    2b52:	20 ef       	ldi	r18, 0xF0	; 240
    2b54:	30 e0       	ldi	r19, 0x00	; 0
    2b56:	40 e4       	ldi	r20, 0x40	; 64
    2b58:	51 e0       	ldi	r21, 0x01	; 1
    2b5a:	60 e0       	ldi	r22, 0x00	; 0
    2b5c:	70 e0       	ldi	r23, 0x00	; 0
    2b5e:	80 e0       	ldi	r24, 0x00	; 0
    2b60:	90 e0       	ldi	r25, 0x00	; 0
    2b62:	bd dd       	rcall	.-1158   	; 0x26de <_Z13FillRectanglejjjjhhh>
}
    2b64:	0f 91       	pop	r16
    2b66:	ef 90       	pop	r14
    2b68:	cf 90       	pop	r12
    2b6a:	08 95       	ret

00002b6c <_ZN11Touchscreen23presentButtonsOnDisplayEv>:

void Touchscreen::presentButtonsOnDisplay(void)
{
    2b6c:	cf 92       	push	r12
    2b6e:	ef 92       	push	r14
    2b70:	0f 93       	push	r16
    2b72:	cf 93       	push	r28
    2b74:	df 93       	push	r29
    2b76:	ec 01       	movw	r28, r24
	
	// Button One
	FillRectangle(blueBnt.startX, blueBnt.startY, blueBnt.width, blueBnt.height, blueBnt.colorRed, blueBnt.colorGreen, blueBnt.colorBlue);
    2b78:	2c 81       	ldd	r18, Y+4	; 0x04
    2b7a:	30 e0       	ldi	r19, 0x00	; 0
    2b7c:	4d 81       	ldd	r20, Y+5	; 0x05
    2b7e:	5e 81       	ldd	r21, Y+6	; 0x06
    2b80:	6b 81       	ldd	r22, Y+3	; 0x03
    2b82:	70 e0       	ldi	r23, 0x00	; 0
    2b84:	8a 81       	ldd	r24, Y+2	; 0x02
    2b86:	c8 84       	ldd	r12, Y+8	; 0x08
    2b88:	e9 84       	ldd	r14, Y+9	; 0x09
    2b8a:	0f 81       	ldd	r16, Y+7	; 0x07
    2b8c:	90 e0       	ldi	r25, 0x00	; 0
    2b8e:	a7 dd       	rcall	.-1202   	; 0x26de <_Z13FillRectanglejjjjhhh>

	// Button Two
	FillRectangle(greenBnt.startX, greenBnt.startY, greenBnt.width, greenBnt.height, greenBnt.colorRed, greenBnt.colorGreen, greenBnt.colorBlue);
    2b90:	2f 85       	ldd	r18, Y+15	; 0x0f
    2b92:	30 e0       	ldi	r19, 0x00	; 0
    2b94:	48 89       	ldd	r20, Y+16	; 0x10
    2b96:	59 89       	ldd	r21, Y+17	; 0x11
    2b98:	6e 85       	ldd	r22, Y+14	; 0x0e
    2b9a:	70 e0       	ldi	r23, 0x00	; 0
    2b9c:	8d 85       	ldd	r24, Y+13	; 0x0d
    2b9e:	cb 88       	ldd	r12, Y+19	; 0x13
    2ba0:	ec 88       	ldd	r14, Y+20	; 0x14
    2ba2:	0a 89       	ldd	r16, Y+18	; 0x12
    2ba4:	90 e0       	ldi	r25, 0x00	; 0
    2ba6:	9b dd       	rcall	.-1226   	; 0x26de <_Z13FillRectanglejjjjhhh>
}
    2ba8:	df 91       	pop	r29
    2baa:	cf 91       	pop	r28
    2bac:	0f 91       	pop	r16
    2bae:	ef 90       	pop	r14
    2bb0:	cf 90       	pop	r12
    2bb2:	08 95       	ret

00002bb4 <_ZN11Touchscreen17flashRedOnDisplayEv>:

void Touchscreen::flashRedOnDisplay(void)
{
    2bb4:	cf 92       	push	r12
    2bb6:	ef 92       	push	r14
    2bb8:	0f 93       	push	r16
    2bba:	fc 01       	movw	r30, r24
	FillRectangle(flashRed.startX, flashRed.startY, flashRed.width, flashRed.height, flashRed.colorRed, flashRed.colorGreen, flashRed.colorBlue);
    2bbc:	22 8d       	ldd	r18, Z+26	; 0x1a
    2bbe:	30 e0       	ldi	r19, 0x00	; 0
    2bc0:	43 8d       	ldd	r20, Z+27	; 0x1b
    2bc2:	54 8d       	ldd	r21, Z+28	; 0x1c
    2bc4:	61 8d       	ldd	r22, Z+25	; 0x19
    2bc6:	70 e0       	ldi	r23, 0x00	; 0
    2bc8:	80 8d       	ldd	r24, Z+24	; 0x18
    2bca:	c6 8c       	ldd	r12, Z+30	; 0x1e
    2bcc:	e7 8c       	ldd	r14, Z+31	; 0x1f
    2bce:	05 8d       	ldd	r16, Z+29	; 0x1d
    2bd0:	90 e0       	ldi	r25, 0x00	; 0
    2bd2:	85 dd       	rcall	.-1270   	; 0x26de <_Z13FillRectanglejjjjhhh>
}
    2bd4:	0f 91       	pop	r16
    2bd6:	ef 90       	pop	r14
    2bd8:	cf 90       	pop	r12
    2bda:	08 95       	ret

00002bdc <_ZN11TouchDriverC1Ev>:
	// Enable Interrupt
	EICRB = 0b00000010;
	EIMSK |= 0b00010000;
	
	// Enable global Interrupts
	sei();
    2bdc:	2c e9       	ldi	r18, 0x9C	; 156
    2bde:	fc 01       	movw	r30, r24
    2be0:	20 83       	st	Z, r18
    2be2:	2c ed       	ldi	r18, 0xDC	; 220
    2be4:	21 83       	std	Z+1, r18	; 0x01
    2be6:	e1 e0       	ldi	r30, 0x01	; 1
    2be8:	f1 e0       	ldi	r31, 0x01	; 1
    2bea:	80 81       	ld	r24, Z
    2bec:	88 60       	ori	r24, 0x08	; 8
    2bee:	80 83       	st	Z, r24
    2bf0:	6b 9a       	sbi	0x0d, 3	; 13
    2bf2:	9d 9a       	sbi	0x13, 5	; 19
    2bf4:	82 e0       	ldi	r24, 0x02	; 2
    2bf6:	80 93 6a 00 	sts	0x006A, r24	; 0x80006a <__TEXT_REGION_LENGTH__+0x70006a>
    2bfa:	ec 9a       	sbi	0x1d, 4	; 29
    2bfc:	78 94       	sei
    2bfe:	08 95       	ret

00002c00 <_ZN11TouchDriverD1Ev>:
    2c00:	08 95       	ret

00002c02 <__vector_5>:
	
}

ISR (INT4_vect)
{
    2c02:	1f 92       	push	r1
    2c04:	0f 92       	push	r0
    2c06:	0f b6       	in	r0, 0x3f	; 63
    2c08:	0f 92       	push	r0
    2c0a:	11 24       	eor	r1, r1
	eIntHappend = 0;
    2c0c:	10 92 0d 02 	sts	0x020D, r1	; 0x80020d <eIntHappend>
}
    2c10:	0f 90       	pop	r0
    2c12:	0f be       	out	0x3f, r0	; 63
    2c14:	0f 90       	pop	r0
    2c16:	1f 90       	pop	r1
    2c18:	18 95       	reti

00002c1a <_ZN11TouchDriver14getCoordinatesEPhS0_>:

void TouchDriver::getCoordinates(uint8_t *x_ptr, uint8_t *y_ptr)
{	
    2c1a:	2f 92       	push	r2
    2c1c:	3f 92       	push	r3
    2c1e:	4f 92       	push	r4
    2c20:	5f 92       	push	r5
    2c22:	6f 92       	push	r6
    2c24:	7f 92       	push	r7
    2c26:	8f 92       	push	r8
    2c28:	9f 92       	push	r9
    2c2a:	af 92       	push	r10
    2c2c:	bf 92       	push	r11
    2c2e:	cf 92       	push	r12
    2c30:	df 92       	push	r13
    2c32:	ef 92       	push	r14
    2c34:	ff 92       	push	r15
    2c36:	0f 93       	push	r16
    2c38:	1f 93       	push	r17
    2c3a:	cf 93       	push	r28
    2c3c:	df 93       	push	r29
    2c3e:	cd b7       	in	r28, 0x3d	; 61
    2c40:	de b7       	in	r29, 0x3e	; 62
    2c42:	a5 97       	sbiw	r28, 0x25	; 37
    2c44:	0f b6       	in	r0, 0x3f	; 63
    2c46:	f8 94       	cli
    2c48:	de bf       	out	0x3e, r29	; 62
    2c4a:	0f be       	out	0x3f, r0	; 63
    2c4c:	cd bf       	out	0x3d, r28	; 61
    2c4e:	20 e0       	ldi	r18, 0x00	; 0
    2c50:	31 e0       	ldi	r19, 0x01	; 1
    2c52:	04 c0       	rjmp	.+8      	; 0x2c5c <_ZN11TouchDriver14getCoordinatesEPhS0_+0x42>
    2c54:	21 50       	subi	r18, 0x01	; 1
    2c56:	31 09       	sbc	r19, r1
	uint16_t timeout = 0;
	while(eIntHappend != 0)
	{
		timeout++;
		if (timeout > 255)
    2c58:	09 f4       	brne	.+2      	; 0x2c5c <_ZN11TouchDriver14getCoordinatesEPhS0_+0x42>
    2c5a:	a1 c5       	rjmp	.+2882   	; 0x379e <_ZN11TouchDriver14getCoordinatesEPhS0_+0xb84>
}

void TouchDriver::getCoordinates(uint8_t *x_ptr, uint8_t *y_ptr)
{	
	uint16_t timeout = 0;
	while(eIntHappend != 0)
    2c5c:	d0 90 0d 02 	lds	r13, 0x020D	; 0x80020d <eIntHappend>
    2c60:	d1 10       	cpse	r13, r1
    2c62:	f8 cf       	rjmp	.-16     	; 0x2c54 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x3a>
    uint8_t dinByte = 0;
    
	// Makes is easy to toggle between receiveing x and y coordinates
    if (coord == 'X')
    {
        dinByte = dinXByte;
    2c64:	fc 01       	movw	r30, r24
    2c66:	70 80       	ld	r7, Z
    else{
        return 255;
    }
    
    // ChipSelect Set to 0    
    CS_PORT &= ~CS_PIN;
    2c68:	73 98       	cbi	0x0e, 3	; 14
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    2c6a:	fa e2       	ldi	r31, 0x2A	; 42
    2c6c:	fa 95       	dec	r31
    2c6e:	f1 f7       	brne	.-4      	; 0x2c6c <_ZN11TouchDriver14getCoordinatesEPhS0_+0x52>
    2c70:	00 c0       	rjmp	.+0      	; 0x2c72 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x58>
    2c72:	27 2d       	mov	r18, r7
    2c74:	30 e0       	ldi	r19, 0x00	; 0
    2c76:	ea e2       	ldi	r30, 0x2A	; 42
    2c78:	ea 95       	dec	r30
    2c7a:	f1 f7       	brne	.-4      	; 0x2c78 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x5e>
    2c7c:	00 c0       	rjmp	.+0      	; 0x2c7e <_ZN11TouchDriver14getCoordinatesEPhS0_+0x64>
    // DIN byte and pulse DCLK for Read X
    for (int i = 7; i >= 0; i--)
    {
        _delay_us(delayTime);
        
        DIN_PORT |= (((dinByte >> i)  & 0x01) << 5);
    2c7e:	64 b2       	in	r6, 0x14	; 20
    2c80:	69 01       	movw	r12, r18
    2c82:	cc 0c       	add	r12, r12
    2c84:	cd 2c       	mov	r12, r13
    2c86:	cc 1c       	adc	r12, r12
    2c88:	dd 08       	sbc	r13, r13
    2c8a:	cc 0c       	add	r12, r12
    2c8c:	dd 1c       	adc	r13, r13
    2c8e:	c2 94       	swap	r12
    2c90:	d2 94       	swap	r13
    2c92:	e0 ef       	ldi	r30, 0xF0	; 240
    2c94:	de 22       	and	r13, r30
    2c96:	dc 24       	eor	r13, r12
    2c98:	ce 22       	and	r12, r30
    2c9a:	dc 24       	eor	r13, r12
    2c9c:	c6 28       	or	r12, r6
    2c9e:	c4 ba       	out	0x14, r12	; 20
        
        CLK_PORT |= CLK_PIN;
    2ca0:	30 91 02 01 	lds	r19, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    2ca4:	38 60       	ori	r19, 0x08	; 8
    2ca6:	30 93 02 01 	sts	0x0102, r19	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    2caa:	fa e2       	ldi	r31, 0x2A	; 42
    2cac:	fa 95       	dec	r31
    2cae:	f1 f7       	brne	.-4      	; 0x2cac <_ZN11TouchDriver14getCoordinatesEPhS0_+0x92>
    2cb0:	00 c0       	rjmp	.+0      	; 0x2cb2 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x98>
		
        _delay_us(delayTime);
        
        CLK_PORT &= ~CLK_PIN;
    2cb2:	30 91 02 01 	lds	r19, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    2cb6:	37 7f       	andi	r19, 0xF7	; 247
    2cb8:	30 93 02 01 	sts	0x0102, r19	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
        DIN_PORT &= ~BIT6_SHIFTED;
    2cbc:	a5 98       	cbi	0x14, 5	; 20
    2cbe:	ea e2       	ldi	r30, 0x2A	; 42
    2cc0:	ea 95       	dec	r30
    2cc2:	f1 f7       	brne	.-4      	; 0x2cc0 <_ZN11TouchDriver14getCoordinatesEPhS0_+0xa6>
    2cc4:	00 c0       	rjmp	.+0      	; 0x2cc6 <_ZN11TouchDriver14getCoordinatesEPhS0_+0xac>
    // DIN byte and pulse DCLK for Read X
    for (int i = 7; i >= 0; i--)
    {
        _delay_us(delayTime);
        
        DIN_PORT |= (((dinByte >> i)  & 0x01) << 5);
    2cc6:	34 b3       	in	r19, 0x14	; 20
    2cc8:	76 fa       	bst	r7, 6
    2cca:	ee 24       	eor	r14, r14
    2ccc:	e0 f8       	bld	r14, 0
    2cce:	f1 2c       	mov	r15, r1
    2cd0:	ee 0c       	add	r14, r14
    2cd2:	ff 1c       	adc	r15, r15
    2cd4:	e2 94       	swap	r14
    2cd6:	f2 94       	swap	r15
    2cd8:	f0 ef       	ldi	r31, 0xF0	; 240
    2cda:	ff 22       	and	r15, r31
    2cdc:	fe 24       	eor	r15, r14
    2cde:	ef 22       	and	r14, r31
    2ce0:	fe 24       	eor	r15, r14
    2ce2:	e3 2a       	or	r14, r19
    2ce4:	e4 ba       	out	0x14, r14	; 20
        
        CLK_PORT |= CLK_PIN;
    2ce6:	30 91 02 01 	lds	r19, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    2cea:	38 60       	ori	r19, 0x08	; 8
    2cec:	30 93 02 01 	sts	0x0102, r19	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    2cf0:	fa e2       	ldi	r31, 0x2A	; 42
    2cf2:	fa 95       	dec	r31
    2cf4:	f1 f7       	brne	.-4      	; 0x2cf2 <_ZN11TouchDriver14getCoordinatesEPhS0_+0xd8>
    2cf6:	00 c0       	rjmp	.+0      	; 0x2cf8 <_ZN11TouchDriver14getCoordinatesEPhS0_+0xde>
		
        _delay_us(delayTime);
        
        CLK_PORT &= ~CLK_PIN;
    2cf8:	30 91 02 01 	lds	r19, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    2cfc:	37 7f       	andi	r19, 0xF7	; 247
    2cfe:	30 93 02 01 	sts	0x0102, r19	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
        DIN_PORT &= ~BIT6_SHIFTED;
    2d02:	a5 98       	cbi	0x14, 5	; 20
    2d04:	ea e2       	ldi	r30, 0x2A	; 42
    2d06:	ea 95       	dec	r30
    2d08:	f1 f7       	brne	.-4      	; 0x2d06 <_ZN11TouchDriver14getCoordinatesEPhS0_+0xec>
    2d0a:	00 c0       	rjmp	.+0      	; 0x2d0c <_ZN11TouchDriver14getCoordinatesEPhS0_+0xf2>
    // DIN byte and pulse DCLK for Read X
    for (int i = 7; i >= 0; i--)
    {
        _delay_us(delayTime);
        
        DIN_PORT |= (((dinByte >> i)  & 0x01) << 5);
    2d0c:	34 b3       	in	r19, 0x14	; 20
    2d0e:	75 fa       	bst	r7, 5
    2d10:	00 27       	eor	r16, r16
    2d12:	00 f9       	bld	r16, 0
    2d14:	10 e0       	ldi	r17, 0x00	; 0
    2d16:	00 0f       	add	r16, r16
    2d18:	11 1f       	adc	r17, r17
    2d1a:	02 95       	swap	r16
    2d1c:	12 95       	swap	r17
    2d1e:	10 7f       	andi	r17, 0xF0	; 240
    2d20:	10 27       	eor	r17, r16
    2d22:	00 7f       	andi	r16, 0xF0	; 240
    2d24:	10 27       	eor	r17, r16
    2d26:	03 2b       	or	r16, r19
    2d28:	04 bb       	out	0x14, r16	; 20
        
        CLK_PORT |= CLK_PIN;
    2d2a:	30 91 02 01 	lds	r19, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    2d2e:	38 60       	ori	r19, 0x08	; 8
    2d30:	30 93 02 01 	sts	0x0102, r19	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    2d34:	fa e2       	ldi	r31, 0x2A	; 42
    2d36:	fa 95       	dec	r31
    2d38:	f1 f7       	brne	.-4      	; 0x2d36 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x11c>
    2d3a:	00 c0       	rjmp	.+0      	; 0x2d3c <_ZN11TouchDriver14getCoordinatesEPhS0_+0x122>
		
        _delay_us(delayTime);
        
        CLK_PORT &= ~CLK_PIN;
    2d3c:	30 91 02 01 	lds	r19, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    2d40:	37 7f       	andi	r19, 0xF7	; 247
    2d42:	30 93 02 01 	sts	0x0102, r19	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
        DIN_PORT &= ~BIT6_SHIFTED;
    2d46:	a5 98       	cbi	0x14, 5	; 20
    2d48:	ea e2       	ldi	r30, 0x2A	; 42
    2d4a:	ea 95       	dec	r30
    2d4c:	f1 f7       	brne	.-4      	; 0x2d4a <_ZN11TouchDriver14getCoordinatesEPhS0_+0x130>
    2d4e:	00 c0       	rjmp	.+0      	; 0x2d50 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x136>
    // DIN byte and pulse DCLK for Read X
    for (int i = 7; i >= 0; i--)
    {
        _delay_us(delayTime);
        
        DIN_PORT |= (((dinByte >> i)  & 0x01) << 5);
    2d50:	34 b3       	in	r19, 0x14	; 20
    2d52:	74 fa       	bst	r7, 4
    2d54:	ff 27       	eor	r31, r31
    2d56:	f0 f9       	bld	r31, 0
    2d58:	fc a3       	std	Y+36, r31	; 0x24
    2d5a:	1d a2       	std	Y+37, r1	; 0x25
    2d5c:	ec a1       	ldd	r30, Y+36	; 0x24
    2d5e:	fd a1       	ldd	r31, Y+37	; 0x25
    2d60:	ee 0f       	add	r30, r30
    2d62:	ff 1f       	adc	r31, r31
    2d64:	e2 95       	swap	r30
    2d66:	f2 95       	swap	r31
    2d68:	f0 7f       	andi	r31, 0xF0	; 240
    2d6a:	fe 27       	eor	r31, r30
    2d6c:	e0 7f       	andi	r30, 0xF0	; 240
    2d6e:	fe 27       	eor	r31, r30
    2d70:	fd a3       	std	Y+37, r31	; 0x25
    2d72:	ec a3       	std	Y+36, r30	; 0x24
    2d74:	e3 2b       	or	r30, r19
    2d76:	e4 bb       	out	0x14, r30	; 20
        
        CLK_PORT |= CLK_PIN;
    2d78:	30 91 02 01 	lds	r19, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    2d7c:	38 60       	ori	r19, 0x08	; 8
    2d7e:	30 93 02 01 	sts	0x0102, r19	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    2d82:	fa e2       	ldi	r31, 0x2A	; 42
    2d84:	fa 95       	dec	r31
    2d86:	f1 f7       	brne	.-4      	; 0x2d84 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x16a>
    2d88:	00 c0       	rjmp	.+0      	; 0x2d8a <_ZN11TouchDriver14getCoordinatesEPhS0_+0x170>
		
        _delay_us(delayTime);
        
        CLK_PORT &= ~CLK_PIN;
    2d8a:	30 91 02 01 	lds	r19, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    2d8e:	37 7f       	andi	r19, 0xF7	; 247
    2d90:	30 93 02 01 	sts	0x0102, r19	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
        DIN_PORT &= ~BIT6_SHIFTED;
    2d94:	a5 98       	cbi	0x14, 5	; 20
    2d96:	ea e2       	ldi	r30, 0x2A	; 42
    2d98:	ea 95       	dec	r30
    2d9a:	f1 f7       	brne	.-4      	; 0x2d98 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x17e>
    2d9c:	00 c0       	rjmp	.+0      	; 0x2d9e <_ZN11TouchDriver14getCoordinatesEPhS0_+0x184>
    // DIN byte and pulse DCLK for Read X
    for (int i = 7; i >= 0; i--)
    {
        _delay_us(delayTime);
        
        DIN_PORT |= (((dinByte >> i)  & 0x01) << 5);
    2d9e:	34 b3       	in	r19, 0x14	; 20
    2da0:	73 fa       	bst	r7, 3
    2da2:	aa 27       	eor	r26, r26
    2da4:	a0 f9       	bld	r26, 0
    2da6:	b0 e0       	ldi	r27, 0x00	; 0
    2da8:	aa 0f       	add	r26, r26
    2daa:	bb 1f       	adc	r27, r27
    2dac:	a2 95       	swap	r26
    2dae:	b2 95       	swap	r27
    2db0:	b0 7f       	andi	r27, 0xF0	; 240
    2db2:	ba 27       	eor	r27, r26
    2db4:	a0 7f       	andi	r26, 0xF0	; 240
    2db6:	ba 27       	eor	r27, r26
    2db8:	a3 2b       	or	r26, r19
    2dba:	a4 bb       	out	0x14, r26	; 20
        
        CLK_PORT |= CLK_PIN;
    2dbc:	30 91 02 01 	lds	r19, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    2dc0:	38 60       	ori	r19, 0x08	; 8
    2dc2:	30 93 02 01 	sts	0x0102, r19	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    2dc6:	fa e2       	ldi	r31, 0x2A	; 42
    2dc8:	fa 95       	dec	r31
    2dca:	f1 f7       	brne	.-4      	; 0x2dc8 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x1ae>
    2dcc:	00 c0       	rjmp	.+0      	; 0x2dce <_ZN11TouchDriver14getCoordinatesEPhS0_+0x1b4>
		
        _delay_us(delayTime);
        
        CLK_PORT &= ~CLK_PIN;
    2dce:	30 91 02 01 	lds	r19, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    2dd2:	37 7f       	andi	r19, 0xF7	; 247
    2dd4:	30 93 02 01 	sts	0x0102, r19	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
        DIN_PORT &= ~BIT6_SHIFTED;
    2dd8:	a5 98       	cbi	0x14, 5	; 20
    2dda:	ea e2       	ldi	r30, 0x2A	; 42
    2ddc:	ea 95       	dec	r30
    2dde:	f1 f7       	brne	.-4      	; 0x2ddc <_ZN11TouchDriver14getCoordinatesEPhS0_+0x1c2>
    2de0:	00 c0       	rjmp	.+0      	; 0x2de2 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x1c8>
    // DIN byte and pulse DCLK for Read X
    for (int i = 7; i >= 0; i--)
    {
        _delay_us(delayTime);
        
        DIN_PORT |= (((dinByte >> i)  & 0x01) << 5);
    2de2:	34 b3       	in	r19, 0x14	; 20
    2de4:	72 fa       	bst	r7, 2
    2de6:	ee 27       	eor	r30, r30
    2de8:	e0 f9       	bld	r30, 0
    2dea:	f0 e0       	ldi	r31, 0x00	; 0
    2dec:	ee 0f       	add	r30, r30
    2dee:	ff 1f       	adc	r31, r31
    2df0:	e2 95       	swap	r30
    2df2:	f2 95       	swap	r31
    2df4:	f0 7f       	andi	r31, 0xF0	; 240
    2df6:	fe 27       	eor	r31, r30
    2df8:	e0 7f       	andi	r30, 0xF0	; 240
    2dfa:	fe 27       	eor	r31, r30
    2dfc:	e3 2b       	or	r30, r19
    2dfe:	e4 bb       	out	0x14, r30	; 20
        
        CLK_PORT |= CLK_PIN;
    2e00:	30 91 02 01 	lds	r19, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    2e04:	38 60       	ori	r19, 0x08	; 8
    2e06:	30 93 02 01 	sts	0x0102, r19	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    2e0a:	fa e2       	ldi	r31, 0x2A	; 42
    2e0c:	fa 95       	dec	r31
    2e0e:	f1 f7       	brne	.-4      	; 0x2e0c <_ZN11TouchDriver14getCoordinatesEPhS0_+0x1f2>
    2e10:	00 c0       	rjmp	.+0      	; 0x2e12 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x1f8>
		
        _delay_us(delayTime);
        
        CLK_PORT &= ~CLK_PIN;
    2e12:	30 91 02 01 	lds	r19, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    2e16:	37 7f       	andi	r19, 0xF7	; 247
    2e18:	30 93 02 01 	sts	0x0102, r19	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
        DIN_PORT &= ~BIT6_SHIFTED;
    2e1c:	a5 98       	cbi	0x14, 5	; 20
    2e1e:	ea e2       	ldi	r30, 0x2A	; 42
    2e20:	ea 95       	dec	r30
    2e22:	f1 f7       	brne	.-4      	; 0x2e20 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x206>
    2e24:	00 c0       	rjmp	.+0      	; 0x2e26 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x20c>
    // DIN byte and pulse DCLK for Read X
    for (int i = 7; i >= 0; i--)
    {
        _delay_us(delayTime);
        
        DIN_PORT |= (((dinByte >> i)  & 0x01) << 5);
    2e26:	34 b3       	in	r19, 0x14	; 20
    2e28:	71 fa       	bst	r7, 1
    2e2a:	aa 24       	eor	r10, r10
    2e2c:	a0 f8       	bld	r10, 0
    2e2e:	b1 2c       	mov	r11, r1
    2e30:	aa 0c       	add	r10, r10
    2e32:	bb 1c       	adc	r11, r11
    2e34:	a2 94       	swap	r10
    2e36:	b2 94       	swap	r11
    2e38:	20 ef       	ldi	r18, 0xF0	; 240
    2e3a:	b2 22       	and	r11, r18
    2e3c:	ba 24       	eor	r11, r10
    2e3e:	a2 22       	and	r10, r18
    2e40:	ba 24       	eor	r11, r10
    2e42:	a3 2a       	or	r10, r19
    2e44:	a4 ba       	out	0x14, r10	; 20
        
        CLK_PORT |= CLK_PIN;
    2e46:	20 91 02 01 	lds	r18, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    2e4a:	28 60       	ori	r18, 0x08	; 8
    2e4c:	20 93 02 01 	sts	0x0102, r18	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    2e50:	fa e2       	ldi	r31, 0x2A	; 42
    2e52:	fa 95       	dec	r31
    2e54:	f1 f7       	brne	.-4      	; 0x2e52 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x238>
    2e56:	00 c0       	rjmp	.+0      	; 0x2e58 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x23e>
		
        _delay_us(delayTime);
        
        CLK_PORT &= ~CLK_PIN;
    2e58:	20 91 02 01 	lds	r18, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    2e5c:	27 7f       	andi	r18, 0xF7	; 247
    2e5e:	20 93 02 01 	sts	0x0102, r18	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
        DIN_PORT &= ~BIT6_SHIFTED;
    2e62:	a5 98       	cbi	0x14, 5	; 20
    2e64:	2a e2       	ldi	r18, 0x2A	; 42
    2e66:	2a 95       	dec	r18
    2e68:	f1 f7       	brne	.-4      	; 0x2e66 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x24c>
    2e6a:	00 c0       	rjmp	.+0      	; 0x2e6c <_ZN11TouchDriver14getCoordinatesEPhS0_+0x252>
    // DIN byte and pulse DCLK for Read X
    for (int i = 7; i >= 0; i--)
    {
        _delay_us(delayTime);
        
        DIN_PORT |= (((dinByte >> i)  & 0x01) << 5);
    2e6c:	24 b3       	in	r18, 0x14	; 20
    2e6e:	70 fa       	bst	r7, 0
    2e70:	88 24       	eor	r8, r8
    2e72:	80 f8       	bld	r8, 0
    2e74:	91 2c       	mov	r9, r1
    2e76:	88 0c       	add	r8, r8
    2e78:	99 1c       	adc	r9, r9
    2e7a:	82 94       	swap	r8
    2e7c:	92 94       	swap	r9
    2e7e:	30 ef       	ldi	r19, 0xF0	; 240
    2e80:	93 22       	and	r9, r19
    2e82:	98 24       	eor	r9, r8
    2e84:	83 22       	and	r8, r19
    2e86:	98 24       	eor	r9, r8
    2e88:	82 2a       	or	r8, r18
    2e8a:	84 ba       	out	0x14, r8	; 20
        
        CLK_PORT |= CLK_PIN;
    2e8c:	20 91 02 01 	lds	r18, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    2e90:	28 60       	ori	r18, 0x08	; 8
    2e92:	20 93 02 01 	sts	0x0102, r18	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    2e96:	3a e2       	ldi	r19, 0x2A	; 42
    2e98:	3a 95       	dec	r19
    2e9a:	f1 f7       	brne	.-4      	; 0x2e98 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x27e>
    2e9c:	00 c0       	rjmp	.+0      	; 0x2e9e <_ZN11TouchDriver14getCoordinatesEPhS0_+0x284>
		
        _delay_us(delayTime);
        
        CLK_PORT &= ~CLK_PIN;
    2e9e:	20 91 02 01 	lds	r18, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    2ea2:	27 7f       	andi	r18, 0xF7	; 247
    2ea4:	20 93 02 01 	sts	0x0102, r18	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
        DIN_PORT &= ~BIT6_SHIFTED;
    2ea8:	a5 98       	cbi	0x14, 5	; 20
    2eaa:	ea e2       	ldi	r30, 0x2A	; 42
    2eac:	ea 95       	dec	r30
    2eae:	f1 f7       	brne	.-4      	; 0x2eac <_ZN11TouchDriver14getCoordinatesEPhS0_+0x292>
    2eb0:	00 c0       	rjmp	.+0      	; 0x2eb2 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x298>
    // Systematically read DOUT
    for (int i = 7; i >= 0; i--)
    {
        _delay_us(delayTime);
        
        CLK_PORT |= CLK_PIN;
    2eb2:	20 91 02 01 	lds	r18, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    2eb6:	28 60       	ori	r18, 0x08	; 8
    2eb8:	20 93 02 01 	sts	0x0102, r18	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    2ebc:	fa e2       	ldi	r31, 0x2A	; 42
    2ebe:	fa 95       	dec	r31
    2ec0:	f1 f7       	brne	.-4      	; 0x2ebe <_ZN11TouchDriver14getCoordinatesEPhS0_+0x2a4>
    2ec2:	00 c0       	rjmp	.+0      	; 0x2ec4 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x2aa>
        _delay_us(delayTime);
        CLK_PORT &= ~CLK_PIN;
    2ec4:	20 91 02 01 	lds	r18, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    2ec8:	27 7f       	andi	r18, 0xF7	; 247
    2eca:	20 93 02 01 	sts	0x0102, r18	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    2ece:	25 e0       	ldi	r18, 0x05	; 5
    2ed0:	2a 95       	dec	r18
    2ed2:	f1 f7       	brne	.-4      	; 0x2ed0 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x2b6>
    2ed4:	00 00       	nop
        _delay_us(1);
        
        bool temp = (PINE & (1U << 5));
    2ed6:	2c b1       	in	r18, 0x0c	; 12
    2ed8:	3a e2       	ldi	r19, 0x2A	; 42
    2eda:	3a 95       	dec	r19
    2edc:	f1 f7       	brne	.-4      	; 0x2eda <_ZN11TouchDriver14getCoordinatesEPhS0_+0x2c0>
    2ede:	00 c0       	rjmp	.+0      	; 0x2ee0 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x2c6>
    // Systematically read DOUT
    for (int i = 7; i >= 0; i--)
    {
        _delay_us(delayTime);
        
        CLK_PORT |= CLK_PIN;
    2ee0:	30 91 02 01 	lds	r19, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    2ee4:	38 60       	ori	r19, 0x08	; 8
    2ee6:	30 93 02 01 	sts	0x0102, r19	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    2eea:	ea e2       	ldi	r30, 0x2A	; 42
    2eec:	ea 95       	dec	r30
    2eee:	f1 f7       	brne	.-4      	; 0x2eec <_ZN11TouchDriver14getCoordinatesEPhS0_+0x2d2>
    2ef0:	00 c0       	rjmp	.+0      	; 0x2ef2 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x2d8>
        _delay_us(delayTime);
        CLK_PORT &= ~CLK_PIN;
    2ef2:	30 91 02 01 	lds	r19, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    2ef6:	37 7f       	andi	r19, 0xF7	; 247
    2ef8:	30 93 02 01 	sts	0x0102, r19	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    2efc:	f5 e0       	ldi	r31, 0x05	; 5
    2efe:	fa 95       	dec	r31
    2f00:	f1 f7       	brne	.-4      	; 0x2efe <_ZN11TouchDriver14getCoordinatesEPhS0_+0x2e4>
    2f02:	00 00       	nop
        _delay_us(1);
        
        bool temp = (PINE & (1U << 5));
    2f04:	3c b1       	in	r19, 0x0c	; 12
        
        result |= (temp << i);
    2f06:	35 fb       	bst	r19, 5
    2f08:	44 24       	eor	r4, r4
    2f0a:	40 f8       	bld	r4, 0
    2f0c:	51 2c       	mov	r5, r1
    2f0e:	00 24       	eor	r0, r0
    2f10:	56 94       	lsr	r5
    2f12:	47 94       	ror	r4
    2f14:	07 94       	ror	r0
    2f16:	56 94       	lsr	r5
    2f18:	47 94       	ror	r4
    2f1a:	07 94       	ror	r0
    2f1c:	54 2c       	mov	r5, r4
    2f1e:	40 2c       	mov	r4, r0
    2f20:	25 fb       	bst	r18, 5
    2f22:	22 24       	eor	r2, r2
    2f24:	20 f8       	bld	r2, 0
    2f26:	31 2c       	mov	r3, r1
    2f28:	36 94       	lsr	r3
    2f2a:	32 2c       	mov	r3, r2
    2f2c:	22 24       	eor	r2, r2
    2f2e:	37 94       	ror	r3
    2f30:	27 94       	ror	r2
    2f32:	42 28       	or	r4, r2
    2f34:	2a e2       	ldi	r18, 0x2A	; 42
    2f36:	2a 95       	dec	r18
    2f38:	f1 f7       	brne	.-4      	; 0x2f36 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x31c>
    2f3a:	00 c0       	rjmp	.+0      	; 0x2f3c <_ZN11TouchDriver14getCoordinatesEPhS0_+0x322>
    // Systematically read DOUT
    for (int i = 7; i >= 0; i--)
    {
        _delay_us(delayTime);
        
        CLK_PORT |= CLK_PIN;
    2f3c:	20 91 02 01 	lds	r18, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    2f40:	28 60       	ori	r18, 0x08	; 8
    2f42:	20 93 02 01 	sts	0x0102, r18	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    2f46:	3a e2       	ldi	r19, 0x2A	; 42
    2f48:	3a 95       	dec	r19
    2f4a:	f1 f7       	brne	.-4      	; 0x2f48 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x32e>
    2f4c:	00 c0       	rjmp	.+0      	; 0x2f4e <_ZN11TouchDriver14getCoordinatesEPhS0_+0x334>
        _delay_us(delayTime);
        CLK_PORT &= ~CLK_PIN;
    2f4e:	20 91 02 01 	lds	r18, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    2f52:	27 7f       	andi	r18, 0xF7	; 247
    2f54:	20 93 02 01 	sts	0x0102, r18	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    2f58:	e5 e0       	ldi	r30, 0x05	; 5
    2f5a:	ea 95       	dec	r30
    2f5c:	f1 f7       	brne	.-4      	; 0x2f5a <_ZN11TouchDriver14getCoordinatesEPhS0_+0x340>
    2f5e:	00 00       	nop
        _delay_us(1);
        
        bool temp = (PINE & (1U << 5));
    2f60:	2c b1       	in	r18, 0x0c	; 12
        
        result |= (temp << i);
    2f62:	20 72       	andi	r18, 0x20	; 32
    2f64:	42 2a       	or	r4, r18
    2f66:	fa e2       	ldi	r31, 0x2A	; 42
    2f68:	fa 95       	dec	r31
    2f6a:	f1 f7       	brne	.-4      	; 0x2f68 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x34e>
    2f6c:	00 c0       	rjmp	.+0      	; 0x2f6e <_ZN11TouchDriver14getCoordinatesEPhS0_+0x354>
    // Systematically read DOUT
    for (int i = 7; i >= 0; i--)
    {
        _delay_us(delayTime);
        
        CLK_PORT |= CLK_PIN;
    2f6e:	20 91 02 01 	lds	r18, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    2f72:	28 60       	ori	r18, 0x08	; 8
    2f74:	20 93 02 01 	sts	0x0102, r18	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    2f78:	2a e2       	ldi	r18, 0x2A	; 42
    2f7a:	2a 95       	dec	r18
    2f7c:	f1 f7       	brne	.-4      	; 0x2f7a <_ZN11TouchDriver14getCoordinatesEPhS0_+0x360>
    2f7e:	00 c0       	rjmp	.+0      	; 0x2f80 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x366>
        _delay_us(delayTime);
        CLK_PORT &= ~CLK_PIN;
    2f80:	20 91 02 01 	lds	r18, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    2f84:	27 7f       	andi	r18, 0xF7	; 247
    2f86:	20 93 02 01 	sts	0x0102, r18	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    2f8a:	35 e0       	ldi	r19, 0x05	; 5
    2f8c:	3a 95       	dec	r19
    2f8e:	f1 f7       	brne	.-4      	; 0x2f8c <_ZN11TouchDriver14getCoordinatesEPhS0_+0x372>
    2f90:	00 00       	nop
        _delay_us(1);
        
        bool temp = (PINE & (1U << 5));
    2f92:	2c b1       	in	r18, 0x0c	; 12
        
        result |= (temp << i);
    2f94:	25 fb       	bst	r18, 5
    2f96:	22 27       	eor	r18, r18
    2f98:	20 f9       	bld	r18, 0
    2f9a:	29 83       	std	Y+1, r18	; 0x01
    2f9c:	1a 82       	std	Y+2, r1	; 0x02
    2f9e:	29 81       	ldd	r18, Y+1	; 0x01
    2fa0:	3a 81       	ldd	r19, Y+2	; 0x02
    2fa2:	22 95       	swap	r18
    2fa4:	32 95       	swap	r19
    2fa6:	30 7f       	andi	r19, 0xF0	; 240
    2fa8:	32 27       	eor	r19, r18
    2faa:	20 7f       	andi	r18, 0xF0	; 240
    2fac:	32 27       	eor	r19, r18
    2fae:	42 2a       	or	r4, r18
    2fb0:	ea e2       	ldi	r30, 0x2A	; 42
    2fb2:	ea 95       	dec	r30
    2fb4:	f1 f7       	brne	.-4      	; 0x2fb2 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x398>
    2fb6:	00 c0       	rjmp	.+0      	; 0x2fb8 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x39e>
    // Systematically read DOUT
    for (int i = 7; i >= 0; i--)
    {
        _delay_us(delayTime);
        
        CLK_PORT |= CLK_PIN;
    2fb8:	20 91 02 01 	lds	r18, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    2fbc:	28 60       	ori	r18, 0x08	; 8
    2fbe:	20 93 02 01 	sts	0x0102, r18	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    2fc2:	fa e2       	ldi	r31, 0x2A	; 42
    2fc4:	fa 95       	dec	r31
    2fc6:	f1 f7       	brne	.-4      	; 0x2fc4 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x3aa>
    2fc8:	00 c0       	rjmp	.+0      	; 0x2fca <_ZN11TouchDriver14getCoordinatesEPhS0_+0x3b0>
        _delay_us(delayTime);
        CLK_PORT &= ~CLK_PIN;
    2fca:	20 91 02 01 	lds	r18, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    2fce:	27 7f       	andi	r18, 0xF7	; 247
    2fd0:	20 93 02 01 	sts	0x0102, r18	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    2fd4:	25 e0       	ldi	r18, 0x05	; 5
    2fd6:	2a 95       	dec	r18
    2fd8:	f1 f7       	brne	.-4      	; 0x2fd6 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x3bc>
    2fda:	00 00       	nop
        _delay_us(1);
        
        bool temp = (PINE & (1U << 5));
    2fdc:	2c b1       	in	r18, 0x0c	; 12
        
        result |= (temp << i);
    2fde:	25 fb       	bst	r18, 5
    2fe0:	22 27       	eor	r18, r18
    2fe2:	20 f9       	bld	r18, 0
    2fe4:	2b 83       	std	Y+3, r18	; 0x03
    2fe6:	1c 82       	std	Y+4, r1	; 0x04
    2fe8:	eb 81       	ldd	r30, Y+3	; 0x03
    2fea:	fc 81       	ldd	r31, Y+4	; 0x04
    2fec:	ee 0f       	add	r30, r30
    2fee:	ff 1f       	adc	r31, r31
    2ff0:	ee 0f       	add	r30, r30
    2ff2:	ff 1f       	adc	r31, r31
    2ff4:	ee 0f       	add	r30, r30
    2ff6:	ff 1f       	adc	r31, r31
    2ff8:	4e 2a       	or	r4, r30
    2ffa:	3a e2       	ldi	r19, 0x2A	; 42
    2ffc:	3a 95       	dec	r19
    2ffe:	f1 f7       	brne	.-4      	; 0x2ffc <_ZN11TouchDriver14getCoordinatesEPhS0_+0x3e2>
    3000:	00 c0       	rjmp	.+0      	; 0x3002 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x3e8>
    // Systematically read DOUT
    for (int i = 7; i >= 0; i--)
    {
        _delay_us(delayTime);
        
        CLK_PORT |= CLK_PIN;
    3002:	20 91 02 01 	lds	r18, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    3006:	28 60       	ori	r18, 0x08	; 8
    3008:	20 93 02 01 	sts	0x0102, r18	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    300c:	ea e2       	ldi	r30, 0x2A	; 42
    300e:	ea 95       	dec	r30
    3010:	f1 f7       	brne	.-4      	; 0x300e <_ZN11TouchDriver14getCoordinatesEPhS0_+0x3f4>
    3012:	00 c0       	rjmp	.+0      	; 0x3014 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x3fa>
        _delay_us(delayTime);
        CLK_PORT &= ~CLK_PIN;
    3014:	20 91 02 01 	lds	r18, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    3018:	27 7f       	andi	r18, 0xF7	; 247
    301a:	20 93 02 01 	sts	0x0102, r18	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    301e:	f5 e0       	ldi	r31, 0x05	; 5
    3020:	fa 95       	dec	r31
    3022:	f1 f7       	brne	.-4      	; 0x3020 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x406>
    3024:	00 00       	nop
        _delay_us(1);
        
        bool temp = (PINE & (1U << 5));
    3026:	2c b1       	in	r18, 0x0c	; 12
        
        result |= (temp << i);
    3028:	25 fb       	bst	r18, 5
    302a:	22 27       	eor	r18, r18
    302c:	20 f9       	bld	r18, 0
    302e:	2d 83       	std	Y+5, r18	; 0x05
    3030:	1e 82       	std	Y+6, r1	; 0x06
    3032:	ad 81       	ldd	r26, Y+5	; 0x05
    3034:	be 81       	ldd	r27, Y+6	; 0x06
    3036:	aa 0f       	add	r26, r26
    3038:	bb 1f       	adc	r27, r27
    303a:	aa 0f       	add	r26, r26
    303c:	bb 1f       	adc	r27, r27
    303e:	4a 2a       	or	r4, r26
    3040:	2a e2       	ldi	r18, 0x2A	; 42
    3042:	2a 95       	dec	r18
    3044:	f1 f7       	brne	.-4      	; 0x3042 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x428>
    3046:	00 c0       	rjmp	.+0      	; 0x3048 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x42e>
    // Systematically read DOUT
    for (int i = 7; i >= 0; i--)
    {
        _delay_us(delayTime);
        
        CLK_PORT |= CLK_PIN;
    3048:	20 91 02 01 	lds	r18, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    304c:	28 60       	ori	r18, 0x08	; 8
    304e:	20 93 02 01 	sts	0x0102, r18	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    3052:	3a e2       	ldi	r19, 0x2A	; 42
    3054:	3a 95       	dec	r19
    3056:	f1 f7       	brne	.-4      	; 0x3054 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x43a>
    3058:	00 c0       	rjmp	.+0      	; 0x305a <_ZN11TouchDriver14getCoordinatesEPhS0_+0x440>
        _delay_us(delayTime);
        CLK_PORT &= ~CLK_PIN;
    305a:	20 91 02 01 	lds	r18, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    305e:	27 7f       	andi	r18, 0xF7	; 247
    3060:	20 93 02 01 	sts	0x0102, r18	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    3064:	e5 e0       	ldi	r30, 0x05	; 5
    3066:	ea 95       	dec	r30
    3068:	f1 f7       	brne	.-4      	; 0x3066 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x44c>
    306a:	00 00       	nop
        _delay_us(1);
        
        bool temp = (PINE & (1U << 5));
    306c:	2c b1       	in	r18, 0x0c	; 12
        
        result |= (temp << i);
    306e:	25 fb       	bst	r18, 5
    3070:	22 27       	eor	r18, r18
    3072:	20 f9       	bld	r18, 0
    3074:	2f 83       	std	Y+7, r18	; 0x07
    3076:	18 86       	std	Y+8, r1	; 0x08
    3078:	2f 81       	ldd	r18, Y+7	; 0x07
    307a:	38 85       	ldd	r19, Y+8	; 0x08
    307c:	22 0f       	add	r18, r18
    307e:	33 1f       	adc	r19, r19
    3080:	3a 83       	std	Y+2, r19	; 0x02
    3082:	29 83       	std	Y+1, r18	; 0x01
    3084:	24 29       	or	r18, r4
    3086:	29 83       	std	Y+1, r18	; 0x01
    3088:	3a e2       	ldi	r19, 0x2A	; 42
    308a:	3a 95       	dec	r19
    308c:	f1 f7       	brne	.-4      	; 0x308a <_ZN11TouchDriver14getCoordinatesEPhS0_+0x470>
    308e:	00 c0       	rjmp	.+0      	; 0x3090 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x476>
    // Systematically read DOUT
    for (int i = 7; i >= 0; i--)
    {
        _delay_us(delayTime);
        
        CLK_PORT |= CLK_PIN;
    3090:	20 91 02 01 	lds	r18, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    3094:	28 60       	ori	r18, 0x08	; 8
    3096:	20 93 02 01 	sts	0x0102, r18	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    309a:	ea e2       	ldi	r30, 0x2A	; 42
    309c:	ea 95       	dec	r30
    309e:	f1 f7       	brne	.-4      	; 0x309c <_ZN11TouchDriver14getCoordinatesEPhS0_+0x482>
    30a0:	00 c0       	rjmp	.+0      	; 0x30a2 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x488>
        _delay_us(delayTime);
        CLK_PORT &= ~CLK_PIN;
    30a2:	20 91 02 01 	lds	r18, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    30a6:	27 7f       	andi	r18, 0xF7	; 247
    30a8:	20 93 02 01 	sts	0x0102, r18	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    30ac:	f5 e0       	ldi	r31, 0x05	; 5
    30ae:	fa 95       	dec	r31
    30b0:	f1 f7       	brne	.-4      	; 0x30ae <_ZN11TouchDriver14getCoordinatesEPhS0_+0x494>
    30b2:	00 00       	nop
        _delay_us(1);
        
        bool temp = (PINE & (1U << 5));
    30b4:	4c b0       	in	r4, 0x0c	; 12
    30b6:	2a e2       	ldi	r18, 0x2A	; 42
    30b8:	2a 95       	dec	r18
    30ba:	f1 f7       	brne	.-4      	; 0x30b8 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x49e>
    30bc:	00 c0       	rjmp	.+0      	; 0x30be <_ZN11TouchDriver14getCoordinatesEPhS0_+0x4a4>
    
    for (int i = 7; i >= 0; i--)
    {
        
        _delay_us(delayTime);
        CLK_PORT |= CLK_PIN;
    30be:	20 91 02 01 	lds	r18, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    30c2:	28 60       	ori	r18, 0x08	; 8
    30c4:	20 93 02 01 	sts	0x0102, r18	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    30c8:	3a e2       	ldi	r19, 0x2A	; 42
    30ca:	3a 95       	dec	r19
    30cc:	f1 f7       	brne	.-4      	; 0x30ca <_ZN11TouchDriver14getCoordinatesEPhS0_+0x4b0>
    30ce:	00 c0       	rjmp	.+0      	; 0x30d0 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x4b6>
        _delay_us(delayTime);
        CLK_PORT &= ~CLK_PIN;
    30d0:	20 91 02 01 	lds	r18, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    30d4:	27 7f       	andi	r18, 0xF7	; 247
    30d6:	20 93 02 01 	sts	0x0102, r18	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    30da:	ea e2       	ldi	r30, 0x2A	; 42
    30dc:	ea 95       	dec	r30
    30de:	f1 f7       	brne	.-4      	; 0x30dc <_ZN11TouchDriver14getCoordinatesEPhS0_+0x4c2>
    30e0:	00 c0       	rjmp	.+0      	; 0x30e2 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x4c8>
    
    for (int i = 7; i >= 0; i--)
    {
        
        _delay_us(delayTime);
        CLK_PORT |= CLK_PIN;
    30e2:	20 91 02 01 	lds	r18, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    30e6:	28 60       	ori	r18, 0x08	; 8
    30e8:	20 93 02 01 	sts	0x0102, r18	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    30ec:	fa e2       	ldi	r31, 0x2A	; 42
    30ee:	fa 95       	dec	r31
    30f0:	f1 f7       	brne	.-4      	; 0x30ee <_ZN11TouchDriver14getCoordinatesEPhS0_+0x4d4>
    30f2:	00 c0       	rjmp	.+0      	; 0x30f4 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x4da>
        _delay_us(delayTime);
        CLK_PORT &= ~CLK_PIN;
    30f4:	20 91 02 01 	lds	r18, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    30f8:	27 7f       	andi	r18, 0xF7	; 247
    30fa:	20 93 02 01 	sts	0x0102, r18	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    30fe:	2a e2       	ldi	r18, 0x2A	; 42
    3100:	2a 95       	dec	r18
    3102:	f1 f7       	brne	.-4      	; 0x3100 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x4e6>
    3104:	00 c0       	rjmp	.+0      	; 0x3106 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x4ec>
    
    for (int i = 7; i >= 0; i--)
    {
        
        _delay_us(delayTime);
        CLK_PORT |= CLK_PIN;
    3106:	20 91 02 01 	lds	r18, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    310a:	28 60       	ori	r18, 0x08	; 8
    310c:	20 93 02 01 	sts	0x0102, r18	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    3110:	3a e2       	ldi	r19, 0x2A	; 42
    3112:	3a 95       	dec	r19
    3114:	f1 f7       	brne	.-4      	; 0x3112 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x4f8>
    3116:	00 c0       	rjmp	.+0      	; 0x3118 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x4fe>
        _delay_us(delayTime);
        CLK_PORT &= ~CLK_PIN;
    3118:	20 91 02 01 	lds	r18, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    311c:	27 7f       	andi	r18, 0xF7	; 247
    311e:	20 93 02 01 	sts	0x0102, r18	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    3122:	ea e2       	ldi	r30, 0x2A	; 42
    3124:	ea 95       	dec	r30
    3126:	f1 f7       	brne	.-4      	; 0x3124 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x50a>
    3128:	00 c0       	rjmp	.+0      	; 0x312a <_ZN11TouchDriver14getCoordinatesEPhS0_+0x510>
    
    for (int i = 7; i >= 0; i--)
    {
        
        _delay_us(delayTime);
        CLK_PORT |= CLK_PIN;
    312a:	20 91 02 01 	lds	r18, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    312e:	28 60       	ori	r18, 0x08	; 8
    3130:	20 93 02 01 	sts	0x0102, r18	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    3134:	fa e2       	ldi	r31, 0x2A	; 42
    3136:	fa 95       	dec	r31
    3138:	f1 f7       	brne	.-4      	; 0x3136 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x51c>
    313a:	00 c0       	rjmp	.+0      	; 0x313c <_ZN11TouchDriver14getCoordinatesEPhS0_+0x522>
        _delay_us(delayTime);
        CLK_PORT &= ~CLK_PIN;
    313c:	20 91 02 01 	lds	r18, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    3140:	27 7f       	andi	r18, 0xF7	; 247
    3142:	20 93 02 01 	sts	0x0102, r18	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    3146:	2a e2       	ldi	r18, 0x2A	; 42
    3148:	2a 95       	dec	r18
    314a:	f1 f7       	brne	.-4      	; 0x3148 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x52e>
    314c:	00 c0       	rjmp	.+0      	; 0x314e <_ZN11TouchDriver14getCoordinatesEPhS0_+0x534>
    
    for (int i = 7; i >= 0; i--)
    {
        
        _delay_us(delayTime);
        CLK_PORT |= CLK_PIN;
    314e:	20 91 02 01 	lds	r18, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    3152:	28 60       	ori	r18, 0x08	; 8
    3154:	20 93 02 01 	sts	0x0102, r18	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    3158:	3a e2       	ldi	r19, 0x2A	; 42
    315a:	3a 95       	dec	r19
    315c:	f1 f7       	brne	.-4      	; 0x315a <_ZN11TouchDriver14getCoordinatesEPhS0_+0x540>
    315e:	00 c0       	rjmp	.+0      	; 0x3160 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x546>
        _delay_us(delayTime);
        CLK_PORT &= ~CLK_PIN;
    3160:	20 91 02 01 	lds	r18, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    3164:	27 7f       	andi	r18, 0xF7	; 247
    3166:	20 93 02 01 	sts	0x0102, r18	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    316a:	ea e2       	ldi	r30, 0x2A	; 42
    316c:	ea 95       	dec	r30
    316e:	f1 f7       	brne	.-4      	; 0x316c <_ZN11TouchDriver14getCoordinatesEPhS0_+0x552>
    3170:	00 c0       	rjmp	.+0      	; 0x3172 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x558>
    
    for (int i = 7; i >= 0; i--)
    {
        
        _delay_us(delayTime);
        CLK_PORT |= CLK_PIN;
    3172:	20 91 02 01 	lds	r18, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    3176:	28 60       	ori	r18, 0x08	; 8
    3178:	20 93 02 01 	sts	0x0102, r18	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    317c:	fa e2       	ldi	r31, 0x2A	; 42
    317e:	fa 95       	dec	r31
    3180:	f1 f7       	brne	.-4      	; 0x317e <_ZN11TouchDriver14getCoordinatesEPhS0_+0x564>
    3182:	00 c0       	rjmp	.+0      	; 0x3184 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x56a>
        _delay_us(delayTime);
        CLK_PORT &= ~CLK_PIN;
    3184:	20 91 02 01 	lds	r18, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    3188:	27 7f       	andi	r18, 0xF7	; 247
    318a:	20 93 02 01 	sts	0x0102, r18	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    318e:	2a e2       	ldi	r18, 0x2A	; 42
    3190:	2a 95       	dec	r18
    3192:	f1 f7       	brne	.-4      	; 0x3190 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x576>
    3194:	00 c0       	rjmp	.+0      	; 0x3196 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x57c>
    
    for (int i = 7; i >= 0; i--)
    {
        
        _delay_us(delayTime);
        CLK_PORT |= CLK_PIN;
    3196:	20 91 02 01 	lds	r18, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    319a:	28 60       	ori	r18, 0x08	; 8
    319c:	20 93 02 01 	sts	0x0102, r18	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    31a0:	3a e2       	ldi	r19, 0x2A	; 42
    31a2:	3a 95       	dec	r19
    31a4:	f1 f7       	brne	.-4      	; 0x31a2 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x588>
    31a6:	00 c0       	rjmp	.+0      	; 0x31a8 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x58e>
        _delay_us(delayTime);
        CLK_PORT &= ~CLK_PIN;
    31a8:	20 91 02 01 	lds	r18, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    31ac:	27 7f       	andi	r18, 0xF7	; 247
    31ae:	20 93 02 01 	sts	0x0102, r18	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    31b2:	ea e2       	ldi	r30, 0x2A	; 42
    31b4:	ea 95       	dec	r30
    31b6:	f1 f7       	brne	.-4      	; 0x31b4 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x59a>
    31b8:	00 c0       	rjmp	.+0      	; 0x31ba <_ZN11TouchDriver14getCoordinatesEPhS0_+0x5a0>
    
    for (int i = 7; i >= 0; i--)
    {
        
        _delay_us(delayTime);
        CLK_PORT |= CLK_PIN;
    31ba:	20 91 02 01 	lds	r18, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    31be:	28 60       	ori	r18, 0x08	; 8
    31c0:	20 93 02 01 	sts	0x0102, r18	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    31c4:	fa e2       	ldi	r31, 0x2A	; 42
    31c6:	fa 95       	dec	r31
    31c8:	f1 f7       	brne	.-4      	; 0x31c6 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x5ac>
    31ca:	00 c0       	rjmp	.+0      	; 0x31cc <_ZN11TouchDriver14getCoordinatesEPhS0_+0x5b2>
        _delay_us(delayTime);
        CLK_PORT &= ~CLK_PIN;
    31cc:	20 91 02 01 	lds	r18, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    31d0:	27 7f       	andi	r18, 0xF7	; 247
    31d2:	20 93 02 01 	sts	0x0102, r18	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    }
    
    CS_PORT |= CS_PIN;
    31d6:	73 9a       	sbi	0x0e, 3	; 14
		if (timeout > 255)
		{
			return;
		}
	}
	*x_ptr = readTouch('X');
    31d8:	45 fa       	bst	r4, 5
    31da:	44 24       	eor	r4, r4
    31dc:	40 f8       	bld	r4, 0
    31de:	29 81       	ldd	r18, Y+1	; 0x01
    31e0:	42 2a       	or	r4, r18
    31e2:	40 94       	com	r4
    31e4:	fb 01       	movw	r30, r22
    31e6:	40 82       	st	Z, r4
    {
        dinByte = dinXByte;
        
    }else if (coord == 'Y')
    {
        dinByte = dinYByte;
    31e8:	fc 01       	movw	r30, r24
    31ea:	61 81       	ldd	r22, Z+1	; 0x01
    else{
        return 255;
    }
    
    // ChipSelect Set to 0    
    CS_PORT &= ~CS_PIN;
    31ec:	73 98       	cbi	0x0e, 3	; 14
    31ee:	fa e2       	ldi	r31, 0x2A	; 42
    31f0:	fa 95       	dec	r31
    31f2:	f1 f7       	brne	.-4      	; 0x31f0 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x5d6>
    31f4:	00 c0       	rjmp	.+0      	; 0x31f6 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x5dc>
    31f6:	86 2f       	mov	r24, r22
    31f8:	90 e0       	ldi	r25, 0x00	; 0
    31fa:	2a e2       	ldi	r18, 0x2A	; 42
    31fc:	2a 95       	dec	r18
    31fe:	f1 f7       	brne	.-4      	; 0x31fc <_ZN11TouchDriver14getCoordinatesEPhS0_+0x5e2>
    3200:	00 c0       	rjmp	.+0      	; 0x3202 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x5e8>
    // DIN byte and pulse DCLK for Read X
    for (int i = 7; i >= 0; i--)
    {
        _delay_us(delayTime);
        
        DIN_PORT |= (((dinByte >> i)  & 0x01) << 5);
    3202:	74 b3       	in	r23, 0x14	; 20
    3204:	9c 01       	movw	r18, r24
    3206:	22 0f       	add	r18, r18
    3208:	23 2f       	mov	r18, r19
    320a:	22 1f       	adc	r18, r18
    320c:	33 0b       	sbc	r19, r19
    320e:	22 0f       	add	r18, r18
    3210:	33 1f       	adc	r19, r19
    3212:	22 95       	swap	r18
    3214:	32 95       	swap	r19
    3216:	30 7f       	andi	r19, 0xF0	; 240
    3218:	32 27       	eor	r19, r18
    321a:	20 7f       	andi	r18, 0xF0	; 240
    321c:	32 27       	eor	r19, r18
    321e:	27 2b       	or	r18, r23
    3220:	24 bb       	out	0x14, r18	; 20
        
        CLK_PORT |= CLK_PIN;
    3222:	90 91 02 01 	lds	r25, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    3226:	98 60       	ori	r25, 0x08	; 8
    3228:	90 93 02 01 	sts	0x0102, r25	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    322c:	3a e2       	ldi	r19, 0x2A	; 42
    322e:	3a 95       	dec	r19
    3230:	f1 f7       	brne	.-4      	; 0x322e <_ZN11TouchDriver14getCoordinatesEPhS0_+0x614>
    3232:	00 c0       	rjmp	.+0      	; 0x3234 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x61a>
		
        _delay_us(delayTime);
        
        CLK_PORT &= ~CLK_PIN;
    3234:	90 91 02 01 	lds	r25, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    3238:	97 7f       	andi	r25, 0xF7	; 247
    323a:	90 93 02 01 	sts	0x0102, r25	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
        DIN_PORT &= ~BIT6_SHIFTED;
    323e:	a5 98       	cbi	0x14, 5	; 20
    3240:	ea e2       	ldi	r30, 0x2A	; 42
    3242:	ea 95       	dec	r30
    3244:	f1 f7       	brne	.-4      	; 0x3242 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x628>
    3246:	00 c0       	rjmp	.+0      	; 0x3248 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x62e>
    // DIN byte and pulse DCLK for Read X
    for (int i = 7; i >= 0; i--)
    {
        _delay_us(delayTime);
        
        DIN_PORT |= (((dinByte >> i)  & 0x01) << 5);
    3248:	94 b3       	in	r25, 0x14	; 20
    324a:	66 fb       	bst	r22, 6
    324c:	ff 27       	eor	r31, r31
    324e:	f0 f9       	bld	r31, 0
    3250:	f9 87       	std	Y+9, r31	; 0x09
    3252:	1a 86       	std	Y+10, r1	; 0x0a
    3254:	29 85       	ldd	r18, Y+9	; 0x09
    3256:	3a 85       	ldd	r19, Y+10	; 0x0a
    3258:	22 0f       	add	r18, r18
    325a:	33 1f       	adc	r19, r19
    325c:	22 95       	swap	r18
    325e:	32 95       	swap	r19
    3260:	30 7f       	andi	r19, 0xF0	; 240
    3262:	32 27       	eor	r19, r18
    3264:	20 7f       	andi	r18, 0xF0	; 240
    3266:	32 27       	eor	r19, r18
    3268:	29 2b       	or	r18, r25
    326a:	24 bb       	out	0x14, r18	; 20
        
        CLK_PORT |= CLK_PIN;
    326c:	90 91 02 01 	lds	r25, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    3270:	98 60       	ori	r25, 0x08	; 8
    3272:	90 93 02 01 	sts	0x0102, r25	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    3276:	2a e2       	ldi	r18, 0x2A	; 42
    3278:	2a 95       	dec	r18
    327a:	f1 f7       	brne	.-4      	; 0x3278 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x65e>
    327c:	00 c0       	rjmp	.+0      	; 0x327e <_ZN11TouchDriver14getCoordinatesEPhS0_+0x664>
		
        _delay_us(delayTime);
        
        CLK_PORT &= ~CLK_PIN;
    327e:	90 91 02 01 	lds	r25, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    3282:	97 7f       	andi	r25, 0xF7	; 247
    3284:	90 93 02 01 	sts	0x0102, r25	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
        DIN_PORT &= ~BIT6_SHIFTED;
    3288:	a5 98       	cbi	0x14, 5	; 20
    328a:	3a e2       	ldi	r19, 0x2A	; 42
    328c:	3a 95       	dec	r19
    328e:	f1 f7       	brne	.-4      	; 0x328c <_ZN11TouchDriver14getCoordinatesEPhS0_+0x672>
    3290:	00 c0       	rjmp	.+0      	; 0x3292 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x678>
    // DIN byte and pulse DCLK for Read X
    for (int i = 7; i >= 0; i--)
    {
        _delay_us(delayTime);
        
        DIN_PORT |= (((dinByte >> i)  & 0x01) << 5);
    3292:	94 b3       	in	r25, 0x14	; 20
    3294:	65 fb       	bst	r22, 5
    3296:	ee 27       	eor	r30, r30
    3298:	e0 f9       	bld	r30, 0
    329a:	eb 87       	std	Y+11, r30	; 0x0b
    329c:	1c 86       	std	Y+12, r1	; 0x0c
    329e:	2b 85       	ldd	r18, Y+11	; 0x0b
    32a0:	3c 85       	ldd	r19, Y+12	; 0x0c
    32a2:	22 0f       	add	r18, r18
    32a4:	33 1f       	adc	r19, r19
    32a6:	22 95       	swap	r18
    32a8:	32 95       	swap	r19
    32aa:	30 7f       	andi	r19, 0xF0	; 240
    32ac:	32 27       	eor	r19, r18
    32ae:	20 7f       	andi	r18, 0xF0	; 240
    32b0:	32 27       	eor	r19, r18
    32b2:	29 2b       	or	r18, r25
    32b4:	24 bb       	out	0x14, r18	; 20
        
        CLK_PORT |= CLK_PIN;
    32b6:	90 91 02 01 	lds	r25, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    32ba:	98 60       	ori	r25, 0x08	; 8
    32bc:	90 93 02 01 	sts	0x0102, r25	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    32c0:	fa e2       	ldi	r31, 0x2A	; 42
    32c2:	fa 95       	dec	r31
    32c4:	f1 f7       	brne	.-4      	; 0x32c2 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x6a8>
    32c6:	00 c0       	rjmp	.+0      	; 0x32c8 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x6ae>
		
        _delay_us(delayTime);
        
        CLK_PORT &= ~CLK_PIN;
    32c8:	90 91 02 01 	lds	r25, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    32cc:	97 7f       	andi	r25, 0xF7	; 247
    32ce:	90 93 02 01 	sts	0x0102, r25	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
        DIN_PORT &= ~BIT6_SHIFTED;
    32d2:	a5 98       	cbi	0x14, 5	; 20
    32d4:	2a e2       	ldi	r18, 0x2A	; 42
    32d6:	2a 95       	dec	r18
    32d8:	f1 f7       	brne	.-4      	; 0x32d6 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x6bc>
    32da:	00 c0       	rjmp	.+0      	; 0x32dc <_ZN11TouchDriver14getCoordinatesEPhS0_+0x6c2>
    // DIN byte and pulse DCLK for Read X
    for (int i = 7; i >= 0; i--)
    {
        _delay_us(delayTime);
        
        DIN_PORT |= (((dinByte >> i)  & 0x01) << 5);
    32dc:	94 b3       	in	r25, 0x14	; 20
    32de:	64 fb       	bst	r22, 4
    32e0:	33 27       	eor	r19, r19
    32e2:	30 f9       	bld	r19, 0
    32e4:	3d 87       	std	Y+13, r19	; 0x0d
    32e6:	1e 86       	std	Y+14, r1	; 0x0e
    32e8:	2d 85       	ldd	r18, Y+13	; 0x0d
    32ea:	3e 85       	ldd	r19, Y+14	; 0x0e
    32ec:	22 0f       	add	r18, r18
    32ee:	33 1f       	adc	r19, r19
    32f0:	22 95       	swap	r18
    32f2:	32 95       	swap	r19
    32f4:	30 7f       	andi	r19, 0xF0	; 240
    32f6:	32 27       	eor	r19, r18
    32f8:	20 7f       	andi	r18, 0xF0	; 240
    32fa:	32 27       	eor	r19, r18
    32fc:	29 2b       	or	r18, r25
    32fe:	24 bb       	out	0x14, r18	; 20
        
        CLK_PORT |= CLK_PIN;
    3300:	90 91 02 01 	lds	r25, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    3304:	98 60       	ori	r25, 0x08	; 8
    3306:	90 93 02 01 	sts	0x0102, r25	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    330a:	ea e2       	ldi	r30, 0x2A	; 42
    330c:	ea 95       	dec	r30
    330e:	f1 f7       	brne	.-4      	; 0x330c <_ZN11TouchDriver14getCoordinatesEPhS0_+0x6f2>
    3310:	00 c0       	rjmp	.+0      	; 0x3312 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x6f8>
		
        _delay_us(delayTime);
        
        CLK_PORT &= ~CLK_PIN;
    3312:	90 91 02 01 	lds	r25, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    3316:	97 7f       	andi	r25, 0xF7	; 247
    3318:	90 93 02 01 	sts	0x0102, r25	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
        DIN_PORT &= ~BIT6_SHIFTED;
    331c:	a5 98       	cbi	0x14, 5	; 20
    331e:	fa e2       	ldi	r31, 0x2A	; 42
    3320:	fa 95       	dec	r31
    3322:	f1 f7       	brne	.-4      	; 0x3320 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x706>
    3324:	00 c0       	rjmp	.+0      	; 0x3326 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x70c>
    // DIN byte and pulse DCLK for Read X
    for (int i = 7; i >= 0; i--)
    {
        _delay_us(delayTime);
        
        DIN_PORT |= (((dinByte >> i)  & 0x01) << 5);
    3326:	94 b3       	in	r25, 0x14	; 20
    3328:	63 fb       	bst	r22, 3
    332a:	22 27       	eor	r18, r18
    332c:	20 f9       	bld	r18, 0
    332e:	2f 87       	std	Y+15, r18	; 0x0f
    3330:	18 8a       	std	Y+16, r1	; 0x10
    3332:	2f 85       	ldd	r18, Y+15	; 0x0f
    3334:	38 89       	ldd	r19, Y+16	; 0x10
    3336:	22 0f       	add	r18, r18
    3338:	33 1f       	adc	r19, r19
    333a:	22 95       	swap	r18
    333c:	32 95       	swap	r19
    333e:	30 7f       	andi	r19, 0xF0	; 240
    3340:	32 27       	eor	r19, r18
    3342:	20 7f       	andi	r18, 0xF0	; 240
    3344:	32 27       	eor	r19, r18
    3346:	29 2b       	or	r18, r25
    3348:	24 bb       	out	0x14, r18	; 20
        
        CLK_PORT |= CLK_PIN;
    334a:	90 91 02 01 	lds	r25, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    334e:	98 60       	ori	r25, 0x08	; 8
    3350:	90 93 02 01 	sts	0x0102, r25	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    3354:	3a e2       	ldi	r19, 0x2A	; 42
    3356:	3a 95       	dec	r19
    3358:	f1 f7       	brne	.-4      	; 0x3356 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x73c>
    335a:	00 c0       	rjmp	.+0      	; 0x335c <_ZN11TouchDriver14getCoordinatesEPhS0_+0x742>
		
        _delay_us(delayTime);
        
        CLK_PORT &= ~CLK_PIN;
    335c:	90 91 02 01 	lds	r25, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    3360:	97 7f       	andi	r25, 0xF7	; 247
    3362:	90 93 02 01 	sts	0x0102, r25	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
        DIN_PORT &= ~BIT6_SHIFTED;
    3366:	a5 98       	cbi	0x14, 5	; 20
    3368:	ea e2       	ldi	r30, 0x2A	; 42
    336a:	ea 95       	dec	r30
    336c:	f1 f7       	brne	.-4      	; 0x336a <_ZN11TouchDriver14getCoordinatesEPhS0_+0x750>
    336e:	00 c0       	rjmp	.+0      	; 0x3370 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x756>
    // DIN byte and pulse DCLK for Read X
    for (int i = 7; i >= 0; i--)
    {
        _delay_us(delayTime);
        
        DIN_PORT |= (((dinByte >> i)  & 0x01) << 5);
    3370:	94 b3       	in	r25, 0x14	; 20
    3372:	62 fb       	bst	r22, 2
    3374:	ff 27       	eor	r31, r31
    3376:	f0 f9       	bld	r31, 0
    3378:	f9 8b       	std	Y+17, r31	; 0x11
    337a:	1a 8a       	std	Y+18, r1	; 0x12
    337c:	29 89       	ldd	r18, Y+17	; 0x11
    337e:	3a 89       	ldd	r19, Y+18	; 0x12
    3380:	22 0f       	add	r18, r18
    3382:	33 1f       	adc	r19, r19
    3384:	22 95       	swap	r18
    3386:	32 95       	swap	r19
    3388:	30 7f       	andi	r19, 0xF0	; 240
    338a:	32 27       	eor	r19, r18
    338c:	20 7f       	andi	r18, 0xF0	; 240
    338e:	32 27       	eor	r19, r18
    3390:	29 2b       	or	r18, r25
    3392:	24 bb       	out	0x14, r18	; 20
        
        CLK_PORT |= CLK_PIN;
    3394:	90 91 02 01 	lds	r25, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    3398:	98 60       	ori	r25, 0x08	; 8
    339a:	90 93 02 01 	sts	0x0102, r25	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    339e:	2a e2       	ldi	r18, 0x2A	; 42
    33a0:	2a 95       	dec	r18
    33a2:	f1 f7       	brne	.-4      	; 0x33a0 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x786>
    33a4:	00 c0       	rjmp	.+0      	; 0x33a6 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x78c>
		
        _delay_us(delayTime);
        
        CLK_PORT &= ~CLK_PIN;
    33a6:	90 91 02 01 	lds	r25, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    33aa:	97 7f       	andi	r25, 0xF7	; 247
    33ac:	90 93 02 01 	sts	0x0102, r25	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
        DIN_PORT &= ~BIT6_SHIFTED;
    33b0:	a5 98       	cbi	0x14, 5	; 20
    33b2:	3a e2       	ldi	r19, 0x2A	; 42
    33b4:	3a 95       	dec	r19
    33b6:	f1 f7       	brne	.-4      	; 0x33b4 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x79a>
    33b8:	00 c0       	rjmp	.+0      	; 0x33ba <_ZN11TouchDriver14getCoordinatesEPhS0_+0x7a0>
    // DIN byte and pulse DCLK for Read X
    for (int i = 7; i >= 0; i--)
    {
        _delay_us(delayTime);
        
        DIN_PORT |= (((dinByte >> i)  & 0x01) << 5);
    33ba:	24 b3       	in	r18, 0x14	; 20
    33bc:	61 fb       	bst	r22, 1
    33be:	ee 27       	eor	r30, r30
    33c0:	e0 f9       	bld	r30, 0
    33c2:	eb 8b       	std	Y+19, r30	; 0x13
    33c4:	1c 8a       	std	Y+20, r1	; 0x14
    33c6:	8b 89       	ldd	r24, Y+19	; 0x13
    33c8:	9c 89       	ldd	r25, Y+20	; 0x14
    33ca:	88 0f       	add	r24, r24
    33cc:	99 1f       	adc	r25, r25
    33ce:	82 95       	swap	r24
    33d0:	92 95       	swap	r25
    33d2:	90 7f       	andi	r25, 0xF0	; 240
    33d4:	98 27       	eor	r25, r24
    33d6:	80 7f       	andi	r24, 0xF0	; 240
    33d8:	98 27       	eor	r25, r24
    33da:	82 2b       	or	r24, r18
    33dc:	84 bb       	out	0x14, r24	; 20
        
        CLK_PORT |= CLK_PIN;
    33de:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    33e2:	88 60       	ori	r24, 0x08	; 8
    33e4:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    33e8:	fa e2       	ldi	r31, 0x2A	; 42
    33ea:	fa 95       	dec	r31
    33ec:	f1 f7       	brne	.-4      	; 0x33ea <_ZN11TouchDriver14getCoordinatesEPhS0_+0x7d0>
    33ee:	00 c0       	rjmp	.+0      	; 0x33f0 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x7d6>
		
        _delay_us(delayTime);
        
        CLK_PORT &= ~CLK_PIN;
    33f0:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    33f4:	87 7f       	andi	r24, 0xF7	; 247
    33f6:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
        DIN_PORT &= ~BIT6_SHIFTED;
    33fa:	a5 98       	cbi	0x14, 5	; 20
    33fc:	2a e2       	ldi	r18, 0x2A	; 42
    33fe:	2a 95       	dec	r18
    3400:	f1 f7       	brne	.-4      	; 0x33fe <_ZN11TouchDriver14getCoordinatesEPhS0_+0x7e4>
    3402:	00 c0       	rjmp	.+0      	; 0x3404 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x7ea>
    // DIN byte and pulse DCLK for Read X
    for (int i = 7; i >= 0; i--)
    {
        _delay_us(delayTime);
        
        DIN_PORT |= (((dinByte >> i)  & 0x01) << 5);
    3404:	24 b3       	in	r18, 0x14	; 20
    3406:	61 70       	andi	r22, 0x01	; 1
    3408:	6d 8b       	std	Y+21, r22	; 0x15
    340a:	1e 8a       	std	Y+22, r1	; 0x16
    340c:	8d 89       	ldd	r24, Y+21	; 0x15
    340e:	9e 89       	ldd	r25, Y+22	; 0x16
    3410:	88 0f       	add	r24, r24
    3412:	99 1f       	adc	r25, r25
    3414:	82 95       	swap	r24
    3416:	92 95       	swap	r25
    3418:	90 7f       	andi	r25, 0xF0	; 240
    341a:	98 27       	eor	r25, r24
    341c:	80 7f       	andi	r24, 0xF0	; 240
    341e:	98 27       	eor	r25, r24
    3420:	82 2b       	or	r24, r18
    3422:	84 bb       	out	0x14, r24	; 20
        
        CLK_PORT |= CLK_PIN;
    3424:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    3428:	88 60       	ori	r24, 0x08	; 8
    342a:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    342e:	3a e2       	ldi	r19, 0x2A	; 42
    3430:	3a 95       	dec	r19
    3432:	f1 f7       	brne	.-4      	; 0x3430 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x816>
    3434:	00 c0       	rjmp	.+0      	; 0x3436 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x81c>
		
        _delay_us(delayTime);
        
        CLK_PORT &= ~CLK_PIN;
    3436:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    343a:	87 7f       	andi	r24, 0xF7	; 247
    343c:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
        DIN_PORT &= ~BIT6_SHIFTED;
    3440:	a5 98       	cbi	0x14, 5	; 20
    3442:	8a e2       	ldi	r24, 0x2A	; 42
    3444:	8a 95       	dec	r24
    3446:	f1 f7       	brne	.-4      	; 0x3444 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x82a>
    3448:	00 c0       	rjmp	.+0      	; 0x344a <_ZN11TouchDriver14getCoordinatesEPhS0_+0x830>
    // Systematically read DOUT
    for (int i = 7; i >= 0; i--)
    {
        _delay_us(delayTime);
        
        CLK_PORT |= CLK_PIN;
    344a:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    344e:	88 60       	ori	r24, 0x08	; 8
    3450:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    3454:	9a e2       	ldi	r25, 0x2A	; 42
    3456:	9a 95       	dec	r25
    3458:	f1 f7       	brne	.-4      	; 0x3456 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x83c>
    345a:	00 c0       	rjmp	.+0      	; 0x345c <_ZN11TouchDriver14getCoordinatesEPhS0_+0x842>
        _delay_us(delayTime);
        CLK_PORT &= ~CLK_PIN;
    345c:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    3460:	87 7f       	andi	r24, 0xF7	; 247
    3462:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    3466:	e5 e0       	ldi	r30, 0x05	; 5
    3468:	ea 95       	dec	r30
    346a:	f1 f7       	brne	.-4      	; 0x3468 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x84e>
    346c:	00 00       	nop
        _delay_us(1);
        
        bool temp = (PINE & (1U << 5));
    346e:	9c b1       	in	r25, 0x0c	; 12
    3470:	fa e2       	ldi	r31, 0x2A	; 42
    3472:	fa 95       	dec	r31
    3474:	f1 f7       	brne	.-4      	; 0x3472 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x858>
    3476:	00 c0       	rjmp	.+0      	; 0x3478 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x85e>
    // Systematically read DOUT
    for (int i = 7; i >= 0; i--)
    {
        _delay_us(delayTime);
        
        CLK_PORT |= CLK_PIN;
    3478:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    347c:	88 60       	ori	r24, 0x08	; 8
    347e:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    3482:	2a e2       	ldi	r18, 0x2A	; 42
    3484:	2a 95       	dec	r18
    3486:	f1 f7       	brne	.-4      	; 0x3484 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x86a>
    3488:	00 c0       	rjmp	.+0      	; 0x348a <_ZN11TouchDriver14getCoordinatesEPhS0_+0x870>
        _delay_us(delayTime);
        CLK_PORT &= ~CLK_PIN;
    348a:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    348e:	87 7f       	andi	r24, 0xF7	; 247
    3490:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    3494:	35 e0       	ldi	r19, 0x05	; 5
    3496:	3a 95       	dec	r19
    3498:	f1 f7       	brne	.-4      	; 0x3496 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x87c>
    349a:	00 00       	nop
        _delay_us(1);
        
        bool temp = (PINE & (1U << 5));
    349c:	8c b1       	in	r24, 0x0c	; 12
        
        result |= (temp << i);
    349e:	85 fb       	bst	r24, 5
    34a0:	88 27       	eor	r24, r24
    34a2:	80 f9       	bld	r24, 0
    34a4:	8f 8b       	std	Y+23, r24	; 0x17
    34a6:	18 8e       	std	Y+24, r1	; 0x18
    34a8:	2f 89       	ldd	r18, Y+23	; 0x17
    34aa:	38 8d       	ldd	r19, Y+24	; 0x18
    34ac:	00 24       	eor	r0, r0
    34ae:	36 95       	lsr	r19
    34b0:	27 95       	ror	r18
    34b2:	07 94       	ror	r0
    34b4:	36 95       	lsr	r19
    34b6:	27 95       	ror	r18
    34b8:	07 94       	ror	r0
    34ba:	32 2f       	mov	r19, r18
    34bc:	20 2d       	mov	r18, r0
    34be:	95 fb       	bst	r25, 5
    34c0:	99 27       	eor	r25, r25
    34c2:	90 f9       	bld	r25, 0
    34c4:	99 8f       	std	Y+25, r25	; 0x19
    34c6:	1a 8e       	std	Y+26, r1	; 0x1a
    34c8:	89 8d       	ldd	r24, Y+25	; 0x19
    34ca:	9a 8d       	ldd	r25, Y+26	; 0x1a
    34cc:	96 95       	lsr	r25
    34ce:	98 2f       	mov	r25, r24
    34d0:	88 27       	eor	r24, r24
    34d2:	97 95       	ror	r25
    34d4:	87 95       	ror	r24
    34d6:	82 2b       	or	r24, r18
    34d8:	9a e2       	ldi	r25, 0x2A	; 42
    34da:	9a 95       	dec	r25
    34dc:	f1 f7       	brne	.-4      	; 0x34da <_ZN11TouchDriver14getCoordinatesEPhS0_+0x8c0>
    34de:	00 c0       	rjmp	.+0      	; 0x34e0 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x8c6>
    // Systematically read DOUT
    for (int i = 7; i >= 0; i--)
    {
        _delay_us(delayTime);
        
        CLK_PORT |= CLK_PIN;
    34e0:	90 91 02 01 	lds	r25, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    34e4:	98 60       	ori	r25, 0x08	; 8
    34e6:	90 93 02 01 	sts	0x0102, r25	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    34ea:	ea e2       	ldi	r30, 0x2A	; 42
    34ec:	ea 95       	dec	r30
    34ee:	f1 f7       	brne	.-4      	; 0x34ec <_ZN11TouchDriver14getCoordinatesEPhS0_+0x8d2>
    34f0:	00 c0       	rjmp	.+0      	; 0x34f2 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x8d8>
        _delay_us(delayTime);
        CLK_PORT &= ~CLK_PIN;
    34f2:	90 91 02 01 	lds	r25, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    34f6:	97 7f       	andi	r25, 0xF7	; 247
    34f8:	90 93 02 01 	sts	0x0102, r25	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    34fc:	f5 e0       	ldi	r31, 0x05	; 5
    34fe:	fa 95       	dec	r31
    3500:	f1 f7       	brne	.-4      	; 0x34fe <_ZN11TouchDriver14getCoordinatesEPhS0_+0x8e4>
    3502:	00 00       	nop
        _delay_us(1);
        
        bool temp = (PINE & (1U << 5));
    3504:	9c b1       	in	r25, 0x0c	; 12
        
        result |= (temp << i);
    3506:	90 72       	andi	r25, 0x20	; 32
    3508:	89 2b       	or	r24, r25
    350a:	2a e2       	ldi	r18, 0x2A	; 42
    350c:	2a 95       	dec	r18
    350e:	f1 f7       	brne	.-4      	; 0x350c <_ZN11TouchDriver14getCoordinatesEPhS0_+0x8f2>
    3510:	00 c0       	rjmp	.+0      	; 0x3512 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x8f8>
    // Systematically read DOUT
    for (int i = 7; i >= 0; i--)
    {
        _delay_us(delayTime);
        
        CLK_PORT |= CLK_PIN;
    3512:	90 91 02 01 	lds	r25, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    3516:	98 60       	ori	r25, 0x08	; 8
    3518:	90 93 02 01 	sts	0x0102, r25	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    351c:	3a e2       	ldi	r19, 0x2A	; 42
    351e:	3a 95       	dec	r19
    3520:	f1 f7       	brne	.-4      	; 0x351e <_ZN11TouchDriver14getCoordinatesEPhS0_+0x904>
    3522:	00 c0       	rjmp	.+0      	; 0x3524 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x90a>
        _delay_us(delayTime);
        CLK_PORT &= ~CLK_PIN;
    3524:	90 91 02 01 	lds	r25, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    3528:	97 7f       	andi	r25, 0xF7	; 247
    352a:	90 93 02 01 	sts	0x0102, r25	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    352e:	95 e0       	ldi	r25, 0x05	; 5
    3530:	9a 95       	dec	r25
    3532:	f1 f7       	brne	.-4      	; 0x3530 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x916>
    3534:	00 00       	nop
        _delay_us(1);
        
        bool temp = (PINE & (1U << 5));
    3536:	9c b1       	in	r25, 0x0c	; 12
        
        result |= (temp << i);
    3538:	95 fb       	bst	r25, 5
    353a:	99 27       	eor	r25, r25
    353c:	90 f9       	bld	r25, 0
    353e:	9b 8f       	std	Y+27, r25	; 0x1b
    3540:	1c 8e       	std	Y+28, r1	; 0x1c
    3542:	6b 8d       	ldd	r22, Y+27	; 0x1b
    3544:	7c 8d       	ldd	r23, Y+28	; 0x1c
    3546:	62 95       	swap	r22
    3548:	72 95       	swap	r23
    354a:	70 7f       	andi	r23, 0xF0	; 240
    354c:	76 27       	eor	r23, r22
    354e:	60 7f       	andi	r22, 0xF0	; 240
    3550:	76 27       	eor	r23, r22
    3552:	28 2f       	mov	r18, r24
    3554:	26 2b       	or	r18, r22
    3556:	ea e2       	ldi	r30, 0x2A	; 42
    3558:	ea 95       	dec	r30
    355a:	f1 f7       	brne	.-4      	; 0x3558 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x93e>
    355c:	00 c0       	rjmp	.+0      	; 0x355e <_ZN11TouchDriver14getCoordinatesEPhS0_+0x944>
    // Systematically read DOUT
    for (int i = 7; i >= 0; i--)
    {
        _delay_us(delayTime);
        
        CLK_PORT |= CLK_PIN;
    355e:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    3562:	88 60       	ori	r24, 0x08	; 8
    3564:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    3568:	fa e2       	ldi	r31, 0x2A	; 42
    356a:	fa 95       	dec	r31
    356c:	f1 f7       	brne	.-4      	; 0x356a <_ZN11TouchDriver14getCoordinatesEPhS0_+0x950>
    356e:	00 c0       	rjmp	.+0      	; 0x3570 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x956>
        _delay_us(delayTime);
        CLK_PORT &= ~CLK_PIN;
    3570:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    3574:	87 7f       	andi	r24, 0xF7	; 247
    3576:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    357a:	35 e0       	ldi	r19, 0x05	; 5
    357c:	3a 95       	dec	r19
    357e:	f1 f7       	brne	.-4      	; 0x357c <_ZN11TouchDriver14getCoordinatesEPhS0_+0x962>
    3580:	00 00       	nop
        _delay_us(1);
        
        bool temp = (PINE & (1U << 5));
    3582:	8c b1       	in	r24, 0x0c	; 12
        
        result |= (temp << i);
    3584:	85 fb       	bst	r24, 5
    3586:	88 27       	eor	r24, r24
    3588:	80 f9       	bld	r24, 0
    358a:	8d 8f       	std	Y+29, r24	; 0x1d
    358c:	1e 8e       	std	Y+30, r1	; 0x1e
    358e:	6d 8d       	ldd	r22, Y+29	; 0x1d
    3590:	7e 8d       	ldd	r23, Y+30	; 0x1e
    3592:	66 0f       	add	r22, r22
    3594:	77 1f       	adc	r23, r23
    3596:	66 0f       	add	r22, r22
    3598:	77 1f       	adc	r23, r23
    359a:	66 0f       	add	r22, r22
    359c:	77 1f       	adc	r23, r23
    359e:	62 2b       	or	r22, r18
    35a0:	8a e2       	ldi	r24, 0x2A	; 42
    35a2:	8a 95       	dec	r24
    35a4:	f1 f7       	brne	.-4      	; 0x35a2 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x988>
    35a6:	00 c0       	rjmp	.+0      	; 0x35a8 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x98e>
    // Systematically read DOUT
    for (int i = 7; i >= 0; i--)
    {
        _delay_us(delayTime);
        
        CLK_PORT |= CLK_PIN;
    35a8:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    35ac:	88 60       	ori	r24, 0x08	; 8
    35ae:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    35b2:	9a e2       	ldi	r25, 0x2A	; 42
    35b4:	9a 95       	dec	r25
    35b6:	f1 f7       	brne	.-4      	; 0x35b4 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x99a>
    35b8:	00 c0       	rjmp	.+0      	; 0x35ba <_ZN11TouchDriver14getCoordinatesEPhS0_+0x9a0>
        _delay_us(delayTime);
        CLK_PORT &= ~CLK_PIN;
    35ba:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    35be:	87 7f       	andi	r24, 0xF7	; 247
    35c0:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    35c4:	e5 e0       	ldi	r30, 0x05	; 5
    35c6:	ea 95       	dec	r30
    35c8:	f1 f7       	brne	.-4      	; 0x35c6 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x9ac>
    35ca:	00 00       	nop
        _delay_us(1);
        
        bool temp = (PINE & (1U << 5));
    35cc:	8c b1       	in	r24, 0x0c	; 12
        
        result |= (temp << i);
    35ce:	85 fb       	bst	r24, 5
    35d0:	88 27       	eor	r24, r24
    35d2:	80 f9       	bld	r24, 0
    35d4:	8f 8f       	std	Y+31, r24	; 0x1f
    35d6:	18 a2       	std	Y+32, r1	; 0x20
    35d8:	2f 8d       	ldd	r18, Y+31	; 0x1f
    35da:	38 a1       	ldd	r19, Y+32	; 0x20
    35dc:	22 0f       	add	r18, r18
    35de:	33 1f       	adc	r19, r19
    35e0:	22 0f       	add	r18, r18
    35e2:	33 1f       	adc	r19, r19
    35e4:	26 2b       	or	r18, r22
    35e6:	fa e2       	ldi	r31, 0x2A	; 42
    35e8:	fa 95       	dec	r31
    35ea:	f1 f7       	brne	.-4      	; 0x35e8 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x9ce>
    35ec:	00 c0       	rjmp	.+0      	; 0x35ee <_ZN11TouchDriver14getCoordinatesEPhS0_+0x9d4>
    // Systematically read DOUT
    for (int i = 7; i >= 0; i--)
    {
        _delay_us(delayTime);
        
        CLK_PORT |= CLK_PIN;
    35ee:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    35f2:	88 60       	ori	r24, 0x08	; 8
    35f4:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    35f8:	3a e2       	ldi	r19, 0x2A	; 42
    35fa:	3a 95       	dec	r19
    35fc:	f1 f7       	brne	.-4      	; 0x35fa <_ZN11TouchDriver14getCoordinatesEPhS0_+0x9e0>
    35fe:	00 c0       	rjmp	.+0      	; 0x3600 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x9e6>
        _delay_us(delayTime);
        CLK_PORT &= ~CLK_PIN;
    3600:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    3604:	87 7f       	andi	r24, 0xF7	; 247
    3606:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    360a:	85 e0       	ldi	r24, 0x05	; 5
    360c:	8a 95       	dec	r24
    360e:	f1 f7       	brne	.-4      	; 0x360c <_ZN11TouchDriver14getCoordinatesEPhS0_+0x9f2>
    3610:	00 00       	nop
        _delay_us(1);
        
        bool temp = (PINE & (1U << 5));
    3612:	8c b1       	in	r24, 0x0c	; 12
        
        result |= (temp << i);
    3614:	85 fb       	bst	r24, 5
    3616:	88 27       	eor	r24, r24
    3618:	80 f9       	bld	r24, 0
    361a:	89 a3       	std	Y+33, r24	; 0x21
    361c:	1a a2       	std	Y+34, r1	; 0x22
    361e:	89 a1       	ldd	r24, Y+33	; 0x21
    3620:	9a a1       	ldd	r25, Y+34	; 0x22
    3622:	88 0f       	add	r24, r24
    3624:	99 1f       	adc	r25, r25
    3626:	28 2b       	or	r18, r24
    3628:	9a e2       	ldi	r25, 0x2A	; 42
    362a:	9a 95       	dec	r25
    362c:	f1 f7       	brne	.-4      	; 0x362a <_ZN11TouchDriver14getCoordinatesEPhS0_+0xa10>
    362e:	00 c0       	rjmp	.+0      	; 0x3630 <_ZN11TouchDriver14getCoordinatesEPhS0_+0xa16>
    // Systematically read DOUT
    for (int i = 7; i >= 0; i--)
    {
        _delay_us(delayTime);
        
        CLK_PORT |= CLK_PIN;
    3630:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    3634:	88 60       	ori	r24, 0x08	; 8
    3636:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    363a:	ea e2       	ldi	r30, 0x2A	; 42
    363c:	ea 95       	dec	r30
    363e:	f1 f7       	brne	.-4      	; 0x363c <_ZN11TouchDriver14getCoordinatesEPhS0_+0xa22>
    3640:	00 c0       	rjmp	.+0      	; 0x3642 <_ZN11TouchDriver14getCoordinatesEPhS0_+0xa28>
        _delay_us(delayTime);
        CLK_PORT &= ~CLK_PIN;
    3642:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    3646:	87 7f       	andi	r24, 0xF7	; 247
    3648:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    364c:	f5 e0       	ldi	r31, 0x05	; 5
    364e:	fa 95       	dec	r31
    3650:	f1 f7       	brne	.-4      	; 0x364e <_ZN11TouchDriver14getCoordinatesEPhS0_+0xa34>
    3652:	00 00       	nop
        _delay_us(1);
        
        bool temp = (PINE & (1U << 5));
    3654:	8c b1       	in	r24, 0x0c	; 12
    3656:	3a e2       	ldi	r19, 0x2A	; 42
    3658:	3a 95       	dec	r19
    365a:	f1 f7       	brne	.-4      	; 0x3658 <_ZN11TouchDriver14getCoordinatesEPhS0_+0xa3e>
    365c:	00 c0       	rjmp	.+0      	; 0x365e <_ZN11TouchDriver14getCoordinatesEPhS0_+0xa44>
    
    for (int i = 7; i >= 0; i--)
    {
        
        _delay_us(delayTime);
        CLK_PORT |= CLK_PIN;
    365e:	90 91 02 01 	lds	r25, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    3662:	98 60       	ori	r25, 0x08	; 8
    3664:	90 93 02 01 	sts	0x0102, r25	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    3668:	9a e2       	ldi	r25, 0x2A	; 42
    366a:	9a 95       	dec	r25
    366c:	f1 f7       	brne	.-4      	; 0x366a <_ZN11TouchDriver14getCoordinatesEPhS0_+0xa50>
    366e:	00 c0       	rjmp	.+0      	; 0x3670 <_ZN11TouchDriver14getCoordinatesEPhS0_+0xa56>
        _delay_us(delayTime);
        CLK_PORT &= ~CLK_PIN;
    3670:	90 91 02 01 	lds	r25, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    3674:	97 7f       	andi	r25, 0xF7	; 247
    3676:	90 93 02 01 	sts	0x0102, r25	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    367a:	ea e2       	ldi	r30, 0x2A	; 42
    367c:	ea 95       	dec	r30
    367e:	f1 f7       	brne	.-4      	; 0x367c <_ZN11TouchDriver14getCoordinatesEPhS0_+0xa62>
    3680:	00 c0       	rjmp	.+0      	; 0x3682 <_ZN11TouchDriver14getCoordinatesEPhS0_+0xa68>
    
    for (int i = 7; i >= 0; i--)
    {
        
        _delay_us(delayTime);
        CLK_PORT |= CLK_PIN;
    3682:	90 91 02 01 	lds	r25, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    3686:	98 60       	ori	r25, 0x08	; 8
    3688:	90 93 02 01 	sts	0x0102, r25	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    368c:	fa e2       	ldi	r31, 0x2A	; 42
    368e:	fa 95       	dec	r31
    3690:	f1 f7       	brne	.-4      	; 0x368e <_ZN11TouchDriver14getCoordinatesEPhS0_+0xa74>
    3692:	00 c0       	rjmp	.+0      	; 0x3694 <_ZN11TouchDriver14getCoordinatesEPhS0_+0xa7a>
        _delay_us(delayTime);
        CLK_PORT &= ~CLK_PIN;
    3694:	90 91 02 01 	lds	r25, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    3698:	97 7f       	andi	r25, 0xF7	; 247
    369a:	90 93 02 01 	sts	0x0102, r25	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    369e:	3a e2       	ldi	r19, 0x2A	; 42
    36a0:	3a 95       	dec	r19
    36a2:	f1 f7       	brne	.-4      	; 0x36a0 <_ZN11TouchDriver14getCoordinatesEPhS0_+0xa86>
    36a4:	00 c0       	rjmp	.+0      	; 0x36a6 <_ZN11TouchDriver14getCoordinatesEPhS0_+0xa8c>
    
    for (int i = 7; i >= 0; i--)
    {
        
        _delay_us(delayTime);
        CLK_PORT |= CLK_PIN;
    36a6:	90 91 02 01 	lds	r25, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    36aa:	98 60       	ori	r25, 0x08	; 8
    36ac:	90 93 02 01 	sts	0x0102, r25	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    36b0:	9a e2       	ldi	r25, 0x2A	; 42
    36b2:	9a 95       	dec	r25
    36b4:	f1 f7       	brne	.-4      	; 0x36b2 <_ZN11TouchDriver14getCoordinatesEPhS0_+0xa98>
    36b6:	00 c0       	rjmp	.+0      	; 0x36b8 <_ZN11TouchDriver14getCoordinatesEPhS0_+0xa9e>
        _delay_us(delayTime);
        CLK_PORT &= ~CLK_PIN;
    36b8:	90 91 02 01 	lds	r25, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    36bc:	97 7f       	andi	r25, 0xF7	; 247
    36be:	90 93 02 01 	sts	0x0102, r25	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    36c2:	ea e2       	ldi	r30, 0x2A	; 42
    36c4:	ea 95       	dec	r30
    36c6:	f1 f7       	brne	.-4      	; 0x36c4 <_ZN11TouchDriver14getCoordinatesEPhS0_+0xaaa>
    36c8:	00 c0       	rjmp	.+0      	; 0x36ca <_ZN11TouchDriver14getCoordinatesEPhS0_+0xab0>
    
    for (int i = 7; i >= 0; i--)
    {
        
        _delay_us(delayTime);
        CLK_PORT |= CLK_PIN;
    36ca:	90 91 02 01 	lds	r25, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    36ce:	98 60       	ori	r25, 0x08	; 8
    36d0:	90 93 02 01 	sts	0x0102, r25	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    36d4:	fa e2       	ldi	r31, 0x2A	; 42
    36d6:	fa 95       	dec	r31
    36d8:	f1 f7       	brne	.-4      	; 0x36d6 <_ZN11TouchDriver14getCoordinatesEPhS0_+0xabc>
    36da:	00 c0       	rjmp	.+0      	; 0x36dc <_ZN11TouchDriver14getCoordinatesEPhS0_+0xac2>
        _delay_us(delayTime);
        CLK_PORT &= ~CLK_PIN;
    36dc:	90 91 02 01 	lds	r25, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    36e0:	97 7f       	andi	r25, 0xF7	; 247
    36e2:	90 93 02 01 	sts	0x0102, r25	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    36e6:	3a e2       	ldi	r19, 0x2A	; 42
    36e8:	3a 95       	dec	r19
    36ea:	f1 f7       	brne	.-4      	; 0x36e8 <_ZN11TouchDriver14getCoordinatesEPhS0_+0xace>
    36ec:	00 c0       	rjmp	.+0      	; 0x36ee <_ZN11TouchDriver14getCoordinatesEPhS0_+0xad4>
    
    for (int i = 7; i >= 0; i--)
    {
        
        _delay_us(delayTime);
        CLK_PORT |= CLK_PIN;
    36ee:	90 91 02 01 	lds	r25, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    36f2:	98 60       	ori	r25, 0x08	; 8
    36f4:	90 93 02 01 	sts	0x0102, r25	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    36f8:	9a e2       	ldi	r25, 0x2A	; 42
    36fa:	9a 95       	dec	r25
    36fc:	f1 f7       	brne	.-4      	; 0x36fa <_ZN11TouchDriver14getCoordinatesEPhS0_+0xae0>
    36fe:	00 c0       	rjmp	.+0      	; 0x3700 <_ZN11TouchDriver14getCoordinatesEPhS0_+0xae6>
        _delay_us(delayTime);
        CLK_PORT &= ~CLK_PIN;
    3700:	90 91 02 01 	lds	r25, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    3704:	97 7f       	andi	r25, 0xF7	; 247
    3706:	90 93 02 01 	sts	0x0102, r25	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    370a:	ea e2       	ldi	r30, 0x2A	; 42
    370c:	ea 95       	dec	r30
    370e:	f1 f7       	brne	.-4      	; 0x370c <_ZN11TouchDriver14getCoordinatesEPhS0_+0xaf2>
    3710:	00 c0       	rjmp	.+0      	; 0x3712 <_ZN11TouchDriver14getCoordinatesEPhS0_+0xaf8>
    
    for (int i = 7; i >= 0; i--)
    {
        
        _delay_us(delayTime);
        CLK_PORT |= CLK_PIN;
    3712:	90 91 02 01 	lds	r25, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    3716:	98 60       	ori	r25, 0x08	; 8
    3718:	90 93 02 01 	sts	0x0102, r25	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    371c:	fa e2       	ldi	r31, 0x2A	; 42
    371e:	fa 95       	dec	r31
    3720:	f1 f7       	brne	.-4      	; 0x371e <_ZN11TouchDriver14getCoordinatesEPhS0_+0xb04>
    3722:	00 c0       	rjmp	.+0      	; 0x3724 <_ZN11TouchDriver14getCoordinatesEPhS0_+0xb0a>
        _delay_us(delayTime);
        CLK_PORT &= ~CLK_PIN;
    3724:	90 91 02 01 	lds	r25, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    3728:	97 7f       	andi	r25, 0xF7	; 247
    372a:	90 93 02 01 	sts	0x0102, r25	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    372e:	3a e2       	ldi	r19, 0x2A	; 42
    3730:	3a 95       	dec	r19
    3732:	f1 f7       	brne	.-4      	; 0x3730 <_ZN11TouchDriver14getCoordinatesEPhS0_+0xb16>
    3734:	00 c0       	rjmp	.+0      	; 0x3736 <_ZN11TouchDriver14getCoordinatesEPhS0_+0xb1c>
    
    for (int i = 7; i >= 0; i--)
    {
        
        _delay_us(delayTime);
        CLK_PORT |= CLK_PIN;
    3736:	90 91 02 01 	lds	r25, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    373a:	98 60       	ori	r25, 0x08	; 8
    373c:	90 93 02 01 	sts	0x0102, r25	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    3740:	9a e2       	ldi	r25, 0x2A	; 42
    3742:	9a 95       	dec	r25
    3744:	f1 f7       	brne	.-4      	; 0x3742 <_ZN11TouchDriver14getCoordinatesEPhS0_+0xb28>
    3746:	00 c0       	rjmp	.+0      	; 0x3748 <_ZN11TouchDriver14getCoordinatesEPhS0_+0xb2e>
        _delay_us(delayTime);
        CLK_PORT &= ~CLK_PIN;
    3748:	90 91 02 01 	lds	r25, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    374c:	97 7f       	andi	r25, 0xF7	; 247
    374e:	90 93 02 01 	sts	0x0102, r25	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    3752:	ea e2       	ldi	r30, 0x2A	; 42
    3754:	ea 95       	dec	r30
    3756:	f1 f7       	brne	.-4      	; 0x3754 <_ZN11TouchDriver14getCoordinatesEPhS0_+0xb3a>
    3758:	00 c0       	rjmp	.+0      	; 0x375a <_ZN11TouchDriver14getCoordinatesEPhS0_+0xb40>
    
    for (int i = 7; i >= 0; i--)
    {
        
        _delay_us(delayTime);
        CLK_PORT |= CLK_PIN;
    375a:	90 91 02 01 	lds	r25, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    375e:	98 60       	ori	r25, 0x08	; 8
    3760:	90 93 02 01 	sts	0x0102, r25	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    3764:	fa e2       	ldi	r31, 0x2A	; 42
    3766:	fa 95       	dec	r31
    3768:	f1 f7       	brne	.-4      	; 0x3766 <_ZN11TouchDriver14getCoordinatesEPhS0_+0xb4c>
    376a:	00 c0       	rjmp	.+0      	; 0x376c <_ZN11TouchDriver14getCoordinatesEPhS0_+0xb52>
        _delay_us(delayTime);
        CLK_PORT &= ~CLK_PIN;
    376c:	90 91 02 01 	lds	r25, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    3770:	97 7f       	andi	r25, 0xF7	; 247
    3772:	90 93 02 01 	sts	0x0102, r25	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    }
    
    CS_PORT |= CS_PIN;
    3776:	73 9a       	sbi	0x0e, 3	; 14
		{
			return;
		}
	}
	*x_ptr = readTouch('X');
	*y_ptr = readTouch('Y');
    3778:	85 fb       	bst	r24, 5
    377a:	88 27       	eor	r24, r24
    377c:	80 f9       	bld	r24, 0
    377e:	28 2b       	or	r18, r24
    3780:	20 95       	com	r18
    3782:	fa 01       	movw	r30, r20
    3784:	20 83       	st	Z, r18
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    3786:	ff ef       	ldi	r31, 0xFF	; 255
    3788:	20 e7       	ldi	r18, 0x70	; 112
    378a:	32 e0       	ldi	r19, 0x02	; 2
    378c:	f1 50       	subi	r31, 0x01	; 1
    378e:	20 40       	sbci	r18, 0x00	; 0
    3790:	30 40       	sbci	r19, 0x00	; 0
    3792:	e1 f7       	brne	.-8      	; 0x378c <_ZN11TouchDriver14getCoordinatesEPhS0_+0xb72>
    3794:	00 c0       	rjmp	.+0      	; 0x3796 <_ZN11TouchDriver14getCoordinatesEPhS0_+0xb7c>
    3796:	00 00       	nop
	_delay_ms( 50 );
	eIntHappend = 255;
    3798:	8f ef       	ldi	r24, 0xFF	; 255
    379a:	80 93 0d 02 	sts	0x020D, r24	; 0x80020d <eIntHappend>
	
}
    379e:	a5 96       	adiw	r28, 0x25	; 37
    37a0:	0f b6       	in	r0, 0x3f	; 63
    37a2:	f8 94       	cli
    37a4:	de bf       	out	0x3e, r29	; 62
    37a6:	0f be       	out	0x3f, r0	; 63
    37a8:	cd bf       	out	0x3d, r28	; 61
    37aa:	df 91       	pop	r29
    37ac:	cf 91       	pop	r28
    37ae:	1f 91       	pop	r17
    37b0:	0f 91       	pop	r16
    37b2:	ff 90       	pop	r15
    37b4:	ef 90       	pop	r14
    37b6:	df 90       	pop	r13
    37b8:	cf 90       	pop	r12
    37ba:	bf 90       	pop	r11
    37bc:	af 90       	pop	r10
    37be:	9f 90       	pop	r9
    37c0:	8f 90       	pop	r8
    37c2:	7f 90       	pop	r7
    37c4:	6f 90       	pop	r6
    37c6:	5f 90       	pop	r5
    37c8:	4f 90       	pop	r4
    37ca:	3f 90       	pop	r3
    37cc:	2f 90       	pop	r2
    37ce:	08 95       	ret

000037d0 <__subsf3>:
    37d0:	50 58       	subi	r21, 0x80	; 128

000037d2 <__addsf3>:
    37d2:	bb 27       	eor	r27, r27
    37d4:	aa 27       	eor	r26, r26
    37d6:	0e d0       	rcall	.+28     	; 0x37f4 <__addsf3x>
    37d8:	70 c1       	rjmp	.+736    	; 0x3aba <__fp_round>
    37da:	61 d1       	rcall	.+706    	; 0x3a9e <__fp_pscA>
    37dc:	30 f0       	brcs	.+12     	; 0x37ea <__addsf3+0x18>
    37de:	66 d1       	rcall	.+716    	; 0x3aac <__fp_pscB>
    37e0:	20 f0       	brcs	.+8      	; 0x37ea <__addsf3+0x18>
    37e2:	31 f4       	brne	.+12     	; 0x37f0 <__addsf3+0x1e>
    37e4:	9f 3f       	cpi	r25, 0xFF	; 255
    37e6:	11 f4       	brne	.+4      	; 0x37ec <__addsf3+0x1a>
    37e8:	1e f4       	brtc	.+6      	; 0x37f0 <__addsf3+0x1e>
    37ea:	56 c1       	rjmp	.+684    	; 0x3a98 <__fp_nan>
    37ec:	0e f4       	brtc	.+2      	; 0x37f0 <__addsf3+0x1e>
    37ee:	e0 95       	com	r30
    37f0:	e7 fb       	bst	r30, 7
    37f2:	4c c1       	rjmp	.+664    	; 0x3a8c <__fp_inf>

000037f4 <__addsf3x>:
    37f4:	e9 2f       	mov	r30, r25
    37f6:	72 d1       	rcall	.+740    	; 0x3adc <__fp_split3>
    37f8:	80 f3       	brcs	.-32     	; 0x37da <__addsf3+0x8>
    37fa:	ba 17       	cp	r27, r26
    37fc:	62 07       	cpc	r22, r18
    37fe:	73 07       	cpc	r23, r19
    3800:	84 07       	cpc	r24, r20
    3802:	95 07       	cpc	r25, r21
    3804:	18 f0       	brcs	.+6      	; 0x380c <__addsf3x+0x18>
    3806:	71 f4       	brne	.+28     	; 0x3824 <__addsf3x+0x30>
    3808:	9e f5       	brtc	.+102    	; 0x3870 <__addsf3x+0x7c>
    380a:	8a c1       	rjmp	.+788    	; 0x3b20 <__fp_zero>
    380c:	0e f4       	brtc	.+2      	; 0x3810 <__addsf3x+0x1c>
    380e:	e0 95       	com	r30
    3810:	0b 2e       	mov	r0, r27
    3812:	ba 2f       	mov	r27, r26
    3814:	a0 2d       	mov	r26, r0
    3816:	0b 01       	movw	r0, r22
    3818:	b9 01       	movw	r22, r18
    381a:	90 01       	movw	r18, r0
    381c:	0c 01       	movw	r0, r24
    381e:	ca 01       	movw	r24, r20
    3820:	a0 01       	movw	r20, r0
    3822:	11 24       	eor	r1, r1
    3824:	ff 27       	eor	r31, r31
    3826:	59 1b       	sub	r21, r25
    3828:	99 f0       	breq	.+38     	; 0x3850 <__addsf3x+0x5c>
    382a:	59 3f       	cpi	r21, 0xF9	; 249
    382c:	50 f4       	brcc	.+20     	; 0x3842 <__addsf3x+0x4e>
    382e:	50 3e       	cpi	r21, 0xE0	; 224
    3830:	68 f1       	brcs	.+90     	; 0x388c <__addsf3x+0x98>
    3832:	1a 16       	cp	r1, r26
    3834:	f0 40       	sbci	r31, 0x00	; 0
    3836:	a2 2f       	mov	r26, r18
    3838:	23 2f       	mov	r18, r19
    383a:	34 2f       	mov	r19, r20
    383c:	44 27       	eor	r20, r20
    383e:	58 5f       	subi	r21, 0xF8	; 248
    3840:	f3 cf       	rjmp	.-26     	; 0x3828 <__addsf3x+0x34>
    3842:	46 95       	lsr	r20
    3844:	37 95       	ror	r19
    3846:	27 95       	ror	r18
    3848:	a7 95       	ror	r26
    384a:	f0 40       	sbci	r31, 0x00	; 0
    384c:	53 95       	inc	r21
    384e:	c9 f7       	brne	.-14     	; 0x3842 <__addsf3x+0x4e>
    3850:	7e f4       	brtc	.+30     	; 0x3870 <__addsf3x+0x7c>
    3852:	1f 16       	cp	r1, r31
    3854:	ba 0b       	sbc	r27, r26
    3856:	62 0b       	sbc	r22, r18
    3858:	73 0b       	sbc	r23, r19
    385a:	84 0b       	sbc	r24, r20
    385c:	ba f0       	brmi	.+46     	; 0x388c <__addsf3x+0x98>
    385e:	91 50       	subi	r25, 0x01	; 1
    3860:	a1 f0       	breq	.+40     	; 0x388a <__addsf3x+0x96>
    3862:	ff 0f       	add	r31, r31
    3864:	bb 1f       	adc	r27, r27
    3866:	66 1f       	adc	r22, r22
    3868:	77 1f       	adc	r23, r23
    386a:	88 1f       	adc	r24, r24
    386c:	c2 f7       	brpl	.-16     	; 0x385e <__addsf3x+0x6a>
    386e:	0e c0       	rjmp	.+28     	; 0x388c <__addsf3x+0x98>
    3870:	ba 0f       	add	r27, r26
    3872:	62 1f       	adc	r22, r18
    3874:	73 1f       	adc	r23, r19
    3876:	84 1f       	adc	r24, r20
    3878:	48 f4       	brcc	.+18     	; 0x388c <__addsf3x+0x98>
    387a:	87 95       	ror	r24
    387c:	77 95       	ror	r23
    387e:	67 95       	ror	r22
    3880:	b7 95       	ror	r27
    3882:	f7 95       	ror	r31
    3884:	9e 3f       	cpi	r25, 0xFE	; 254
    3886:	08 f0       	brcs	.+2      	; 0x388a <__addsf3x+0x96>
    3888:	b3 cf       	rjmp	.-154    	; 0x37f0 <__addsf3+0x1e>
    388a:	93 95       	inc	r25
    388c:	88 0f       	add	r24, r24
    388e:	08 f0       	brcs	.+2      	; 0x3892 <__addsf3x+0x9e>
    3890:	99 27       	eor	r25, r25
    3892:	ee 0f       	add	r30, r30
    3894:	97 95       	ror	r25
    3896:	87 95       	ror	r24
    3898:	08 95       	ret

0000389a <__cmpsf2>:
    389a:	d4 d0       	rcall	.+424    	; 0x3a44 <__fp_cmp>
    389c:	08 f4       	brcc	.+2      	; 0x38a0 <__cmpsf2+0x6>
    389e:	81 e0       	ldi	r24, 0x01	; 1
    38a0:	08 95       	ret

000038a2 <__divsf3>:
    38a2:	0c d0       	rcall	.+24     	; 0x38bc <__divsf3x>
    38a4:	0a c1       	rjmp	.+532    	; 0x3aba <__fp_round>
    38a6:	02 d1       	rcall	.+516    	; 0x3aac <__fp_pscB>
    38a8:	40 f0       	brcs	.+16     	; 0x38ba <__divsf3+0x18>
    38aa:	f9 d0       	rcall	.+498    	; 0x3a9e <__fp_pscA>
    38ac:	30 f0       	brcs	.+12     	; 0x38ba <__divsf3+0x18>
    38ae:	21 f4       	brne	.+8      	; 0x38b8 <__divsf3+0x16>
    38b0:	5f 3f       	cpi	r21, 0xFF	; 255
    38b2:	19 f0       	breq	.+6      	; 0x38ba <__divsf3+0x18>
    38b4:	eb c0       	rjmp	.+470    	; 0x3a8c <__fp_inf>
    38b6:	51 11       	cpse	r21, r1
    38b8:	34 c1       	rjmp	.+616    	; 0x3b22 <__fp_szero>
    38ba:	ee c0       	rjmp	.+476    	; 0x3a98 <__fp_nan>

000038bc <__divsf3x>:
    38bc:	0f d1       	rcall	.+542    	; 0x3adc <__fp_split3>
    38be:	98 f3       	brcs	.-26     	; 0x38a6 <__divsf3+0x4>

000038c0 <__divsf3_pse>:
    38c0:	99 23       	and	r25, r25
    38c2:	c9 f3       	breq	.-14     	; 0x38b6 <__divsf3+0x14>
    38c4:	55 23       	and	r21, r21
    38c6:	b1 f3       	breq	.-20     	; 0x38b4 <__divsf3+0x12>
    38c8:	95 1b       	sub	r25, r21
    38ca:	55 0b       	sbc	r21, r21
    38cc:	bb 27       	eor	r27, r27
    38ce:	aa 27       	eor	r26, r26
    38d0:	62 17       	cp	r22, r18
    38d2:	73 07       	cpc	r23, r19
    38d4:	84 07       	cpc	r24, r20
    38d6:	38 f0       	brcs	.+14     	; 0x38e6 <__divsf3_pse+0x26>
    38d8:	9f 5f       	subi	r25, 0xFF	; 255
    38da:	5f 4f       	sbci	r21, 0xFF	; 255
    38dc:	22 0f       	add	r18, r18
    38de:	33 1f       	adc	r19, r19
    38e0:	44 1f       	adc	r20, r20
    38e2:	aa 1f       	adc	r26, r26
    38e4:	a9 f3       	breq	.-22     	; 0x38d0 <__divsf3_pse+0x10>
    38e6:	33 d0       	rcall	.+102    	; 0x394e <__divsf3_pse+0x8e>
    38e8:	0e 2e       	mov	r0, r30
    38ea:	3a f0       	brmi	.+14     	; 0x38fa <__divsf3_pse+0x3a>
    38ec:	e0 e8       	ldi	r30, 0x80	; 128
    38ee:	30 d0       	rcall	.+96     	; 0x3950 <__divsf3_pse+0x90>
    38f0:	91 50       	subi	r25, 0x01	; 1
    38f2:	50 40       	sbci	r21, 0x00	; 0
    38f4:	e6 95       	lsr	r30
    38f6:	00 1c       	adc	r0, r0
    38f8:	ca f7       	brpl	.-14     	; 0x38ec <__divsf3_pse+0x2c>
    38fa:	29 d0       	rcall	.+82     	; 0x394e <__divsf3_pse+0x8e>
    38fc:	fe 2f       	mov	r31, r30
    38fe:	27 d0       	rcall	.+78     	; 0x394e <__divsf3_pse+0x8e>
    3900:	66 0f       	add	r22, r22
    3902:	77 1f       	adc	r23, r23
    3904:	88 1f       	adc	r24, r24
    3906:	bb 1f       	adc	r27, r27
    3908:	26 17       	cp	r18, r22
    390a:	37 07       	cpc	r19, r23
    390c:	48 07       	cpc	r20, r24
    390e:	ab 07       	cpc	r26, r27
    3910:	b0 e8       	ldi	r27, 0x80	; 128
    3912:	09 f0       	breq	.+2      	; 0x3916 <__divsf3_pse+0x56>
    3914:	bb 0b       	sbc	r27, r27
    3916:	80 2d       	mov	r24, r0
    3918:	bf 01       	movw	r22, r30
    391a:	ff 27       	eor	r31, r31
    391c:	93 58       	subi	r25, 0x83	; 131
    391e:	5f 4f       	sbci	r21, 0xFF	; 255
    3920:	2a f0       	brmi	.+10     	; 0x392c <__divsf3_pse+0x6c>
    3922:	9e 3f       	cpi	r25, 0xFE	; 254
    3924:	51 05       	cpc	r21, r1
    3926:	68 f0       	brcs	.+26     	; 0x3942 <__divsf3_pse+0x82>
    3928:	b1 c0       	rjmp	.+354    	; 0x3a8c <__fp_inf>
    392a:	fb c0       	rjmp	.+502    	; 0x3b22 <__fp_szero>
    392c:	5f 3f       	cpi	r21, 0xFF	; 255
    392e:	ec f3       	brlt	.-6      	; 0x392a <__divsf3_pse+0x6a>
    3930:	98 3e       	cpi	r25, 0xE8	; 232
    3932:	dc f3       	brlt	.-10     	; 0x392a <__divsf3_pse+0x6a>
    3934:	86 95       	lsr	r24
    3936:	77 95       	ror	r23
    3938:	67 95       	ror	r22
    393a:	b7 95       	ror	r27
    393c:	f7 95       	ror	r31
    393e:	9f 5f       	subi	r25, 0xFF	; 255
    3940:	c9 f7       	brne	.-14     	; 0x3934 <__divsf3_pse+0x74>
    3942:	88 0f       	add	r24, r24
    3944:	91 1d       	adc	r25, r1
    3946:	96 95       	lsr	r25
    3948:	87 95       	ror	r24
    394a:	97 f9       	bld	r25, 7
    394c:	08 95       	ret
    394e:	e1 e0       	ldi	r30, 0x01	; 1
    3950:	66 0f       	add	r22, r22
    3952:	77 1f       	adc	r23, r23
    3954:	88 1f       	adc	r24, r24
    3956:	bb 1f       	adc	r27, r27
    3958:	62 17       	cp	r22, r18
    395a:	73 07       	cpc	r23, r19
    395c:	84 07       	cpc	r24, r20
    395e:	ba 07       	cpc	r27, r26
    3960:	20 f0       	brcs	.+8      	; 0x396a <__divsf3_pse+0xaa>
    3962:	62 1b       	sub	r22, r18
    3964:	73 0b       	sbc	r23, r19
    3966:	84 0b       	sbc	r24, r20
    3968:	ba 0b       	sbc	r27, r26
    396a:	ee 1f       	adc	r30, r30
    396c:	88 f7       	brcc	.-30     	; 0x3950 <__divsf3_pse+0x90>
    396e:	e0 95       	com	r30
    3970:	08 95       	ret

00003972 <__fixunssfsi>:
    3972:	bc d0       	rcall	.+376    	; 0x3aec <__fp_splitA>
    3974:	88 f0       	brcs	.+34     	; 0x3998 <__fixunssfsi+0x26>
    3976:	9f 57       	subi	r25, 0x7F	; 127
    3978:	90 f0       	brcs	.+36     	; 0x399e <__fixunssfsi+0x2c>
    397a:	b9 2f       	mov	r27, r25
    397c:	99 27       	eor	r25, r25
    397e:	b7 51       	subi	r27, 0x17	; 23
    3980:	a0 f0       	brcs	.+40     	; 0x39aa <__fixunssfsi+0x38>
    3982:	d1 f0       	breq	.+52     	; 0x39b8 <__fixunssfsi+0x46>
    3984:	66 0f       	add	r22, r22
    3986:	77 1f       	adc	r23, r23
    3988:	88 1f       	adc	r24, r24
    398a:	99 1f       	adc	r25, r25
    398c:	1a f0       	brmi	.+6      	; 0x3994 <__fixunssfsi+0x22>
    398e:	ba 95       	dec	r27
    3990:	c9 f7       	brne	.-14     	; 0x3984 <__fixunssfsi+0x12>
    3992:	12 c0       	rjmp	.+36     	; 0x39b8 <__fixunssfsi+0x46>
    3994:	b1 30       	cpi	r27, 0x01	; 1
    3996:	81 f0       	breq	.+32     	; 0x39b8 <__fixunssfsi+0x46>
    3998:	c3 d0       	rcall	.+390    	; 0x3b20 <__fp_zero>
    399a:	b1 e0       	ldi	r27, 0x01	; 1
    399c:	08 95       	ret
    399e:	c0 c0       	rjmp	.+384    	; 0x3b20 <__fp_zero>
    39a0:	67 2f       	mov	r22, r23
    39a2:	78 2f       	mov	r23, r24
    39a4:	88 27       	eor	r24, r24
    39a6:	b8 5f       	subi	r27, 0xF8	; 248
    39a8:	39 f0       	breq	.+14     	; 0x39b8 <__fixunssfsi+0x46>
    39aa:	b9 3f       	cpi	r27, 0xF9	; 249
    39ac:	cc f3       	brlt	.-14     	; 0x39a0 <__fixunssfsi+0x2e>
    39ae:	86 95       	lsr	r24
    39b0:	77 95       	ror	r23
    39b2:	67 95       	ror	r22
    39b4:	b3 95       	inc	r27
    39b6:	d9 f7       	brne	.-10     	; 0x39ae <__fixunssfsi+0x3c>
    39b8:	3e f4       	brtc	.+14     	; 0x39c8 <__fixunssfsi+0x56>
    39ba:	90 95       	com	r25
    39bc:	80 95       	com	r24
    39be:	70 95       	com	r23
    39c0:	61 95       	neg	r22
    39c2:	7f 4f       	sbci	r23, 0xFF	; 255
    39c4:	8f 4f       	sbci	r24, 0xFF	; 255
    39c6:	9f 4f       	sbci	r25, 0xFF	; 255
    39c8:	08 95       	ret

000039ca <__floatunsisf>:
    39ca:	e8 94       	clt
    39cc:	09 c0       	rjmp	.+18     	; 0x39e0 <__floatsisf+0x12>

000039ce <__floatsisf>:
    39ce:	97 fb       	bst	r25, 7
    39d0:	3e f4       	brtc	.+14     	; 0x39e0 <__floatsisf+0x12>
    39d2:	90 95       	com	r25
    39d4:	80 95       	com	r24
    39d6:	70 95       	com	r23
    39d8:	61 95       	neg	r22
    39da:	7f 4f       	sbci	r23, 0xFF	; 255
    39dc:	8f 4f       	sbci	r24, 0xFF	; 255
    39de:	9f 4f       	sbci	r25, 0xFF	; 255
    39e0:	99 23       	and	r25, r25
    39e2:	a9 f0       	breq	.+42     	; 0x3a0e <__floatsisf+0x40>
    39e4:	f9 2f       	mov	r31, r25
    39e6:	96 e9       	ldi	r25, 0x96	; 150
    39e8:	bb 27       	eor	r27, r27
    39ea:	93 95       	inc	r25
    39ec:	f6 95       	lsr	r31
    39ee:	87 95       	ror	r24
    39f0:	77 95       	ror	r23
    39f2:	67 95       	ror	r22
    39f4:	b7 95       	ror	r27
    39f6:	f1 11       	cpse	r31, r1
    39f8:	f8 cf       	rjmp	.-16     	; 0x39ea <__floatsisf+0x1c>
    39fa:	fa f4       	brpl	.+62     	; 0x3a3a <__floatsisf+0x6c>
    39fc:	bb 0f       	add	r27, r27
    39fe:	11 f4       	brne	.+4      	; 0x3a04 <__floatsisf+0x36>
    3a00:	60 ff       	sbrs	r22, 0
    3a02:	1b c0       	rjmp	.+54     	; 0x3a3a <__floatsisf+0x6c>
    3a04:	6f 5f       	subi	r22, 0xFF	; 255
    3a06:	7f 4f       	sbci	r23, 0xFF	; 255
    3a08:	8f 4f       	sbci	r24, 0xFF	; 255
    3a0a:	9f 4f       	sbci	r25, 0xFF	; 255
    3a0c:	16 c0       	rjmp	.+44     	; 0x3a3a <__floatsisf+0x6c>
    3a0e:	88 23       	and	r24, r24
    3a10:	11 f0       	breq	.+4      	; 0x3a16 <__floatsisf+0x48>
    3a12:	96 e9       	ldi	r25, 0x96	; 150
    3a14:	11 c0       	rjmp	.+34     	; 0x3a38 <__floatsisf+0x6a>
    3a16:	77 23       	and	r23, r23
    3a18:	21 f0       	breq	.+8      	; 0x3a22 <__floatsisf+0x54>
    3a1a:	9e e8       	ldi	r25, 0x8E	; 142
    3a1c:	87 2f       	mov	r24, r23
    3a1e:	76 2f       	mov	r23, r22
    3a20:	05 c0       	rjmp	.+10     	; 0x3a2c <__floatsisf+0x5e>
    3a22:	66 23       	and	r22, r22
    3a24:	71 f0       	breq	.+28     	; 0x3a42 <__floatsisf+0x74>
    3a26:	96 e8       	ldi	r25, 0x86	; 134
    3a28:	86 2f       	mov	r24, r22
    3a2a:	70 e0       	ldi	r23, 0x00	; 0
    3a2c:	60 e0       	ldi	r22, 0x00	; 0
    3a2e:	2a f0       	brmi	.+10     	; 0x3a3a <__floatsisf+0x6c>
    3a30:	9a 95       	dec	r25
    3a32:	66 0f       	add	r22, r22
    3a34:	77 1f       	adc	r23, r23
    3a36:	88 1f       	adc	r24, r24
    3a38:	da f7       	brpl	.-10     	; 0x3a30 <__floatsisf+0x62>
    3a3a:	88 0f       	add	r24, r24
    3a3c:	96 95       	lsr	r25
    3a3e:	87 95       	ror	r24
    3a40:	97 f9       	bld	r25, 7
    3a42:	08 95       	ret

00003a44 <__fp_cmp>:
    3a44:	99 0f       	add	r25, r25
    3a46:	00 08       	sbc	r0, r0
    3a48:	55 0f       	add	r21, r21
    3a4a:	aa 0b       	sbc	r26, r26
    3a4c:	e0 e8       	ldi	r30, 0x80	; 128
    3a4e:	fe ef       	ldi	r31, 0xFE	; 254
    3a50:	16 16       	cp	r1, r22
    3a52:	17 06       	cpc	r1, r23
    3a54:	e8 07       	cpc	r30, r24
    3a56:	f9 07       	cpc	r31, r25
    3a58:	c0 f0       	brcs	.+48     	; 0x3a8a <__fp_cmp+0x46>
    3a5a:	12 16       	cp	r1, r18
    3a5c:	13 06       	cpc	r1, r19
    3a5e:	e4 07       	cpc	r30, r20
    3a60:	f5 07       	cpc	r31, r21
    3a62:	98 f0       	brcs	.+38     	; 0x3a8a <__fp_cmp+0x46>
    3a64:	62 1b       	sub	r22, r18
    3a66:	73 0b       	sbc	r23, r19
    3a68:	84 0b       	sbc	r24, r20
    3a6a:	95 0b       	sbc	r25, r21
    3a6c:	39 f4       	brne	.+14     	; 0x3a7c <__fp_cmp+0x38>
    3a6e:	0a 26       	eor	r0, r26
    3a70:	61 f0       	breq	.+24     	; 0x3a8a <__fp_cmp+0x46>
    3a72:	23 2b       	or	r18, r19
    3a74:	24 2b       	or	r18, r20
    3a76:	25 2b       	or	r18, r21
    3a78:	21 f4       	brne	.+8      	; 0x3a82 <__fp_cmp+0x3e>
    3a7a:	08 95       	ret
    3a7c:	0a 26       	eor	r0, r26
    3a7e:	09 f4       	brne	.+2      	; 0x3a82 <__fp_cmp+0x3e>
    3a80:	a1 40       	sbci	r26, 0x01	; 1
    3a82:	a6 95       	lsr	r26
    3a84:	8f ef       	ldi	r24, 0xFF	; 255
    3a86:	81 1d       	adc	r24, r1
    3a88:	81 1d       	adc	r24, r1
    3a8a:	08 95       	ret

00003a8c <__fp_inf>:
    3a8c:	97 f9       	bld	r25, 7
    3a8e:	9f 67       	ori	r25, 0x7F	; 127
    3a90:	80 e8       	ldi	r24, 0x80	; 128
    3a92:	70 e0       	ldi	r23, 0x00	; 0
    3a94:	60 e0       	ldi	r22, 0x00	; 0
    3a96:	08 95       	ret

00003a98 <__fp_nan>:
    3a98:	9f ef       	ldi	r25, 0xFF	; 255
    3a9a:	80 ec       	ldi	r24, 0xC0	; 192
    3a9c:	08 95       	ret

00003a9e <__fp_pscA>:
    3a9e:	00 24       	eor	r0, r0
    3aa0:	0a 94       	dec	r0
    3aa2:	16 16       	cp	r1, r22
    3aa4:	17 06       	cpc	r1, r23
    3aa6:	18 06       	cpc	r1, r24
    3aa8:	09 06       	cpc	r0, r25
    3aaa:	08 95       	ret

00003aac <__fp_pscB>:
    3aac:	00 24       	eor	r0, r0
    3aae:	0a 94       	dec	r0
    3ab0:	12 16       	cp	r1, r18
    3ab2:	13 06       	cpc	r1, r19
    3ab4:	14 06       	cpc	r1, r20
    3ab6:	05 06       	cpc	r0, r21
    3ab8:	08 95       	ret

00003aba <__fp_round>:
    3aba:	09 2e       	mov	r0, r25
    3abc:	03 94       	inc	r0
    3abe:	00 0c       	add	r0, r0
    3ac0:	11 f4       	brne	.+4      	; 0x3ac6 <__fp_round+0xc>
    3ac2:	88 23       	and	r24, r24
    3ac4:	52 f0       	brmi	.+20     	; 0x3ada <__fp_round+0x20>
    3ac6:	bb 0f       	add	r27, r27
    3ac8:	40 f4       	brcc	.+16     	; 0x3ada <__fp_round+0x20>
    3aca:	bf 2b       	or	r27, r31
    3acc:	11 f4       	brne	.+4      	; 0x3ad2 <__fp_round+0x18>
    3ace:	60 ff       	sbrs	r22, 0
    3ad0:	04 c0       	rjmp	.+8      	; 0x3ada <__fp_round+0x20>
    3ad2:	6f 5f       	subi	r22, 0xFF	; 255
    3ad4:	7f 4f       	sbci	r23, 0xFF	; 255
    3ad6:	8f 4f       	sbci	r24, 0xFF	; 255
    3ad8:	9f 4f       	sbci	r25, 0xFF	; 255
    3ada:	08 95       	ret

00003adc <__fp_split3>:
    3adc:	57 fd       	sbrc	r21, 7
    3ade:	90 58       	subi	r25, 0x80	; 128
    3ae0:	44 0f       	add	r20, r20
    3ae2:	55 1f       	adc	r21, r21
    3ae4:	59 f0       	breq	.+22     	; 0x3afc <__fp_splitA+0x10>
    3ae6:	5f 3f       	cpi	r21, 0xFF	; 255
    3ae8:	71 f0       	breq	.+28     	; 0x3b06 <__fp_splitA+0x1a>
    3aea:	47 95       	ror	r20

00003aec <__fp_splitA>:
    3aec:	88 0f       	add	r24, r24
    3aee:	97 fb       	bst	r25, 7
    3af0:	99 1f       	adc	r25, r25
    3af2:	61 f0       	breq	.+24     	; 0x3b0c <__fp_splitA+0x20>
    3af4:	9f 3f       	cpi	r25, 0xFF	; 255
    3af6:	79 f0       	breq	.+30     	; 0x3b16 <__fp_splitA+0x2a>
    3af8:	87 95       	ror	r24
    3afa:	08 95       	ret
    3afc:	12 16       	cp	r1, r18
    3afe:	13 06       	cpc	r1, r19
    3b00:	14 06       	cpc	r1, r20
    3b02:	55 1f       	adc	r21, r21
    3b04:	f2 cf       	rjmp	.-28     	; 0x3aea <__fp_split3+0xe>
    3b06:	46 95       	lsr	r20
    3b08:	f1 df       	rcall	.-30     	; 0x3aec <__fp_splitA>
    3b0a:	08 c0       	rjmp	.+16     	; 0x3b1c <__fp_splitA+0x30>
    3b0c:	16 16       	cp	r1, r22
    3b0e:	17 06       	cpc	r1, r23
    3b10:	18 06       	cpc	r1, r24
    3b12:	99 1f       	adc	r25, r25
    3b14:	f1 cf       	rjmp	.-30     	; 0x3af8 <__fp_splitA+0xc>
    3b16:	86 95       	lsr	r24
    3b18:	71 05       	cpc	r23, r1
    3b1a:	61 05       	cpc	r22, r1
    3b1c:	08 94       	sec
    3b1e:	08 95       	ret

00003b20 <__fp_zero>:
    3b20:	e8 94       	clt

00003b22 <__fp_szero>:
    3b22:	bb 27       	eor	r27, r27
    3b24:	66 27       	eor	r22, r22
    3b26:	77 27       	eor	r23, r23
    3b28:	cb 01       	movw	r24, r22
    3b2a:	97 f9       	bld	r25, 7
    3b2c:	08 95       	ret

00003b2e <__gesf2>:
    3b2e:	8a df       	rcall	.-236    	; 0x3a44 <__fp_cmp>
    3b30:	08 f4       	brcc	.+2      	; 0x3b34 <__gesf2+0x6>
    3b32:	8f ef       	ldi	r24, 0xFF	; 255
    3b34:	08 95       	ret

00003b36 <__mulsf3>:
    3b36:	0b d0       	rcall	.+22     	; 0x3b4e <__mulsf3x>
    3b38:	c0 cf       	rjmp	.-128    	; 0x3aba <__fp_round>
    3b3a:	b1 df       	rcall	.-158    	; 0x3a9e <__fp_pscA>
    3b3c:	28 f0       	brcs	.+10     	; 0x3b48 <__mulsf3+0x12>
    3b3e:	b6 df       	rcall	.-148    	; 0x3aac <__fp_pscB>
    3b40:	18 f0       	brcs	.+6      	; 0x3b48 <__mulsf3+0x12>
    3b42:	95 23       	and	r25, r21
    3b44:	09 f0       	breq	.+2      	; 0x3b48 <__mulsf3+0x12>
    3b46:	a2 cf       	rjmp	.-188    	; 0x3a8c <__fp_inf>
    3b48:	a7 cf       	rjmp	.-178    	; 0x3a98 <__fp_nan>
    3b4a:	11 24       	eor	r1, r1
    3b4c:	ea cf       	rjmp	.-44     	; 0x3b22 <__fp_szero>

00003b4e <__mulsf3x>:
    3b4e:	c6 df       	rcall	.-116    	; 0x3adc <__fp_split3>
    3b50:	a0 f3       	brcs	.-24     	; 0x3b3a <__mulsf3+0x4>

00003b52 <__mulsf3_pse>:
    3b52:	95 9f       	mul	r25, r21
    3b54:	d1 f3       	breq	.-12     	; 0x3b4a <__mulsf3+0x14>
    3b56:	95 0f       	add	r25, r21
    3b58:	50 e0       	ldi	r21, 0x00	; 0
    3b5a:	55 1f       	adc	r21, r21
    3b5c:	62 9f       	mul	r22, r18
    3b5e:	f0 01       	movw	r30, r0
    3b60:	72 9f       	mul	r23, r18
    3b62:	bb 27       	eor	r27, r27
    3b64:	f0 0d       	add	r31, r0
    3b66:	b1 1d       	adc	r27, r1
    3b68:	63 9f       	mul	r22, r19
    3b6a:	aa 27       	eor	r26, r26
    3b6c:	f0 0d       	add	r31, r0
    3b6e:	b1 1d       	adc	r27, r1
    3b70:	aa 1f       	adc	r26, r26
    3b72:	64 9f       	mul	r22, r20
    3b74:	66 27       	eor	r22, r22
    3b76:	b0 0d       	add	r27, r0
    3b78:	a1 1d       	adc	r26, r1
    3b7a:	66 1f       	adc	r22, r22
    3b7c:	82 9f       	mul	r24, r18
    3b7e:	22 27       	eor	r18, r18
    3b80:	b0 0d       	add	r27, r0
    3b82:	a1 1d       	adc	r26, r1
    3b84:	62 1f       	adc	r22, r18
    3b86:	73 9f       	mul	r23, r19
    3b88:	b0 0d       	add	r27, r0
    3b8a:	a1 1d       	adc	r26, r1
    3b8c:	62 1f       	adc	r22, r18
    3b8e:	83 9f       	mul	r24, r19
    3b90:	a0 0d       	add	r26, r0
    3b92:	61 1d       	adc	r22, r1
    3b94:	22 1f       	adc	r18, r18
    3b96:	74 9f       	mul	r23, r20
    3b98:	33 27       	eor	r19, r19
    3b9a:	a0 0d       	add	r26, r0
    3b9c:	61 1d       	adc	r22, r1
    3b9e:	23 1f       	adc	r18, r19
    3ba0:	84 9f       	mul	r24, r20
    3ba2:	60 0d       	add	r22, r0
    3ba4:	21 1d       	adc	r18, r1
    3ba6:	82 2f       	mov	r24, r18
    3ba8:	76 2f       	mov	r23, r22
    3baa:	6a 2f       	mov	r22, r26
    3bac:	11 24       	eor	r1, r1
    3bae:	9f 57       	subi	r25, 0x7F	; 127
    3bb0:	50 40       	sbci	r21, 0x00	; 0
    3bb2:	8a f0       	brmi	.+34     	; 0x3bd6 <__mulsf3_pse+0x84>
    3bb4:	e1 f0       	breq	.+56     	; 0x3bee <__mulsf3_pse+0x9c>
    3bb6:	88 23       	and	r24, r24
    3bb8:	4a f0       	brmi	.+18     	; 0x3bcc <__mulsf3_pse+0x7a>
    3bba:	ee 0f       	add	r30, r30
    3bbc:	ff 1f       	adc	r31, r31
    3bbe:	bb 1f       	adc	r27, r27
    3bc0:	66 1f       	adc	r22, r22
    3bc2:	77 1f       	adc	r23, r23
    3bc4:	88 1f       	adc	r24, r24
    3bc6:	91 50       	subi	r25, 0x01	; 1
    3bc8:	50 40       	sbci	r21, 0x00	; 0
    3bca:	a9 f7       	brne	.-22     	; 0x3bb6 <__mulsf3_pse+0x64>
    3bcc:	9e 3f       	cpi	r25, 0xFE	; 254
    3bce:	51 05       	cpc	r21, r1
    3bd0:	70 f0       	brcs	.+28     	; 0x3bee <__mulsf3_pse+0x9c>
    3bd2:	5c cf       	rjmp	.-328    	; 0x3a8c <__fp_inf>
    3bd4:	a6 cf       	rjmp	.-180    	; 0x3b22 <__fp_szero>
    3bd6:	5f 3f       	cpi	r21, 0xFF	; 255
    3bd8:	ec f3       	brlt	.-6      	; 0x3bd4 <__mulsf3_pse+0x82>
    3bda:	98 3e       	cpi	r25, 0xE8	; 232
    3bdc:	dc f3       	brlt	.-10     	; 0x3bd4 <__mulsf3_pse+0x82>
    3bde:	86 95       	lsr	r24
    3be0:	77 95       	ror	r23
    3be2:	67 95       	ror	r22
    3be4:	b7 95       	ror	r27
    3be6:	f7 95       	ror	r31
    3be8:	e7 95       	ror	r30
    3bea:	9f 5f       	subi	r25, 0xFF	; 255
    3bec:	c1 f7       	brne	.-16     	; 0x3bde <__mulsf3_pse+0x8c>
    3bee:	fe 2b       	or	r31, r30
    3bf0:	88 0f       	add	r24, r24
    3bf2:	91 1d       	adc	r25, r1
    3bf4:	96 95       	lsr	r25
    3bf6:	87 95       	ror	r24
    3bf8:	97 f9       	bld	r25, 7
    3bfa:	08 95       	ret

00003bfc <__umulhisi3>:
    3bfc:	a2 9f       	mul	r26, r18
    3bfe:	b0 01       	movw	r22, r0
    3c00:	b3 9f       	mul	r27, r19
    3c02:	c0 01       	movw	r24, r0
    3c04:	a3 9f       	mul	r26, r19
    3c06:	70 0d       	add	r23, r0
    3c08:	81 1d       	adc	r24, r1
    3c0a:	11 24       	eor	r1, r1
    3c0c:	91 1d       	adc	r25, r1
    3c0e:	b2 9f       	mul	r27, r18
    3c10:	70 0d       	add	r23, r0
    3c12:	81 1d       	adc	r24, r1
    3c14:	11 24       	eor	r1, r1
    3c16:	91 1d       	adc	r25, r1
    3c18:	08 95       	ret

00003c1a <__tablejump2__>:
    3c1a:	ee 0f       	add	r30, r30
    3c1c:	ff 1f       	adc	r31, r31
    3c1e:	88 1f       	adc	r24, r24
    3c20:	8b bf       	out	0x3b, r24	; 59
    3c22:	07 90       	elpm	r0, Z+
    3c24:	f6 91       	elpm	r31, Z
    3c26:	e0 2d       	mov	r30, r0
    3c28:	19 94       	eijmp

00003c2a <malloc>:
    3c2a:	0f 93       	push	r16
    3c2c:	1f 93       	push	r17
    3c2e:	cf 93       	push	r28
    3c30:	df 93       	push	r29
    3c32:	82 30       	cpi	r24, 0x02	; 2
    3c34:	91 05       	cpc	r25, r1
    3c36:	10 f4       	brcc	.+4      	; 0x3c3c <malloc+0x12>
    3c38:	82 e0       	ldi	r24, 0x02	; 2
    3c3a:	90 e0       	ldi	r25, 0x00	; 0
    3c3c:	e0 91 e2 12 	lds	r30, 0x12E2	; 0x8012e2 <__flp>
    3c40:	f0 91 e3 12 	lds	r31, 0x12E3	; 0x8012e3 <__flp+0x1>
    3c44:	20 e0       	ldi	r18, 0x00	; 0
    3c46:	30 e0       	ldi	r19, 0x00	; 0
    3c48:	a0 e0       	ldi	r26, 0x00	; 0
    3c4a:	b0 e0       	ldi	r27, 0x00	; 0
    3c4c:	30 97       	sbiw	r30, 0x00	; 0
    3c4e:	19 f1       	breq	.+70     	; 0x3c96 <malloc+0x6c>
    3c50:	40 81       	ld	r20, Z
    3c52:	51 81       	ldd	r21, Z+1	; 0x01
    3c54:	02 81       	ldd	r16, Z+2	; 0x02
    3c56:	13 81       	ldd	r17, Z+3	; 0x03
    3c58:	48 17       	cp	r20, r24
    3c5a:	59 07       	cpc	r21, r25
    3c5c:	c8 f0       	brcs	.+50     	; 0x3c90 <malloc+0x66>
    3c5e:	84 17       	cp	r24, r20
    3c60:	95 07       	cpc	r25, r21
    3c62:	69 f4       	brne	.+26     	; 0x3c7e <malloc+0x54>
    3c64:	10 97       	sbiw	r26, 0x00	; 0
    3c66:	31 f0       	breq	.+12     	; 0x3c74 <malloc+0x4a>
    3c68:	12 96       	adiw	r26, 0x02	; 2
    3c6a:	0c 93       	st	X, r16
    3c6c:	12 97       	sbiw	r26, 0x02	; 2
    3c6e:	13 96       	adiw	r26, 0x03	; 3
    3c70:	1c 93       	st	X, r17
    3c72:	27 c0       	rjmp	.+78     	; 0x3cc2 <malloc+0x98>
    3c74:	00 93 e2 12 	sts	0x12E2, r16	; 0x8012e2 <__flp>
    3c78:	10 93 e3 12 	sts	0x12E3, r17	; 0x8012e3 <__flp+0x1>
    3c7c:	22 c0       	rjmp	.+68     	; 0x3cc2 <malloc+0x98>
    3c7e:	21 15       	cp	r18, r1
    3c80:	31 05       	cpc	r19, r1
    3c82:	19 f0       	breq	.+6      	; 0x3c8a <malloc+0x60>
    3c84:	42 17       	cp	r20, r18
    3c86:	53 07       	cpc	r21, r19
    3c88:	18 f4       	brcc	.+6      	; 0x3c90 <malloc+0x66>
    3c8a:	9a 01       	movw	r18, r20
    3c8c:	bd 01       	movw	r22, r26
    3c8e:	ef 01       	movw	r28, r30
    3c90:	df 01       	movw	r26, r30
    3c92:	f8 01       	movw	r30, r16
    3c94:	db cf       	rjmp	.-74     	; 0x3c4c <malloc+0x22>
    3c96:	21 15       	cp	r18, r1
    3c98:	31 05       	cpc	r19, r1
    3c9a:	f9 f0       	breq	.+62     	; 0x3cda <malloc+0xb0>
    3c9c:	28 1b       	sub	r18, r24
    3c9e:	39 0b       	sbc	r19, r25
    3ca0:	24 30       	cpi	r18, 0x04	; 4
    3ca2:	31 05       	cpc	r19, r1
    3ca4:	80 f4       	brcc	.+32     	; 0x3cc6 <malloc+0x9c>
    3ca6:	8a 81       	ldd	r24, Y+2	; 0x02
    3ca8:	9b 81       	ldd	r25, Y+3	; 0x03
    3caa:	61 15       	cp	r22, r1
    3cac:	71 05       	cpc	r23, r1
    3cae:	21 f0       	breq	.+8      	; 0x3cb8 <malloc+0x8e>
    3cb0:	fb 01       	movw	r30, r22
    3cb2:	93 83       	std	Z+3, r25	; 0x03
    3cb4:	82 83       	std	Z+2, r24	; 0x02
    3cb6:	04 c0       	rjmp	.+8      	; 0x3cc0 <malloc+0x96>
    3cb8:	90 93 e3 12 	sts	0x12E3, r25	; 0x8012e3 <__flp+0x1>
    3cbc:	80 93 e2 12 	sts	0x12E2, r24	; 0x8012e2 <__flp>
    3cc0:	fe 01       	movw	r30, r28
    3cc2:	32 96       	adiw	r30, 0x02	; 2
    3cc4:	44 c0       	rjmp	.+136    	; 0x3d4e <malloc+0x124>
    3cc6:	fe 01       	movw	r30, r28
    3cc8:	e2 0f       	add	r30, r18
    3cca:	f3 1f       	adc	r31, r19
    3ccc:	81 93       	st	Z+, r24
    3cce:	91 93       	st	Z+, r25
    3cd0:	22 50       	subi	r18, 0x02	; 2
    3cd2:	31 09       	sbc	r19, r1
    3cd4:	39 83       	std	Y+1, r19	; 0x01
    3cd6:	28 83       	st	Y, r18
    3cd8:	3a c0       	rjmp	.+116    	; 0x3d4e <malloc+0x124>
    3cda:	20 91 e0 12 	lds	r18, 0x12E0	; 0x8012e0 <__brkval>
    3cde:	30 91 e1 12 	lds	r19, 0x12E1	; 0x8012e1 <__brkval+0x1>
    3ce2:	23 2b       	or	r18, r19
    3ce4:	41 f4       	brne	.+16     	; 0x3cf6 <malloc+0xcc>
    3ce6:	20 91 02 02 	lds	r18, 0x0202	; 0x800202 <__malloc_heap_start>
    3cea:	30 91 03 02 	lds	r19, 0x0203	; 0x800203 <__malloc_heap_start+0x1>
    3cee:	30 93 e1 12 	sts	0x12E1, r19	; 0x8012e1 <__brkval+0x1>
    3cf2:	20 93 e0 12 	sts	0x12E0, r18	; 0x8012e0 <__brkval>
    3cf6:	20 91 00 02 	lds	r18, 0x0200	; 0x800200 <__data_start>
    3cfa:	30 91 01 02 	lds	r19, 0x0201	; 0x800201 <__data_start+0x1>
    3cfe:	21 15       	cp	r18, r1
    3d00:	31 05       	cpc	r19, r1
    3d02:	41 f4       	brne	.+16     	; 0x3d14 <malloc+0xea>
    3d04:	2d b7       	in	r18, 0x3d	; 61
    3d06:	3e b7       	in	r19, 0x3e	; 62
    3d08:	40 91 04 02 	lds	r20, 0x0204	; 0x800204 <__malloc_margin>
    3d0c:	50 91 05 02 	lds	r21, 0x0205	; 0x800205 <__malloc_margin+0x1>
    3d10:	24 1b       	sub	r18, r20
    3d12:	35 0b       	sbc	r19, r21
    3d14:	e0 91 e0 12 	lds	r30, 0x12E0	; 0x8012e0 <__brkval>
    3d18:	f0 91 e1 12 	lds	r31, 0x12E1	; 0x8012e1 <__brkval+0x1>
    3d1c:	e2 17       	cp	r30, r18
    3d1e:	f3 07       	cpc	r31, r19
    3d20:	a0 f4       	brcc	.+40     	; 0x3d4a <malloc+0x120>
    3d22:	2e 1b       	sub	r18, r30
    3d24:	3f 0b       	sbc	r19, r31
    3d26:	28 17       	cp	r18, r24
    3d28:	39 07       	cpc	r19, r25
    3d2a:	78 f0       	brcs	.+30     	; 0x3d4a <malloc+0x120>
    3d2c:	ac 01       	movw	r20, r24
    3d2e:	4e 5f       	subi	r20, 0xFE	; 254
    3d30:	5f 4f       	sbci	r21, 0xFF	; 255
    3d32:	24 17       	cp	r18, r20
    3d34:	35 07       	cpc	r19, r21
    3d36:	48 f0       	brcs	.+18     	; 0x3d4a <malloc+0x120>
    3d38:	4e 0f       	add	r20, r30
    3d3a:	5f 1f       	adc	r21, r31
    3d3c:	50 93 e1 12 	sts	0x12E1, r21	; 0x8012e1 <__brkval+0x1>
    3d40:	40 93 e0 12 	sts	0x12E0, r20	; 0x8012e0 <__brkval>
    3d44:	81 93       	st	Z+, r24
    3d46:	91 93       	st	Z+, r25
    3d48:	02 c0       	rjmp	.+4      	; 0x3d4e <malloc+0x124>
    3d4a:	e0 e0       	ldi	r30, 0x00	; 0
    3d4c:	f0 e0       	ldi	r31, 0x00	; 0
    3d4e:	cf 01       	movw	r24, r30
    3d50:	df 91       	pop	r29
    3d52:	cf 91       	pop	r28
    3d54:	1f 91       	pop	r17
    3d56:	0f 91       	pop	r16
    3d58:	08 95       	ret

00003d5a <free>:
    3d5a:	cf 93       	push	r28
    3d5c:	df 93       	push	r29
    3d5e:	00 97       	sbiw	r24, 0x00	; 0
    3d60:	09 f4       	brne	.+2      	; 0x3d64 <free+0xa>
    3d62:	81 c0       	rjmp	.+258    	; 0x3e66 <free+0x10c>
    3d64:	fc 01       	movw	r30, r24
    3d66:	32 97       	sbiw	r30, 0x02	; 2
    3d68:	13 82       	std	Z+3, r1	; 0x03
    3d6a:	12 82       	std	Z+2, r1	; 0x02
    3d6c:	a0 91 e2 12 	lds	r26, 0x12E2	; 0x8012e2 <__flp>
    3d70:	b0 91 e3 12 	lds	r27, 0x12E3	; 0x8012e3 <__flp+0x1>
    3d74:	10 97       	sbiw	r26, 0x00	; 0
    3d76:	81 f4       	brne	.+32     	; 0x3d98 <free+0x3e>
    3d78:	20 81       	ld	r18, Z
    3d7a:	31 81       	ldd	r19, Z+1	; 0x01
    3d7c:	82 0f       	add	r24, r18
    3d7e:	93 1f       	adc	r25, r19
    3d80:	20 91 e0 12 	lds	r18, 0x12E0	; 0x8012e0 <__brkval>
    3d84:	30 91 e1 12 	lds	r19, 0x12E1	; 0x8012e1 <__brkval+0x1>
    3d88:	28 17       	cp	r18, r24
    3d8a:	39 07       	cpc	r19, r25
    3d8c:	51 f5       	brne	.+84     	; 0x3de2 <free+0x88>
    3d8e:	f0 93 e1 12 	sts	0x12E1, r31	; 0x8012e1 <__brkval+0x1>
    3d92:	e0 93 e0 12 	sts	0x12E0, r30	; 0x8012e0 <__brkval>
    3d96:	67 c0       	rjmp	.+206    	; 0x3e66 <free+0x10c>
    3d98:	ed 01       	movw	r28, r26
    3d9a:	20 e0       	ldi	r18, 0x00	; 0
    3d9c:	30 e0       	ldi	r19, 0x00	; 0
    3d9e:	ce 17       	cp	r28, r30
    3da0:	df 07       	cpc	r29, r31
    3da2:	40 f4       	brcc	.+16     	; 0x3db4 <free+0x5a>
    3da4:	4a 81       	ldd	r20, Y+2	; 0x02
    3da6:	5b 81       	ldd	r21, Y+3	; 0x03
    3da8:	9e 01       	movw	r18, r28
    3daa:	41 15       	cp	r20, r1
    3dac:	51 05       	cpc	r21, r1
    3dae:	f1 f0       	breq	.+60     	; 0x3dec <free+0x92>
    3db0:	ea 01       	movw	r28, r20
    3db2:	f5 cf       	rjmp	.-22     	; 0x3d9e <free+0x44>
    3db4:	d3 83       	std	Z+3, r29	; 0x03
    3db6:	c2 83       	std	Z+2, r28	; 0x02
    3db8:	40 81       	ld	r20, Z
    3dba:	51 81       	ldd	r21, Z+1	; 0x01
    3dbc:	84 0f       	add	r24, r20
    3dbe:	95 1f       	adc	r25, r21
    3dc0:	c8 17       	cp	r28, r24
    3dc2:	d9 07       	cpc	r29, r25
    3dc4:	59 f4       	brne	.+22     	; 0x3ddc <free+0x82>
    3dc6:	88 81       	ld	r24, Y
    3dc8:	99 81       	ldd	r25, Y+1	; 0x01
    3dca:	84 0f       	add	r24, r20
    3dcc:	95 1f       	adc	r25, r21
    3dce:	02 96       	adiw	r24, 0x02	; 2
    3dd0:	91 83       	std	Z+1, r25	; 0x01
    3dd2:	80 83       	st	Z, r24
    3dd4:	8a 81       	ldd	r24, Y+2	; 0x02
    3dd6:	9b 81       	ldd	r25, Y+3	; 0x03
    3dd8:	93 83       	std	Z+3, r25	; 0x03
    3dda:	82 83       	std	Z+2, r24	; 0x02
    3ddc:	21 15       	cp	r18, r1
    3dde:	31 05       	cpc	r19, r1
    3de0:	29 f4       	brne	.+10     	; 0x3dec <free+0x92>
    3de2:	f0 93 e3 12 	sts	0x12E3, r31	; 0x8012e3 <__flp+0x1>
    3de6:	e0 93 e2 12 	sts	0x12E2, r30	; 0x8012e2 <__flp>
    3dea:	3d c0       	rjmp	.+122    	; 0x3e66 <free+0x10c>
    3dec:	e9 01       	movw	r28, r18
    3dee:	fb 83       	std	Y+3, r31	; 0x03
    3df0:	ea 83       	std	Y+2, r30	; 0x02
    3df2:	49 91       	ld	r20, Y+
    3df4:	59 91       	ld	r21, Y+
    3df6:	c4 0f       	add	r28, r20
    3df8:	d5 1f       	adc	r29, r21
    3dfa:	ec 17       	cp	r30, r28
    3dfc:	fd 07       	cpc	r31, r29
    3dfe:	61 f4       	brne	.+24     	; 0x3e18 <free+0xbe>
    3e00:	80 81       	ld	r24, Z
    3e02:	91 81       	ldd	r25, Z+1	; 0x01
    3e04:	84 0f       	add	r24, r20
    3e06:	95 1f       	adc	r25, r21
    3e08:	02 96       	adiw	r24, 0x02	; 2
    3e0a:	e9 01       	movw	r28, r18
    3e0c:	99 83       	std	Y+1, r25	; 0x01
    3e0e:	88 83       	st	Y, r24
    3e10:	82 81       	ldd	r24, Z+2	; 0x02
    3e12:	93 81       	ldd	r25, Z+3	; 0x03
    3e14:	9b 83       	std	Y+3, r25	; 0x03
    3e16:	8a 83       	std	Y+2, r24	; 0x02
    3e18:	e0 e0       	ldi	r30, 0x00	; 0
    3e1a:	f0 e0       	ldi	r31, 0x00	; 0
    3e1c:	12 96       	adiw	r26, 0x02	; 2
    3e1e:	8d 91       	ld	r24, X+
    3e20:	9c 91       	ld	r25, X
    3e22:	13 97       	sbiw	r26, 0x03	; 3
    3e24:	00 97       	sbiw	r24, 0x00	; 0
    3e26:	19 f0       	breq	.+6      	; 0x3e2e <free+0xd4>
    3e28:	fd 01       	movw	r30, r26
    3e2a:	dc 01       	movw	r26, r24
    3e2c:	f7 cf       	rjmp	.-18     	; 0x3e1c <free+0xc2>
    3e2e:	8d 91       	ld	r24, X+
    3e30:	9c 91       	ld	r25, X
    3e32:	11 97       	sbiw	r26, 0x01	; 1
    3e34:	9d 01       	movw	r18, r26
    3e36:	2e 5f       	subi	r18, 0xFE	; 254
    3e38:	3f 4f       	sbci	r19, 0xFF	; 255
    3e3a:	82 0f       	add	r24, r18
    3e3c:	93 1f       	adc	r25, r19
    3e3e:	20 91 e0 12 	lds	r18, 0x12E0	; 0x8012e0 <__brkval>
    3e42:	30 91 e1 12 	lds	r19, 0x12E1	; 0x8012e1 <__brkval+0x1>
    3e46:	28 17       	cp	r18, r24
    3e48:	39 07       	cpc	r19, r25
    3e4a:	69 f4       	brne	.+26     	; 0x3e66 <free+0x10c>
    3e4c:	30 97       	sbiw	r30, 0x00	; 0
    3e4e:	29 f4       	brne	.+10     	; 0x3e5a <free+0x100>
    3e50:	10 92 e3 12 	sts	0x12E3, r1	; 0x8012e3 <__flp+0x1>
    3e54:	10 92 e2 12 	sts	0x12E2, r1	; 0x8012e2 <__flp>
    3e58:	02 c0       	rjmp	.+4      	; 0x3e5e <free+0x104>
    3e5a:	13 82       	std	Z+3, r1	; 0x03
    3e5c:	12 82       	std	Z+2, r1	; 0x02
    3e5e:	b0 93 e1 12 	sts	0x12E1, r27	; 0x8012e1 <__brkval+0x1>
    3e62:	a0 93 e0 12 	sts	0x12E0, r26	; 0x8012e0 <__brkval>
    3e66:	df 91       	pop	r29
    3e68:	cf 91       	pop	r28
    3e6a:	08 95       	ret

00003e6c <memset>:
    3e6c:	dc 01       	movw	r26, r24
    3e6e:	01 c0       	rjmp	.+2      	; 0x3e72 <memset+0x6>
    3e70:	6d 93       	st	X+, r22
    3e72:	41 50       	subi	r20, 0x01	; 1
    3e74:	50 40       	sbci	r21, 0x00	; 0
    3e76:	e0 f7       	brcc	.-8      	; 0x3e70 <memset+0x4>
    3e78:	08 95       	ret

00003e7a <strncpy>:
    3e7a:	fb 01       	movw	r30, r22
    3e7c:	dc 01       	movw	r26, r24
    3e7e:	41 50       	subi	r20, 0x01	; 1
    3e80:	50 40       	sbci	r21, 0x00	; 0
    3e82:	48 f0       	brcs	.+18     	; 0x3e96 <strncpy+0x1c>
    3e84:	01 90       	ld	r0, Z+
    3e86:	0d 92       	st	X+, r0
    3e88:	00 20       	and	r0, r0
    3e8a:	c9 f7       	brne	.-14     	; 0x3e7e <strncpy+0x4>
    3e8c:	01 c0       	rjmp	.+2      	; 0x3e90 <strncpy+0x16>
    3e8e:	1d 92       	st	X+, r1
    3e90:	41 50       	subi	r20, 0x01	; 1
    3e92:	50 40       	sbci	r21, 0x00	; 0
    3e94:	e0 f7       	brcc	.-8      	; 0x3e8e <strncpy+0x14>
    3e96:	08 95       	ret

00003e98 <__do_global_dtors>:
    3e98:	10 e0       	ldi	r17, 0x00	; 0
    3e9a:	c3 e7       	ldi	r28, 0x73	; 115
    3e9c:	d0 e0       	ldi	r29, 0x00	; 0
    3e9e:	00 e0       	ldi	r16, 0x00	; 0
    3ea0:	05 c0       	rjmp	.+10     	; 0x3eac <__do_global_dtors+0x14>
    3ea2:	80 2f       	mov	r24, r16
    3ea4:	fe 01       	movw	r30, r28
    3ea6:	b9 de       	rcall	.-654    	; 0x3c1a <__tablejump2__>
    3ea8:	21 96       	adiw	r28, 0x01	; 1
    3eaa:	01 1d       	adc	r16, r1
    3eac:	c4 37       	cpi	r28, 0x74	; 116
    3eae:	d1 07       	cpc	r29, r17
    3eb0:	80 e0       	ldi	r24, 0x00	; 0
    3eb2:	08 07       	cpc	r16, r24
    3eb4:	b1 f7       	brne	.-20     	; 0x3ea2 <__do_global_dtors+0xa>
    3eb6:	f8 94       	cli

00003eb8 <__stop_program>:
    3eb8:	ff cf       	rjmp	.-2      	; 0x3eb8 <__stop_program>
