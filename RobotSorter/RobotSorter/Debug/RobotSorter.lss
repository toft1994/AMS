
RobotSorter.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000000d0  00800200  0000324e  000032e2  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000324e  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000fea  008002d0  008002d0  000033b2  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000033b2  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  000033e4  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000730  00000000  00000000  00003424  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00009ae0  00000000  00000000  00003b54  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00003acc  00000000  00000000  0000d634  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00004142  00000000  00000000  00011100  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001454  00000000  00000000  00015244  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00002670  00000000  00000000  00016698  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00004d77  00000000  00000000  00018d08  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000608  00000000  00000000  0001da7f  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	eb c0       	rjmp	.+470    	; 0x1d8 <__dtors_end>
       2:	00 00       	nop
       4:	19 c1       	rjmp	.+562    	; 0x238 <__bad_interrupt>
       6:	00 00       	nop
       8:	17 c1       	rjmp	.+558    	; 0x238 <__bad_interrupt>
       a:	00 00       	nop
       c:	15 c1       	rjmp	.+554    	; 0x238 <__bad_interrupt>
       e:	00 00       	nop
      10:	13 c1       	rjmp	.+550    	; 0x238 <__bad_interrupt>
      12:	00 00       	nop
      14:	0c 94 25 14 	jmp	0x284a	; 0x284a <__vector_5>
      18:	0f c1       	rjmp	.+542    	; 0x238 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	0d c1       	rjmp	.+538    	; 0x238 <__bad_interrupt>
      1e:	00 00       	nop
      20:	0b c1       	rjmp	.+534    	; 0x238 <__bad_interrupt>
      22:	00 00       	nop
      24:	09 c1       	rjmp	.+530    	; 0x238 <__bad_interrupt>
      26:	00 00       	nop
      28:	07 c1       	rjmp	.+526    	; 0x238 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	05 c1       	rjmp	.+522    	; 0x238 <__bad_interrupt>
      2e:	00 00       	nop
      30:	03 c1       	rjmp	.+518    	; 0x238 <__bad_interrupt>
      32:	00 00       	nop
      34:	01 c1       	rjmp	.+514    	; 0x238 <__bad_interrupt>
      36:	00 00       	nop
      38:	ff c0       	rjmp	.+510    	; 0x238 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	fd c0       	rjmp	.+506    	; 0x238 <__bad_interrupt>
      3e:	00 00       	nop
      40:	fb c0       	rjmp	.+502    	; 0x238 <__bad_interrupt>
      42:	00 00       	nop
      44:	f9 c0       	rjmp	.+498    	; 0x238 <__bad_interrupt>
      46:	00 00       	nop
      48:	f7 c0       	rjmp	.+494    	; 0x238 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	f5 c0       	rjmp	.+490    	; 0x238 <__bad_interrupt>
      4e:	00 00       	nop
      50:	f3 c0       	rjmp	.+486    	; 0x238 <__bad_interrupt>
      52:	00 00       	nop
      54:	0c 94 80 0e 	jmp	0x1d00	; 0x1d00 <__vector_21>
      58:	ef c0       	rjmp	.+478    	; 0x238 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	ed c0       	rjmp	.+474    	; 0x238 <__bad_interrupt>
      5e:	00 00       	nop
      60:	eb c0       	rjmp	.+470    	; 0x238 <__bad_interrupt>
      62:	00 00       	nop
      64:	e9 c0       	rjmp	.+466    	; 0x238 <__bad_interrupt>
      66:	00 00       	nop
      68:	e7 c0       	rjmp	.+462    	; 0x238 <__bad_interrupt>
      6a:	00 00       	nop
      6c:	e5 c0       	rjmp	.+458    	; 0x238 <__bad_interrupt>
      6e:	00 00       	nop
      70:	e3 c0       	rjmp	.+454    	; 0x238 <__bad_interrupt>
      72:	00 00       	nop
      74:	e1 c0       	rjmp	.+450    	; 0x238 <__bad_interrupt>
      76:	00 00       	nop
      78:	df c0       	rjmp	.+446    	; 0x238 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	dd c0       	rjmp	.+442    	; 0x238 <__bad_interrupt>
      7e:	00 00       	nop
      80:	db c0       	rjmp	.+438    	; 0x238 <__bad_interrupt>
      82:	00 00       	nop
      84:	d9 c0       	rjmp	.+434    	; 0x238 <__bad_interrupt>
      86:	00 00       	nop
      88:	d7 c0       	rjmp	.+430    	; 0x238 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	d5 c0       	rjmp	.+426    	; 0x238 <__bad_interrupt>
      8e:	00 00       	nop
      90:	d3 c0       	rjmp	.+422    	; 0x238 <__bad_interrupt>
      92:	00 00       	nop
      94:	d1 c0       	rjmp	.+418    	; 0x238 <__bad_interrupt>
      96:	00 00       	nop
      98:	cf c0       	rjmp	.+414    	; 0x238 <__bad_interrupt>
      9a:	00 00       	nop
      9c:	cd c0       	rjmp	.+410    	; 0x238 <__bad_interrupt>
      9e:	00 00       	nop
      a0:	cb c0       	rjmp	.+406    	; 0x238 <__bad_interrupt>
      a2:	00 00       	nop
      a4:	c1 c2       	rjmp	.+1410   	; 0x628 <__vector_41>
      a6:	00 00       	nop
      a8:	c7 c0       	rjmp	.+398    	; 0x238 <__bad_interrupt>
      aa:	00 00       	nop
      ac:	c5 c0       	rjmp	.+394    	; 0x238 <__bad_interrupt>
      ae:	00 00       	nop
      b0:	c3 c0       	rjmp	.+390    	; 0x238 <__bad_interrupt>
      b2:	00 00       	nop
      b4:	94 c2       	rjmp	.+1320   	; 0x5de <__vector_45>
      b6:	00 00       	nop
      b8:	bf c0       	rjmp	.+382    	; 0x238 <__bad_interrupt>
      ba:	00 00       	nop
      bc:	bd c0       	rjmp	.+378    	; 0x238 <__bad_interrupt>
      be:	00 00       	nop
      c0:	bb c0       	rjmp	.+374    	; 0x238 <__bad_interrupt>
      c2:	00 00       	nop
      c4:	b9 c0       	rjmp	.+370    	; 0x238 <__bad_interrupt>
      c6:	00 00       	nop
      c8:	b7 c0       	rjmp	.+366    	; 0x238 <__bad_interrupt>
      ca:	00 00       	nop
      cc:	b5 c0       	rjmp	.+362    	; 0x238 <__bad_interrupt>
      ce:	00 00       	nop
      d0:	b3 c0       	rjmp	.+358    	; 0x238 <__bad_interrupt>
      d2:	00 00       	nop
      d4:	b1 c0       	rjmp	.+354    	; 0x238 <__bad_interrupt>
      d6:	00 00       	nop
      d8:	af c0       	rjmp	.+350    	; 0x238 <__bad_interrupt>
      da:	00 00       	nop
      dc:	ad c0       	rjmp	.+346    	; 0x238 <__bad_interrupt>
      de:	00 00       	nop
      e0:	ab c0       	rjmp	.+342    	; 0x238 <__bad_interrupt>
      e2:	00 00       	nop
      e4:	07 04       	cpc	r0, r7
      e6:	03 04       	cpc	r0, r3
      e8:	0b 04       	cpc	r0, r11
      ea:	09 04       	cpc	r0, r9
      ec:	0b 04       	cpc	r0, r11
      ee:	0b 04       	cpc	r0, r11
      f0:	0b 04       	cpc	r0, r11
      f2:	05 04       	cpc	r0, r5
      f4:	0b 04       	cpc	r0, r11
      f6:	0b 04       	cpc	r0, r11
      f8:	0b 04       	cpc	r0, r11
      fa:	0b 04       	cpc	r0, r11
      fc:	0b 04       	cpc	r0, r11
      fe:	0b 04       	cpc	r0, r11
     100:	0b 04       	cpc	r0, r11
     102:	0b 04       	cpc	r0, r11
     104:	ff 03       	fmulsu	r23, r23
     106:	fb 03       	fmulsu	r23, r19
     108:	0b 04       	cpc	r0, r11
     10a:	01 04       	cpc	r0, r1
     10c:	0b 04       	cpc	r0, r11
     10e:	0b 04       	cpc	r0, r11
     110:	0b 04       	cpc	r0, r11
     112:	fd 03       	fmulsu	r23, r21
     114:	0b 04       	cpc	r0, r11
     116:	0b 04       	cpc	r0, r11
     118:	0b 04       	cpc	r0, r11
     11a:	0b 04       	cpc	r0, r11
     11c:	0b 04       	cpc	r0, r11
     11e:	0b 04       	cpc	r0, r11
     120:	0b 04       	cpc	r0, r11
     122:	0b 04       	cpc	r0, r11
     124:	0b 04       	cpc	r0, r11
     126:	0b 04       	cpc	r0, r11
     128:	0b 04       	cpc	r0, r11
     12a:	0b 04       	cpc	r0, r11
     12c:	0b 04       	cpc	r0, r11
     12e:	0b 04       	cpc	r0, r11
     130:	0b 04       	cpc	r0, r11
     132:	0b 04       	cpc	r0, r11
     134:	0b 04       	cpc	r0, r11
     136:	0b 04       	cpc	r0, r11
     138:	0b 04       	cpc	r0, r11
     13a:	0b 04       	cpc	r0, r11
     13c:	0b 04       	cpc	r0, r11
     13e:	0b 04       	cpc	r0, r11
     140:	0b 04       	cpc	r0, r11
     142:	0b 04       	cpc	r0, r11
     144:	ef 03       	fmulsu	r22, r23
     146:	ed 03       	fmulsu	r22, r21
     148:	0b 04       	cpc	r0, r11
     14a:	f1 03       	fmuls	r23, r17
     14c:	0b 04       	cpc	r0, r11
     14e:	0b 04       	cpc	r0, r11
     150:	0b 04       	cpc	r0, r11
     152:	0d 04       	cpc	r0, r13
     154:	0b 04       	cpc	r0, r11
     156:	0b 04       	cpc	r0, r11
     158:	0b 04       	cpc	r0, r11
     15a:	0b 04       	cpc	r0, r11
     15c:	0b 04       	cpc	r0, r11
     15e:	0b 04       	cpc	r0, r11
     160:	0b 04       	cpc	r0, r11
     162:	0b 04       	cpc	r0, r11
     164:	0b 04       	cpc	r0, r11
     166:	0b 04       	cpc	r0, r11
     168:	0b 04       	cpc	r0, r11
     16a:	0b 04       	cpc	r0, r11
     16c:	0b 04       	cpc	r0, r11
     16e:	0b 04       	cpc	r0, r11
     170:	0b 04       	cpc	r0, r11
     172:	0b 04       	cpc	r0, r11
     174:	0b 04       	cpc	r0, r11
     176:	0b 04       	cpc	r0, r11
     178:	0b 04       	cpc	r0, r11
     17a:	0b 04       	cpc	r0, r11
     17c:	0b 04       	cpc	r0, r11
     17e:	0b 04       	cpc	r0, r11
     180:	0b 04       	cpc	r0, r11
     182:	0b 04       	cpc	r0, r11
     184:	0b 04       	cpc	r0, r11
     186:	0b 04       	cpc	r0, r11
     188:	0b 04       	cpc	r0, r11
     18a:	0b 04       	cpc	r0, r11
     18c:	0b 04       	cpc	r0, r11
     18e:	0b 04       	cpc	r0, r11
     190:	0b 04       	cpc	r0, r11
     192:	0b 04       	cpc	r0, r11
     194:	0b 04       	cpc	r0, r11
     196:	0b 04       	cpc	r0, r11
     198:	0b 04       	cpc	r0, r11
     19a:	0b 04       	cpc	r0, r11
     19c:	0b 04       	cpc	r0, r11
     19e:	0b 04       	cpc	r0, r11
     1a0:	0b 04       	cpc	r0, r11
     1a2:	0b 04       	cpc	r0, r11
     1a4:	0b 04       	cpc	r0, r11
     1a6:	0b 04       	cpc	r0, r11
     1a8:	0b 04       	cpc	r0, r11
     1aa:	0b 04       	cpc	r0, r11
     1ac:	0b 04       	cpc	r0, r11
     1ae:	0b 04       	cpc	r0, r11
     1b0:	0b 04       	cpc	r0, r11
     1b2:	0b 04       	cpc	r0, r11
     1b4:	0b 04       	cpc	r0, r11
     1b6:	0b 04       	cpc	r0, r11
     1b8:	0b 04       	cpc	r0, r11
     1ba:	0b 04       	cpc	r0, r11
     1bc:	0b 04       	cpc	r0, r11
     1be:	0b 04       	cpc	r0, r11
     1c0:	0b 04       	cpc	r0, r11
     1c2:	0b 04       	cpc	r0, r11
     1c4:	f7 03       	fmuls	r23, r23
     1c6:	f3 03       	fmuls	r23, r19
     1c8:	0b 04       	cpc	r0, r11
     1ca:	f9 03       	fmulsu	r23, r17
     1cc:	0b 04       	cpc	r0, r11
     1ce:	0b 04       	cpc	r0, r11
     1d0:	0b 04       	cpc	r0, r11
     1d2:	f5 03       	fmuls	r23, r21

000001d4 <__ctors_start>:
     1d4:	33 05       	cpc	r19, r3

000001d6 <__ctors_end>:
     1d6:	39 05       	cpc	r19, r9

000001d8 <__dtors_end>:
     1d8:	11 24       	eor	r1, r1
     1da:	1f be       	out	0x3f, r1	; 63
     1dc:	cf ef       	ldi	r28, 0xFF	; 255
     1de:	d1 e2       	ldi	r29, 0x21	; 33
     1e0:	de bf       	out	0x3e, r29	; 62
     1e2:	cd bf       	out	0x3d, r28	; 61
     1e4:	00 e0       	ldi	r16, 0x00	; 0
     1e6:	0c bf       	out	0x3c, r16	; 60

000001e8 <__do_copy_data>:
     1e8:	12 e0       	ldi	r17, 0x02	; 2
     1ea:	a0 e0       	ldi	r26, 0x00	; 0
     1ec:	b2 e0       	ldi	r27, 0x02	; 2
     1ee:	ee e4       	ldi	r30, 0x4E	; 78
     1f0:	f2 e3       	ldi	r31, 0x32	; 50
     1f2:	00 e0       	ldi	r16, 0x00	; 0
     1f4:	0b bf       	out	0x3b, r16	; 59
     1f6:	02 c0       	rjmp	.+4      	; 0x1fc <__do_copy_data+0x14>
     1f8:	07 90       	elpm	r0, Z+
     1fa:	0d 92       	st	X+, r0
     1fc:	a0 3d       	cpi	r26, 0xD0	; 208
     1fe:	b1 07       	cpc	r27, r17
     200:	d9 f7       	brne	.-10     	; 0x1f8 <__do_copy_data+0x10>

00000202 <__do_clear_bss>:
     202:	22 e1       	ldi	r18, 0x12	; 18
     204:	a0 ed       	ldi	r26, 0xD0	; 208
     206:	b2 e0       	ldi	r27, 0x02	; 2
     208:	01 c0       	rjmp	.+2      	; 0x20c <.do_clear_bss_start>

0000020a <.do_clear_bss_loop>:
     20a:	1d 92       	st	X+, r1

0000020c <.do_clear_bss_start>:
     20c:	aa 3b       	cpi	r26, 0xBA	; 186
     20e:	b2 07       	cpc	r27, r18
     210:	e1 f7       	brne	.-8      	; 0x20a <.do_clear_bss_loop>

00000212 <__do_global_ctors>:
     212:	10 e0       	ldi	r17, 0x00	; 0
     214:	cb ee       	ldi	r28, 0xEB	; 235
     216:	d0 e0       	ldi	r29, 0x00	; 0
     218:	00 e0       	ldi	r16, 0x00	; 0
     21a:	06 c0       	rjmp	.+12     	; 0x228 <__do_global_ctors+0x16>
     21c:	21 97       	sbiw	r28, 0x01	; 1
     21e:	01 09       	sbc	r16, r1
     220:	80 2f       	mov	r24, r16
     222:	fe 01       	movw	r30, r28
     224:	0e 94 95 17 	call	0x2f2a	; 0x2f2a <__tablejump2__>
     228:	ca 3e       	cpi	r28, 0xEA	; 234
     22a:	d1 07       	cpc	r29, r17
     22c:	80 e0       	ldi	r24, 0x00	; 0
     22e:	08 07       	cpc	r16, r24
     230:	a9 f7       	brne	.-22     	; 0x21c <__do_global_ctors+0xa>
     232:	e5 d3       	rcall	.+1994   	; 0x9fe <main>
     234:	0c 94 16 19 	jmp	0x322c	; 0x322c <__do_global_dtors>

00000238 <__bad_interrupt>:
     238:	e3 ce       	rjmp	.-570    	; 0x0 <__vectors>

0000023a <_ZN5ColorC1Ev>:
}

uint8_t Color::getColorIndex( void )
{
	return _colorIndex;
}
     23a:	08 95       	ret

0000023c <_ZN5Color12getRedPeriodEv>:
     23c:	fc 01       	movw	r30, r24
     23e:	80 81       	ld	r24, Z
     240:	91 81       	ldd	r25, Z+1	; 0x01
     242:	08 95       	ret

00000244 <_ZN5Color13getBluePeriodEv>:
     244:	fc 01       	movw	r30, r24
     246:	82 81       	ldd	r24, Z+2	; 0x02
     248:	93 81       	ldd	r25, Z+3	; 0x03
     24a:	08 95       	ret

0000024c <_ZN5Color14getGreenPeriodEv>:
     24c:	fc 01       	movw	r30, r24
     24e:	84 81       	ldd	r24, Z+4	; 0x04
     250:	95 81       	ldd	r25, Z+5	; 0x05
     252:	08 95       	ret

00000254 <_ZN5Color14getWhitePeriodEv>:
     254:	fc 01       	movw	r30, r24
     256:	86 81       	ldd	r24, Z+6	; 0x06
     258:	97 81       	ldd	r25, Z+7	; 0x07
     25a:	08 95       	ret

0000025c <_ZN5Color12setRedPeriodEj>:

void Color::setRedPeriod( uint16_t redPeriod )
{
	_redPeriod = redPeriod;
     25c:	fc 01       	movw	r30, r24
     25e:	71 83       	std	Z+1, r23	; 0x01
     260:	60 83       	st	Z, r22
     262:	08 95       	ret

00000264 <_ZN5Color13setBluePeriodEj>:
}

void Color::setBluePeriod( uint16_t bluePeriod )
{
	_bluePeriod = bluePeriod;
     264:	fc 01       	movw	r30, r24
     266:	73 83       	std	Z+3, r23	; 0x03
     268:	62 83       	std	Z+2, r22	; 0x02
     26a:	08 95       	ret

0000026c <_ZN5Color14setGreenPeriodEj>:
}

void Color::setGreenPeriod( uint16_t greenPeriod )
{
	_greenPeriod = greenPeriod;
     26c:	fc 01       	movw	r30, r24
     26e:	75 83       	std	Z+5, r23	; 0x05
     270:	64 83       	std	Z+4, r22	; 0x04
     272:	08 95       	ret

00000274 <_ZN5Color14setWhitePeriodEj>:
}

void Color::setWhitePeriod( uint16_t whitePeriod )
{
	_whitePeriod = whitePeriod;
     274:	fc 01       	movw	r30, r24
     276:	77 83       	std	Z+7, r23	; 0x07
     278:	66 83       	std	Z+6, r22	; 0x06
     27a:	08 95       	ret

0000027c <_ZN5Color13setColorIndexEh>:
}

void Color::setColorIndex( uint8_t index )
{
	_colorIndex = index;
     27c:	fc 01       	movw	r30, r24
     27e:	60 87       	std	Z+8, r22	; 0x08
     280:	08 95       	ret

00000282 <_ZN11ColorSensor9setFilterE6Filter>:
	}
}

void ColorSensor::setFilter( Filter filter_ )
{
	switch ( filter_ )
     282:	61 30       	cpi	r22, 0x01	; 1
     284:	31 f0       	breq	.+12     	; 0x292 <_ZN11ColorSensor9setFilterE6Filter+0x10>
     286:	e8 f0       	brcs	.+58     	; 0x2c2 <_ZN11ColorSensor9setFilterE6Filter+0x40>
     288:	62 30       	cpi	r22, 0x02	; 2
     28a:	99 f0       	breq	.+38     	; 0x2b2 <_ZN11ColorSensor9setFilterE6Filter+0x30>
     28c:	63 30       	cpi	r22, 0x03	; 3
     28e:	49 f0       	breq	.+18     	; 0x2a2 <_ZN11ColorSensor9setFilterE6Filter+0x20>
     290:	08 95       	ret
	{
	case redFilter:
		COLORSENSOR_S2_PORT &= ~( COLORSENSOR_S2_PIN );
     292:	e2 e0       	ldi	r30, 0x02	; 2
     294:	f1 e0       	ldi	r31, 0x01	; 1
     296:	80 81       	ld	r24, Z
     298:	8e 7f       	andi	r24, 0xFE	; 254
     29a:	80 83       	st	Z, r24
		COLORSENSOR_S3_PORT &= ~( COLORSENSOR_S3_PIN );
     29c:	80 81       	ld	r24, Z
     29e:	80 83       	st	Z, r24
		break;
     2a0:	08 95       	ret

	case blueFilter:
		COLORSENSOR_S2_PORT &= ~( COLORSENSOR_S2_PIN );
     2a2:	e2 e0       	ldi	r30, 0x02	; 2
     2a4:	f1 e0       	ldi	r31, 0x01	; 1
     2a6:	80 81       	ld	r24, Z
     2a8:	8e 7f       	andi	r24, 0xFE	; 254
     2aa:	80 83       	st	Z, r24
		COLORSENSOR_S3_PORT |= COLORSENSOR_S3_PIN;
     2ac:	80 81       	ld	r24, Z
     2ae:	80 83       	st	Z, r24
		break;
     2b0:	08 95       	ret

	case greenFilter:
		COLORSENSOR_S2_PORT |= COLORSENSOR_S2_PIN;
     2b2:	e2 e0       	ldi	r30, 0x02	; 2
     2b4:	f1 e0       	ldi	r31, 0x01	; 1
     2b6:	80 81       	ld	r24, Z
     2b8:	81 60       	ori	r24, 0x01	; 1
     2ba:	80 83       	st	Z, r24
		COLORSENSOR_S3_PORT |= COLORSENSOR_S3_PIN;
     2bc:	80 81       	ld	r24, Z
     2be:	80 83       	st	Z, r24
		break;
     2c0:	08 95       	ret

	case noFilter:
		COLORSENSOR_S2_PORT |= COLORSENSOR_S2_PIN;
     2c2:	e2 e0       	ldi	r30, 0x02	; 2
     2c4:	f1 e0       	ldi	r31, 0x01	; 1
     2c6:	80 81       	ld	r24, Z
     2c8:	81 60       	ori	r24, 0x01	; 1
     2ca:	80 83       	st	Z, r24
		COLORSENSOR_S3_PORT &= ~( COLORSENSOR_S3_PIN );
     2cc:	80 81       	ld	r24, Z
     2ce:	80 83       	st	Z, r24
     2d0:	08 95       	ret

000002d2 <_ZN11ColorSensor8getColorEv>:
ColorSensor::~ColorSensor()
{	
}

uint8_t ColorSensor::getColor()
{
     2d2:	6f 92       	push	r6
     2d4:	7f 92       	push	r7
     2d6:	8f 92       	push	r8
     2d8:	9f 92       	push	r9
     2da:	af 92       	push	r10
     2dc:	bf 92       	push	r11
     2de:	cf 92       	push	r12
     2e0:	df 92       	push	r13
     2e2:	ef 92       	push	r14
     2e4:	ff 92       	push	r15
     2e6:	0f 93       	push	r16
     2e8:	1f 93       	push	r17
     2ea:	cf 93       	push	r28
     2ec:	df 93       	push	r29
     2ee:	8c 01       	movw	r16, r24
	uint8_t result = 255;
	
	// Get period values from all filters
	setFilter( redFilter );
     2f0:	61 e0       	ldi	r22, 0x01	; 1
     2f2:	c7 df       	rcall	.-114    	; 0x282 <_ZN11ColorSensor9setFilterE6Filter>
	uint16_t redPeriod = frequency_.getPeriod();
     2f4:	c8 01       	movw	r24, r16
     2f6:	41 d1       	rcall	.+642    	; 0x57a <_ZN6Timer49getPeriodEv>
     2f8:	7c 01       	movw	r14, r24

	setFilter( blueFilter );
     2fa:	63 e0       	ldi	r22, 0x03	; 3
     2fc:	c8 01       	movw	r24, r16
	uint16_t bluePeriod = frequency_.getPeriod();  
     2fe:	c1 df       	rcall	.-126    	; 0x282 <_ZN11ColorSensor9setFilterE6Filter>
     300:	c8 01       	movw	r24, r16
     302:	3b d1       	rcall	.+630    	; 0x57a <_ZN6Timer49getPeriodEv>

	setFilter( greenFilter );
     304:	6c 01       	movw	r12, r24
     306:	62 e0       	ldi	r22, 0x02	; 2
     308:	c8 01       	movw	r24, r16
	uint16_t greenPeriod = frequency_.getPeriod();
     30a:	bb df       	rcall	.-138    	; 0x282 <_ZN11ColorSensor9setFilterE6Filter>
     30c:	c8 01       	movw	r24, r16
	
	setFilter( noFilter );
     30e:	35 d1       	rcall	.+618    	; 0x57a <_ZN6Timer49getPeriodEv>
     310:	5c 01       	movw	r10, r24
     312:	60 e0       	ldi	r22, 0x00	; 0
     314:	c8 01       	movw	r24, r16
	uint16_t whitePeriod = frequency_.getPeriod();
     316:	b5 df       	rcall	.-150    	; 0x282 <_ZN11ColorSensor9setFilterE6Filter>
     318:	c8 01       	movw	r24, r16
     31a:	2f d1       	rcall	.+606    	; 0x57a <_ZN6Timer49getPeriodEv>
     31c:	4c 01       	movw	r8, r24
	
	// Check all stored colors against read values	
	for ( uint8_t index = 0U; index < 10; index++)
     31e:	71 2c       	mov	r7, r1
     320:	89 e0       	ldi	r24, 0x09	; 9
     322:	87 15       	cp	r24, r7
     324:	08 f4       	brcc	.+2      	; 0x328 <_ZN11ColorSensor8getColorEv+0x56>
     326:	5a c0       	rjmp	.+180    	; 0x3dc <_ZN11ColorSensor8getColorEv+0x10a>
	{		
		if ( _colors[index].getRedPeriod() + 5 > redPeriod && _colors[index].getRedPeriod() - 5 < redPeriod )
     328:	c7 2d       	mov	r28, r7
     32a:	d0 e0       	ldi	r29, 0x00	; 0
     32c:	ce 01       	movw	r24, r28
     32e:	88 0f       	add	r24, r24
     330:	99 1f       	adc	r25, r25
     332:	88 0f       	add	r24, r24
     334:	99 1f       	adc	r25, r25
     336:	88 0f       	add	r24, r24
     338:	99 1f       	adc	r25, r25
     33a:	c8 0f       	add	r28, r24
     33c:	d9 1f       	adc	r29, r25
     33e:	21 96       	adiw	r28, 0x01	; 1
     340:	c0 0f       	add	r28, r16
     342:	d1 1f       	adc	r29, r17
     344:	ce 01       	movw	r24, r28
     346:	7a df       	rcall	.-268    	; 0x23c <_ZN5Color12getRedPeriodEv>
     348:	05 96       	adiw	r24, 0x05	; 5
     34a:	e8 16       	cp	r14, r24
     34c:	f9 06       	cpc	r15, r25
     34e:	48 f4       	brcc	.+18     	; 0x362 <_ZN11ColorSensor8getColorEv+0x90>
     350:	ce 01       	movw	r24, r28
     352:	74 df       	rcall	.-280    	; 0x23c <_ZN5Color12getRedPeriodEv>
     354:	05 97       	sbiw	r24, 0x05	; 5
     356:	8e 15       	cp	r24, r14
     358:	9f 05       	cpc	r25, r15
     35a:	28 f4       	brcc	.+10     	; 0x366 <_ZN11ColorSensor8getColorEv+0x94>
     35c:	66 24       	eor	r6, r6
     35e:	63 94       	inc	r6
     360:	03 c0       	rjmp	.+6      	; 0x368 <_ZN11ColorSensor8getColorEv+0x96>
     362:	61 2c       	mov	r6, r1
     364:	01 c0       	rjmp	.+2      	; 0x368 <_ZN11ColorSensor8getColorEv+0x96>
     366:	61 2c       	mov	r6, r1
		{
			if ( _colors[index].getBluePeriod() + 5 > bluePeriod && _colors[index].getBluePeriod() - 5 < bluePeriod )
     368:	66 20       	and	r6, r6
     36a:	b1 f1       	breq	.+108    	; 0x3d8 <_ZN11ColorSensor8getColorEv+0x106>
     36c:	ce 01       	movw	r24, r28
     36e:	6a df       	rcall	.-300    	; 0x244 <_ZN5Color13getBluePeriodEv>
     370:	05 96       	adiw	r24, 0x05	; 5
     372:	c8 16       	cp	r12, r24
     374:	d9 06       	cpc	r13, r25
     376:	38 f4       	brcc	.+14     	; 0x386 <_ZN11ColorSensor8getColorEv+0xb4>
     378:	ce 01       	movw	r24, r28
     37a:	64 df       	rcall	.-312    	; 0x244 <_ZN5Color13getBluePeriodEv>
     37c:	05 97       	sbiw	r24, 0x05	; 5
     37e:	8c 15       	cp	r24, r12
     380:	9d 05       	cpc	r25, r13
     382:	18 f4       	brcc	.+6      	; 0x38a <_ZN11ColorSensor8getColorEv+0xb8>
     384:	03 c0       	rjmp	.+6      	; 0x38c <_ZN11ColorSensor8getColorEv+0xba>
     386:	61 2c       	mov	r6, r1
     388:	01 c0       	rjmp	.+2      	; 0x38c <_ZN11ColorSensor8getColorEv+0xba>
     38a:	61 2c       	mov	r6, r1
			{
				if ( _colors[index].getGreenPeriod() + 5 > greenPeriod && _colors[index].getGreenPeriod() - 5 < greenPeriod )
     38c:	66 20       	and	r6, r6
     38e:	21 f1       	breq	.+72     	; 0x3d8 <_ZN11ColorSensor8getColorEv+0x106>
     390:	ce 01       	movw	r24, r28
     392:	5c df       	rcall	.-328    	; 0x24c <_ZN5Color14getGreenPeriodEv>
     394:	05 96       	adiw	r24, 0x05	; 5
     396:	a8 16       	cp	r10, r24
     398:	b9 06       	cpc	r11, r25
     39a:	38 f4       	brcc	.+14     	; 0x3aa <_ZN11ColorSensor8getColorEv+0xd8>
     39c:	ce 01       	movw	r24, r28
     39e:	56 df       	rcall	.-340    	; 0x24c <_ZN5Color14getGreenPeriodEv>
     3a0:	05 97       	sbiw	r24, 0x05	; 5
     3a2:	8a 15       	cp	r24, r10
     3a4:	9b 05       	cpc	r25, r11
     3a6:	18 f4       	brcc	.+6      	; 0x3ae <_ZN11ColorSensor8getColorEv+0xdc>
     3a8:	03 c0       	rjmp	.+6      	; 0x3b0 <_ZN11ColorSensor8getColorEv+0xde>
     3aa:	61 2c       	mov	r6, r1
     3ac:	01 c0       	rjmp	.+2      	; 0x3b0 <_ZN11ColorSensor8getColorEv+0xde>
     3ae:	61 2c       	mov	r6, r1
				{
					if ( _colors[index].getWhitePeriod() + 2 > whitePeriod && _colors[index].getWhitePeriod() - 2 < whitePeriod )
     3b0:	66 20       	and	r6, r6
     3b2:	91 f0       	breq	.+36     	; 0x3d8 <_ZN11ColorSensor8getColorEv+0x106>
     3b4:	ce 01       	movw	r24, r28
     3b6:	4e df       	rcall	.-356    	; 0x254 <_ZN5Color14getWhitePeriodEv>
     3b8:	02 96       	adiw	r24, 0x02	; 2
     3ba:	88 16       	cp	r8, r24
     3bc:	99 06       	cpc	r9, r25
     3be:	38 f4       	brcc	.+14     	; 0x3ce <_ZN11ColorSensor8getColorEv+0xfc>
     3c0:	ce 01       	movw	r24, r28
     3c2:	48 df       	rcall	.-368    	; 0x254 <_ZN5Color14getWhitePeriodEv>
     3c4:	02 97       	sbiw	r24, 0x02	; 2
     3c6:	88 15       	cp	r24, r8
     3c8:	99 05       	cpc	r25, r9
     3ca:	18 f4       	brcc	.+6      	; 0x3d2 <_ZN11ColorSensor8getColorEv+0x100>
     3cc:	03 c0       	rjmp	.+6      	; 0x3d4 <_ZN11ColorSensor8getColorEv+0x102>
     3ce:	61 2c       	mov	r6, r1
     3d0:	01 c0       	rjmp	.+2      	; 0x3d4 <_ZN11ColorSensor8getColorEv+0x102>
     3d2:	61 2c       	mov	r6, r1
     3d4:	61 10       	cpse	r6, r1
     3d6:	04 c0       	rjmp	.+8      	; 0x3e0 <_ZN11ColorSensor8getColorEv+0x10e>
	
	setFilter( noFilter );
	uint16_t whitePeriod = frequency_.getPeriod();
	
	// Check all stored colors against read values	
	for ( uint8_t index = 0U; index < 10; index++)
     3d8:	73 94       	inc	r7
     3da:	a2 cf       	rjmp	.-188    	; 0x320 <_ZN11ColorSensor8getColorEv+0x4e>
{	
}

uint8_t ColorSensor::getColor()
{
	uint8_t result = 255;
     3dc:	77 24       	eor	r7, r7
     3de:	7a 94       	dec	r7
		}
	}
	
	// Return value
	return result;
}
     3e0:	87 2d       	mov	r24, r7
     3e2:	df 91       	pop	r29
     3e4:	cf 91       	pop	r28
     3e6:	1f 91       	pop	r17
     3e8:	0f 91       	pop	r16
     3ea:	ff 90       	pop	r15
     3ec:	ef 90       	pop	r14
     3ee:	df 90       	pop	r13
     3f0:	cf 90       	pop	r12
     3f2:	bf 90       	pop	r11
     3f4:	af 90       	pop	r10
     3f6:	9f 90       	pop	r9
     3f8:	8f 90       	pop	r8
     3fa:	7f 90       	pop	r7
     3fc:	6f 90       	pop	r6
     3fe:	08 95       	ret

00000400 <_ZN11ColorSensor17addCalibrateColorEh>:

void ColorSensor::addCalibrateColor( uint8_t colorIndex )
{
     400:	ff 92       	push	r15
     402:	0f 93       	push	r16
     404:	1f 93       	push	r17
     406:	cf 93       	push	r28
     408:	df 93       	push	r29
	if ( colorIndex < 10U )
     40a:	6a 30       	cpi	r22, 0x0A	; 10
     40c:	08 f0       	brcs	.+2      	; 0x410 <_ZN11ColorSensor17addCalibrateColorEh+0x10>
     40e:	33 c0       	rjmp	.+102    	; 0x476 <_ZN11ColorSensor17addCalibrateColorEh+0x76>
     410:	f6 2e       	mov	r15, r22
     412:	ec 01       	movw	r28, r24
	{	
		// Set all colors
		setFilter( redFilter );
     414:	61 e0       	ldi	r22, 0x01	; 1
     416:	35 df       	rcall	.-406    	; 0x282 <_ZN11ColorSensor9setFilterE6Filter>
		_colors[colorIndex].setRedPeriod( frequency_.getPeriod() );
     418:	ce 01       	movw	r24, r28
     41a:	af d0       	rcall	.+350    	; 0x57a <_ZN6Timer49getPeriodEv>
     41c:	2f 2d       	mov	r18, r15
     41e:	30 e0       	ldi	r19, 0x00	; 0
     420:	89 01       	movw	r16, r18
     422:	00 0f       	add	r16, r16
     424:	11 1f       	adc	r17, r17
     426:	00 0f       	add	r16, r16
     428:	11 1f       	adc	r17, r17
     42a:	00 0f       	add	r16, r16
     42c:	11 1f       	adc	r17, r17
     42e:	02 0f       	add	r16, r18
     430:	13 1f       	adc	r17, r19
     432:	0f 5f       	subi	r16, 0xFF	; 255
     434:	1f 4f       	sbci	r17, 0xFF	; 255
     436:	0c 0f       	add	r16, r28
     438:	1d 1f       	adc	r17, r29
     43a:	bc 01       	movw	r22, r24
     43c:	c8 01       	movw	r24, r16
     43e:	0e df       	rcall	.-484    	; 0x25c <_ZN5Color12setRedPeriodEj>

		setFilter( blueFilter );
     440:	63 e0       	ldi	r22, 0x03	; 3
     442:	ce 01       	movw	r24, r28
     444:	1e df       	rcall	.-452    	; 0x282 <_ZN11ColorSensor9setFilterE6Filter>
		_colors[colorIndex].setBluePeriod( frequency_.getPeriod() );
     446:	ce 01       	movw	r24, r28
     448:	98 d0       	rcall	.+304    	; 0x57a <_ZN6Timer49getPeriodEv>
     44a:	bc 01       	movw	r22, r24
     44c:	c8 01       	movw	r24, r16
     44e:	0a df       	rcall	.-492    	; 0x264 <_ZN5Color13setBluePeriodEj>
		
		setFilter( greenFilter );
     450:	62 e0       	ldi	r22, 0x02	; 2
     452:	ce 01       	movw	r24, r28
     454:	16 df       	rcall	.-468    	; 0x282 <_ZN11ColorSensor9setFilterE6Filter>
		_colors[colorIndex].setGreenPeriod( frequency_.getPeriod() );
     456:	ce 01       	movw	r24, r28
     458:	90 d0       	rcall	.+288    	; 0x57a <_ZN6Timer49getPeriodEv>
     45a:	bc 01       	movw	r22, r24
     45c:	c8 01       	movw	r24, r16
     45e:	06 df       	rcall	.-500    	; 0x26c <_ZN5Color14setGreenPeriodEj>
		
		setFilter( noFilter );
     460:	60 e0       	ldi	r22, 0x00	; 0
     462:	ce 01       	movw	r24, r28
     464:	0e df       	rcall	.-484    	; 0x282 <_ZN11ColorSensor9setFilterE6Filter>
		_colors[colorIndex].setWhitePeriod( frequency_.getPeriod() );
     466:	ce 01       	movw	r24, r28
     468:	88 d0       	rcall	.+272    	; 0x57a <_ZN6Timer49getPeriodEv>
     46a:	bc 01       	movw	r22, r24
     46c:	c8 01       	movw	r24, r16
     46e:	02 df       	rcall	.-508    	; 0x274 <_ZN5Color14setWhitePeriodEj>
     470:	6f 2d       	mov	r22, r15
     472:	c8 01       	movw	r24, r16
				
		// Set index
		_colors[colorIndex].setColorIndex( colorIndex );
     474:	03 df       	rcall	.-506    	; 0x27c <_ZN5Color13setColorIndexEh>
     476:	df 91       	pop	r29
     478:	cf 91       	pop	r28
     47a:	1f 91       	pop	r17
	}
	else
	{
		/* Cant add more colors. Increase size of array. */
	}
}
     47c:	0f 91       	pop	r16
     47e:	ff 90       	pop	r15
     480:	08 95       	ret

00000482 <_ZN11ColorSensor19setFrequencyscalingE16FrequencyScaling>:
     482:	61 30       	cpi	r22, 0x01	; 1
     484:	71 f0       	breq	.+28     	; 0x4a2 <_ZN11ColorSensor19setFrequencyscalingE16FrequencyScaling+0x20>
     486:	28 f0       	brcs	.+10     	; 0x492 <_ZN11ColorSensor19setFrequencyscalingE16FrequencyScaling+0x10>
	}	
}

void ColorSensor::setFrequencyscaling( FrequencyScaling scaling )
{
	switch (scaling)
     488:	62 30       	cpi	r22, 0x02	; 2
     48a:	99 f0       	breq	.+38     	; 0x4b2 <_ZN11ColorSensor19setFrequencyscalingE16FrequencyScaling+0x30>
     48c:	63 30       	cpi	r22, 0x03	; 3
     48e:	c9 f0       	breq	.+50     	; 0x4c2 <_ZN11ColorSensor19setFrequencyscalingE16FrequencyScaling+0x40>
     490:	08 95       	ret
	{
	case powerDown:
		COLORSENSOR_S0_PORT &= ~( COLORSENSOR_S0_PIN );
     492:	e5 e0       	ldi	r30, 0x05	; 5
     494:	f1 e0       	ldi	r31, 0x01	; 1
     496:	80 81       	ld	r24, Z
     498:	8e 7f       	andi	r24, 0xFE	; 254
     49a:	80 83       	st	Z, r24
		COLORSENSOR_S1_PORT &= ~( COLORSENSOR_S1_PIN );
     49c:	80 81       	ld	r24, Z
     49e:	80 83       	st	Z, r24
		break;
     4a0:	08 95       	ret

	case twoPercent:
		COLORSENSOR_S0_PORT &= ~( COLORSENSOR_S0_PIN );
     4a2:	e5 e0       	ldi	r30, 0x05	; 5
     4a4:	f1 e0       	ldi	r31, 0x01	; 1
     4a6:	80 81       	ld	r24, Z
     4a8:	8e 7f       	andi	r24, 0xFE	; 254
     4aa:	80 83       	st	Z, r24
		COLORSENSOR_S1_PORT |= COLORSENSOR_S1_PIN;
     4ac:	80 81       	ld	r24, Z
     4ae:	80 83       	st	Z, r24
		break;
     4b0:	08 95       	ret

	case twentyPercent:
		COLORSENSOR_S0_PORT |= COLORSENSOR_S0_PIN;
     4b2:	e5 e0       	ldi	r30, 0x05	; 5
     4b4:	f1 e0       	ldi	r31, 0x01	; 1
     4b6:	80 81       	ld	r24, Z
     4b8:	81 60       	ori	r24, 0x01	; 1
     4ba:	80 83       	st	Z, r24
		COLORSENSOR_S1_PORT &= ~( COLORSENSOR_S1_PIN );
     4bc:	80 81       	ld	r24, Z
     4be:	80 83       	st	Z, r24
		break;
     4c0:	08 95       	ret

	case hundredPercent:
		COLORSENSOR_S0_PORT |= COLORSENSOR_S0_PIN;
     4c2:	e5 e0       	ldi	r30, 0x05	; 5
     4c4:	f1 e0       	ldi	r31, 0x01	; 1
     4c6:	80 81       	ld	r24, Z
     4c8:	81 60       	ori	r24, 0x01	; 1
     4ca:	80 83       	st	Z, r24
		COLORSENSOR_S1_PORT |= COLORSENSOR_S1_PIN;
     4cc:	80 81       	ld	r24, Z
     4ce:	80 83       	st	Z, r24
     4d0:	08 95       	ret

000004d2 <_ZN11ColorSensorC1E16FrequencyScaling>:
#include "FreeRTOS.h"
#include "task.h"
#include "portmacro.h"

// default constructor
ColorSensor::ColorSensor( FrequencyScaling scaling )
     4d2:	bf 92       	push	r11
     4d4:	cf 92       	push	r12
     4d6:	df 92       	push	r13
     4d8:	ef 92       	push	r14
     4da:	ff 92       	push	r15
     4dc:	0f 93       	push	r16
     4de:	1f 93       	push	r17
     4e0:	cf 93       	push	r28
     4e2:	df 93       	push	r29
     4e4:	1f 92       	push	r1
     4e6:	cd b7       	in	r28, 0x3d	; 61
     4e8:	de b7       	in	r29, 0x3e	; 62
     4ea:	6c 01       	movw	r12, r24
     4ec:	b6 2e       	mov	r11, r22
     4ee:	26 d0       	rcall	.+76     	; 0x53c <_ZN6Timer4C1Ev>
     4f0:	76 01       	movw	r14, r12
     4f2:	8f ef       	ldi	r24, 0xFF	; 255
     4f4:	e8 1a       	sub	r14, r24
     4f6:	f8 0a       	sbc	r15, r24
     4f8:	09 e0       	ldi	r16, 0x09	; 9
     4fa:	10 e0       	ldi	r17, 0x00	; 0
     4fc:	0f 3f       	cpi	r16, 0xFF	; 255
     4fe:	8f ef       	ldi	r24, 0xFF	; 255
     500:	18 07       	cpc	r17, r24
     502:	41 f0       	breq	.+16     	; 0x514 <_ZN11ColorSensorC1E16FrequencyScaling+0x42>
     504:	c7 01       	movw	r24, r14
     506:	99 de       	rcall	.-718    	; 0x23a <_ZN5ColorC1Ev>
     508:	89 e0       	ldi	r24, 0x09	; 9
     50a:	e8 0e       	add	r14, r24
     50c:	f1 1c       	adc	r15, r1
     50e:	01 50       	subi	r16, 0x01	; 1
     510:	11 09       	sbc	r17, r1
     512:	f4 cf       	rjmp	.-24     	; 0x4fc <_ZN11ColorSensorC1E16FrequencyScaling+0x2a>
{
	frequency_ = Timer4();
     514:	ce 01       	movw	r24, r28
     516:	01 96       	adiw	r24, 0x01	; 1
     518:	11 d0       	rcall	.+34     	; 0x53c <_ZN6Timer4C1Ev>

	// Set default filter and scaling
	setFilter( noFilter );
     51a:	60 e0       	ldi	r22, 0x00	; 0
     51c:	c6 01       	movw	r24, r12
     51e:	b1 de       	rcall	.-670    	; 0x282 <_ZN11ColorSensor9setFilterE6Filter>
	setFrequencyscaling( scaling );
     520:	6b 2d       	mov	r22, r11
     522:	c6 01       	movw	r24, r12
     524:	ae df       	rcall	.-164    	; 0x482 <_ZN11ColorSensor19setFrequencyscalingE16FrequencyScaling>
     526:	0f 90       	pop	r0
}
     528:	df 91       	pop	r29
     52a:	cf 91       	pop	r28
     52c:	1f 91       	pop	r17
     52e:	0f 91       	pop	r16
     530:	ff 90       	pop	r15
     532:	ef 90       	pop	r14
     534:	df 90       	pop	r13
     536:	cf 90       	pop	r12
     538:	bf 90       	pop	r11
     53a:	08 95       	ret

0000053c <_ZN6Timer4C1Ev>:
//volatile float tick = 0.000064;

Timer4::Timer4()
{
	// Set ports to the right values.
	COLORSENSOR_S0_PORT |= ( 1 << COLORSENSOR_S0_PIN );
     53c:	e5 e0       	ldi	r30, 0x05	; 5
     53e:	f1 e0       	ldi	r31, 0x01	; 1
     540:	80 81       	ld	r24, Z
     542:	82 60       	ori	r24, 0x02	; 2
     544:	80 83       	st	Z, r24
	COLORSENSOR_S1_PORT |= ( 1 << COLORSENSOR_S1_PIN );
     546:	80 81       	ld	r24, Z
     548:	81 60       	ori	r24, 0x01	; 1
     54a:	80 83       	st	Z, r24
	COLORSENSOR_S2_PORT |= ( 1 << COLORSENSOR_S2_PIN );
     54c:	e2 e0       	ldi	r30, 0x02	; 2
     54e:	f1 e0       	ldi	r31, 0x01	; 1
     550:	80 81       	ld	r24, Z
     552:	82 60       	ori	r24, 0x02	; 2
     554:	80 83       	st	Z, r24
	COLORSENSOR_S3_PORT |= ( 1 << COLORSENSOR_S3_PIN );
     556:	80 81       	ld	r24, Z
     558:	81 60       	ori	r24, 0x01	; 1
     55a:	80 83       	st	Z, r24
	
	// Setup timer to normal mode and pre scaler to 64
	TCCR4A = 0U;
     55c:	10 92 a0 00 	sts	0x00A0, r1	; 0x8000a0 <__TEXT_REGION_LENGTH__+0x7000a0>
	TCCR4B = ( 1 << ICNC4 ) | ( 1 << ICES4 ) | ( 1 << CS40 ) | ( 1 << CS41 );
     560:	83 ec       	ldi	r24, 0xC3	; 195
     562:	80 93 a1 00 	sts	0x00A1, r24	; 0x8000a1 <__TEXT_REGION_LENGTH__+0x7000a1>
	TCCR4C = 0U;
     566:	10 92 a2 00 	sts	0x00A2, r1	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
	
	// Clear flags and set counter to zero
	TIFR4 = ( 1 << ICF4 ) | ( 1 << TOV4 );
     56a:	81 e2       	ldi	r24, 0x21	; 33
     56c:	89 bb       	out	0x19, r24	; 25
	TCNT4 = 0;        
     56e:	10 92 a5 00 	sts	0x00A5, r1	; 0x8000a5 <__TEXT_REGION_LENGTH__+0x7000a5>
     572:	10 92 a4 00 	sts	0x00A4, r1	; 0x8000a4 <__TEXT_REGION_LENGTH__+0x7000a4>

	// Enable global interrupts
    sei();
     576:	78 94       	sei
     578:	08 95       	ret

0000057a <_ZN6Timer49getPeriodEv>:
}

uint16_t Timer4::getPeriod( void )
{
	// Reset all needed values
	first = true;
     57a:	81 e0       	ldi	r24, 0x01	; 1
     57c:	80 93 0a 02 	sts	0x020A, r24	; 0x80020a <first>
	oldValue = 0U;
     580:	10 92 d7 02 	sts	0x02D7, r1	; 0x8002d7 <oldValue+0x1>
     584:	10 92 d6 02 	sts	0x02D6, r1	; 0x8002d6 <oldValue>
	period = 0U;
     588:	10 92 d1 02 	sts	0x02D1, r1	; 0x8002d1 <__data_end+0x1>
     58c:	10 92 d0 02 	sts	0x02D0, r1	; 0x8002d0 <__data_end>
	timeroverflow = 0;
     590:	10 92 d2 02 	sts	0x02D2, r1	; 0x8002d2 <timeroverflow>
     594:	10 92 d3 02 	sts	0x02D3, r1	; 0x8002d3 <timeroverflow+0x1>
     598:	10 92 d4 02 	sts	0x02D4, r1	; 0x8002d4 <timeroverflow+0x2>
     59c:	10 92 d5 02 	sts	0x02D5, r1	; 0x8002d5 <timeroverflow+0x3>
	
	// Enable interrupt and clear pending
	TIFR4 = ( 1 << ICF4 ) | ( 1 << TOV4 );
     5a0:	81 e2       	ldi	r24, 0x21	; 33
     5a2:	89 bb       	out	0x19, r24	; 25
	TIMSK4 = ( 1 << ICIE4 ) | ( 1 << TOIE4 );	
     5a4:	80 93 72 00 	sts	0x0072, r24	; 0x800072 <__TEXT_REGION_LENGTH__+0x700072>
	
	// Wait until measurement has been taken
	while ( period == 0U )
     5a8:	80 91 d0 02 	lds	r24, 0x02D0	; 0x8002d0 <__data_end>
     5ac:	90 91 d1 02 	lds	r25, 0x02D1	; 0x8002d1 <__data_end+0x1>
     5b0:	89 2b       	or	r24, r25
     5b2:	81 f4       	brne	.+32     	; 0x5d4 <_ZN6Timer49getPeriodEv+0x5a>
	{
		if ( timeroverflow > 10U )
     5b4:	80 91 d2 02 	lds	r24, 0x02D2	; 0x8002d2 <timeroverflow>
     5b8:	90 91 d3 02 	lds	r25, 0x02D3	; 0x8002d3 <timeroverflow+0x1>
     5bc:	a0 91 d4 02 	lds	r26, 0x02D4	; 0x8002d4 <timeroverflow+0x2>
     5c0:	b0 91 d5 02 	lds	r27, 0x02D5	; 0x8002d5 <timeroverflow+0x3>
     5c4:	0b 97       	sbiw	r24, 0x0b	; 11
     5c6:	a1 05       	cpc	r26, r1
     5c8:	b1 05       	cpc	r27, r1
     5ca:	70 f3       	brcs	.-36     	; 0x5a8 <_ZN6Timer49getPeriodEv+0x2e>
		{
			// Error - Disable interrupt and clear pending
			TIMSK4 = 0U;
     5cc:	10 92 72 00 	sts	0x0072, r1	; 0x800072 <__TEXT_REGION_LENGTH__+0x700072>
			TIFR4 = ( 1 << ICF4 ) | ( 1 << TOV4 );
     5d0:	81 e2       	ldi	r24, 0x21	; 33
     5d2:	89 bb       	out	0x19, r24	; 25
			break;
		}
	}
	
	return period;
     5d4:	80 91 d0 02 	lds	r24, 0x02D0	; 0x8002d0 <__data_end>
     5d8:	90 91 d1 02 	lds	r25, 0x02D1	; 0x8002d1 <__data_end+0x1>
}
     5dc:	08 95       	ret

000005de <__vector_45>:

ISR(TIMER4_OVF_vect)
{
     5de:	1f 92       	push	r1
     5e0:	0f 92       	push	r0
     5e2:	0f b6       	in	r0, 0x3f	; 63
     5e4:	0f 92       	push	r0
     5e6:	11 24       	eor	r1, r1
     5e8:	8f 93       	push	r24
     5ea:	9f 93       	push	r25
     5ec:	af 93       	push	r26
     5ee:	bf 93       	push	r27
	timeroverflow++;
     5f0:	80 91 d2 02 	lds	r24, 0x02D2	; 0x8002d2 <timeroverflow>
     5f4:	90 91 d3 02 	lds	r25, 0x02D3	; 0x8002d3 <timeroverflow+0x1>
     5f8:	a0 91 d4 02 	lds	r26, 0x02D4	; 0x8002d4 <timeroverflow+0x2>
     5fc:	b0 91 d5 02 	lds	r27, 0x02D5	; 0x8002d5 <timeroverflow+0x3>
     600:	01 96       	adiw	r24, 0x01	; 1
     602:	a1 1d       	adc	r26, r1
     604:	b1 1d       	adc	r27, r1
     606:	80 93 d2 02 	sts	0x02D2, r24	; 0x8002d2 <timeroverflow>
     60a:	90 93 d3 02 	sts	0x02D3, r25	; 0x8002d3 <timeroverflow+0x1>
     60e:	a0 93 d4 02 	sts	0x02D4, r26	; 0x8002d4 <timeroverflow+0x2>
     612:	b0 93 d5 02 	sts	0x02D5, r27	; 0x8002d5 <timeroverflow+0x3>
}
     616:	bf 91       	pop	r27
     618:	af 91       	pop	r26
     61a:	9f 91       	pop	r25
     61c:	8f 91       	pop	r24
     61e:	0f 90       	pop	r0
     620:	0f be       	out	0x3f, r0	; 63
     622:	0f 90       	pop	r0
     624:	1f 90       	pop	r1
     626:	18 95       	reti

00000628 <__vector_41>:

ISR(TIMER4_CAPT_vect)
{
     628:	1f 92       	push	r1
     62a:	0f 92       	push	r0
     62c:	0f b6       	in	r0, 0x3f	; 63
     62e:	0f 92       	push	r0
     630:	11 24       	eor	r1, r1
     632:	0b b6       	in	r0, 0x3b	; 59
     634:	0f 92       	push	r0
     636:	cf 92       	push	r12
     638:	df 92       	push	r13
     63a:	ef 92       	push	r14
     63c:	ff 92       	push	r15
     63e:	0f 93       	push	r16
     640:	1f 93       	push	r17
     642:	2f 93       	push	r18
     644:	3f 93       	push	r19
     646:	4f 93       	push	r20
     648:	5f 93       	push	r21
     64a:	6f 93       	push	r22
     64c:	7f 93       	push	r23
     64e:	8f 93       	push	r24
     650:	9f 93       	push	r25
     652:	af 93       	push	r26
     654:	bf 93       	push	r27
     656:	ef 93       	push	r30
     658:	ff 93       	push	r31
	// Read value of timer
	uint16_t readValue = ICR4;
     65a:	60 91 a6 00 	lds	r22, 0x00A6	; 0x8000a6 <__TEXT_REGION_LENGTH__+0x7000a6>
     65e:	70 91 a7 00 	lds	r23, 0x00A7	; 0x8000a7 <__TEXT_REGION_LENGTH__+0x7000a7>

	if ( first == true )
     662:	80 91 0a 02 	lds	r24, 0x020A	; 0x80020a <first>
     666:	88 23       	and	r24, r24
     668:	79 f0       	breq	.+30     	; 0x688 <__vector_41+0x60>
	{
		timeroverflow = 0U;
     66a:	10 92 d2 02 	sts	0x02D2, r1	; 0x8002d2 <timeroverflow>
     66e:	10 92 d3 02 	sts	0x02D3, r1	; 0x8002d3 <timeroverflow+0x1>
     672:	10 92 d4 02 	sts	0x02D4, r1	; 0x8002d4 <timeroverflow+0x2>
     676:	10 92 d5 02 	sts	0x02D5, r1	; 0x8002d5 <timeroverflow+0x3>
		oldValue = readValue;
     67a:	70 93 d7 02 	sts	0x02D7, r23	; 0x8002d7 <oldValue+0x1>
     67e:	60 93 d6 02 	sts	0x02D6, r22	; 0x8002d6 <oldValue>
		first = false;
     682:	10 92 0a 02 	sts	0x020A, r1	; 0x80020a <first>
		return;
     686:	81 c0       	rjmp	.+258    	; 0x78a <__vector_41+0x162>
	}
	
	// Check if overflow is pending
	if ( TIFR4 & ( 1 << TOV4 ))
     688:	c8 9b       	sbis	0x19, 0	; 25
     68a:	13 c0       	rjmp	.+38     	; 0x6b2 <__vector_41+0x8a>
	{
		timeroverflow++;
     68c:	80 91 d2 02 	lds	r24, 0x02D2	; 0x8002d2 <timeroverflow>
     690:	90 91 d3 02 	lds	r25, 0x02D3	; 0x8002d3 <timeroverflow+0x1>
     694:	a0 91 d4 02 	lds	r26, 0x02D4	; 0x8002d4 <timeroverflow+0x2>
     698:	b0 91 d5 02 	lds	r27, 0x02D5	; 0x8002d5 <timeroverflow+0x3>
     69c:	01 96       	adiw	r24, 0x01	; 1
     69e:	a1 1d       	adc	r26, r1
     6a0:	b1 1d       	adc	r27, r1
     6a2:	80 93 d2 02 	sts	0x02D2, r24	; 0x8002d2 <timeroverflow>
     6a6:	90 93 d3 02 	sts	0x02D3, r25	; 0x8002d3 <timeroverflow+0x1>
     6aa:	a0 93 d4 02 	sts	0x02D4, r26	; 0x8002d4 <timeroverflow+0x2>
     6ae:	b0 93 d5 02 	sts	0x02D5, r27	; 0x8002d5 <timeroverflow+0x3>
	}
		
	// Disable interrupt and clear pending
	TIMSK4 = 0U;	
     6b2:	10 92 72 00 	sts	0x0072, r1	; 0x800072 <__TEXT_REGION_LENGTH__+0x700072>
	TIFR4 = ( 1 << ICF4 ) | ( 1 << TOV4 );		
     6b6:	81 e2       	ldi	r24, 0x21	; 33
     6b8:	89 bb       	out	0x19, r24	; 25
			
	// Calculate difference
	uint32_t diff = 0U;

	if ( readValue < oldValue )
     6ba:	80 91 d6 02 	lds	r24, 0x02D6	; 0x8002d6 <oldValue>
     6be:	90 91 d7 02 	lds	r25, 0x02D7	; 0x8002d7 <oldValue+0x1>
     6c2:	68 17       	cp	r22, r24
     6c4:	79 07       	cpc	r23, r25
     6c6:	58 f5       	brcc	.+86     	; 0x71e <__vector_41+0xf6>
	{
		if ( timeroverflow != 0 )
     6c8:	80 91 d2 02 	lds	r24, 0x02D2	; 0x8002d2 <timeroverflow>
     6cc:	90 91 d3 02 	lds	r25, 0x02D3	; 0x8002d3 <timeroverflow+0x1>
     6d0:	a0 91 d4 02 	lds	r26, 0x02D4	; 0x8002d4 <timeroverflow+0x2>
     6d4:	b0 91 d5 02 	lds	r27, 0x02D5	; 0x8002d5 <timeroverflow+0x3>
     6d8:	89 2b       	or	r24, r25
     6da:	8a 2b       	or	r24, r26
     6dc:	8b 2b       	or	r24, r27
     6de:	99 f0       	breq	.+38     	; 0x706 <__vector_41+0xde>
		{
			timeroverflow--;
     6e0:	80 91 d2 02 	lds	r24, 0x02D2	; 0x8002d2 <timeroverflow>
     6e4:	90 91 d3 02 	lds	r25, 0x02D3	; 0x8002d3 <timeroverflow+0x1>
     6e8:	a0 91 d4 02 	lds	r26, 0x02D4	; 0x8002d4 <timeroverflow+0x2>
     6ec:	b0 91 d5 02 	lds	r27, 0x02D5	; 0x8002d5 <timeroverflow+0x3>
     6f0:	01 97       	sbiw	r24, 0x01	; 1
     6f2:	a1 09       	sbc	r26, r1
     6f4:	b1 09       	sbc	r27, r1
     6f6:	80 93 d2 02 	sts	0x02D2, r24	; 0x8002d2 <timeroverflow>
     6fa:	90 93 d3 02 	sts	0x02D3, r25	; 0x8002d3 <timeroverflow+0x1>
     6fe:	a0 93 d4 02 	sts	0x02D4, r26	; 0x8002d4 <timeroverflow+0x2>
     702:	b0 93 d5 02 	sts	0x02D5, r27	; 0x8002d5 <timeroverflow+0x3>
		}
		diff = ( 0xFFFF - oldValue ) + readValue;
     706:	80 91 d6 02 	lds	r24, 0x02D6	; 0x8002d6 <oldValue>
     70a:	90 91 d7 02 	lds	r25, 0x02D7	; 0x8002d7 <oldValue+0x1>
     70e:	68 1b       	sub	r22, r24
     710:	79 0b       	sbc	r23, r25
     712:	61 50       	subi	r22, 0x01	; 1
     714:	71 09       	sbc	r23, r1
     716:	cb 01       	movw	r24, r22
     718:	a0 e0       	ldi	r26, 0x00	; 0
     71a:	b0 e0       	ldi	r27, 0x00	; 0
     71c:	09 c0       	rjmp	.+18     	; 0x730 <__vector_41+0x108>
	}
	else
	{
		diff = readValue - oldValue;
     71e:	80 91 d6 02 	lds	r24, 0x02D6	; 0x8002d6 <oldValue>
     722:	90 91 d7 02 	lds	r25, 0x02D7	; 0x8002d7 <oldValue+0x1>
     726:	68 1b       	sub	r22, r24
     728:	79 0b       	sbc	r23, r25
     72a:	cb 01       	movw	r24, r22
     72c:	a0 e0       	ldi	r26, 0x00	; 0
     72e:	b0 e0       	ldi	r27, 0x00	; 0
	}
	
	// Add timeroverflow to total diff
	diff += timeroverflow << 16U;
     730:	40 91 d2 02 	lds	r20, 0x02D2	; 0x8002d2 <timeroverflow>
     734:	50 91 d3 02 	lds	r21, 0x02D3	; 0x8002d3 <timeroverflow+0x1>
     738:	60 91 d4 02 	lds	r22, 0x02D4	; 0x8002d4 <timeroverflow+0x2>
     73c:	70 91 d5 02 	lds	r23, 0x02D5	; 0x8002d5 <timeroverflow+0x3>
     740:	ba 01       	movw	r22, r20
     742:	55 27       	eor	r21, r21
     744:	44 27       	eor	r20, r20
     746:	8a 01       	movw	r16, r20
     748:	9b 01       	movw	r18, r22
     74a:	08 0f       	add	r16, r24
     74c:	19 1f       	adc	r17, r25
     74e:	2a 1f       	adc	r18, r26
     750:	3b 1f       	adc	r19, r27
     752:	c9 01       	movw	r24, r18
     754:	b8 01       	movw	r22, r16
	
	// Calculate period
	period = diff * tick * 1000000;
     756:	c0 90 06 02 	lds	r12, 0x0206	; 0x800206 <tick>
     75a:	d0 90 07 02 	lds	r13, 0x0207	; 0x800207 <tick+0x1>
     75e:	e0 90 08 02 	lds	r14, 0x0208	; 0x800208 <tick+0x2>
     762:	f0 90 09 02 	lds	r15, 0x0209	; 0x800209 <tick+0x3>
     766:	0e 94 5a 16 	call	0x2cb4	; 0x2cb4 <__floatunsisf>
     76a:	a7 01       	movw	r20, r14
     76c:	96 01       	movw	r18, r12
     76e:	0e 94 10 17 	call	0x2e20	; 0x2e20 <__mulsf3>
     772:	20 e0       	ldi	r18, 0x00	; 0
     774:	34 e2       	ldi	r19, 0x24	; 36
     776:	44 e7       	ldi	r20, 0x74	; 116
     778:	59 e4       	ldi	r21, 0x49	; 73
     77a:	0e 94 10 17 	call	0x2e20	; 0x2e20 <__mulsf3>
     77e:	0e 94 2e 16 	call	0x2c5c	; 0x2c5c <__fixunssfsi>
     782:	70 93 d1 02 	sts	0x02D1, r23	; 0x8002d1 <__data_end+0x1>
     786:	60 93 d0 02 	sts	0x02D0, r22	; 0x8002d0 <__data_end>
     78a:	ff 91       	pop	r31
     78c:	ef 91       	pop	r30
     78e:	bf 91       	pop	r27
     790:	af 91       	pop	r26
     792:	9f 91       	pop	r25
     794:	8f 91       	pop	r24
     796:	7f 91       	pop	r23
     798:	6f 91       	pop	r22
     79a:	5f 91       	pop	r21
     79c:	4f 91       	pop	r20
     79e:	3f 91       	pop	r19
     7a0:	2f 91       	pop	r18
     7a2:	1f 91       	pop	r17
     7a4:	0f 91       	pop	r16
     7a6:	ff 90       	pop	r15
     7a8:	ef 90       	pop	r14
     7aa:	df 90       	pop	r13
     7ac:	cf 90       	pop	r12
     7ae:	0f 90       	pop	r0
     7b0:	0b be       	out	0x3b, r0	; 59
     7b2:	0f 90       	pop	r0
     7b4:	0f be       	out	0x3f, r0	; 63
     7b6:	0f 90       	pop	r0
     7b8:	1f 90       	pop	r1
     7ba:	18 95       	reti

000007bc <_ZN6KeyPadC1Ev>:
/* RTOS include */
#include "FreeRTOS.h"
#include "task.h"
#include "portmacro.h"

 KeyPad::KeyPad()
     7bc:	08 95       	ret

000007be <_ZN6KeyPadD1Ev>:
{
}

KeyPad::~KeyPad()
     7be:	08 95       	ret

000007c0 <_ZN6KeyPad7findKeyEh>:
{
	// Switch case for what key is pressed on pad
	// Might need to be change if Inputs are not connected the 
	// same way
	
	switch(pin_press) {
     7c0:	86 2f       	mov	r24, r22
     7c2:	90 e0       	ldi	r25, 0x00	; 0
     7c4:	fc 01       	movw	r30, r24
     7c6:	71 97       	sbiw	r30, 0x11	; 17
     7c8:	e8 37       	cpi	r30, 0x78	; 120
     7ca:	f1 05       	cpc	r31, r1
     7cc:	20 f5       	brcc	.+72     	; 0x816 <_ZN6KeyPad7findKeyEh+0x56>
     7ce:	88 27       	eor	r24, r24
     7d0:	ee 58       	subi	r30, 0x8E	; 142
     7d2:	ff 4f       	sbci	r31, 0xFF	; 255
     7d4:	8f 4f       	sbci	r24, 0xFF	; 255
     7d6:	0c 94 95 17 	jmp	0x2f2a	; 0x2f2a <__tablejump2__>
		
		case 0b01000010  :
			return '1';
     7da:	81 e3       	ldi	r24, 0x31	; 49
     7dc:	08 95       	ret
		case 0b01001000  :
			return '2';
		case 0b01000001  :
			return '3';
     7de:	83 e3       	ldi	r24, 0x33	; 51
     7e0:	08 95       	ret
		case 0b01000100  :
			return 'A';
     7e2:	81 e4       	ldi	r24, 0x41	; 65
     7e4:	08 95       	ret
			
		case 0b10000010  :
			return '4';
     7e6:	84 e3       	ldi	r24, 0x34	; 52
     7e8:	08 95       	ret
		case 0b10001000  :
			return '5';
     7ea:	85 e3       	ldi	r24, 0x35	; 53
     7ec:	08 95       	ret
		case 0b10000001  :
			return '6';
     7ee:	86 e3       	ldi	r24, 0x36	; 54
     7f0:	08 95       	ret
		case 0b10000100  :
			return 'B';
     7f2:	82 e4       	ldi	r24, 0x42	; 66
     7f4:	08 95       	ret
			
		case 0b00100010  :
			return '7';
     7f6:	87 e3       	ldi	r24, 0x37	; 55
     7f8:	08 95       	ret
		case 0b00101000  :
			return '8';
     7fa:	88 e3       	ldi	r24, 0x38	; 56
     7fc:	08 95       	ret
		case 0b00100001  :
			return '9';
     7fe:	89 e3       	ldi	r24, 0x39	; 57
     800:	08 95       	ret
		case 0b00100100  :
			return 'C';
     802:	83 e4       	ldi	r24, 0x43	; 67
     804:	08 95       	ret
			
		case 0b00010010  :
			return '*';
     806:	8a e2       	ldi	r24, 0x2A	; 42
     808:	08 95       	ret
		case 0b00011000  :
			return '0';
     80a:	80 e3       	ldi	r24, 0x30	; 48
     80c:	08 95       	ret
		case 0b00010001  :
			return '#';
     80e:	83 e2       	ldi	r24, 0x23	; 35
     810:	08 95       	ret
		case 0b00010100  :
			return 'D';
     812:	84 e4       	ldi	r24, 0x44	; 68
     814:	08 95       	ret
			
		
		default :
			return 'E';
     816:	85 e4       	ldi	r24, 0x45	; 69
     818:	08 95       	ret
	switch(pin_press) {
		
		case 0b01000010  :
			return '1';
		case 0b01001000  :
			return '2';
     81a:	82 e3       	ldi	r24, 0x32	; 50
			
		
		default :
			return 'E';
	}
     81c:	08 95       	ret

0000081e <_ZN6KeyPad12readKeyboardEv>:

KeyPad::~KeyPad()
{
}

char KeyPad::readKeyboard(){
     81e:	ef 92       	push	r14
     820:	ff 92       	push	r15
     822:	0f 93       	push	r16
     824:	1f 93       	push	r17
     826:	cf 93       	push	r28
     828:	8c 01       	movw	r16, r24
	
	uint8_t read_byte = 0; // Bytes to contain pressed char
	DDRK = 0b11110000; // Configure for Columns to be output and row to be input
     82a:	80 ef       	ldi	r24, 0xF0	; 240
     82c:	80 93 07 01 	sts	0x0107, r24	; 0x800107 <__TEXT_REGION_LENGTH__+0x700107>
	PORTK = 0b11110000; // Set Columns output to be high!
     830:	80 93 08 01 	sts	0x0108, r24	; 0x800108 <__TEXT_REGION_LENGTH__+0x700108>
	
	vTaskDelay(8/portTICK_RATE_MS);	// Delays for allowing Pins to switch state from input to output and reverse
     834:	88 e0       	ldi	r24, 0x08	; 8
     836:	90 e0       	ldi	r25, 0x00	; 0
     838:	0e 94 59 11 	call	0x22b2	; 0x22b2 <vTaskDelay>
	
	while( (PINK & 0b00001111) == 0 );	// Wait for key pressed
     83c:	80 91 06 01 	lds	r24, 0x0106	; 0x800106 <__TEXT_REGION_LENGTH__+0x700106>
     840:	8f 70       	andi	r24, 0x0F	; 15
     842:	e1 f3       	breq	.-8      	; 0x83c <_ZN6KeyPad12readKeyboardEv+0x1e>
	
	read_byte = (PINK & 0b00001111); // Get row of pressed key
     844:	0f 2e       	mov	r0, r31
     846:	f6 e0       	ldi	r31, 0x06	; 6
     848:	ef 2e       	mov	r14, r31
     84a:	ff 24       	eor	r15, r15
     84c:	f3 94       	inc	r15
     84e:	f0 2d       	mov	r31, r0
     850:	f7 01       	movw	r30, r14
     852:	c0 81       	ld	r28, Z
     854:	cf 70       	andi	r28, 0x0F	; 15
	
	DDRK = 0b00001111; // Switch Columns to be input and row to be output
     856:	8f e0       	ldi	r24, 0x0F	; 15
     858:	80 93 07 01 	sts	0x0107, r24	; 0x800107 <__TEXT_REGION_LENGTH__+0x700107>
	PORTK = 0b00001111; // Set Row outputs to be high!
     85c:	80 93 08 01 	sts	0x0108, r24	; 0x800108 <__TEXT_REGION_LENGTH__+0x700108>
	
	vTaskDelay(8/portTICK_RATE_MS);
     860:	88 e0       	ldi	r24, 0x08	; 8
     862:	90 e0       	ldi	r25, 0x00	; 0
     864:	0e 94 59 11 	call	0x22b2	; 0x22b2 <vTaskDelay>
	
	char pressed_key = findKey(read_byte | (PINK & 0b11110000));
     868:	f7 01       	movw	r30, r14
     86a:	60 81       	ld	r22, Z
     86c:	60 7f       	andi	r22, 0xF0	; 240
     86e:	6c 2b       	or	r22, r28
     870:	c8 01       	movw	r24, r16
     872:	a6 df       	rcall	.-180    	; 0x7c0 <_ZN6KeyPad7findKeyEh>
     874:	c8 2f       	mov	r28, r24

	// Wait for no key pressed anymore
	while((PINK & 0b11110000) != 0);
     876:	80 91 06 01 	lds	r24, 0x0106	; 0x800106 <__TEXT_REGION_LENGTH__+0x700106>
     87a:	80 7f       	andi	r24, 0xF0	; 240
     87c:	e1 f7       	brne	.-8      	; 0x876 <_ZN6KeyPad12readKeyboardEv+0x58>
	SendString("pressed key:\r\n");
     87e:	8e e0       	ldi	r24, 0x0E	; 14
     880:	92 e0       	ldi	r25, 0x02	; 2
     882:	0e 94 36 15 	call	0x2a6c	; 0x2a6c <_Z10SendStringPc>
	SendInteger(pressed_key);
     886:	8c 2f       	mov	r24, r28
     888:	90 e0       	ldi	r25, 0x00	; 0
     88a:	0e 94 42 15 	call	0x2a84	; 0x2a84 <_Z11SendIntegeri>
	SendString("\r\n");
     88e:	8a e1       	ldi	r24, 0x1A	; 26
     890:	92 e0       	ldi	r25, 0x02	; 2
     892:	0e 94 36 15 	call	0x2a6c	; 0x2a6c <_Z10SendStringPc>
	return pressed_key;
}
     896:	8c 2f       	mov	r24, r28
     898:	cf 91       	pop	r28
     89a:	1f 91       	pop	r17
     89c:	0f 91       	pop	r16
     89e:	ff 90       	pop	r15
     8a0:	ef 90       	pop	r14
     8a2:	08 95       	ret

000008a4 <_ZN14LoginInterfaceC1Ev>:
#include <stdlib.h>
#include <avr/io.h>
#include "KeyPad.h"
#include "LoginInterface.h"

 LoginInterface::LoginInterface()
     8a4:	0f 93       	push	r16
     8a6:	1f 93       	push	r17
     8a8:	cf 93       	push	r28
     8aa:	df 93       	push	r29
     8ac:	1f 92       	push	r1
     8ae:	cd b7       	in	r28, 0x3d	; 61
     8b0:	de b7       	in	r29, 0x3e	; 62
     8b2:	8c 01       	movw	r16, r24
     8b4:	83 df       	rcall	.-250    	; 0x7bc <_ZN6KeyPadC1Ev>
 {
	 keypad = KeyPad();
     8b6:	ce 01       	movw	r24, r28
     8b8:	01 96       	adiw	r24, 0x01	; 1
     8ba:	80 df       	rcall	.-256    	; 0x7bc <_ZN6KeyPadC1Ev>
     8bc:	ce 01       	movw	r24, r28
     8be:	01 96       	adiw	r24, 0x01	; 1
     8c0:	7e df       	rcall	.-260    	; 0x7be <_ZN6KeyPadD1Ev>
	 // ASCII Used since static declaration is not supported before STD c++ 11
	 passWord[0] = 49; // 1
     8c2:	81 e3       	ldi	r24, 0x31	; 49
     8c4:	f8 01       	movw	r30, r16
     8c6:	81 83       	std	Z+1, r24	; 0x01
	 passWord[1] = 52; // 4
     8c8:	84 e3       	ldi	r24, 0x34	; 52
     8ca:	82 83       	std	Z+2, r24	; 0x02
	 passWord[2] = 55; // 7
     8cc:	87 e3       	ldi	r24, 0x37	; 55
     8ce:	83 83       	std	Z+3, r24	; 0x03
	 passWord[3] = 50; // 2
     8d0:	82 e3       	ldi	r24, 0x32	; 50
     8d2:	84 83       	std	Z+4, r24	; 0x04
	 stateOfMachine = 'L';
     8d4:	8c e4       	ldi	r24, 0x4C	; 76
     8d6:	85 83       	std	Z+5, r24	; 0x05
 }
     8d8:	0f 90       	pop	r0
     8da:	df 91       	pop	r29
     8dc:	cf 91       	pop	r28
     8de:	1f 91       	pop	r17
     8e0:	0f 91       	pop	r16
     8e2:	08 95       	ret

000008e4 <_ZN14LoginInterfaceD1Ev>:
 
 LoginInterface::~LoginInterface()
     8e4:	6c cf       	rjmp	.-296    	; 0x7be <_ZN6KeyPadD1Ev>
     8e6:	08 95       	ret

000008e8 <_ZN14LoginInterface17getstateOfMachineEv>:
 
 // Set and get Method for stateOfMachine
 char LoginInterface::getstateOfMachine()
 {
	 return stateOfMachine;
 }
     8e8:	fc 01       	movw	r30, r24
     8ea:	85 81       	ldd	r24, Z+5	; 0x05
     8ec:	08 95       	ret

000008ee <_ZN14LoginInterface10checkLoginEv>:
 LoginInterface::~LoginInterface()
 {
 }
 
 void LoginInterface::checkLogin()
 {
     8ee:	0f 93       	push	r16
     8f0:	1f 93       	push	r17
     8f2:	cf 93       	push	r28
     8f4:	8c 01       	movw	r16, r24
	 uint8_t userPressed = 0;
     8f6:	c0 e0       	ldi	r28, 0x00	; 0
     8f8:	01 c0       	rjmp	.+2      	; 0x8fc <_ZN14LoginInterface10checkLoginEv+0xe>
		 char buf = keypad.readKeyboard();
		 
		 // If star is pressed.. Reset Keys pressed
		 if (buf == 42)
		 {
			 userPressed = 0;
     8fa:	c0 e0       	ldi	r28, 0x00	; 0
 void LoginInterface::checkLogin()
 {
	 uint8_t userPressed = 0;
	 uint8_t userPass[4];
	 
	 while(userPressed < 4)
     8fc:	c4 30       	cpi	r28, 0x04	; 4
     8fe:	30 f4       	brcc	.+12     	; 0x90c <_ZN14LoginInterface10checkLoginEv+0x1e>
	 {
		 char buf = keypad.readKeyboard();
     900:	c8 01       	movw	r24, r16
     902:	8d df       	rcall	.-230    	; 0x81e <_ZN6KeyPad12readKeyboardEv>
		 
		 // If star is pressed.. Reset Keys pressed
		 if (buf == 42)
     904:	8a 32       	cpi	r24, 0x2A	; 42
     906:	c9 f3       	breq	.-14     	; 0x8fa <_ZN14LoginInterface10checkLoginEv+0xc>
			 userPressed = 0;
		 }else
		 {
			 // Put key pressed into array
			 userPass[userPressed] = buf;
			 userPressed++; 
     908:	cf 5f       	subi	r28, 0xFF	; 255
     90a:	f8 cf       	rjmp	.-16     	; 0x8fc <_ZN14LoginInterface10checkLoginEv+0xe>
     90c:	80 e0       	ldi	r24, 0x00	; 0
		 }
	 }
	 
	 
	 // Check each of the entries in array if they match password
	 for (uint8_t i = 0; i < 4; i++)
     90e:	84 30       	cpi	r24, 0x04	; 4
     910:	10 f4       	brcc	.+4      	; 0x916 <_ZN14LoginInterface10checkLoginEv+0x28>
     912:	8f 5f       	subi	r24, 0xFF	; 255
     914:	fc cf       	rjmp	.-8      	; 0x90e <_ZN14LoginInterface10checkLoginEv+0x20>
		 setstateOfMachine('U');
	 }else
	 {
		 setstateOfMachine('L');	
	 }
 }
     916:	cf 91       	pop	r28
     918:	1f 91       	pop	r17
     91a:	0f 91       	pop	r16
     91c:	08 95       	ret

0000091e <_Z11LoginKeyPadPv>:
void * operator new(size_t size);
void operator delete(void * ptr);

int __cxa_guard_acquire(__guard *g) {return !*(char *)(g);};
void __cxa_guard_release (__guard *g) {*(char *)g = 1;};
void __cxa_guard_abort (__guard *) {};
     91e:	89 ed       	ldi	r24, 0xD9	; 217
     920:	92 e0       	ldi	r25, 0x02	; 2
     922:	e5 df       	rcall	.-54     	; 0x8ee <_ZN14LoginInterface10checkLoginEv>
     924:	fc cf       	rjmp	.-8      	; 0x91e <_Z11LoginKeyPadPv>

00000926 <_Z10DisplayArmPv>:
     926:	cf 93       	push	r28
     928:	df 93       	push	r29
     92a:	cd b7       	in	r28, 0x3d	; 61
     92c:	de b7       	in	r29, 0x3e	; 62
     92e:	c1 57       	subi	r28, 0x71	; 113
     930:	d1 09       	sbc	r29, r1
     932:	0f b6       	in	r0, 0x3f	; 63
     934:	f8 94       	cli
     936:	de bf       	out	0x3e, r29	; 62
     938:	0f be       	out	0x3f, r0	; 63
     93a:	cd bf       	out	0x3d, r28	; 61
     93c:	8c 01       	movw	r16, r24
     93e:	62 e0       	ldi	r22, 0x02	; 2
     940:	ce 01       	movw	r24, r28
     942:	01 96       	adiw	r24, 0x01	; 1
     944:	c6 dd       	rcall	.-1140   	; 0x4d2 <_ZN11ColorSensorC1E16FrequencyScaling>
     946:	ce 01       	movw	r24, r28
     948:	84 5a       	subi	r24, 0xA4	; 164
     94a:	9f 4f       	sbci	r25, 0xFF	; 255
     94c:	0e 94 ca 12 	call	0x2594	; 0x2594 <_ZN11TouchscreenC1Ev>
     950:	ce 01       	movw	r24, r28
     952:	84 5a       	subi	r24, 0xA4	; 164
     954:	9f 4f       	sbci	r25, 0xFF	; 255
     956:	0e 94 d1 13 	call	0x27a2	; 0x27a2 <_ZN11Touchscreen11clearScreenEv>
     95a:	89 ed       	ldi	r24, 0xD9	; 217
     95c:	92 e0       	ldi	r25, 0x02	; 2
     95e:	c4 df       	rcall	.-120    	; 0x8e8 <_ZN14LoginInterface17getstateOfMachineEv>
     960:	85 35       	cpi	r24, 0x55	; 85
     962:	b1 f7       	brne	.-20     	; 0x950 <_Z10DisplayArmPv+0x2a>
     964:	ce 01       	movw	r24, r28
     966:	84 5a       	subi	r24, 0xA4	; 164
     968:	9f 4f       	sbci	r25, 0xFF	; 255
     96a:	0e 94 e6 13 	call	0x27cc	; 0x27cc <_ZN11Touchscreen23presentButtonsOnDisplayEv>
     96e:	ce 01       	movw	r24, r28
     970:	84 5a       	subi	r24, 0xA4	; 164
     972:	9f 4f       	sbci	r25, 0xFF	; 255
     974:	0e 94 37 13 	call	0x266e	; 0x266e <_ZN11Touchscreen12checkButtonsEv>
     978:	81 30       	cpi	r24, 0x01	; 1
     97a:	19 f0       	breq	.+6      	; 0x982 <_Z10DisplayArmPv+0x5c>
     97c:	82 30       	cpi	r24, 0x02	; 2
     97e:	81 f0       	breq	.+32     	; 0x9a0 <_Z10DisplayArmPv+0x7a>
     980:	ec cf       	rjmp	.-40     	; 0x95a <_Z10DisplayArmPv+0x34>
     982:	8d e1       	ldi	r24, 0x1D	; 29
     984:	92 e0       	ldi	r25, 0x02	; 2
     986:	0e 94 36 15 	call	0x2a6c	; 0x2a6c <_Z10SendStringPc>
     98a:	60 91 d8 02 	lds	r22, 0x02D8	; 0x8002d8 <colorIndex>
     98e:	ce 01       	movw	r24, r28
     990:	01 96       	adiw	r24, 0x01	; 1
     992:	36 dd       	rcall	.-1428   	; 0x400 <_ZN11ColorSensor17addCalibrateColorEh>
     994:	80 91 d8 02 	lds	r24, 0x02D8	; 0x8002d8 <colorIndex>
     998:	8f 5f       	subi	r24, 0xFF	; 255
     99a:	80 93 d8 02 	sts	0x02D8, r24	; 0x8002d8 <colorIndex>
     99e:	dd cf       	rjmp	.-70     	; 0x95a <_Z10DisplayArmPv+0x34>
     9a0:	8c e2       	ldi	r24, 0x2C	; 44
     9a2:	92 e0       	ldi	r25, 0x02	; 2
     9a4:	0e 94 36 15 	call	0x2a6c	; 0x2a6c <_Z10SendStringPc>
     9a8:	ce 01       	movw	r24, r28
     9aa:	01 96       	adiw	r24, 0x01	; 1
     9ac:	92 dc       	rcall	.-1756   	; 0x2d2 <_ZN11ColorSensor8getColorEv>
     9ae:	68 2f       	mov	r22, r24
     9b0:	c8 01       	movw	r24, r16
     9b2:	01 d2       	rcall	.+1026   	; 0xdb6 <_ZN8Robotarm8MoveItemEh>
     9b4:	d2 cf       	rjmp	.-92     	; 0x95a <_Z10DisplayArmPv+0x34>

000009b6 <_Z41__static_initialization_and_destruction_0ii>:
     9b6:	0f 93       	push	r16
     9b8:	1f 93       	push	r17
     9ba:	cf 93       	push	r28
     9bc:	df 93       	push	r29
     9be:	ec 01       	movw	r28, r24
     9c0:	8b 01       	movw	r16, r22
     9c2:	01 97       	sbiw	r24, 0x01	; 1
     9c4:	31 f4       	brne	.+12     	; 0x9d2 <_Z41__static_initialization_and_destruction_0ii+0x1c>
     9c6:	6f 3f       	cpi	r22, 0xFF	; 255
     9c8:	7f 4f       	sbci	r23, 0xFF	; 255
     9ca:	19 f4       	brne	.+6      	; 0x9d2 <_Z41__static_initialization_and_destruction_0ii+0x1c>
     9cc:	89 ed       	ldi	r24, 0xD9	; 217
     9ce:	92 e0       	ldi	r25, 0x02	; 2
     9d0:	69 df       	rcall	.-302    	; 0x8a4 <_ZN14LoginInterfaceC1Ev>
     9d2:	cd 2b       	or	r28, r29
     9d4:	31 f4       	brne	.+12     	; 0x9e2 <_Z41__static_initialization_and_destruction_0ii+0x2c>
     9d6:	0f 3f       	cpi	r16, 0xFF	; 255
     9d8:	1f 4f       	sbci	r17, 0xFF	; 255
     9da:	19 f4       	brne	.+6      	; 0x9e2 <_Z41__static_initialization_and_destruction_0ii+0x2c>
     9dc:	89 ed       	ldi	r24, 0xD9	; 217
     9de:	92 e0       	ldi	r25, 0x02	; 2
     9e0:	81 df       	rcall	.-254    	; 0x8e4 <_ZN14LoginInterfaceD1Ev>
     9e2:	df 91       	pop	r29
     9e4:	cf 91       	pop	r28
     9e6:	1f 91       	pop	r17
     9e8:	0f 91       	pop	r16
     9ea:	08 95       	ret

000009ec <__cxa_pure_virtual>:
     9ec:	ff cf       	rjmp	.-2      	; 0x9ec <__cxa_pure_virtual>

000009ee <_Znwj>:

void * operator new(size_t size)
{
	return malloc(size);
     9ee:	0c 94 ac 17 	jmp	0x2f58	; 0x2f58 <malloc>
}
     9f2:	08 95       	ret

000009f4 <_ZdlPv>:

void operator delete(void * ptr)
{
	ptr != NULL ? free(ptr) : void(0);
     9f4:	00 97       	sbiw	r24, 0x00	; 0
     9f6:	11 f0       	breq	.+4      	; 0x9fc <_ZdlPv+0x8>
     9f8:	0c 94 44 18 	jmp	0x3088	; 0x3088 <free>
     9fc:	08 95       	ret

000009fe <main>:
		}
	}
}

int main(void)
{		
     9fe:	cf 93       	push	r28
     a00:	df 93       	push	r29
     a02:	cd b7       	in	r28, 0x3d	; 61
     a04:	de b7       	in	r29, 0x3e	; 62
     a06:	2e 97       	sbiw	r28, 0x0e	; 14
     a08:	0f b6       	in	r0, 0x3f	; 63
     a0a:	f8 94       	cli
     a0c:	de bf       	out	0x3e, r29	; 62
     a0e:	0f be       	out	0x3f, r0	; 63
     a10:	cd bf       	out	0x3d, r28	; 61
	Robotarm arm = Robotarm();
     a12:	ce 01       	movw	r24, r28
     a14:	01 96       	adiw	r24, 0x01	; 1
     a16:	49 d0       	rcall	.+146    	; 0xaaa <_ZN8RobotarmC1Ev>
	InitUART(9600,8,'N');
     a18:	2e e4       	ldi	r18, 0x4E	; 78
     a1a:	48 e0       	ldi	r20, 0x08	; 8
     a1c:	60 e8       	ldi	r22, 0x80	; 128
     a1e:	75 e2       	ldi	r23, 0x25	; 37
     a20:	80 e0       	ldi	r24, 0x00	; 0
     a22:	90 e0       	ldi	r25, 0x00	; 0
     a24:	0e 94 e2 14 	call	0x29c4	; 0x29c4 <_Z8InitUARTmhc>
	xTaskCreate(LoginKeyPad,  ( signed char * ) "Keypad Task", configMAIN_STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL);
     a28:	a1 2c       	mov	r10, r1
     a2a:	b1 2c       	mov	r11, r1
     a2c:	c1 2c       	mov	r12, r1
     a2e:	d1 2c       	mov	r13, r1
     a30:	e1 2c       	mov	r14, r1
     a32:	f1 2c       	mov	r15, r1
     a34:	00 e0       	ldi	r16, 0x00	; 0
     a36:	20 e0       	ldi	r18, 0x00	; 0
     a38:	30 e0       	ldi	r19, 0x00	; 0
     a3a:	48 e5       	ldi	r20, 0x58	; 88
     a3c:	52 e0       	ldi	r21, 0x02	; 2
     a3e:	6c e3       	ldi	r22, 0x3C	; 60
     a40:	72 e0       	ldi	r23, 0x02	; 2
     a42:	8f e8       	ldi	r24, 0x8F	; 143
     a44:	94 e0       	ldi	r25, 0x04	; 4
     a46:	0e 94 5a 0f 	call	0x1eb4	; 0x1eb4 <xTaskGenericCreate>
	xTaskCreate(DisplayArm,  ( signed char * ) "Display + Arm Task", configMAIN_STACK_SIZE, &arm, tskIDLE_PRIORITY, NULL);
     a4a:	9e 01       	movw	r18, r28
     a4c:	2f 5f       	subi	r18, 0xFF	; 255
     a4e:	3f 4f       	sbci	r19, 0xFF	; 255
     a50:	48 e5       	ldi	r20, 0x58	; 88
     a52:	52 e0       	ldi	r21, 0x02	; 2
     a54:	68 e4       	ldi	r22, 0x48	; 72
     a56:	72 e0       	ldi	r23, 0x02	; 2
     a58:	83 e9       	ldi	r24, 0x93	; 147
     a5a:	94 e0       	ldi	r25, 0x04	; 4
     a5c:	0e 94 5a 0f 	call	0x1eb4	; 0x1eb4 <xTaskGenericCreate>
	vTaskStartScheduler();
     a60:	0e 94 12 10 	call	0x2024	; 0x2024 <vTaskStartScheduler>
     a64:	ff cf       	rjmp	.-2      	; 0xa64 <main+0x66>

00000a66 <_GLOBAL__sub_I___cxa_pure_virtual>:

	while (1)
	{
	}
     a66:	6f ef       	ldi	r22, 0xFF	; 255
     a68:	7f ef       	ldi	r23, 0xFF	; 255
     a6a:	81 e0       	ldi	r24, 0x01	; 1
     a6c:	90 e0       	ldi	r25, 0x00	; 0
     a6e:	a3 cf       	rjmp	.-186    	; 0x9b6 <_Z41__static_initialization_and_destruction_0ii>
     a70:	08 95       	ret

00000a72 <_GLOBAL__sub_D___cxa_pure_virtual>:
     a72:	6f ef       	ldi	r22, 0xFF	; 255
     a74:	7f ef       	ldi	r23, 0xFF	; 255
     a76:	80 e0       	ldi	r24, 0x00	; 0
     a78:	90 e0       	ldi	r25, 0x00	; 0
     a7a:	9d cf       	rjmp	.-198    	; 0x9b6 <_Z41__static_initialization_and_destruction_0ii>
     a7c:	08 95       	ret

00000a7e <_ZN8Robotarm14startMotorImplEPv>:
	motors_[3]->SetDegrees(90);
	vTaskDelay( 250 / portTICK_RATE_MS );
}

void Robotarm::startMotorImpl( void *_this )
{
     a7e:	8c 01       	movw	r16, r24
void Robotarm::MotorSpeedController()
{
	while(1)
	{
		/* Move all motors one step. */
		for ( uint8_t i = 0U; i < 6U; i++ )
     a80:	c0 e0       	ldi	r28, 0x00	; 0
     a82:	c6 30       	cpi	r28, 0x06	; 6
     a84:	e8 f7       	brcc	.-6      	; 0xa80 <_ZN8Robotarm14startMotorImplEPv+0x2>
		{
			motors_[i]->TurnMotor();
     a86:	ec 2f       	mov	r30, r28
     a88:	f0 e0       	ldi	r31, 0x00	; 0
     a8a:	31 96       	adiw	r30, 0x01	; 1
     a8c:	ee 0f       	add	r30, r30
     a8e:	ff 1f       	adc	r31, r31
     a90:	e0 0f       	add	r30, r16
     a92:	f1 1f       	adc	r31, r17
     a94:	80 81       	ld	r24, Z
     a96:	91 81       	ldd	r25, Z+1	; 0x01
     a98:	dc 01       	movw	r26, r24
     a9a:	ed 91       	ld	r30, X+
     a9c:	fc 91       	ld	r31, X
     a9e:	04 80       	ldd	r0, Z+4	; 0x04
     aa0:	f5 81       	ldd	r31, Z+5	; 0x05
     aa2:	e0 2d       	mov	r30, r0
     aa4:	19 95       	eicall
void Robotarm::MotorSpeedController()
{
	while(1)
	{
		/* Move all motors one step. */
		for ( uint8_t i = 0U; i < 6U; i++ )
     aa6:	cf 5f       	subi	r28, 0xFF	; 255
     aa8:	ec cf       	rjmp	.-40     	; 0xa82 <_ZN8Robotarm14startMotorImplEPv+0x4>

00000aaa <_ZN8RobotarmC1Ev>:
/* RTOS include */
#include "FreeRTOS.h"
#include "task.h"
#include "portmacro.h"

Robotarm::Robotarm() : tmr1_(), tmr3_()
     aaa:	af 92       	push	r10
     aac:	bf 92       	push	r11
     aae:	cf 92       	push	r12
     ab0:	df 92       	push	r13
     ab2:	ef 92       	push	r14
     ab4:	ff 92       	push	r15
     ab6:	0f 93       	push	r16
     ab8:	1f 93       	push	r17
     aba:	cf 93       	push	r28
     abc:	df 93       	push	r29
     abe:	ec 01       	movw	r28, r24
     ac0:	d5 d5       	rcall	.+2986   	; 0x166c <_ZN6Timer1C1Ev>
     ac2:	8e 01       	movw	r16, r28
     ac4:	0f 5f       	subi	r16, 0xFF	; 255
     ac6:	1f 4f       	sbci	r17, 0xFF	; 255
     ac8:	c8 01       	movw	r24, r16
     aca:	75 d6       	rcall	.+3306   	; 0x17b6 <_ZN6Timer5C1Ev>
{
	/* Create all motor objects */
	motors_[0] = new M1( &tmr1_ );
     acc:	89 e1       	ldi	r24, 0x19	; 25
     ace:	90 e0       	ldi	r25, 0x00	; 0
     ad0:	8e df       	rcall	.-228    	; 0x9ee <_Znwj>
     ad2:	7c 01       	movw	r14, r24
     ad4:	be 01       	movw	r22, r28
     ad6:	66 d2       	rcall	.+1228   	; 0xfa4 <_ZN2M1C1EP6Timer1>
     ad8:	fb 82       	std	Y+3, r15	; 0x03
     ada:	ea 82       	std	Y+2, r14	; 0x02
	motors_[1] = new M2( &tmr1_ );
     adc:	89 e1       	ldi	r24, 0x19	; 25
     ade:	90 e0       	ldi	r25, 0x00	; 0
     ae0:	86 df       	rcall	.-244    	; 0x9ee <_Znwj>
     ae2:	7c 01       	movw	r14, r24
     ae4:	be 01       	movw	r22, r28
     ae6:	04 d3       	rcall	.+1544   	; 0x10f0 <_ZN2M2C1EP6Timer1>
     ae8:	fd 82       	std	Y+5, r15	; 0x05
     aea:	ec 82       	std	Y+4, r14	; 0x04
	motors_[2] = new M3( &tmr1_ );
     aec:	89 e1       	ldi	r24, 0x19	; 25
     aee:	90 e0       	ldi	r25, 0x00	; 0
     af0:	7e df       	rcall	.-260    	; 0x9ee <_Znwj>
     af2:	7c 01       	movw	r14, r24
     af4:	be 01       	movw	r22, r28
     af6:	a2 d3       	rcall	.+1860   	; 0x123c <_ZN2M3C1EP6Timer1>
     af8:	ff 82       	std	Y+7, r15	; 0x07
     afa:	ee 82       	std	Y+6, r14	; 0x06
	motors_[3] = new M4( &tmr3_ );
     afc:	89 e1       	ldi	r24, 0x19	; 25
     afe:	90 e0       	ldi	r25, 0x00	; 0
     b00:	76 df       	rcall	.-276    	; 0x9ee <_Znwj>
     b02:	7c 01       	movw	r14, r24
     b04:	b8 01       	movw	r22, r16
     b06:	3e d4       	rcall	.+2172   	; 0x1384 <_ZN2M4C1EP6Timer5>
     b08:	f9 86       	std	Y+9, r15	; 0x09
     b0a:	e8 86       	std	Y+8, r14	; 0x08
	motors_[4] = new M5( &tmr3_ );
     b0c:	89 e1       	ldi	r24, 0x19	; 25
     b0e:	90 e0       	ldi	r25, 0x00	; 0
     b10:	6e df       	rcall	.-292    	; 0x9ee <_Znwj>
     b12:	7c 01       	movw	r14, r24
     b14:	b8 01       	movw	r22, r16
     b16:	da d4       	rcall	.+2484   	; 0x14cc <_ZN2M5C1EP6Timer5>
     b18:	fb 86       	std	Y+11, r15	; 0x0b
     b1a:	ea 86       	std	Y+10, r14	; 0x0a
	motors_[5] = new M6( &tmr3_ );
     b1c:	89 e1       	ldi	r24, 0x19	; 25
     b1e:	90 e0       	ldi	r25, 0x00	; 0
     b20:	66 df       	rcall	.-308    	; 0x9ee <_Znwj>
     b22:	7c 01       	movw	r14, r24
     b24:	b8 01       	movw	r22, r16
     b26:	72 d5       	rcall	.+2788   	; 0x160c <_ZN2M6C1EP6Timer5>
     b28:	fd 86       	std	Y+13, r15	; 0x0d
     b2a:	ec 86       	std	Y+12, r14	; 0x0c
     b2c:	a1 2c       	mov	r10, r1
     b2e:	b1 2c       	mov	r11, r1
	
	/* Create task to control motors */
	xTaskCreate(this->startMotorImpl,  ( signed char * ) "Motors", configMAIN_STACK_SIZE, this, tskIDLE_PRIORITY, NULL);
     b30:	c1 2c       	mov	r12, r1
     b32:	d1 2c       	mov	r13, r1
     b34:	e1 2c       	mov	r14, r1
     b36:	f1 2c       	mov	r15, r1
     b38:	00 e0       	ldi	r16, 0x00	; 0
     b3a:	9e 01       	movw	r18, r28
     b3c:	48 e5       	ldi	r20, 0x58	; 88
     b3e:	52 e0       	ldi	r21, 0x02	; 2
     b40:	6b e5       	ldi	r22, 0x5B	; 91
     b42:	72 e0       	ldi	r23, 0x02	; 2
     b44:	8f e3       	ldi	r24, 0x3F	; 63
     b46:	95 e0       	ldi	r25, 0x05	; 5
     b48:	0e 94 5a 0f 	call	0x1eb4	; 0x1eb4 <xTaskGenericCreate>
     b4c:	df 91       	pop	r29
     b4e:	cf 91       	pop	r28
}
     b50:	1f 91       	pop	r17
     b52:	0f 91       	pop	r16
     b54:	ff 90       	pop	r15
     b56:	ef 90       	pop	r14
     b58:	df 90       	pop	r13
     b5a:	cf 90       	pop	r12
     b5c:	bf 90       	pop	r11
     b5e:	af 90       	pop	r10
     b60:	08 95       	ret

00000b62 <_ZN8Robotarm9grabBlockEv>:
     b62:	cf 93       	push	r28
     b64:	df 93       	push	r29
		break;
	}
}

void Robotarm::grabBlock()
{
     b66:	ec 01       	movw	r28, r24
	motors_[3]->SetDegrees(40);
     b68:	88 85       	ldd	r24, Y+8	; 0x08
     b6a:	99 85       	ldd	r25, Y+9	; 0x09
     b6c:	dc 01       	movw	r26, r24
     b6e:	ed 91       	ld	r30, X+
     b70:	fc 91       	ld	r31, X
     b72:	06 80       	ldd	r0, Z+6	; 0x06
     b74:	f7 81       	ldd	r31, Z+7	; 0x07
     b76:	e0 2d       	mov	r30, r0
     b78:	68 e2       	ldi	r22, 0x28	; 40
     b7a:	19 95       	eicall
	motors_[4]->SetDegrees(90);
     b7c:	8a 85       	ldd	r24, Y+10	; 0x0a
     b7e:	9b 85       	ldd	r25, Y+11	; 0x0b
     b80:	dc 01       	movw	r26, r24
     b82:	ed 91       	ld	r30, X+
     b84:	fc 91       	ld	r31, X
     b86:	06 80       	ldd	r0, Z+6	; 0x06
     b88:	f7 81       	ldd	r31, Z+7	; 0x07
     b8a:	e0 2d       	mov	r30, r0
     b8c:	6a e5       	ldi	r22, 0x5A	; 90
     b8e:	19 95       	eicall
	motors_[0]->SetDegrees(0);
     b90:	8a 81       	ldd	r24, Y+2	; 0x02
     b92:	9b 81       	ldd	r25, Y+3	; 0x03
     b94:	dc 01       	movw	r26, r24
     b96:	ed 91       	ld	r30, X+
     b98:	fc 91       	ld	r31, X
     b9a:	06 80       	ldd	r0, Z+6	; 0x06
     b9c:	f7 81       	ldd	r31, Z+7	; 0x07
     b9e:	e0 2d       	mov	r30, r0
     ba0:	60 e0       	ldi	r22, 0x00	; 0
     ba2:	19 95       	eicall
	vTaskDelay( 1500 / portTICK_RATE_MS );
     ba4:	8c ed       	ldi	r24, 0xDC	; 220
     ba6:	95 e0       	ldi	r25, 0x05	; 5
     ba8:	0e 94 59 11 	call	0x22b2	; 0x22b2 <vTaskDelay>
	motors_[1]->SetDegrees(35);
     bac:	8c 81       	ldd	r24, Y+4	; 0x04
     bae:	9d 81       	ldd	r25, Y+5	; 0x05
     bb0:	dc 01       	movw	r26, r24
     bb2:	ed 91       	ld	r30, X+
     bb4:	fc 91       	ld	r31, X
     bb6:	06 80       	ldd	r0, Z+6	; 0x06
     bb8:	f7 81       	ldd	r31, Z+7	; 0x07
     bba:	e0 2d       	mov	r30, r0
     bbc:	63 e2       	ldi	r22, 0x23	; 35
     bbe:	19 95       	eicall
	motors_[2]->SetDegrees(63);
     bc0:	8e 81       	ldd	r24, Y+6	; 0x06
     bc2:	9f 81       	ldd	r25, Y+7	; 0x07
     bc4:	dc 01       	movw	r26, r24
     bc6:	ed 91       	ld	r30, X+
     bc8:	fc 91       	ld	r31, X
     bca:	06 80       	ldd	r0, Z+6	; 0x06
     bcc:	f7 81       	ldd	r31, Z+7	; 0x07
     bce:	e0 2d       	mov	r30, r0
     bd0:	6f e3       	ldi	r22, 0x3F	; 63
     bd2:	19 95       	eicall
	vTaskDelay( 1500 / portTICK_RATE_MS );
     bd4:	8c ed       	ldi	r24, 0xDC	; 220
     bd6:	95 e0       	ldi	r25, 0x05	; 5
     bd8:	0e 94 59 11 	call	0x22b2	; 0x22b2 <vTaskDelay>
	motors_[5]->SetDegrees(63);
     bdc:	8c 85       	ldd	r24, Y+12	; 0x0c
     bde:	9d 85       	ldd	r25, Y+13	; 0x0d
     be0:	dc 01       	movw	r26, r24
     be2:	ed 91       	ld	r30, X+
     be4:	fc 91       	ld	r31, X
     be6:	06 80       	ldd	r0, Z+6	; 0x06
     be8:	f7 81       	ldd	r31, Z+7	; 0x07
     bea:	e0 2d       	mov	r30, r0
     bec:	6f e3       	ldi	r22, 0x3F	; 63
     bee:	19 95       	eicall
	vTaskDelay( 250 / portTICK_RATE_MS );
     bf0:	8a ef       	ldi	r24, 0xFA	; 250
     bf2:	90 e0       	ldi	r25, 0x00	; 0
     bf4:	0e 94 59 11 	call	0x22b2	; 0x22b2 <vTaskDelay>
	motors_[1]->SetDegrees(70);
     bf8:	8c 81       	ldd	r24, Y+4	; 0x04
     bfa:	9d 81       	ldd	r25, Y+5	; 0x05
     bfc:	dc 01       	movw	r26, r24
     bfe:	ed 91       	ld	r30, X+
     c00:	fc 91       	ld	r31, X
     c02:	06 80       	ldd	r0, Z+6	; 0x06
     c04:	f7 81       	ldd	r31, Z+7	; 0x07
     c06:	e0 2d       	mov	r30, r0
     c08:	66 e4       	ldi	r22, 0x46	; 70
     c0a:	19 95       	eicall
	motors_[2]->SetDegrees(70);
     c0c:	8e 81       	ldd	r24, Y+6	; 0x06
     c0e:	9f 81       	ldd	r25, Y+7	; 0x07
     c10:	dc 01       	movw	r26, r24
     c12:	ed 91       	ld	r30, X+
     c14:	fc 91       	ld	r31, X
     c16:	06 80       	ldd	r0, Z+6	; 0x06
     c18:	f7 81       	ldd	r31, Z+7	; 0x07
     c1a:	e0 2d       	mov	r30, r0
     c1c:	66 e4       	ldi	r22, 0x46	; 70
     c1e:	19 95       	eicall
	motors_[3]->SetDegrees(70);
     c20:	88 85       	ldd	r24, Y+8	; 0x08
     c22:	99 85       	ldd	r25, Y+9	; 0x09
     c24:	dc 01       	movw	r26, r24
     c26:	ed 91       	ld	r30, X+
     c28:	fc 91       	ld	r31, X
     c2a:	06 80       	ldd	r0, Z+6	; 0x06
     c2c:	f7 81       	ldd	r31, Z+7	; 0x07
     c2e:	e0 2d       	mov	r30, r0
     c30:	66 e4       	ldi	r22, 0x46	; 70
     c32:	19 95       	eicall
}
     c34:	df 91       	pop	r29
     c36:	cf 91       	pop	r28
     c38:	08 95       	ret

00000c3a <_ZN8Robotarm18ArmDownReleaseItemEv>:
	motors_[0]->SetDegrees(180);
	ArmDownReleaseItem();
}

void Robotarm::ArmDownReleaseItem()
{
     c3a:	cf 93       	push	r28
     c3c:	df 93       	push	r29
     c3e:	ec 01       	movw	r28, r24
	vTaskDelay( 1500 / portTICK_RATE_MS );
     c40:	8c ed       	ldi	r24, 0xDC	; 220
     c42:	95 e0       	ldi	r25, 0x05	; 5
     c44:	0e 94 59 11 	call	0x22b2	; 0x22b2 <vTaskDelay>
	motors_[1]->SetDegrees(35);
     c48:	8c 81       	ldd	r24, Y+4	; 0x04
     c4a:	9d 81       	ldd	r25, Y+5	; 0x05
     c4c:	dc 01       	movw	r26, r24
     c4e:	ed 91       	ld	r30, X+
     c50:	fc 91       	ld	r31, X
     c52:	06 80       	ldd	r0, Z+6	; 0x06
     c54:	f7 81       	ldd	r31, Z+7	; 0x07
     c56:	e0 2d       	mov	r30, r0
     c58:	63 e2       	ldi	r22, 0x23	; 35
     c5a:	19 95       	eicall
	motors_[2]->SetDegrees(40);
     c5c:	8e 81       	ldd	r24, Y+6	; 0x06
     c5e:	9f 81       	ldd	r25, Y+7	; 0x07
     c60:	dc 01       	movw	r26, r24
     c62:	ed 91       	ld	r30, X+
     c64:	fc 91       	ld	r31, X
     c66:	06 80       	ldd	r0, Z+6	; 0x06
     c68:	f7 81       	ldd	r31, Z+7	; 0x07
     c6a:	e0 2d       	mov	r30, r0
     c6c:	68 e2       	ldi	r22, 0x28	; 40
     c6e:	19 95       	eicall
	vTaskDelay( 1500 / portTICK_RATE_MS );
     c70:	8c ed       	ldi	r24, 0xDC	; 220
     c72:	95 e0       	ldi	r25, 0x05	; 5
     c74:	0e 94 59 11 	call	0x22b2	; 0x22b2 <vTaskDelay>
	motors_[5]->SetDegrees(0);
     c78:	8c 85       	ldd	r24, Y+12	; 0x0c
     c7a:	9d 85       	ldd	r25, Y+13	; 0x0d
     c7c:	dc 01       	movw	r26, r24
     c7e:	ed 91       	ld	r30, X+
     c80:	fc 91       	ld	r31, X
     c82:	06 80       	ldd	r0, Z+6	; 0x06
     c84:	f7 81       	ldd	r31, Z+7	; 0x07
     c86:	e0 2d       	mov	r30, r0
     c88:	60 e0       	ldi	r22, 0x00	; 0
     c8a:	19 95       	eicall
	vTaskDelay( 250 / portTICK_RATE_MS );
     c8c:	8a ef       	ldi	r24, 0xFA	; 250
     c8e:	90 e0       	ldi	r25, 0x00	; 0
     c90:	0e 94 59 11 	call	0x22b2	; 0x22b2 <vTaskDelay>
	motors_[1]->SetDegrees(90);
     c94:	8c 81       	ldd	r24, Y+4	; 0x04
     c96:	9d 81       	ldd	r25, Y+5	; 0x05
     c98:	dc 01       	movw	r26, r24
     c9a:	ed 91       	ld	r30, X+
     c9c:	fc 91       	ld	r31, X
     c9e:	06 80       	ldd	r0, Z+6	; 0x06
     ca0:	f7 81       	ldd	r31, Z+7	; 0x07
     ca2:	e0 2d       	mov	r30, r0
     ca4:	6a e5       	ldi	r22, 0x5A	; 90
     ca6:	19 95       	eicall
	motors_[2]->SetDegrees(90);
     ca8:	8e 81       	ldd	r24, Y+6	; 0x06
     caa:	9f 81       	ldd	r25, Y+7	; 0x07
     cac:	dc 01       	movw	r26, r24
     cae:	ed 91       	ld	r30, X+
     cb0:	fc 91       	ld	r31, X
     cb2:	06 80       	ldd	r0, Z+6	; 0x06
     cb4:	f7 81       	ldd	r31, Z+7	; 0x07
     cb6:	e0 2d       	mov	r30, r0
     cb8:	6a e5       	ldi	r22, 0x5A	; 90
     cba:	19 95       	eicall
	motors_[3]->SetDegrees(90);
     cbc:	88 85       	ldd	r24, Y+8	; 0x08
     cbe:	99 85       	ldd	r25, Y+9	; 0x09
     cc0:	dc 01       	movw	r26, r24
     cc2:	ed 91       	ld	r30, X+
     cc4:	fc 91       	ld	r31, X
     cc6:	06 80       	ldd	r0, Z+6	; 0x06
     cc8:	f7 81       	ldd	r31, Z+7	; 0x07
     cca:	e0 2d       	mov	r30, r0
     ccc:	6a e5       	ldi	r22, 0x5A	; 90
     cce:	19 95       	eicall
	vTaskDelay( 250 / portTICK_RATE_MS );
     cd0:	8a ef       	ldi	r24, 0xFA	; 250
     cd2:	90 e0       	ldi	r25, 0x00	; 0
     cd4:	0e 94 59 11 	call	0x22b2	; 0x22b2 <vTaskDelay>
}
     cd8:	df 91       	pop	r29
     cda:	cf 91       	pop	r28
     cdc:	08 95       	ret

00000cde <_ZN8Robotarm18moveBlockToZoneOneEv>:
	motors_[2]->SetDegrees(70);
	motors_[3]->SetDegrees(70);
}

void Robotarm::moveBlockToZoneOne()
{
     cde:	cf 93       	push	r28
     ce0:	df 93       	push	r29
     ce2:	ec 01       	movw	r28, r24
	motors_[0]->SetDegrees(40);
     ce4:	8a 81       	ldd	r24, Y+2	; 0x02
     ce6:	9b 81       	ldd	r25, Y+3	; 0x03
     ce8:	dc 01       	movw	r26, r24
     cea:	ed 91       	ld	r30, X+
     cec:	fc 91       	ld	r31, X
     cee:	06 80       	ldd	r0, Z+6	; 0x06
     cf0:	f7 81       	ldd	r31, Z+7	; 0x07
     cf2:	e0 2d       	mov	r30, r0
     cf4:	68 e2       	ldi	r22, 0x28	; 40
     cf6:	19 95       	eicall
	ArmDownReleaseItem();
     cf8:	ce 01       	movw	r24, r28
     cfa:	9f df       	rcall	.-194    	; 0xc3a <_ZN8Robotarm18ArmDownReleaseItemEv>
}
     cfc:	df 91       	pop	r29
     cfe:	cf 91       	pop	r28
     d00:	08 95       	ret

00000d02 <_ZN8Robotarm18moveBlockToZoneTwoEv>:

void Robotarm::moveBlockToZoneTwo()
{
     d02:	cf 93       	push	r28
     d04:	df 93       	push	r29
     d06:	ec 01       	movw	r28, r24
	motors_[0]->SetDegrees(68);
     d08:	8a 81       	ldd	r24, Y+2	; 0x02
     d0a:	9b 81       	ldd	r25, Y+3	; 0x03
     d0c:	dc 01       	movw	r26, r24
     d0e:	ed 91       	ld	r30, X+
     d10:	fc 91       	ld	r31, X
     d12:	06 80       	ldd	r0, Z+6	; 0x06
     d14:	f7 81       	ldd	r31, Z+7	; 0x07
     d16:	e0 2d       	mov	r30, r0
     d18:	64 e4       	ldi	r22, 0x44	; 68
     d1a:	19 95       	eicall
	ArmDownReleaseItem();
     d1c:	ce 01       	movw	r24, r28
     d1e:	8d df       	rcall	.-230    	; 0xc3a <_ZN8Robotarm18ArmDownReleaseItemEv>
}
     d20:	df 91       	pop	r29
     d22:	cf 91       	pop	r28
     d24:	08 95       	ret

00000d26 <_ZN8Robotarm20moveBlockToZoneThreeEv>:

void Robotarm::moveBlockToZoneThree()
{
     d26:	cf 93       	push	r28
     d28:	df 93       	push	r29
     d2a:	ec 01       	movw	r28, r24
	motors_[0]->SetDegrees(96);
     d2c:	8a 81       	ldd	r24, Y+2	; 0x02
     d2e:	9b 81       	ldd	r25, Y+3	; 0x03
     d30:	dc 01       	movw	r26, r24
     d32:	ed 91       	ld	r30, X+
     d34:	fc 91       	ld	r31, X
     d36:	06 80       	ldd	r0, Z+6	; 0x06
     d38:	f7 81       	ldd	r31, Z+7	; 0x07
     d3a:	e0 2d       	mov	r30, r0
     d3c:	60 e6       	ldi	r22, 0x60	; 96
     d3e:	19 95       	eicall
	ArmDownReleaseItem();
     d40:	ce 01       	movw	r24, r28
     d42:	7b df       	rcall	.-266    	; 0xc3a <_ZN8Robotarm18ArmDownReleaseItemEv>
}
     d44:	df 91       	pop	r29
     d46:	cf 91       	pop	r28
     d48:	08 95       	ret

00000d4a <_ZN8Robotarm19moveBlockToZoneFourEv>:

void Robotarm::moveBlockToZoneFour()
{
     d4a:	cf 93       	push	r28
     d4c:	df 93       	push	r29
     d4e:	ec 01       	movw	r28, r24
	motors_[0]->SetDegrees(124);
     d50:	8a 81       	ldd	r24, Y+2	; 0x02
     d52:	9b 81       	ldd	r25, Y+3	; 0x03
     d54:	dc 01       	movw	r26, r24
     d56:	ed 91       	ld	r30, X+
     d58:	fc 91       	ld	r31, X
     d5a:	06 80       	ldd	r0, Z+6	; 0x06
     d5c:	f7 81       	ldd	r31, Z+7	; 0x07
     d5e:	e0 2d       	mov	r30, r0
     d60:	6c e7       	ldi	r22, 0x7C	; 124
     d62:	19 95       	eicall
	ArmDownReleaseItem();
     d64:	ce 01       	movw	r24, r28
     d66:	69 df       	rcall	.-302    	; 0xc3a <_ZN8Robotarm18ArmDownReleaseItemEv>
}
     d68:	df 91       	pop	r29
     d6a:	cf 91       	pop	r28
     d6c:	08 95       	ret

00000d6e <_ZN8Robotarm19moveBlockToZoneFiveEv>:

void Robotarm::moveBlockToZoneFive()
{
     d6e:	cf 93       	push	r28
     d70:	df 93       	push	r29
     d72:	ec 01       	movw	r28, r24
	motors_[0]->SetDegrees(152);
     d74:	8a 81       	ldd	r24, Y+2	; 0x02
     d76:	9b 81       	ldd	r25, Y+3	; 0x03
     d78:	dc 01       	movw	r26, r24
     d7a:	ed 91       	ld	r30, X+
     d7c:	fc 91       	ld	r31, X
     d7e:	06 80       	ldd	r0, Z+6	; 0x06
     d80:	f7 81       	ldd	r31, Z+7	; 0x07
     d82:	e0 2d       	mov	r30, r0
     d84:	68 e9       	ldi	r22, 0x98	; 152
     d86:	19 95       	eicall
	ArmDownReleaseItem();
     d88:	ce 01       	movw	r24, r28
     d8a:	57 df       	rcall	.-338    	; 0xc3a <_ZN8Robotarm18ArmDownReleaseItemEv>
}
     d8c:	df 91       	pop	r29
     d8e:	cf 91       	pop	r28
     d90:	08 95       	ret

00000d92 <_ZN8Robotarm18moveBlockToZoneSixEv>:

void Robotarm::moveBlockToZoneSix()
{
     d92:	cf 93       	push	r28
     d94:	df 93       	push	r29
     d96:	ec 01       	movw	r28, r24
	motors_[0]->SetDegrees(180);
     d98:	8a 81       	ldd	r24, Y+2	; 0x02
     d9a:	9b 81       	ldd	r25, Y+3	; 0x03
     d9c:	dc 01       	movw	r26, r24
     d9e:	ed 91       	ld	r30, X+
     da0:	fc 91       	ld	r31, X
     da2:	06 80       	ldd	r0, Z+6	; 0x06
     da4:	f7 81       	ldd	r31, Z+7	; 0x07
     da6:	e0 2d       	mov	r30, r0
     da8:	64 eb       	ldi	r22, 0xB4	; 180
     daa:	19 95       	eicall
	ArmDownReleaseItem();
     dac:	ce 01       	movw	r24, r28
     dae:	45 df       	rcall	.-374    	; 0xc3a <_ZN8Robotarm18ArmDownReleaseItemEv>
}
     db0:	df 91       	pop	r29
     db2:	cf 91       	pop	r28
     db4:	08 95       	ret

00000db6 <_ZN8Robotarm8MoveItemEh>:
	/* Create task to control motors */
	xTaskCreate(this->startMotorImpl,  ( signed char * ) "Motors", configMAIN_STACK_SIZE, this, tskIDLE_PRIORITY, NULL);
}

void Robotarm::MoveItem( uint8_t color )
{
     db6:	cf 93       	push	r28
     db8:	df 93       	push	r29
     dba:	ec 01       	movw	r28, r24
	switch ( color )
     dbc:	62 30       	cpi	r22, 0x02	; 2
     dbe:	29 f1       	breq	.+74     	; 0xe0a <_ZN8Robotarm8MoveItemEh+0x54>
     dc0:	28 f4       	brcc	.+10     	; 0xdcc <_ZN8Robotarm8MoveItemEh+0x16>
     dc2:	66 23       	and	r22, r22
     dc4:	51 f0       	breq	.+20     	; 0xdda <_ZN8Robotarm8MoveItemEh+0x24>
     dc6:	61 30       	cpi	r22, 0x01	; 1
     dc8:	a1 f0       	breq	.+40     	; 0xdf2 <_ZN8Robotarm8MoveItemEh+0x3c>
     dca:	4e c0       	rjmp	.+156    	; 0xe68 <_ZN8Robotarm8MoveItemEh+0xb2>
     dcc:	64 30       	cpi	r22, 0x04	; 4
     dce:	a9 f1       	breq	.+106    	; 0xe3a <_ZN8Robotarm8MoveItemEh+0x84>
     dd0:	40 f1       	brcs	.+80     	; 0xe22 <_ZN8Robotarm8MoveItemEh+0x6c>
     dd2:	65 30       	cpi	r22, 0x05	; 5
     dd4:	09 f4       	brne	.+2      	; 0xdd8 <_ZN8Robotarm8MoveItemEh+0x22>
     dd6:	3d c0       	rjmp	.+122    	; 0xe52 <_ZN8Robotarm8MoveItemEh+0x9c>
     dd8:	47 c0       	rjmp	.+142    	; 0xe68 <_ZN8Robotarm8MoveItemEh+0xb2>
	{
		case 0U:
		grabBlock();
     dda:	c3 de       	rcall	.-634    	; 0xb62 <_ZN8Robotarm9grabBlockEv>
		vTaskDelay( 500 / portTICK_RATE_MS ); // This might not be needed!!! it can be added in Robotarm!!!! we will seeee later
     ddc:	84 ef       	ldi	r24, 0xF4	; 244
     dde:	91 e0       	ldi	r25, 0x01	; 1
     de0:	0e 94 59 11 	call	0x22b2	; 0x22b2 <vTaskDelay>
		moveBlockToZoneOne();
     de4:	ce 01       	movw	r24, r28
     de6:	7b df       	rcall	.-266    	; 0xcde <_ZN8Robotarm18moveBlockToZoneOneEv>
		vTaskDelay( 500 / portTICK_RATE_MS );
     de8:	84 ef       	ldi	r24, 0xF4	; 244
     dea:	91 e0       	ldi	r25, 0x01	; 1
     dec:	0e 94 59 11 	call	0x22b2	; 0x22b2 <vTaskDelay>
		break;
		
		case 1U:
		grabBlock();
     df0:	3b c0       	rjmp	.+118    	; 0xe68 <_ZN8Robotarm8MoveItemEh+0xb2>
     df2:	b7 de       	rcall	.-658    	; 0xb62 <_ZN8Robotarm9grabBlockEv>
		vTaskDelay( 500 / portTICK_RATE_MS );
     df4:	84 ef       	ldi	r24, 0xF4	; 244
     df6:	91 e0       	ldi	r25, 0x01	; 1
     df8:	0e 94 59 11 	call	0x22b2	; 0x22b2 <vTaskDelay>
		moveBlockToZoneTwo();
     dfc:	ce 01       	movw	r24, r28
     dfe:	81 df       	rcall	.-254    	; 0xd02 <_ZN8Robotarm18moveBlockToZoneTwoEv>
		vTaskDelay( 500 / portTICK_RATE_MS );
     e00:	84 ef       	ldi	r24, 0xF4	; 244
     e02:	91 e0       	ldi	r25, 0x01	; 1
     e04:	0e 94 59 11 	call	0x22b2	; 0x22b2 <vTaskDelay>
		break;
		
		case 2U:
		grabBlock();
     e08:	2f c0       	rjmp	.+94     	; 0xe68 <_ZN8Robotarm8MoveItemEh+0xb2>
     e0a:	ab de       	rcall	.-682    	; 0xb62 <_ZN8Robotarm9grabBlockEv>
		vTaskDelay( 500 / portTICK_RATE_MS );
     e0c:	84 ef       	ldi	r24, 0xF4	; 244
     e0e:	91 e0       	ldi	r25, 0x01	; 1
     e10:	0e 94 59 11 	call	0x22b2	; 0x22b2 <vTaskDelay>
		moveBlockToZoneThree();
     e14:	ce 01       	movw	r24, r28
		vTaskDelay( 500 / portTICK_RATE_MS );
     e16:	87 df       	rcall	.-242    	; 0xd26 <_ZN8Robotarm20moveBlockToZoneThreeEv>
     e18:	84 ef       	ldi	r24, 0xF4	; 244
     e1a:	91 e0       	ldi	r25, 0x01	; 1
     e1c:	0e 94 59 11 	call	0x22b2	; 0x22b2 <vTaskDelay>
		break;
		
		case 3U:
		grabBlock();
     e20:	23 c0       	rjmp	.+70     	; 0xe68 <_ZN8Robotarm8MoveItemEh+0xb2>
		vTaskDelay( 500 / portTICK_RATE_MS );
     e22:	9f de       	rcall	.-706    	; 0xb62 <_ZN8Robotarm9grabBlockEv>
     e24:	84 ef       	ldi	r24, 0xF4	; 244
     e26:	91 e0       	ldi	r25, 0x01	; 1
     e28:	0e 94 59 11 	call	0x22b2	; 0x22b2 <vTaskDelay>
		moveBlockToZoneFour();
     e2c:	ce 01       	movw	r24, r28
		vTaskDelay( 500 / portTICK_RATE_MS );
     e2e:	8d df       	rcall	.-230    	; 0xd4a <_ZN8Robotarm19moveBlockToZoneFourEv>
     e30:	84 ef       	ldi	r24, 0xF4	; 244
     e32:	91 e0       	ldi	r25, 0x01	; 1
		break;
     e34:	0e 94 59 11 	call	0x22b2	; 0x22b2 <vTaskDelay>
		
		case 4U:
		grabBlock();
     e38:	17 c0       	rjmp	.+46     	; 0xe68 <_ZN8Robotarm8MoveItemEh+0xb2>
		vTaskDelay( 500 / portTICK_RATE_MS );
     e3a:	93 de       	rcall	.-730    	; 0xb62 <_ZN8Robotarm9grabBlockEv>
     e3c:	84 ef       	ldi	r24, 0xF4	; 244
     e3e:	91 e0       	ldi	r25, 0x01	; 1
		moveBlockToZoneFive();
     e40:	0e 94 59 11 	call	0x22b2	; 0x22b2 <vTaskDelay>
     e44:	ce 01       	movw	r24, r28
		vTaskDelay( 500 / portTICK_RATE_MS );
     e46:	93 df       	rcall	.-218    	; 0xd6e <_ZN8Robotarm19moveBlockToZoneFiveEv>
     e48:	84 ef       	ldi	r24, 0xF4	; 244
     e4a:	91 e0       	ldi	r25, 0x01	; 1
		break;
     e4c:	0e 94 59 11 	call	0x22b2	; 0x22b2 <vTaskDelay>
		
		case 5U:
		grabBlock();
     e50:	0b c0       	rjmp	.+22     	; 0xe68 <_ZN8Robotarm8MoveItemEh+0xb2>
		vTaskDelay( 500 / portTICK_RATE_MS );
     e52:	87 de       	rcall	.-754    	; 0xb62 <_ZN8Robotarm9grabBlockEv>
     e54:	84 ef       	ldi	r24, 0xF4	; 244
     e56:	91 e0       	ldi	r25, 0x01	; 1
     e58:	0e 94 59 11 	call	0x22b2	; 0x22b2 <vTaskDelay>
		moveBlockToZoneSix();
     e5c:	ce 01       	movw	r24, r28
     e5e:	99 df       	rcall	.-206    	; 0xd92 <_ZN8Robotarm18moveBlockToZoneSixEv>
		vTaskDelay( 500 / portTICK_RATE_MS );
     e60:	84 ef       	ldi	r24, 0xF4	; 244
     e62:	91 e0       	ldi	r25, 0x01	; 1
     e64:	0e 94 59 11 	call	0x22b2	; 0x22b2 <vTaskDelay>
		break;
		
		default:
		break;
	}
}
     e68:	df 91       	pop	r29
     e6a:	cf 91       	pop	r28
     e6c:	08 95       	ret

00000e6e <_ZN5Motor10SetDegreesEh>:
	*	 can be used to turn motor at a specific speed set by \ref delay. C
	*	 Note that this function needs to run multiple times to work as intended.
	*    @param uint8_t	degrees to turn
	*    @return void Nothing
	*/
	virtual void SetDegrees( uint8_t degrees )
     e6e:	cf 92       	push	r12
     e70:	df 92       	push	r13
     e72:	ef 92       	push	r14
     e74:	ff 92       	push	r15
     e76:	cf 93       	push	r28
     e78:	df 93       	push	r29
	{
		if ( maxDegrees_ >= degrees )
     e7a:	fc 01       	movw	r30, r24
     e7c:	26 89       	ldd	r18, Z+22	; 0x16
     e7e:	26 17       	cp	r18, r22
     e80:	c0 f0       	brcs	.+48     	; 0xeb2 <_ZN5Motor10SetDegreesEh+0x44>
     e82:	ec 01       	movw	r28, r24
		{
			percent_ = percentPrDeg * degrees + startpercent_;
     e84:	c6 80       	ldd	r12, Z+6	; 0x06
     e86:	d7 80       	ldd	r13, Z+7	; 0x07
     e88:	e0 84       	ldd	r14, Z+8	; 0x08
     e8a:	f1 84       	ldd	r15, Z+9	; 0x09
     e8c:	70 e0       	ldi	r23, 0x00	; 0
     e8e:	80 e0       	ldi	r24, 0x00	; 0
     e90:	90 e0       	ldi	r25, 0x00	; 0
     e92:	0e 94 5c 16 	call	0x2cb8	; 0x2cb8 <__floatsisf>
     e96:	a7 01       	movw	r20, r14
     e98:	96 01       	movw	r18, r12
     e9a:	0e 94 10 17 	call	0x2e20	; 0x2e20 <__mulsf3>
     e9e:	2a 89       	ldd	r18, Y+18	; 0x12
     ea0:	3b 89       	ldd	r19, Y+19	; 0x13
     ea2:	4c 89       	ldd	r20, Y+20	; 0x14
     ea4:	5d 89       	ldd	r21, Y+21	; 0x15
     ea6:	0e 94 5e 15 	call	0x2abc	; 0x2abc <__addsf3>
     eaa:	6a 87       	std	Y+10, r22	; 0x0a
     eac:	7b 87       	std	Y+11, r23	; 0x0b
     eae:	8c 87       	std	Y+12, r24	; 0x0c
     eb0:	9d 87       	std	Y+13, r25	; 0x0d
		}
	}
     eb2:	df 91       	pop	r29
     eb4:	cf 91       	pop	r28
     eb6:	ff 90       	pop	r15
     eb8:	ef 90       	pop	r14
     eba:	df 90       	pop	r13
     ebc:	cf 90       	pop	r12
     ebe:	08 95       	ret

00000ec0 <_ZN2M1D1Ev>:

class Motor
{
//functions
public:
	virtual ~Motor() {};
     ec0:	26 e6       	ldi	r18, 0x66	; 102
     ec2:	32 e0       	ldi	r19, 0x02	; 2
     ec4:	fc 01       	movw	r30, r24
     ec6:	31 83       	std	Z+1, r19	; 0x01
     ec8:	20 83       	st	Z, r18
     eca:	08 95       	ret

00000ecc <_ZN2M1D0Ev>:
	SetDegrees( 90 );
	tmr1Ptr_->setDutyCycleComA( percent_ );
	oldPercent_ = percent_;
} 

M1::~M1()
     ecc:	cf 93       	push	r28
     ece:	df 93       	push	r29
     ed0:	ec 01       	movw	r28, r24
{
}
     ed2:	f6 df       	rcall	.-20     	; 0xec0 <_ZN2M1D1Ev>
     ed4:	ce 01       	movw	r24, r28
     ed6:	8e dd       	rcall	.-1252   	; 0x9f4 <_ZdlPv>
     ed8:	df 91       	pop	r29
     eda:	cf 91       	pop	r28
     edc:	08 95       	ret

00000ede <_ZN2M19TurnMotorEv>:

void M1::TurnMotor()
{
     ede:	4f 92       	push	r4
     ee0:	5f 92       	push	r5
     ee2:	6f 92       	push	r6
     ee4:	7f 92       	push	r7
     ee6:	8f 92       	push	r8
     ee8:	9f 92       	push	r9
     eea:	af 92       	push	r10
     eec:	bf 92       	push	r11
     eee:	cf 92       	push	r12
     ef0:	df 92       	push	r13
     ef2:	ef 92       	push	r14
     ef4:	ff 92       	push	r15
     ef6:	cf 93       	push	r28
     ef8:	df 93       	push	r29
     efa:	ec 01       	movw	r28, r24
	if ( percent_ > oldPercent_ + PERCENT_PR_TICK )
     efc:	8a 84       	ldd	r8, Y+10	; 0x0a
     efe:	9b 84       	ldd	r9, Y+11	; 0x0b
     f00:	ac 84       	ldd	r10, Y+12	; 0x0c
     f02:	bd 84       	ldd	r11, Y+13	; 0x0d
     f04:	ce 84       	ldd	r12, Y+14	; 0x0e
     f06:	df 84       	ldd	r13, Y+15	; 0x0f
     f08:	e8 88       	ldd	r14, Y+16	; 0x10
     f0a:	f9 88       	ldd	r15, Y+17	; 0x11
     f0c:	20 e0       	ldi	r18, 0x00	; 0
     f0e:	30 e0       	ldi	r19, 0x00	; 0
     f10:	40 e8       	ldi	r20, 0x80	; 128
     f12:	5d e3       	ldi	r21, 0x3D	; 61
     f14:	c7 01       	movw	r24, r14
     f16:	b6 01       	movw	r22, r12
     f18:	0e 94 5e 15 	call	0x2abc	; 0x2abc <__addsf3>
     f1c:	2b 01       	movw	r4, r22
     f1e:	3c 01       	movw	r6, r24
     f20:	9b 01       	movw	r18, r22
     f22:	ac 01       	movw	r20, r24
     f24:	c5 01       	movw	r24, r10
     f26:	b4 01       	movw	r22, r8
     f28:	0e 94 0c 17 	call	0x2e18	; 0x2e18 <__gesf2>
     f2c:	18 16       	cp	r1, r24
     f2e:	74 f4       	brge	.+28     	; 0xf4c <_ZN2M19TurnMotorEv+0x6e>
	{
		oldPercent_ += PERCENT_PR_TICK;
     f30:	4e 86       	std	Y+14, r4	; 0x0e
     f32:	5f 86       	std	Y+15, r5	; 0x0f
     f34:	68 8a       	std	Y+16, r6	; 0x10
     f36:	79 8a       	std	Y+17, r7	; 0x11
		tmr1Ptr_->setDutyCycleComA( oldPercent_ );
     f38:	b3 01       	movw	r22, r6
     f3a:	a2 01       	movw	r20, r4
     f3c:	8a 81       	ldd	r24, Y+2	; 0x02
     f3e:	9b 81       	ldd	r25, Y+3	; 0x03
     f40:	b9 d3       	rcall	.+1906   	; 0x16b4 <_ZN6Timer116setDutyCycleComAEf>
		vTaskDelay( delay_ / portTICK_RATE_MS );
     f42:	8f 89       	ldd	r24, Y+23	; 0x17
     f44:	98 8d       	ldd	r25, Y+24	; 0x18
     f46:	0e 94 59 11 	call	0x22b2	; 0x22b2 <vTaskDelay>
     f4a:	1d c0       	rjmp	.+58     	; 0xf86 <_ZN2M19TurnMotorEv+0xa8>
	}
	else if ( percent_ < oldPercent_ )
     f4c:	a7 01       	movw	r20, r14
     f4e:	96 01       	movw	r18, r12
     f50:	c5 01       	movw	r24, r10
     f52:	b4 01       	movw	r22, r8
     f54:	0e 94 c2 15 	call	0x2b84	; 0x2b84 <__cmpsf2>
     f58:	88 23       	and	r24, r24
     f5a:	ac f4       	brge	.+42     	; 0xf86 <_ZN2M19TurnMotorEv+0xa8>
	{
		oldPercent_ -= PERCENT_PR_TICK;
     f5c:	20 e0       	ldi	r18, 0x00	; 0
     f5e:	30 e0       	ldi	r19, 0x00	; 0
     f60:	40 e8       	ldi	r20, 0x80	; 128
     f62:	5d e3       	ldi	r21, 0x3D	; 61
     f64:	c7 01       	movw	r24, r14
     f66:	b6 01       	movw	r22, r12
     f68:	0e 94 5d 15 	call	0x2aba	; 0x2aba <__subsf3>
     f6c:	ab 01       	movw	r20, r22
     f6e:	bc 01       	movw	r22, r24
     f70:	4e 87       	std	Y+14, r20	; 0x0e
     f72:	5f 87       	std	Y+15, r21	; 0x0f
     f74:	68 8b       	std	Y+16, r22	; 0x10
     f76:	79 8b       	std	Y+17, r23	; 0x11
		tmr1Ptr_->setDutyCycleComA( oldPercent_ );
     f78:	8a 81       	ldd	r24, Y+2	; 0x02
     f7a:	9b 81       	ldd	r25, Y+3	; 0x03
     f7c:	9b d3       	rcall	.+1846   	; 0x16b4 <_ZN6Timer116setDutyCycleComAEf>
		vTaskDelay( delay_ / portTICK_RATE_MS );
     f7e:	8f 89       	ldd	r24, Y+23	; 0x17
     f80:	98 8d       	ldd	r25, Y+24	; 0x18
     f82:	0e 94 59 11 	call	0x22b2	; 0x22b2 <vTaskDelay>
	}
}
     f86:	df 91       	pop	r29
     f88:	cf 91       	pop	r28
     f8a:	ff 90       	pop	r15
     f8c:	ef 90       	pop	r14
     f8e:	df 90       	pop	r13
     f90:	cf 90       	pop	r12
     f92:	bf 90       	pop	r11
     f94:	af 90       	pop	r10
     f96:	9f 90       	pop	r9
     f98:	8f 90       	pop	r8
     f9a:	7f 90       	pop	r7
     f9c:	6f 90       	pop	r6
     f9e:	5f 90       	pop	r5
     fa0:	4f 90       	pop	r4
     fa2:	08 95       	ret

00000fa4 <_ZN2M1C1EP6Timer1>:
* Author: jespe
*/

#include "M1.h"

M1::M1( Timer1* tmr )
     fa4:	cf 93       	push	r28
     fa6:	df 93       	push	r29
     fa8:	ec 01       	movw	r28, r24
     faa:	cb 01       	movw	r24, r22
     fac:	22 e7       	ldi	r18, 0x72	; 114
     fae:	32 e0       	ldi	r19, 0x02	; 2
     fb0:	39 83       	std	Y+1, r19	; 0x01
     fb2:	28 83       	st	Y, r18
{
	/* Store timer pointer */
	tmr1Ptr_ = tmr;
     fb4:	7b 83       	std	Y+3, r23	; 0x03
     fb6:	6a 83       	std	Y+2, r22	; 0x02
	
	/* This value is number of percent to add or subtract pr degree. */
	percentPrDeg = 0.0555555555555556;
     fb8:	49 e3       	ldi	r20, 0x39	; 57
     fba:	5e e8       	ldi	r21, 0x8E	; 142
     fbc:	63 e6       	ldi	r22, 0x63	; 99
     fbe:	7d e3       	ldi	r23, 0x3D	; 61
     fc0:	4e 83       	std	Y+6, r20	; 0x06
     fc2:	5f 83       	std	Y+7, r21	; 0x07
     fc4:	68 87       	std	Y+8, r22	; 0x08
     fc6:	79 87       	std	Y+9, r23	; 0x09
	
	/* This value is the lowest duty cycle percentage needed to make motor turn. */
	startpercent_ = 2.5;
     fc8:	40 e0       	ldi	r20, 0x00	; 0
     fca:	50 e0       	ldi	r21, 0x00	; 0
     fcc:	60 e2       	ldi	r22, 0x20	; 32
     fce:	70 e4       	ldi	r23, 0x40	; 64
     fd0:	4a 8b       	std	Y+18, r20	; 0x12
     fd2:	5b 8b       	std	Y+19, r21	; 0x13
     fd4:	6c 8b       	std	Y+20, r22	; 0x14
     fd6:	7d 8b       	std	Y+21, r23	; 0x15
	
	/* This value is the delay on motor. A lower value makes motors go faster and higher value makes motors go slower. */
	delay_ = 10;
     fd8:	2a e0       	ldi	r18, 0x0A	; 10
     fda:	30 e0       	ldi	r19, 0x00	; 0
     fdc:	38 8f       	std	Y+24, r19	; 0x18
     fde:	2f 8b       	std	Y+23, r18	; 0x17
	
	/* This value is the maximum number of degrees the motor can turn */
	maxDegrees_ = 180;
     fe0:	24 eb       	ldi	r18, 0xB4	; 180
     fe2:	2e 8b       	std	Y+22, r18	; 0x16
	*/
	virtual void SetDegrees( uint8_t degrees )
	{
		if ( maxDegrees_ >= degrees )
		{
			percent_ = percentPrDeg * degrees + startpercent_;
     fe4:	40 e0       	ldi	r20, 0x00	; 0
     fe6:	50 e0       	ldi	r21, 0x00	; 0
     fe8:	60 ef       	ldi	r22, 0xF0	; 240
     fea:	70 e4       	ldi	r23, 0x40	; 64
     fec:	4a 87       	std	Y+10, r20	; 0x0a
     fee:	5b 87       	std	Y+11, r21	; 0x0b
     ff0:	6c 87       	std	Y+12, r22	; 0x0c
     ff2:	7d 87       	std	Y+13, r23	; 0x0d
	
	/* Set motor to default startup value */
	SetDegrees( 90 );
	tmr1Ptr_->setDutyCycleComA( percent_ );
     ff4:	5f d3       	rcall	.+1726   	; 0x16b4 <_ZN6Timer116setDutyCycleComAEf>
	oldPercent_ = percent_;
     ff6:	8a 85       	ldd	r24, Y+10	; 0x0a
     ff8:	9b 85       	ldd	r25, Y+11	; 0x0b
     ffa:	ac 85       	ldd	r26, Y+12	; 0x0c
     ffc:	bd 85       	ldd	r27, Y+13	; 0x0d
     ffe:	8e 87       	std	Y+14, r24	; 0x0e
    1000:	9f 87       	std	Y+15, r25	; 0x0f
    1002:	a8 8b       	std	Y+16, r26	; 0x10
    1004:	b9 8b       	std	Y+17, r27	; 0x11
} 
    1006:	df 91       	pop	r29
    1008:	cf 91       	pop	r28
    100a:	08 95       	ret

0000100c <_ZN2M2D1Ev>:

class Motor
{
//functions
public:
	virtual ~Motor() {};
    100c:	26 e6       	ldi	r18, 0x66	; 102
    100e:	32 e0       	ldi	r19, 0x02	; 2
    1010:	fc 01       	movw	r30, r24
    1012:	31 83       	std	Z+1, r19	; 0x01
    1014:	20 83       	st	Z, r18
    1016:	08 95       	ret

00001018 <_ZN2M2D0Ev>:
	SetDegrees( 90 );
	tmr1Ptr_->setDutyCycleComB( percent_ );
	oldPercent_ = percent_;
}

M2::~M2()
    1018:	cf 93       	push	r28
    101a:	df 93       	push	r29
    101c:	ec 01       	movw	r28, r24
{
}
    101e:	f6 df       	rcall	.-20     	; 0x100c <_ZN2M2D1Ev>
    1020:	ce 01       	movw	r24, r28
    1022:	e8 dc       	rcall	.-1584   	; 0x9f4 <_ZdlPv>
    1024:	df 91       	pop	r29
    1026:	cf 91       	pop	r28
    1028:	08 95       	ret

0000102a <_ZN2M29TurnMotorEv>:

void M2::TurnMotor()
{
    102a:	4f 92       	push	r4
    102c:	5f 92       	push	r5
    102e:	6f 92       	push	r6
    1030:	7f 92       	push	r7
    1032:	8f 92       	push	r8
    1034:	9f 92       	push	r9
    1036:	af 92       	push	r10
    1038:	bf 92       	push	r11
    103a:	cf 92       	push	r12
    103c:	df 92       	push	r13
    103e:	ef 92       	push	r14
    1040:	ff 92       	push	r15
    1042:	cf 93       	push	r28
    1044:	df 93       	push	r29
    1046:	ec 01       	movw	r28, r24
	if ( percent_ > oldPercent_ + PERCENT_PR_TICK )
    1048:	8a 84       	ldd	r8, Y+10	; 0x0a
    104a:	9b 84       	ldd	r9, Y+11	; 0x0b
    104c:	ac 84       	ldd	r10, Y+12	; 0x0c
    104e:	bd 84       	ldd	r11, Y+13	; 0x0d
    1050:	ce 84       	ldd	r12, Y+14	; 0x0e
    1052:	df 84       	ldd	r13, Y+15	; 0x0f
    1054:	e8 88       	ldd	r14, Y+16	; 0x10
    1056:	f9 88       	ldd	r15, Y+17	; 0x11
    1058:	20 e0       	ldi	r18, 0x00	; 0
    105a:	30 e0       	ldi	r19, 0x00	; 0
    105c:	40 e8       	ldi	r20, 0x80	; 128
    105e:	5d e3       	ldi	r21, 0x3D	; 61
    1060:	c7 01       	movw	r24, r14
    1062:	b6 01       	movw	r22, r12
    1064:	0e 94 5e 15 	call	0x2abc	; 0x2abc <__addsf3>
    1068:	2b 01       	movw	r4, r22
    106a:	3c 01       	movw	r6, r24
    106c:	9b 01       	movw	r18, r22
    106e:	ac 01       	movw	r20, r24
    1070:	c5 01       	movw	r24, r10
    1072:	b4 01       	movw	r22, r8
    1074:	0e 94 0c 17 	call	0x2e18	; 0x2e18 <__gesf2>
    1078:	18 16       	cp	r1, r24
    107a:	74 f4       	brge	.+28     	; 0x1098 <_ZN2M29TurnMotorEv+0x6e>
	{
		oldPercent_ += PERCENT_PR_TICK;
    107c:	4e 86       	std	Y+14, r4	; 0x0e
    107e:	5f 86       	std	Y+15, r5	; 0x0f
    1080:	68 8a       	std	Y+16, r6	; 0x10
    1082:	79 8a       	std	Y+17, r7	; 0x11
		tmr1Ptr_->setDutyCycleComB( oldPercent_ );
    1084:	b3 01       	movw	r22, r6
    1086:	a2 01       	movw	r20, r4
    1088:	8a 81       	ldd	r24, Y+2	; 0x02
    108a:	9b 81       	ldd	r25, Y+3	; 0x03
    108c:	3e d3       	rcall	.+1660   	; 0x170a <_ZN6Timer116setDutyCycleComBEf>
		vTaskDelay( delay_ / portTICK_RATE_MS );
    108e:	8f 89       	ldd	r24, Y+23	; 0x17
    1090:	98 8d       	ldd	r25, Y+24	; 0x18
    1092:	0e 94 59 11 	call	0x22b2	; 0x22b2 <vTaskDelay>
    1096:	1d c0       	rjmp	.+58     	; 0x10d2 <_ZN2M29TurnMotorEv+0xa8>
	}
	else if ( percent_ < oldPercent_ )
    1098:	a7 01       	movw	r20, r14
    109a:	96 01       	movw	r18, r12
    109c:	c5 01       	movw	r24, r10
    109e:	b4 01       	movw	r22, r8
    10a0:	0e 94 c2 15 	call	0x2b84	; 0x2b84 <__cmpsf2>
    10a4:	88 23       	and	r24, r24
    10a6:	ac f4       	brge	.+42     	; 0x10d2 <_ZN2M29TurnMotorEv+0xa8>
	{
		oldPercent_ -= PERCENT_PR_TICK;
    10a8:	20 e0       	ldi	r18, 0x00	; 0
    10aa:	30 e0       	ldi	r19, 0x00	; 0
    10ac:	40 e8       	ldi	r20, 0x80	; 128
    10ae:	5d e3       	ldi	r21, 0x3D	; 61
    10b0:	c7 01       	movw	r24, r14
    10b2:	b6 01       	movw	r22, r12
    10b4:	0e 94 5d 15 	call	0x2aba	; 0x2aba <__subsf3>
    10b8:	ab 01       	movw	r20, r22
    10ba:	bc 01       	movw	r22, r24
    10bc:	4e 87       	std	Y+14, r20	; 0x0e
    10be:	5f 87       	std	Y+15, r21	; 0x0f
    10c0:	68 8b       	std	Y+16, r22	; 0x10
    10c2:	79 8b       	std	Y+17, r23	; 0x11
		tmr1Ptr_->setDutyCycleComB( oldPercent_ );
    10c4:	8a 81       	ldd	r24, Y+2	; 0x02
    10c6:	9b 81       	ldd	r25, Y+3	; 0x03
    10c8:	20 d3       	rcall	.+1600   	; 0x170a <_ZN6Timer116setDutyCycleComBEf>
		vTaskDelay( delay_ / portTICK_RATE_MS );
    10ca:	8f 89       	ldd	r24, Y+23	; 0x17
    10cc:	98 8d       	ldd	r25, Y+24	; 0x18
    10ce:	0e 94 59 11 	call	0x22b2	; 0x22b2 <vTaskDelay>
	}
}
    10d2:	df 91       	pop	r29
    10d4:	cf 91       	pop	r28
    10d6:	ff 90       	pop	r15
    10d8:	ef 90       	pop	r14
    10da:	df 90       	pop	r13
    10dc:	cf 90       	pop	r12
    10de:	bf 90       	pop	r11
    10e0:	af 90       	pop	r10
    10e2:	9f 90       	pop	r9
    10e4:	8f 90       	pop	r8
    10e6:	7f 90       	pop	r7
    10e8:	6f 90       	pop	r6
    10ea:	5f 90       	pop	r5
    10ec:	4f 90       	pop	r4
    10ee:	08 95       	ret

000010f0 <_ZN2M2C1EP6Timer1>:
* Author: jespe
*/

#include "M2.h"

M2::M2( Timer1* tmr )
    10f0:	cf 93       	push	r28
    10f2:	df 93       	push	r29
    10f4:	ec 01       	movw	r28, r24
    10f6:	cb 01       	movw	r24, r22
    10f8:	2e e7       	ldi	r18, 0x7E	; 126
    10fa:	32 e0       	ldi	r19, 0x02	; 2
    10fc:	39 83       	std	Y+1, r19	; 0x01
    10fe:	28 83       	st	Y, r18
{
	/* Store timer pointer */
	tmr1Ptr_ = tmr;
    1100:	7b 83       	std	Y+3, r23	; 0x03
    1102:	6a 83       	std	Y+2, r22	; 0x02
	
	/* This value is number of percent to add or subtract pr degree. */
	percentPrDeg = 0.06;
    1104:	4f e8       	ldi	r20, 0x8F	; 143
    1106:	52 ec       	ldi	r21, 0xC2	; 194
    1108:	65 e7       	ldi	r22, 0x75	; 117
    110a:	7d e3       	ldi	r23, 0x3D	; 61
    110c:	4e 83       	std	Y+6, r20	; 0x06
    110e:	5f 83       	std	Y+7, r21	; 0x07
    1110:	68 87       	std	Y+8, r22	; 0x08
    1112:	79 87       	std	Y+9, r23	; 0x09

	/* This value is the lowest duty cycle percentage needed to make motor turn. */
	startpercent_ = 3;
    1114:	40 e0       	ldi	r20, 0x00	; 0
    1116:	50 e0       	ldi	r21, 0x00	; 0
    1118:	60 e4       	ldi	r22, 0x40	; 64
    111a:	70 e4       	ldi	r23, 0x40	; 64
    111c:	4a 8b       	std	Y+18, r20	; 0x12
    111e:	5b 8b       	std	Y+19, r21	; 0x13
    1120:	6c 8b       	std	Y+20, r22	; 0x14
    1122:	7d 8b       	std	Y+21, r23	; 0x15

	/* This value is the delay on motor. A lower value makes motors go faster and higher value makes motors go slower. Value is in MS */
	delay_ = 10;
    1124:	2a e0       	ldi	r18, 0x0A	; 10
    1126:	30 e0       	ldi	r19, 0x00	; 0
    1128:	38 8f       	std	Y+24, r19	; 0x18
    112a:	2f 8b       	std	Y+23, r18	; 0x17

	/* This value is the maximum number of degrees the motor can turn */
	maxDegrees_ = 150;
    112c:	26 e9       	ldi	r18, 0x96	; 150
    112e:	2e 8b       	std	Y+22, r18	; 0x16
	*/
	virtual void SetDegrees( uint8_t degrees )
	{
		if ( maxDegrees_ >= degrees )
		{
			percent_ = percentPrDeg * degrees + startpercent_;
    1130:	46 e6       	ldi	r20, 0x66	; 102
    1132:	56 e6       	ldi	r21, 0x66	; 102
    1134:	66 e0       	ldi	r22, 0x06	; 6
    1136:	71 e4       	ldi	r23, 0x41	; 65
    1138:	4a 87       	std	Y+10, r20	; 0x0a
    113a:	5b 87       	std	Y+11, r21	; 0x0b
    113c:	6c 87       	std	Y+12, r22	; 0x0c
    113e:	7d 87       	std	Y+13, r23	; 0x0d

	/* Set motor to default startup value */
	SetDegrees( 90 );
	tmr1Ptr_->setDutyCycleComB( percent_ );
    1140:	e4 d2       	rcall	.+1480   	; 0x170a <_ZN6Timer116setDutyCycleComBEf>
	oldPercent_ = percent_;
    1142:	8a 85       	ldd	r24, Y+10	; 0x0a
    1144:	9b 85       	ldd	r25, Y+11	; 0x0b
    1146:	ac 85       	ldd	r26, Y+12	; 0x0c
    1148:	bd 85       	ldd	r27, Y+13	; 0x0d
    114a:	8e 87       	std	Y+14, r24	; 0x0e
    114c:	9f 87       	std	Y+15, r25	; 0x0f
    114e:	a8 8b       	std	Y+16, r26	; 0x10
    1150:	b9 8b       	std	Y+17, r27	; 0x11
}
    1152:	df 91       	pop	r29
    1154:	cf 91       	pop	r28
    1156:	08 95       	ret

00001158 <_ZN2M3D1Ev>:

class Motor
{
//functions
public:
	virtual ~Motor() {};
    1158:	26 e6       	ldi	r18, 0x66	; 102
    115a:	32 e0       	ldi	r19, 0x02	; 2
    115c:	fc 01       	movw	r30, r24
    115e:	31 83       	std	Z+1, r19	; 0x01
    1160:	20 83       	st	Z, r18
    1162:	08 95       	ret

00001164 <_ZN2M3D0Ev>:
	SetDegrees( 90 );
	tmr1Ptr_->setDutyCycleComC( percent_ );
	oldPercent_ = percent_;	
}

M3::~M3()
    1164:	cf 93       	push	r28
    1166:	df 93       	push	r29
    1168:	ec 01       	movw	r28, r24
{
}
    116a:	f6 df       	rcall	.-20     	; 0x1158 <_ZN2M3D1Ev>
    116c:	ce 01       	movw	r24, r28
    116e:	42 dc       	rcall	.-1916   	; 0x9f4 <_ZdlPv>
    1170:	df 91       	pop	r29
    1172:	cf 91       	pop	r28
    1174:	08 95       	ret

00001176 <_ZN2M39TurnMotorEv>:

void M3::TurnMotor()
{
    1176:	4f 92       	push	r4
    1178:	5f 92       	push	r5
    117a:	6f 92       	push	r6
    117c:	7f 92       	push	r7
    117e:	8f 92       	push	r8
    1180:	9f 92       	push	r9
    1182:	af 92       	push	r10
    1184:	bf 92       	push	r11
    1186:	cf 92       	push	r12
    1188:	df 92       	push	r13
    118a:	ef 92       	push	r14
    118c:	ff 92       	push	r15
    118e:	cf 93       	push	r28
    1190:	df 93       	push	r29
    1192:	ec 01       	movw	r28, r24
	if ( percent_ > oldPercent_ + PERCENT_PR_TICK )
    1194:	8a 84       	ldd	r8, Y+10	; 0x0a
    1196:	9b 84       	ldd	r9, Y+11	; 0x0b
    1198:	ac 84       	ldd	r10, Y+12	; 0x0c
    119a:	bd 84       	ldd	r11, Y+13	; 0x0d
    119c:	ce 84       	ldd	r12, Y+14	; 0x0e
    119e:	df 84       	ldd	r13, Y+15	; 0x0f
    11a0:	e8 88       	ldd	r14, Y+16	; 0x10
    11a2:	f9 88       	ldd	r15, Y+17	; 0x11
    11a4:	20 e0       	ldi	r18, 0x00	; 0
    11a6:	30 e0       	ldi	r19, 0x00	; 0
    11a8:	40 e8       	ldi	r20, 0x80	; 128
    11aa:	5d e3       	ldi	r21, 0x3D	; 61
    11ac:	c7 01       	movw	r24, r14
    11ae:	b6 01       	movw	r22, r12
    11b0:	0e 94 5e 15 	call	0x2abc	; 0x2abc <__addsf3>
    11b4:	2b 01       	movw	r4, r22
    11b6:	3c 01       	movw	r6, r24
    11b8:	9b 01       	movw	r18, r22
    11ba:	ac 01       	movw	r20, r24
    11bc:	c5 01       	movw	r24, r10
    11be:	b4 01       	movw	r22, r8
    11c0:	0e 94 0c 17 	call	0x2e18	; 0x2e18 <__gesf2>
    11c4:	18 16       	cp	r1, r24
    11c6:	74 f4       	brge	.+28     	; 0x11e4 <_ZN2M39TurnMotorEv+0x6e>
	{
		oldPercent_ += PERCENT_PR_TICK;
    11c8:	4e 86       	std	Y+14, r4	; 0x0e
    11ca:	5f 86       	std	Y+15, r5	; 0x0f
    11cc:	68 8a       	std	Y+16, r6	; 0x10
    11ce:	79 8a       	std	Y+17, r7	; 0x11
		tmr1Ptr_->setDutyCycleComC( oldPercent_ );
    11d0:	b3 01       	movw	r22, r6
    11d2:	a2 01       	movw	r20, r4
    11d4:	8a 81       	ldd	r24, Y+2	; 0x02
    11d6:	9b 81       	ldd	r25, Y+3	; 0x03
    11d8:	c3 d2       	rcall	.+1414   	; 0x1760 <_ZN6Timer116setDutyCycleComCEf>
		vTaskDelay( delay_ / portTICK_RATE_MS );
    11da:	8f 89       	ldd	r24, Y+23	; 0x17
    11dc:	98 8d       	ldd	r25, Y+24	; 0x18
    11de:	0e 94 59 11 	call	0x22b2	; 0x22b2 <vTaskDelay>
    11e2:	1d c0       	rjmp	.+58     	; 0x121e <_ZN2M39TurnMotorEv+0xa8>
	}
	else if ( percent_ < oldPercent_ )
    11e4:	a7 01       	movw	r20, r14
    11e6:	96 01       	movw	r18, r12
    11e8:	c5 01       	movw	r24, r10
    11ea:	b4 01       	movw	r22, r8
    11ec:	0e 94 c2 15 	call	0x2b84	; 0x2b84 <__cmpsf2>
    11f0:	88 23       	and	r24, r24
    11f2:	ac f4       	brge	.+42     	; 0x121e <_ZN2M39TurnMotorEv+0xa8>
	{
		oldPercent_ -= PERCENT_PR_TICK;
    11f4:	20 e0       	ldi	r18, 0x00	; 0
    11f6:	30 e0       	ldi	r19, 0x00	; 0
    11f8:	40 e8       	ldi	r20, 0x80	; 128
    11fa:	5d e3       	ldi	r21, 0x3D	; 61
    11fc:	c7 01       	movw	r24, r14
    11fe:	b6 01       	movw	r22, r12
    1200:	0e 94 5d 15 	call	0x2aba	; 0x2aba <__subsf3>
    1204:	ab 01       	movw	r20, r22
    1206:	bc 01       	movw	r22, r24
    1208:	4e 87       	std	Y+14, r20	; 0x0e
    120a:	5f 87       	std	Y+15, r21	; 0x0f
    120c:	68 8b       	std	Y+16, r22	; 0x10
    120e:	79 8b       	std	Y+17, r23	; 0x11
		tmr1Ptr_->setDutyCycleComC( oldPercent_ );
    1210:	8a 81       	ldd	r24, Y+2	; 0x02
    1212:	9b 81       	ldd	r25, Y+3	; 0x03
    1214:	a5 d2       	rcall	.+1354   	; 0x1760 <_ZN6Timer116setDutyCycleComCEf>
		vTaskDelay( delay_ / portTICK_RATE_MS );
    1216:	8f 89       	ldd	r24, Y+23	; 0x17
    1218:	98 8d       	ldd	r25, Y+24	; 0x18
    121a:	0e 94 59 11 	call	0x22b2	; 0x22b2 <vTaskDelay>
	}
}
    121e:	df 91       	pop	r29
    1220:	cf 91       	pop	r28
    1222:	ff 90       	pop	r15
    1224:	ef 90       	pop	r14
    1226:	df 90       	pop	r13
    1228:	cf 90       	pop	r12
    122a:	bf 90       	pop	r11
    122c:	af 90       	pop	r10
    122e:	9f 90       	pop	r9
    1230:	8f 90       	pop	r8
    1232:	7f 90       	pop	r7
    1234:	6f 90       	pop	r6
    1236:	5f 90       	pop	r5
    1238:	4f 90       	pop	r4
    123a:	08 95       	ret

0000123c <_ZN2M3C1EP6Timer1>:
*/

#include "M3.h"


M3::M3( Timer1* tmr )
    123c:	cf 93       	push	r28
    123e:	df 93       	push	r29
    1240:	ec 01       	movw	r28, r24
    1242:	cb 01       	movw	r24, r22
    1244:	2a e8       	ldi	r18, 0x8A	; 138
    1246:	32 e0       	ldi	r19, 0x02	; 2
    1248:	39 83       	std	Y+1, r19	; 0x01
    124a:	28 83       	st	Y, r18
{
	/* Store timer pointer */
	tmr1Ptr_ = tmr;
    124c:	7b 83       	std	Y+3, r23	; 0x03
    124e:	6a 83       	std	Y+2, r22	; 0x02
		
	/* This value is number of percent to add or subtract pr degree. */
	percentPrDeg = 0.0555555555555556;
    1250:	49 e3       	ldi	r20, 0x39	; 57
    1252:	5e e8       	ldi	r21, 0x8E	; 142
    1254:	63 e6       	ldi	r22, 0x63	; 99
    1256:	7d e3       	ldi	r23, 0x3D	; 61
    1258:	4e 83       	std	Y+6, r20	; 0x06
    125a:	5f 83       	std	Y+7, r21	; 0x07
    125c:	68 87       	std	Y+8, r22	; 0x08
    125e:	79 87       	std	Y+9, r23	; 0x09
	
	/* This value is the lowest duty cycle percentage needed to make motor turn. */
	startpercent_ = 2.5;
    1260:	40 e0       	ldi	r20, 0x00	; 0
    1262:	50 e0       	ldi	r21, 0x00	; 0
    1264:	60 e2       	ldi	r22, 0x20	; 32
    1266:	70 e4       	ldi	r23, 0x40	; 64
    1268:	4a 8b       	std	Y+18, r20	; 0x12
    126a:	5b 8b       	std	Y+19, r21	; 0x13
    126c:	6c 8b       	std	Y+20, r22	; 0x14
    126e:	7d 8b       	std	Y+21, r23	; 0x15

	/* This value is the delay on motor. A lower value makes motors go faster and higher value makes motors go slower. Value is in MS */
	delay_ = 10;
    1270:	2a e0       	ldi	r18, 0x0A	; 10
    1272:	30 e0       	ldi	r19, 0x00	; 0
    1274:	38 8f       	std	Y+24, r19	; 0x18
    1276:	2f 8b       	std	Y+23, r18	; 0x17
	
	/* This value is the maximum number of degrees the motor can turn */
	maxDegrees_ = 180;
    1278:	24 eb       	ldi	r18, 0xB4	; 180
    127a:	2e 8b       	std	Y+22, r18	; 0x16
	*/
	virtual void SetDegrees( uint8_t degrees )
	{
		if ( maxDegrees_ >= degrees )
		{
			percent_ = percentPrDeg * degrees + startpercent_;
    127c:	40 e0       	ldi	r20, 0x00	; 0
    127e:	50 e0       	ldi	r21, 0x00	; 0
    1280:	60 ef       	ldi	r22, 0xF0	; 240
    1282:	70 e4       	ldi	r23, 0x40	; 64
    1284:	4a 87       	std	Y+10, r20	; 0x0a
    1286:	5b 87       	std	Y+11, r21	; 0x0b
    1288:	6c 87       	std	Y+12, r22	; 0x0c
    128a:	7d 87       	std	Y+13, r23	; 0x0d
	
	/* Set motor to default startup value */
	SetDegrees( 90 );
	tmr1Ptr_->setDutyCycleComC( percent_ );
    128c:	69 d2       	rcall	.+1234   	; 0x1760 <_ZN6Timer116setDutyCycleComCEf>
	oldPercent_ = percent_;	
    128e:	8a 85       	ldd	r24, Y+10	; 0x0a
    1290:	9b 85       	ldd	r25, Y+11	; 0x0b
    1292:	ac 85       	ldd	r26, Y+12	; 0x0c
    1294:	bd 85       	ldd	r27, Y+13	; 0x0d
    1296:	8e 87       	std	Y+14, r24	; 0x0e
    1298:	9f 87       	std	Y+15, r25	; 0x0f
    129a:	a8 8b       	std	Y+16, r26	; 0x10
    129c:	b9 8b       	std	Y+17, r27	; 0x11
}
    129e:	df 91       	pop	r29
    12a0:	cf 91       	pop	r28
    12a2:	08 95       	ret

000012a4 <_ZN2M4D1Ev>:

class Motor
{
//functions
public:
	virtual ~Motor() {};
    12a4:	26 e6       	ldi	r18, 0x66	; 102
    12a6:	32 e0       	ldi	r19, 0x02	; 2
    12a8:	fc 01       	movw	r30, r24
    12aa:	31 83       	std	Z+1, r19	; 0x01
    12ac:	20 83       	st	Z, r18
    12ae:	08 95       	ret

000012b0 <_ZN2M4D0Ev>:
	SetDegrees( 90 );
	tmr3Ptr_->setDutyCycleComA( percent_ );
	oldPercent_ = percent_;
}

M4::~M4()
    12b0:	cf 93       	push	r28
    12b2:	df 93       	push	r29
    12b4:	ec 01       	movw	r28, r24
{
} 
    12b6:	f6 df       	rcall	.-20     	; 0x12a4 <_ZN2M4D1Ev>
    12b8:	ce 01       	movw	r24, r28
    12ba:	9c db       	rcall	.-2248   	; 0x9f4 <_ZdlPv>
    12bc:	df 91       	pop	r29
    12be:	cf 91       	pop	r28
    12c0:	08 95       	ret

000012c2 <_ZN2M49TurnMotorEv>:

void M4::TurnMotor()
{
    12c2:	4f 92       	push	r4
    12c4:	5f 92       	push	r5
    12c6:	6f 92       	push	r6
    12c8:	7f 92       	push	r7
    12ca:	8f 92       	push	r8
    12cc:	9f 92       	push	r9
    12ce:	af 92       	push	r10
    12d0:	bf 92       	push	r11
    12d2:	cf 92       	push	r12
    12d4:	df 92       	push	r13
    12d6:	ef 92       	push	r14
    12d8:	ff 92       	push	r15
    12da:	cf 93       	push	r28
    12dc:	df 93       	push	r29
    12de:	ec 01       	movw	r28, r24
	if ( percent_ > oldPercent_ + PERCENT_PR_TICK )
    12e0:	8a 84       	ldd	r8, Y+10	; 0x0a
    12e2:	9b 84       	ldd	r9, Y+11	; 0x0b
    12e4:	ac 84       	ldd	r10, Y+12	; 0x0c
    12e6:	bd 84       	ldd	r11, Y+13	; 0x0d
    12e8:	ce 84       	ldd	r12, Y+14	; 0x0e
    12ea:	df 84       	ldd	r13, Y+15	; 0x0f
    12ec:	e8 88       	ldd	r14, Y+16	; 0x10
    12ee:	f9 88       	ldd	r15, Y+17	; 0x11
    12f0:	20 e0       	ldi	r18, 0x00	; 0
    12f2:	30 e0       	ldi	r19, 0x00	; 0
    12f4:	40 e8       	ldi	r20, 0x80	; 128
    12f6:	5d e3       	ldi	r21, 0x3D	; 61
    12f8:	c7 01       	movw	r24, r14
    12fa:	b6 01       	movw	r22, r12
    12fc:	0e 94 5e 15 	call	0x2abc	; 0x2abc <__addsf3>
    1300:	2b 01       	movw	r4, r22
    1302:	3c 01       	movw	r6, r24
    1304:	9b 01       	movw	r18, r22
    1306:	ac 01       	movw	r20, r24
    1308:	c5 01       	movw	r24, r10
    130a:	b4 01       	movw	r22, r8
    130c:	0e 94 0c 17 	call	0x2e18	; 0x2e18 <__gesf2>
    1310:	18 16       	cp	r1, r24
    1312:	6c f4       	brge	.+26     	; 0x132e <_ZN2M49TurnMotorEv+0x6c>
	{
		oldPercent_ += PERCENT_PR_TICK;
    1314:	4e 86       	std	Y+14, r4	; 0x0e
    1316:	5f 86       	std	Y+15, r5	; 0x0f
    1318:	68 8a       	std	Y+16, r6	; 0x10
    131a:	79 8a       	std	Y+17, r7	; 0x11
		tmr3Ptr_->setDutyCycleComA( oldPercent_ );
    131c:	b3 01       	movw	r22, r6
    131e:	a2 01       	movw	r20, r4
    1320:	8c 81       	ldd	r24, Y+4	; 0x04
    1322:	9d 81       	ldd	r25, Y+5	; 0x05
    1324:	6e d2       	rcall	.+1244   	; 0x1802 <_ZN6Timer516setDutyCycleComAEf>
		vTaskDelay( 10 / portTICK_RATE_MS );
    1326:	8a e0       	ldi	r24, 0x0A	; 10
    1328:	90 e0       	ldi	r25, 0x00	; 0
    132a:	c3 d7       	rcall	.+3974   	; 0x22b2 <vTaskDelay>
    132c:	1c c0       	rjmp	.+56     	; 0x1366 <_ZN2M49TurnMotorEv+0xa4>
	}
	else if ( percent_ < oldPercent_ )
    132e:	a7 01       	movw	r20, r14
    1330:	96 01       	movw	r18, r12
    1332:	c5 01       	movw	r24, r10
    1334:	b4 01       	movw	r22, r8
    1336:	0e 94 c2 15 	call	0x2b84	; 0x2b84 <__cmpsf2>
    133a:	88 23       	and	r24, r24
    133c:	a4 f4       	brge	.+40     	; 0x1366 <_ZN2M49TurnMotorEv+0xa4>
	{
		oldPercent_ -= PERCENT_PR_TICK;
    133e:	20 e0       	ldi	r18, 0x00	; 0
    1340:	30 e0       	ldi	r19, 0x00	; 0
    1342:	40 e8       	ldi	r20, 0x80	; 128
    1344:	5d e3       	ldi	r21, 0x3D	; 61
    1346:	c7 01       	movw	r24, r14
    1348:	b6 01       	movw	r22, r12
    134a:	0e 94 5d 15 	call	0x2aba	; 0x2aba <__subsf3>
    134e:	ab 01       	movw	r20, r22
    1350:	bc 01       	movw	r22, r24
    1352:	4e 87       	std	Y+14, r20	; 0x0e
    1354:	5f 87       	std	Y+15, r21	; 0x0f
    1356:	68 8b       	std	Y+16, r22	; 0x10
    1358:	79 8b       	std	Y+17, r23	; 0x11
		tmr3Ptr_->setDutyCycleComA( oldPercent_ );
    135a:	8c 81       	ldd	r24, Y+4	; 0x04
    135c:	9d 81       	ldd	r25, Y+5	; 0x05
    135e:	51 d2       	rcall	.+1186   	; 0x1802 <_ZN6Timer516setDutyCycleComAEf>
		vTaskDelay( 10 / portTICK_RATE_MS );
    1360:	8a e0       	ldi	r24, 0x0A	; 10
    1362:	90 e0       	ldi	r25, 0x00	; 0
    1364:	a6 d7       	rcall	.+3916   	; 0x22b2 <vTaskDelay>
    1366:	df 91       	pop	r29
	}
}
    1368:	cf 91       	pop	r28
    136a:	ff 90       	pop	r15
    136c:	ef 90       	pop	r14
    136e:	df 90       	pop	r13
    1370:	cf 90       	pop	r12
    1372:	bf 90       	pop	r11
    1374:	af 90       	pop	r10
    1376:	9f 90       	pop	r9
    1378:	8f 90       	pop	r8
    137a:	7f 90       	pop	r7
    137c:	6f 90       	pop	r6
    137e:	5f 90       	pop	r5
    1380:	4f 90       	pop	r4
    1382:	08 95       	ret

00001384 <_ZN2M4C1EP6Timer5>:
    1384:	cf 93       	push	r28
* Author: jespe
*/

#include "M4.h"

M4::M4( Timer5* tmr )
    1386:	df 93       	push	r29
    1388:	ec 01       	movw	r28, r24
    138a:	cb 01       	movw	r24, r22
    138c:	26 e9       	ldi	r18, 0x96	; 150
    138e:	32 e0       	ldi	r19, 0x02	; 2
    1390:	39 83       	std	Y+1, r19	; 0x01
    1392:	28 83       	st	Y, r18
{
	/* Store timer pointer */
	tmr3Ptr_ = tmr;
    1394:	7d 83       	std	Y+5, r23	; 0x05
    1396:	6c 83       	std	Y+4, r22	; 0x04
	
	/* This value is number of percent to add or subtract pr degree. */
	percentPrDeg = 0.0555555555555556;
    1398:	49 e3       	ldi	r20, 0x39	; 57
    139a:	5e e8       	ldi	r21, 0x8E	; 142
    139c:	63 e6       	ldi	r22, 0x63	; 99
    139e:	7d e3       	ldi	r23, 0x3D	; 61
    13a0:	4e 83       	std	Y+6, r20	; 0x06
    13a2:	5f 83       	std	Y+7, r21	; 0x07
    13a4:	68 87       	std	Y+8, r22	; 0x08
    13a6:	79 87       	std	Y+9, r23	; 0x09
	
	/* This value is the lowest duty cycle percentage needed to make motor turn. */
	startpercent_ = 2.5;
    13a8:	40 e0       	ldi	r20, 0x00	; 0
    13aa:	50 e0       	ldi	r21, 0x00	; 0
    13ac:	60 e2       	ldi	r22, 0x20	; 32
    13ae:	70 e4       	ldi	r23, 0x40	; 64
    13b0:	4a 8b       	std	Y+18, r20	; 0x12
    13b2:	5b 8b       	std	Y+19, r21	; 0x13
    13b4:	6c 8b       	std	Y+20, r22	; 0x14
    13b6:	7d 8b       	std	Y+21, r23	; 0x15
		
	/* This value is the delay on motor. A lower value makes motors go faster and higher value makes motors go slower. Value is in MS */
	delay_ = 5;
    13b8:	25 e0       	ldi	r18, 0x05	; 5
    13ba:	30 e0       	ldi	r19, 0x00	; 0
    13bc:	38 8f       	std	Y+24, r19	; 0x18
    13be:	2f 8b       	std	Y+23, r18	; 0x17
	
	/* This value is the maximum number of degrees the motor can turn */
	maxDegrees_ = 180;
    13c0:	24 eb       	ldi	r18, 0xB4	; 180
    13c2:	2e 8b       	std	Y+22, r18	; 0x16
	*/
	virtual void SetDegrees( uint8_t degrees )
	{
		if ( maxDegrees_ >= degrees )
		{
			percent_ = percentPrDeg * degrees + startpercent_;
    13c4:	40 e0       	ldi	r20, 0x00	; 0
    13c6:	50 e0       	ldi	r21, 0x00	; 0
    13c8:	60 ef       	ldi	r22, 0xF0	; 240
    13ca:	70 e4       	ldi	r23, 0x40	; 64
    13cc:	4a 87       	std	Y+10, r20	; 0x0a
    13ce:	5b 87       	std	Y+11, r21	; 0x0b
    13d0:	6c 87       	std	Y+12, r22	; 0x0c
    13d2:	7d 87       	std	Y+13, r23	; 0x0d
	
	/* Set motor to default startup value */
	SetDegrees( 90 );
	tmr3Ptr_->setDutyCycleComA( percent_ );
    13d4:	16 d2       	rcall	.+1068   	; 0x1802 <_ZN6Timer516setDutyCycleComAEf>
	oldPercent_ = percent_;
    13d6:	8a 85       	ldd	r24, Y+10	; 0x0a
    13d8:	9b 85       	ldd	r25, Y+11	; 0x0b
    13da:	ac 85       	ldd	r26, Y+12	; 0x0c
    13dc:	bd 85       	ldd	r27, Y+13	; 0x0d
    13de:	8e 87       	std	Y+14, r24	; 0x0e
    13e0:	9f 87       	std	Y+15, r25	; 0x0f
    13e2:	a8 8b       	std	Y+16, r26	; 0x10
    13e4:	b9 8b       	std	Y+17, r27	; 0x11
}
    13e6:	df 91       	pop	r29
    13e8:	cf 91       	pop	r28
    13ea:	08 95       	ret

000013ec <_ZN2M5D1Ev>:

class Motor
{
//functions
public:
	virtual ~Motor() {};
    13ec:	26 e6       	ldi	r18, 0x66	; 102
    13ee:	32 e0       	ldi	r19, 0x02	; 2
    13f0:	fc 01       	movw	r30, r24
    13f2:	31 83       	std	Z+1, r19	; 0x01
    13f4:	20 83       	st	Z, r18
    13f6:	08 95       	ret

000013f8 <_ZN2M5D0Ev>:
	SetDegrees( 0 );
	tmr3Ptr_->setDutyCycleComB( percent_ );
	oldPercent_ = percent_;
}

M5::~M5()
    13f8:	cf 93       	push	r28
    13fa:	df 93       	push	r29
    13fc:	ec 01       	movw	r28, r24
{
}
    13fe:	f6 df       	rcall	.-20     	; 0x13ec <_ZN2M5D1Ev>
    1400:	ce 01       	movw	r24, r28
    1402:	f8 da       	rcall	.-2576   	; 0x9f4 <_ZdlPv>
    1404:	df 91       	pop	r29
    1406:	cf 91       	pop	r28
    1408:	08 95       	ret

0000140a <_ZN2M59TurnMotorEv>:

void M5::TurnMotor()
{
    140a:	4f 92       	push	r4
    140c:	5f 92       	push	r5
    140e:	6f 92       	push	r6
    1410:	7f 92       	push	r7
    1412:	8f 92       	push	r8
    1414:	9f 92       	push	r9
    1416:	af 92       	push	r10
    1418:	bf 92       	push	r11
    141a:	cf 92       	push	r12
    141c:	df 92       	push	r13
    141e:	ef 92       	push	r14
    1420:	ff 92       	push	r15
    1422:	cf 93       	push	r28
    1424:	df 93       	push	r29
    1426:	ec 01       	movw	r28, r24
	if ( percent_ > oldPercent_ + PERCENT_PR_TICK )
    1428:	8a 84       	ldd	r8, Y+10	; 0x0a
    142a:	9b 84       	ldd	r9, Y+11	; 0x0b
    142c:	ac 84       	ldd	r10, Y+12	; 0x0c
    142e:	bd 84       	ldd	r11, Y+13	; 0x0d
    1430:	ce 84       	ldd	r12, Y+14	; 0x0e
    1432:	df 84       	ldd	r13, Y+15	; 0x0f
    1434:	e8 88       	ldd	r14, Y+16	; 0x10
    1436:	f9 88       	ldd	r15, Y+17	; 0x11
    1438:	20 e0       	ldi	r18, 0x00	; 0
    143a:	30 e0       	ldi	r19, 0x00	; 0
    143c:	40 e8       	ldi	r20, 0x80	; 128
    143e:	5d e3       	ldi	r21, 0x3D	; 61
    1440:	c7 01       	movw	r24, r14
    1442:	b6 01       	movw	r22, r12
    1444:	0e 94 5e 15 	call	0x2abc	; 0x2abc <__addsf3>
    1448:	2b 01       	movw	r4, r22
    144a:	3c 01       	movw	r6, r24
    144c:	9b 01       	movw	r18, r22
    144e:	ac 01       	movw	r20, r24
    1450:	c5 01       	movw	r24, r10
    1452:	b4 01       	movw	r22, r8
    1454:	0e 94 0c 17 	call	0x2e18	; 0x2e18 <__gesf2>
    1458:	18 16       	cp	r1, r24
    145a:	6c f4       	brge	.+26     	; 0x1476 <_ZN2M59TurnMotorEv+0x6c>
	{
		oldPercent_ += PERCENT_PR_TICK;
    145c:	4e 86       	std	Y+14, r4	; 0x0e
    145e:	5f 86       	std	Y+15, r5	; 0x0f
    1460:	68 8a       	std	Y+16, r6	; 0x10
    1462:	79 8a       	std	Y+17, r7	; 0x11
		tmr3Ptr_->setDutyCycleComB( oldPercent_ );
    1464:	b3 01       	movw	r22, r6
    1466:	a2 01       	movw	r20, r4
    1468:	8c 81       	ldd	r24, Y+4	; 0x04
    146a:	9d 81       	ldd	r25, Y+5	; 0x05
    146c:	f5 d1       	rcall	.+1002   	; 0x1858 <_ZN6Timer516setDutyCycleComBEf>
		vTaskDelay( delay_ / portTICK_RATE_MS );
    146e:	8f 89       	ldd	r24, Y+23	; 0x17
    1470:	98 8d       	ldd	r25, Y+24	; 0x18
    1472:	1f d7       	rcall	.+3646   	; 0x22b2 <vTaskDelay>
    1474:	1c c0       	rjmp	.+56     	; 0x14ae <_ZN2M59TurnMotorEv+0xa4>
	}
	else if ( percent_ < oldPercent_ )
    1476:	a7 01       	movw	r20, r14
    1478:	96 01       	movw	r18, r12
    147a:	c5 01       	movw	r24, r10
    147c:	b4 01       	movw	r22, r8
    147e:	0e 94 c2 15 	call	0x2b84	; 0x2b84 <__cmpsf2>
    1482:	88 23       	and	r24, r24
    1484:	a4 f4       	brge	.+40     	; 0x14ae <_ZN2M59TurnMotorEv+0xa4>
	{
		oldPercent_ -= PERCENT_PR_TICK;
    1486:	20 e0       	ldi	r18, 0x00	; 0
    1488:	30 e0       	ldi	r19, 0x00	; 0
    148a:	40 e8       	ldi	r20, 0x80	; 128
    148c:	5d e3       	ldi	r21, 0x3D	; 61
    148e:	c7 01       	movw	r24, r14
    1490:	b6 01       	movw	r22, r12
    1492:	0e 94 5d 15 	call	0x2aba	; 0x2aba <__subsf3>
    1496:	ab 01       	movw	r20, r22
    1498:	bc 01       	movw	r22, r24
    149a:	4e 87       	std	Y+14, r20	; 0x0e
    149c:	5f 87       	std	Y+15, r21	; 0x0f
    149e:	68 8b       	std	Y+16, r22	; 0x10
    14a0:	79 8b       	std	Y+17, r23	; 0x11
		tmr3Ptr_->setDutyCycleComB( oldPercent_ );
    14a2:	8c 81       	ldd	r24, Y+4	; 0x04
    14a4:	9d 81       	ldd	r25, Y+5	; 0x05
    14a6:	d8 d1       	rcall	.+944    	; 0x1858 <_ZN6Timer516setDutyCycleComBEf>
		vTaskDelay( delay_ / portTICK_RATE_MS );
    14a8:	8f 89       	ldd	r24, Y+23	; 0x17
    14aa:	98 8d       	ldd	r25, Y+24	; 0x18
    14ac:	02 d7       	rcall	.+3588   	; 0x22b2 <vTaskDelay>
    14ae:	df 91       	pop	r29
	}
}
    14b0:	cf 91       	pop	r28
    14b2:	ff 90       	pop	r15
    14b4:	ef 90       	pop	r14
    14b6:	df 90       	pop	r13
    14b8:	cf 90       	pop	r12
    14ba:	bf 90       	pop	r11
    14bc:	af 90       	pop	r10
    14be:	9f 90       	pop	r9
    14c0:	8f 90       	pop	r8
    14c2:	7f 90       	pop	r7
    14c4:	6f 90       	pop	r6
    14c6:	5f 90       	pop	r5
    14c8:	4f 90       	pop	r4
    14ca:	08 95       	ret

000014cc <_ZN2M5C1EP6Timer5>:
    14cc:	cf 93       	push	r28
* Author: jespe
*/

#include "M5.h"

M5::M5( Timer5* tmr )
    14ce:	df 93       	push	r29
    14d0:	ec 01       	movw	r28, r24
    14d2:	cb 01       	movw	r24, r22
    14d4:	22 ea       	ldi	r18, 0xA2	; 162
    14d6:	32 e0       	ldi	r19, 0x02	; 2
    14d8:	39 83       	std	Y+1, r19	; 0x01
    14da:	28 83       	st	Y, r18
{
	/* Store timer pointer */
	tmr3Ptr_ = tmr;
    14dc:	7d 83       	std	Y+5, r23	; 0x05
    14de:	6c 83       	std	Y+4, r22	; 0x04
	
	/* This value is number of percent to add or subtract pr degree. */
	percentPrDeg = 0.0555555555555556;
    14e0:	49 e3       	ldi	r20, 0x39	; 57
    14e2:	5e e8       	ldi	r21, 0x8E	; 142
    14e4:	63 e6       	ldi	r22, 0x63	; 99
    14e6:	7d e3       	ldi	r23, 0x3D	; 61
    14e8:	4e 83       	std	Y+6, r20	; 0x06
    14ea:	5f 83       	std	Y+7, r21	; 0x07
    14ec:	68 87       	std	Y+8, r22	; 0x08
    14ee:	79 87       	std	Y+9, r23	; 0x09
	
	/* This value is the lowest duty cycle percentage needed to make motor turn. */
	startpercent_ = 2.5;
    14f0:	40 e0       	ldi	r20, 0x00	; 0
    14f2:	50 e0       	ldi	r21, 0x00	; 0
    14f4:	60 e2       	ldi	r22, 0x20	; 32
    14f6:	70 e4       	ldi	r23, 0x40	; 64
    14f8:	4a 8b       	std	Y+18, r20	; 0x12
    14fa:	5b 8b       	std	Y+19, r21	; 0x13
    14fc:	6c 8b       	std	Y+20, r22	; 0x14
    14fe:	7d 8b       	std	Y+21, r23	; 0x15
	
	/* This value is the delay on motor. A lower value makes motors go faster and higher value makes motors go slower. Value is in MS */
	delay_ = 1;
    1500:	21 e0       	ldi	r18, 0x01	; 1
    1502:	30 e0       	ldi	r19, 0x00	; 0
    1504:	38 8f       	std	Y+24, r19	; 0x18
    1506:	2f 8b       	std	Y+23, r18	; 0x17
	
	/* This value is the maximum number of degrees the motor can turn */
	maxDegrees_ = 180;
    1508:	24 eb       	ldi	r18, 0xB4	; 180
    150a:	2e 8b       	std	Y+22, r18	; 0x16
	*/
	virtual void SetDegrees( uint8_t degrees )
	{
		if ( maxDegrees_ >= degrees )
		{
			percent_ = percentPrDeg * degrees + startpercent_;
    150c:	4a 87       	std	Y+10, r20	; 0x0a
    150e:	5b 87       	std	Y+11, r21	; 0x0b
    1510:	6c 87       	std	Y+12, r22	; 0x0c
    1512:	7d 87       	std	Y+13, r23	; 0x0d
	
	/* Set motor to default startup value */
	SetDegrees( 0 );
	tmr3Ptr_->setDutyCycleComB( percent_ );
    1514:	a1 d1       	rcall	.+834    	; 0x1858 <_ZN6Timer516setDutyCycleComBEf>
	oldPercent_ = percent_;
    1516:	8a 85       	ldd	r24, Y+10	; 0x0a
    1518:	9b 85       	ldd	r25, Y+11	; 0x0b
    151a:	ac 85       	ldd	r26, Y+12	; 0x0c
    151c:	bd 85       	ldd	r27, Y+13	; 0x0d
    151e:	8e 87       	std	Y+14, r24	; 0x0e
    1520:	9f 87       	std	Y+15, r25	; 0x0f
    1522:	a8 8b       	std	Y+16, r26	; 0x10
    1524:	b9 8b       	std	Y+17, r27	; 0x11
}
    1526:	df 91       	pop	r29
    1528:	cf 91       	pop	r28
    152a:	08 95       	ret

0000152c <_ZN2M6D1Ev>:

class Motor
{
//functions
public:
	virtual ~Motor() {};
    152c:	26 e6       	ldi	r18, 0x66	; 102
    152e:	32 e0       	ldi	r19, 0x02	; 2
    1530:	fc 01       	movw	r30, r24
    1532:	31 83       	std	Z+1, r19	; 0x01
    1534:	20 83       	st	Z, r18
    1536:	08 95       	ret

00001538 <_ZN2M6D0Ev>:
	SetDegrees( 0 );
	tmr3Ptr_->setDutyCycleComC( percent_ );
	oldPercent_ = percent_;
}

M6::~M6()
    1538:	cf 93       	push	r28
    153a:	df 93       	push	r29
    153c:	ec 01       	movw	r28, r24
{
}
    153e:	f6 df       	rcall	.-20     	; 0x152c <_ZN2M6D1Ev>
    1540:	ce 01       	movw	r24, r28
    1542:	58 da       	rcall	.-2896   	; 0x9f4 <_ZdlPv>
    1544:	df 91       	pop	r29
    1546:	cf 91       	pop	r28
    1548:	08 95       	ret

0000154a <_ZN2M69TurnMotorEv>:

void M6::TurnMotor()
{
    154a:	4f 92       	push	r4
    154c:	5f 92       	push	r5
    154e:	6f 92       	push	r6
    1550:	7f 92       	push	r7
    1552:	8f 92       	push	r8
    1554:	9f 92       	push	r9
    1556:	af 92       	push	r10
    1558:	bf 92       	push	r11
    155a:	cf 92       	push	r12
    155c:	df 92       	push	r13
    155e:	ef 92       	push	r14
    1560:	ff 92       	push	r15
    1562:	cf 93       	push	r28
    1564:	df 93       	push	r29
    1566:	ec 01       	movw	r28, r24
	if ( percent_ > oldPercent_ + PERCENT_PR_TICK )
    1568:	8a 84       	ldd	r8, Y+10	; 0x0a
    156a:	9b 84       	ldd	r9, Y+11	; 0x0b
    156c:	ac 84       	ldd	r10, Y+12	; 0x0c
    156e:	bd 84       	ldd	r11, Y+13	; 0x0d
    1570:	ce 84       	ldd	r12, Y+14	; 0x0e
    1572:	df 84       	ldd	r13, Y+15	; 0x0f
    1574:	e8 88       	ldd	r14, Y+16	; 0x10
    1576:	f9 88       	ldd	r15, Y+17	; 0x11
    1578:	20 e0       	ldi	r18, 0x00	; 0
    157a:	30 e0       	ldi	r19, 0x00	; 0
    157c:	40 e8       	ldi	r20, 0x80	; 128
    157e:	5d e3       	ldi	r21, 0x3D	; 61
    1580:	c7 01       	movw	r24, r14
    1582:	b6 01       	movw	r22, r12
    1584:	0e 94 5e 15 	call	0x2abc	; 0x2abc <__addsf3>
    1588:	2b 01       	movw	r4, r22
    158a:	3c 01       	movw	r6, r24
    158c:	9b 01       	movw	r18, r22
    158e:	ac 01       	movw	r20, r24
    1590:	c5 01       	movw	r24, r10
    1592:	b4 01       	movw	r22, r8
    1594:	0e 94 0c 17 	call	0x2e18	; 0x2e18 <__gesf2>
    1598:	18 16       	cp	r1, r24
    159a:	6c f4       	brge	.+26     	; 0x15b6 <_ZN2M69TurnMotorEv+0x6c>
	{
		oldPercent_ += 0.0625;
    159c:	4e 86       	std	Y+14, r4	; 0x0e
    159e:	5f 86       	std	Y+15, r5	; 0x0f
    15a0:	68 8a       	std	Y+16, r6	; 0x10
    15a2:	79 8a       	std	Y+17, r7	; 0x11
		tmr3Ptr_->setDutyCycleComC( oldPercent_ );
    15a4:	b3 01       	movw	r22, r6
    15a6:	a2 01       	movw	r20, r4
    15a8:	8c 81       	ldd	r24, Y+4	; 0x04
    15aa:	9d 81       	ldd	r25, Y+5	; 0x05
    15ac:	80 d1       	rcall	.+768    	; 0x18ae <_ZN6Timer516setDutyCycleComCEf>
		vTaskDelay( delay_ / portTICK_RATE_MS );
    15ae:	8f 89       	ldd	r24, Y+23	; 0x17
    15b0:	98 8d       	ldd	r25, Y+24	; 0x18
    15b2:	7f d6       	rcall	.+3326   	; 0x22b2 <vTaskDelay>
    15b4:	1c c0       	rjmp	.+56     	; 0x15ee <_ZN2M69TurnMotorEv+0xa4>
	}
	else if ( percent_ < oldPercent_ )
    15b6:	a7 01       	movw	r20, r14
    15b8:	96 01       	movw	r18, r12
    15ba:	c5 01       	movw	r24, r10
    15bc:	b4 01       	movw	r22, r8
    15be:	0e 94 c2 15 	call	0x2b84	; 0x2b84 <__cmpsf2>
    15c2:	88 23       	and	r24, r24
    15c4:	a4 f4       	brge	.+40     	; 0x15ee <_ZN2M69TurnMotorEv+0xa4>
	{
		oldPercent_ -= 0.0625;
    15c6:	20 e0       	ldi	r18, 0x00	; 0
    15c8:	30 e0       	ldi	r19, 0x00	; 0
    15ca:	40 e8       	ldi	r20, 0x80	; 128
    15cc:	5d e3       	ldi	r21, 0x3D	; 61
    15ce:	c7 01       	movw	r24, r14
    15d0:	b6 01       	movw	r22, r12
    15d2:	0e 94 5d 15 	call	0x2aba	; 0x2aba <__subsf3>
    15d6:	ab 01       	movw	r20, r22
    15d8:	bc 01       	movw	r22, r24
    15da:	4e 87       	std	Y+14, r20	; 0x0e
    15dc:	5f 87       	std	Y+15, r21	; 0x0f
    15de:	68 8b       	std	Y+16, r22	; 0x10
    15e0:	79 8b       	std	Y+17, r23	; 0x11
		tmr3Ptr_->setDutyCycleComC( oldPercent_ );
    15e2:	8c 81       	ldd	r24, Y+4	; 0x04
    15e4:	9d 81       	ldd	r25, Y+5	; 0x05
    15e6:	63 d1       	rcall	.+710    	; 0x18ae <_ZN6Timer516setDutyCycleComCEf>
		vTaskDelay( delay_ / portTICK_RATE_MS );
    15e8:	8f 89       	ldd	r24, Y+23	; 0x17
    15ea:	98 8d       	ldd	r25, Y+24	; 0x18
    15ec:	62 d6       	rcall	.+3268   	; 0x22b2 <vTaskDelay>
    15ee:	df 91       	pop	r29
	}
}
    15f0:	cf 91       	pop	r28
    15f2:	ff 90       	pop	r15
    15f4:	ef 90       	pop	r14
    15f6:	df 90       	pop	r13
    15f8:	cf 90       	pop	r12
    15fa:	bf 90       	pop	r11
    15fc:	af 90       	pop	r10
    15fe:	9f 90       	pop	r9
    1600:	8f 90       	pop	r8
    1602:	7f 90       	pop	r7
    1604:	6f 90       	pop	r6
    1606:	5f 90       	pop	r5
    1608:	4f 90       	pop	r4
    160a:	08 95       	ret

0000160c <_ZN2M6C1EP6Timer5>:
    160c:	cf 93       	push	r28
* Author: jespe
*/

#include "M6.h"

M6::M6( Timer5* tmr )
    160e:	df 93       	push	r29
    1610:	ec 01       	movw	r28, r24
    1612:	cb 01       	movw	r24, r22
    1614:	2e ea       	ldi	r18, 0xAE	; 174
    1616:	32 e0       	ldi	r19, 0x02	; 2
    1618:	39 83       	std	Y+1, r19	; 0x01
    161a:	28 83       	st	Y, r18
{
	/* Store timer pointer */
	tmr3Ptr_ = tmr;
    161c:	7d 83       	std	Y+5, r23	; 0x05
    161e:	6c 83       	std	Y+4, r22	; 0x04
	
	/* This value is number of percent to add or subtract pr degree. */
	percentPrDeg = 0.07936507936507;
    1620:	49 e2       	ldi	r20, 0x29	; 41
    1622:	5a e8       	ldi	r21, 0x8A	; 138
    1624:	62 ea       	ldi	r22, 0xA2	; 162
    1626:	7d e3       	ldi	r23, 0x3D	; 61
    1628:	4e 83       	std	Y+6, r20	; 0x06
    162a:	5f 83       	std	Y+7, r21	; 0x07
    162c:	68 87       	std	Y+8, r22	; 0x08
    162e:	79 87       	std	Y+9, r23	; 0x09
	
	/* This value is the lowest duty cycle percentage needed to make motor turn. */
	startpercent_ = 2.5;
    1630:	40 e0       	ldi	r20, 0x00	; 0
    1632:	50 e0       	ldi	r21, 0x00	; 0
    1634:	60 e2       	ldi	r22, 0x20	; 32
    1636:	70 e4       	ldi	r23, 0x40	; 64
    1638:	4a 8b       	std	Y+18, r20	; 0x12
    163a:	5b 8b       	std	Y+19, r21	; 0x13
    163c:	6c 8b       	std	Y+20, r22	; 0x14
    163e:	7d 8b       	std	Y+21, r23	; 0x15
	
	/* This value is the delay on motor. A lower value makes motors go faster and higher value makes motors go slower. Value is in MS */
	delay_ = 1;
    1640:	21 e0       	ldi	r18, 0x01	; 1
    1642:	30 e0       	ldi	r19, 0x00	; 0
    1644:	38 8f       	std	Y+24, r19	; 0x18
    1646:	2f 8b       	std	Y+23, r18	; 0x17
	
	/* This value is the maximum number of degrees the motor can turn */
	maxDegrees_ = 63;
    1648:	2f e3       	ldi	r18, 0x3F	; 63
    164a:	2e 8b       	std	Y+22, r18	; 0x16
	*/
	virtual void SetDegrees( uint8_t degrees )
	{
		if ( maxDegrees_ >= degrees )
		{
			percent_ = percentPrDeg * degrees + startpercent_;
    164c:	4a 87       	std	Y+10, r20	; 0x0a
    164e:	5b 87       	std	Y+11, r21	; 0x0b
    1650:	6c 87       	std	Y+12, r22	; 0x0c
    1652:	7d 87       	std	Y+13, r23	; 0x0d
	
	/* Set motor to default startup value */
	SetDegrees( 0 );
	tmr3Ptr_->setDutyCycleComC( percent_ );
    1654:	2c d1       	rcall	.+600    	; 0x18ae <_ZN6Timer516setDutyCycleComCEf>
	oldPercent_ = percent_;
    1656:	8a 85       	ldd	r24, Y+10	; 0x0a
    1658:	9b 85       	ldd	r25, Y+11	; 0x0b
    165a:	ac 85       	ldd	r26, Y+12	; 0x0c
    165c:	bd 85       	ldd	r27, Y+13	; 0x0d
    165e:	8e 87       	std	Y+14, r24	; 0x0e
    1660:	9f 87       	std	Y+15, r25	; 0x0f
    1662:	a8 8b       	std	Y+16, r26	; 0x10
    1664:	b9 8b       	std	Y+17, r27	; 0x11
}
    1666:	df 91       	pop	r29
    1668:	cf 91       	pop	r28
    166a:	08 95       	ret

0000166c <_ZN6Timer1C1Ev>:
#include <avr/io.h>

Timer1::Timer1()
{
	// Set all needed ports to outputs
	ROBOTARM_M1_OUT_PORT |= ( 1 << ROBOTARM_M1_OUT_PIN );
    166c:	84 b1       	in	r24, 0x04	; 4
    166e:	80 62       	ori	r24, 0x20	; 32
    1670:	84 b9       	out	0x04, r24	; 4
	ROBOTARM_M2_OUT_PORT |= ( 1 << ROBOTARM_M2_OUT_PIN );
    1672:	84 b1       	in	r24, 0x04	; 4
    1674:	80 64       	ori	r24, 0x40	; 64
    1676:	84 b9       	out	0x04, r24	; 4
	ROBOTARM_M3_OUT_PORT |= ( 1 << ROBOTARM_M3_OUT_PIN );
    1678:	84 b1       	in	r24, 0x04	; 4
    167a:	80 68       	ori	r24, 0x80	; 128
    167c:	84 b9       	out	0x04, r24	; 4
		
	// Set timer to run in PWM, Phase Correct mode with 50 Hz freq. 
	TCCR1A = ( 1 << COM1A1 ) | ( 1 << COM1B1 ) | ( 1 << COM1C1 ) | ( 0 << WGM10 ) | ( 0 << WGM11 );
    167e:	88 ea       	ldi	r24, 0xA8	; 168
    1680:	80 93 80 00 	sts	0x0080, r24	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
	TCCR1B = ( 1 << WGM13 ) | ( 0 << CS10 )  | ( 1 << CS12 );
    1684:	84 e1       	ldi	r24, 0x14	; 20
    1686:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x700081>
	TCCR1C = 0;
    168a:	10 92 82 00 	sts	0x0082, r1	; 0x800082 <__TEXT_REGION_LENGTH__+0x700082>
	ICR1 = 622;
    168e:	8e e6       	ldi	r24, 0x6E	; 110
    1690:	92 e0       	ldi	r25, 0x02	; 2
    1692:	90 93 87 00 	sts	0x0087, r25	; 0x800087 <__TEXT_REGION_LENGTH__+0x700087>
    1696:	80 93 86 00 	sts	0x0086, r24	; 0x800086 <__TEXT_REGION_LENGTH__+0x700086>
	
	OCR1A = 0;
    169a:	10 92 89 00 	sts	0x0089, r1	; 0x800089 <__TEXT_REGION_LENGTH__+0x700089>
    169e:	10 92 88 00 	sts	0x0088, r1	; 0x800088 <__TEXT_REGION_LENGTH__+0x700088>
	OCR1B = 0;
    16a2:	10 92 8b 00 	sts	0x008B, r1	; 0x80008b <__TEXT_REGION_LENGTH__+0x70008b>
    16a6:	10 92 8a 00 	sts	0x008A, r1	; 0x80008a <__TEXT_REGION_LENGTH__+0x70008a>
	OCR1C = 0;
    16aa:	10 92 8d 00 	sts	0x008D, r1	; 0x80008d <__TEXT_REGION_LENGTH__+0x70008d>
    16ae:	10 92 8c 00 	sts	0x008C, r1	; 0x80008c <__TEXT_REGION_LENGTH__+0x70008c>
    16b2:	08 95       	ret

000016b4 <_ZN6Timer116setDutyCycleComAEf>:
}

void Timer1::setDutyCycleComA( float dutyCycle )
{
    16b4:	cf 92       	push	r12
    16b6:	df 92       	push	r13
    16b8:	ef 92       	push	r14
    16ba:	ff 92       	push	r15
    16bc:	6a 01       	movw	r12, r20
    16be:	7b 01       	movw	r14, r22
	float percent = ICR1/100;
    16c0:	20 91 86 00 	lds	r18, 0x0086	; 0x800086 <__TEXT_REGION_LENGTH__+0x700086>
    16c4:	30 91 87 00 	lds	r19, 0x0087	; 0x800087 <__TEXT_REGION_LENGTH__+0x700087>
    16c8:	36 95       	lsr	r19
    16ca:	27 95       	ror	r18
    16cc:	36 95       	lsr	r19
    16ce:	27 95       	ror	r18
    16d0:	ab e7       	ldi	r26, 0x7B	; 123
    16d2:	b4 e1       	ldi	r27, 0x14	; 20
    16d4:	0e 94 9d 17 	call	0x2f3a	; 0x2f3a <__umulhisi3>
    16d8:	96 95       	lsr	r25
    16da:	87 95       	ror	r24
	OCR1A = (uint8_t)percent*dutyCycle;
    16dc:	bc 01       	movw	r22, r24
    16de:	77 27       	eor	r23, r23
    16e0:	07 2e       	mov	r0, r23
    16e2:	00 0c       	add	r0, r0
    16e4:	88 0b       	sbc	r24, r24
    16e6:	99 0b       	sbc	r25, r25
    16e8:	0e 94 5c 16 	call	0x2cb8	; 0x2cb8 <__floatsisf>
    16ec:	a7 01       	movw	r20, r14
    16ee:	96 01       	movw	r18, r12
    16f0:	0e 94 10 17 	call	0x2e20	; 0x2e20 <__mulsf3>
    16f4:	0e 94 2e 16 	call	0x2c5c	; 0x2c5c <__fixunssfsi>
    16f8:	70 93 89 00 	sts	0x0089, r23	; 0x800089 <__TEXT_REGION_LENGTH__+0x700089>
    16fc:	60 93 88 00 	sts	0x0088, r22	; 0x800088 <__TEXT_REGION_LENGTH__+0x700088>
}
    1700:	ff 90       	pop	r15
    1702:	ef 90       	pop	r14
    1704:	df 90       	pop	r13
    1706:	cf 90       	pop	r12
    1708:	08 95       	ret

0000170a <_ZN6Timer116setDutyCycleComBEf>:

void Timer1::setDutyCycleComB( float dutyCycle )
{
    170a:	cf 92       	push	r12
    170c:	df 92       	push	r13
    170e:	ef 92       	push	r14
    1710:	ff 92       	push	r15
    1712:	6a 01       	movw	r12, r20
    1714:	7b 01       	movw	r14, r22
	float percent = ICR1/100;
    1716:	20 91 86 00 	lds	r18, 0x0086	; 0x800086 <__TEXT_REGION_LENGTH__+0x700086>
    171a:	30 91 87 00 	lds	r19, 0x0087	; 0x800087 <__TEXT_REGION_LENGTH__+0x700087>
    171e:	36 95       	lsr	r19
    1720:	27 95       	ror	r18
    1722:	36 95       	lsr	r19
    1724:	27 95       	ror	r18
    1726:	ab e7       	ldi	r26, 0x7B	; 123
    1728:	b4 e1       	ldi	r27, 0x14	; 20
    172a:	0e 94 9d 17 	call	0x2f3a	; 0x2f3a <__umulhisi3>
    172e:	96 95       	lsr	r25
    1730:	87 95       	ror	r24
	OCR1B = (uint8_t)percent*dutyCycle;
    1732:	bc 01       	movw	r22, r24
    1734:	77 27       	eor	r23, r23
    1736:	07 2e       	mov	r0, r23
    1738:	00 0c       	add	r0, r0
    173a:	88 0b       	sbc	r24, r24
    173c:	99 0b       	sbc	r25, r25
    173e:	0e 94 5c 16 	call	0x2cb8	; 0x2cb8 <__floatsisf>
    1742:	a7 01       	movw	r20, r14
    1744:	96 01       	movw	r18, r12
    1746:	0e 94 10 17 	call	0x2e20	; 0x2e20 <__mulsf3>
    174a:	0e 94 2e 16 	call	0x2c5c	; 0x2c5c <__fixunssfsi>
    174e:	70 93 8b 00 	sts	0x008B, r23	; 0x80008b <__TEXT_REGION_LENGTH__+0x70008b>
    1752:	60 93 8a 00 	sts	0x008A, r22	; 0x80008a <__TEXT_REGION_LENGTH__+0x70008a>
}
    1756:	ff 90       	pop	r15
    1758:	ef 90       	pop	r14
    175a:	df 90       	pop	r13
    175c:	cf 90       	pop	r12
    175e:	08 95       	ret

00001760 <_ZN6Timer116setDutyCycleComCEf>:

void Timer1::setDutyCycleComC( float dutyCycle )
{
    1760:	cf 92       	push	r12
    1762:	df 92       	push	r13
    1764:	ef 92       	push	r14
    1766:	ff 92       	push	r15
    1768:	6a 01       	movw	r12, r20
    176a:	7b 01       	movw	r14, r22
	float percent = ICR1/100;
    176c:	20 91 86 00 	lds	r18, 0x0086	; 0x800086 <__TEXT_REGION_LENGTH__+0x700086>
    1770:	30 91 87 00 	lds	r19, 0x0087	; 0x800087 <__TEXT_REGION_LENGTH__+0x700087>
    1774:	36 95       	lsr	r19
    1776:	27 95       	ror	r18
    1778:	36 95       	lsr	r19
    177a:	27 95       	ror	r18
    177c:	ab e7       	ldi	r26, 0x7B	; 123
    177e:	b4 e1       	ldi	r27, 0x14	; 20
    1780:	0e 94 9d 17 	call	0x2f3a	; 0x2f3a <__umulhisi3>
    1784:	96 95       	lsr	r25
    1786:	87 95       	ror	r24
	OCR1C = (uint8_t)percent*dutyCycle;
    1788:	bc 01       	movw	r22, r24
    178a:	77 27       	eor	r23, r23
    178c:	07 2e       	mov	r0, r23
    178e:	00 0c       	add	r0, r0
    1790:	88 0b       	sbc	r24, r24
    1792:	99 0b       	sbc	r25, r25
    1794:	0e 94 5c 16 	call	0x2cb8	; 0x2cb8 <__floatsisf>
    1798:	a7 01       	movw	r20, r14
    179a:	96 01       	movw	r18, r12
    179c:	0e 94 10 17 	call	0x2e20	; 0x2e20 <__mulsf3>
    17a0:	0e 94 2e 16 	call	0x2c5c	; 0x2c5c <__fixunssfsi>
    17a4:	70 93 8d 00 	sts	0x008D, r23	; 0x80008d <__TEXT_REGION_LENGTH__+0x70008d>
    17a8:	60 93 8c 00 	sts	0x008C, r22	; 0x80008c <__TEXT_REGION_LENGTH__+0x70008c>
    17ac:	ff 90       	pop	r15
    17ae:	ef 90       	pop	r14
    17b0:	df 90       	pop	r13
    17b2:	cf 90       	pop	r12
    17b4:	08 95       	ret

000017b6 <_ZN6Timer5C1Ev>:
#include <avr/io.h>

Timer5::Timer5()
{
	// Set all needed ports to outputs
	ROBOTARM_M4_OUT_PORT |= ( 1 << ROBOTARM_M4_OUT_PIN );
    17b6:	ea e0       	ldi	r30, 0x0A	; 10
    17b8:	f1 e0       	ldi	r31, 0x01	; 1
    17ba:	80 81       	ld	r24, Z
    17bc:	88 60       	ori	r24, 0x08	; 8
    17be:	80 83       	st	Z, r24
	ROBOTARM_M5_OUT_PORT |= ( 1 << ROBOTARM_M5_OUT_PIN );
    17c0:	80 81       	ld	r24, Z
    17c2:	80 61       	ori	r24, 0x10	; 16
    17c4:	80 83       	st	Z, r24
	ROBOTARM_M6_OUT_PORT |= ( 1 << ROBOTARM_M6_OUT_PIN );
    17c6:	80 81       	ld	r24, Z
    17c8:	80 62       	ori	r24, 0x20	; 32
    17ca:	80 83       	st	Z, r24
	
	// Set timer to run in PWM, Phase Correct mode with 50 Hz freq.
	TCCR5A = ( 1 << COM3A1 ) | ( 1 << COM3B1 ) | ( 1 << COM3C1 ) | ( 0 << WGM30 ) | ( 0 << WGM31 );
    17cc:	88 ea       	ldi	r24, 0xA8	; 168
    17ce:	80 93 20 01 	sts	0x0120, r24	; 0x800120 <__TEXT_REGION_LENGTH__+0x700120>
	TCCR5B = ( 1 << WGM33 ) | ( 0 << CS30 )  | ( 1 << CS32 );
    17d2:	84 e1       	ldi	r24, 0x14	; 20
    17d4:	80 93 21 01 	sts	0x0121, r24	; 0x800121 <__TEXT_REGION_LENGTH__+0x700121>
	TCCR5C = 0;
    17d8:	10 92 22 01 	sts	0x0122, r1	; 0x800122 <__TEXT_REGION_LENGTH__+0x700122>
	ICR5 = 622;
    17dc:	8e e6       	ldi	r24, 0x6E	; 110
    17de:	92 e0       	ldi	r25, 0x02	; 2
    17e0:	90 93 27 01 	sts	0x0127, r25	; 0x800127 <__TEXT_REGION_LENGTH__+0x700127>
    17e4:	80 93 26 01 	sts	0x0126, r24	; 0x800126 <__TEXT_REGION_LENGTH__+0x700126>
	
	OCR5A = 0;
    17e8:	10 92 29 01 	sts	0x0129, r1	; 0x800129 <__TEXT_REGION_LENGTH__+0x700129>
    17ec:	10 92 28 01 	sts	0x0128, r1	; 0x800128 <__TEXT_REGION_LENGTH__+0x700128>
	OCR5B = 0;
    17f0:	10 92 2b 01 	sts	0x012B, r1	; 0x80012b <__TEXT_REGION_LENGTH__+0x70012b>
    17f4:	10 92 2a 01 	sts	0x012A, r1	; 0x80012a <__TEXT_REGION_LENGTH__+0x70012a>
	OCR5C = 0;
    17f8:	10 92 2d 01 	sts	0x012D, r1	; 0x80012d <__TEXT_REGION_LENGTH__+0x70012d>
    17fc:	10 92 2c 01 	sts	0x012C, r1	; 0x80012c <__TEXT_REGION_LENGTH__+0x70012c>
    1800:	08 95       	ret

00001802 <_ZN6Timer516setDutyCycleComAEf>:
}

void Timer5::setDutyCycleComA( float dutyCycle )
{
    1802:	cf 92       	push	r12
    1804:	df 92       	push	r13
    1806:	ef 92       	push	r14
    1808:	ff 92       	push	r15
    180a:	6a 01       	movw	r12, r20
    180c:	7b 01       	movw	r14, r22
	float percent = ICR5/100;
    180e:	20 91 26 01 	lds	r18, 0x0126	; 0x800126 <__TEXT_REGION_LENGTH__+0x700126>
    1812:	30 91 27 01 	lds	r19, 0x0127	; 0x800127 <__TEXT_REGION_LENGTH__+0x700127>
    1816:	36 95       	lsr	r19
    1818:	27 95       	ror	r18
    181a:	36 95       	lsr	r19
    181c:	27 95       	ror	r18
    181e:	ab e7       	ldi	r26, 0x7B	; 123
    1820:	b4 e1       	ldi	r27, 0x14	; 20
    1822:	0e 94 9d 17 	call	0x2f3a	; 0x2f3a <__umulhisi3>
    1826:	96 95       	lsr	r25
    1828:	87 95       	ror	r24
	OCR5A = (uint8_t)percent*dutyCycle;
    182a:	bc 01       	movw	r22, r24
    182c:	77 27       	eor	r23, r23
    182e:	07 2e       	mov	r0, r23
    1830:	00 0c       	add	r0, r0
    1832:	88 0b       	sbc	r24, r24
    1834:	99 0b       	sbc	r25, r25
    1836:	0e 94 5c 16 	call	0x2cb8	; 0x2cb8 <__floatsisf>
    183a:	a7 01       	movw	r20, r14
    183c:	96 01       	movw	r18, r12
    183e:	0e 94 10 17 	call	0x2e20	; 0x2e20 <__mulsf3>
    1842:	0e 94 2e 16 	call	0x2c5c	; 0x2c5c <__fixunssfsi>
    1846:	70 93 29 01 	sts	0x0129, r23	; 0x800129 <__TEXT_REGION_LENGTH__+0x700129>
    184a:	60 93 28 01 	sts	0x0128, r22	; 0x800128 <__TEXT_REGION_LENGTH__+0x700128>
}
    184e:	ff 90       	pop	r15
    1850:	ef 90       	pop	r14
    1852:	df 90       	pop	r13
    1854:	cf 90       	pop	r12
    1856:	08 95       	ret

00001858 <_ZN6Timer516setDutyCycleComBEf>:

void Timer5::setDutyCycleComB( float dutyCycle )
{
    1858:	cf 92       	push	r12
    185a:	df 92       	push	r13
    185c:	ef 92       	push	r14
    185e:	ff 92       	push	r15
    1860:	6a 01       	movw	r12, r20
    1862:	7b 01       	movw	r14, r22
	float percent = ICR5/100;
    1864:	20 91 26 01 	lds	r18, 0x0126	; 0x800126 <__TEXT_REGION_LENGTH__+0x700126>
    1868:	30 91 27 01 	lds	r19, 0x0127	; 0x800127 <__TEXT_REGION_LENGTH__+0x700127>
    186c:	36 95       	lsr	r19
    186e:	27 95       	ror	r18
    1870:	36 95       	lsr	r19
    1872:	27 95       	ror	r18
    1874:	ab e7       	ldi	r26, 0x7B	; 123
    1876:	b4 e1       	ldi	r27, 0x14	; 20
    1878:	0e 94 9d 17 	call	0x2f3a	; 0x2f3a <__umulhisi3>
    187c:	96 95       	lsr	r25
    187e:	87 95       	ror	r24
	OCR5B = (uint8_t)percent*dutyCycle;
    1880:	bc 01       	movw	r22, r24
    1882:	77 27       	eor	r23, r23
    1884:	07 2e       	mov	r0, r23
    1886:	00 0c       	add	r0, r0
    1888:	88 0b       	sbc	r24, r24
    188a:	99 0b       	sbc	r25, r25
    188c:	0e 94 5c 16 	call	0x2cb8	; 0x2cb8 <__floatsisf>
    1890:	a7 01       	movw	r20, r14
    1892:	96 01       	movw	r18, r12
    1894:	0e 94 10 17 	call	0x2e20	; 0x2e20 <__mulsf3>
    1898:	0e 94 2e 16 	call	0x2c5c	; 0x2c5c <__fixunssfsi>
    189c:	70 93 2b 01 	sts	0x012B, r23	; 0x80012b <__TEXT_REGION_LENGTH__+0x70012b>
    18a0:	60 93 2a 01 	sts	0x012A, r22	; 0x80012a <__TEXT_REGION_LENGTH__+0x70012a>
}
    18a4:	ff 90       	pop	r15
    18a6:	ef 90       	pop	r14
    18a8:	df 90       	pop	r13
    18aa:	cf 90       	pop	r12
    18ac:	08 95       	ret

000018ae <_ZN6Timer516setDutyCycleComCEf>:

void Timer5::setDutyCycleComC( float dutyCycle )
{
    18ae:	cf 92       	push	r12
    18b0:	df 92       	push	r13
    18b2:	ef 92       	push	r14
    18b4:	ff 92       	push	r15
    18b6:	6a 01       	movw	r12, r20
    18b8:	7b 01       	movw	r14, r22
	float percent = ICR5/100;
    18ba:	20 91 26 01 	lds	r18, 0x0126	; 0x800126 <__TEXT_REGION_LENGTH__+0x700126>
    18be:	30 91 27 01 	lds	r19, 0x0127	; 0x800127 <__TEXT_REGION_LENGTH__+0x700127>
    18c2:	36 95       	lsr	r19
    18c4:	27 95       	ror	r18
    18c6:	36 95       	lsr	r19
    18c8:	27 95       	ror	r18
    18ca:	ab e7       	ldi	r26, 0x7B	; 123
    18cc:	b4 e1       	ldi	r27, 0x14	; 20
    18ce:	0e 94 9d 17 	call	0x2f3a	; 0x2f3a <__umulhisi3>
    18d2:	96 95       	lsr	r25
    18d4:	87 95       	ror	r24
	OCR5C = (uint8_t)percent*dutyCycle;
    18d6:	bc 01       	movw	r22, r24
    18d8:	77 27       	eor	r23, r23
    18da:	07 2e       	mov	r0, r23
    18dc:	00 0c       	add	r0, r0
    18de:	88 0b       	sbc	r24, r24
    18e0:	99 0b       	sbc	r25, r25
    18e2:	0e 94 5c 16 	call	0x2cb8	; 0x2cb8 <__floatsisf>
    18e6:	a7 01       	movw	r20, r14
    18e8:	96 01       	movw	r18, r12
    18ea:	0e 94 10 17 	call	0x2e20	; 0x2e20 <__mulsf3>
    18ee:	0e 94 2e 16 	call	0x2c5c	; 0x2c5c <__fixunssfsi>
    18f2:	70 93 2d 01 	sts	0x012D, r23	; 0x80012d <__TEXT_REGION_LENGTH__+0x70012d>
    18f6:	60 93 2c 01 	sts	0x012C, r22	; 0x80012c <__TEXT_REGION_LENGTH__+0x70012c>
    18fa:	ff 90       	pop	r15
    18fc:	ef 90       	pop	r14
    18fe:	df 90       	pop	r13
    1900:	cf 90       	pop	r12
    1902:	08 95       	ret

00001904 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
    1904:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
    1906:	03 96       	adiw	r24, 0x03	; 3
    1908:	92 83       	std	Z+2, r25	; 0x02
    190a:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    190c:	2f ef       	ldi	r18, 0xFF	; 255
    190e:	3f ef       	ldi	r19, 0xFF	; 255
    1910:	34 83       	std	Z+4, r19	; 0x04
    1912:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
    1914:	96 83       	std	Z+6, r25	; 0x06
    1916:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
    1918:	90 87       	std	Z+8, r25	; 0x08
    191a:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
    191c:	10 82       	st	Z, r1
    191e:	08 95       	ret

00001920 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    1920:	fc 01       	movw	r30, r24
    1922:	11 86       	std	Z+9, r1	; 0x09
    1924:	10 86       	std	Z+8, r1	; 0x08
    1926:	08 95       	ret

00001928 <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
    1928:	cf 93       	push	r28
    192a:	df 93       	push	r29
    192c:	fc 01       	movw	r30, r24
    192e:	db 01       	movw	r26, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
    1930:	21 81       	ldd	r18, Z+1	; 0x01
    1932:	32 81       	ldd	r19, Z+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
    1934:	e9 01       	movw	r28, r18
    1936:	8a 81       	ldd	r24, Y+2	; 0x02
    1938:	9b 81       	ldd	r25, Y+3	; 0x03
    193a:	13 96       	adiw	r26, 0x03	; 3
    193c:	9c 93       	st	X, r25
    193e:	8e 93       	st	-X, r24
    1940:	12 97       	sbiw	r26, 0x02	; 2
	pxNewListItem->pxPrevious = pxList->pxIndex;
    1942:	81 81       	ldd	r24, Z+1	; 0x01
    1944:	92 81       	ldd	r25, Z+2	; 0x02
    1946:	15 96       	adiw	r26, 0x05	; 5
    1948:	9c 93       	st	X, r25
    194a:	8e 93       	st	-X, r24
    194c:	14 97       	sbiw	r26, 0x04	; 4
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    194e:	8a 81       	ldd	r24, Y+2	; 0x02
    1950:	9b 81       	ldd	r25, Y+3	; 0x03
    1952:	ec 01       	movw	r28, r24
    1954:	7d 83       	std	Y+5, r23	; 0x05
    1956:	6c 83       	std	Y+4, r22	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
    1958:	e9 01       	movw	r28, r18
    195a:	7b 83       	std	Y+3, r23	; 0x03
    195c:	6a 83       	std	Y+2, r22	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
    195e:	72 83       	std	Z+2, r23	; 0x02
    1960:	61 83       	std	Z+1, r22	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1962:	19 96       	adiw	r26, 0x09	; 9
    1964:	fc 93       	st	X, r31
    1966:	ee 93       	st	-X, r30
    1968:	18 97       	sbiw	r26, 0x08	; 8

	( pxList->uxNumberOfItems )++;
    196a:	80 81       	ld	r24, Z
    196c:	8f 5f       	subi	r24, 0xFF	; 255
    196e:	80 83       	st	Z, r24
}
    1970:	df 91       	pop	r29
    1972:	cf 91       	pop	r28
    1974:	08 95       	ret

00001976 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
    1976:	cf 93       	push	r28
    1978:	df 93       	push	r29
    197a:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
    197c:	48 81       	ld	r20, Y
    197e:	59 81       	ldd	r21, Y+1	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    1980:	4f 3f       	cpi	r20, 0xFF	; 255
    1982:	2f ef       	ldi	r18, 0xFF	; 255
    1984:	52 07       	cpc	r21, r18
    1986:	31 f4       	brne	.+12     	; 0x1994 <vListInsert+0x1e>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    1988:	dc 01       	movw	r26, r24
    198a:	17 96       	adiw	r26, 0x07	; 7
    198c:	ed 91       	ld	r30, X+
    198e:	fc 91       	ld	r31, X
    1990:	18 97       	sbiw	r26, 0x08	; 8
    1992:	0d c0       	rjmp	.+26     	; 0x19ae <vListInsert+0x38>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    1994:	fc 01       	movw	r30, r24
    1996:	33 96       	adiw	r30, 0x03	; 3
    1998:	03 c0       	rjmp	.+6      	; 0x19a0 <vListInsert+0x2a>
    199a:	02 80       	ldd	r0, Z+2	; 0x02
    199c:	f3 81       	ldd	r31, Z+3	; 0x03
    199e:	e0 2d       	mov	r30, r0
    19a0:	a2 81       	ldd	r26, Z+2	; 0x02
    19a2:	b3 81       	ldd	r27, Z+3	; 0x03
    19a4:	2d 91       	ld	r18, X+
    19a6:	3c 91       	ld	r19, X
    19a8:	42 17       	cp	r20, r18
    19aa:	53 07       	cpc	r21, r19
    19ac:	b0 f7       	brcc	.-20     	; 0x199a <vListInsert+0x24>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    19ae:	a2 81       	ldd	r26, Z+2	; 0x02
    19b0:	b3 81       	ldd	r27, Z+3	; 0x03
    19b2:	bb 83       	std	Y+3, r27	; 0x03
    19b4:	aa 83       	std	Y+2, r26	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    19b6:	15 96       	adiw	r26, 0x05	; 5
    19b8:	dc 93       	st	X, r29
    19ba:	ce 93       	st	-X, r28
    19bc:	14 97       	sbiw	r26, 0x04	; 4
	pxNewListItem->pxPrevious = pxIterator;
    19be:	fd 83       	std	Y+5, r31	; 0x05
    19c0:	ec 83       	std	Y+4, r30	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    19c2:	d3 83       	std	Z+3, r29	; 0x03
    19c4:	c2 83       	std	Z+2, r28	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    19c6:	99 87       	std	Y+9, r25	; 0x09
    19c8:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    19ca:	fc 01       	movw	r30, r24
    19cc:	20 81       	ld	r18, Z
    19ce:	2f 5f       	subi	r18, 0xFF	; 255
    19d0:	20 83       	st	Z, r18
}
    19d2:	df 91       	pop	r29
    19d4:	cf 91       	pop	r28
    19d6:	08 95       	ret

000019d8 <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
    19d8:	fc 01       	movw	r30, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    19da:	a2 81       	ldd	r26, Z+2	; 0x02
    19dc:	b3 81       	ldd	r27, Z+3	; 0x03
    19de:	84 81       	ldd	r24, Z+4	; 0x04
    19e0:	95 81       	ldd	r25, Z+5	; 0x05
    19e2:	15 96       	adiw	r26, 0x05	; 5
    19e4:	9c 93       	st	X, r25
    19e6:	8e 93       	st	-X, r24
    19e8:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    19ea:	a4 81       	ldd	r26, Z+4	; 0x04
    19ec:	b5 81       	ldd	r27, Z+5	; 0x05
    19ee:	82 81       	ldd	r24, Z+2	; 0x02
    19f0:	93 81       	ldd	r25, Z+3	; 0x03
    19f2:	13 96       	adiw	r26, 0x03	; 3
    19f4:	9c 93       	st	X, r25
    19f6:	8e 93       	st	-X, r24
    19f8:	12 97       	sbiw	r26, 0x02	; 2
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    19fa:	a0 85       	ldd	r26, Z+8	; 0x08
    19fc:	b1 85       	ldd	r27, Z+9	; 0x09

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    19fe:	11 96       	adiw	r26, 0x01	; 1
    1a00:	8d 91       	ld	r24, X+
    1a02:	9c 91       	ld	r25, X
    1a04:	12 97       	sbiw	r26, 0x02	; 2
    1a06:	e8 17       	cp	r30, r24
    1a08:	f9 07       	cpc	r31, r25
    1a0a:	31 f4       	brne	.+12     	; 0x1a18 <vListRemove+0x40>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    1a0c:	84 81       	ldd	r24, Z+4	; 0x04
    1a0e:	95 81       	ldd	r25, Z+5	; 0x05
    1a10:	12 96       	adiw	r26, 0x02	; 2
    1a12:	9c 93       	st	X, r25
    1a14:	8e 93       	st	-X, r24
    1a16:	11 97       	sbiw	r26, 0x01	; 1
	}

	pxItemToRemove->pvContainer = NULL;
    1a18:	11 86       	std	Z+9, r1	; 0x09
    1a1a:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    1a1c:	8c 91       	ld	r24, X
    1a1e:	81 50       	subi	r24, 0x01	; 1
    1a20:	8c 93       	st	X, r24
    1a22:	08 95       	ret

00001a24 <prvSetupTimerInterrupt>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    1a24:	8a ef       	ldi	r24, 0xFA	; 250
    1a26:	87 bd       	out	0x27, r24	; 39
    1a28:	82 e0       	ldi	r24, 0x02	; 2
    1a2a:	84 bd       	out	0x24, r24	; 36
    1a2c:	93 e0       	ldi	r25, 0x03	; 3
    1a2e:	95 bd       	out	0x25, r25	; 37
    1a30:	80 93 6e 00 	sts	0x006E, r24	; 0x80006e <__TEXT_REGION_LENGTH__+0x70006e>
    1a34:	08 95       	ret

00001a36 <pxPortInitialiseStack>:
    1a36:	31 e1       	ldi	r19, 0x11	; 17
    1a38:	fc 01       	movw	r30, r24
    1a3a:	30 83       	st	Z, r19
    1a3c:	31 97       	sbiw	r30, 0x01	; 1
    1a3e:	22 e2       	ldi	r18, 0x22	; 34
    1a40:	20 83       	st	Z, r18
    1a42:	31 97       	sbiw	r30, 0x01	; 1
    1a44:	a3 e3       	ldi	r26, 0x33	; 51
    1a46:	a0 83       	st	Z, r26
    1a48:	31 97       	sbiw	r30, 0x01	; 1
    1a4a:	60 83       	st	Z, r22
    1a4c:	31 97       	sbiw	r30, 0x01	; 1
    1a4e:	70 83       	st	Z, r23
    1a50:	31 97       	sbiw	r30, 0x01	; 1
    1a52:	10 82       	st	Z, r1
    1a54:	31 97       	sbiw	r30, 0x01	; 1
    1a56:	10 82       	st	Z, r1
    1a58:	31 97       	sbiw	r30, 0x01	; 1
    1a5a:	60 e8       	ldi	r22, 0x80	; 128
    1a5c:	60 83       	st	Z, r22
    1a5e:	31 97       	sbiw	r30, 0x01	; 1
    1a60:	10 82       	st	Z, r1
    1a62:	31 97       	sbiw	r30, 0x01	; 1
    1a64:	10 82       	st	Z, r1
    1a66:	31 97       	sbiw	r30, 0x01	; 1
    1a68:	10 82       	st	Z, r1
    1a6a:	31 97       	sbiw	r30, 0x01	; 1
    1a6c:	62 e0       	ldi	r22, 0x02	; 2
    1a6e:	60 83       	st	Z, r22
    1a70:	31 97       	sbiw	r30, 0x01	; 1
    1a72:	63 e0       	ldi	r22, 0x03	; 3
    1a74:	60 83       	st	Z, r22
    1a76:	31 97       	sbiw	r30, 0x01	; 1
    1a78:	64 e0       	ldi	r22, 0x04	; 4
    1a7a:	60 83       	st	Z, r22
    1a7c:	31 97       	sbiw	r30, 0x01	; 1
    1a7e:	65 e0       	ldi	r22, 0x05	; 5
    1a80:	60 83       	st	Z, r22
    1a82:	31 97       	sbiw	r30, 0x01	; 1
    1a84:	66 e0       	ldi	r22, 0x06	; 6
    1a86:	60 83       	st	Z, r22
    1a88:	31 97       	sbiw	r30, 0x01	; 1
    1a8a:	67 e0       	ldi	r22, 0x07	; 7
    1a8c:	60 83       	st	Z, r22
    1a8e:	31 97       	sbiw	r30, 0x01	; 1
    1a90:	68 e0       	ldi	r22, 0x08	; 8
    1a92:	60 83       	st	Z, r22
    1a94:	31 97       	sbiw	r30, 0x01	; 1
    1a96:	69 e0       	ldi	r22, 0x09	; 9
    1a98:	60 83       	st	Z, r22
    1a9a:	31 97       	sbiw	r30, 0x01	; 1
    1a9c:	60 e1       	ldi	r22, 0x10	; 16
    1a9e:	60 83       	st	Z, r22
    1aa0:	31 97       	sbiw	r30, 0x01	; 1
    1aa2:	30 83       	st	Z, r19
    1aa4:	31 97       	sbiw	r30, 0x01	; 1
    1aa6:	32 e1       	ldi	r19, 0x12	; 18
    1aa8:	30 83       	st	Z, r19
    1aaa:	31 97       	sbiw	r30, 0x01	; 1
    1aac:	33 e1       	ldi	r19, 0x13	; 19
    1aae:	30 83       	st	Z, r19
    1ab0:	31 97       	sbiw	r30, 0x01	; 1
    1ab2:	34 e1       	ldi	r19, 0x14	; 20
    1ab4:	30 83       	st	Z, r19
    1ab6:	31 97       	sbiw	r30, 0x01	; 1
    1ab8:	35 e1       	ldi	r19, 0x15	; 21
    1aba:	30 83       	st	Z, r19
    1abc:	31 97       	sbiw	r30, 0x01	; 1
    1abe:	36 e1       	ldi	r19, 0x16	; 22
    1ac0:	30 83       	st	Z, r19
    1ac2:	31 97       	sbiw	r30, 0x01	; 1
    1ac4:	37 e1       	ldi	r19, 0x17	; 23
    1ac6:	30 83       	st	Z, r19
    1ac8:	31 97       	sbiw	r30, 0x01	; 1
    1aca:	38 e1       	ldi	r19, 0x18	; 24
    1acc:	30 83       	st	Z, r19
    1ace:	31 97       	sbiw	r30, 0x01	; 1
    1ad0:	39 e1       	ldi	r19, 0x19	; 25
    1ad2:	30 83       	st	Z, r19
    1ad4:	31 97       	sbiw	r30, 0x01	; 1
    1ad6:	30 e2       	ldi	r19, 0x20	; 32
    1ad8:	30 83       	st	Z, r19
    1ada:	31 97       	sbiw	r30, 0x01	; 1
    1adc:	31 e2       	ldi	r19, 0x21	; 33
    1ade:	30 83       	st	Z, r19
    1ae0:	31 97       	sbiw	r30, 0x01	; 1
    1ae2:	20 83       	st	Z, r18
    1ae4:	31 97       	sbiw	r30, 0x01	; 1
    1ae6:	23 e2       	ldi	r18, 0x23	; 35
    1ae8:	20 83       	st	Z, r18
    1aea:	31 97       	sbiw	r30, 0x01	; 1
    1aec:	40 83       	st	Z, r20
    1aee:	31 97       	sbiw	r30, 0x01	; 1
    1af0:	50 83       	st	Z, r21
    1af2:	31 97       	sbiw	r30, 0x01	; 1
    1af4:	26 e2       	ldi	r18, 0x26	; 38
    1af6:	20 83       	st	Z, r18
    1af8:	31 97       	sbiw	r30, 0x01	; 1
    1afa:	27 e2       	ldi	r18, 0x27	; 39
    1afc:	20 83       	st	Z, r18
    1afe:	31 97       	sbiw	r30, 0x01	; 1
    1b00:	28 e2       	ldi	r18, 0x28	; 40
    1b02:	20 83       	st	Z, r18
    1b04:	31 97       	sbiw	r30, 0x01	; 1
    1b06:	29 e2       	ldi	r18, 0x29	; 41
    1b08:	20 83       	st	Z, r18
    1b0a:	31 97       	sbiw	r30, 0x01	; 1
    1b0c:	20 e3       	ldi	r18, 0x30	; 48
    1b0e:	20 83       	st	Z, r18
    1b10:	31 97       	sbiw	r30, 0x01	; 1
    1b12:	21 e3       	ldi	r18, 0x31	; 49
    1b14:	20 83       	st	Z, r18
    1b16:	89 97       	sbiw	r24, 0x29	; 41
    1b18:	08 95       	ret

00001b1a <xPortStartScheduler>:
    1b1a:	84 df       	rcall	.-248    	; 0x1a24 <prvSetupTimerInterrupt>
    1b1c:	a0 91 b4 12 	lds	r26, 0x12B4	; 0x8012b4 <pxCurrentTCB>
    1b20:	b0 91 b5 12 	lds	r27, 0x12B5	; 0x8012b5 <pxCurrentTCB+0x1>
    1b24:	cd 91       	ld	r28, X+
    1b26:	cd bf       	out	0x3d, r28	; 61
    1b28:	dd 91       	ld	r29, X+
    1b2a:	de bf       	out	0x3e, r29	; 62
    1b2c:	ff 91       	pop	r31
    1b2e:	ef 91       	pop	r30
    1b30:	df 91       	pop	r29
    1b32:	cf 91       	pop	r28
    1b34:	bf 91       	pop	r27
    1b36:	af 91       	pop	r26
    1b38:	9f 91       	pop	r25
    1b3a:	8f 91       	pop	r24
    1b3c:	7f 91       	pop	r23
    1b3e:	6f 91       	pop	r22
    1b40:	5f 91       	pop	r21
    1b42:	4f 91       	pop	r20
    1b44:	3f 91       	pop	r19
    1b46:	2f 91       	pop	r18
    1b48:	1f 91       	pop	r17
    1b4a:	0f 91       	pop	r16
    1b4c:	ff 90       	pop	r15
    1b4e:	ef 90       	pop	r14
    1b50:	df 90       	pop	r13
    1b52:	cf 90       	pop	r12
    1b54:	bf 90       	pop	r11
    1b56:	af 90       	pop	r10
    1b58:	9f 90       	pop	r9
    1b5a:	8f 90       	pop	r8
    1b5c:	7f 90       	pop	r7
    1b5e:	6f 90       	pop	r6
    1b60:	5f 90       	pop	r5
    1b62:	4f 90       	pop	r4
    1b64:	3f 90       	pop	r3
    1b66:	2f 90       	pop	r2
    1b68:	1f 90       	pop	r1
    1b6a:	0f 90       	pop	r0
    1b6c:	0c be       	out	0x3c, r0	; 60
    1b6e:	0f 90       	pop	r0
    1b70:	0b be       	out	0x3b, r0	; 59
    1b72:	0f 90       	pop	r0
    1b74:	0f be       	out	0x3f, r0	; 63
    1b76:	0f 90       	pop	r0
    1b78:	08 95       	ret
    1b7a:	81 e0       	ldi	r24, 0x01	; 1
    1b7c:	08 95       	ret

00001b7e <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    1b7e:	0f 92       	push	r0
    1b80:	0f b6       	in	r0, 0x3f	; 63
    1b82:	f8 94       	cli
    1b84:	0f 92       	push	r0
    1b86:	0b b6       	in	r0, 0x3b	; 59
    1b88:	0f 92       	push	r0
    1b8a:	0c b6       	in	r0, 0x3c	; 60
    1b8c:	0f 92       	push	r0
    1b8e:	1f 92       	push	r1
    1b90:	11 24       	eor	r1, r1
    1b92:	2f 92       	push	r2
    1b94:	3f 92       	push	r3
    1b96:	4f 92       	push	r4
    1b98:	5f 92       	push	r5
    1b9a:	6f 92       	push	r6
    1b9c:	7f 92       	push	r7
    1b9e:	8f 92       	push	r8
    1ba0:	9f 92       	push	r9
    1ba2:	af 92       	push	r10
    1ba4:	bf 92       	push	r11
    1ba6:	cf 92       	push	r12
    1ba8:	df 92       	push	r13
    1baa:	ef 92       	push	r14
    1bac:	ff 92       	push	r15
    1bae:	0f 93       	push	r16
    1bb0:	1f 93       	push	r17
    1bb2:	2f 93       	push	r18
    1bb4:	3f 93       	push	r19
    1bb6:	4f 93       	push	r20
    1bb8:	5f 93       	push	r21
    1bba:	6f 93       	push	r22
    1bbc:	7f 93       	push	r23
    1bbe:	8f 93       	push	r24
    1bc0:	9f 93       	push	r25
    1bc2:	af 93       	push	r26
    1bc4:	bf 93       	push	r27
    1bc6:	cf 93       	push	r28
    1bc8:	df 93       	push	r29
    1bca:	ef 93       	push	r30
    1bcc:	ff 93       	push	r31
    1bce:	a0 91 b4 12 	lds	r26, 0x12B4	; 0x8012b4 <pxCurrentTCB>
    1bd2:	b0 91 b5 12 	lds	r27, 0x12B5	; 0x8012b5 <pxCurrentTCB+0x1>
    1bd6:	0d b6       	in	r0, 0x3d	; 61
    1bd8:	0d 92       	st	X+, r0
    1bda:	0e b6       	in	r0, 0x3e	; 62
    1bdc:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    1bde:	86 d3       	rcall	.+1804   	; 0x22ec <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1be0:	a0 91 b4 12 	lds	r26, 0x12B4	; 0x8012b4 <pxCurrentTCB>
    1be4:	b0 91 b5 12 	lds	r27, 0x12B5	; 0x8012b5 <pxCurrentTCB+0x1>
    1be8:	cd 91       	ld	r28, X+
    1bea:	cd bf       	out	0x3d, r28	; 61
    1bec:	dd 91       	ld	r29, X+
    1bee:	de bf       	out	0x3e, r29	; 62
    1bf0:	ff 91       	pop	r31
    1bf2:	ef 91       	pop	r30
    1bf4:	df 91       	pop	r29
    1bf6:	cf 91       	pop	r28
    1bf8:	bf 91       	pop	r27
    1bfa:	af 91       	pop	r26
    1bfc:	9f 91       	pop	r25
    1bfe:	8f 91       	pop	r24
    1c00:	7f 91       	pop	r23
    1c02:	6f 91       	pop	r22
    1c04:	5f 91       	pop	r21
    1c06:	4f 91       	pop	r20
    1c08:	3f 91       	pop	r19
    1c0a:	2f 91       	pop	r18
    1c0c:	1f 91       	pop	r17
    1c0e:	0f 91       	pop	r16
    1c10:	ff 90       	pop	r15
    1c12:	ef 90       	pop	r14
    1c14:	df 90       	pop	r13
    1c16:	cf 90       	pop	r12
    1c18:	bf 90       	pop	r11
    1c1a:	af 90       	pop	r10
    1c1c:	9f 90       	pop	r9
    1c1e:	8f 90       	pop	r8
    1c20:	7f 90       	pop	r7
    1c22:	6f 90       	pop	r6
    1c24:	5f 90       	pop	r5
    1c26:	4f 90       	pop	r4
    1c28:	3f 90       	pop	r3
    1c2a:	2f 90       	pop	r2
    1c2c:	1f 90       	pop	r1
    1c2e:	0f 90       	pop	r0
    1c30:	0c be       	out	0x3c, r0	; 60
    1c32:	0f 90       	pop	r0
    1c34:	0b be       	out	0x3b, r0	; 59
    1c36:	0f 90       	pop	r0
    1c38:	0f be       	out	0x3f, r0	; 63
    1c3a:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1c3c:	08 95       	ret

00001c3e <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    1c3e:	0f 92       	push	r0
    1c40:	0f b6       	in	r0, 0x3f	; 63
    1c42:	f8 94       	cli
    1c44:	0f 92       	push	r0
    1c46:	0b b6       	in	r0, 0x3b	; 59
    1c48:	0f 92       	push	r0
    1c4a:	0c b6       	in	r0, 0x3c	; 60
    1c4c:	0f 92       	push	r0
    1c4e:	1f 92       	push	r1
    1c50:	11 24       	eor	r1, r1
    1c52:	2f 92       	push	r2
    1c54:	3f 92       	push	r3
    1c56:	4f 92       	push	r4
    1c58:	5f 92       	push	r5
    1c5a:	6f 92       	push	r6
    1c5c:	7f 92       	push	r7
    1c5e:	8f 92       	push	r8
    1c60:	9f 92       	push	r9
    1c62:	af 92       	push	r10
    1c64:	bf 92       	push	r11
    1c66:	cf 92       	push	r12
    1c68:	df 92       	push	r13
    1c6a:	ef 92       	push	r14
    1c6c:	ff 92       	push	r15
    1c6e:	0f 93       	push	r16
    1c70:	1f 93       	push	r17
    1c72:	2f 93       	push	r18
    1c74:	3f 93       	push	r19
    1c76:	4f 93       	push	r20
    1c78:	5f 93       	push	r21
    1c7a:	6f 93       	push	r22
    1c7c:	7f 93       	push	r23
    1c7e:	8f 93       	push	r24
    1c80:	9f 93       	push	r25
    1c82:	af 93       	push	r26
    1c84:	bf 93       	push	r27
    1c86:	cf 93       	push	r28
    1c88:	df 93       	push	r29
    1c8a:	ef 93       	push	r30
    1c8c:	ff 93       	push	r31
    1c8e:	a0 91 b4 12 	lds	r26, 0x12B4	; 0x8012b4 <pxCurrentTCB>
    1c92:	b0 91 b5 12 	lds	r27, 0x12B5	; 0x8012b5 <pxCurrentTCB+0x1>
    1c96:	0d b6       	in	r0, 0x3d	; 61
    1c98:	0d 92       	st	X+, r0
    1c9a:	0e b6       	in	r0, 0x3e	; 62
    1c9c:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    1c9e:	f1 d1       	rcall	.+994    	; 0x2082 <vTaskIncrementTick>
	vTaskSwitchContext();
    1ca0:	25 d3       	rcall	.+1610   	; 0x22ec <vTaskSwitchContext>
    1ca2:	a0 91 b4 12 	lds	r26, 0x12B4	; 0x8012b4 <pxCurrentTCB>
	portRESTORE_CONTEXT();
    1ca6:	b0 91 b5 12 	lds	r27, 0x12B5	; 0x8012b5 <pxCurrentTCB+0x1>
    1caa:	cd 91       	ld	r28, X+
    1cac:	cd bf       	out	0x3d, r28	; 61
    1cae:	dd 91       	ld	r29, X+
    1cb0:	de bf       	out	0x3e, r29	; 62
    1cb2:	ff 91       	pop	r31
    1cb4:	ef 91       	pop	r30
    1cb6:	df 91       	pop	r29
    1cb8:	cf 91       	pop	r28
    1cba:	bf 91       	pop	r27
    1cbc:	af 91       	pop	r26
    1cbe:	9f 91       	pop	r25
    1cc0:	8f 91       	pop	r24
    1cc2:	7f 91       	pop	r23
    1cc4:	6f 91       	pop	r22
    1cc6:	5f 91       	pop	r21
    1cc8:	4f 91       	pop	r20
    1cca:	3f 91       	pop	r19
    1ccc:	2f 91       	pop	r18
    1cce:	1f 91       	pop	r17
    1cd0:	0f 91       	pop	r16
    1cd2:	ff 90       	pop	r15
    1cd4:	ef 90       	pop	r14
    1cd6:	df 90       	pop	r13
    1cd8:	cf 90       	pop	r12
    1cda:	bf 90       	pop	r11
    1cdc:	af 90       	pop	r10
    1cde:	9f 90       	pop	r9
    1ce0:	8f 90       	pop	r8
    1ce2:	7f 90       	pop	r7
    1ce4:	6f 90       	pop	r6
    1ce6:	5f 90       	pop	r5
    1ce8:	4f 90       	pop	r4
    1cea:	3f 90       	pop	r3
    1cec:	2f 90       	pop	r2
    1cee:	1f 90       	pop	r1
    1cf0:	0f 90       	pop	r0
    1cf2:	0c be       	out	0x3c, r0	; 60
    1cf4:	0f 90       	pop	r0
    1cf6:	0b be       	out	0x3b, r0	; 59
    1cf8:	0f 90       	pop	r0
    1cfa:	0f be       	out	0x3f, r0	; 63
    1cfc:	0f 90       	pop	r0
    1cfe:	08 95       	ret

00001d00 <__vector_21>:
	asm volatile ( "ret" );
    1d00:	9e df       	rcall	.-196    	; 0x1c3e <vPortYieldFromTick>
//	void SIG_OUTPUT_COMPARE1A( void )
	void TIMER0_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER0_COMPA_vect( void )
	{
		vPortYieldFromTick();
		asm volatile ( "reti" );
    1d02:	18 95       	reti

00001d04 <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    1d04:	cf 93       	push	r28
    1d06:	df 93       	push	r29
    1d08:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
    1d0a:	b5 d1       	rcall	.+874    	; 0x2076 <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
    1d0c:	20 91 df 02 	lds	r18, 0x02DF	; 0x8002df <xNextFreeByte>
    1d10:	30 91 e0 02 	lds	r19, 0x02E0	; 0x8002e0 <xNextFreeByte+0x1>
    1d14:	c9 01       	movw	r24, r18
    1d16:	8c 0f       	add	r24, r28
    1d18:	9d 1f       	adc	r25, r29
    1d1a:	80 3a       	cpi	r24, 0xA0	; 160
    1d1c:	4f e0       	ldi	r20, 0x0F	; 15
    1d1e:	94 07       	cpc	r25, r20
    1d20:	58 f4       	brcc	.+22     	; 0x1d38 <pvPortMalloc+0x34>
    1d22:	28 17       	cp	r18, r24
    1d24:	39 07       	cpc	r19, r25
    1d26:	58 f4       	brcc	.+22     	; 0x1d3e <pvPortMalloc+0x3a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
    1d28:	e9 01       	movw	r28, r18
    1d2a:	cf 51       	subi	r28, 0x1F	; 31
    1d2c:	dd 4f       	sbci	r29, 0xFD	; 253
			xNextFreeByte += xWantedSize;			
    1d2e:	90 93 e0 02 	sts	0x02E0, r25	; 0x8002e0 <xNextFreeByte+0x1>
    1d32:	80 93 df 02 	sts	0x02DF, r24	; 0x8002df <xNextFreeByte>
    1d36:	05 c0       	rjmp	.+10     	; 0x1d42 <pvPortMalloc+0x3e>
static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL; 
    1d38:	c0 e0       	ldi	r28, 0x00	; 0
    1d3a:	d0 e0       	ldi	r29, 0x00	; 0
    1d3c:	02 c0       	rjmp	.+4      	; 0x1d42 <pvPortMalloc+0x3e>
    1d3e:	c0 e0       	ldi	r28, 0x00	; 0
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
			xNextFreeByte += xWantedSize;			
		}	
	}
	xTaskResumeAll();
    1d40:	d0 e0       	ldi	r29, 0x00	; 0
    1d42:	46 d2       	rcall	.+1164   	; 0x21d0 <xTaskResumeAll>
		}
	}
	#endif	

	return pvReturn;
}
    1d44:	ce 01       	movw	r24, r28
    1d46:	df 91       	pop	r29
    1d48:	cf 91       	pop	r28
    1d4a:	08 95       	ret

00001d4c <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    1d4c:	08 95       	ret

00001d4e <prvIdleTask>:
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
		}
	}
    1d4e:	80 91 ab 12 	lds	r24, 0x12AB	; 0x8012ab <pxReadyTasksLists>
    1d52:	82 30       	cpi	r24, 0x02	; 2
    1d54:	e0 f3       	brcs	.-8      	; 0x1d4e <prvIdleTask>
    1d56:	13 df       	rcall	.-474    	; 0x1b7e <vPortYield>
    1d58:	fa cf       	rjmp	.-12     	; 0x1d4e <prvIdleTask>

00001d5a <prvAllocateTCBAndStack>:
    1d5a:	ef 92       	push	r14
    1d5c:	ff 92       	push	r15
    1d5e:	0f 93       	push	r16
    1d60:	1f 93       	push	r17
    1d62:	cf 93       	push	r28
    1d64:	df 93       	push	r29
    1d66:	7c 01       	movw	r14, r24
    1d68:	eb 01       	movw	r28, r22
    1d6a:	81 e2       	ldi	r24, 0x21	; 33
    1d6c:	90 e0       	ldi	r25, 0x00	; 0
    1d6e:	ca df       	rcall	.-108    	; 0x1d04 <pvPortMalloc>
    1d70:	8c 01       	movw	r16, r24
    1d72:	89 2b       	or	r24, r25
    1d74:	a9 f0       	breq	.+42     	; 0x1da0 <prvAllocateTCBAndStack+0x46>
    1d76:	20 97       	sbiw	r28, 0x00	; 0
    1d78:	19 f4       	brne	.+6      	; 0x1d80 <prvAllocateTCBAndStack+0x26>
    1d7a:	c7 01       	movw	r24, r14
    1d7c:	c3 df       	rcall	.-122    	; 0x1d04 <pvPortMalloc>
    1d7e:	01 c0       	rjmp	.+2      	; 0x1d82 <prvAllocateTCBAndStack+0x28>
    1d80:	ce 01       	movw	r24, r28
    1d82:	f8 01       	movw	r30, r16
    1d84:	90 8f       	std	Z+24, r25	; 0x18
    1d86:	87 8b       	std	Z+23, r24	; 0x17
    1d88:	00 97       	sbiw	r24, 0x00	; 0
    1d8a:	29 f4       	brne	.+10     	; 0x1d96 <prvAllocateTCBAndStack+0x3c>
    1d8c:	c8 01       	movw	r24, r16
    1d8e:	de df       	rcall	.-68     	; 0x1d4c <vPortFree>
    1d90:	00 e0       	ldi	r16, 0x00	; 0
    1d92:	10 e0       	ldi	r17, 0x00	; 0
    1d94:	05 c0       	rjmp	.+10     	; 0x1da0 <prvAllocateTCBAndStack+0x46>
    1d96:	a7 01       	movw	r20, r14
    1d98:	65 ea       	ldi	r22, 0xA5	; 165
    1d9a:	70 e0       	ldi	r23, 0x00	; 0
    1d9c:	0e 94 cd 18 	call	0x319a	; 0x319a <memset>
    1da0:	c8 01       	movw	r24, r16
    1da2:	df 91       	pop	r29
    1da4:	cf 91       	pop	r28
    1da6:	1f 91       	pop	r17
    1da8:	0f 91       	pop	r16
    1daa:	ff 90       	pop	r15
    1dac:	ef 90       	pop	r14
    1dae:	08 95       	ret

00001db0 <prvInitialiseTCBVariables>:
    1db0:	1f 93       	push	r17
    1db2:	cf 93       	push	r28
    1db4:	df 93       	push	r29
    1db6:	ec 01       	movw	r28, r24
    1db8:	14 2f       	mov	r17, r20
    1dba:	48 e0       	ldi	r20, 0x08	; 8
    1dbc:	50 e0       	ldi	r21, 0x00	; 0
    1dbe:	49 96       	adiw	r24, 0x19	; 25
    1dc0:	0e 94 d4 18 	call	0x31a8	; 0x31a8 <strncpy>
    1dc4:	18 a2       	std	Y+32, r1	; 0x20
    1dc6:	11 11       	cpse	r17, r1
    1dc8:	10 e0       	ldi	r17, 0x00	; 0
    1dca:	1e 8b       	std	Y+22, r17	; 0x16
    1dcc:	ce 01       	movw	r24, r28
    1dce:	02 96       	adiw	r24, 0x02	; 2
    1dd0:	a7 dd       	rcall	.-1202   	; 0x1920 <vListInitialiseItem>
    1dd2:	ce 01       	movw	r24, r28
    1dd4:	0c 96       	adiw	r24, 0x0c	; 12
    1dd6:	a4 dd       	rcall	.-1208   	; 0x1920 <vListInitialiseItem>
    1dd8:	d9 87       	std	Y+9, r29	; 0x09
    1dda:	c8 87       	std	Y+8, r28	; 0x08
    1ddc:	81 e0       	ldi	r24, 0x01	; 1
    1dde:	90 e0       	ldi	r25, 0x00	; 0
    1de0:	81 1b       	sub	r24, r17
    1de2:	91 09       	sbc	r25, r1
    1de4:	9d 87       	std	Y+13, r25	; 0x0d
    1de6:	8c 87       	std	Y+12, r24	; 0x0c
    1de8:	db 8b       	std	Y+19, r29	; 0x13
    1dea:	ca 8b       	std	Y+18, r28	; 0x12
    1dec:	df 91       	pop	r29
    1dee:	cf 91       	pop	r28
    1df0:	1f 91       	pop	r17
    1df2:	08 95       	ret

00001df4 <prvInitialiseTaskLists>:
    1df4:	cf 93       	push	r28
    1df6:	c0 e0       	ldi	r28, 0x00	; 0
    1df8:	0f c0       	rjmp	.+30     	; 0x1e18 <prvInitialiseTaskLists+0x24>
    1dfa:	8c 2f       	mov	r24, r28
    1dfc:	90 e0       	ldi	r25, 0x00	; 0
    1dfe:	9c 01       	movw	r18, r24
    1e00:	22 0f       	add	r18, r18
    1e02:	33 1f       	adc	r19, r19
    1e04:	22 0f       	add	r18, r18
    1e06:	33 1f       	adc	r19, r19
    1e08:	22 0f       	add	r18, r18
    1e0a:	33 1f       	adc	r19, r19
    1e0c:	82 0f       	add	r24, r18
    1e0e:	93 1f       	adc	r25, r19
    1e10:	85 55       	subi	r24, 0x55	; 85
    1e12:	9d 4e       	sbci	r25, 0xED	; 237
    1e14:	77 dd       	rcall	.-1298   	; 0x1904 <vListInitialise>
    1e16:	cf 5f       	subi	r28, 0xFF	; 255
    1e18:	cc 23       	and	r28, r28
    1e1a:	79 f3       	breq	.-34     	; 0x1dfa <prvInitialiseTaskLists+0x6>
    1e1c:	82 ea       	ldi	r24, 0xA2	; 162
    1e1e:	92 e1       	ldi	r25, 0x12	; 18
    1e20:	71 dd       	rcall	.-1310   	; 0x1904 <vListInitialise>
    1e22:	89 e9       	ldi	r24, 0x99	; 153
    1e24:	92 e1       	ldi	r25, 0x12	; 18
    1e26:	6e dd       	rcall	.-1316   	; 0x1904 <vListInitialise>
    1e28:	8c e8       	ldi	r24, 0x8C	; 140
    1e2a:	92 e1       	ldi	r25, 0x12	; 18
    1e2c:	6b dd       	rcall	.-1322   	; 0x1904 <vListInitialise>
    1e2e:	82 ea       	ldi	r24, 0xA2	; 162
    1e30:	92 e1       	ldi	r25, 0x12	; 18
    1e32:	90 93 98 12 	sts	0x1298, r25	; 0x801298 <pxDelayedTaskList+0x1>
    1e36:	80 93 97 12 	sts	0x1297, r24	; 0x801297 <pxDelayedTaskList>
    1e3a:	89 e9       	ldi	r24, 0x99	; 153
    1e3c:	92 e1       	ldi	r25, 0x12	; 18
    1e3e:	90 93 96 12 	sts	0x1296, r25	; 0x801296 <pxOverflowDelayedTaskList+0x1>
    1e42:	80 93 95 12 	sts	0x1295, r24	; 0x801295 <pxOverflowDelayedTaskList>
    1e46:	cf 91       	pop	r28
    1e48:	08 95       	ret

00001e4a <prvAddCurrentTaskToDelayedList>:
    1e4a:	cf 93       	push	r28
    1e4c:	df 93       	push	r29
    1e4e:	ec 01       	movw	r28, r24
    1e50:	e0 91 b4 12 	lds	r30, 0x12B4	; 0x8012b4 <pxCurrentTCB>
    1e54:	f0 91 b5 12 	lds	r31, 0x12B5	; 0x8012b5 <pxCurrentTCB+0x1>
    1e58:	93 83       	std	Z+3, r25	; 0x03
    1e5a:	82 83       	std	Z+2, r24	; 0x02
    1e5c:	80 91 89 12 	lds	r24, 0x1289	; 0x801289 <xTickCount>
    1e60:	90 91 8a 12 	lds	r25, 0x128A	; 0x80128a <xTickCount+0x1>
    1e64:	c8 17       	cp	r28, r24
    1e66:	d9 07       	cpc	r29, r25
    1e68:	60 f4       	brcc	.+24     	; 0x1e82 <prvAddCurrentTaskToDelayedList+0x38>
    1e6a:	60 91 b4 12 	lds	r22, 0x12B4	; 0x8012b4 <pxCurrentTCB>
    1e6e:	70 91 b5 12 	lds	r23, 0x12B5	; 0x8012b5 <pxCurrentTCB+0x1>
    1e72:	80 91 95 12 	lds	r24, 0x1295	; 0x801295 <pxOverflowDelayedTaskList>
    1e76:	90 91 96 12 	lds	r25, 0x1296	; 0x801296 <pxOverflowDelayedTaskList+0x1>
    1e7a:	6e 5f       	subi	r22, 0xFE	; 254
    1e7c:	7f 4f       	sbci	r23, 0xFF	; 255
    1e7e:	7b dd       	rcall	.-1290   	; 0x1976 <vListInsert>
    1e80:	16 c0       	rjmp	.+44     	; 0x1eae <prvAddCurrentTaskToDelayedList+0x64>
    1e82:	60 91 b4 12 	lds	r22, 0x12B4	; 0x8012b4 <pxCurrentTCB>
    1e86:	70 91 b5 12 	lds	r23, 0x12B5	; 0x8012b5 <pxCurrentTCB+0x1>
    1e8a:	80 91 97 12 	lds	r24, 0x1297	; 0x801297 <pxDelayedTaskList>
    1e8e:	90 91 98 12 	lds	r25, 0x1298	; 0x801298 <pxDelayedTaskList+0x1>
    1e92:	6e 5f       	subi	r22, 0xFE	; 254
    1e94:	7f 4f       	sbci	r23, 0xFF	; 255
    1e96:	6f dd       	rcall	.-1314   	; 0x1976 <vListInsert>
    1e98:	80 91 0b 02 	lds	r24, 0x020B	; 0x80020b <xNextTaskUnblockTime>
    1e9c:	90 91 0c 02 	lds	r25, 0x020C	; 0x80020c <xNextTaskUnblockTime+0x1>
    1ea0:	c8 17       	cp	r28, r24
    1ea2:	d9 07       	cpc	r29, r25
    1ea4:	20 f4       	brcc	.+8      	; 0x1eae <prvAddCurrentTaskToDelayedList+0x64>
    1ea6:	d0 93 0c 02 	sts	0x020C, r29	; 0x80020c <xNextTaskUnblockTime+0x1>
    1eaa:	c0 93 0b 02 	sts	0x020B, r28	; 0x80020b <xNextTaskUnblockTime>
    1eae:	df 91       	pop	r29
    1eb0:	cf 91       	pop	r28
    1eb2:	08 95       	ret

00001eb4 <xTaskGenericCreate>:
    1eb4:	2f 92       	push	r2
    1eb6:	3f 92       	push	r3
    1eb8:	4f 92       	push	r4
    1eba:	5f 92       	push	r5
    1ebc:	7f 92       	push	r7
    1ebe:	8f 92       	push	r8
    1ec0:	9f 92       	push	r9
    1ec2:	af 92       	push	r10
    1ec4:	bf 92       	push	r11
    1ec6:	cf 92       	push	r12
    1ec8:	df 92       	push	r13
    1eca:	ef 92       	push	r14
    1ecc:	ff 92       	push	r15
    1ece:	0f 93       	push	r16
    1ed0:	1f 93       	push	r17
    1ed2:	cf 93       	push	r28
    1ed4:	df 93       	push	r29
    1ed6:	00 d0       	rcall	.+0      	; 0x1ed8 <xTaskGenericCreate+0x24>
    1ed8:	1f 92       	push	r1
    1eda:	cd b7       	in	r28, 0x3d	; 61
    1edc:	de b7       	in	r29, 0x3e	; 62
    1ede:	9a 83       	std	Y+2, r25	; 0x02
    1ee0:	89 83       	std	Y+1, r24	; 0x01
    1ee2:	4b 01       	movw	r8, r22
    1ee4:	5c 83       	std	Y+4, r21	; 0x04
    1ee6:	4b 83       	std	Y+3, r20	; 0x03
    1ee8:	19 01       	movw	r2, r18
    1eea:	70 2e       	mov	r7, r16
    1eec:	b6 01       	movw	r22, r12
    1eee:	25 01       	movw	r4, r10
    1ef0:	ca 01       	movw	r24, r20
    1ef2:	33 df       	rcall	.-410    	; 0x1d5a <prvAllocateTCBAndStack>
    1ef4:	5c 01       	movw	r10, r24
    1ef6:	00 97       	sbiw	r24, 0x00	; 0
    1ef8:	09 f4       	brne	.+2      	; 0x1efc <xTaskGenericCreate+0x48>
    1efa:	6c c0       	rjmp	.+216    	; 0x1fd4 <xTaskGenericCreate+0x120>
    1efc:	fc 01       	movw	r30, r24
    1efe:	c7 88       	ldd	r12, Z+23	; 0x17
    1f00:	d0 8c       	ldd	r13, Z+24	; 0x18
    1f02:	8b 81       	ldd	r24, Y+3	; 0x03
    1f04:	9c 81       	ldd	r25, Y+4	; 0x04
    1f06:	01 97       	sbiw	r24, 0x01	; 1
    1f08:	c8 0e       	add	r12, r24
    1f0a:	d9 1e       	adc	r13, r25
    1f0c:	0b 81       	ldd	r16, Y+3	; 0x03
    1f0e:	1c 81       	ldd	r17, Y+4	; 0x04
    1f10:	92 01       	movw	r18, r4
    1f12:	47 2d       	mov	r20, r7
    1f14:	b4 01       	movw	r22, r8
    1f16:	c5 01       	movw	r24, r10
    1f18:	4b df       	rcall	.-362    	; 0x1db0 <prvInitialiseTCBVariables>
    1f1a:	a1 01       	movw	r20, r2
    1f1c:	69 81       	ldd	r22, Y+1	; 0x01
    1f1e:	7a 81       	ldd	r23, Y+2	; 0x02
    1f20:	c6 01       	movw	r24, r12
    1f22:	89 dd       	rcall	.-1262   	; 0x1a36 <pxPortInitialiseStack>
    1f24:	f5 01       	movw	r30, r10
    1f26:	91 83       	std	Z+1, r25	; 0x01
    1f28:	80 83       	st	Z, r24
    1f2a:	e1 14       	cp	r14, r1
    1f2c:	f1 04       	cpc	r15, r1
    1f2e:	19 f0       	breq	.+6      	; 0x1f36 <xTaskGenericCreate+0x82>
    1f30:	f7 01       	movw	r30, r14
    1f32:	b1 82       	std	Z+1, r11	; 0x01
    1f34:	a0 82       	st	Z, r10
    1f36:	0f b6       	in	r0, 0x3f	; 63
    1f38:	f8 94       	cli
    1f3a:	0f 92       	push	r0
    1f3c:	80 91 8b 12 	lds	r24, 0x128B	; 0x80128b <uxCurrentNumberOfTasks>
    1f40:	8f 5f       	subi	r24, 0xFF	; 255
    1f42:	80 93 8b 12 	sts	0x128B, r24	; 0x80128b <uxCurrentNumberOfTasks>
    1f46:	80 91 b4 12 	lds	r24, 0x12B4	; 0x8012b4 <pxCurrentTCB>
    1f4a:	90 91 b5 12 	lds	r25, 0x12B5	; 0x8012b5 <pxCurrentTCB+0x1>
    1f4e:	89 2b       	or	r24, r25
    1f50:	51 f4       	brne	.+20     	; 0x1f66 <xTaskGenericCreate+0xb2>
    1f52:	b0 92 b5 12 	sts	0x12B5, r11	; 0x8012b5 <pxCurrentTCB+0x1>
    1f56:	a0 92 b4 12 	sts	0x12B4, r10	; 0x8012b4 <pxCurrentTCB>
    1f5a:	80 91 8b 12 	lds	r24, 0x128B	; 0x80128b <uxCurrentNumberOfTasks>
    1f5e:	81 30       	cpi	r24, 0x01	; 1
    1f60:	89 f4       	brne	.+34     	; 0x1f84 <xTaskGenericCreate+0xd0>
    1f62:	48 df       	rcall	.-368    	; 0x1df4 <prvInitialiseTaskLists>
    1f64:	0f c0       	rjmp	.+30     	; 0x1f84 <xTaskGenericCreate+0xd0>
    1f66:	80 91 86 12 	lds	r24, 0x1286	; 0x801286 <xSchedulerRunning>
    1f6a:	81 11       	cpse	r24, r1
    1f6c:	0b c0       	rjmp	.+22     	; 0x1f84 <xTaskGenericCreate+0xd0>
    1f6e:	e0 91 b4 12 	lds	r30, 0x12B4	; 0x8012b4 <pxCurrentTCB>
    1f72:	f0 91 b5 12 	lds	r31, 0x12B5	; 0x8012b5 <pxCurrentTCB+0x1>
    1f76:	86 89       	ldd	r24, Z+22	; 0x16
    1f78:	78 16       	cp	r7, r24
    1f7a:	20 f0       	brcs	.+8      	; 0x1f84 <xTaskGenericCreate+0xd0>
    1f7c:	b0 92 b5 12 	sts	0x12B5, r11	; 0x8012b5 <pxCurrentTCB+0x1>
    1f80:	a0 92 b4 12 	sts	0x12B4, r10	; 0x8012b4 <pxCurrentTCB>
    1f84:	f5 01       	movw	r30, r10
    1f86:	86 89       	ldd	r24, Z+22	; 0x16
    1f88:	90 91 88 12 	lds	r25, 0x1288	; 0x801288 <uxTopUsedPriority>
    1f8c:	98 17       	cp	r25, r24
    1f8e:	10 f4       	brcc	.+4      	; 0x1f94 <xTaskGenericCreate+0xe0>
    1f90:	80 93 88 12 	sts	0x1288, r24	; 0x801288 <uxTopUsedPriority>
    1f94:	90 91 81 12 	lds	r25, 0x1281	; 0x801281 <uxTCBNumber>
    1f98:	9f 5f       	subi	r25, 0xFF	; 255
    1f9a:	90 93 81 12 	sts	0x1281, r25	; 0x801281 <uxTCBNumber>
    1f9e:	90 91 87 12 	lds	r25, 0x1287	; 0x801287 <uxTopReadyPriority>
    1fa2:	98 17       	cp	r25, r24
    1fa4:	10 f4       	brcc	.+4      	; 0x1faa <xTaskGenericCreate+0xf6>
    1fa6:	80 93 87 12 	sts	0x1287, r24	; 0x801287 <uxTopReadyPriority>
    1faa:	90 e0       	ldi	r25, 0x00	; 0
    1fac:	b5 01       	movw	r22, r10
    1fae:	6e 5f       	subi	r22, 0xFE	; 254
    1fb0:	7f 4f       	sbci	r23, 0xFF	; 255
    1fb2:	9c 01       	movw	r18, r24
    1fb4:	22 0f       	add	r18, r18
    1fb6:	33 1f       	adc	r19, r19
    1fb8:	22 0f       	add	r18, r18
    1fba:	33 1f       	adc	r19, r19
    1fbc:	22 0f       	add	r18, r18
    1fbe:	33 1f       	adc	r19, r19
    1fc0:	82 0f       	add	r24, r18
    1fc2:	93 1f       	adc	r25, r19
    1fc4:	85 55       	subi	r24, 0x55	; 85
    1fc6:	9d 4e       	sbci	r25, 0xED	; 237
    1fc8:	af dc       	rcall	.-1698   	; 0x1928 <vListInsertEnd>
    1fca:	0f 90       	pop	r0
    1fcc:	0f be       	out	0x3f, r0	; 63
    1fce:	f1 e0       	ldi	r31, 0x01	; 1
    1fd0:	f9 83       	std	Y+1, r31	; 0x01
    1fd2:	02 c0       	rjmp	.+4      	; 0x1fd8 <xTaskGenericCreate+0x124>
    1fd4:	8f ef       	ldi	r24, 0xFF	; 255
    1fd6:	89 83       	std	Y+1, r24	; 0x01
    1fd8:	e9 81       	ldd	r30, Y+1	; 0x01
    1fda:	e1 30       	cpi	r30, 0x01	; 1
    1fdc:	61 f4       	brne	.+24     	; 0x1ff6 <xTaskGenericCreate+0x142>
    1fde:	80 91 86 12 	lds	r24, 0x1286	; 0x801286 <xSchedulerRunning>
    1fe2:	88 23       	and	r24, r24
    1fe4:	41 f0       	breq	.+16     	; 0x1ff6 <xTaskGenericCreate+0x142>
    1fe6:	e0 91 b4 12 	lds	r30, 0x12B4	; 0x8012b4 <pxCurrentTCB>
    1fea:	f0 91 b5 12 	lds	r31, 0x12B5	; 0x8012b5 <pxCurrentTCB+0x1>
    1fee:	86 89       	ldd	r24, Z+22	; 0x16
    1ff0:	87 15       	cp	r24, r7
    1ff2:	08 f4       	brcc	.+2      	; 0x1ff6 <xTaskGenericCreate+0x142>
    1ff4:	c4 dd       	rcall	.-1144   	; 0x1b7e <vPortYield>
    1ff6:	89 81       	ldd	r24, Y+1	; 0x01
    1ff8:	0f 90       	pop	r0
    1ffa:	0f 90       	pop	r0
    1ffc:	0f 90       	pop	r0
    1ffe:	0f 90       	pop	r0
    2000:	df 91       	pop	r29
    2002:	cf 91       	pop	r28
    2004:	1f 91       	pop	r17
    2006:	0f 91       	pop	r16
    2008:	ff 90       	pop	r15
    200a:	ef 90       	pop	r14
    200c:	df 90       	pop	r13
    200e:	cf 90       	pop	r12
    2010:	bf 90       	pop	r11
    2012:	af 90       	pop	r10
    2014:	9f 90       	pop	r9
    2016:	8f 90       	pop	r8
    2018:	7f 90       	pop	r7
    201a:	5f 90       	pop	r5
    201c:	4f 90       	pop	r4
    201e:	3f 90       	pop	r3
    2020:	2f 90       	pop	r2
    2022:	08 95       	ret

00002024 <vTaskStartScheduler>:
    2024:	af 92       	push	r10
    2026:	bf 92       	push	r11
    2028:	cf 92       	push	r12
    202a:	df 92       	push	r13
    202c:	ef 92       	push	r14
    202e:	ff 92       	push	r15
    2030:	0f 93       	push	r16
    2032:	a1 2c       	mov	r10, r1
    2034:	b1 2c       	mov	r11, r1
    2036:	c1 2c       	mov	r12, r1
    2038:	d1 2c       	mov	r13, r1
    203a:	e1 2c       	mov	r14, r1
    203c:	f1 2c       	mov	r15, r1
    203e:	00 e0       	ldi	r16, 0x00	; 0
    2040:	20 e0       	ldi	r18, 0x00	; 0
    2042:	30 e0       	ldi	r19, 0x00	; 0
    2044:	45 e5       	ldi	r20, 0x55	; 85
    2046:	50 e0       	ldi	r21, 0x00	; 0
    2048:	66 eb       	ldi	r22, 0xB6	; 182
    204a:	72 e0       	ldi	r23, 0x02	; 2
    204c:	87 ea       	ldi	r24, 0xA7	; 167
    204e:	9e e0       	ldi	r25, 0x0E	; 14
    2050:	31 df       	rcall	.-414    	; 0x1eb4 <xTaskGenericCreate>
    2052:	81 30       	cpi	r24, 0x01	; 1
    2054:	41 f4       	brne	.+16     	; 0x2066 <vTaskStartScheduler+0x42>
    2056:	f8 94       	cli
    2058:	80 93 86 12 	sts	0x1286, r24	; 0x801286 <xSchedulerRunning>
    205c:	10 92 8a 12 	sts	0x128A, r1	; 0x80128a <xTickCount+0x1>
    2060:	10 92 89 12 	sts	0x1289, r1	; 0x801289 <xTickCount>
    2064:	5a dd       	rcall	.-1356   	; 0x1b1a <xPortStartScheduler>
    2066:	0f 91       	pop	r16
    2068:	ff 90       	pop	r15
    206a:	ef 90       	pop	r14
    206c:	df 90       	pop	r13
    206e:	cf 90       	pop	r12
    2070:	bf 90       	pop	r11
    2072:	af 90       	pop	r10
    2074:	08 95       	ret

00002076 <vTaskSuspendAll>:
    2076:	80 91 85 12 	lds	r24, 0x1285	; 0x801285 <uxSchedulerSuspended>
    207a:	8f 5f       	subi	r24, 0xFF	; 255
    207c:	80 93 85 12 	sts	0x1285, r24	; 0x801285 <uxSchedulerSuspended>
    2080:	08 95       	ret

00002082 <vTaskIncrementTick>:
    2082:	0f 93       	push	r16
    2084:	1f 93       	push	r17
    2086:	cf 93       	push	r28
    2088:	df 93       	push	r29
    208a:	80 91 85 12 	lds	r24, 0x1285	; 0x801285 <uxSchedulerSuspended>
    208e:	81 11       	cpse	r24, r1
    2090:	95 c0       	rjmp	.+298    	; 0x21bc <vTaskIncrementTick+0x13a>
    2092:	80 91 89 12 	lds	r24, 0x1289	; 0x801289 <xTickCount>
    2096:	90 91 8a 12 	lds	r25, 0x128A	; 0x80128a <xTickCount+0x1>
    209a:	01 96       	adiw	r24, 0x01	; 1
    209c:	90 93 8a 12 	sts	0x128A, r25	; 0x80128a <xTickCount+0x1>
    20a0:	80 93 89 12 	sts	0x1289, r24	; 0x801289 <xTickCount>
    20a4:	80 91 89 12 	lds	r24, 0x1289	; 0x801289 <xTickCount>
    20a8:	90 91 8a 12 	lds	r25, 0x128A	; 0x80128a <xTickCount+0x1>
    20ac:	89 2b       	or	r24, r25
    20ae:	99 f5       	brne	.+102    	; 0x2116 <vTaskIncrementTick+0x94>
    20b0:	80 91 97 12 	lds	r24, 0x1297	; 0x801297 <pxDelayedTaskList>
    20b4:	90 91 98 12 	lds	r25, 0x1298	; 0x801298 <pxDelayedTaskList+0x1>
    20b8:	20 91 95 12 	lds	r18, 0x1295	; 0x801295 <pxOverflowDelayedTaskList>
    20bc:	30 91 96 12 	lds	r19, 0x1296	; 0x801296 <pxOverflowDelayedTaskList+0x1>
    20c0:	30 93 98 12 	sts	0x1298, r19	; 0x801298 <pxDelayedTaskList+0x1>
    20c4:	20 93 97 12 	sts	0x1297, r18	; 0x801297 <pxDelayedTaskList>
    20c8:	90 93 96 12 	sts	0x1296, r25	; 0x801296 <pxOverflowDelayedTaskList+0x1>
    20cc:	80 93 95 12 	sts	0x1295, r24	; 0x801295 <pxOverflowDelayedTaskList>
    20d0:	80 91 82 12 	lds	r24, 0x1282	; 0x801282 <xNumOfOverflows>
    20d4:	8f 5f       	subi	r24, 0xFF	; 255
    20d6:	80 93 82 12 	sts	0x1282, r24	; 0x801282 <xNumOfOverflows>
    20da:	e0 91 97 12 	lds	r30, 0x1297	; 0x801297 <pxDelayedTaskList>
    20de:	f0 91 98 12 	lds	r31, 0x1298	; 0x801298 <pxDelayedTaskList+0x1>
    20e2:	80 81       	ld	r24, Z
    20e4:	81 11       	cpse	r24, r1
    20e6:	07 c0       	rjmp	.+14     	; 0x20f6 <vTaskIncrementTick+0x74>
    20e8:	8f ef       	ldi	r24, 0xFF	; 255
    20ea:	9f ef       	ldi	r25, 0xFF	; 255
    20ec:	90 93 0c 02 	sts	0x020C, r25	; 0x80020c <xNextTaskUnblockTime+0x1>
    20f0:	80 93 0b 02 	sts	0x020B, r24	; 0x80020b <xNextTaskUnblockTime>
    20f4:	10 c0       	rjmp	.+32     	; 0x2116 <vTaskIncrementTick+0x94>
    20f6:	e0 91 97 12 	lds	r30, 0x1297	; 0x801297 <pxDelayedTaskList>
    20fa:	f0 91 98 12 	lds	r31, 0x1298	; 0x801298 <pxDelayedTaskList+0x1>
    20fe:	05 80       	ldd	r0, Z+5	; 0x05
    2100:	f6 81       	ldd	r31, Z+6	; 0x06
    2102:	e0 2d       	mov	r30, r0
    2104:	06 80       	ldd	r0, Z+6	; 0x06
    2106:	f7 81       	ldd	r31, Z+7	; 0x07
    2108:	e0 2d       	mov	r30, r0
    210a:	82 81       	ldd	r24, Z+2	; 0x02
    210c:	93 81       	ldd	r25, Z+3	; 0x03
    210e:	90 93 0c 02 	sts	0x020C, r25	; 0x80020c <xNextTaskUnblockTime+0x1>
    2112:	80 93 0b 02 	sts	0x020B, r24	; 0x80020b <xNextTaskUnblockTime>
    2116:	20 91 89 12 	lds	r18, 0x1289	; 0x801289 <xTickCount>
    211a:	30 91 8a 12 	lds	r19, 0x128A	; 0x80128a <xTickCount+0x1>
    211e:	80 91 0b 02 	lds	r24, 0x020B	; 0x80020b <xNextTaskUnblockTime>
    2122:	90 91 0c 02 	lds	r25, 0x020C	; 0x80020c <xNextTaskUnblockTime+0x1>
    2126:	28 17       	cp	r18, r24
    2128:	39 07       	cpc	r19, r25
    212a:	08 f4       	brcc	.+2      	; 0x212e <vTaskIncrementTick+0xac>
    212c:	4c c0       	rjmp	.+152    	; 0x21c6 <vTaskIncrementTick+0x144>
    212e:	e0 91 97 12 	lds	r30, 0x1297	; 0x801297 <pxDelayedTaskList>
    2132:	f0 91 98 12 	lds	r31, 0x1298	; 0x801298 <pxDelayedTaskList+0x1>
    2136:	80 81       	ld	r24, Z
    2138:	81 11       	cpse	r24, r1
    213a:	07 c0       	rjmp	.+14     	; 0x214a <vTaskIncrementTick+0xc8>
    213c:	8f ef       	ldi	r24, 0xFF	; 255
    213e:	9f ef       	ldi	r25, 0xFF	; 255
    2140:	90 93 0c 02 	sts	0x020C, r25	; 0x80020c <xNextTaskUnblockTime+0x1>
    2144:	80 93 0b 02 	sts	0x020B, r24	; 0x80020b <xNextTaskUnblockTime>
    2148:	3e c0       	rjmp	.+124    	; 0x21c6 <vTaskIncrementTick+0x144>
    214a:	e0 91 97 12 	lds	r30, 0x1297	; 0x801297 <pxDelayedTaskList>
    214e:	f0 91 98 12 	lds	r31, 0x1298	; 0x801298 <pxDelayedTaskList+0x1>
    2152:	05 80       	ldd	r0, Z+5	; 0x05
    2154:	f6 81       	ldd	r31, Z+6	; 0x06
    2156:	e0 2d       	mov	r30, r0
    2158:	c6 81       	ldd	r28, Z+6	; 0x06
    215a:	d7 81       	ldd	r29, Z+7	; 0x07
    215c:	8a 81       	ldd	r24, Y+2	; 0x02
    215e:	9b 81       	ldd	r25, Y+3	; 0x03
    2160:	20 91 89 12 	lds	r18, 0x1289	; 0x801289 <xTickCount>
    2164:	30 91 8a 12 	lds	r19, 0x128A	; 0x80128a <xTickCount+0x1>
    2168:	28 17       	cp	r18, r24
    216a:	39 07       	cpc	r19, r25
    216c:	28 f4       	brcc	.+10     	; 0x2178 <vTaskIncrementTick+0xf6>
    216e:	90 93 0c 02 	sts	0x020C, r25	; 0x80020c <xNextTaskUnblockTime+0x1>
    2172:	80 93 0b 02 	sts	0x020B, r24	; 0x80020b <xNextTaskUnblockTime>
    2176:	27 c0       	rjmp	.+78     	; 0x21c6 <vTaskIncrementTick+0x144>
    2178:	8e 01       	movw	r16, r28
    217a:	0e 5f       	subi	r16, 0xFE	; 254
    217c:	1f 4f       	sbci	r17, 0xFF	; 255
    217e:	c8 01       	movw	r24, r16
    2180:	2b dc       	rcall	.-1962   	; 0x19d8 <vListRemove>
    2182:	8c 89       	ldd	r24, Y+20	; 0x14
    2184:	9d 89       	ldd	r25, Y+21	; 0x15
    2186:	89 2b       	or	r24, r25
    2188:	19 f0       	breq	.+6      	; 0x2190 <vTaskIncrementTick+0x10e>
    218a:	ce 01       	movw	r24, r28
    218c:	0c 96       	adiw	r24, 0x0c	; 12
    218e:	24 dc       	rcall	.-1976   	; 0x19d8 <vListRemove>
    2190:	8e 89       	ldd	r24, Y+22	; 0x16
    2192:	90 91 87 12 	lds	r25, 0x1287	; 0x801287 <uxTopReadyPriority>
    2196:	98 17       	cp	r25, r24
    2198:	10 f4       	brcc	.+4      	; 0x219e <vTaskIncrementTick+0x11c>
    219a:	80 93 87 12 	sts	0x1287, r24	; 0x801287 <uxTopReadyPriority>
    219e:	90 e0       	ldi	r25, 0x00	; 0
    21a0:	9c 01       	movw	r18, r24
    21a2:	22 0f       	add	r18, r18
    21a4:	33 1f       	adc	r19, r19
    21a6:	22 0f       	add	r18, r18
    21a8:	33 1f       	adc	r19, r19
    21aa:	22 0f       	add	r18, r18
    21ac:	33 1f       	adc	r19, r19
    21ae:	82 0f       	add	r24, r18
    21b0:	93 1f       	adc	r25, r19
    21b2:	b8 01       	movw	r22, r16
    21b4:	85 55       	subi	r24, 0x55	; 85
    21b6:	9d 4e       	sbci	r25, 0xED	; 237
    21b8:	b7 db       	rcall	.-2194   	; 0x1928 <vListInsertEnd>
    21ba:	b9 cf       	rjmp	.-142    	; 0x212e <vTaskIncrementTick+0xac>
    21bc:	80 91 84 12 	lds	r24, 0x1284	; 0x801284 <uxMissedTicks>
    21c0:	8f 5f       	subi	r24, 0xFF	; 255
    21c2:	80 93 84 12 	sts	0x1284, r24	; 0x801284 <uxMissedTicks>
    21c6:	df 91       	pop	r29
    21c8:	cf 91       	pop	r28
    21ca:	1f 91       	pop	r17
    21cc:	0f 91       	pop	r16
    21ce:	08 95       	ret

000021d0 <xTaskResumeAll>:
    21d0:	ff 92       	push	r15
    21d2:	0f 93       	push	r16
    21d4:	1f 93       	push	r17
    21d6:	cf 93       	push	r28
    21d8:	df 93       	push	r29
    21da:	0f b6       	in	r0, 0x3f	; 63
    21dc:	f8 94       	cli
    21de:	0f 92       	push	r0
    21e0:	80 91 85 12 	lds	r24, 0x1285	; 0x801285 <uxSchedulerSuspended>
    21e4:	81 50       	subi	r24, 0x01	; 1
    21e6:	80 93 85 12 	sts	0x1285, r24	; 0x801285 <uxSchedulerSuspended>
    21ea:	80 91 85 12 	lds	r24, 0x1285	; 0x801285 <uxSchedulerSuspended>
    21ee:	81 11       	cpse	r24, r1
    21f0:	55 c0       	rjmp	.+170    	; 0x229c <__stack+0x9d>
    21f2:	80 91 8b 12 	lds	r24, 0x128B	; 0x80128b <uxCurrentNumberOfTasks>
    21f6:	81 11       	cpse	r24, r1
    21f8:	2f c0       	rjmp	.+94     	; 0x2258 <__stack+0x59>
    21fa:	53 c0       	rjmp	.+166    	; 0x22a2 <__stack+0xa3>
    21fc:	e0 91 91 12 	lds	r30, 0x1291	; 0x801291 <xPendingReadyList+0x5>
    2200:	f0 91 92 12 	lds	r31, 0x1292	; 0x801292 <xPendingReadyList+0x6>
    2204:	c6 81       	ldd	r28, Z+6	; 0x06
    2206:	d7 81       	ldd	r29, Z+7	; 0x07
    2208:	ce 01       	movw	r24, r28
    220a:	0c 96       	adiw	r24, 0x0c	; 12
    220c:	e5 db       	rcall	.-2102   	; 0x19d8 <vListRemove>
    220e:	8e 01       	movw	r16, r28
    2210:	0e 5f       	subi	r16, 0xFE	; 254
    2212:	1f 4f       	sbci	r17, 0xFF	; 255
    2214:	c8 01       	movw	r24, r16
    2216:	e0 db       	rcall	.-2112   	; 0x19d8 <vListRemove>
    2218:	8e 89       	ldd	r24, Y+22	; 0x16
    221a:	90 91 87 12 	lds	r25, 0x1287	; 0x801287 <uxTopReadyPriority>
    221e:	98 17       	cp	r25, r24
    2220:	10 f4       	brcc	.+4      	; 0x2226 <__stack+0x27>
    2222:	80 93 87 12 	sts	0x1287, r24	; 0x801287 <uxTopReadyPriority>
    2226:	90 e0       	ldi	r25, 0x00	; 0
    2228:	9c 01       	movw	r18, r24
    222a:	22 0f       	add	r18, r18
    222c:	33 1f       	adc	r19, r19
    222e:	22 0f       	add	r18, r18
    2230:	33 1f       	adc	r19, r19
    2232:	22 0f       	add	r18, r18
    2234:	33 1f       	adc	r19, r19
    2236:	82 0f       	add	r24, r18
    2238:	93 1f       	adc	r25, r19
    223a:	b8 01       	movw	r22, r16
    223c:	85 55       	subi	r24, 0x55	; 85
    223e:	9d 4e       	sbci	r25, 0xED	; 237
    2240:	73 db       	rcall	.-2330   	; 0x1928 <vListInsertEnd>
    2242:	9e 89       	ldd	r25, Y+22	; 0x16
    2244:	e0 91 b4 12 	lds	r30, 0x12B4	; 0x8012b4 <pxCurrentTCB>
    2248:	f0 91 b5 12 	lds	r31, 0x12B5	; 0x8012b5 <pxCurrentTCB+0x1>
    224c:	86 89       	ldd	r24, Z+22	; 0x16
    224e:	98 17       	cp	r25, r24
    2250:	20 f0       	brcs	.+8      	; 0x225a <__stack+0x5b>
    2252:	ff 24       	eor	r15, r15
    2254:	f3 94       	inc	r15
    2256:	01 c0       	rjmp	.+2      	; 0x225a <__stack+0x5b>
    2258:	f1 2c       	mov	r15, r1
    225a:	80 91 8c 12 	lds	r24, 0x128C	; 0x80128c <xPendingReadyList>
    225e:	81 11       	cpse	r24, r1
    2260:	cd cf       	rjmp	.-102    	; 0x21fc <xTaskResumeAll+0x2c>
    2262:	80 91 84 12 	lds	r24, 0x1284	; 0x801284 <uxMissedTicks>
    2266:	81 11       	cpse	r24, r1
    2268:	07 c0       	rjmp	.+14     	; 0x2278 <__stack+0x79>
    226a:	0c c0       	rjmp	.+24     	; 0x2284 <__stack+0x85>
    226c:	0a df       	rcall	.-492    	; 0x2082 <vTaskIncrementTick>
    226e:	80 91 84 12 	lds	r24, 0x1284	; 0x801284 <uxMissedTicks>
    2272:	81 50       	subi	r24, 0x01	; 1
    2274:	80 93 84 12 	sts	0x1284, r24	; 0x801284 <uxMissedTicks>
    2278:	80 91 84 12 	lds	r24, 0x1284	; 0x801284 <uxMissedTicks>
    227c:	81 11       	cpse	r24, r1
    227e:	f6 cf       	rjmp	.-20     	; 0x226c <__stack+0x6d>
    2280:	ff 24       	eor	r15, r15
    2282:	f3 94       	inc	r15
    2284:	81 e0       	ldi	r24, 0x01	; 1
    2286:	f8 16       	cp	r15, r24
    2288:	21 f0       	breq	.+8      	; 0x2292 <__stack+0x93>
    228a:	80 91 83 12 	lds	r24, 0x1283	; 0x801283 <xMissedYield>
    228e:	81 30       	cpi	r24, 0x01	; 1
    2290:	39 f4       	brne	.+14     	; 0x22a0 <__stack+0xa1>
    2292:	10 92 83 12 	sts	0x1283, r1	; 0x801283 <xMissedYield>
    2296:	73 dc       	rcall	.-1818   	; 0x1b7e <vPortYield>
    2298:	81 e0       	ldi	r24, 0x01	; 1
    229a:	03 c0       	rjmp	.+6      	; 0x22a2 <__stack+0xa3>
    229c:	80 e0       	ldi	r24, 0x00	; 0
    229e:	01 c0       	rjmp	.+2      	; 0x22a2 <__stack+0xa3>
    22a0:	80 e0       	ldi	r24, 0x00	; 0
    22a2:	0f 90       	pop	r0
    22a4:	0f be       	out	0x3f, r0	; 63
    22a6:	df 91       	pop	r29
    22a8:	cf 91       	pop	r28
    22aa:	1f 91       	pop	r17
    22ac:	0f 91       	pop	r16
    22ae:	ff 90       	pop	r15
    22b0:	08 95       	ret

000022b2 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    22b2:	cf 93       	push	r28
    22b4:	df 93       	push	r29
    22b6:	ec 01       	movw	r28, r24
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    22b8:	89 2b       	or	r24, r25
    22ba:	89 f0       	breq	.+34     	; 0x22de <vTaskDelay+0x2c>
		{
			vTaskSuspendAll();
    22bc:	dc de       	rcall	.-584    	; 0x2076 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    22be:	80 91 89 12 	lds	r24, 0x1289	; 0x801289 <xTickCount>
    22c2:	90 91 8a 12 	lds	r25, 0x128A	; 0x80128a <xTickCount+0x1>
    22c6:	c8 0f       	add	r28, r24
    22c8:	d9 1f       	adc	r29, r25

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    22ca:	80 91 b4 12 	lds	r24, 0x12B4	; 0x8012b4 <pxCurrentTCB>
    22ce:	90 91 b5 12 	lds	r25, 0x12B5	; 0x8012b5 <pxCurrentTCB+0x1>
    22d2:	02 96       	adiw	r24, 0x02	; 2
    22d4:	81 db       	rcall	.-2302   	; 0x19d8 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    22d6:	ce 01       	movw	r24, r28
    22d8:	b8 dd       	rcall	.-1168   	; 0x1e4a <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    22da:	7a df       	rcall	.-268    	; 0x21d0 <xTaskResumeAll>
    22dc:	01 c0       	rjmp	.+2      	; 0x22e0 <vTaskDelay+0x2e>
#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    22de:	80 e0       	ldi	r24, 0x00	; 0
			xAlreadyYielded = xTaskResumeAll();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    22e0:	81 11       	cpse	r24, r1
    22e2:	01 c0       	rjmp	.+2      	; 0x22e6 <vTaskDelay+0x34>
		{
			portYIELD_WITHIN_API();
    22e4:	4c dc       	rcall	.-1896   	; 0x1b7e <vPortYield>
    22e6:	df 91       	pop	r29
		}
	}
    22e8:	cf 91       	pop	r28
    22ea:	08 95       	ret

000022ec <vTaskSwitchContext>:
    22ec:	80 91 85 12 	lds	r24, 0x1285	; 0x801285 <uxSchedulerSuspended>
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    22f0:	88 23       	and	r24, r24
    22f2:	49 f0       	breq	.+18     	; 0x2306 <vTaskSwitchContext+0x1a>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    22f4:	81 e0       	ldi	r24, 0x01	; 1
    22f6:	80 93 83 12 	sts	0x1283, r24	; 0x801283 <xMissedYield>
    22fa:	08 95       	ret
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    22fc:	80 91 87 12 	lds	r24, 0x1287	; 0x801287 <uxTopReadyPriority>
    2300:	81 50       	subi	r24, 0x01	; 1
    2302:	80 93 87 12 	sts	0x1287, r24	; 0x801287 <uxTopReadyPriority>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    2306:	80 91 87 12 	lds	r24, 0x1287	; 0x801287 <uxTopReadyPriority>
    230a:	90 e0       	ldi	r25, 0x00	; 0
    230c:	fc 01       	movw	r30, r24
    230e:	ee 0f       	add	r30, r30
    2310:	ff 1f       	adc	r31, r31
    2312:	ee 0f       	add	r30, r30
    2314:	ff 1f       	adc	r31, r31
    2316:	ee 0f       	add	r30, r30
    2318:	ff 1f       	adc	r31, r31
    231a:	8e 0f       	add	r24, r30
    231c:	9f 1f       	adc	r25, r31
    231e:	fc 01       	movw	r30, r24
    2320:	e5 55       	subi	r30, 0x55	; 85
    2322:	fd 4e       	sbci	r31, 0xED	; 237
    2324:	80 81       	ld	r24, Z
    2326:	88 23       	and	r24, r24
    2328:	49 f3       	breq	.-46     	; 0x22fc <vTaskSwitchContext+0x10>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    232a:	80 91 87 12 	lds	r24, 0x1287	; 0x801287 <uxTopReadyPriority>
    232e:	90 e0       	ldi	r25, 0x00	; 0
    2330:	9c 01       	movw	r18, r24
    2332:	22 0f       	add	r18, r18
    2334:	33 1f       	adc	r19, r19
    2336:	22 0f       	add	r18, r18
    2338:	33 1f       	adc	r19, r19
    233a:	22 0f       	add	r18, r18
    233c:	33 1f       	adc	r19, r19
    233e:	28 0f       	add	r18, r24
    2340:	39 1f       	adc	r19, r25
    2342:	d9 01       	movw	r26, r18
    2344:	a5 55       	subi	r26, 0x55	; 85
    2346:	bd 4e       	sbci	r27, 0xED	; 237
    2348:	11 96       	adiw	r26, 0x01	; 1
    234a:	ed 91       	ld	r30, X+
    234c:	fc 91       	ld	r31, X
    234e:	12 97       	sbiw	r26, 0x02	; 2
    2350:	02 80       	ldd	r0, Z+2	; 0x02
    2352:	f3 81       	ldd	r31, Z+3	; 0x03
    2354:	e0 2d       	mov	r30, r0
    2356:	12 96       	adiw	r26, 0x02	; 2
    2358:	fc 93       	st	X, r31
    235a:	ee 93       	st	-X, r30
    235c:	11 97       	sbiw	r26, 0x01	; 1
    235e:	22 55       	subi	r18, 0x52	; 82
    2360:	3d 4e       	sbci	r19, 0xED	; 237
    2362:	e2 17       	cp	r30, r18
    2364:	f3 07       	cpc	r31, r19
    2366:	29 f4       	brne	.+10     	; 0x2372 <vTaskSwitchContext+0x86>
    2368:	22 81       	ldd	r18, Z+2	; 0x02
    236a:	33 81       	ldd	r19, Z+3	; 0x03
    236c:	fd 01       	movw	r30, r26
    236e:	32 83       	std	Z+2, r19	; 0x02
    2370:	21 83       	std	Z+1, r18	; 0x01
    2372:	fc 01       	movw	r30, r24
    2374:	ee 0f       	add	r30, r30
    2376:	ff 1f       	adc	r31, r31
    2378:	ee 0f       	add	r30, r30
    237a:	ff 1f       	adc	r31, r31
    237c:	ee 0f       	add	r30, r30
    237e:	ff 1f       	adc	r31, r31
    2380:	8e 0f       	add	r24, r30
    2382:	9f 1f       	adc	r25, r31
    2384:	fc 01       	movw	r30, r24
    2386:	e5 55       	subi	r30, 0x55	; 85
    2388:	fd 4e       	sbci	r31, 0xED	; 237
    238a:	01 80       	ldd	r0, Z+1	; 0x01
    238c:	f2 81       	ldd	r31, Z+2	; 0x02
    238e:	e0 2d       	mov	r30, r0
    2390:	86 81       	ldd	r24, Z+6	; 0x06
    2392:	97 81       	ldd	r25, Z+7	; 0x07
    2394:	90 93 b5 12 	sts	0x12B5, r25	; 0x8012b5 <pxCurrentTCB+0x1>
    2398:	80 93 b4 12 	sts	0x12B4, r24	; 0x8012b4 <pxCurrentTCB>
    239c:	08 95       	ret

0000239e <_Z12WriteCommandj>:
}

void DisplayOff()
{
	// Send command DisplayOff which is 0x28 in HEX.
	WriteCommand(0x28);
    239e:	2b b1       	in	r18, 0x0b	; 11
    23a0:	2f 77       	andi	r18, 0x7F	; 127
    23a2:	2b b9       	out	0x0b, r18	; 11
    23a4:	24 b3       	in	r18, 0x14	; 20
    23a6:	2d 7f       	andi	r18, 0xFD	; 253
    23a8:	24 bb       	out	0x14, r18	; 20
    23aa:	00 00       	nop
    23ac:	92 b9       	out	0x02, r25	; 2
    23ae:	88 b9       	out	0x08, r24	; 8
    23b0:	84 b3       	in	r24, 0x14	; 20
    23b2:	8b 7f       	andi	r24, 0xFB	; 251
    23b4:	84 bb       	out	0x14, r24	; 20
    23b6:	00 00       	nop
    23b8:	84 b3       	in	r24, 0x14	; 20
    23ba:	84 60       	ori	r24, 0x04	; 4
    23bc:	84 bb       	out	0x14, r24	; 20
    23be:	00 00       	nop
    23c0:	84 b3       	in	r24, 0x14	; 20
    23c2:	82 60       	ori	r24, 0x02	; 2
    23c4:	84 bb       	out	0x14, r24	; 20
    23c6:	08 95       	ret

000023c8 <_Z9WriteDataj>:
    23c8:	2b b1       	in	r18, 0x0b	; 11
    23ca:	20 68       	ori	r18, 0x80	; 128
    23cc:	2b b9       	out	0x0b, r18	; 11
    23ce:	24 b3       	in	r18, 0x14	; 20
    23d0:	2d 7f       	andi	r18, 0xFD	; 253
    23d2:	24 bb       	out	0x14, r18	; 20
    23d4:	00 00       	nop
    23d6:	92 b9       	out	0x02, r25	; 2
    23d8:	88 b9       	out	0x08, r24	; 8
    23da:	84 b3       	in	r24, 0x14	; 20
    23dc:	8b 7f       	andi	r24, 0xFB	; 251
    23de:	84 bb       	out	0x14, r24	; 20
    23e0:	00 00       	nop
    23e2:	84 b3       	in	r24, 0x14	; 20
    23e4:	84 60       	ori	r24, 0x04	; 4
    23e6:	84 bb       	out	0x14, r24	; 20
    23e8:	00 00       	nop
    23ea:	84 b3       	in	r24, 0x14	; 20
    23ec:	82 60       	ori	r24, 0x02	; 2
    23ee:	84 bb       	out	0x14, r24	; 20
    23f0:	08 95       	ret

000023f2 <_Z9DisplayOnv>:
}

void DisplayOn()
{
	// Send command DisplayOn which is 0x29 in HEX.
	WriteCommand(0x29);
    23f2:	89 e2       	ldi	r24, 0x29	; 41
    23f4:	90 e0       	ldi	r25, 0x00	; 0
    23f6:	d3 cf       	rjmp	.-90     	; 0x239e <_Z12WriteCommandj>
    23f8:	08 95       	ret

000023fa <_Z8SleepOutv>:
}

void SleepOut()
{
	// Send command SleepOut which is 0x11 in HEX. 
	WriteCommand(0x11);
    23fa:	81 e1       	ldi	r24, 0x11	; 17
    23fc:	90 e0       	ldi	r25, 0x00	; 0
    23fe:	cf cf       	rjmp	.-98     	; 0x239e <_Z12WriteCommandj>
    2400:	08 95       	ret

00002402 <_Z19MemoryAccessControlh>:
}

void MemoryAccessControl(unsigned char parameter)
{
    2402:	cf 93       	push	r28
    2404:	c8 2f       	mov	r28, r24
	WriteCommand(0x36);
    2406:	86 e3       	ldi	r24, 0x36	; 54
    2408:	90 e0       	ldi	r25, 0x00	; 0
    240a:	c9 df       	rcall	.-110    	; 0x239e <_Z12WriteCommandj>
	WriteData(parameter);
    240c:	8c 2f       	mov	r24, r28
    240e:	90 e0       	ldi	r25, 0x00	; 0
    2410:	db df       	rcall	.-74     	; 0x23c8 <_Z9WriteDataj>
}
    2412:	cf 91       	pop	r28
    2414:	08 95       	ret

00002416 <_Z20InterfacePixelFormath>:

void InterfacePixelFormat(unsigned char parameter)
{
    2416:	cf 93       	push	r28
    2418:	c8 2f       	mov	r28, r24
	WriteCommand(0x3A);
    241a:	8a e3       	ldi	r24, 0x3A	; 58
    241c:	90 e0       	ldi	r25, 0x00	; 0
    241e:	bf df       	rcall	.-130    	; 0x239e <_Z12WriteCommandj>
	WriteData(parameter);
    2420:	8c 2f       	mov	r24, r28
    2422:	90 e0       	ldi	r25, 0x00	; 0
    2424:	d1 df       	rcall	.-94     	; 0x23c8 <_Z9WriteDataj>
}
    2426:	cf 91       	pop	r28
    2428:	08 95       	ret

0000242a <_Z11DisplayInitv>:

// Initializes (resets) the display
void DisplayInit()
{
	// Control pins are outputs
	DDRG |= 0b00000111;
    242a:	83 b3       	in	r24, 0x13	; 19
    242c:	87 60       	ori	r24, 0x07	; 7
    242e:	83 bb       	out	0x13, r24	; 19
	DDRD |= 0b10000000;
    2430:	8a b1       	in	r24, 0x0a	; 10
    2432:	80 68       	ori	r24, 0x80	; 128
    2434:	8a b9       	out	0x0a, r24	; 10
	
	// Data pins are outputs
	DDRA = 0xFF;
    2436:	8f ef       	ldi	r24, 0xFF	; 255
    2438:	81 b9       	out	0x01, r24	; 1
	DDRC = 0xFF;
    243a:	87 b9       	out	0x07, r24	; 7
	
	// All control pins high;
	PORTG |= 0b00000111;
    243c:	84 b3       	in	r24, 0x14	; 20
    243e:	87 60       	ori	r24, 0x07	; 7
    2440:	84 bb       	out	0x14, r24	; 20
	PORTD |= 0b10000000;
    2442:	8b b1       	in	r24, 0x0b	; 11
    2444:	80 68       	ori	r24, 0x80	; 128
    2446:	8b b9       	out	0x0b, r24	; 11
	
	// Pull reset pin - Wait min 10 uS
	RST_PORT &= ~(1 << RST_BIT);
    2448:	84 b3       	in	r24, 0x14	; 20
    244a:	8e 7f       	andi	r24, 0xFE	; 254
    244c:	84 bb       	out	0x14, r24	; 20
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    244e:	2f ef       	ldi	r18, 0xFF	; 255
    2450:	89 e6       	ldi	r24, 0x69	; 105
    2452:	98 e1       	ldi	r25, 0x18	; 24
    2454:	21 50       	subi	r18, 0x01	; 1
    2456:	80 40       	sbci	r24, 0x00	; 0
    2458:	90 40       	sbci	r25, 0x00	; 0
    245a:	e1 f7       	brne	.-8      	; 0x2454 <_Z11DisplayInitv+0x2a>
    245c:	00 c0       	rjmp	.+0      	; 0x245e <_Z11DisplayInitv+0x34>
    245e:	00 00       	nop
	_delay_ms( 500 );

	RST_PORT |= (1 << RST_BIT);
    2460:	84 b3       	in	r24, 0x14	; 20
    2462:	81 60       	ori	r24, 0x01	; 1
    2464:	84 bb       	out	0x14, r24	; 20
    2466:	2f ef       	ldi	r18, 0xFF	; 255
    2468:	89 e6       	ldi	r24, 0x69	; 105
    246a:	98 e1       	ldi	r25, 0x18	; 24
    246c:	21 50       	subi	r18, 0x01	; 1
    246e:	80 40       	sbci	r24, 0x00	; 0
    2470:	90 40       	sbci	r25, 0x00	; 0
    2472:	e1 f7       	brne	.-8      	; 0x246c <_Z11DisplayInitv+0x42>
    2474:	00 c0       	rjmp	.+0      	; 0x2476 <_Z11DisplayInitv+0x4c>
    2476:	00 00       	nop
	
	// Wait for display to be rdy
	_delay_ms( 500 );
	
	// Set pixel interface and memoryaccesscontrol
	InterfacePixelFormat(0b00000101);
    2478:	85 e0       	ldi	r24, 0x05	; 5
    247a:	cd df       	rcall	.-102    	; 0x2416 <_Z20InterfacePixelFormath>
	MemoryAccessControl(0b00001000);
    247c:	88 e0       	ldi	r24, 0x08	; 8
	
	// Call sleepout and display on.
	SleepOut();
    247e:	c1 df       	rcall	.-126    	; 0x2402 <_Z19MemoryAccessControlh>
    2480:	bc df       	rcall	.-136    	; 0x23fa <_Z8SleepOutv>
	DisplayOn();
    2482:	b7 cf       	rjmp	.-146    	; 0x23f2 <_Z9DisplayOnv>
    2484:	08 95       	ret

00002486 <_Z11MemoryWritev>:
    2486:	8c e2       	ldi	r24, 0x2C	; 44
	WriteData(parameter);
}

void MemoryWrite()
{
	WriteCommand(0x2C);
    2488:	90 e0       	ldi	r25, 0x00	; 0
    248a:	89 cf       	rjmp	.-238    	; 0x239e <_Z12WriteCommandj>
    248c:	08 95       	ret

0000248e <_Z10WritePixelhhh>:
}

// Red 0-31, Green 0-63, Blue 0-31
void WritePixel(unsigned char Red, unsigned char Green, unsigned char Blue)
{
	uint16_t toSend = (Red << 11U) | (Green << 5U) | (Blue);
    248e:	90 e0       	ldi	r25, 0x00	; 0
    2490:	98 2f       	mov	r25, r24
    2492:	88 27       	eor	r24, r24
    2494:	99 0f       	add	r25, r25
    2496:	99 0f       	add	r25, r25
    2498:	99 0f       	add	r25, r25
    249a:	20 e2       	ldi	r18, 0x20	; 32
    249c:	62 9f       	mul	r22, r18
    249e:	b0 01       	movw	r22, r0
    24a0:	11 24       	eor	r1, r1
    24a2:	86 2b       	or	r24, r22
    24a4:	97 2b       	or	r25, r23
	WriteData(toSend);
    24a6:	84 2b       	or	r24, r20
    24a8:	8f cf       	rjmp	.-226    	; 0x23c8 <_Z9WriteDataj>
    24aa:	08 95       	ret

000024ac <_Z16SetColumnAddressjj>:
}

// Set Column Address (0-239), Start > End
void SetColumnAddress(unsigned int Start, unsigned int End)
{
    24ac:	0f 93       	push	r16
    24ae:	1f 93       	push	r17
    24b0:	cf 93       	push	r28
    24b2:	df 93       	push	r29
	if (Start < End)
    24b4:	86 17       	cp	r24, r22
    24b6:	97 07       	cpc	r25, r23
    24b8:	78 f4       	brcc	.+30     	; 0x24d8 <_Z16SetColumnAddressjj+0x2c>
    24ba:	eb 01       	movw	r28, r22
    24bc:	8c 01       	movw	r16, r24
	{
		WriteCommand(0x2A);
    24be:	8a e2       	ldi	r24, 0x2A	; 42
    24c0:	90 e0       	ldi	r25, 0x00	; 0
    24c2:	6d df       	rcall	.-294    	; 0x239e <_Z12WriteCommandj>
		WriteData(Start >> 8U);
    24c4:	81 2f       	mov	r24, r17
    24c6:	90 e0       	ldi	r25, 0x00	; 0
    24c8:	7f df       	rcall	.-258    	; 0x23c8 <_Z9WriteDataj>
		WriteData(Start);
    24ca:	c8 01       	movw	r24, r16
    24cc:	7d df       	rcall	.-262    	; 0x23c8 <_Z9WriteDataj>
		WriteData(End >> 8U);
    24ce:	8d 2f       	mov	r24, r29
    24d0:	90 e0       	ldi	r25, 0x00	; 0
    24d2:	7a df       	rcall	.-268    	; 0x23c8 <_Z9WriteDataj>
		WriteData(End);
    24d4:	ce 01       	movw	r24, r28
    24d6:	78 df       	rcall	.-272    	; 0x23c8 <_Z9WriteDataj>
    24d8:	df 91       	pop	r29
	}
}
    24da:	cf 91       	pop	r28
    24dc:	1f 91       	pop	r17
    24de:	0f 91       	pop	r16
    24e0:	08 95       	ret

000024e2 <_Z14SetPageAddressjj>:
    24e2:	0f 93       	push	r16

// Set Page Address (0-319), Start > End
void SetPageAddress(unsigned int Start, unsigned int End)
{
    24e4:	1f 93       	push	r17
    24e6:	cf 93       	push	r28
    24e8:	df 93       	push	r29
	if (Start < End)
    24ea:	86 17       	cp	r24, r22
    24ec:	97 07       	cpc	r25, r23
    24ee:	78 f4       	brcc	.+30     	; 0x250e <_Z14SetPageAddressjj+0x2c>
    24f0:	eb 01       	movw	r28, r22
    24f2:	8c 01       	movw	r16, r24
	{
		WriteCommand(0x2B);
    24f4:	8b e2       	ldi	r24, 0x2B	; 43
    24f6:	90 e0       	ldi	r25, 0x00	; 0
    24f8:	52 df       	rcall	.-348    	; 0x239e <_Z12WriteCommandj>
		WriteData(Start >> 8U);
    24fa:	81 2f       	mov	r24, r17
    24fc:	90 e0       	ldi	r25, 0x00	; 0
    24fe:	64 df       	rcall	.-312    	; 0x23c8 <_Z9WriteDataj>
		WriteData(Start);
    2500:	c8 01       	movw	r24, r16
    2502:	62 df       	rcall	.-316    	; 0x23c8 <_Z9WriteDataj>
		WriteData(End >> 8U);
    2504:	8d 2f       	mov	r24, r29
    2506:	90 e0       	ldi	r25, 0x00	; 0
    2508:	5f df       	rcall	.-322    	; 0x23c8 <_Z9WriteDataj>
		WriteData(End);
    250a:	ce 01       	movw	r24, r28
    250c:	5d df       	rcall	.-326    	; 0x23c8 <_Z9WriteDataj>
    250e:	df 91       	pop	r29
	}
}
    2510:	cf 91       	pop	r28
    2512:	1f 91       	pop	r17
    2514:	0f 91       	pop	r16
    2516:	08 95       	ret

00002518 <_Z13FillRectanglejjjjhhh>:
    2518:	6f 92       	push	r6
// Fills rectangle with specified color
// (StartX,StartY) = Upper left corner. X horizontal (0-319) , Y vertical (0-239).
// Height (1-240) is vertical. Width (1-320) is horizontal.
// R-G-B = 5-6-5 bits.
void FillRectangle(unsigned int StartX, unsigned int StartY, unsigned int Width, unsigned int Height, unsigned char Blue, unsigned char Green, unsigned char Red)
{
    251a:	7f 92       	push	r7
    251c:	8f 92       	push	r8
    251e:	9f 92       	push	r9
    2520:	af 92       	push	r10
    2522:	bf 92       	push	r11
    2524:	cf 92       	push	r12
    2526:	ef 92       	push	r14
    2528:	0f 93       	push	r16
    252a:	cf 93       	push	r28
    252c:	df 93       	push	r29
    252e:	5b 01       	movw	r10, r22
    2530:	3a 01       	movw	r6, r20
    2532:	e9 01       	movw	r28, r18
	SetPageAddress(StartX,StartX+Width-1);
    2534:	bc 01       	movw	r22, r24
    2536:	64 0f       	add	r22, r20
    2538:	75 1f       	adc	r23, r21
    253a:	61 50       	subi	r22, 0x01	; 1
    253c:	71 09       	sbc	r23, r1
    253e:	d1 df       	rcall	.-94     	; 0x24e2 <_Z14SetPageAddressjj>
	SetColumnAddress(StartY,StartY+Height-1);
    2540:	b5 01       	movw	r22, r10
    2542:	6c 0f       	add	r22, r28
    2544:	7d 1f       	adc	r23, r29
    2546:	61 50       	subi	r22, 0x01	; 1
    2548:	71 09       	sbc	r23, r1
    254a:	c5 01       	movw	r24, r10
	MemoryWrite();
    254c:	af df       	rcall	.-162    	; 0x24ac <_Z16SetColumnAddressjj>
    254e:	9b df       	rcall	.-202    	; 0x2486 <_Z11MemoryWritev>
	
	for (uint32_t counter = 0; counter < (uint32_t)Width*Height; counter++)
    2550:	81 2c       	mov	r8, r1
    2552:	91 2c       	mov	r9, r1
    2554:	54 01       	movw	r10, r8
    2556:	93 01       	movw	r18, r6
    2558:	de 01       	movw	r26, r28
    255a:	ef d4       	rcall	.+2526   	; 0x2f3a <__umulhisi3>
    255c:	86 16       	cp	r8, r22
    255e:	97 06       	cpc	r9, r23
    2560:	a8 06       	cpc	r10, r24
    2562:	b9 06       	cpc	r11, r25
	{
		WritePixel(Red,Green,Blue);
    2564:	50 f4       	brcc	.+20     	; 0x257a <_Z13FillRectanglejjjjhhh+0x62>
    2566:	40 2f       	mov	r20, r16
    2568:	6e 2d       	mov	r22, r14
    256a:	8c 2d       	mov	r24, r12
    256c:	90 df       	rcall	.-224    	; 0x248e <_Z10WritePixelhhh>
{
	SetPageAddress(StartX,StartX+Width-1);
	SetColumnAddress(StartY,StartY+Height-1);
	MemoryWrite();
	
	for (uint32_t counter = 0; counter < (uint32_t)Width*Height; counter++)
    256e:	8f ef       	ldi	r24, 0xFF	; 255
    2570:	88 1a       	sub	r8, r24
    2572:	98 0a       	sbc	r9, r24
    2574:	a8 0a       	sbc	r10, r24
    2576:	b8 0a       	sbc	r11, r24
	{
		WritePixel(Red,Green,Blue);
	}
	SleepOut();
    2578:	ee cf       	rjmp	.-36     	; 0x2556 <_Z13FillRectanglejjjjhhh+0x3e>
    257a:	3f df       	rcall	.-386    	; 0x23fa <_Z8SleepOutv>
}
    257c:	df 91       	pop	r29
    257e:	cf 91       	pop	r28
    2580:	0f 91       	pop	r16
    2582:	ef 90       	pop	r14
    2584:	cf 90       	pop	r12
    2586:	bf 90       	pop	r11
    2588:	af 90       	pop	r10
    258a:	9f 90       	pop	r9
    258c:	8f 90       	pop	r8
    258e:	7f 90       	pop	r7
    2590:	6f 90       	pop	r6
    2592:	08 95       	ret

00002594 <_ZN11TouchscreenC1Ev>:
	greenBnt = ButtonClass(200, 70, 300, 170, 44, 2, 234);
	
	DisplayInit();
}

Touchscreen::~Touchscreen()
    2594:	0f 93       	push	r16
    2596:	1f 93       	push	r17
    2598:	cf 93       	push	r28
    259a:	df 93       	push	r29
    259c:	cd b7       	in	r28, 0x3d	; 61
    259e:	de b7       	in	r29, 0x3e	; 62
    25a0:	66 97       	sbiw	r28, 0x16	; 22
    25a2:	0f b6       	in	r0, 0x3f	; 63
    25a4:	f8 94       	cli
    25a6:	de bf       	out	0x3e, r29	; 62
    25a8:	0f be       	out	0x3f, r0	; 63
    25aa:	cd bf       	out	0x3d, r28	; 61
    25ac:	8c 01       	movw	r16, r24
    25ae:	4b d1       	rcall	.+662    	; 0x2846 <_ZN11TouchDriverC1Ev>
    25b0:	f8 01       	movw	r30, r16
    25b2:	12 82       	std	Z+2, r1	; 0x02
    25b4:	13 82       	std	Z+3, r1	; 0x03
    25b6:	14 82       	std	Z+4, r1	; 0x04
    25b8:	15 82       	std	Z+5, r1	; 0x05
    25ba:	16 82       	std	Z+6, r1	; 0x06
    25bc:	17 82       	std	Z+7, r1	; 0x07
    25be:	10 86       	std	Z+8, r1	; 0x08
    25c0:	12 86       	std	Z+10, r1	; 0x0a
    25c2:	11 86       	std	Z+9, r1	; 0x09
    25c4:	13 86       	std	Z+11, r1	; 0x0b
    25c6:	14 86       	std	Z+12, r1	; 0x0c
    25c8:	15 86       	std	Z+13, r1	; 0x0d
    25ca:	16 86       	std	Z+14, r1	; 0x0e
    25cc:	17 86       	std	Z+15, r1	; 0x0f
    25ce:	10 8a       	std	Z+16, r1	; 0x10
    25d0:	11 8a       	std	Z+17, r1	; 0x11
    25d2:	12 8a       	std	Z+18, r1	; 0x12
    25d4:	14 8a       	std	Z+20, r1	; 0x14
    25d6:	13 8a       	std	Z+19, r1	; 0x13
    25d8:	15 8a       	std	Z+21, r1	; 0x15
    25da:	ce 01       	movw	r24, r28
    25dc:	45 96       	adiw	r24, 0x15	; 21
    25de:	33 d1       	rcall	.+614    	; 0x2846 <_ZN11TouchDriverC1Ev>
    25e0:	8d 89       	ldd	r24, Y+21	; 0x15
    25e2:	9e 89       	ldd	r25, Y+22	; 0x16
    25e4:	f8 01       	movw	r30, r16
    25e6:	91 83       	std	Z+1, r25	; 0x01
    25e8:	80 83       	st	Z, r24
    25ea:	ce 01       	movw	r24, r28
    25ec:	45 96       	adiw	r24, 0x15	; 21
    25ee:	12 d1       	rcall	.+548    	; 0x2814 <_ZN11TouchDriverD1Ev>
    25f0:	84 e1       	ldi	r24, 0x14	; 20
    25f2:	8b 87       	std	Y+11, r24	; 0x0b
    25f4:	46 e4       	ldi	r20, 0x46	; 70
    25f6:	4c 87       	std	Y+12, r20	; 0x0c
    25f8:	88 e7       	ldi	r24, 0x78	; 120
    25fa:	90 e0       	ldi	r25, 0x00	; 0
    25fc:	9b 8b       	std	Y+19, r25	; 0x13
    25fe:	8a 8b       	std	Y+18, r24	; 0x12
    2600:	3a ea       	ldi	r19, 0xAA	; 170
    2602:	3c 8b       	std	Y+20, r19	; 0x14
    2604:	84 e6       	ldi	r24, 0x64	; 100
    2606:	8e 87       	std	Y+14, r24	; 0x0e
    2608:	8d 87       	std	Y+13, r24	; 0x0d
    260a:	9d e1       	ldi	r25, 0x1D	; 29
    260c:	9f 87       	std	Y+15, r25	; 0x0f
    260e:	9a ee       	ldi	r25, 0xEA	; 234
    2610:	98 8b       	std	Y+16, r25	; 0x10
    2612:	22 e0       	ldi	r18, 0x02	; 2
    2614:	29 8b       	std	Y+17, r18	; 0x11
    2616:	5a e0       	ldi	r21, 0x0A	; 10
    2618:	fe 01       	movw	r30, r28
    261a:	3b 96       	adiw	r30, 0x0b	; 11
    261c:	d8 01       	movw	r26, r16
    261e:	12 96       	adiw	r26, 0x02	; 2
    2620:	01 90       	ld	r0, Z+
    2622:	0d 92       	st	X+, r0
    2624:	5a 95       	dec	r21
    2626:	e1 f7       	brne	.-8      	; 0x2620 <_ZN11TouchscreenC1Ev+0x8c>
    2628:	58 ec       	ldi	r21, 0xC8	; 200
    262a:	59 83       	std	Y+1, r21	; 0x01
    262c:	4a 83       	std	Y+2, r20	; 0x02
    262e:	4c e2       	ldi	r20, 0x2C	; 44
    2630:	51 e0       	ldi	r21, 0x01	; 1
    2632:	59 87       	std	Y+9, r21	; 0x09
    2634:	48 87       	std	Y+8, r20	; 0x08
    2636:	3a 87       	std	Y+10, r19	; 0x0a
    2638:	8c 83       	std	Y+4, r24	; 0x04
    263a:	8b 83       	std	Y+3, r24	; 0x03
    263c:	8c e2       	ldi	r24, 0x2C	; 44
    263e:	8d 83       	std	Y+5, r24	; 0x05
    2640:	2e 83       	std	Y+6, r18	; 0x06
    2642:	9f 83       	std	Y+7, r25	; 0x07
    2644:	8a e0       	ldi	r24, 0x0A	; 10
    2646:	fe 01       	movw	r30, r28
    2648:	31 96       	adiw	r30, 0x01	; 1
    264a:	d8 01       	movw	r26, r16
    264c:	1c 96       	adiw	r26, 0x0c	; 12
    264e:	01 90       	ld	r0, Z+
    2650:	0d 92       	st	X+, r0
    2652:	8a 95       	dec	r24
    2654:	e1 f7       	brne	.-8      	; 0x264e <_ZN11TouchscreenC1Ev+0xba>
    2656:	e9 de       	rcall	.-558    	; 0x242a <_Z11DisplayInitv>
    2658:	66 96       	adiw	r28, 0x16	; 22
    265a:	0f b6       	in	r0, 0x3f	; 63
    265c:	f8 94       	cli
    265e:	de bf       	out	0x3e, r29	; 62
    2660:	0f be       	out	0x3f, r0	; 63
    2662:	cd bf       	out	0x3d, r28	; 61
    2664:	df 91       	pop	r29
    2666:	cf 91       	pop	r28
    2668:	1f 91       	pop	r17
    266a:	0f 91       	pop	r16
    266c:	08 95       	ret

0000266e <_ZN11Touchscreen12checkButtonsEv>:
{
}

uint8_t Touchscreen::checkButtons(void)
{
    266e:	cf 92       	push	r12
    2670:	df 92       	push	r13
    2672:	ef 92       	push	r14
    2674:	ff 92       	push	r15
    2676:	0f 93       	push	r16
    2678:	1f 93       	push	r17
    267a:	cf 93       	push	r28
    267c:	df 93       	push	r29
    267e:	1f 92       	push	r1
    2680:	1f 92       	push	r1
    2682:	cd b7       	in	r28, 0x3d	; 61
    2684:	de b7       	in	r29, 0x3e	; 62
    2686:	8c 01       	movw	r16, r24
	uint8_t x = 0;
    2688:	19 82       	std	Y+1, r1	; 0x01
	uint8_t y = 0;
    268a:	1a 82       	std	Y+2, r1	; 0x02
	
	// receive x and y by call by reference
	TouchDriv.getCoordinates(&x, &y);
    268c:	ae 01       	movw	r20, r28
    268e:	4e 5f       	subi	r20, 0xFE	; 254
    2690:	5f 4f       	sbci	r21, 0xFF	; 255
    2692:	be 01       	movw	r22, r28
    2694:	6f 5f       	subi	r22, 0xFF	; 255
    2696:	7f 4f       	sbci	r23, 0xFF	; 255
    2698:	6b d1       	rcall	.+726    	; 0x2970 <_ZN11TouchDriver14getCoordinatesEPhS0_>
	
	// Print which can be uncommented
	SendString("X value: ");
    269a:	8b eb       	ldi	r24, 0xBB	; 187
    269c:	92 e0       	ldi	r25, 0x02	; 2
    269e:	e6 d1       	rcall	.+972    	; 0x2a6c <_Z10SendStringPc>
	SendInteger(x);
    26a0:	89 81       	ldd	r24, Y+1	; 0x01
    26a2:	90 e0       	ldi	r25, 0x00	; 0
    26a4:	ef d1       	rcall	.+990    	; 0x2a84 <_Z11SendIntegeri>
	SendString("y value: ");
    26a6:	85 ec       	ldi	r24, 0xC5	; 197
    26a8:	92 e0       	ldi	r25, 0x02	; 2
    26aa:	e0 d1       	rcall	.+960    	; 0x2a6c <_Z10SendStringPc>
	SendInteger(y);
    26ac:	8a 81       	ldd	r24, Y+2	; 0x02
    26ae:	90 e0       	ldi	r25, 0x00	; 0
    26b0:	e9 d1       	rcall	.+978    	; 0x2a84 <_Z11SendIntegeri>
	SendString("\r\n");
    26b2:	8a e1       	ldi	r24, 0x1A	; 26
    26b4:	92 e0       	ldi	r25, 0x02	; 2
    26b6:	da d1       	rcall	.+948    	; 0x2a6c <_Z10SendStringPc>
	
	// Check if touch is in between buttons on display. 1.33 is the scaling factor between touch and display.
	// Max Touch Res is 255 while display is 320
	if (x > blueBnt.startX/1.33 && x < blueBnt.endX/1.33 && y > blueBnt.startY && y < blueBnt.endY)
    26b8:	69 81       	ldd	r22, Y+1	; 0x01
    26ba:	70 e0       	ldi	r23, 0x00	; 0
    26bc:	80 e0       	ldi	r24, 0x00	; 0
    26be:	90 e0       	ldi	r25, 0x00	; 0
    26c0:	fb d2       	rcall	.+1526   	; 0x2cb8 <__floatsisf>
    26c2:	6b 01       	movw	r12, r22
    26c4:	7c 01       	movw	r14, r24
    26c6:	f8 01       	movw	r30, r16
    26c8:	62 81       	ldd	r22, Z+2	; 0x02
    26ca:	70 e0       	ldi	r23, 0x00	; 0
    26cc:	80 e0       	ldi	r24, 0x00	; 0
    26ce:	90 e0       	ldi	r25, 0x00	; 0
    26d0:	f3 d2       	rcall	.+1510   	; 0x2cb8 <__floatsisf>
    26d2:	21 e7       	ldi	r18, 0x71	; 113
    26d4:	3d e3       	ldi	r19, 0x3D	; 61
    26d6:	4a ea       	ldi	r20, 0xAA	; 170
    26d8:	5f e3       	ldi	r21, 0x3F	; 63
    26da:	58 d2       	rcall	.+1200   	; 0x2b8c <__divsf3>
    26dc:	9b 01       	movw	r18, r22
    26de:	ac 01       	movw	r20, r24
    26e0:	c7 01       	movw	r24, r14
    26e2:	b6 01       	movw	r22, r12
    26e4:	99 d3       	rcall	.+1842   	; 0x2e18 <__gesf2>
    26e6:	18 16       	cp	r1, r24
    26e8:	d4 f4       	brge	.+52     	; 0x271e <_ZN11Touchscreen12checkButtonsEv+0xb0>
    26ea:	f8 01       	movw	r30, r16
    26ec:	61 85       	ldd	r22, Z+9	; 0x09
    26ee:	72 85       	ldd	r23, Z+10	; 0x0a
    26f0:	80 e0       	ldi	r24, 0x00	; 0
    26f2:	90 e0       	ldi	r25, 0x00	; 0
    26f4:	df d2       	rcall	.+1470   	; 0x2cb4 <__floatunsisf>
    26f6:	21 e7       	ldi	r18, 0x71	; 113
    26f8:	3d e3       	ldi	r19, 0x3D	; 61
    26fa:	4a ea       	ldi	r20, 0xAA	; 170
    26fc:	5f e3       	ldi	r21, 0x3F	; 63
    26fe:	46 d2       	rcall	.+1164   	; 0x2b8c <__divsf3>
    2700:	9b 01       	movw	r18, r22
    2702:	ac 01       	movw	r20, r24
    2704:	c7 01       	movw	r24, r14
    2706:	b6 01       	movw	r22, r12
    2708:	3d d2       	rcall	.+1146   	; 0x2b84 <__cmpsf2>
    270a:	88 23       	and	r24, r24
    270c:	44 f4       	brge	.+16     	; 0x271e <_ZN11Touchscreen12checkButtonsEv+0xb0>
    270e:	f8 01       	movw	r30, r16
    2710:	93 81       	ldd	r25, Z+3	; 0x03
    2712:	8a 81       	ldd	r24, Y+2	; 0x02
    2714:	98 17       	cp	r25, r24
    2716:	18 f4       	brcc	.+6      	; 0x271e <_ZN11Touchscreen12checkButtonsEv+0xb0>
    2718:	93 85       	ldd	r25, Z+11	; 0x0b
    271a:	89 17       	cp	r24, r25
	{
		return 1;
	}
	else if (x > greenBnt.startX/1.33 && x < greenBnt.endX/1.33 && y > greenBnt.startY && y < greenBnt.endY)
    271c:	70 f1       	brcs	.+92     	; 0x277a <_ZN11Touchscreen12checkButtonsEv+0x10c>
    271e:	f8 01       	movw	r30, r16
    2720:	64 85       	ldd	r22, Z+12	; 0x0c
    2722:	70 e0       	ldi	r23, 0x00	; 0
    2724:	80 e0       	ldi	r24, 0x00	; 0
    2726:	90 e0       	ldi	r25, 0x00	; 0
    2728:	c7 d2       	rcall	.+1422   	; 0x2cb8 <__floatsisf>
    272a:	21 e7       	ldi	r18, 0x71	; 113
    272c:	3d e3       	ldi	r19, 0x3D	; 61
    272e:	4a ea       	ldi	r20, 0xAA	; 170
    2730:	5f e3       	ldi	r21, 0x3F	; 63
    2732:	2c d2       	rcall	.+1112   	; 0x2b8c <__divsf3>
    2734:	9b 01       	movw	r18, r22
    2736:	ac 01       	movw	r20, r24
    2738:	c7 01       	movw	r24, r14
    273a:	b6 01       	movw	r22, r12
    273c:	6d d3       	rcall	.+1754   	; 0x2e18 <__gesf2>
    273e:	18 16       	cp	r1, r24
    2740:	f4 f4       	brge	.+60     	; 0x277e <_ZN11Touchscreen12checkButtonsEv+0x110>
    2742:	f8 01       	movw	r30, r16
    2744:	63 89       	ldd	r22, Z+19	; 0x13
    2746:	74 89       	ldd	r23, Z+20	; 0x14
    2748:	80 e0       	ldi	r24, 0x00	; 0
    274a:	90 e0       	ldi	r25, 0x00	; 0
    274c:	b3 d2       	rcall	.+1382   	; 0x2cb4 <__floatunsisf>
    274e:	21 e7       	ldi	r18, 0x71	; 113
    2750:	3d e3       	ldi	r19, 0x3D	; 61
    2752:	4a ea       	ldi	r20, 0xAA	; 170
    2754:	5f e3       	ldi	r21, 0x3F	; 63
    2756:	1a d2       	rcall	.+1076   	; 0x2b8c <__divsf3>
    2758:	9b 01       	movw	r18, r22
    275a:	ac 01       	movw	r20, r24
    275c:	c7 01       	movw	r24, r14
    275e:	b6 01       	movw	r22, r12
    2760:	11 d2       	rcall	.+1058   	; 0x2b84 <__cmpsf2>
    2762:	88 23       	and	r24, r24
    2764:	74 f4       	brge	.+28     	; 0x2782 <_ZN11Touchscreen12checkButtonsEv+0x114>
    2766:	f8 01       	movw	r30, r16
    2768:	95 85       	ldd	r25, Z+13	; 0x0d
    276a:	8a 81       	ldd	r24, Y+2	; 0x02
    276c:	98 17       	cp	r25, r24
    276e:	58 f4       	brcc	.+22     	; 0x2786 <_ZN11Touchscreen12checkButtonsEv+0x118>
    2770:	95 89       	ldd	r25, Z+21	; 0x15
    2772:	89 17       	cp	r24, r25
    2774:	50 f0       	brcs	.+20     	; 0x278a <_ZN11Touchscreen12checkButtonsEv+0x11c>
    2776:	80 e0       	ldi	r24, 0x00	; 0
    2778:	09 c0       	rjmp	.+18     	; 0x278c <_ZN11Touchscreen12checkButtonsEv+0x11e>
	{
		return 2;
	}
	else
	{
		return 0;
    277a:	81 e0       	ldi	r24, 0x01	; 1
    277c:	07 c0       	rjmp	.+14     	; 0x278c <_ZN11Touchscreen12checkButtonsEv+0x11e>
	
	// Check if touch is in between buttons on display. 1.33 is the scaling factor between touch and display.
	// Max Touch Res is 255 while display is 320
	if (x > blueBnt.startX/1.33 && x < blueBnt.endX/1.33 && y > blueBnt.startY && y < blueBnt.endY)
	{
		return 1;
    277e:	80 e0       	ldi	r24, 0x00	; 0
    2780:	05 c0       	rjmp	.+10     	; 0x278c <_ZN11Touchscreen12checkButtonsEv+0x11e>
	{
		return 2;
	}
	else
	{
		return 0;
    2782:	80 e0       	ldi	r24, 0x00	; 0
    2784:	03 c0       	rjmp	.+6      	; 0x278c <_ZN11Touchscreen12checkButtonsEv+0x11e>
    2786:	80 e0       	ldi	r24, 0x00	; 0
    2788:	01 c0       	rjmp	.+2      	; 0x278c <_ZN11Touchscreen12checkButtonsEv+0x11e>
    278a:	82 e0       	ldi	r24, 0x02	; 2
    278c:	0f 90       	pop	r0
	{
		return 1;
	}
	else if (x > greenBnt.startX/1.33 && x < greenBnt.endX/1.33 && y > greenBnt.startY && y < greenBnt.endY)
	{
		return 2;
    278e:	0f 90       	pop	r0
	else
	{
		return 0;
	}
	
}
    2790:	df 91       	pop	r29
    2792:	cf 91       	pop	r28
    2794:	1f 91       	pop	r17
    2796:	0f 91       	pop	r16
    2798:	ff 90       	pop	r15
    279a:	ef 90       	pop	r14
    279c:	df 90       	pop	r13
    279e:	cf 90       	pop	r12
    27a0:	08 95       	ret

000027a2 <_ZN11Touchscreen11clearScreenEv>:
    27a2:	cf 92       	push	r12
    27a4:	ef 92       	push	r14

void Touchscreen::clearScreen(void)
{
    27a6:	0f 93       	push	r16
	// Full Screen White
	FillRectangle(0,0,320,240,255,255,255);
    27a8:	cc 24       	eor	r12, r12
    27aa:	ca 94       	dec	r12
    27ac:	ee 24       	eor	r14, r14
    27ae:	ea 94       	dec	r14
    27b0:	0f ef       	ldi	r16, 0xFF	; 255
    27b2:	20 ef       	ldi	r18, 0xF0	; 240
    27b4:	30 e0       	ldi	r19, 0x00	; 0
    27b6:	40 e4       	ldi	r20, 0x40	; 64
    27b8:	51 e0       	ldi	r21, 0x01	; 1
    27ba:	60 e0       	ldi	r22, 0x00	; 0
    27bc:	70 e0       	ldi	r23, 0x00	; 0
    27be:	80 e0       	ldi	r24, 0x00	; 0
    27c0:	90 e0       	ldi	r25, 0x00	; 0
    27c2:	aa de       	rcall	.-684    	; 0x2518 <_Z13FillRectanglejjjjhhh>
}
    27c4:	0f 91       	pop	r16
    27c6:	ef 90       	pop	r14
    27c8:	cf 90       	pop	r12
    27ca:	08 95       	ret

000027cc <_ZN11Touchscreen23presentButtonsOnDisplayEv>:

void Touchscreen::presentButtonsOnDisplay(void)
{
    27cc:	cf 92       	push	r12
    27ce:	ef 92       	push	r14
    27d0:	0f 93       	push	r16
    27d2:	cf 93       	push	r28
    27d4:	df 93       	push	r29
    27d6:	ec 01       	movw	r28, r24
	
	// Button One
	FillRectangle(blueBnt.startX, blueBnt.startY, blueBnt.width, blueBnt.height, blueBnt.colorRed, blueBnt.colorGreen, blueBnt.colorBlue);
    27d8:	cf 80       	ldd	r12, Y+7	; 0x07
    27da:	e8 84       	ldd	r14, Y+8	; 0x08
    27dc:	0e 81       	ldd	r16, Y+6	; 0x06
    27de:	2c 81       	ldd	r18, Y+4	; 0x04
    27e0:	30 e0       	ldi	r19, 0x00	; 0
    27e2:	4d 81       	ldd	r20, Y+5	; 0x05
    27e4:	50 e0       	ldi	r21, 0x00	; 0
    27e6:	6b 81       	ldd	r22, Y+3	; 0x03
    27e8:	70 e0       	ldi	r23, 0x00	; 0
    27ea:	8a 81       	ldd	r24, Y+2	; 0x02
    27ec:	90 e0       	ldi	r25, 0x00	; 0
    27ee:	94 de       	rcall	.-728    	; 0x2518 <_Z13FillRectanglejjjjhhh>

	// Button Two
	FillRectangle(greenBnt.startX, greenBnt.startY, greenBnt.width, greenBnt.height, greenBnt.colorRed, greenBnt.colorGreen, greenBnt.colorBlue);
    27f0:	c9 88       	ldd	r12, Y+17	; 0x11
    27f2:	ea 88       	ldd	r14, Y+18	; 0x12
    27f4:	08 89       	ldd	r16, Y+16	; 0x10
    27f6:	2e 85       	ldd	r18, Y+14	; 0x0e
    27f8:	30 e0       	ldi	r19, 0x00	; 0
    27fa:	4f 85       	ldd	r20, Y+15	; 0x0f
    27fc:	50 e0       	ldi	r21, 0x00	; 0
    27fe:	6d 85       	ldd	r22, Y+13	; 0x0d
    2800:	70 e0       	ldi	r23, 0x00	; 0
    2802:	8c 85       	ldd	r24, Y+12	; 0x0c
    2804:	90 e0       	ldi	r25, 0x00	; 0
    2806:	88 de       	rcall	.-752    	; 0x2518 <_Z13FillRectanglejjjjhhh>
}
    2808:	df 91       	pop	r29
    280a:	cf 91       	pop	r28
    280c:	0f 91       	pop	r16
    280e:	ef 90       	pop	r14
    2810:	cf 90       	pop	r12
    2812:	08 95       	ret

00002814 <_ZN11TouchDriverD1Ev>:
TouchDriver::TouchDriver()
{
	initTouchDriver();
}

TouchDriver::~TouchDriver()
    2814:	08 95       	ret

00002816 <_ZN11TouchDriver15initTouchDriverEv>:
	/* MODE							= 12bit = High							*/
	/* SER/DFR						= Differential = High					*/
	/* PD1/PD0						= Device always powered = 00			*/
	/************************************************************************/
	
	dinXByte = 0b10011100;
    2816:	2c e9       	ldi	r18, 0x9C	; 156
    2818:	fc 01       	movw	r30, r24
    281a:	20 83       	st	Z, r18
	dinYByte = 0b11011100;
    281c:	2c ed       	ldi	r18, 0xDC	; 220
    281e:	21 83       	std	Z+1, r18	; 0x01
	
	DDRH |= BIT4_SHIFTED;
    2820:	e1 e0       	ldi	r30, 0x01	; 1
    2822:	f1 e0       	ldi	r31, 0x01	; 1
    2824:	80 81       	ld	r24, Z
    2826:	88 60       	ori	r24, 0x08	; 8
    2828:	80 83       	st	Z, r24
	DDRE |= BIT4_SHIFTED;
    282a:	8d b1       	in	r24, 0x0d	; 13
    282c:	88 60       	ori	r24, 0x08	; 8
    282e:	8d b9       	out	0x0d, r24	; 13
	DDRG |= BIT6_SHIFTED;
    2830:	83 b3       	in	r24, 0x13	; 19
    2832:	80 62       	ori	r24, 0x20	; 32
    2834:	83 bb       	out	0x13, r24	; 19
	
	// Enable Interrupt
	EICRB = 0b00000010;
    2836:	82 e0       	ldi	r24, 0x02	; 2
    2838:	80 93 6a 00 	sts	0x006A, r24	; 0x80006a <__TEXT_REGION_LENGTH__+0x70006a>
	EIMSK |= 0b00010000;
    283c:	8d b3       	in	r24, 0x1d	; 29
    283e:	80 61       	ori	r24, 0x10	; 16
    2840:	8d bb       	out	0x1d, r24	; 29
	
	// Enable global Interrupts
	sei();
    2842:	78 94       	sei
    2844:	08 95       	ret

00002846 <_ZN11TouchDriverC1Ev>:
/* PE4 = IRQ (Not Used)													*/
/************************************************************************/

TouchDriver::TouchDriver()
{
	initTouchDriver();
    2846:	e7 cf       	rjmp	.-50     	; 0x2816 <_ZN11TouchDriver15initTouchDriverEv>
    2848:	08 95       	ret

0000284a <__vector_5>:
	sei();
	
}

ISR (INT4_vect)
{
    284a:	1f 92       	push	r1
    284c:	0f 92       	push	r0
    284e:	0f b6       	in	r0, 0x3f	; 63
    2850:	0f 92       	push	r0
    2852:	11 24       	eor	r1, r1
	eIntHappend = 0;
    2854:	10 92 0d 02 	sts	0x020D, r1	; 0x80020d <eIntHappend>
}
    2858:	0f 90       	pop	r0
    285a:	0f be       	out	0x3f, r0	; 63
    285c:	0f 90       	pop	r0
    285e:	1f 90       	pop	r1
    2860:	18 95       	reti

00002862 <_ZN11TouchDriver9readTouchEc>:
    
    uint8_t delayTime = 8;
    uint8_t dinByte = 0;
    
	// Makes is easy to toggle between receiveing x and y coordinates
    if (coord == 'X')
    2862:	68 35       	cpi	r22, 0x58	; 88
    2864:	19 f4       	brne	.+6      	; 0x286c <_ZN11TouchDriver9readTouchEc+0xa>
    {
        dinByte = dinXByte;
    2866:	fc 01       	movw	r30, r24
    2868:	70 81       	ld	r23, Z
    286a:	05 c0       	rjmp	.+10     	; 0x2876 <_ZN11TouchDriver9readTouchEc+0x14>
        
    }else if (coord == 'Y')
    286c:	69 35       	cpi	r22, 0x59	; 89
    286e:	09 f0       	breq	.+2      	; 0x2872 <_ZN11TouchDriver9readTouchEc+0x10>
    2870:	7d c0       	rjmp	.+250    	; 0x296c <_ZN11TouchDriver9readTouchEc+0x10a>
    {
        dinByte = dinYByte;
    2872:	fc 01       	movw	r30, r24
    2874:	71 81       	ldd	r23, Z+1	; 0x01
    else{
        return 255;
    }
    
    // ChipSelect Set to 0    
    CS_PORT &= ~CS_PIN;
    2876:	8e b1       	in	r24, 0x0e	; 14
    2878:	87 7f       	andi	r24, 0xF7	; 247
    287a:	8e b9       	out	0x0e, r24	; 14
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    287c:	fa e2       	ldi	r31, 0x2A	; 42
    287e:	fa 95       	dec	r31
    2880:	f1 f7       	brne	.-4      	; 0x287e <_ZN11TouchDriver9readTouchEc+0x1c>
    2882:	00 c0       	rjmp	.+0      	; 0x2884 <_ZN11TouchDriver9readTouchEc+0x22>
    _delay_us(delayTime);
    
	uint8_t result = 0;
    
    // DIN byte and pulse DCLK for Read X
    for (int i = 7; i >= 0; i--)
    2884:	27 e0       	ldi	r18, 0x07	; 7
    2886:	30 e0       	ldi	r19, 0x00	; 0
    2888:	33 23       	and	r19, r19
    288a:	5c f1       	brlt	.+86     	; 0x28e2 <_ZN11TouchDriver9readTouchEc+0x80>
    288c:	8a e2       	ldi	r24, 0x2A	; 42
    288e:	8a 95       	dec	r24
    2890:	f1 f7       	brne	.-4      	; 0x288e <_ZN11TouchDriver9readTouchEc+0x2c>
    2892:	00 c0       	rjmp	.+0      	; 0x2894 <_ZN11TouchDriver9readTouchEc+0x32>
    {
        _delay_us(delayTime);
        
        DIN_PORT |= (((dinByte >> i)  & 0x01) << 5);
    2894:	64 b3       	in	r22, 0x14	; 20
    2896:	87 2f       	mov	r24, r23
    2898:	90 e0       	ldi	r25, 0x00	; 0
    289a:	02 2e       	mov	r0, r18
    289c:	02 c0       	rjmp	.+4      	; 0x28a2 <_ZN11TouchDriver9readTouchEc+0x40>
    289e:	95 95       	asr	r25
    28a0:	87 95       	ror	r24
    28a2:	0a 94       	dec	r0
    28a4:	e2 f7       	brpl	.-8      	; 0x289e <_ZN11TouchDriver9readTouchEc+0x3c>
    28a6:	81 70       	andi	r24, 0x01	; 1
    28a8:	99 27       	eor	r25, r25
    28aa:	88 0f       	add	r24, r24
    28ac:	99 1f       	adc	r25, r25
    28ae:	82 95       	swap	r24
    28b0:	92 95       	swap	r25
    28b2:	90 7f       	andi	r25, 0xF0	; 240
    28b4:	98 27       	eor	r25, r24
    28b6:	80 7f       	andi	r24, 0xF0	; 240
    28b8:	98 27       	eor	r25, r24
    28ba:	86 2b       	or	r24, r22
    28bc:	84 bb       	out	0x14, r24	; 20
        
        CLK_PORT |= CLK_PIN;
    28be:	e2 e0       	ldi	r30, 0x02	; 2
    28c0:	f1 e0       	ldi	r31, 0x01	; 1
    28c2:	80 81       	ld	r24, Z
    28c4:	88 60       	ori	r24, 0x08	; 8
    28c6:	80 83       	st	Z, r24
    28c8:	9a e2       	ldi	r25, 0x2A	; 42
    28ca:	9a 95       	dec	r25
    28cc:	f1 f7       	brne	.-4      	; 0x28ca <_ZN11TouchDriver9readTouchEc+0x68>
    28ce:	00 c0       	rjmp	.+0      	; 0x28d0 <_ZN11TouchDriver9readTouchEc+0x6e>
		
        _delay_us(delayTime);
        
        CLK_PORT &= ~CLK_PIN;
    28d0:	80 81       	ld	r24, Z
    28d2:	87 7f       	andi	r24, 0xF7	; 247
    28d4:	80 83       	st	Z, r24
        DIN_PORT &= ~BIT6_SHIFTED;
    28d6:	84 b3       	in	r24, 0x14	; 20
    28d8:	8f 7d       	andi	r24, 0xDF	; 223
    28da:	84 bb       	out	0x14, r24	; 20
    _delay_us(delayTime);
    
	uint8_t result = 0;
    
    // DIN byte and pulse DCLK for Read X
    for (int i = 7; i >= 0; i--)
    28dc:	21 50       	subi	r18, 0x01	; 1
    28de:	31 09       	sbc	r19, r1
    28e0:	d3 cf       	rjmp	.-90     	; 0x2888 <_ZN11TouchDriver9readTouchEc+0x26>
    28e2:	27 e0       	ldi	r18, 0x07	; 7
    28e4:	30 e0       	ldi	r19, 0x00	; 0
    28e6:	80 e0       	ldi	r24, 0x00	; 0
        CLK_PORT &= ~CLK_PIN;
        DIN_PORT &= ~BIT6_SHIFTED;
    }
        
    // Systematically read DOUT
    for (int i = 7; i >= 0; i--)
    28e8:	33 23       	and	r19, r19
    28ea:	24 f1       	brlt	.+72     	; 0x2934 <_ZN11TouchDriver9readTouchEc+0xd2>
    28ec:	ea e2       	ldi	r30, 0x2A	; 42
    28ee:	ea 95       	dec	r30
    28f0:	f1 f7       	brne	.-4      	; 0x28ee <_ZN11TouchDriver9readTouchEc+0x8c>
    28f2:	00 c0       	rjmp	.+0      	; 0x28f4 <_ZN11TouchDriver9readTouchEc+0x92>
    {
        _delay_us(delayTime);
        
        CLK_PORT |= CLK_PIN;
    28f4:	e2 e0       	ldi	r30, 0x02	; 2
    28f6:	f1 e0       	ldi	r31, 0x01	; 1
    28f8:	90 81       	ld	r25, Z
    28fa:	98 60       	ori	r25, 0x08	; 8
    28fc:	90 83       	st	Z, r25
    28fe:	9a e2       	ldi	r25, 0x2A	; 42
    2900:	9a 95       	dec	r25
    2902:	f1 f7       	brne	.-4      	; 0x2900 <_ZN11TouchDriver9readTouchEc+0x9e>
    2904:	00 c0       	rjmp	.+0      	; 0x2906 <_ZN11TouchDriver9readTouchEc+0xa4>
        _delay_us(delayTime);
        CLK_PORT &= ~CLK_PIN;
    2906:	90 81       	ld	r25, Z
    2908:	97 7f       	andi	r25, 0xF7	; 247
    290a:	90 83       	st	Z, r25
    290c:	e5 e0       	ldi	r30, 0x05	; 5
    290e:	ea 95       	dec	r30
    2910:	f1 f7       	brne	.-4      	; 0x290e <_ZN11TouchDriver9readTouchEc+0xac>
    2912:	00 00       	nop
        _delay_us(1);
        
        bool temp = (PINE & (1U << 5));
    2914:	9c b1       	in	r25, 0x0c	; 12
        
        result |= (temp << i);
    2916:	95 fb       	bst	r25, 5
    2918:	44 27       	eor	r20, r20
    291a:	40 f9       	bld	r20, 0
    291c:	50 e0       	ldi	r21, 0x00	; 0
    291e:	ba 01       	movw	r22, r20
    2920:	02 2e       	mov	r0, r18
    2922:	02 c0       	rjmp	.+4      	; 0x2928 <_ZN11TouchDriver9readTouchEc+0xc6>
    2924:	66 0f       	add	r22, r22
    2926:	77 1f       	adc	r23, r23
    2928:	0a 94       	dec	r0
    292a:	e2 f7       	brpl	.-8      	; 0x2924 <_ZN11TouchDriver9readTouchEc+0xc2>
    292c:	86 2b       	or	r24, r22
        CLK_PORT &= ~CLK_PIN;
        DIN_PORT &= ~BIT6_SHIFTED;
    }
        
    // Systematically read DOUT
    for (int i = 7; i >= 0; i--)
    292e:	21 50       	subi	r18, 0x01	; 1
    2930:	31 09       	sbc	r19, r1
    2932:	da cf       	rjmp	.-76     	; 0x28e8 <_ZN11TouchDriver9readTouchEc+0x86>
    2934:	27 e0       	ldi	r18, 0x07	; 7
    2936:	30 e0       	ldi	r19, 0x00	; 0
        bool temp = (PINE & (1U << 5));
        
        result |= (temp << i);
    }
    
    for (int i = 7; i >= 0; i--)
    2938:	33 23       	and	r19, r19
    293a:	9c f0       	brlt	.+38     	; 0x2962 <_ZN11TouchDriver9readTouchEc+0x100>
    293c:	fa e2       	ldi	r31, 0x2A	; 42
    293e:	fa 95       	dec	r31
    2940:	f1 f7       	brne	.-4      	; 0x293e <_ZN11TouchDriver9readTouchEc+0xdc>
    2942:	00 c0       	rjmp	.+0      	; 0x2944 <_ZN11TouchDriver9readTouchEc+0xe2>
    {
        
        _delay_us(delayTime);
        CLK_PORT |= CLK_PIN;
    2944:	e2 e0       	ldi	r30, 0x02	; 2
    2946:	f1 e0       	ldi	r31, 0x01	; 1
    2948:	90 81       	ld	r25, Z
    294a:	98 60       	ori	r25, 0x08	; 8
    294c:	90 83       	st	Z, r25
    294e:	9a e2       	ldi	r25, 0x2A	; 42
    2950:	9a 95       	dec	r25
    2952:	f1 f7       	brne	.-4      	; 0x2950 <_ZN11TouchDriver9readTouchEc+0xee>
    2954:	00 c0       	rjmp	.+0      	; 0x2956 <_ZN11TouchDriver9readTouchEc+0xf4>
        _delay_us(delayTime);
        CLK_PORT &= ~CLK_PIN;
    2956:	90 81       	ld	r25, Z
    2958:	97 7f       	andi	r25, 0xF7	; 247
    295a:	90 83       	st	Z, r25
        bool temp = (PINE & (1U << 5));
        
        result |= (temp << i);
    }
    
    for (int i = 7; i >= 0; i--)
    295c:	21 50       	subi	r18, 0x01	; 1
    295e:	31 09       	sbc	r19, r1
    2960:	eb cf       	rjmp	.-42     	; 0x2938 <_ZN11TouchDriver9readTouchEc+0xd6>
        CLK_PORT |= CLK_PIN;
        _delay_us(delayTime);
        CLK_PORT &= ~CLK_PIN;
    }
    
    CS_PORT |= CS_PIN;
    2962:	9e b1       	in	r25, 0x0e	; 14
    2964:	98 60       	ori	r25, 0x08	; 8
    2966:	9e b9       	out	0x0e, r25	; 14
        
    return ~result;
    2968:	80 95       	com	r24
    296a:	08 95       	ret
    }else if (coord == 'Y')
    {
        dinByte = dinYByte;
    }
    else{
        return 255;
    296c:	8f ef       	ldi	r24, 0xFF	; 255
    }
    
    CS_PORT |= CS_PIN;
        
    return ~result;
    296e:	08 95       	ret

00002970 <_ZN11TouchDriver14getCoordinatesEPhS0_>:
{
	eIntHappend = 0;
}

void TouchDriver::getCoordinates(uint8_t *x_ptr, uint8_t *y_ptr)
{	
    2970:	ef 92       	push	r14
    2972:	ff 92       	push	r15
    2974:	0f 93       	push	r16
    2976:	1f 93       	push	r17
    2978:	cf 93       	push	r28
    297a:	df 93       	push	r29
    297c:	ec 01       	movw	r28, r24
    297e:	7b 01       	movw	r14, r22
    2980:	8a 01       	movw	r16, r20
	while(eIntHappend != 0);
    2982:	80 91 0d 02 	lds	r24, 0x020D	; 0x80020d <eIntHappend>
    2986:	81 11       	cpse	r24, r1
    2988:	fc cf       	rjmp	.-8      	; 0x2982 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x12>
	
	//taskENTER_CRITICAL();
	*x_ptr = readTouch('X');
    298a:	68 e5       	ldi	r22, 0x58	; 88
    298c:	ce 01       	movw	r24, r28
    298e:	69 df       	rcall	.-302    	; 0x2862 <_ZN11TouchDriver9readTouchEc>
    2990:	f7 01       	movw	r30, r14
    2992:	80 83       	st	Z, r24
	*y_ptr = readTouch('Y');
    2994:	69 e5       	ldi	r22, 0x59	; 89
    2996:	ce 01       	movw	r24, r28
    2998:	64 df       	rcall	.-312    	; 0x2862 <_ZN11TouchDriver9readTouchEc>
    299a:	f8 01       	movw	r30, r16
    299c:	80 83       	st	Z, r24
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    299e:	ff ef       	ldi	r31, 0xFF	; 255
    29a0:	20 e7       	ldi	r18, 0x70	; 112
    29a2:	82 e0       	ldi	r24, 0x02	; 2
    29a4:	f1 50       	subi	r31, 0x01	; 1
    29a6:	20 40       	sbci	r18, 0x00	; 0
    29a8:	80 40       	sbci	r24, 0x00	; 0
    29aa:	e1 f7       	brne	.-8      	; 0x29a4 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x34>
    29ac:	00 c0       	rjmp	.+0      	; 0x29ae <_ZN11TouchDriver14getCoordinatesEPhS0_+0x3e>
    29ae:	00 00       	nop
	//taskEXIT_CRITICAL();
	_delay_ms( 50 );
	eIntHappend = 255;
    29b0:	8f ef       	ldi	r24, 0xFF	; 255
    29b2:	80 93 0d 02 	sts	0x020D, r24	; 0x80020d <eIntHappend>
	
}
    29b6:	df 91       	pop	r29
    29b8:	cf 91       	pop	r28
    29ba:	1f 91       	pop	r17
    29bc:	0f 91       	pop	r16
    29be:	ff 90       	pop	r15
    29c0:	ef 90       	pop	r14
    29c2:	08 95       	ret

000029c4 <_Z8InitUARTmhc>:
  // Wait for new character received
  while ( (UCSR0A & (1<<7)) == 0 )
  {}                        
  // Then return it
  return UDR0;
}
    29c4:	0f 93       	push	r16
    29c6:	1f 93       	push	r17
    29c8:	52 2f       	mov	r21, r18
    29ca:	8b 01       	movw	r16, r22
    29cc:	9c 01       	movw	r18, r24
    29ce:	0c 52       	subi	r16, 0x2C	; 44
    29d0:	11 40       	sbci	r17, 0x01	; 1
    29d2:	21 09       	sbc	r18, r1
    29d4:	31 09       	sbc	r19, r1
    29d6:	05 3d       	cpi	r16, 0xD5	; 213
    29d8:	10 4c       	sbci	r17, 0xC0	; 192
    29da:	21 40       	sbci	r18, 0x01	; 1
    29dc:	31 05       	cpc	r19, r1
    29de:	e0 f5       	brcc	.+120    	; 0x2a58 <_Z8InitUARTmhc+0x94>
    29e0:	45 30       	cpi	r20, 0x05	; 5
    29e2:	d0 f1       	brcs	.+116    	; 0x2a58 <_Z8InitUARTmhc+0x94>
    29e4:	49 30       	cpi	r20, 0x09	; 9
    29e6:	c0 f5       	brcc	.+112    	; 0x2a58 <_Z8InitUARTmhc+0x94>
    29e8:	20 e2       	ldi	r18, 0x20	; 32
    29ea:	20 93 c0 00 	sts	0x00C0, r18	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7000c0>
    29ee:	28 e1       	ldi	r18, 0x18	; 24
    29f0:	20 93 c1 00 	sts	0x00C1, r18	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7000c1>
    29f4:	45 50       	subi	r20, 0x05	; 5
    29f6:	44 0f       	add	r20, r20
    29f8:	40 93 c2 00 	sts	0x00C2, r20	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7000c2>
    29fc:	55 34       	cpi	r21, 0x45	; 69
    29fe:	31 f4       	brne	.+12     	; 0x2a0c <_Z8InitUARTmhc+0x48>
    2a00:	e2 ec       	ldi	r30, 0xC2	; 194
    2a02:	f0 e0       	ldi	r31, 0x00	; 0
    2a04:	20 81       	ld	r18, Z
    2a06:	20 62       	ori	r18, 0x20	; 32
    2a08:	20 83       	st	Z, r18
    2a0a:	07 c0       	rjmp	.+14     	; 0x2a1a <_Z8InitUARTmhc+0x56>
    2a0c:	5f 34       	cpi	r21, 0x4F	; 79
    2a0e:	29 f4       	brne	.+10     	; 0x2a1a <_Z8InitUARTmhc+0x56>
    2a10:	e2 ec       	ldi	r30, 0xC2	; 194
    2a12:	f0 e0       	ldi	r31, 0x00	; 0
    2a14:	20 81       	ld	r18, Z
    2a16:	20 63       	ori	r18, 0x30	; 48
    2a18:	20 83       	st	Z, r18
    2a1a:	dc 01       	movw	r26, r24
    2a1c:	cb 01       	movw	r24, r22
    2a1e:	88 0f       	add	r24, r24
    2a20:	99 1f       	adc	r25, r25
    2a22:	aa 1f       	adc	r26, r26
    2a24:	bb 1f       	adc	r27, r27
    2a26:	88 0f       	add	r24, r24
    2a28:	99 1f       	adc	r25, r25
    2a2a:	aa 1f       	adc	r26, r26
    2a2c:	bb 1f       	adc	r27, r27
    2a2e:	9c 01       	movw	r18, r24
    2a30:	ad 01       	movw	r20, r26
    2a32:	22 0f       	add	r18, r18
    2a34:	33 1f       	adc	r19, r19
    2a36:	44 1f       	adc	r20, r20
    2a38:	55 1f       	adc	r21, r21
    2a3a:	22 0f       	add	r18, r18
    2a3c:	33 1f       	adc	r19, r19
    2a3e:	44 1f       	adc	r20, r20
    2a40:	55 1f       	adc	r21, r21
    2a42:	60 e0       	ldi	r22, 0x00	; 0
    2a44:	74 e2       	ldi	r23, 0x24	; 36
    2a46:	84 ef       	ldi	r24, 0xF4	; 244
    2a48:	90 e0       	ldi	r25, 0x00	; 0
    2a4a:	4d d2       	rcall	.+1178   	; 0x2ee6 <__udivmodsi4>
    2a4c:	21 50       	subi	r18, 0x01	; 1
    2a4e:	31 09       	sbc	r19, r1
    2a50:	30 93 c5 00 	sts	0x00C5, r19	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7000c5>
    2a54:	20 93 c4 00 	sts	0x00C4, r18	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7000c4>
    2a58:	1f 91       	pop	r17
    2a5a:	0f 91       	pop	r16
    2a5c:	08 95       	ret

00002a5e <_Z8SendCharc>:
	Tegn : Character for sending. 
*************************************************************************/
void SendChar(char Tegn)
{
  // Wait for transmitter register empty (ready for new character)
  while ( (UCSR0A & (1<<5)) == 0 )
    2a5e:	90 91 c0 00 	lds	r25, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7000c0>
    2a62:	95 ff       	sbrs	r25, 5
    2a64:	fc cf       	rjmp	.-8      	; 0x2a5e <_Z8SendCharc>
  {}
  // Then send the character
  UDR0 = Tegn;
    2a66:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7000c6>
    2a6a:	08 95       	ret

00002a6c <_Z10SendStringPc>:
Sends 0 terminated string.
Parameter:
   Streng: Pointer to the string. 
*************************************************************************/
void SendString(char* Streng)
{
    2a6c:	cf 93       	push	r28
    2a6e:	df 93       	push	r29
    2a70:	ec 01       	movw	r28, r24
  // Repeat until zero-termination
  while (*Streng != 0)
    2a72:	88 81       	ld	r24, Y
    2a74:	88 23       	and	r24, r24
    2a76:	19 f0       	breq	.+6      	; 0x2a7e <_Z10SendStringPc+0x12>
  {
    // Send the character pointed to by "Streng"
    SendChar(*Streng);
    2a78:	f2 df       	rcall	.-28     	; 0x2a5e <_Z8SendCharc>
    // Advance the pointer one step
    Streng++;
    2a7a:	21 96       	adiw	r28, 0x01	; 1
   Streng: Pointer to the string. 
*************************************************************************/
void SendString(char* Streng)
{
  // Repeat until zero-termination
  while (*Streng != 0)
    2a7c:	fa cf       	rjmp	.-12     	; 0x2a72 <_Z10SendStringPc+0x6>
    // Send the character pointed to by "Streng"
    SendChar(*Streng);
    // Advance the pointer one step
    Streng++;
  }
}
    2a7e:	df 91       	pop	r29
    2a80:	cf 91       	pop	r28
    2a82:	08 95       	ret

00002a84 <_Z11SendIntegeri>:
Makes use of the C standard library <stdlib.h>.
Parameter:
    Tal: The integer to be converted and sent. 
*************************************************************************/
void SendInteger(int Tal)
{
    2a84:	cf 93       	push	r28
    2a86:	df 93       	push	r29
    2a88:	cd b7       	in	r28, 0x3d	; 61
    2a8a:	de b7       	in	r29, 0x3e	; 62
    2a8c:	27 97       	sbiw	r28, 0x07	; 7
    2a8e:	0f b6       	in	r0, 0x3f	; 63
    2a90:	f8 94       	cli
    2a92:	de bf       	out	0x3e, r29	; 62
    2a94:	0f be       	out	0x3f, r0	; 63
    2a96:	cd bf       	out	0x3d, r28	; 61
    } else if (__radix < 2 || __radix > 36) {
	*__s = 0;
	return __s;
    } else {
	extern char *__itoa_ncheck (int, char *, unsigned char);
	return __itoa_ncheck (__val, __s, __radix);
    2a98:	4a e0       	ldi	r20, 0x0A	; 10
    2a9a:	be 01       	movw	r22, r28
    2a9c:	6f 5f       	subi	r22, 0xFF	; 255
    2a9e:	7f 4f       	sbci	r23, 0xFF	; 255
    2aa0:	92 d3       	rcall	.+1828   	; 0x31c6 <__itoa_ncheck>
char array[7];
  // Convert the integer to an ASCII string (array), radix = 10 
  itoa(Tal, array, 10);
  // - then send the string
  SendString(array);
    2aa2:	ce 01       	movw	r24, r28
    2aa4:	01 96       	adiw	r24, 0x01	; 1
    2aa6:	e2 df       	rcall	.-60     	; 0x2a6c <_Z10SendStringPc>
}
    2aa8:	27 96       	adiw	r28, 0x07	; 7
    2aaa:	0f b6       	in	r0, 0x3f	; 63
    2aac:	f8 94       	cli
    2aae:	de bf       	out	0x3e, r29	; 62
    2ab0:	0f be       	out	0x3f, r0	; 63
    2ab2:	cd bf       	out	0x3d, r28	; 61
    2ab4:	df 91       	pop	r29
    2ab6:	cf 91       	pop	r28
    2ab8:	08 95       	ret

00002aba <__subsf3>:
    2aba:	50 58       	subi	r21, 0x80	; 128

00002abc <__addsf3>:
    2abc:	bb 27       	eor	r27, r27
    2abe:	aa 27       	eor	r26, r26
    2ac0:	0e d0       	rcall	.+28     	; 0x2ade <__addsf3x>
    2ac2:	70 c1       	rjmp	.+736    	; 0x2da4 <__fp_round>
    2ac4:	61 d1       	rcall	.+706    	; 0x2d88 <__fp_pscA>
    2ac6:	30 f0       	brcs	.+12     	; 0x2ad4 <__addsf3+0x18>
    2ac8:	66 d1       	rcall	.+716    	; 0x2d96 <__fp_pscB>
    2aca:	20 f0       	brcs	.+8      	; 0x2ad4 <__addsf3+0x18>
    2acc:	31 f4       	brne	.+12     	; 0x2ada <__addsf3+0x1e>
    2ace:	9f 3f       	cpi	r25, 0xFF	; 255
    2ad0:	11 f4       	brne	.+4      	; 0x2ad6 <__addsf3+0x1a>
    2ad2:	1e f4       	brtc	.+6      	; 0x2ada <__addsf3+0x1e>
    2ad4:	56 c1       	rjmp	.+684    	; 0x2d82 <__fp_nan>
    2ad6:	0e f4       	brtc	.+2      	; 0x2ada <__addsf3+0x1e>
    2ad8:	e0 95       	com	r30
    2ada:	e7 fb       	bst	r30, 7
    2adc:	4c c1       	rjmp	.+664    	; 0x2d76 <__fp_inf>

00002ade <__addsf3x>:
    2ade:	e9 2f       	mov	r30, r25
    2ae0:	72 d1       	rcall	.+740    	; 0x2dc6 <__fp_split3>
    2ae2:	80 f3       	brcs	.-32     	; 0x2ac4 <__addsf3+0x8>
    2ae4:	ba 17       	cp	r27, r26
    2ae6:	62 07       	cpc	r22, r18
    2ae8:	73 07       	cpc	r23, r19
    2aea:	84 07       	cpc	r24, r20
    2aec:	95 07       	cpc	r25, r21
    2aee:	18 f0       	brcs	.+6      	; 0x2af6 <__addsf3x+0x18>
    2af0:	71 f4       	brne	.+28     	; 0x2b0e <__addsf3x+0x30>
    2af2:	9e f5       	brtc	.+102    	; 0x2b5a <__addsf3x+0x7c>
    2af4:	8a c1       	rjmp	.+788    	; 0x2e0a <__fp_zero>
    2af6:	0e f4       	brtc	.+2      	; 0x2afa <__addsf3x+0x1c>
    2af8:	e0 95       	com	r30
    2afa:	0b 2e       	mov	r0, r27
    2afc:	ba 2f       	mov	r27, r26
    2afe:	a0 2d       	mov	r26, r0
    2b00:	0b 01       	movw	r0, r22
    2b02:	b9 01       	movw	r22, r18
    2b04:	90 01       	movw	r18, r0
    2b06:	0c 01       	movw	r0, r24
    2b08:	ca 01       	movw	r24, r20
    2b0a:	a0 01       	movw	r20, r0
    2b0c:	11 24       	eor	r1, r1
    2b0e:	ff 27       	eor	r31, r31
    2b10:	59 1b       	sub	r21, r25
    2b12:	99 f0       	breq	.+38     	; 0x2b3a <__addsf3x+0x5c>
    2b14:	59 3f       	cpi	r21, 0xF9	; 249
    2b16:	50 f4       	brcc	.+20     	; 0x2b2c <__addsf3x+0x4e>
    2b18:	50 3e       	cpi	r21, 0xE0	; 224
    2b1a:	68 f1       	brcs	.+90     	; 0x2b76 <__addsf3x+0x98>
    2b1c:	1a 16       	cp	r1, r26
    2b1e:	f0 40       	sbci	r31, 0x00	; 0
    2b20:	a2 2f       	mov	r26, r18
    2b22:	23 2f       	mov	r18, r19
    2b24:	34 2f       	mov	r19, r20
    2b26:	44 27       	eor	r20, r20
    2b28:	58 5f       	subi	r21, 0xF8	; 248
    2b2a:	f3 cf       	rjmp	.-26     	; 0x2b12 <__addsf3x+0x34>
    2b2c:	46 95       	lsr	r20
    2b2e:	37 95       	ror	r19
    2b30:	27 95       	ror	r18
    2b32:	a7 95       	ror	r26
    2b34:	f0 40       	sbci	r31, 0x00	; 0
    2b36:	53 95       	inc	r21
    2b38:	c9 f7       	brne	.-14     	; 0x2b2c <__addsf3x+0x4e>
    2b3a:	7e f4       	brtc	.+30     	; 0x2b5a <__addsf3x+0x7c>
    2b3c:	1f 16       	cp	r1, r31
    2b3e:	ba 0b       	sbc	r27, r26
    2b40:	62 0b       	sbc	r22, r18
    2b42:	73 0b       	sbc	r23, r19
    2b44:	84 0b       	sbc	r24, r20
    2b46:	ba f0       	brmi	.+46     	; 0x2b76 <__addsf3x+0x98>
    2b48:	91 50       	subi	r25, 0x01	; 1
    2b4a:	a1 f0       	breq	.+40     	; 0x2b74 <__addsf3x+0x96>
    2b4c:	ff 0f       	add	r31, r31
    2b4e:	bb 1f       	adc	r27, r27
    2b50:	66 1f       	adc	r22, r22
    2b52:	77 1f       	adc	r23, r23
    2b54:	88 1f       	adc	r24, r24
    2b56:	c2 f7       	brpl	.-16     	; 0x2b48 <__addsf3x+0x6a>
    2b58:	0e c0       	rjmp	.+28     	; 0x2b76 <__addsf3x+0x98>
    2b5a:	ba 0f       	add	r27, r26
    2b5c:	62 1f       	adc	r22, r18
    2b5e:	73 1f       	adc	r23, r19
    2b60:	84 1f       	adc	r24, r20
    2b62:	48 f4       	brcc	.+18     	; 0x2b76 <__addsf3x+0x98>
    2b64:	87 95       	ror	r24
    2b66:	77 95       	ror	r23
    2b68:	67 95       	ror	r22
    2b6a:	b7 95       	ror	r27
    2b6c:	f7 95       	ror	r31
    2b6e:	9e 3f       	cpi	r25, 0xFE	; 254
    2b70:	08 f0       	brcs	.+2      	; 0x2b74 <__addsf3x+0x96>
    2b72:	b3 cf       	rjmp	.-154    	; 0x2ada <__addsf3+0x1e>
    2b74:	93 95       	inc	r25
    2b76:	88 0f       	add	r24, r24
    2b78:	08 f0       	brcs	.+2      	; 0x2b7c <__addsf3x+0x9e>
    2b7a:	99 27       	eor	r25, r25
    2b7c:	ee 0f       	add	r30, r30
    2b7e:	97 95       	ror	r25
    2b80:	87 95       	ror	r24
    2b82:	08 95       	ret

00002b84 <__cmpsf2>:
    2b84:	d4 d0       	rcall	.+424    	; 0x2d2e <__fp_cmp>
    2b86:	08 f4       	brcc	.+2      	; 0x2b8a <__cmpsf2+0x6>
    2b88:	81 e0       	ldi	r24, 0x01	; 1
    2b8a:	08 95       	ret

00002b8c <__divsf3>:
    2b8c:	0c d0       	rcall	.+24     	; 0x2ba6 <__divsf3x>
    2b8e:	0a c1       	rjmp	.+532    	; 0x2da4 <__fp_round>
    2b90:	02 d1       	rcall	.+516    	; 0x2d96 <__fp_pscB>
    2b92:	40 f0       	brcs	.+16     	; 0x2ba4 <__divsf3+0x18>
    2b94:	f9 d0       	rcall	.+498    	; 0x2d88 <__fp_pscA>
    2b96:	30 f0       	brcs	.+12     	; 0x2ba4 <__divsf3+0x18>
    2b98:	21 f4       	brne	.+8      	; 0x2ba2 <__divsf3+0x16>
    2b9a:	5f 3f       	cpi	r21, 0xFF	; 255
    2b9c:	19 f0       	breq	.+6      	; 0x2ba4 <__divsf3+0x18>
    2b9e:	eb c0       	rjmp	.+470    	; 0x2d76 <__fp_inf>
    2ba0:	51 11       	cpse	r21, r1
    2ba2:	34 c1       	rjmp	.+616    	; 0x2e0c <__fp_szero>
    2ba4:	ee c0       	rjmp	.+476    	; 0x2d82 <__fp_nan>

00002ba6 <__divsf3x>:
    2ba6:	0f d1       	rcall	.+542    	; 0x2dc6 <__fp_split3>
    2ba8:	98 f3       	brcs	.-26     	; 0x2b90 <__divsf3+0x4>

00002baa <__divsf3_pse>:
    2baa:	99 23       	and	r25, r25
    2bac:	c9 f3       	breq	.-14     	; 0x2ba0 <__divsf3+0x14>
    2bae:	55 23       	and	r21, r21
    2bb0:	b1 f3       	breq	.-20     	; 0x2b9e <__divsf3+0x12>
    2bb2:	95 1b       	sub	r25, r21
    2bb4:	55 0b       	sbc	r21, r21
    2bb6:	bb 27       	eor	r27, r27
    2bb8:	aa 27       	eor	r26, r26
    2bba:	62 17       	cp	r22, r18
    2bbc:	73 07       	cpc	r23, r19
    2bbe:	84 07       	cpc	r24, r20
    2bc0:	38 f0       	brcs	.+14     	; 0x2bd0 <__divsf3_pse+0x26>
    2bc2:	9f 5f       	subi	r25, 0xFF	; 255
    2bc4:	5f 4f       	sbci	r21, 0xFF	; 255
    2bc6:	22 0f       	add	r18, r18
    2bc8:	33 1f       	adc	r19, r19
    2bca:	44 1f       	adc	r20, r20
    2bcc:	aa 1f       	adc	r26, r26
    2bce:	a9 f3       	breq	.-22     	; 0x2bba <__divsf3_pse+0x10>
    2bd0:	33 d0       	rcall	.+102    	; 0x2c38 <__divsf3_pse+0x8e>
    2bd2:	0e 2e       	mov	r0, r30
    2bd4:	3a f0       	brmi	.+14     	; 0x2be4 <__divsf3_pse+0x3a>
    2bd6:	e0 e8       	ldi	r30, 0x80	; 128
    2bd8:	30 d0       	rcall	.+96     	; 0x2c3a <__divsf3_pse+0x90>
    2bda:	91 50       	subi	r25, 0x01	; 1
    2bdc:	50 40       	sbci	r21, 0x00	; 0
    2bde:	e6 95       	lsr	r30
    2be0:	00 1c       	adc	r0, r0
    2be2:	ca f7       	brpl	.-14     	; 0x2bd6 <__divsf3_pse+0x2c>
    2be4:	29 d0       	rcall	.+82     	; 0x2c38 <__divsf3_pse+0x8e>
    2be6:	fe 2f       	mov	r31, r30
    2be8:	27 d0       	rcall	.+78     	; 0x2c38 <__divsf3_pse+0x8e>
    2bea:	66 0f       	add	r22, r22
    2bec:	77 1f       	adc	r23, r23
    2bee:	88 1f       	adc	r24, r24
    2bf0:	bb 1f       	adc	r27, r27
    2bf2:	26 17       	cp	r18, r22
    2bf4:	37 07       	cpc	r19, r23
    2bf6:	48 07       	cpc	r20, r24
    2bf8:	ab 07       	cpc	r26, r27
    2bfa:	b0 e8       	ldi	r27, 0x80	; 128
    2bfc:	09 f0       	breq	.+2      	; 0x2c00 <__divsf3_pse+0x56>
    2bfe:	bb 0b       	sbc	r27, r27
    2c00:	80 2d       	mov	r24, r0
    2c02:	bf 01       	movw	r22, r30
    2c04:	ff 27       	eor	r31, r31
    2c06:	93 58       	subi	r25, 0x83	; 131
    2c08:	5f 4f       	sbci	r21, 0xFF	; 255
    2c0a:	2a f0       	brmi	.+10     	; 0x2c16 <__divsf3_pse+0x6c>
    2c0c:	9e 3f       	cpi	r25, 0xFE	; 254
    2c0e:	51 05       	cpc	r21, r1
    2c10:	68 f0       	brcs	.+26     	; 0x2c2c <__divsf3_pse+0x82>
    2c12:	b1 c0       	rjmp	.+354    	; 0x2d76 <__fp_inf>
    2c14:	fb c0       	rjmp	.+502    	; 0x2e0c <__fp_szero>
    2c16:	5f 3f       	cpi	r21, 0xFF	; 255
    2c18:	ec f3       	brlt	.-6      	; 0x2c14 <__divsf3_pse+0x6a>
    2c1a:	98 3e       	cpi	r25, 0xE8	; 232
    2c1c:	dc f3       	brlt	.-10     	; 0x2c14 <__divsf3_pse+0x6a>
    2c1e:	86 95       	lsr	r24
    2c20:	77 95       	ror	r23
    2c22:	67 95       	ror	r22
    2c24:	b7 95       	ror	r27
    2c26:	f7 95       	ror	r31
    2c28:	9f 5f       	subi	r25, 0xFF	; 255
    2c2a:	c9 f7       	brne	.-14     	; 0x2c1e <__divsf3_pse+0x74>
    2c2c:	88 0f       	add	r24, r24
    2c2e:	91 1d       	adc	r25, r1
    2c30:	96 95       	lsr	r25
    2c32:	87 95       	ror	r24
    2c34:	97 f9       	bld	r25, 7
    2c36:	08 95       	ret
    2c38:	e1 e0       	ldi	r30, 0x01	; 1
    2c3a:	66 0f       	add	r22, r22
    2c3c:	77 1f       	adc	r23, r23
    2c3e:	88 1f       	adc	r24, r24
    2c40:	bb 1f       	adc	r27, r27
    2c42:	62 17       	cp	r22, r18
    2c44:	73 07       	cpc	r23, r19
    2c46:	84 07       	cpc	r24, r20
    2c48:	ba 07       	cpc	r27, r26
    2c4a:	20 f0       	brcs	.+8      	; 0x2c54 <__divsf3_pse+0xaa>
    2c4c:	62 1b       	sub	r22, r18
    2c4e:	73 0b       	sbc	r23, r19
    2c50:	84 0b       	sbc	r24, r20
    2c52:	ba 0b       	sbc	r27, r26
    2c54:	ee 1f       	adc	r30, r30
    2c56:	88 f7       	brcc	.-30     	; 0x2c3a <__divsf3_pse+0x90>
    2c58:	e0 95       	com	r30
    2c5a:	08 95       	ret

00002c5c <__fixunssfsi>:
    2c5c:	bc d0       	rcall	.+376    	; 0x2dd6 <__fp_splitA>
    2c5e:	88 f0       	brcs	.+34     	; 0x2c82 <__fixunssfsi+0x26>
    2c60:	9f 57       	subi	r25, 0x7F	; 127
    2c62:	90 f0       	brcs	.+36     	; 0x2c88 <__fixunssfsi+0x2c>
    2c64:	b9 2f       	mov	r27, r25
    2c66:	99 27       	eor	r25, r25
    2c68:	b7 51       	subi	r27, 0x17	; 23
    2c6a:	a0 f0       	brcs	.+40     	; 0x2c94 <__fixunssfsi+0x38>
    2c6c:	d1 f0       	breq	.+52     	; 0x2ca2 <__fixunssfsi+0x46>
    2c6e:	66 0f       	add	r22, r22
    2c70:	77 1f       	adc	r23, r23
    2c72:	88 1f       	adc	r24, r24
    2c74:	99 1f       	adc	r25, r25
    2c76:	1a f0       	brmi	.+6      	; 0x2c7e <__fixunssfsi+0x22>
    2c78:	ba 95       	dec	r27
    2c7a:	c9 f7       	brne	.-14     	; 0x2c6e <__fixunssfsi+0x12>
    2c7c:	12 c0       	rjmp	.+36     	; 0x2ca2 <__fixunssfsi+0x46>
    2c7e:	b1 30       	cpi	r27, 0x01	; 1
    2c80:	81 f0       	breq	.+32     	; 0x2ca2 <__fixunssfsi+0x46>
    2c82:	c3 d0       	rcall	.+390    	; 0x2e0a <__fp_zero>
    2c84:	b1 e0       	ldi	r27, 0x01	; 1
    2c86:	08 95       	ret
    2c88:	c0 c0       	rjmp	.+384    	; 0x2e0a <__fp_zero>
    2c8a:	67 2f       	mov	r22, r23
    2c8c:	78 2f       	mov	r23, r24
    2c8e:	88 27       	eor	r24, r24
    2c90:	b8 5f       	subi	r27, 0xF8	; 248
    2c92:	39 f0       	breq	.+14     	; 0x2ca2 <__fixunssfsi+0x46>
    2c94:	b9 3f       	cpi	r27, 0xF9	; 249
    2c96:	cc f3       	brlt	.-14     	; 0x2c8a <__fixunssfsi+0x2e>
    2c98:	86 95       	lsr	r24
    2c9a:	77 95       	ror	r23
    2c9c:	67 95       	ror	r22
    2c9e:	b3 95       	inc	r27
    2ca0:	d9 f7       	brne	.-10     	; 0x2c98 <__fixunssfsi+0x3c>
    2ca2:	3e f4       	brtc	.+14     	; 0x2cb2 <__fixunssfsi+0x56>
    2ca4:	90 95       	com	r25
    2ca6:	80 95       	com	r24
    2ca8:	70 95       	com	r23
    2caa:	61 95       	neg	r22
    2cac:	7f 4f       	sbci	r23, 0xFF	; 255
    2cae:	8f 4f       	sbci	r24, 0xFF	; 255
    2cb0:	9f 4f       	sbci	r25, 0xFF	; 255
    2cb2:	08 95       	ret

00002cb4 <__floatunsisf>:
    2cb4:	e8 94       	clt
    2cb6:	09 c0       	rjmp	.+18     	; 0x2cca <__floatsisf+0x12>

00002cb8 <__floatsisf>:
    2cb8:	97 fb       	bst	r25, 7
    2cba:	3e f4       	brtc	.+14     	; 0x2cca <__floatsisf+0x12>
    2cbc:	90 95       	com	r25
    2cbe:	80 95       	com	r24
    2cc0:	70 95       	com	r23
    2cc2:	61 95       	neg	r22
    2cc4:	7f 4f       	sbci	r23, 0xFF	; 255
    2cc6:	8f 4f       	sbci	r24, 0xFF	; 255
    2cc8:	9f 4f       	sbci	r25, 0xFF	; 255
    2cca:	99 23       	and	r25, r25
    2ccc:	a9 f0       	breq	.+42     	; 0x2cf8 <__floatsisf+0x40>
    2cce:	f9 2f       	mov	r31, r25
    2cd0:	96 e9       	ldi	r25, 0x96	; 150
    2cd2:	bb 27       	eor	r27, r27
    2cd4:	93 95       	inc	r25
    2cd6:	f6 95       	lsr	r31
    2cd8:	87 95       	ror	r24
    2cda:	77 95       	ror	r23
    2cdc:	67 95       	ror	r22
    2cde:	b7 95       	ror	r27
    2ce0:	f1 11       	cpse	r31, r1
    2ce2:	f8 cf       	rjmp	.-16     	; 0x2cd4 <__floatsisf+0x1c>
    2ce4:	fa f4       	brpl	.+62     	; 0x2d24 <__floatsisf+0x6c>
    2ce6:	bb 0f       	add	r27, r27
    2ce8:	11 f4       	brne	.+4      	; 0x2cee <__floatsisf+0x36>
    2cea:	60 ff       	sbrs	r22, 0
    2cec:	1b c0       	rjmp	.+54     	; 0x2d24 <__floatsisf+0x6c>
    2cee:	6f 5f       	subi	r22, 0xFF	; 255
    2cf0:	7f 4f       	sbci	r23, 0xFF	; 255
    2cf2:	8f 4f       	sbci	r24, 0xFF	; 255
    2cf4:	9f 4f       	sbci	r25, 0xFF	; 255
    2cf6:	16 c0       	rjmp	.+44     	; 0x2d24 <__floatsisf+0x6c>
    2cf8:	88 23       	and	r24, r24
    2cfa:	11 f0       	breq	.+4      	; 0x2d00 <__floatsisf+0x48>
    2cfc:	96 e9       	ldi	r25, 0x96	; 150
    2cfe:	11 c0       	rjmp	.+34     	; 0x2d22 <__floatsisf+0x6a>
    2d00:	77 23       	and	r23, r23
    2d02:	21 f0       	breq	.+8      	; 0x2d0c <__floatsisf+0x54>
    2d04:	9e e8       	ldi	r25, 0x8E	; 142
    2d06:	87 2f       	mov	r24, r23
    2d08:	76 2f       	mov	r23, r22
    2d0a:	05 c0       	rjmp	.+10     	; 0x2d16 <__floatsisf+0x5e>
    2d0c:	66 23       	and	r22, r22
    2d0e:	71 f0       	breq	.+28     	; 0x2d2c <__floatsisf+0x74>
    2d10:	96 e8       	ldi	r25, 0x86	; 134
    2d12:	86 2f       	mov	r24, r22
    2d14:	70 e0       	ldi	r23, 0x00	; 0
    2d16:	60 e0       	ldi	r22, 0x00	; 0
    2d18:	2a f0       	brmi	.+10     	; 0x2d24 <__floatsisf+0x6c>
    2d1a:	9a 95       	dec	r25
    2d1c:	66 0f       	add	r22, r22
    2d1e:	77 1f       	adc	r23, r23
    2d20:	88 1f       	adc	r24, r24
    2d22:	da f7       	brpl	.-10     	; 0x2d1a <__floatsisf+0x62>
    2d24:	88 0f       	add	r24, r24
    2d26:	96 95       	lsr	r25
    2d28:	87 95       	ror	r24
    2d2a:	97 f9       	bld	r25, 7
    2d2c:	08 95       	ret

00002d2e <__fp_cmp>:
    2d2e:	99 0f       	add	r25, r25
    2d30:	00 08       	sbc	r0, r0
    2d32:	55 0f       	add	r21, r21
    2d34:	aa 0b       	sbc	r26, r26
    2d36:	e0 e8       	ldi	r30, 0x80	; 128
    2d38:	fe ef       	ldi	r31, 0xFE	; 254
    2d3a:	16 16       	cp	r1, r22
    2d3c:	17 06       	cpc	r1, r23
    2d3e:	e8 07       	cpc	r30, r24
    2d40:	f9 07       	cpc	r31, r25
    2d42:	c0 f0       	brcs	.+48     	; 0x2d74 <__fp_cmp+0x46>
    2d44:	12 16       	cp	r1, r18
    2d46:	13 06       	cpc	r1, r19
    2d48:	e4 07       	cpc	r30, r20
    2d4a:	f5 07       	cpc	r31, r21
    2d4c:	98 f0       	brcs	.+38     	; 0x2d74 <__fp_cmp+0x46>
    2d4e:	62 1b       	sub	r22, r18
    2d50:	73 0b       	sbc	r23, r19
    2d52:	84 0b       	sbc	r24, r20
    2d54:	95 0b       	sbc	r25, r21
    2d56:	39 f4       	brne	.+14     	; 0x2d66 <__fp_cmp+0x38>
    2d58:	0a 26       	eor	r0, r26
    2d5a:	61 f0       	breq	.+24     	; 0x2d74 <__fp_cmp+0x46>
    2d5c:	23 2b       	or	r18, r19
    2d5e:	24 2b       	or	r18, r20
    2d60:	25 2b       	or	r18, r21
    2d62:	21 f4       	brne	.+8      	; 0x2d6c <__fp_cmp+0x3e>
    2d64:	08 95       	ret
    2d66:	0a 26       	eor	r0, r26
    2d68:	09 f4       	brne	.+2      	; 0x2d6c <__fp_cmp+0x3e>
    2d6a:	a1 40       	sbci	r26, 0x01	; 1
    2d6c:	a6 95       	lsr	r26
    2d6e:	8f ef       	ldi	r24, 0xFF	; 255
    2d70:	81 1d       	adc	r24, r1
    2d72:	81 1d       	adc	r24, r1
    2d74:	08 95       	ret

00002d76 <__fp_inf>:
    2d76:	97 f9       	bld	r25, 7
    2d78:	9f 67       	ori	r25, 0x7F	; 127
    2d7a:	80 e8       	ldi	r24, 0x80	; 128
    2d7c:	70 e0       	ldi	r23, 0x00	; 0
    2d7e:	60 e0       	ldi	r22, 0x00	; 0
    2d80:	08 95       	ret

00002d82 <__fp_nan>:
    2d82:	9f ef       	ldi	r25, 0xFF	; 255
    2d84:	80 ec       	ldi	r24, 0xC0	; 192
    2d86:	08 95       	ret

00002d88 <__fp_pscA>:
    2d88:	00 24       	eor	r0, r0
    2d8a:	0a 94       	dec	r0
    2d8c:	16 16       	cp	r1, r22
    2d8e:	17 06       	cpc	r1, r23
    2d90:	18 06       	cpc	r1, r24
    2d92:	09 06       	cpc	r0, r25
    2d94:	08 95       	ret

00002d96 <__fp_pscB>:
    2d96:	00 24       	eor	r0, r0
    2d98:	0a 94       	dec	r0
    2d9a:	12 16       	cp	r1, r18
    2d9c:	13 06       	cpc	r1, r19
    2d9e:	14 06       	cpc	r1, r20
    2da0:	05 06       	cpc	r0, r21
    2da2:	08 95       	ret

00002da4 <__fp_round>:
    2da4:	09 2e       	mov	r0, r25
    2da6:	03 94       	inc	r0
    2da8:	00 0c       	add	r0, r0
    2daa:	11 f4       	brne	.+4      	; 0x2db0 <__fp_round+0xc>
    2dac:	88 23       	and	r24, r24
    2dae:	52 f0       	brmi	.+20     	; 0x2dc4 <__fp_round+0x20>
    2db0:	bb 0f       	add	r27, r27
    2db2:	40 f4       	brcc	.+16     	; 0x2dc4 <__fp_round+0x20>
    2db4:	bf 2b       	or	r27, r31
    2db6:	11 f4       	brne	.+4      	; 0x2dbc <__fp_round+0x18>
    2db8:	60 ff       	sbrs	r22, 0
    2dba:	04 c0       	rjmp	.+8      	; 0x2dc4 <__fp_round+0x20>
    2dbc:	6f 5f       	subi	r22, 0xFF	; 255
    2dbe:	7f 4f       	sbci	r23, 0xFF	; 255
    2dc0:	8f 4f       	sbci	r24, 0xFF	; 255
    2dc2:	9f 4f       	sbci	r25, 0xFF	; 255
    2dc4:	08 95       	ret

00002dc6 <__fp_split3>:
    2dc6:	57 fd       	sbrc	r21, 7
    2dc8:	90 58       	subi	r25, 0x80	; 128
    2dca:	44 0f       	add	r20, r20
    2dcc:	55 1f       	adc	r21, r21
    2dce:	59 f0       	breq	.+22     	; 0x2de6 <__fp_splitA+0x10>
    2dd0:	5f 3f       	cpi	r21, 0xFF	; 255
    2dd2:	71 f0       	breq	.+28     	; 0x2df0 <__fp_splitA+0x1a>
    2dd4:	47 95       	ror	r20

00002dd6 <__fp_splitA>:
    2dd6:	88 0f       	add	r24, r24
    2dd8:	97 fb       	bst	r25, 7
    2dda:	99 1f       	adc	r25, r25
    2ddc:	61 f0       	breq	.+24     	; 0x2df6 <__fp_splitA+0x20>
    2dde:	9f 3f       	cpi	r25, 0xFF	; 255
    2de0:	79 f0       	breq	.+30     	; 0x2e00 <__fp_splitA+0x2a>
    2de2:	87 95       	ror	r24
    2de4:	08 95       	ret
    2de6:	12 16       	cp	r1, r18
    2de8:	13 06       	cpc	r1, r19
    2dea:	14 06       	cpc	r1, r20
    2dec:	55 1f       	adc	r21, r21
    2dee:	f2 cf       	rjmp	.-28     	; 0x2dd4 <__fp_split3+0xe>
    2df0:	46 95       	lsr	r20
    2df2:	f1 df       	rcall	.-30     	; 0x2dd6 <__fp_splitA>
    2df4:	08 c0       	rjmp	.+16     	; 0x2e06 <__fp_splitA+0x30>
    2df6:	16 16       	cp	r1, r22
    2df8:	17 06       	cpc	r1, r23
    2dfa:	18 06       	cpc	r1, r24
    2dfc:	99 1f       	adc	r25, r25
    2dfe:	f1 cf       	rjmp	.-30     	; 0x2de2 <__fp_splitA+0xc>
    2e00:	86 95       	lsr	r24
    2e02:	71 05       	cpc	r23, r1
    2e04:	61 05       	cpc	r22, r1
    2e06:	08 94       	sec
    2e08:	08 95       	ret

00002e0a <__fp_zero>:
    2e0a:	e8 94       	clt

00002e0c <__fp_szero>:
    2e0c:	bb 27       	eor	r27, r27
    2e0e:	66 27       	eor	r22, r22
    2e10:	77 27       	eor	r23, r23
    2e12:	cb 01       	movw	r24, r22
    2e14:	97 f9       	bld	r25, 7
    2e16:	08 95       	ret

00002e18 <__gesf2>:
    2e18:	8a df       	rcall	.-236    	; 0x2d2e <__fp_cmp>
    2e1a:	08 f4       	brcc	.+2      	; 0x2e1e <__gesf2+0x6>
    2e1c:	8f ef       	ldi	r24, 0xFF	; 255
    2e1e:	08 95       	ret

00002e20 <__mulsf3>:
    2e20:	0b d0       	rcall	.+22     	; 0x2e38 <__mulsf3x>
    2e22:	c0 cf       	rjmp	.-128    	; 0x2da4 <__fp_round>
    2e24:	b1 df       	rcall	.-158    	; 0x2d88 <__fp_pscA>
    2e26:	28 f0       	brcs	.+10     	; 0x2e32 <__mulsf3+0x12>
    2e28:	b6 df       	rcall	.-148    	; 0x2d96 <__fp_pscB>
    2e2a:	18 f0       	brcs	.+6      	; 0x2e32 <__mulsf3+0x12>
    2e2c:	95 23       	and	r25, r21
    2e2e:	09 f0       	breq	.+2      	; 0x2e32 <__mulsf3+0x12>
    2e30:	a2 cf       	rjmp	.-188    	; 0x2d76 <__fp_inf>
    2e32:	a7 cf       	rjmp	.-178    	; 0x2d82 <__fp_nan>
    2e34:	11 24       	eor	r1, r1
    2e36:	ea cf       	rjmp	.-44     	; 0x2e0c <__fp_szero>

00002e38 <__mulsf3x>:
    2e38:	c6 df       	rcall	.-116    	; 0x2dc6 <__fp_split3>
    2e3a:	a0 f3       	brcs	.-24     	; 0x2e24 <__mulsf3+0x4>

00002e3c <__mulsf3_pse>:
    2e3c:	95 9f       	mul	r25, r21
    2e3e:	d1 f3       	breq	.-12     	; 0x2e34 <__mulsf3+0x14>
    2e40:	95 0f       	add	r25, r21
    2e42:	50 e0       	ldi	r21, 0x00	; 0
    2e44:	55 1f       	adc	r21, r21
    2e46:	62 9f       	mul	r22, r18
    2e48:	f0 01       	movw	r30, r0
    2e4a:	72 9f       	mul	r23, r18
    2e4c:	bb 27       	eor	r27, r27
    2e4e:	f0 0d       	add	r31, r0
    2e50:	b1 1d       	adc	r27, r1
    2e52:	63 9f       	mul	r22, r19
    2e54:	aa 27       	eor	r26, r26
    2e56:	f0 0d       	add	r31, r0
    2e58:	b1 1d       	adc	r27, r1
    2e5a:	aa 1f       	adc	r26, r26
    2e5c:	64 9f       	mul	r22, r20
    2e5e:	66 27       	eor	r22, r22
    2e60:	b0 0d       	add	r27, r0
    2e62:	a1 1d       	adc	r26, r1
    2e64:	66 1f       	adc	r22, r22
    2e66:	82 9f       	mul	r24, r18
    2e68:	22 27       	eor	r18, r18
    2e6a:	b0 0d       	add	r27, r0
    2e6c:	a1 1d       	adc	r26, r1
    2e6e:	62 1f       	adc	r22, r18
    2e70:	73 9f       	mul	r23, r19
    2e72:	b0 0d       	add	r27, r0
    2e74:	a1 1d       	adc	r26, r1
    2e76:	62 1f       	adc	r22, r18
    2e78:	83 9f       	mul	r24, r19
    2e7a:	a0 0d       	add	r26, r0
    2e7c:	61 1d       	adc	r22, r1
    2e7e:	22 1f       	adc	r18, r18
    2e80:	74 9f       	mul	r23, r20
    2e82:	33 27       	eor	r19, r19
    2e84:	a0 0d       	add	r26, r0
    2e86:	61 1d       	adc	r22, r1
    2e88:	23 1f       	adc	r18, r19
    2e8a:	84 9f       	mul	r24, r20
    2e8c:	60 0d       	add	r22, r0
    2e8e:	21 1d       	adc	r18, r1
    2e90:	82 2f       	mov	r24, r18
    2e92:	76 2f       	mov	r23, r22
    2e94:	6a 2f       	mov	r22, r26
    2e96:	11 24       	eor	r1, r1
    2e98:	9f 57       	subi	r25, 0x7F	; 127
    2e9a:	50 40       	sbci	r21, 0x00	; 0
    2e9c:	8a f0       	brmi	.+34     	; 0x2ec0 <__mulsf3_pse+0x84>
    2e9e:	e1 f0       	breq	.+56     	; 0x2ed8 <__mulsf3_pse+0x9c>
    2ea0:	88 23       	and	r24, r24
    2ea2:	4a f0       	brmi	.+18     	; 0x2eb6 <__mulsf3_pse+0x7a>
    2ea4:	ee 0f       	add	r30, r30
    2ea6:	ff 1f       	adc	r31, r31
    2ea8:	bb 1f       	adc	r27, r27
    2eaa:	66 1f       	adc	r22, r22
    2eac:	77 1f       	adc	r23, r23
    2eae:	88 1f       	adc	r24, r24
    2eb0:	91 50       	subi	r25, 0x01	; 1
    2eb2:	50 40       	sbci	r21, 0x00	; 0
    2eb4:	a9 f7       	brne	.-22     	; 0x2ea0 <__mulsf3_pse+0x64>
    2eb6:	9e 3f       	cpi	r25, 0xFE	; 254
    2eb8:	51 05       	cpc	r21, r1
    2eba:	70 f0       	brcs	.+28     	; 0x2ed8 <__mulsf3_pse+0x9c>
    2ebc:	5c cf       	rjmp	.-328    	; 0x2d76 <__fp_inf>
    2ebe:	a6 cf       	rjmp	.-180    	; 0x2e0c <__fp_szero>
    2ec0:	5f 3f       	cpi	r21, 0xFF	; 255
    2ec2:	ec f3       	brlt	.-6      	; 0x2ebe <__mulsf3_pse+0x82>
    2ec4:	98 3e       	cpi	r25, 0xE8	; 232
    2ec6:	dc f3       	brlt	.-10     	; 0x2ebe <__mulsf3_pse+0x82>
    2ec8:	86 95       	lsr	r24
    2eca:	77 95       	ror	r23
    2ecc:	67 95       	ror	r22
    2ece:	b7 95       	ror	r27
    2ed0:	f7 95       	ror	r31
    2ed2:	e7 95       	ror	r30
    2ed4:	9f 5f       	subi	r25, 0xFF	; 255
    2ed6:	c1 f7       	brne	.-16     	; 0x2ec8 <__mulsf3_pse+0x8c>
    2ed8:	fe 2b       	or	r31, r30
    2eda:	88 0f       	add	r24, r24
    2edc:	91 1d       	adc	r25, r1
    2ede:	96 95       	lsr	r25
    2ee0:	87 95       	ror	r24
    2ee2:	97 f9       	bld	r25, 7
    2ee4:	08 95       	ret

00002ee6 <__udivmodsi4>:
    2ee6:	a1 e2       	ldi	r26, 0x21	; 33
    2ee8:	1a 2e       	mov	r1, r26
    2eea:	aa 1b       	sub	r26, r26
    2eec:	bb 1b       	sub	r27, r27
    2eee:	fd 01       	movw	r30, r26
    2ef0:	0d c0       	rjmp	.+26     	; 0x2f0c <__udivmodsi4_ep>

00002ef2 <__udivmodsi4_loop>:
    2ef2:	aa 1f       	adc	r26, r26
    2ef4:	bb 1f       	adc	r27, r27
    2ef6:	ee 1f       	adc	r30, r30
    2ef8:	ff 1f       	adc	r31, r31
    2efa:	a2 17       	cp	r26, r18
    2efc:	b3 07       	cpc	r27, r19
    2efe:	e4 07       	cpc	r30, r20
    2f00:	f5 07       	cpc	r31, r21
    2f02:	20 f0       	brcs	.+8      	; 0x2f0c <__udivmodsi4_ep>
    2f04:	a2 1b       	sub	r26, r18
    2f06:	b3 0b       	sbc	r27, r19
    2f08:	e4 0b       	sbc	r30, r20
    2f0a:	f5 0b       	sbc	r31, r21

00002f0c <__udivmodsi4_ep>:
    2f0c:	66 1f       	adc	r22, r22
    2f0e:	77 1f       	adc	r23, r23
    2f10:	88 1f       	adc	r24, r24
    2f12:	99 1f       	adc	r25, r25
    2f14:	1a 94       	dec	r1
    2f16:	69 f7       	brne	.-38     	; 0x2ef2 <__udivmodsi4_loop>
    2f18:	60 95       	com	r22
    2f1a:	70 95       	com	r23
    2f1c:	80 95       	com	r24
    2f1e:	90 95       	com	r25
    2f20:	9b 01       	movw	r18, r22
    2f22:	ac 01       	movw	r20, r24
    2f24:	bd 01       	movw	r22, r26
    2f26:	cf 01       	movw	r24, r30
    2f28:	08 95       	ret

00002f2a <__tablejump2__>:
    2f2a:	ee 0f       	add	r30, r30
    2f2c:	ff 1f       	adc	r31, r31
    2f2e:	88 1f       	adc	r24, r24
    2f30:	8b bf       	out	0x3b, r24	; 59
    2f32:	07 90       	elpm	r0, Z+
    2f34:	f6 91       	elpm	r31, Z
    2f36:	e0 2d       	mov	r30, r0
    2f38:	19 94       	eijmp

00002f3a <__umulhisi3>:
    2f3a:	a2 9f       	mul	r26, r18
    2f3c:	b0 01       	movw	r22, r0
    2f3e:	b3 9f       	mul	r27, r19
    2f40:	c0 01       	movw	r24, r0
    2f42:	a3 9f       	mul	r26, r19
    2f44:	70 0d       	add	r23, r0
    2f46:	81 1d       	adc	r24, r1
    2f48:	11 24       	eor	r1, r1
    2f4a:	91 1d       	adc	r25, r1
    2f4c:	b2 9f       	mul	r27, r18
    2f4e:	70 0d       	add	r23, r0
    2f50:	81 1d       	adc	r24, r1
    2f52:	11 24       	eor	r1, r1
    2f54:	91 1d       	adc	r25, r1
    2f56:	08 95       	ret

00002f58 <malloc>:
    2f58:	0f 93       	push	r16
    2f5a:	1f 93       	push	r17
    2f5c:	cf 93       	push	r28
    2f5e:	df 93       	push	r29
    2f60:	82 30       	cpi	r24, 0x02	; 2
    2f62:	91 05       	cpc	r25, r1
    2f64:	10 f4       	brcc	.+4      	; 0x2f6a <malloc+0x12>
    2f66:	82 e0       	ldi	r24, 0x02	; 2
    2f68:	90 e0       	ldi	r25, 0x00	; 0
    2f6a:	e0 91 b8 12 	lds	r30, 0x12B8	; 0x8012b8 <__flp>
    2f6e:	f0 91 b9 12 	lds	r31, 0x12B9	; 0x8012b9 <__flp+0x1>
    2f72:	20 e0       	ldi	r18, 0x00	; 0
    2f74:	30 e0       	ldi	r19, 0x00	; 0
    2f76:	a0 e0       	ldi	r26, 0x00	; 0
    2f78:	b0 e0       	ldi	r27, 0x00	; 0
    2f7a:	30 97       	sbiw	r30, 0x00	; 0
    2f7c:	19 f1       	breq	.+70     	; 0x2fc4 <malloc+0x6c>
    2f7e:	40 81       	ld	r20, Z
    2f80:	51 81       	ldd	r21, Z+1	; 0x01
    2f82:	02 81       	ldd	r16, Z+2	; 0x02
    2f84:	13 81       	ldd	r17, Z+3	; 0x03
    2f86:	48 17       	cp	r20, r24
    2f88:	59 07       	cpc	r21, r25
    2f8a:	c8 f0       	brcs	.+50     	; 0x2fbe <malloc+0x66>
    2f8c:	84 17       	cp	r24, r20
    2f8e:	95 07       	cpc	r25, r21
    2f90:	69 f4       	brne	.+26     	; 0x2fac <malloc+0x54>
    2f92:	10 97       	sbiw	r26, 0x00	; 0
    2f94:	31 f0       	breq	.+12     	; 0x2fa2 <malloc+0x4a>
    2f96:	12 96       	adiw	r26, 0x02	; 2
    2f98:	0c 93       	st	X, r16
    2f9a:	12 97       	sbiw	r26, 0x02	; 2
    2f9c:	13 96       	adiw	r26, 0x03	; 3
    2f9e:	1c 93       	st	X, r17
    2fa0:	27 c0       	rjmp	.+78     	; 0x2ff0 <malloc+0x98>
    2fa2:	00 93 b8 12 	sts	0x12B8, r16	; 0x8012b8 <__flp>
    2fa6:	10 93 b9 12 	sts	0x12B9, r17	; 0x8012b9 <__flp+0x1>
    2faa:	22 c0       	rjmp	.+68     	; 0x2ff0 <malloc+0x98>
    2fac:	21 15       	cp	r18, r1
    2fae:	31 05       	cpc	r19, r1
    2fb0:	19 f0       	breq	.+6      	; 0x2fb8 <malloc+0x60>
    2fb2:	42 17       	cp	r20, r18
    2fb4:	53 07       	cpc	r21, r19
    2fb6:	18 f4       	brcc	.+6      	; 0x2fbe <malloc+0x66>
    2fb8:	9a 01       	movw	r18, r20
    2fba:	bd 01       	movw	r22, r26
    2fbc:	ef 01       	movw	r28, r30
    2fbe:	df 01       	movw	r26, r30
    2fc0:	f8 01       	movw	r30, r16
    2fc2:	db cf       	rjmp	.-74     	; 0x2f7a <malloc+0x22>
    2fc4:	21 15       	cp	r18, r1
    2fc6:	31 05       	cpc	r19, r1
    2fc8:	f9 f0       	breq	.+62     	; 0x3008 <malloc+0xb0>
    2fca:	28 1b       	sub	r18, r24
    2fcc:	39 0b       	sbc	r19, r25
    2fce:	24 30       	cpi	r18, 0x04	; 4
    2fd0:	31 05       	cpc	r19, r1
    2fd2:	80 f4       	brcc	.+32     	; 0x2ff4 <malloc+0x9c>
    2fd4:	8a 81       	ldd	r24, Y+2	; 0x02
    2fd6:	9b 81       	ldd	r25, Y+3	; 0x03
    2fd8:	61 15       	cp	r22, r1
    2fda:	71 05       	cpc	r23, r1
    2fdc:	21 f0       	breq	.+8      	; 0x2fe6 <malloc+0x8e>
    2fde:	fb 01       	movw	r30, r22
    2fe0:	93 83       	std	Z+3, r25	; 0x03
    2fe2:	82 83       	std	Z+2, r24	; 0x02
    2fe4:	04 c0       	rjmp	.+8      	; 0x2fee <malloc+0x96>
    2fe6:	90 93 b9 12 	sts	0x12B9, r25	; 0x8012b9 <__flp+0x1>
    2fea:	80 93 b8 12 	sts	0x12B8, r24	; 0x8012b8 <__flp>
    2fee:	fe 01       	movw	r30, r28
    2ff0:	32 96       	adiw	r30, 0x02	; 2
    2ff2:	44 c0       	rjmp	.+136    	; 0x307c <malloc+0x124>
    2ff4:	fe 01       	movw	r30, r28
    2ff6:	e2 0f       	add	r30, r18
    2ff8:	f3 1f       	adc	r31, r19
    2ffa:	81 93       	st	Z+, r24
    2ffc:	91 93       	st	Z+, r25
    2ffe:	22 50       	subi	r18, 0x02	; 2
    3000:	31 09       	sbc	r19, r1
    3002:	39 83       	std	Y+1, r19	; 0x01
    3004:	28 83       	st	Y, r18
    3006:	3a c0       	rjmp	.+116    	; 0x307c <malloc+0x124>
    3008:	20 91 b6 12 	lds	r18, 0x12B6	; 0x8012b6 <__brkval>
    300c:	30 91 b7 12 	lds	r19, 0x12B7	; 0x8012b7 <__brkval+0x1>
    3010:	23 2b       	or	r18, r19
    3012:	41 f4       	brne	.+16     	; 0x3024 <malloc+0xcc>
    3014:	20 91 02 02 	lds	r18, 0x0202	; 0x800202 <__malloc_heap_start>
    3018:	30 91 03 02 	lds	r19, 0x0203	; 0x800203 <__malloc_heap_start+0x1>
    301c:	30 93 b7 12 	sts	0x12B7, r19	; 0x8012b7 <__brkval+0x1>
    3020:	20 93 b6 12 	sts	0x12B6, r18	; 0x8012b6 <__brkval>
    3024:	20 91 00 02 	lds	r18, 0x0200	; 0x800200 <__DATA_REGION_ORIGIN__>
    3028:	30 91 01 02 	lds	r19, 0x0201	; 0x800201 <__DATA_REGION_ORIGIN__+0x1>
    302c:	21 15       	cp	r18, r1
    302e:	31 05       	cpc	r19, r1
    3030:	41 f4       	brne	.+16     	; 0x3042 <malloc+0xea>
    3032:	2d b7       	in	r18, 0x3d	; 61
    3034:	3e b7       	in	r19, 0x3e	; 62
    3036:	40 91 04 02 	lds	r20, 0x0204	; 0x800204 <__malloc_margin>
    303a:	50 91 05 02 	lds	r21, 0x0205	; 0x800205 <__malloc_margin+0x1>
    303e:	24 1b       	sub	r18, r20
    3040:	35 0b       	sbc	r19, r21
    3042:	e0 91 b6 12 	lds	r30, 0x12B6	; 0x8012b6 <__brkval>
    3046:	f0 91 b7 12 	lds	r31, 0x12B7	; 0x8012b7 <__brkval+0x1>
    304a:	e2 17       	cp	r30, r18
    304c:	f3 07       	cpc	r31, r19
    304e:	a0 f4       	brcc	.+40     	; 0x3078 <malloc+0x120>
    3050:	2e 1b       	sub	r18, r30
    3052:	3f 0b       	sbc	r19, r31
    3054:	28 17       	cp	r18, r24
    3056:	39 07       	cpc	r19, r25
    3058:	78 f0       	brcs	.+30     	; 0x3078 <malloc+0x120>
    305a:	ac 01       	movw	r20, r24
    305c:	4e 5f       	subi	r20, 0xFE	; 254
    305e:	5f 4f       	sbci	r21, 0xFF	; 255
    3060:	24 17       	cp	r18, r20
    3062:	35 07       	cpc	r19, r21
    3064:	48 f0       	brcs	.+18     	; 0x3078 <malloc+0x120>
    3066:	4e 0f       	add	r20, r30
    3068:	5f 1f       	adc	r21, r31
    306a:	50 93 b7 12 	sts	0x12B7, r21	; 0x8012b7 <__brkval+0x1>
    306e:	40 93 b6 12 	sts	0x12B6, r20	; 0x8012b6 <__brkval>
    3072:	81 93       	st	Z+, r24
    3074:	91 93       	st	Z+, r25
    3076:	02 c0       	rjmp	.+4      	; 0x307c <malloc+0x124>
    3078:	e0 e0       	ldi	r30, 0x00	; 0
    307a:	f0 e0       	ldi	r31, 0x00	; 0
    307c:	cf 01       	movw	r24, r30
    307e:	df 91       	pop	r29
    3080:	cf 91       	pop	r28
    3082:	1f 91       	pop	r17
    3084:	0f 91       	pop	r16
    3086:	08 95       	ret

00003088 <free>:
    3088:	cf 93       	push	r28
    308a:	df 93       	push	r29
    308c:	00 97       	sbiw	r24, 0x00	; 0
    308e:	09 f4       	brne	.+2      	; 0x3092 <free+0xa>
    3090:	81 c0       	rjmp	.+258    	; 0x3194 <free+0x10c>
    3092:	fc 01       	movw	r30, r24
    3094:	32 97       	sbiw	r30, 0x02	; 2
    3096:	13 82       	std	Z+3, r1	; 0x03
    3098:	12 82       	std	Z+2, r1	; 0x02
    309a:	a0 91 b8 12 	lds	r26, 0x12B8	; 0x8012b8 <__flp>
    309e:	b0 91 b9 12 	lds	r27, 0x12B9	; 0x8012b9 <__flp+0x1>
    30a2:	10 97       	sbiw	r26, 0x00	; 0
    30a4:	81 f4       	brne	.+32     	; 0x30c6 <free+0x3e>
    30a6:	20 81       	ld	r18, Z
    30a8:	31 81       	ldd	r19, Z+1	; 0x01
    30aa:	82 0f       	add	r24, r18
    30ac:	93 1f       	adc	r25, r19
    30ae:	20 91 b6 12 	lds	r18, 0x12B6	; 0x8012b6 <__brkval>
    30b2:	30 91 b7 12 	lds	r19, 0x12B7	; 0x8012b7 <__brkval+0x1>
    30b6:	28 17       	cp	r18, r24
    30b8:	39 07       	cpc	r19, r25
    30ba:	51 f5       	brne	.+84     	; 0x3110 <free+0x88>
    30bc:	f0 93 b7 12 	sts	0x12B7, r31	; 0x8012b7 <__brkval+0x1>
    30c0:	e0 93 b6 12 	sts	0x12B6, r30	; 0x8012b6 <__brkval>
    30c4:	67 c0       	rjmp	.+206    	; 0x3194 <free+0x10c>
    30c6:	ed 01       	movw	r28, r26
    30c8:	20 e0       	ldi	r18, 0x00	; 0
    30ca:	30 e0       	ldi	r19, 0x00	; 0
    30cc:	ce 17       	cp	r28, r30
    30ce:	df 07       	cpc	r29, r31
    30d0:	40 f4       	brcc	.+16     	; 0x30e2 <free+0x5a>
    30d2:	4a 81       	ldd	r20, Y+2	; 0x02
    30d4:	5b 81       	ldd	r21, Y+3	; 0x03
    30d6:	9e 01       	movw	r18, r28
    30d8:	41 15       	cp	r20, r1
    30da:	51 05       	cpc	r21, r1
    30dc:	f1 f0       	breq	.+60     	; 0x311a <free+0x92>
    30de:	ea 01       	movw	r28, r20
    30e0:	f5 cf       	rjmp	.-22     	; 0x30cc <free+0x44>
    30e2:	d3 83       	std	Z+3, r29	; 0x03
    30e4:	c2 83       	std	Z+2, r28	; 0x02
    30e6:	40 81       	ld	r20, Z
    30e8:	51 81       	ldd	r21, Z+1	; 0x01
    30ea:	84 0f       	add	r24, r20
    30ec:	95 1f       	adc	r25, r21
    30ee:	c8 17       	cp	r28, r24
    30f0:	d9 07       	cpc	r29, r25
    30f2:	59 f4       	brne	.+22     	; 0x310a <free+0x82>
    30f4:	88 81       	ld	r24, Y
    30f6:	99 81       	ldd	r25, Y+1	; 0x01
    30f8:	84 0f       	add	r24, r20
    30fa:	95 1f       	adc	r25, r21
    30fc:	02 96       	adiw	r24, 0x02	; 2
    30fe:	91 83       	std	Z+1, r25	; 0x01
    3100:	80 83       	st	Z, r24
    3102:	8a 81       	ldd	r24, Y+2	; 0x02
    3104:	9b 81       	ldd	r25, Y+3	; 0x03
    3106:	93 83       	std	Z+3, r25	; 0x03
    3108:	82 83       	std	Z+2, r24	; 0x02
    310a:	21 15       	cp	r18, r1
    310c:	31 05       	cpc	r19, r1
    310e:	29 f4       	brne	.+10     	; 0x311a <free+0x92>
    3110:	f0 93 b9 12 	sts	0x12B9, r31	; 0x8012b9 <__flp+0x1>
    3114:	e0 93 b8 12 	sts	0x12B8, r30	; 0x8012b8 <__flp>
    3118:	3d c0       	rjmp	.+122    	; 0x3194 <free+0x10c>
    311a:	e9 01       	movw	r28, r18
    311c:	fb 83       	std	Y+3, r31	; 0x03
    311e:	ea 83       	std	Y+2, r30	; 0x02
    3120:	49 91       	ld	r20, Y+
    3122:	59 91       	ld	r21, Y+
    3124:	c4 0f       	add	r28, r20
    3126:	d5 1f       	adc	r29, r21
    3128:	ec 17       	cp	r30, r28
    312a:	fd 07       	cpc	r31, r29
    312c:	61 f4       	brne	.+24     	; 0x3146 <free+0xbe>
    312e:	80 81       	ld	r24, Z
    3130:	91 81       	ldd	r25, Z+1	; 0x01
    3132:	84 0f       	add	r24, r20
    3134:	95 1f       	adc	r25, r21
    3136:	02 96       	adiw	r24, 0x02	; 2
    3138:	e9 01       	movw	r28, r18
    313a:	99 83       	std	Y+1, r25	; 0x01
    313c:	88 83       	st	Y, r24
    313e:	82 81       	ldd	r24, Z+2	; 0x02
    3140:	93 81       	ldd	r25, Z+3	; 0x03
    3142:	9b 83       	std	Y+3, r25	; 0x03
    3144:	8a 83       	std	Y+2, r24	; 0x02
    3146:	e0 e0       	ldi	r30, 0x00	; 0
    3148:	f0 e0       	ldi	r31, 0x00	; 0
    314a:	12 96       	adiw	r26, 0x02	; 2
    314c:	8d 91       	ld	r24, X+
    314e:	9c 91       	ld	r25, X
    3150:	13 97       	sbiw	r26, 0x03	; 3
    3152:	00 97       	sbiw	r24, 0x00	; 0
    3154:	19 f0       	breq	.+6      	; 0x315c <free+0xd4>
    3156:	fd 01       	movw	r30, r26
    3158:	dc 01       	movw	r26, r24
    315a:	f7 cf       	rjmp	.-18     	; 0x314a <free+0xc2>
    315c:	8d 91       	ld	r24, X+
    315e:	9c 91       	ld	r25, X
    3160:	11 97       	sbiw	r26, 0x01	; 1
    3162:	9d 01       	movw	r18, r26
    3164:	2e 5f       	subi	r18, 0xFE	; 254
    3166:	3f 4f       	sbci	r19, 0xFF	; 255
    3168:	82 0f       	add	r24, r18
    316a:	93 1f       	adc	r25, r19
    316c:	20 91 b6 12 	lds	r18, 0x12B6	; 0x8012b6 <__brkval>
    3170:	30 91 b7 12 	lds	r19, 0x12B7	; 0x8012b7 <__brkval+0x1>
    3174:	28 17       	cp	r18, r24
    3176:	39 07       	cpc	r19, r25
    3178:	69 f4       	brne	.+26     	; 0x3194 <free+0x10c>
    317a:	30 97       	sbiw	r30, 0x00	; 0
    317c:	29 f4       	brne	.+10     	; 0x3188 <free+0x100>
    317e:	10 92 b9 12 	sts	0x12B9, r1	; 0x8012b9 <__flp+0x1>
    3182:	10 92 b8 12 	sts	0x12B8, r1	; 0x8012b8 <__flp>
    3186:	02 c0       	rjmp	.+4      	; 0x318c <free+0x104>
    3188:	13 82       	std	Z+3, r1	; 0x03
    318a:	12 82       	std	Z+2, r1	; 0x02
    318c:	b0 93 b7 12 	sts	0x12B7, r27	; 0x8012b7 <__brkval+0x1>
    3190:	a0 93 b6 12 	sts	0x12B6, r26	; 0x8012b6 <__brkval>
    3194:	df 91       	pop	r29
    3196:	cf 91       	pop	r28
    3198:	08 95       	ret

0000319a <memset>:
    319a:	dc 01       	movw	r26, r24
    319c:	01 c0       	rjmp	.+2      	; 0x31a0 <memset+0x6>
    319e:	6d 93       	st	X+, r22
    31a0:	41 50       	subi	r20, 0x01	; 1
    31a2:	50 40       	sbci	r21, 0x00	; 0
    31a4:	e0 f7       	brcc	.-8      	; 0x319e <memset+0x4>
    31a6:	08 95       	ret

000031a8 <strncpy>:
    31a8:	fb 01       	movw	r30, r22
    31aa:	dc 01       	movw	r26, r24
    31ac:	41 50       	subi	r20, 0x01	; 1
    31ae:	50 40       	sbci	r21, 0x00	; 0
    31b0:	48 f0       	brcs	.+18     	; 0x31c4 <strncpy+0x1c>
    31b2:	01 90       	ld	r0, Z+
    31b4:	0d 92       	st	X+, r0
    31b6:	00 20       	and	r0, r0
    31b8:	c9 f7       	brne	.-14     	; 0x31ac <strncpy+0x4>
    31ba:	01 c0       	rjmp	.+2      	; 0x31be <strncpy+0x16>
    31bc:	1d 92       	st	X+, r1
    31be:	41 50       	subi	r20, 0x01	; 1
    31c0:	50 40       	sbci	r21, 0x00	; 0
    31c2:	e0 f7       	brcc	.-8      	; 0x31bc <strncpy+0x14>
    31c4:	08 95       	ret

000031c6 <__itoa_ncheck>:
    31c6:	bb 27       	eor	r27, r27
    31c8:	4a 30       	cpi	r20, 0x0A	; 10
    31ca:	31 f4       	brne	.+12     	; 0x31d8 <__itoa_ncheck+0x12>
    31cc:	99 23       	and	r25, r25
    31ce:	22 f4       	brpl	.+8      	; 0x31d8 <__itoa_ncheck+0x12>
    31d0:	bd e2       	ldi	r27, 0x2D	; 45
    31d2:	90 95       	com	r25
    31d4:	81 95       	neg	r24
    31d6:	9f 4f       	sbci	r25, 0xFF	; 255
    31d8:	01 c0       	rjmp	.+2      	; 0x31dc <__utoa_common>

000031da <__utoa_ncheck>:
    31da:	bb 27       	eor	r27, r27

000031dc <__utoa_common>:
    31dc:	fb 01       	movw	r30, r22
    31de:	55 27       	eor	r21, r21
    31e0:	aa 27       	eor	r26, r26
    31e2:	88 0f       	add	r24, r24
    31e4:	99 1f       	adc	r25, r25
    31e6:	aa 1f       	adc	r26, r26
    31e8:	a4 17       	cp	r26, r20
    31ea:	10 f0       	brcs	.+4      	; 0x31f0 <__utoa_common+0x14>
    31ec:	a4 1b       	sub	r26, r20
    31ee:	83 95       	inc	r24
    31f0:	50 51       	subi	r21, 0x10	; 16
    31f2:	b9 f7       	brne	.-18     	; 0x31e2 <__utoa_common+0x6>
    31f4:	a0 5d       	subi	r26, 0xD0	; 208
    31f6:	aa 33       	cpi	r26, 0x3A	; 58
    31f8:	08 f0       	brcs	.+2      	; 0x31fc <__utoa_common+0x20>
    31fa:	a9 5d       	subi	r26, 0xD9	; 217
    31fc:	a1 93       	st	Z+, r26
    31fe:	00 97       	sbiw	r24, 0x00	; 0
    3200:	79 f7       	brne	.-34     	; 0x31e0 <__utoa_common+0x4>
    3202:	b1 11       	cpse	r27, r1
    3204:	b1 93       	st	Z+, r27
    3206:	11 92       	st	Z+, r1
    3208:	cb 01       	movw	r24, r22
    320a:	00 c0       	rjmp	.+0      	; 0x320c <strrev>

0000320c <strrev>:
    320c:	dc 01       	movw	r26, r24
    320e:	fc 01       	movw	r30, r24
    3210:	67 2f       	mov	r22, r23
    3212:	71 91       	ld	r23, Z+
    3214:	77 23       	and	r23, r23
    3216:	e1 f7       	brne	.-8      	; 0x3210 <strrev+0x4>
    3218:	32 97       	sbiw	r30, 0x02	; 2
    321a:	04 c0       	rjmp	.+8      	; 0x3224 <strrev+0x18>
    321c:	7c 91       	ld	r23, X
    321e:	6d 93       	st	X+, r22
    3220:	70 83       	st	Z, r23
    3222:	62 91       	ld	r22, -Z
    3224:	ae 17       	cp	r26, r30
    3226:	bf 07       	cpc	r27, r31
    3228:	c8 f3       	brcs	.-14     	; 0x321c <strrev+0x10>
    322a:	08 95       	ret

0000322c <__do_global_dtors>:
    322c:	10 e0       	ldi	r17, 0x00	; 0
    322e:	cb ee       	ldi	r28, 0xEB	; 235
    3230:	d0 e0       	ldi	r29, 0x00	; 0
    3232:	00 e0       	ldi	r16, 0x00	; 0
    3234:	05 c0       	rjmp	.+10     	; 0x3240 <__do_global_dtors+0x14>
    3236:	80 2f       	mov	r24, r16
    3238:	fe 01       	movw	r30, r28
    323a:	77 de       	rcall	.-786    	; 0x2f2a <__tablejump2__>
    323c:	21 96       	adiw	r28, 0x01	; 1
    323e:	01 1d       	adc	r16, r1
    3240:	cc 3e       	cpi	r28, 0xEC	; 236
    3242:	d1 07       	cpc	r29, r17
    3244:	80 e0       	ldi	r24, 0x00	; 0
    3246:	08 07       	cpc	r16, r24
    3248:	b1 f7       	brne	.-20     	; 0x3236 <__do_global_dtors+0xa>
    324a:	f8 94       	cli

0000324c <__stop_program>:
    324c:	ff cf       	rjmp	.-2      	; 0x324c <__stop_program>
