
RobotSorter.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000000fa  00800200  00003ede  00003f72  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00003ede  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000fea  008002fa  008002fa  0000406c  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  0000406c  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  0000409c  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000738  00000000  00000000  000040dc  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000b9f5  00000000  00000000  00004814  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00003c67  00000000  00000000  00010209  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00006016  00000000  00000000  00013e70  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000013f4  00000000  00000000  00019e88  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000026c7  00000000  00000000  0001b27c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00008aa1  00000000  00000000  0001d943  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000eb0  00000000  00000000  000263e4  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	73 c0       	rjmp	.+230    	; 0xe8 <__dtors_end>
       2:	00 00       	nop
       4:	a1 c0       	rjmp	.+322    	; 0x148 <__bad_interrupt>
       6:	00 00       	nop
       8:	9f c0       	rjmp	.+318    	; 0x148 <__bad_interrupt>
       a:	00 00       	nop
       c:	9d c0       	rjmp	.+314    	; 0x148 <__bad_interrupt>
       e:	00 00       	nop
      10:	9b c0       	rjmp	.+310    	; 0x148 <__bad_interrupt>
      12:	00 00       	nop
      14:	0c 94 a5 15 	jmp	0x2b4a	; 0x2b4a <__vector_5>
      18:	97 c0       	rjmp	.+302    	; 0x148 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	95 c0       	rjmp	.+298    	; 0x148 <__bad_interrupt>
      1e:	00 00       	nop
      20:	93 c0       	rjmp	.+294    	; 0x148 <__bad_interrupt>
      22:	00 00       	nop
      24:	91 c0       	rjmp	.+290    	; 0x148 <__bad_interrupt>
      26:	00 00       	nop
      28:	8f c0       	rjmp	.+286    	; 0x148 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	8d c0       	rjmp	.+282    	; 0x148 <__bad_interrupt>
      2e:	00 00       	nop
      30:	8b c0       	rjmp	.+278    	; 0x148 <__bad_interrupt>
      32:	00 00       	nop
      34:	89 c0       	rjmp	.+274    	; 0x148 <__bad_interrupt>
      36:	00 00       	nop
      38:	87 c0       	rjmp	.+270    	; 0x148 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	85 c0       	rjmp	.+266    	; 0x148 <__bad_interrupt>
      3e:	00 00       	nop
      40:	83 c0       	rjmp	.+262    	; 0x148 <__bad_interrupt>
      42:	00 00       	nop
      44:	81 c0       	rjmp	.+258    	; 0x148 <__bad_interrupt>
      46:	00 00       	nop
      48:	7f c0       	rjmp	.+254    	; 0x148 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	7d c0       	rjmp	.+250    	; 0x148 <__bad_interrupt>
      4e:	00 00       	nop
      50:	7b c0       	rjmp	.+246    	; 0x148 <__bad_interrupt>
      52:	00 00       	nop
      54:	0c 94 d3 0f 	jmp	0x1fa6	; 0x1fa6 <__vector_21>
      58:	77 c0       	rjmp	.+238    	; 0x148 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	75 c0       	rjmp	.+234    	; 0x148 <__bad_interrupt>
      5e:	00 00       	nop
      60:	73 c0       	rjmp	.+230    	; 0x148 <__bad_interrupt>
      62:	00 00       	nop
      64:	71 c0       	rjmp	.+226    	; 0x148 <__bad_interrupt>
      66:	00 00       	nop
      68:	6f c0       	rjmp	.+222    	; 0x148 <__bad_interrupt>
      6a:	00 00       	nop
      6c:	6d c0       	rjmp	.+218    	; 0x148 <__bad_interrupt>
      6e:	00 00       	nop
      70:	6b c0       	rjmp	.+214    	; 0x148 <__bad_interrupt>
      72:	00 00       	nop
      74:	69 c0       	rjmp	.+210    	; 0x148 <__bad_interrupt>
      76:	00 00       	nop
      78:	67 c0       	rjmp	.+206    	; 0x148 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	65 c0       	rjmp	.+202    	; 0x148 <__bad_interrupt>
      7e:	00 00       	nop
      80:	63 c0       	rjmp	.+198    	; 0x148 <__bad_interrupt>
      82:	00 00       	nop
      84:	61 c0       	rjmp	.+194    	; 0x148 <__bad_interrupt>
      86:	00 00       	nop
      88:	5f c0       	rjmp	.+190    	; 0x148 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	5d c0       	rjmp	.+186    	; 0x148 <__bad_interrupt>
      8e:	00 00       	nop
      90:	5b c0       	rjmp	.+182    	; 0x148 <__bad_interrupt>
      92:	00 00       	nop
      94:	59 c0       	rjmp	.+178    	; 0x148 <__bad_interrupt>
      96:	00 00       	nop
      98:	57 c0       	rjmp	.+174    	; 0x148 <__bad_interrupt>
      9a:	00 00       	nop
      9c:	55 c0       	rjmp	.+170    	; 0x148 <__bad_interrupt>
      9e:	00 00       	nop
      a0:	53 c0       	rjmp	.+166    	; 0x148 <__bad_interrupt>
      a2:	00 00       	nop
      a4:	29 c2       	rjmp	.+1106   	; 0x4f8 <__vector_41>
      a6:	00 00       	nop
      a8:	4f c0       	rjmp	.+158    	; 0x148 <__bad_interrupt>
      aa:	00 00       	nop
      ac:	4d c0       	rjmp	.+154    	; 0x148 <__bad_interrupt>
      ae:	00 00       	nop
      b0:	4b c0       	rjmp	.+150    	; 0x148 <__bad_interrupt>
      b2:	00 00       	nop
      b4:	fc c1       	rjmp	.+1016   	; 0x4ae <__vector_45>
      b6:	00 00       	nop
      b8:	47 c0       	rjmp	.+142    	; 0x148 <__bad_interrupt>
      ba:	00 00       	nop
      bc:	45 c0       	rjmp	.+138    	; 0x148 <__bad_interrupt>
      be:	00 00       	nop
      c0:	43 c0       	rjmp	.+134    	; 0x148 <__bad_interrupt>
      c2:	00 00       	nop
      c4:	41 c0       	rjmp	.+130    	; 0x148 <__bad_interrupt>
      c6:	00 00       	nop
      c8:	3f c0       	rjmp	.+126    	; 0x148 <__bad_interrupt>
      ca:	00 00       	nop
      cc:	3d c0       	rjmp	.+122    	; 0x148 <__bad_interrupt>
      ce:	00 00       	nop
      d0:	3b c0       	rjmp	.+118    	; 0x148 <__bad_interrupt>
      d2:	00 00       	nop
      d4:	39 c0       	rjmp	.+114    	; 0x148 <__bad_interrupt>
      d6:	00 00       	nop
      d8:	37 c0       	rjmp	.+110    	; 0x148 <__bad_interrupt>
      da:	00 00       	nop
      dc:	35 c0       	rjmp	.+106    	; 0x148 <__bad_interrupt>
      de:	00 00       	nop
      e0:	33 c0       	rjmp	.+102    	; 0x148 <__bad_interrupt>
	...

000000e4 <__ctors_start>:
      e4:	93 04       	cpc	r9, r3

000000e6 <__ctors_end>:
      e6:	96 04       	cpc	r9, r6

000000e8 <__dtors_end>:
      e8:	11 24       	eor	r1, r1
      ea:	1f be       	out	0x3f, r1	; 63
      ec:	cf ef       	ldi	r28, 0xFF	; 255
      ee:	d1 e2       	ldi	r29, 0x21	; 33
      f0:	de bf       	out	0x3e, r29	; 62
      f2:	cd bf       	out	0x3d, r28	; 61
      f4:	00 e0       	ldi	r16, 0x00	; 0
      f6:	0c bf       	out	0x3c, r16	; 60

000000f8 <__do_copy_data>:
      f8:	12 e0       	ldi	r17, 0x02	; 2
      fa:	a0 e0       	ldi	r26, 0x00	; 0
      fc:	b2 e0       	ldi	r27, 0x02	; 2
      fe:	ee ed       	ldi	r30, 0xDE	; 222
     100:	fe e3       	ldi	r31, 0x3E	; 62
     102:	00 e0       	ldi	r16, 0x00	; 0
     104:	0b bf       	out	0x3b, r16	; 59
     106:	02 c0       	rjmp	.+4      	; 0x10c <__do_copy_data+0x14>
     108:	07 90       	elpm	r0, Z+
     10a:	0d 92       	st	X+, r0
     10c:	aa 3f       	cpi	r26, 0xFA	; 250
     10e:	b1 07       	cpc	r27, r17
     110:	d9 f7       	brne	.-10     	; 0x108 <__do_copy_data+0x10>

00000112 <__do_clear_bss>:
     112:	22 e1       	ldi	r18, 0x12	; 18
     114:	aa ef       	ldi	r26, 0xFA	; 250
     116:	b2 e0       	ldi	r27, 0x02	; 2
     118:	01 c0       	rjmp	.+2      	; 0x11c <.do_clear_bss_start>

0000011a <.do_clear_bss_loop>:
     11a:	1d 92       	st	X+, r1

0000011c <.do_clear_bss_start>:
     11c:	a4 3e       	cpi	r26, 0xE4	; 228
     11e:	b2 07       	cpc	r27, r18
     120:	e1 f7       	brne	.-8      	; 0x11a <.do_clear_bss_loop>

00000122 <__do_global_ctors>:
     122:	10 e0       	ldi	r17, 0x00	; 0
     124:	c3 e7       	ldi	r28, 0x73	; 115
     126:	d0 e0       	ldi	r29, 0x00	; 0
     128:	00 e0       	ldi	r16, 0x00	; 0
     12a:	06 c0       	rjmp	.+12     	; 0x138 <__do_global_ctors+0x16>
     12c:	21 97       	sbiw	r28, 0x01	; 1
     12e:	01 09       	sbc	r16, r1
     130:	80 2f       	mov	r24, r16
     132:	fe 01       	movw	r30, r28
     134:	0e 94 1f 1e 	call	0x3c3e	; 0x3c3e <__tablejump2__>
     138:	c2 37       	cpi	r28, 0x72	; 114
     13a:	d1 07       	cpc	r29, r17
     13c:	80 e0       	ldi	r24, 0x00	; 0
     13e:	08 07       	cpc	r16, r24
     140:	a9 f7       	brne	.-22     	; 0x12c <__do_global_ctors+0xa>
     142:	bd d3       	rcall	.+1914   	; 0x8be <main>
     144:	0c 94 5e 1f 	jmp	0x3ebc	; 0x3ebc <__do_global_dtors>

00000148 <__bad_interrupt>:
     148:	5b cf       	rjmp	.-330    	; 0x0 <__vectors>

0000014a <_ZN5ColorC1Ev>:
}

uint8_t Color::getColorIndex( void )
{
	return _colorIndex;
}
     14a:	fc 01       	movw	r30, r24
     14c:	11 82       	std	Z+1, r1	; 0x01
     14e:	10 82       	st	Z, r1
     150:	13 82       	std	Z+3, r1	; 0x03
     152:	12 82       	std	Z+2, r1	; 0x02
     154:	15 82       	std	Z+5, r1	; 0x05
     156:	14 82       	std	Z+4, r1	; 0x04
     158:	17 82       	std	Z+7, r1	; 0x07
     15a:	16 82       	std	Z+6, r1	; 0x06
     15c:	8f ef       	ldi	r24, 0xFF	; 255
     15e:	80 87       	std	Z+8, r24	; 0x08
     160:	08 95       	ret

00000162 <_ZN5Color12getRedPeriodEv>:
     162:	fc 01       	movw	r30, r24
     164:	80 81       	ld	r24, Z
     166:	91 81       	ldd	r25, Z+1	; 0x01
     168:	08 95       	ret

0000016a <_ZN5Color13getBluePeriodEv>:
     16a:	fc 01       	movw	r30, r24
     16c:	82 81       	ldd	r24, Z+2	; 0x02
     16e:	93 81       	ldd	r25, Z+3	; 0x03
     170:	08 95       	ret

00000172 <_ZN5Color14getGreenPeriodEv>:
     172:	fc 01       	movw	r30, r24
     174:	84 81       	ldd	r24, Z+4	; 0x04
     176:	95 81       	ldd	r25, Z+5	; 0x05
     178:	08 95       	ret

0000017a <_ZN5Color14getWhitePeriodEv>:
     17a:	fc 01       	movw	r30, r24
     17c:	86 81       	ldd	r24, Z+6	; 0x06
     17e:	97 81       	ldd	r25, Z+7	; 0x07
     180:	08 95       	ret

00000182 <_ZN5Color12setRedPeriodEj>:

void Color::setRedPeriod( uint16_t redPeriod )
{
	_redPeriod = redPeriod;
     182:	fc 01       	movw	r30, r24
     184:	71 83       	std	Z+1, r23	; 0x01
     186:	60 83       	st	Z, r22
     188:	08 95       	ret

0000018a <_ZN5Color13setBluePeriodEj>:
}

void Color::setBluePeriod( uint16_t bluePeriod )
{
	_bluePeriod = bluePeriod;
     18a:	fc 01       	movw	r30, r24
     18c:	73 83       	std	Z+3, r23	; 0x03
     18e:	62 83       	std	Z+2, r22	; 0x02
     190:	08 95       	ret

00000192 <_ZN5Color14setGreenPeriodEj>:
}

void Color::setGreenPeriod( uint16_t greenPeriod )
{
	_greenPeriod = greenPeriod;
     192:	fc 01       	movw	r30, r24
     194:	75 83       	std	Z+5, r23	; 0x05
     196:	64 83       	std	Z+4, r22	; 0x04
     198:	08 95       	ret

0000019a <_ZN5Color14setWhitePeriodEj>:
}

void Color::setWhitePeriod( uint16_t whitePeriod )
{
	_whitePeriod = whitePeriod;
     19a:	fc 01       	movw	r30, r24
     19c:	77 83       	std	Z+7, r23	; 0x07
     19e:	66 83       	std	Z+6, r22	; 0x06
     1a0:	08 95       	ret

000001a2 <_ZN5Color13setColorIndexEh>:
}

void Color::setColorIndex( uint8_t index )
{
	_colorIndex = index;
     1a2:	fc 01       	movw	r30, r24
     1a4:	60 87       	std	Z+8, r22	; 0x08
     1a6:	08 95       	ret

000001a8 <_ZN11ColorSensorC1E16FrequencyScaling>:
}

// default destructor
ColorSensor::~ColorSensor()
{	
}
     1a8:	df 92       	push	r13
     1aa:	ef 92       	push	r14
     1ac:	ff 92       	push	r15
     1ae:	0f 93       	push	r16
     1b0:	1f 93       	push	r17
     1b2:	cf 93       	push	r28
     1b4:	df 93       	push	r29
     1b6:	1f 92       	push	r1
     1b8:	cd b7       	in	r28, 0x3d	; 61
     1ba:	de b7       	in	r29, 0x3e	; 62
     1bc:	7c 01       	movw	r14, r24
     1be:	d6 2e       	mov	r13, r22
     1c0:	1f d1       	rcall	.+574    	; 0x400 <_ZN6Timer4C1Ev>
     1c2:	87 01       	movw	r16, r14
     1c4:	0f 5f       	subi	r16, 0xFF	; 255
     1c6:	1f 4f       	sbci	r17, 0xFF	; 255
     1c8:	8b e5       	ldi	r24, 0x5B	; 91
     1ca:	e8 0e       	add	r14, r24
     1cc:	f1 1c       	adc	r15, r1
     1ce:	c8 01       	movw	r24, r16
     1d0:	bc df       	rcall	.-136    	; 0x14a <_ZN5ColorC1Ev>
     1d2:	07 5f       	subi	r16, 0xF7	; 247
     1d4:	1f 4f       	sbci	r17, 0xFF	; 255
     1d6:	0e 15       	cp	r16, r14
     1d8:	1f 05       	cpc	r17, r15
     1da:	c9 f7       	brne	.-14     	; 0x1ce <_ZN11ColorSensorC1E16FrequencyScaling+0x26>
     1dc:	ce 01       	movw	r24, r28
     1de:	01 96       	adiw	r24, 0x01	; 1
     1e0:	0f d1       	rcall	.+542    	; 0x400 <_ZN6Timer4C1Ev>
     1e2:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
     1e6:	81 60       	ori	r24, 0x01	; 1
     1e8:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
     1ec:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
     1f0:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
     1f4:	81 e0       	ldi	r24, 0x01	; 1
     1f6:	d8 16       	cp	r13, r24
     1f8:	d1 f0       	breq	.+52     	; 0x22e <_ZN11ColorSensorC1E16FrequencyScaling+0x86>
     1fa:	d8 16       	cp	r13, r24
     1fc:	c0 f0       	brcs	.+48     	; 0x22e <_ZN11ColorSensorC1E16FrequencyScaling+0x86>
     1fe:	82 e0       	ldi	r24, 0x02	; 2
     200:	d8 16       	cp	r13, r24
     202:	19 f0       	breq	.+6      	; 0x20a <_ZN11ColorSensorC1E16FrequencyScaling+0x62>
     204:	83 e0       	ldi	r24, 0x03	; 3
     206:	d8 12       	cpse	r13, r24
     208:	09 c0       	rjmp	.+18     	; 0x21c <_ZN11ColorSensorC1E16FrequencyScaling+0x74>
     20a:	80 91 05 01 	lds	r24, 0x0105	; 0x800105 <__TEXT_REGION_LENGTH__+0x700105>
     20e:	81 60       	ori	r24, 0x01	; 1
     210:	80 93 05 01 	sts	0x0105, r24	; 0x800105 <__TEXT_REGION_LENGTH__+0x700105>
     214:	80 91 05 01 	lds	r24, 0x0105	; 0x800105 <__TEXT_REGION_LENGTH__+0x700105>
     218:	80 93 05 01 	sts	0x0105, r24	; 0x800105 <__TEXT_REGION_LENGTH__+0x700105>
     21c:	0f 90       	pop	r0
     21e:	df 91       	pop	r29
     220:	cf 91       	pop	r28
     222:	1f 91       	pop	r17
     224:	0f 91       	pop	r16
     226:	ff 90       	pop	r15
     228:	ef 90       	pop	r14
     22a:	df 90       	pop	r13
     22c:	08 95       	ret
     22e:	80 91 05 01 	lds	r24, 0x0105	; 0x800105 <__TEXT_REGION_LENGTH__+0x700105>
     232:	8e 7f       	andi	r24, 0xFE	; 254
     234:	80 93 05 01 	sts	0x0105, r24	; 0x800105 <__TEXT_REGION_LENGTH__+0x700105>
     238:	80 91 05 01 	lds	r24, 0x0105	; 0x800105 <__TEXT_REGION_LENGTH__+0x700105>
     23c:	80 93 05 01 	sts	0x0105, r24	; 0x800105 <__TEXT_REGION_LENGTH__+0x700105>
     240:	ed cf       	rjmp	.-38     	; 0x21c <_ZN11ColorSensorC1E16FrequencyScaling+0x74>

00000242 <_ZN11ColorSensor8getColorEv>:

uint8_t ColorSensor::getColor()
{
     242:	8f 92       	push	r8
     244:	9f 92       	push	r9
     246:	af 92       	push	r10
     248:	bf 92       	push	r11
     24a:	cf 92       	push	r12
     24c:	df 92       	push	r13
     24e:	ef 92       	push	r14
     250:	ff 92       	push	r15
     252:	1f 93       	push	r17
     254:	cf 93       	push	r28
     256:	df 93       	push	r29
     258:	ec 01       	movw	r28, r24
void ColorSensor::setFilter( Filter filter_ )
{
	switch ( filter_ )
	{
	case redFilter:
		COLORSENSOR_S2_PORT &= ~( COLORSENSOR_S2_PIN );
     25a:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
     25e:	8e 7f       	andi	r24, 0xFE	; 254
     260:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
		COLORSENSOR_S3_PORT &= ~( COLORSENSOR_S3_PIN );
     264:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
     268:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
{
	uint8_t result = 255;
	
	// Get period values from all filters
	setFilter( redFilter );
	uint16_t redPeriod = frequency_.getPeriod();
     26c:	ce 01       	movw	r24, r28
     26e:	e7 d0       	rcall	.+462    	; 0x43e <_ZN6Timer49getPeriodEv>
     270:	7c 01       	movw	r14, r24
		COLORSENSOR_S2_PORT &= ~( COLORSENSOR_S2_PIN );
		COLORSENSOR_S3_PORT &= ~( COLORSENSOR_S3_PIN );
		break;

	case blueFilter:
		COLORSENSOR_S2_PORT &= ~( COLORSENSOR_S2_PIN );
     272:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
     276:	8e 7f       	andi	r24, 0xFE	; 254
     278:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
		COLORSENSOR_S3_PORT |= COLORSENSOR_S3_PIN;
     27c:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
     280:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
	// Get period values from all filters
	setFilter( redFilter );
	uint16_t redPeriod = frequency_.getPeriod();

	setFilter( blueFilter );
	uint16_t bluePeriod = frequency_.getPeriod();  
     284:	ce 01       	movw	r24, r28
     286:	db d0       	rcall	.+438    	; 0x43e <_ZN6Timer49getPeriodEv>
     288:	6c 01       	movw	r12, r24
		COLORSENSOR_S2_PORT &= ~( COLORSENSOR_S2_PIN );
		COLORSENSOR_S3_PORT |= COLORSENSOR_S3_PIN;
		break;

	case greenFilter:
		COLORSENSOR_S2_PORT |= COLORSENSOR_S2_PIN;
     28a:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
     28e:	81 60       	ori	r24, 0x01	; 1
     290:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
		COLORSENSOR_S3_PORT |= COLORSENSOR_S3_PIN;
     294:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
     298:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>

	setFilter( blueFilter );
	uint16_t bluePeriod = frequency_.getPeriod();  

	setFilter( greenFilter );
	uint16_t greenPeriod = frequency_.getPeriod();
     29c:	ce 01       	movw	r24, r28
     29e:	cf d0       	rcall	.+414    	; 0x43e <_ZN6Timer49getPeriodEv>
     2a0:	5c 01       	movw	r10, r24
		COLORSENSOR_S2_PORT |= COLORSENSOR_S2_PIN;
		COLORSENSOR_S3_PORT |= COLORSENSOR_S3_PIN;
		break;

	case noFilter:
		COLORSENSOR_S2_PORT |= COLORSENSOR_S2_PIN;
     2a2:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
     2a6:	81 60       	ori	r24, 0x01	; 1
     2a8:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
		COLORSENSOR_S3_PORT &= ~( COLORSENSOR_S3_PIN );
     2ac:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
     2b0:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>

	setFilter( greenFilter );
	uint16_t greenPeriod = frequency_.getPeriod();
	
	setFilter( noFilter );
	uint16_t whitePeriod = frequency_.getPeriod();
     2b4:	ce 01       	movw	r24, r28
     2b6:	c3 d0       	rcall	.+390    	; 0x43e <_ZN6Timer49getPeriodEv>
     2b8:	4c 01       	movw	r8, r24
     2ba:	21 96       	adiw	r28, 0x01	; 1
	
	// Check all stored colors against read values	
	for ( uint8_t index = 0U; index < 10; index++)
     2bc:	10 e0       	ldi	r17, 0x00	; 0
     2be:	04 c0       	rjmp	.+8      	; 0x2c8 <_ZN11ColorSensor8getColorEv+0x86>
     2c0:	1f 5f       	subi	r17, 0xFF	; 255
     2c2:	29 96       	adiw	r28, 0x09	; 9
     2c4:	1a 30       	cpi	r17, 0x0A	; 10
	{		
		if ( _colors[index].getRedPeriod() + 5 > redPeriod && _colors[index].getRedPeriod() - 5 < redPeriod )
     2c6:	89 f1       	breq	.+98     	; 0x32a <_ZN11ColorSensor8getColorEv+0xe8>
     2c8:	ce 01       	movw	r24, r28
     2ca:	4b df       	rcall	.-362    	; 0x162 <_ZN5Color12getRedPeriodEv>
     2cc:	05 96       	adiw	r24, 0x05	; 5
     2ce:	e8 16       	cp	r14, r24
     2d0:	f9 06       	cpc	r15, r25
     2d2:	b0 f7       	brcc	.-20     	; 0x2c0 <_ZN11ColorSensor8getColorEv+0x7e>
     2d4:	ce 01       	movw	r24, r28
     2d6:	45 df       	rcall	.-374    	; 0x162 <_ZN5Color12getRedPeriodEv>
     2d8:	05 97       	sbiw	r24, 0x05	; 5
     2da:	8e 15       	cp	r24, r14
     2dc:	9f 05       	cpc	r25, r15
		{
 			if ( _colors[index].getBluePeriod() + 5 > bluePeriod && _colors[index].getBluePeriod() - 5 < bluePeriod )
     2de:	80 f7       	brcc	.-32     	; 0x2c0 <_ZN11ColorSensor8getColorEv+0x7e>
     2e0:	ce 01       	movw	r24, r28
     2e2:	43 df       	rcall	.-378    	; 0x16a <_ZN5Color13getBluePeriodEv>
     2e4:	05 96       	adiw	r24, 0x05	; 5
     2e6:	c8 16       	cp	r12, r24
     2e8:	d9 06       	cpc	r13, r25
     2ea:	50 f7       	brcc	.-44     	; 0x2c0 <_ZN11ColorSensor8getColorEv+0x7e>
     2ec:	ce 01       	movw	r24, r28
     2ee:	3d df       	rcall	.-390    	; 0x16a <_ZN5Color13getBluePeriodEv>
     2f0:	05 97       	sbiw	r24, 0x05	; 5
     2f2:	8c 15       	cp	r24, r12
     2f4:	9d 05       	cpc	r25, r13
			{
				if ( _colors[index].getGreenPeriod() + 5 > greenPeriod && _colors[index].getGreenPeriod() - 5 < greenPeriod )
     2f6:	20 f7       	brcc	.-56     	; 0x2c0 <_ZN11ColorSensor8getColorEv+0x7e>
     2f8:	ce 01       	movw	r24, r28
     2fa:	3b df       	rcall	.-394    	; 0x172 <_ZN5Color14getGreenPeriodEv>
     2fc:	05 96       	adiw	r24, 0x05	; 5
     2fe:	a8 16       	cp	r10, r24
     300:	b9 06       	cpc	r11, r25
     302:	f0 f6       	brcc	.-68     	; 0x2c0 <_ZN11ColorSensor8getColorEv+0x7e>
     304:	ce 01       	movw	r24, r28
     306:	35 df       	rcall	.-406    	; 0x172 <_ZN5Color14getGreenPeriodEv>
     308:	05 97       	sbiw	r24, 0x05	; 5
     30a:	8a 15       	cp	r24, r10
     30c:	9b 05       	cpc	r25, r11
				{
					if ( _colors[index].getWhitePeriod() + 2 > whitePeriod && _colors[index].getWhitePeriod() - 2 < whitePeriod )
     30e:	c0 f6       	brcc	.-80     	; 0x2c0 <_ZN11ColorSensor8getColorEv+0x7e>
     310:	ce 01       	movw	r24, r28
     312:	33 df       	rcall	.-410    	; 0x17a <_ZN5Color14getWhitePeriodEv>
     314:	02 96       	adiw	r24, 0x02	; 2
     316:	88 16       	cp	r8, r24
     318:	99 06       	cpc	r9, r25
     31a:	90 f6       	brcc	.-92     	; 0x2c0 <_ZN11ColorSensor8getColorEv+0x7e>
     31c:	ce 01       	movw	r24, r28
     31e:	2d df       	rcall	.-422    	; 0x17a <_ZN5Color14getWhitePeriodEv>
     320:	02 97       	sbiw	r24, 0x02	; 2
     322:	88 15       	cp	r24, r8
     324:	99 05       	cpc	r25, r9
     326:	60 f6       	brcc	.-104    	; 0x2c0 <_ZN11ColorSensor8getColorEv+0x7e>
     328:	01 c0       	rjmp	.+2      	; 0x32c <_ZN11ColorSensor8getColorEv+0xea>
     32a:	1f ef       	ldi	r17, 0xFF	; 255
{	
}

uint8_t ColorSensor::getColor()
{
	uint8_t result = 255;
     32c:	81 2f       	mov	r24, r17
		}
	}
	
	// Return value
	return result;
}
     32e:	df 91       	pop	r29
     330:	cf 91       	pop	r28
     332:	1f 91       	pop	r17
     334:	ff 90       	pop	r15
     336:	ef 90       	pop	r14
     338:	df 90       	pop	r13
     33a:	cf 90       	pop	r12
     33c:	bf 90       	pop	r11
     33e:	af 90       	pop	r10
     340:	9f 90       	pop	r9
     342:	8f 90       	pop	r8
     344:	08 95       	ret

00000346 <_ZN11ColorSensor17addCalibrateColorEh>:
     346:	ff 92       	push	r15

void ColorSensor::addCalibrateColor( uint8_t colorIndex )
{
     348:	0f 93       	push	r16
     34a:	1f 93       	push	r17
     34c:	cf 93       	push	r28
     34e:	df 93       	push	r29
	if ( colorIndex < 10U )
     350:	6a 30       	cpi	r22, 0x0A	; 10
     352:	30 f0       	brcs	.+12     	; 0x360 <_ZN11ColorSensor17addCalibrateColorEh+0x1a>
	}
	else
	{
		/* Cant add more colors. Increase size of array. */
	}
}
     354:	df 91       	pop	r29
     356:	cf 91       	pop	r28
     358:	1f 91       	pop	r17
     35a:	0f 91       	pop	r16
     35c:	ff 90       	pop	r15
     35e:	08 95       	ret
     360:	f6 2e       	mov	r15, r22
     362:	8c 01       	movw	r16, r24
void ColorSensor::setFilter( Filter filter_ )
{
	switch ( filter_ )
	{
	case redFilter:
		COLORSENSOR_S2_PORT &= ~( COLORSENSOR_S2_PIN );
     364:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
     368:	8e 7f       	andi	r24, 0xFE	; 254
     36a:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
		COLORSENSOR_S3_PORT &= ~( COLORSENSOR_S3_PIN );
     36e:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
     372:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
{
	if ( colorIndex < 10U )
	{	
		// Set all colors
		setFilter( redFilter );
		_colors[colorIndex].setRedPeriod( frequency_.getPeriod() );
     376:	c8 01       	movw	r24, r16
     378:	62 d0       	rcall	.+196    	; 0x43e <_ZN6Timer49getPeriodEv>
     37a:	2f 2d       	mov	r18, r15
     37c:	30 e0       	ldi	r19, 0x00	; 0
     37e:	e9 01       	movw	r28, r18
     380:	cc 0f       	add	r28, r28
     382:	dd 1f       	adc	r29, r29
     384:	cc 0f       	add	r28, r28
     386:	dd 1f       	adc	r29, r29
     388:	cc 0f       	add	r28, r28
     38a:	dd 1f       	adc	r29, r29
     38c:	c2 0f       	add	r28, r18
     38e:	d3 1f       	adc	r29, r19
     390:	21 96       	adiw	r28, 0x01	; 1
     392:	c0 0f       	add	r28, r16
     394:	d1 1f       	adc	r29, r17
     396:	bc 01       	movw	r22, r24
     398:	ce 01       	movw	r24, r28
     39a:	f3 de       	rcall	.-538    	; 0x182 <_ZN5Color12setRedPeriodEj>
		COLORSENSOR_S2_PORT &= ~( COLORSENSOR_S2_PIN );
		COLORSENSOR_S3_PORT &= ~( COLORSENSOR_S3_PIN );
		break;

	case blueFilter:
		COLORSENSOR_S2_PORT &= ~( COLORSENSOR_S2_PIN );
     39c:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
     3a0:	8e 7f       	andi	r24, 0xFE	; 254
     3a2:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
		COLORSENSOR_S3_PORT |= COLORSENSOR_S3_PIN;
     3a6:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
     3aa:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
		// Set all colors
		setFilter( redFilter );
		_colors[colorIndex].setRedPeriod( frequency_.getPeriod() );

		setFilter( blueFilter );
		_colors[colorIndex].setBluePeriod( frequency_.getPeriod() );
     3ae:	c8 01       	movw	r24, r16
     3b0:	46 d0       	rcall	.+140    	; 0x43e <_ZN6Timer49getPeriodEv>
     3b2:	bc 01       	movw	r22, r24
     3b4:	ce 01       	movw	r24, r28
     3b6:	e9 de       	rcall	.-558    	; 0x18a <_ZN5Color13setBluePeriodEj>
		COLORSENSOR_S2_PORT &= ~( COLORSENSOR_S2_PIN );
		COLORSENSOR_S3_PORT |= COLORSENSOR_S3_PIN;
		break;

	case greenFilter:
		COLORSENSOR_S2_PORT |= COLORSENSOR_S2_PIN;
     3b8:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
     3bc:	81 60       	ori	r24, 0x01	; 1
     3be:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
		COLORSENSOR_S3_PORT |= COLORSENSOR_S3_PIN;
     3c2:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
     3c6:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>

		setFilter( blueFilter );
		_colors[colorIndex].setBluePeriod( frequency_.getPeriod() );
		
		setFilter( greenFilter );
		_colors[colorIndex].setGreenPeriod( frequency_.getPeriod() );
     3ca:	c8 01       	movw	r24, r16
     3cc:	38 d0       	rcall	.+112    	; 0x43e <_ZN6Timer49getPeriodEv>
     3ce:	bc 01       	movw	r22, r24
     3d0:	ce 01       	movw	r24, r28
     3d2:	df de       	rcall	.-578    	; 0x192 <_ZN5Color14setGreenPeriodEj>
		COLORSENSOR_S2_PORT |= COLORSENSOR_S2_PIN;
		COLORSENSOR_S3_PORT |= COLORSENSOR_S3_PIN;
		break;

	case noFilter:
		COLORSENSOR_S2_PORT |= COLORSENSOR_S2_PIN;
     3d4:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
     3d8:	81 60       	ori	r24, 0x01	; 1
     3da:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
		COLORSENSOR_S3_PORT &= ~( COLORSENSOR_S3_PIN );
     3de:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
		
		setFilter( greenFilter );
		_colors[colorIndex].setGreenPeriod( frequency_.getPeriod() );
		
		setFilter( noFilter );
		_colors[colorIndex].setWhitePeriod( frequency_.getPeriod() );
     3e2:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
     3e6:	c8 01       	movw	r24, r16
     3e8:	2a d0       	rcall	.+84     	; 0x43e <_ZN6Timer49getPeriodEv>
     3ea:	bc 01       	movw	r22, r24
     3ec:	ce 01       	movw	r24, r28
				
		// Set index
		_colors[colorIndex].setColorIndex( colorIndex );
     3ee:	d5 de       	rcall	.-598    	; 0x19a <_ZN5Color14setWhitePeriodEj>
     3f0:	6f 2d       	mov	r22, r15
	}
	else
	{
		/* Cant add more colors. Increase size of array. */
	}
}
     3f2:	ce 01       	movw	r24, r28
     3f4:	df 91       	pop	r29
     3f6:	cf 91       	pop	r28
     3f8:	1f 91       	pop	r17
     3fa:	0f 91       	pop	r16
		
		setFilter( noFilter );
		_colors[colorIndex].setWhitePeriod( frequency_.getPeriod() );
				
		// Set index
		_colors[colorIndex].setColorIndex( colorIndex );
     3fc:	ff 90       	pop	r15
     3fe:	d1 ce       	rjmp	.-606    	; 0x1a2 <_ZN5Color13setColorIndexEh>

00000400 <_ZN6Timer4C1Ev>:
//volatile float tick = 0.000064;

Timer4::Timer4()
{
	// Set ports to the right values.
	COLORSENSOR_S0_PORT |= ( 1 << COLORSENSOR_S0_PIN );
     400:	e5 e0       	ldi	r30, 0x05	; 5
     402:	f1 e0       	ldi	r31, 0x01	; 1
     404:	80 81       	ld	r24, Z
     406:	82 60       	ori	r24, 0x02	; 2
     408:	80 83       	st	Z, r24
	COLORSENSOR_S1_PORT |= ( 1 << COLORSENSOR_S1_PIN );
     40a:	80 81       	ld	r24, Z
     40c:	81 60       	ori	r24, 0x01	; 1
     40e:	80 83       	st	Z, r24
	COLORSENSOR_S2_PORT |= ( 1 << COLORSENSOR_S2_PIN );
     410:	e2 e0       	ldi	r30, 0x02	; 2
     412:	f1 e0       	ldi	r31, 0x01	; 1
     414:	80 81       	ld	r24, Z
     416:	82 60       	ori	r24, 0x02	; 2
     418:	80 83       	st	Z, r24
	COLORSENSOR_S3_PORT |= ( 1 << COLORSENSOR_S3_PIN );
     41a:	80 81       	ld	r24, Z
     41c:	81 60       	ori	r24, 0x01	; 1
     41e:	80 83       	st	Z, r24
	
	// Setup timer to normal mode and pre scaler to 64
	TCCR4A = 0U;
     420:	10 92 a0 00 	sts	0x00A0, r1	; 0x8000a0 <__TEXT_REGION_LENGTH__+0x7000a0>
	TCCR4B = ( 1 << ICNC4 ) | ( 1 << ICES4 ) | ( 1 << CS40 ) | ( 1 << CS41 );
     424:	83 ec       	ldi	r24, 0xC3	; 195
     426:	80 93 a1 00 	sts	0x00A1, r24	; 0x8000a1 <__TEXT_REGION_LENGTH__+0x7000a1>
	TCCR4C = 0U;
     42a:	10 92 a2 00 	sts	0x00A2, r1	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
	
	// Clear flags and set counter to zero
	TIFR4 = ( 1 << ICF4 ) | ( 1 << TOV4 );
     42e:	81 e2       	ldi	r24, 0x21	; 33
     430:	89 bb       	out	0x19, r24	; 25
	TCNT4 = 0;        
     432:	10 92 a5 00 	sts	0x00A5, r1	; 0x8000a5 <__TEXT_REGION_LENGTH__+0x7000a5>
     436:	10 92 a4 00 	sts	0x00A4, r1	; 0x8000a4 <__TEXT_REGION_LENGTH__+0x7000a4>

	// Enable global interrupts
    sei();
     43a:	78 94       	sei
     43c:	08 95       	ret

0000043e <_ZN6Timer49getPeriodEv>:
}

uint16_t Timer4::getPeriod( void )
{
	// Reset all needed values
	first = true;
     43e:	81 e0       	ldi	r24, 0x01	; 1
     440:	80 93 0a 02 	sts	0x020A, r24	; 0x80020a <first>
	oldValue = 0U;
     444:	10 92 01 03 	sts	0x0301, r1	; 0x800301 <oldValue+0x1>
     448:	10 92 00 03 	sts	0x0300, r1	; 0x800300 <oldValue>
	period = 0U;
     44c:	10 92 fb 02 	sts	0x02FB, r1	; 0x8002fb <__data_end+0x1>
     450:	10 92 fa 02 	sts	0x02FA, r1	; 0x8002fa <__data_end>
	timeroverflow = 0;
     454:	10 92 fc 02 	sts	0x02FC, r1	; 0x8002fc <timeroverflow>
     458:	10 92 fd 02 	sts	0x02FD, r1	; 0x8002fd <timeroverflow+0x1>
     45c:	10 92 fe 02 	sts	0x02FE, r1	; 0x8002fe <timeroverflow+0x2>
     460:	10 92 ff 02 	sts	0x02FF, r1	; 0x8002ff <timeroverflow+0x3>
	
	// Enable interrupt and clear pending
	TIFR4 = ( 1 << ICF4 ) | ( 1 << TOV4 );
     464:	81 e2       	ldi	r24, 0x21	; 33
     466:	89 bb       	out	0x19, r24	; 25
	TIMSK4 = ( 1 << ICIE4 ) | ( 1 << TOIE4 );	
     468:	80 93 72 00 	sts	0x0072, r24	; 0x800072 <__TEXT_REGION_LENGTH__+0x700072>
     46c:	0c c0       	rjmp	.+24     	; 0x486 <_ZN6Timer49getPeriodEv+0x48>
	
	// Wait until measurement has been taken
	while ( period == 0U )
	{
		if ( timeroverflow > 10U )
     46e:	80 91 fc 02 	lds	r24, 0x02FC	; 0x8002fc <timeroverflow>
     472:	90 91 fd 02 	lds	r25, 0x02FD	; 0x8002fd <timeroverflow+0x1>
     476:	a0 91 fe 02 	lds	r26, 0x02FE	; 0x8002fe <timeroverflow+0x2>
     47a:	b0 91 ff 02 	lds	r27, 0x02FF	; 0x8002ff <timeroverflow+0x3>
     47e:	0b 97       	sbiw	r24, 0x0b	; 11
     480:	a1 05       	cpc	r26, r1
     482:	b1 05       	cpc	r27, r1
     484:	58 f4       	brcc	.+22     	; 0x49c <_ZN6Timer49getPeriodEv+0x5e>
	// Enable interrupt and clear pending
	TIFR4 = ( 1 << ICF4 ) | ( 1 << TOV4 );
	TIMSK4 = ( 1 << ICIE4 ) | ( 1 << TOIE4 );	
	
	// Wait until measurement has been taken
	while ( period == 0U )
     486:	80 91 fa 02 	lds	r24, 0x02FA	; 0x8002fa <__data_end>
     48a:	90 91 fb 02 	lds	r25, 0x02FB	; 0x8002fb <__data_end+0x1>
     48e:	89 2b       	or	r24, r25
     490:	71 f3       	breq	.-36     	; 0x46e <_ZN6Timer49getPeriodEv+0x30>
			TIFR4 = ( 1 << ICF4 ) | ( 1 << TOV4 );
			break;
		}
	}
	
	return period;
     492:	80 91 fa 02 	lds	r24, 0x02FA	; 0x8002fa <__data_end>
     496:	90 91 fb 02 	lds	r25, 0x02FB	; 0x8002fb <__data_end+0x1>
}
     49a:	08 95       	ret
	while ( period == 0U )
	{
		if ( timeroverflow > 10U )
		{
			// Error - Disable interrupt and clear pending
			TIMSK4 = 0U;
     49c:	10 92 72 00 	sts	0x0072, r1	; 0x800072 <__TEXT_REGION_LENGTH__+0x700072>
			TIFR4 = ( 1 << ICF4 ) | ( 1 << TOV4 );
     4a0:	81 e2       	ldi	r24, 0x21	; 33
     4a2:	89 bb       	out	0x19, r24	; 25
			break;
		}
	}
	
	return period;
     4a4:	80 91 fa 02 	lds	r24, 0x02FA	; 0x8002fa <__data_end>
     4a8:	90 91 fb 02 	lds	r25, 0x02FB	; 0x8002fb <__data_end+0x1>
}
     4ac:	08 95       	ret

000004ae <__vector_45>:

ISR(TIMER4_OVF_vect)
{
     4ae:	1f 92       	push	r1
     4b0:	0f 92       	push	r0
     4b2:	0f b6       	in	r0, 0x3f	; 63
     4b4:	0f 92       	push	r0
     4b6:	11 24       	eor	r1, r1
     4b8:	8f 93       	push	r24
     4ba:	9f 93       	push	r25
     4bc:	af 93       	push	r26
     4be:	bf 93       	push	r27
	timeroverflow++;
     4c0:	80 91 fc 02 	lds	r24, 0x02FC	; 0x8002fc <timeroverflow>
     4c4:	90 91 fd 02 	lds	r25, 0x02FD	; 0x8002fd <timeroverflow+0x1>
     4c8:	a0 91 fe 02 	lds	r26, 0x02FE	; 0x8002fe <timeroverflow+0x2>
     4cc:	b0 91 ff 02 	lds	r27, 0x02FF	; 0x8002ff <timeroverflow+0x3>
     4d0:	01 96       	adiw	r24, 0x01	; 1
     4d2:	a1 1d       	adc	r26, r1
     4d4:	b1 1d       	adc	r27, r1
     4d6:	80 93 fc 02 	sts	0x02FC, r24	; 0x8002fc <timeroverflow>
     4da:	90 93 fd 02 	sts	0x02FD, r25	; 0x8002fd <timeroverflow+0x1>
     4de:	a0 93 fe 02 	sts	0x02FE, r26	; 0x8002fe <timeroverflow+0x2>
     4e2:	b0 93 ff 02 	sts	0x02FF, r27	; 0x8002ff <timeroverflow+0x3>
}
     4e6:	bf 91       	pop	r27
     4e8:	af 91       	pop	r26
     4ea:	9f 91       	pop	r25
     4ec:	8f 91       	pop	r24
     4ee:	0f 90       	pop	r0
     4f0:	0f be       	out	0x3f, r0	; 63
     4f2:	0f 90       	pop	r0
     4f4:	1f 90       	pop	r1
     4f6:	18 95       	reti

000004f8 <__vector_41>:

ISR(TIMER4_CAPT_vect)
{
     4f8:	1f 92       	push	r1
     4fa:	0f 92       	push	r0
     4fc:	0f b6       	in	r0, 0x3f	; 63
     4fe:	0f 92       	push	r0
     500:	11 24       	eor	r1, r1
     502:	0b b6       	in	r0, 0x3b	; 59
     504:	0f 92       	push	r0
     506:	cf 92       	push	r12
     508:	df 92       	push	r13
     50a:	ef 92       	push	r14
     50c:	ff 92       	push	r15
     50e:	0f 93       	push	r16
     510:	1f 93       	push	r17
     512:	2f 93       	push	r18
     514:	3f 93       	push	r19
     516:	4f 93       	push	r20
     518:	5f 93       	push	r21
     51a:	6f 93       	push	r22
     51c:	7f 93       	push	r23
     51e:	8f 93       	push	r24
     520:	9f 93       	push	r25
     522:	af 93       	push	r26
     524:	bf 93       	push	r27
     526:	ef 93       	push	r30
     528:	ff 93       	push	r31
	// Read value of timer
	uint16_t readValue = ICR4;
     52a:	60 91 a6 00 	lds	r22, 0x00A6	; 0x8000a6 <__TEXT_REGION_LENGTH__+0x7000a6>
     52e:	70 91 a7 00 	lds	r23, 0x00A7	; 0x8000a7 <__TEXT_REGION_LENGTH__+0x7000a7>

	if ( first == true )
     532:	80 91 0a 02 	lds	r24, 0x020A	; 0x80020a <first>
     536:	81 11       	cpse	r24, r1
     538:	9b c0       	rjmp	.+310    	; 0x670 <__vector_41+0x178>
		first = false;
		return;
	}
	
	// Check if overflow is pending
	if ( TIFR4 & ( 1 << TOV4 ))
     53a:	c8 9b       	sbis	0x19, 0	; 25
     53c:	13 c0       	rjmp	.+38     	; 0x564 <__vector_41+0x6c>
	{
		timeroverflow++;
     53e:	80 91 fc 02 	lds	r24, 0x02FC	; 0x8002fc <timeroverflow>
     542:	90 91 fd 02 	lds	r25, 0x02FD	; 0x8002fd <timeroverflow+0x1>
     546:	a0 91 fe 02 	lds	r26, 0x02FE	; 0x8002fe <timeroverflow+0x2>
     54a:	b0 91 ff 02 	lds	r27, 0x02FF	; 0x8002ff <timeroverflow+0x3>
     54e:	01 96       	adiw	r24, 0x01	; 1
     550:	a1 1d       	adc	r26, r1
     552:	b1 1d       	adc	r27, r1
     554:	80 93 fc 02 	sts	0x02FC, r24	; 0x8002fc <timeroverflow>
     558:	90 93 fd 02 	sts	0x02FD, r25	; 0x8002fd <timeroverflow+0x1>
     55c:	a0 93 fe 02 	sts	0x02FE, r26	; 0x8002fe <timeroverflow+0x2>
     560:	b0 93 ff 02 	sts	0x02FF, r27	; 0x8002ff <timeroverflow+0x3>
	}
		
	// Disable interrupt and clear pending
	TIMSK4 = 0U;	
     564:	10 92 72 00 	sts	0x0072, r1	; 0x800072 <__TEXT_REGION_LENGTH__+0x700072>
	TIFR4 = ( 1 << ICF4 ) | ( 1 << TOV4 );		
     568:	81 e2       	ldi	r24, 0x21	; 33
     56a:	89 bb       	out	0x19, r24	; 25
			
	// Calculate difference
	uint32_t diff = 0U;

	if ( readValue < oldValue )
     56c:	80 91 00 03 	lds	r24, 0x0300	; 0x800300 <oldValue>
     570:	90 91 01 03 	lds	r25, 0x0301	; 0x800301 <oldValue+0x1>
     574:	68 17       	cp	r22, r24
     576:	79 07       	cpc	r23, r25
     578:	08 f4       	brcc	.+2      	; 0x57c <__vector_41+0x84>
     57a:	4f c0       	rjmp	.+158    	; 0x61a <__vector_41+0x122>
		}
		diff = ( 0xFFFF - oldValue ) + readValue;
	}
	else
	{
		diff = readValue - oldValue;
     57c:	80 91 00 03 	lds	r24, 0x0300	; 0x800300 <oldValue>
     580:	90 91 01 03 	lds	r25, 0x0301	; 0x800301 <oldValue+0x1>
     584:	68 1b       	sub	r22, r24
     586:	79 0b       	sbc	r23, r25
     588:	cb 01       	movw	r24, r22
     58a:	a0 e0       	ldi	r26, 0x00	; 0
     58c:	b0 e0       	ldi	r27, 0x00	; 0
	}
	
	// Add timeroverflow to total diff
	diff += timeroverflow << 16U;
     58e:	40 91 fc 02 	lds	r20, 0x02FC	; 0x8002fc <timeroverflow>
     592:	50 91 fd 02 	lds	r21, 0x02FD	; 0x8002fd <timeroverflow+0x1>
     596:	60 91 fe 02 	lds	r22, 0x02FE	; 0x8002fe <timeroverflow+0x2>
     59a:	70 91 ff 02 	lds	r23, 0x02FF	; 0x8002ff <timeroverflow+0x3>
	
	// Calculate period
	period = diff * tick * 1000000;
     59e:	c0 90 06 02 	lds	r12, 0x0206	; 0x800206 <tick>
     5a2:	d0 90 07 02 	lds	r13, 0x0207	; 0x800207 <tick+0x1>
     5a6:	e0 90 08 02 	lds	r14, 0x0208	; 0x800208 <tick+0x2>
     5aa:	f0 90 09 02 	lds	r15, 0x0209	; 0x800209 <tick+0x3>
     5ae:	ba 01       	movw	r22, r20
     5b0:	55 27       	eor	r21, r21
     5b2:	44 27       	eor	r20, r20
     5b4:	8a 01       	movw	r16, r20
     5b6:	9b 01       	movw	r18, r22
     5b8:	08 0f       	add	r16, r24
     5ba:	19 1f       	adc	r17, r25
     5bc:	2a 1f       	adc	r18, r26
     5be:	3b 1f       	adc	r19, r27
     5c0:	c9 01       	movw	r24, r18
     5c2:	b8 01       	movw	r22, r16
     5c4:	0e 94 d5 1c 	call	0x39aa	; 0x39aa <__floatunsisf>
     5c8:	a7 01       	movw	r20, r14
     5ca:	96 01       	movw	r18, r12
     5cc:	0e 94 8b 1d 	call	0x3b16	; 0x3b16 <__mulsf3>
     5d0:	20 e0       	ldi	r18, 0x00	; 0
     5d2:	34 e2       	ldi	r19, 0x24	; 36
     5d4:	44 e7       	ldi	r20, 0x74	; 116
     5d6:	59 e4       	ldi	r21, 0x49	; 73
     5d8:	0e 94 8b 1d 	call	0x3b16	; 0x3b16 <__mulsf3>
     5dc:	0e 94 a9 1c 	call	0x3952	; 0x3952 <__fixunssfsi>
     5e0:	70 93 fb 02 	sts	0x02FB, r23	; 0x8002fb <__data_end+0x1>
     5e4:	60 93 fa 02 	sts	0x02FA, r22	; 0x8002fa <__data_end>
     5e8:	ff 91       	pop	r31
     5ea:	ef 91       	pop	r30
     5ec:	bf 91       	pop	r27
     5ee:	af 91       	pop	r26
     5f0:	9f 91       	pop	r25
     5f2:	8f 91       	pop	r24
     5f4:	7f 91       	pop	r23
     5f6:	6f 91       	pop	r22
     5f8:	5f 91       	pop	r21
     5fa:	4f 91       	pop	r20
     5fc:	3f 91       	pop	r19
     5fe:	2f 91       	pop	r18
     600:	1f 91       	pop	r17
     602:	0f 91       	pop	r16
     604:	ff 90       	pop	r15
     606:	ef 90       	pop	r14
     608:	df 90       	pop	r13
     60a:	cf 90       	pop	r12
     60c:	0f 90       	pop	r0
     60e:	0b be       	out	0x3b, r0	; 59
     610:	0f 90       	pop	r0
     612:	0f be       	out	0x3f, r0	; 63
     614:	0f 90       	pop	r0
     616:	1f 90       	pop	r1
     618:	18 95       	reti
	// Calculate difference
	uint32_t diff = 0U;

	if ( readValue < oldValue )
	{
		if ( timeroverflow != 0 )
     61a:	80 91 fc 02 	lds	r24, 0x02FC	; 0x8002fc <timeroverflow>
     61e:	90 91 fd 02 	lds	r25, 0x02FD	; 0x8002fd <timeroverflow+0x1>
     622:	a0 91 fe 02 	lds	r26, 0x02FE	; 0x8002fe <timeroverflow+0x2>
     626:	b0 91 ff 02 	lds	r27, 0x02FF	; 0x8002ff <timeroverflow+0x3>
     62a:	89 2b       	or	r24, r25
     62c:	8a 2b       	or	r24, r26
     62e:	8b 2b       	or	r24, r27
     630:	99 f0       	breq	.+38     	; 0x658 <__vector_41+0x160>
		{
			timeroverflow--;
     632:	80 91 fc 02 	lds	r24, 0x02FC	; 0x8002fc <timeroverflow>
     636:	90 91 fd 02 	lds	r25, 0x02FD	; 0x8002fd <timeroverflow+0x1>
     63a:	a0 91 fe 02 	lds	r26, 0x02FE	; 0x8002fe <timeroverflow+0x2>
     63e:	b0 91 ff 02 	lds	r27, 0x02FF	; 0x8002ff <timeroverflow+0x3>
     642:	01 97       	sbiw	r24, 0x01	; 1
     644:	a1 09       	sbc	r26, r1
     646:	b1 09       	sbc	r27, r1
     648:	80 93 fc 02 	sts	0x02FC, r24	; 0x8002fc <timeroverflow>
     64c:	90 93 fd 02 	sts	0x02FD, r25	; 0x8002fd <timeroverflow+0x1>
     650:	a0 93 fe 02 	sts	0x02FE, r26	; 0x8002fe <timeroverflow+0x2>
     654:	b0 93 ff 02 	sts	0x02FF, r27	; 0x8002ff <timeroverflow+0x3>
		}
		diff = ( 0xFFFF - oldValue ) + readValue;
     658:	80 91 00 03 	lds	r24, 0x0300	; 0x800300 <oldValue>
     65c:	90 91 01 03 	lds	r25, 0x0301	; 0x800301 <oldValue+0x1>
     660:	61 50       	subi	r22, 0x01	; 1
     662:	71 09       	sbc	r23, r1
     664:	68 1b       	sub	r22, r24
     666:	79 0b       	sbc	r23, r25
     668:	cb 01       	movw	r24, r22
     66a:	a0 e0       	ldi	r26, 0x00	; 0
     66c:	b0 e0       	ldi	r27, 0x00	; 0
     66e:	8f cf       	rjmp	.-226    	; 0x58e <__vector_41+0x96>
	// Read value of timer
	uint16_t readValue = ICR4;

	if ( first == true )
	{
		timeroverflow = 0U;
     670:	10 92 fc 02 	sts	0x02FC, r1	; 0x8002fc <timeroverflow>
     674:	10 92 fd 02 	sts	0x02FD, r1	; 0x8002fd <timeroverflow+0x1>
     678:	10 92 fe 02 	sts	0x02FE, r1	; 0x8002fe <timeroverflow+0x2>
     67c:	10 92 ff 02 	sts	0x02FF, r1	; 0x8002ff <timeroverflow+0x3>
		oldValue = readValue;
     680:	70 93 01 03 	sts	0x0301, r23	; 0x800301 <oldValue+0x1>
     684:	60 93 00 03 	sts	0x0300, r22	; 0x800300 <oldValue>
		first = false;
     688:	10 92 0a 02 	sts	0x020A, r1	; 0x80020a <first>
		return;
     68c:	ad cf       	rjmp	.-166    	; 0x5e8 <__vector_41+0xf0>

0000068e <_ZN6KeyPadC1Ev>:
/* RTOS include */
#include "FreeRTOS.h"
#include "task.h"
#include "portmacro.h"

 KeyPad::KeyPad()
     68e:	08 95       	ret

00000690 <_ZN6KeyPadD1Ev>:
{
}

KeyPad::~KeyPad()
     690:	08 95       	ret

00000692 <_ZN6KeyPad12readKeyboardEv>:
{
}

char KeyPad::readKeyboard(){
     692:	cf 93       	push	r28
	
	uint8_t read_byte = 0; // Bytes to contain pressed char
	DDRK = 0b11110000; // Configure for Columns to be output and row to be input
     694:	80 ef       	ldi	r24, 0xF0	; 240
     696:	80 93 07 01 	sts	0x0107, r24	; 0x800107 <__TEXT_REGION_LENGTH__+0x700107>
	PORTK = 0b11110000; // Set Columns output to be high!
     69a:	80 93 08 01 	sts	0x0108, r24	; 0x800108 <__TEXT_REGION_LENGTH__+0x700108>
	
	vTaskDelay(8/portTICK_RATE_MS);	// Delays for allowing Pins to switch state from input to output and reverse
     69e:	88 e0       	ldi	r24, 0x08	; 8
     6a0:	90 e0       	ldi	r25, 0x00	; 0
     6a2:	0e 94 ac 12 	call	0x2558	; 0x2558 <vTaskDelay>
	
	while( (PINK & 0b00001111) == 0 );	// Wait for key pressed
     6a6:	80 91 06 01 	lds	r24, 0x0106	; 0x800106 <__TEXT_REGION_LENGTH__+0x700106>
     6aa:	8f 70       	andi	r24, 0x0F	; 15
     6ac:	e1 f3       	breq	.-8      	; 0x6a6 <_ZN6KeyPad12readKeyboardEv+0x14>
	
	read_byte = (PINK & 0b00001111); // Get row of pressed key
     6ae:	c0 91 06 01 	lds	r28, 0x0106	; 0x800106 <__TEXT_REGION_LENGTH__+0x700106>
	
	DDRK = 0b00001111; // Switch Columns to be input and row to be output
     6b2:	8f e0       	ldi	r24, 0x0F	; 15
     6b4:	80 93 07 01 	sts	0x0107, r24	; 0x800107 <__TEXT_REGION_LENGTH__+0x700107>
	PORTK = 0b00001111; // Set Row outputs to be high!
     6b8:	80 93 08 01 	sts	0x0108, r24	; 0x800108 <__TEXT_REGION_LENGTH__+0x700108>
	
	vTaskDelay(8/portTICK_RATE_MS);
     6bc:	88 e0       	ldi	r24, 0x08	; 8
     6be:	90 e0       	ldi	r25, 0x00	; 0
     6c0:	0e 94 ac 12 	call	0x2558	; 0x2558 <vTaskDelay>
	
	char pressed_key = findKey(read_byte | (PINK & 0b11110000));
     6c4:	e0 91 06 01 	lds	r30, 0x0106	; 0x800106 <__TEXT_REGION_LENGTH__+0x700106>
     6c8:	e0 7f       	andi	r30, 0xF0	; 240
     6ca:	cf 70       	andi	r28, 0x0F	; 15
     6cc:	ec 2b       	or	r30, r28
     6ce:	e1 51       	subi	r30, 0x11	; 17
     6d0:	e8 37       	cpi	r30, 0x78	; 120
     6d2:	38 f0       	brcs	.+14     	; 0x6e2 <_ZN6KeyPad12readKeyboardEv+0x50>
     6d4:	85 e4       	ldi	r24, 0x45	; 69

	// Wait for no key pressed anymore
	while((PINK & 0b11110000) != 0);
     6d6:	90 91 06 01 	lds	r25, 0x0106	; 0x800106 <__TEXT_REGION_LENGTH__+0x700106>
     6da:	90 7f       	andi	r25, 0xF0	; 240
     6dc:	e1 f7       	brne	.-8      	; 0x6d6 <_ZN6KeyPad12readKeyboardEv+0x44>
	//SendString("pressed key:\r\n");
	//SendInteger(pressed_key);
	//SendString("\r\n");
	return pressed_key;
}
     6de:	cf 91       	pop	r28
     6e0:	08 95       	ret
     6e2:	f0 e0       	ldi	r31, 0x00	; 0
     6e4:	e2 5f       	subi	r30, 0xF2	; 242
     6e6:	fd 4f       	sbci	r31, 0xFD	; 253
     6e8:	80 81       	ld	r24, Z
     6ea:	f5 cf       	rjmp	.-22     	; 0x6d6 <_ZN6KeyPad12readKeyboardEv+0x44>

000006ec <_ZN14LoginInterfaceC1Ev>:
#include <stdlib.h>
#include <avr/io.h>
#include "KeyPad.h"
#include "LoginInterface.h"

 LoginInterface::LoginInterface()
     6ec:	0f 93       	push	r16
     6ee:	1f 93       	push	r17
     6f0:	cf 93       	push	r28
     6f2:	df 93       	push	r29
     6f4:	1f 92       	push	r1
     6f6:	cd b7       	in	r28, 0x3d	; 61
     6f8:	de b7       	in	r29, 0x3e	; 62
     6fa:	8c 01       	movw	r16, r24
     6fc:	c8 df       	rcall	.-112    	; 0x68e <_ZN6KeyPadC1Ev>
 {
	 keypad = KeyPad();
     6fe:	ce 01       	movw	r24, r28
     700:	01 96       	adiw	r24, 0x01	; 1
     702:	c5 df       	rcall	.-118    	; 0x68e <_ZN6KeyPadC1Ev>
     704:	ce 01       	movw	r24, r28
     706:	01 96       	adiw	r24, 0x01	; 1
     708:	c3 df       	rcall	.-122    	; 0x690 <_ZN6KeyPadD1Ev>
	 // ASCII Used since static declaration is not supported before STD c++ 11
	 passWord[0] = 49; // 1
     70a:	81 e3       	ldi	r24, 0x31	; 49
     70c:	f8 01       	movw	r30, r16
     70e:	81 83       	std	Z+1, r24	; 0x01
	 passWord[1] = 52; // 4
     710:	84 e3       	ldi	r24, 0x34	; 52
     712:	82 83       	std	Z+2, r24	; 0x02
	 passWord[2] = 55; // 7
     714:	87 e3       	ldi	r24, 0x37	; 55
     716:	83 83       	std	Z+3, r24	; 0x03
	 passWord[3] = 50; // 2
     718:	82 e3       	ldi	r24, 0x32	; 50
     71a:	84 83       	std	Z+4, r24	; 0x04
	 stateOfMachine = 'L';
     71c:	8c e4       	ldi	r24, 0x4C	; 76
     71e:	85 83       	std	Z+5, r24	; 0x05
 }
     720:	0f 90       	pop	r0
     722:	df 91       	pop	r29
     724:	cf 91       	pop	r28
     726:	1f 91       	pop	r17
     728:	0f 91       	pop	r16
     72a:	08 95       	ret

0000072c <_ZN14LoginInterfaceD1Ev>:
 
 LoginInterface::~LoginInterface()
     72c:	b1 cf       	rjmp	.-158    	; 0x690 <_ZN6KeyPadD1Ev>

0000072e <_ZN14LoginInterface10checkLoginEv>:
 {
 }
 
 void LoginInterface::checkLogin()
 {
     72e:	ef 92       	push	r14
     730:	ff 92       	push	r15
     732:	1f 93       	push	r17
     734:	cf 93       	push	r28
     736:	df 93       	push	r29
     738:	00 d0       	rcall	.+0      	; 0x73a <_ZN14LoginInterface10checkLoginEv+0xc>
     73a:	1f 92       	push	r1
     73c:	cd b7       	in	r28, 0x3d	; 61
     73e:	de b7       	in	r29, 0x3e	; 62
     740:	7c 01       	movw	r14, r24
	 uint8_t userPressed = 0;
     742:	10 e0       	ldi	r17, 0x00	; 0
     744:	01 c0       	rjmp	.+2      	; 0x748 <_ZN14LoginInterface10checkLoginEv+0x1a>
		 char buf = keypad.readKeyboard();
		 
		 // If star is pressed.. Reset Keys pressed
		 if (buf == 42)
		 {
			 userPressed = 0;
     746:	10 e0       	ldi	r17, 0x00	; 0
	 uint8_t userPressed = 0;
	 volatile uint8_t userPass[4];
	 
	 while(userPressed < 4)
	 {
		 char buf = keypad.readKeyboard();
     748:	c7 01       	movw	r24, r14
     74a:	a3 df       	rcall	.-186    	; 0x692 <_ZN6KeyPad12readKeyboardEv>
		 
		 // If star is pressed.. Reset Keys pressed
		 if (buf == 42)
     74c:	8a 32       	cpi	r24, 0x2A	; 42
     74e:	d9 f3       	breq	.-10     	; 0x746 <_ZN14LoginInterface10checkLoginEv+0x18>
		 {
			 userPressed = 0;
		 }else
		 {
			 // Put key pressed into array
			 userPass[userPressed] = buf;
     750:	e1 e0       	ldi	r30, 0x01	; 1
     752:	f0 e0       	ldi	r31, 0x00	; 0
     754:	ec 0f       	add	r30, r28
     756:	fd 1f       	adc	r31, r29
     758:	e1 0f       	add	r30, r17
     75a:	f1 1d       	adc	r31, r1
     75c:	80 83       	st	Z, r24
			 userPressed++; 
     75e:	1f 5f       	subi	r17, 0xFF	; 255
 void LoginInterface::checkLogin()
 {
	 uint8_t userPressed = 0;
	 volatile uint8_t userPass[4];
	 
	 while(userPressed < 4)
     760:	14 30       	cpi	r17, 0x04	; 4
     762:	91 f7       	brne	.-28     	; 0x748 <_ZN14LoginInterface10checkLoginEv+0x1a>
	 
	 bool all_okay = true;
	 // Check each of the entries in array if they match password
	 for (uint8_t i = 0; i < 4; i++)
	 {
		 if (userPass[i] != passWord[i])
     764:	99 81       	ldd	r25, Y+1	; 0x01
     766:	f7 01       	movw	r30, r14
     768:	81 81       	ldd	r24, Z+1	; 0x01
     76a:	98 17       	cp	r25, r24
     76c:	19 f1       	breq	.+70     	; 0x7b4 <_ZN14LoginInterface10checkLoginEv+0x86>
	 switch(state){
		 case 'U':
			stateOfMachine = 'U';
			break;
		 case 'L':
			stateOfMachine = 'L';
     76e:	8c e4       	ldi	r24, 0x4C	; 76
     770:	85 83       	std	Z+5, r24	; 0x05
	 for (uint8_t i = 0; i < 4; i++)
	 {
		 if (userPass[i] != passWord[i])
		 {
			 setstateOfMachine('L');
			 all_okay = false;
     772:	80 e0       	ldi	r24, 0x00	; 0
	 
	 bool all_okay = true;
	 // Check each of the entries in array if they match password
	 for (uint8_t i = 0; i < 4; i++)
	 {
		 if (userPass[i] != passWord[i])
     774:	2a 81       	ldd	r18, Y+2	; 0x02
     776:	f7 01       	movw	r30, r14
     778:	92 81       	ldd	r25, Z+2	; 0x02
     77a:	29 17       	cp	r18, r25
     77c:	19 f0       	breq	.+6      	; 0x784 <_ZN14LoginInterface10checkLoginEv+0x56>
	 switch(state){
		 case 'U':
			stateOfMachine = 'U';
			break;
		 case 'L':
			stateOfMachine = 'L';
     77e:	8c e4       	ldi	r24, 0x4C	; 76
     780:	85 83       	std	Z+5, r24	; 0x05
	 for (uint8_t i = 0; i < 4; i++)
	 {
		 if (userPass[i] != passWord[i])
		 {
			 setstateOfMachine('L');
			 all_okay = false;
     782:	80 e0       	ldi	r24, 0x00	; 0
	 
	 bool all_okay = true;
	 // Check each of the entries in array if they match password
	 for (uint8_t i = 0; i < 4; i++)
	 {
		 if (userPass[i] != passWord[i])
     784:	2b 81       	ldd	r18, Y+3	; 0x03
     786:	f7 01       	movw	r30, r14
     788:	93 81       	ldd	r25, Z+3	; 0x03
     78a:	29 17       	cp	r18, r25
     78c:	a9 f0       	breq	.+42     	; 0x7b8 <_ZN14LoginInterface10checkLoginEv+0x8a>
	 switch(state){
		 case 'U':
			stateOfMachine = 'U';
			break;
		 case 'L':
			stateOfMachine = 'L';
     78e:	8c e4       	ldi	r24, 0x4C	; 76
     790:	85 83       	std	Z+5, r24	; 0x05
	 
	 bool all_okay = true;
	 // Check each of the entries in array if they match password
	 for (uint8_t i = 0; i < 4; i++)
	 {
		 if (userPass[i] != passWord[i])
     792:	8c 81       	ldd	r24, Y+4	; 0x04
     794:	94 81       	ldd	r25, Z+4	; 0x04
     796:	98 17       	cp	r25, r24
     798:	19 f0       	breq	.+6      	; 0x7a0 <_ZN14LoginInterface10checkLoginEv+0x72>
	 switch(state){
		 case 'U':
			stateOfMachine = 'U';
			break;
		 case 'L':
			stateOfMachine = 'L';
     79a:	8c e4       	ldi	r24, 0x4C	; 76
     79c:	f7 01       	movw	r30, r14
     79e:	85 83       	std	Z+5, r24	; 0x05
		 }else
		 {
			 setstateOfMachine('L');
		 }
	 }
 }
     7a0:	0f 90       	pop	r0
     7a2:	0f 90       	pop	r0
     7a4:	0f 90       	pop	r0
     7a6:	0f 90       	pop	r0
     7a8:	df 91       	pop	r29
     7aa:	cf 91       	pop	r28
     7ac:	1f 91       	pop	r17
     7ae:	ff 90       	pop	r15
     7b0:	ef 90       	pop	r14
     7b2:	08 95       	ret
	 
	 bool all_okay = true;
	 // Check each of the entries in array if they match password
	 for (uint8_t i = 0; i < 4; i++)
	 {
		 if (userPass[i] != passWord[i])
     7b4:	81 e0       	ldi	r24, 0x01	; 1
     7b6:	de cf       	rjmp	.-68     	; 0x774 <_ZN14LoginInterface10checkLoginEv+0x46>
     7b8:	2c 81       	ldd	r18, Y+4	; 0x04
     7ba:	f7 01       	movw	r30, r14
     7bc:	94 81       	ldd	r25, Z+4	; 0x04
     7be:	29 13       	cpse	r18, r25
     7c0:	ec cf       	rjmp	.-40     	; 0x79a <_ZN14LoginInterface10checkLoginEv+0x6c>
		 }
	 }
	 // If state is locked unlock it
	 // If state is unlocked lock it
	 
	 if (all_okay)
     7c2:	88 23       	and	r24, r24
     7c4:	69 f3       	breq	.-38     	; 0x7a0 <_ZN14LoginInterface10checkLoginEv+0x72>
	 {
		 if (getstateOfMachine() == 'L')
     7c6:	f7 01       	movw	r30, r14
     7c8:	85 81       	ldd	r24, Z+5	; 0x05
     7ca:	8c 34       	cpi	r24, 0x4C	; 76
     7cc:	31 f7       	brne	.-52     	; 0x79a <_ZN14LoginInterface10checkLoginEv+0x6c>
 void LoginInterface::setstateOfMachine(char state)
 {
	 
	 switch(state){
		 case 'U':
			stateOfMachine = 'U';
     7ce:	85 e5       	ldi	r24, 0x55	; 85
     7d0:	85 83       	std	Z+5, r24	; 0x05
     7d2:	e6 cf       	rjmp	.-52     	; 0x7a0 <_ZN14LoginInterface10checkLoginEv+0x72>

000007d4 <_ZN14LoginInterface17getstateOfMachineEv>:
 
 // Set and get Method for stateOfMachine
 char LoginInterface::getstateOfMachine()
 {
	 return stateOfMachine;
 }
     7d4:	fc 01       	movw	r30, r24
     7d6:	85 81       	ldd	r24, Z+5	; 0x05
     7d8:	08 95       	ret

000007da <_Z11LoginKeyPadPv>:
void * operator new(size_t size);
void operator delete(void * ptr);

int __cxa_guard_acquire(__guard *g) {return !*(char *)(g);};
void __cxa_guard_release (__guard *g) {*(char *)g = 1;};
void __cxa_guard_abort (__guard *) {};
     7da:	83 e0       	ldi	r24, 0x03	; 3
     7dc:	93 e0       	ldi	r25, 0x03	; 3
     7de:	a7 df       	rcall	.-178    	; 0x72e <_ZN14LoginInterface10checkLoginEv>
     7e0:	fc cf       	rjmp	.-8      	; 0x7da <_Z11LoginKeyPadPv>

000007e2 <_Z10DisplayArmPv>:
     7e2:	cf 93       	push	r28
     7e4:	df 93       	push	r29
     7e6:	cd b7       	in	r28, 0x3d	; 61
     7e8:	de b7       	in	r29, 0x3e	; 62
     7ea:	cb 57       	subi	r28, 0x7B	; 123
     7ec:	d1 09       	sbc	r29, r1
     7ee:	0f b6       	in	r0, 0x3f	; 63
     7f0:	f8 94       	cli
     7f2:	de bf       	out	0x3e, r29	; 62
     7f4:	0f be       	out	0x3f, r0	; 63
     7f6:	cd bf       	out	0x3d, r28	; 61
     7f8:	8c 01       	movw	r16, r24
     7fa:	62 e0       	ldi	r22, 0x02	; 2
     7fc:	ce 01       	movw	r24, r28
     7fe:	01 96       	adiw	r24, 0x01	; 1
     800:	d3 dc       	rcall	.-1626   	; 0x1a8 <_ZN11ColorSensorC1E16FrequencyScaling>
     802:	ce 01       	movw	r24, r28
     804:	84 5a       	subi	r24, 0xA4	; 164
     806:	9f 4f       	sbci	r25, 0xFF	; 255
     808:	0e 94 50 14 	call	0x28a0	; 0x28a0 <_ZN11TouchscreenC1Ev>
     80c:	ce 01       	movw	r24, r28
     80e:	84 5a       	subi	r24, 0xA4	; 164
     810:	9f 4f       	sbci	r25, 0xFF	; 255
     812:	0e 94 45 15 	call	0x2a8a	; 0x2a8a <_ZN11Touchscreen11clearScreenEv>
     816:	83 e0       	ldi	r24, 0x03	; 3
     818:	93 e0       	ldi	r25, 0x03	; 3
     81a:	dc df       	rcall	.-72     	; 0x7d4 <_ZN14LoginInterface17getstateOfMachineEv>
     81c:	85 35       	cpi	r24, 0x55	; 85
     81e:	b1 f7       	brne	.-20     	; 0x80c <_Z10DisplayArmPv+0x2a>
     820:	ce 01       	movw	r24, r28
     822:	84 5a       	subi	r24, 0xA4	; 164
     824:	9f 4f       	sbci	r25, 0xFF	; 255
     826:	0e 94 5a 15 	call	0x2ab4	; 0x2ab4 <_ZN11Touchscreen23presentButtonsOnDisplayEv>
     82a:	ce 01       	movw	r24, r28
     82c:	84 5a       	subi	r24, 0xA4	; 164
     82e:	9f 4f       	sbci	r25, 0xFF	; 255
     830:	0e 94 bd 14 	call	0x297a	; 0x297a <_ZN11Touchscreen12checkButtonsEv>
     834:	81 30       	cpi	r24, 0x01	; 1
     836:	81 f0       	breq	.+32     	; 0x858 <_Z10DisplayArmPv+0x76>
     838:	82 30       	cpi	r24, 0x02	; 2
     83a:	69 f7       	brne	.-38     	; 0x816 <_Z10DisplayArmPv+0x34>
     83c:	ce 01       	movw	r24, r28
     83e:	01 96       	adiw	r24, 0x01	; 1
     840:	00 dd       	rcall	.-1536   	; 0x242 <_ZN11ColorSensor8getColorEv>
     842:	8f 3f       	cpi	r24, 0xFF	; 255
     844:	a1 f0       	breq	.+40     	; 0x86e <_Z10DisplayArmPv+0x8c>
     846:	68 2f       	mov	r22, r24
     848:	c8 01       	movw	r24, r16
     84a:	cc d3       	rcall	.+1944   	; 0xfe4 <_ZN8Robotarm8MoveItemEh>
     84c:	83 e0       	ldi	r24, 0x03	; 3
     84e:	93 e0       	ldi	r25, 0x03	; 3
     850:	c1 df       	rcall	.-126    	; 0x7d4 <_ZN14LoginInterface17getstateOfMachineEv>
     852:	85 35       	cpi	r24, 0x55	; 85
     854:	29 f3       	breq	.-54     	; 0x820 <_Z10DisplayArmPv+0x3e>
     856:	da cf       	rjmp	.-76     	; 0x80c <_Z10DisplayArmPv+0x2a>
     858:	60 91 02 03 	lds	r22, 0x0302	; 0x800302 <colorIndex>
     85c:	ce 01       	movw	r24, r28
     85e:	01 96       	adiw	r24, 0x01	; 1
     860:	72 dd       	rcall	.-1308   	; 0x346 <_ZN11ColorSensor17addCalibrateColorEh>
     862:	80 91 02 03 	lds	r24, 0x0302	; 0x800302 <colorIndex>
     866:	8f 5f       	subi	r24, 0xFF	; 255
     868:	80 93 02 03 	sts	0x0302, r24	; 0x800302 <colorIndex>
     86c:	d4 cf       	rjmp	.-88     	; 0x816 <_Z10DisplayArmPv+0x34>
     86e:	ce 01       	movw	r24, r28
     870:	84 5a       	subi	r24, 0xA4	; 164
     872:	9f 4f       	sbci	r25, 0xFF	; 255
     874:	0e 94 7e 15 	call	0x2afc	; 0x2afc <_ZN11Touchscreen17flashRedOnDisplayEv>
     878:	88 ec       	ldi	r24, 0xC8	; 200
     87a:	90 e0       	ldi	r25, 0x00	; 0
     87c:	0e 94 ac 12 	call	0x2558	; 0x2558 <vTaskDelay>
     880:	ce 01       	movw	r24, r28
     882:	84 5a       	subi	r24, 0xA4	; 164
     884:	9f 4f       	sbci	r25, 0xFF	; 255
     886:	0e 94 5a 15 	call	0x2ab4	; 0x2ab4 <_ZN11Touchscreen23presentButtonsOnDisplayEv>
     88a:	88 ec       	ldi	r24, 0xC8	; 200
     88c:	90 e0       	ldi	r25, 0x00	; 0
     88e:	0e 94 ac 12 	call	0x2558	; 0x2558 <vTaskDelay>
     892:	ce 01       	movw	r24, r28
     894:	84 5a       	subi	r24, 0xA4	; 164
     896:	9f 4f       	sbci	r25, 0xFF	; 255
     898:	0e 94 7e 15 	call	0x2afc	; 0x2afc <_ZN11Touchscreen17flashRedOnDisplayEv>
     89c:	88 ec       	ldi	r24, 0xC8	; 200
     89e:	90 e0       	ldi	r25, 0x00	; 0
     8a0:	0e 94 ac 12 	call	0x2558	; 0x2558 <vTaskDelay>
     8a4:	ce 01       	movw	r24, r28
     8a6:	84 5a       	subi	r24, 0xA4	; 164
     8a8:	9f 4f       	sbci	r25, 0xFF	; 255
     8aa:	0e 94 5a 15 	call	0x2ab4	; 0x2ab4 <_ZN11Touchscreen23presentButtonsOnDisplayEv>
     8ae:	b3 cf       	rjmp	.-154    	; 0x816 <_Z10DisplayArmPv+0x34>

000008b0 <_Znwj>:

void * operator new(size_t size)
{
	return malloc(size);
     8b0:	0c 94 27 1e 	jmp	0x3c4e	; 0x3c4e <malloc>

000008b4 <_ZdlPv>:
}

void operator delete(void * ptr)
{
	ptr != NULL ? free(ptr) : void(0);
     8b4:	00 97       	sbiw	r24, 0x00	; 0
     8b6:	11 f0       	breq	.+4      	; 0x8bc <_ZdlPv+0x8>
     8b8:	0c 94 bf 1e 	jmp	0x3d7e	; 0x3d7e <free>
     8bc:	08 95       	ret

000008be <main>:
		}
	}
}

int main(void)
{		
     8be:	cf 93       	push	r28
     8c0:	df 93       	push	r29
     8c2:	cd b7       	in	r28, 0x3d	; 61
     8c4:	de b7       	in	r29, 0x3e	; 62
     8c6:	2e 97       	sbiw	r28, 0x0e	; 14
     8c8:	0f b6       	in	r0, 0x3f	; 63
     8ca:	f8 94       	cli
     8cc:	de bf       	out	0x3e, r29	; 62
     8ce:	0f be       	out	0x3f, r0	; 63
     8d0:	cd bf       	out	0x3d, r28	; 61
	Robotarm arm = Robotarm();
     8d2:	ce 01       	movw	r24, r28
     8d4:	01 96       	adiw	r24, 0x01	; 1
     8d6:	61 d0       	rcall	.+194    	; 0x99a <_ZN8RobotarmC1Ev>
	InitUART(9600,8,'N');
     8d8:	2e e4       	ldi	r18, 0x4E	; 78
     8da:	48 e0       	ldi	r20, 0x08	; 8
     8dc:	60 e8       	ldi	r22, 0x80	; 128
     8de:	75 e2       	ldi	r23, 0x25	; 37
     8e0:	80 e0       	ldi	r24, 0x00	; 0
     8e2:	90 e0       	ldi	r25, 0x00	; 0
     8e4:	0e 94 8c 1b 	call	0x3718	; 0x3718 <_Z8InitUARTmhc>
	xTaskCreate(LoginKeyPad,  ( signed char * ) "Keypad Task", configMAIN_STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL);
     8e8:	a1 2c       	mov	r10, r1
     8ea:	b1 2c       	mov	r11, r1
     8ec:	c1 2c       	mov	r12, r1
     8ee:	d1 2c       	mov	r13, r1
     8f0:	e1 2c       	mov	r14, r1
     8f2:	f1 2c       	mov	r15, r1
     8f4:	00 e0       	ldi	r16, 0x00	; 0
     8f6:	20 e0       	ldi	r18, 0x00	; 0
     8f8:	30 e0       	ldi	r19, 0x00	; 0
     8fa:	48 e5       	ldi	r20, 0x58	; 88
     8fc:	52 e0       	ldi	r21, 0x02	; 2
     8fe:	66 e8       	ldi	r22, 0x86	; 134
     900:	72 e0       	ldi	r23, 0x02	; 2
     902:	8d ee       	ldi	r24, 0xED	; 237
     904:	93 e0       	ldi	r25, 0x03	; 3
     906:	0e 94 ad 10 	call	0x215a	; 0x215a <xTaskGenericCreate>
	xTaskCreate(DisplayArm,  ( signed char * ) "Display + Arm Task", configMAIN_STACK_SIZE, &arm, tskIDLE_PRIORITY, NULL);
     90a:	9e 01       	movw	r18, r28
     90c:	2f 5f       	subi	r18, 0xFF	; 255
     90e:	3f 4f       	sbci	r19, 0xFF	; 255
     910:	48 e5       	ldi	r20, 0x58	; 88
     912:	52 e0       	ldi	r21, 0x02	; 2
     914:	62 e9       	ldi	r22, 0x92	; 146
     916:	72 e0       	ldi	r23, 0x02	; 2
     918:	81 ef       	ldi	r24, 0xF1	; 241
     91a:	93 e0       	ldi	r25, 0x03	; 3
     91c:	0e 94 ad 10 	call	0x215a	; 0x215a <xTaskGenericCreate>
	vTaskStartScheduler();
     920:	0e 94 65 11 	call	0x22ca	; 0x22ca <vTaskStartScheduler>
     924:	ff cf       	rjmp	.-2      	; 0x924 <main+0x66>

00000926 <_GLOBAL__sub_I___cxa_pure_virtual>:

/* This file is needed to be able to use new and delete operators */
#include "CPlusPlusSpecific.h"

/* Create shared objects */
LoginInterface Login = LoginInterface();
     926:	83 e0       	ldi	r24, 0x03	; 3
     928:	93 e0       	ldi	r25, 0x03	; 3
     92a:	e0 ce       	rjmp	.-576    	; 0x6ec <_ZN14LoginInterfaceC1Ev>

0000092c <_GLOBAL__sub_D___cxa_pure_virtual>:
     92c:	83 e0       	ldi	r24, 0x03	; 3
     92e:	93 e0       	ldi	r25, 0x03	; 3
     930:	fd ce       	rjmp	.-518    	; 0x72c <_ZN14LoginInterfaceD1Ev>

00000932 <_ZN5Motor10SetDegreesEh>:
	*	 can be used to turn motor at a specific speed set by \ref delay. C
	*	 Note that this function needs to run multiple times to work as intended.
	*    @param uint8_t	degrees to turn
	*    @return void Nothing
	*/
	virtual void SetDegrees( uint8_t degrees )
     932:	cf 93       	push	r28
     934:	df 93       	push	r29
	{
		if ( maxDegrees_ >= degrees )
     936:	fc 01       	movw	r30, r24
     938:	26 89       	ldd	r18, Z+22	; 0x16
     93a:	26 17       	cp	r18, r22
     93c:	b0 f0       	brcs	.+44     	; 0x96a <_ZN5Motor10SetDegreesEh+0x38>
     93e:	ec 01       	movw	r28, r24
		{
			percent_ = percentPrDeg * degrees + startpercent_;
     940:	70 e0       	ldi	r23, 0x00	; 0
     942:	80 e0       	ldi	r24, 0x00	; 0
     944:	90 e0       	ldi	r25, 0x00	; 0
     946:	0e 94 d7 1c 	call	0x39ae	; 0x39ae <__floatsisf>
     94a:	2e 81       	ldd	r18, Y+6	; 0x06
     94c:	3f 81       	ldd	r19, Y+7	; 0x07
     94e:	48 85       	ldd	r20, Y+8	; 0x08
     950:	59 85       	ldd	r21, Y+9	; 0x09
     952:	0e 94 8b 1d 	call	0x3b16	; 0x3b16 <__mulsf3>
     956:	2a 89       	ldd	r18, Y+18	; 0x12
     958:	3b 89       	ldd	r19, Y+19	; 0x13
     95a:	4c 89       	ldd	r20, Y+20	; 0x14
     95c:	5d 89       	ldd	r21, Y+21	; 0x15
     95e:	0e 94 d9 1b 	call	0x37b2	; 0x37b2 <__addsf3>
     962:	6a 87       	std	Y+10, r22	; 0x0a
     964:	7b 87       	std	Y+11, r23	; 0x0b
     966:	8c 87       	std	Y+12, r24	; 0x0c
     968:	9d 87       	std	Y+13, r25	; 0x0d
		}
	}
     96a:	df 91       	pop	r29
     96c:	cf 91       	pop	r28
     96e:	08 95       	ret

00000970 <_ZN8Robotarm14startMotorImplEPv>:
{
	vTaskDelay( 1500 / portTICK_RATE_MS );
	motors_[1]->SetDegrees(35);
	motors_[2]->SetDegrees(40);
	vTaskDelay( 1500 / portTICK_RATE_MS );
	motors_[5]->SetDegrees(0);
     970:	8c 01       	movw	r16, r24
     972:	0e 5f       	subi	r16, 0xFE	; 254
     974:	1f 4f       	sbci	r17, 0xFF	; 255
     976:	9c 01       	movw	r18, r24
     978:	22 5f       	subi	r18, 0xF2	; 242
     97a:	3f 4f       	sbci	r19, 0xFF	; 255
     97c:	79 01       	movw	r14, r18
     97e:	e8 01       	movw	r28, r16
     980:	89 91       	ld	r24, Y+
     982:	99 91       	ld	r25, Y+
     984:	dc 01       	movw	r26, r24
     986:	ed 91       	ld	r30, X+
     988:	fc 91       	ld	r31, X
     98a:	04 80       	ldd	r0, Z+4	; 0x04
     98c:	f5 81       	ldd	r31, Z+5	; 0x05
     98e:	e0 2d       	mov	r30, r0
     990:	19 95       	eicall
     992:	ec 16       	cp	r14, r28
     994:	fd 06       	cpc	r15, r29
     996:	99 f3       	breq	.-26     	; 0x97e <_ZN8Robotarm14startMotorImplEPv+0xe>
     998:	f3 cf       	rjmp	.-26     	; 0x980 <_ZN8Robotarm14startMotorImplEPv+0x10>

0000099a <_ZN8RobotarmC1Ev>:
     99a:	af 92       	push	r10
     99c:	bf 92       	push	r11
     99e:	cf 92       	push	r12
     9a0:	df 92       	push	r13
     9a2:	ef 92       	push	r14
     9a4:	ff 92       	push	r15
     9a6:	0f 93       	push	r16
     9a8:	1f 93       	push	r17
     9aa:	cf 93       	push	r28
     9ac:	df 93       	push	r29
     9ae:	ec 01       	movw	r28, r24
     9b0:	c2 d7       	rcall	.+3972   	; 0x1936 <_ZN6Timer1C1Ev>
     9b2:	8e 01       	movw	r16, r28
     9b4:	0f 5f       	subi	r16, 0xFF	; 255
     9b6:	1f 4f       	sbci	r17, 0xFF	; 255
     9b8:	c8 01       	movw	r24, r16
     9ba:	0e 94 34 0d 	call	0x1a68	; 0x1a68 <_ZN6Timer5C1Ev>
     9be:	89 e1       	ldi	r24, 0x19	; 25
     9c0:	90 e0       	ldi	r25, 0x00	; 0
     9c2:	76 df       	rcall	.-276    	; 0x8b0 <_Znwj>
     9c4:	7c 01       	movw	r14, r24
     9c6:	be 01       	movw	r22, r28
     9c8:	6d d4       	rcall	.+2266   	; 0x12a4 <_ZN2M1C1EP6Timer1>
     9ca:	fb 82       	std	Y+3, r15	; 0x03
     9cc:	ea 82       	std	Y+2, r14	; 0x02
     9ce:	89 e1       	ldi	r24, 0x19	; 25
     9d0:	90 e0       	ldi	r25, 0x00	; 0
     9d2:	6e df       	rcall	.-292    	; 0x8b0 <_Znwj>
     9d4:	7c 01       	movw	r14, r24
     9d6:	be 01       	movw	r22, r28
     9d8:	05 d5       	rcall	.+2570   	; 0x13e4 <_ZN2M2C1EP6Timer1>
     9da:	fd 82       	std	Y+5, r15	; 0x05
     9dc:	ec 82       	std	Y+4, r14	; 0x04
     9de:	89 e1       	ldi	r24, 0x19	; 25
     9e0:	90 e0       	ldi	r25, 0x00	; 0
     9e2:	66 df       	rcall	.-308    	; 0x8b0 <_Znwj>
     9e4:	7c 01       	movw	r14, r24
     9e6:	be 01       	movw	r22, r28
     9e8:	9d d5       	rcall	.+2874   	; 0x1524 <_ZN2M3C1EP6Timer1>
     9ea:	ff 82       	std	Y+7, r15	; 0x07
     9ec:	ee 82       	std	Y+6, r14	; 0x06
     9ee:	89 e1       	ldi	r24, 0x19	; 25
     9f0:	90 e0       	ldi	r25, 0x00	; 0
     9f2:	5e df       	rcall	.-324    	; 0x8b0 <_Znwj>
     9f4:	7c 01       	movw	r14, r24
     9f6:	b8 01       	movw	r22, r16
     9f8:	34 d6       	rcall	.+3176   	; 0x1662 <_ZN2M4C1EP6Timer5>
     9fa:	f9 86       	std	Y+9, r15	; 0x09
     9fc:	e8 86       	std	Y+8, r14	; 0x08
     9fe:	89 e1       	ldi	r24, 0x19	; 25
     a00:	90 e0       	ldi	r25, 0x00	; 0
     a02:	56 df       	rcall	.-340    	; 0x8b0 <_Znwj>
     a04:	7c 01       	movw	r14, r24
     a06:	b8 01       	movw	r22, r16
     a08:	cb d6       	rcall	.+3478   	; 0x17a0 <_ZN2M5C1EP6Timer5>
     a0a:	fb 86       	std	Y+11, r15	; 0x0b
     a0c:	ea 86       	std	Y+10, r14	; 0x0a
     a0e:	89 e1       	ldi	r24, 0x19	; 25
     a10:	90 e0       	ldi	r25, 0x00	; 0
     a12:	4e df       	rcall	.-356    	; 0x8b0 <_Znwj>
     a14:	7c 01       	movw	r14, r24
     a16:	b8 01       	movw	r22, r16
     a18:	5e d7       	rcall	.+3772   	; 0x18d6 <_ZN2M6C1EP6Timer5>
     a1a:	fd 86       	std	Y+13, r15	; 0x0d
     a1c:	ec 86       	std	Y+12, r14	; 0x0c
     a1e:	a1 2c       	mov	r10, r1
     a20:	b1 2c       	mov	r11, r1
     a22:	c1 2c       	mov	r12, r1
     a24:	d1 2c       	mov	r13, r1
     a26:	e1 2c       	mov	r14, r1
     a28:	f1 2c       	mov	r15, r1
     a2a:	00 e0       	ldi	r16, 0x00	; 0
     a2c:	9e 01       	movw	r18, r28
     a2e:	48 e5       	ldi	r20, 0x58	; 88
     a30:	52 e0       	ldi	r21, 0x02	; 2
     a32:	65 ea       	ldi	r22, 0xA5	; 165
     a34:	72 e0       	ldi	r23, 0x02	; 2
     a36:	88 eb       	ldi	r24, 0xB8	; 184
     a38:	94 e0       	ldi	r25, 0x04	; 4
     a3a:	0e 94 ad 10 	call	0x215a	; 0x215a <xTaskGenericCreate>
     a3e:	df 91       	pop	r29
     a40:	cf 91       	pop	r28
     a42:	1f 91       	pop	r17
     a44:	0f 91       	pop	r16
     a46:	ff 90       	pop	r15
     a48:	ef 90       	pop	r14
     a4a:	df 90       	pop	r13
     a4c:	cf 90       	pop	r12
     a4e:	bf 90       	pop	r11
     a50:	af 90       	pop	r10
     a52:	08 95       	ret

00000a54 <_ZN8Robotarm9grabBlockEv>:
     a54:	0f 93       	push	r16
     a56:	1f 93       	push	r17
     a58:	cf 93       	push	r28
     a5a:	df 93       	push	r29
     a5c:	ec 01       	movw	r28, r24
     a5e:	08 85       	ldd	r16, Y+8	; 0x08
     a60:	19 85       	ldd	r17, Y+9	; 0x09
     a62:	d8 01       	movw	r26, r16
     a64:	ed 91       	ld	r30, X+
     a66:	fc 91       	ld	r31, X
     a68:	06 80       	ldd	r0, Z+6	; 0x06
     a6a:	f7 81       	ldd	r31, Z+7	; 0x07
     a6c:	e0 2d       	mov	r30, r0
     a6e:	b4 e0       	ldi	r27, 0x04	; 4
     a70:	e9 39       	cpi	r30, 0x99	; 153
     a72:	fb 07       	cpc	r31, r27
     a74:	09 f0       	breq	.+2      	; 0xa78 <_ZN8Robotarm9grabBlockEv+0x24>
     a76:	6b c1       	rjmp	.+726    	; 0xd4e <_ZN8Robotarm9grabBlockEv+0x2fa>
     a78:	f8 01       	movw	r30, r16
     a7a:	86 89       	ldd	r24, Z+22	; 0x16
     a7c:	88 32       	cpi	r24, 0x28	; 40
     a7e:	c0 f0       	brcs	.+48     	; 0xab0 <_ZN8Robotarm9grabBlockEv+0x5c>
     a80:	20 e0       	ldi	r18, 0x00	; 0
     a82:	30 e0       	ldi	r19, 0x00	; 0
     a84:	40 e2       	ldi	r20, 0x20	; 32
     a86:	52 e4       	ldi	r21, 0x42	; 66
     a88:	66 81       	ldd	r22, Z+6	; 0x06
     a8a:	77 81       	ldd	r23, Z+7	; 0x07
     a8c:	80 85       	ldd	r24, Z+8	; 0x08
     a8e:	91 85       	ldd	r25, Z+9	; 0x09
     a90:	0e 94 8b 1d 	call	0x3b16	; 0x3b16 <__mulsf3>
     a94:	d8 01       	movw	r26, r16
     a96:	52 96       	adiw	r26, 0x12	; 18
     a98:	2d 91       	ld	r18, X+
     a9a:	3d 91       	ld	r19, X+
     a9c:	4d 91       	ld	r20, X+
     a9e:	5c 91       	ld	r21, X
     aa0:	55 97       	sbiw	r26, 0x15	; 21
     aa2:	0e 94 d9 1b 	call	0x37b2	; 0x37b2 <__addsf3>
     aa6:	f8 01       	movw	r30, r16
     aa8:	62 87       	std	Z+10, r22	; 0x0a
     aaa:	73 87       	std	Z+11, r23	; 0x0b
     aac:	84 87       	std	Z+12, r24	; 0x0c
     aae:	95 87       	std	Z+13, r25	; 0x0d
     ab0:	0a 85       	ldd	r16, Y+10	; 0x0a
     ab2:	1b 85       	ldd	r17, Y+11	; 0x0b
     ab4:	d8 01       	movw	r26, r16
     ab6:	ed 91       	ld	r30, X+
     ab8:	fc 91       	ld	r31, X
     aba:	06 80       	ldd	r0, Z+6	; 0x06
     abc:	f7 81       	ldd	r31, Z+7	; 0x07
     abe:	e0 2d       	mov	r30, r0
     ac0:	b4 e0       	ldi	r27, 0x04	; 4
     ac2:	e9 39       	cpi	r30, 0x99	; 153
     ac4:	fb 07       	cpc	r31, r27
     ac6:	09 f0       	breq	.+2      	; 0xaca <_ZN8Robotarm9grabBlockEv+0x76>
     ac8:	52 c1       	rjmp	.+676    	; 0xd6e <_ZN8Robotarm9grabBlockEv+0x31a>
     aca:	f8 01       	movw	r30, r16
     acc:	86 89       	ldd	r24, Z+22	; 0x16
     ace:	8a 35       	cpi	r24, 0x5A	; 90
     ad0:	c0 f0       	brcs	.+48     	; 0xb02 <_ZN8Robotarm9grabBlockEv+0xae>
     ad2:	20 e0       	ldi	r18, 0x00	; 0
     ad4:	30 e0       	ldi	r19, 0x00	; 0
     ad6:	44 eb       	ldi	r20, 0xB4	; 180
     ad8:	52 e4       	ldi	r21, 0x42	; 66
     ada:	66 81       	ldd	r22, Z+6	; 0x06
     adc:	77 81       	ldd	r23, Z+7	; 0x07
     ade:	80 85       	ldd	r24, Z+8	; 0x08
     ae0:	91 85       	ldd	r25, Z+9	; 0x09
     ae2:	0e 94 8b 1d 	call	0x3b16	; 0x3b16 <__mulsf3>
     ae6:	d8 01       	movw	r26, r16
     ae8:	52 96       	adiw	r26, 0x12	; 18
     aea:	2d 91       	ld	r18, X+
     aec:	3d 91       	ld	r19, X+
     aee:	4d 91       	ld	r20, X+
     af0:	5c 91       	ld	r21, X
     af2:	55 97       	sbiw	r26, 0x15	; 21
     af4:	0e 94 d9 1b 	call	0x37b2	; 0x37b2 <__addsf3>
     af8:	f8 01       	movw	r30, r16
     afa:	62 87       	std	Z+10, r22	; 0x0a
     afc:	73 87       	std	Z+11, r23	; 0x0b
     afe:	84 87       	std	Z+12, r24	; 0x0c
     b00:	95 87       	std	Z+13, r25	; 0x0d
     b02:	0a 81       	ldd	r16, Y+2	; 0x02
     b04:	1b 81       	ldd	r17, Y+3	; 0x03
     b06:	d8 01       	movw	r26, r16
     b08:	ed 91       	ld	r30, X+
     b0a:	fc 91       	ld	r31, X
     b0c:	06 80       	ldd	r0, Z+6	; 0x06
     b0e:	f7 81       	ldd	r31, Z+7	; 0x07
     b10:	e0 2d       	mov	r30, r0
     b12:	b4 e0       	ldi	r27, 0x04	; 4
     b14:	e9 39       	cpi	r30, 0x99	; 153
     b16:	fb 07       	cpc	r31, r27
     b18:	09 f0       	breq	.+2      	; 0xb1c <_ZN8Robotarm9grabBlockEv+0xc8>
     b1a:	21 c1       	rjmp	.+578    	; 0xd5e <_ZN8Robotarm9grabBlockEv+0x30a>
     b1c:	20 e0       	ldi	r18, 0x00	; 0
     b1e:	30 e0       	ldi	r19, 0x00	; 0
     b20:	a9 01       	movw	r20, r18
     b22:	f8 01       	movw	r30, r16
     b24:	66 81       	ldd	r22, Z+6	; 0x06
     b26:	77 81       	ldd	r23, Z+7	; 0x07
     b28:	80 85       	ldd	r24, Z+8	; 0x08
     b2a:	91 85       	ldd	r25, Z+9	; 0x09
     b2c:	0e 94 8b 1d 	call	0x3b16	; 0x3b16 <__mulsf3>
     b30:	d8 01       	movw	r26, r16
     b32:	52 96       	adiw	r26, 0x12	; 18
     b34:	2d 91       	ld	r18, X+
     b36:	3d 91       	ld	r19, X+
     b38:	4d 91       	ld	r20, X+
     b3a:	5c 91       	ld	r21, X
     b3c:	55 97       	sbiw	r26, 0x15	; 21
     b3e:	0e 94 d9 1b 	call	0x37b2	; 0x37b2 <__addsf3>
     b42:	f8 01       	movw	r30, r16
     b44:	62 87       	std	Z+10, r22	; 0x0a
     b46:	73 87       	std	Z+11, r23	; 0x0b
     b48:	84 87       	std	Z+12, r24	; 0x0c
     b4a:	95 87       	std	Z+13, r25	; 0x0d
     b4c:	8c ed       	ldi	r24, 0xDC	; 220
     b4e:	95 e0       	ldi	r25, 0x05	; 5
     b50:	0e 94 ac 12 	call	0x2558	; 0x2558 <vTaskDelay>
     b54:	0c 81       	ldd	r16, Y+4	; 0x04
     b56:	1d 81       	ldd	r17, Y+5	; 0x05
     b58:	d8 01       	movw	r26, r16
     b5a:	ed 91       	ld	r30, X+
     b5c:	fc 91       	ld	r31, X
     b5e:	06 80       	ldd	r0, Z+6	; 0x06
     b60:	f7 81       	ldd	r31, Z+7	; 0x07
     b62:	e0 2d       	mov	r30, r0
     b64:	b4 e0       	ldi	r27, 0x04	; 4
     b66:	e9 39       	cpi	r30, 0x99	; 153
     b68:	fb 07       	cpc	r31, r27
     b6a:	09 f0       	breq	.+2      	; 0xb6e <_ZN8Robotarm9grabBlockEv+0x11a>
     b6c:	f4 c0       	rjmp	.+488    	; 0xd56 <_ZN8Robotarm9grabBlockEv+0x302>
     b6e:	f8 01       	movw	r30, r16
     b70:	86 89       	ldd	r24, Z+22	; 0x16
     b72:	83 32       	cpi	r24, 0x23	; 35
     b74:	c0 f0       	brcs	.+48     	; 0xba6 <_ZN8Robotarm9grabBlockEv+0x152>
     b76:	20 e0       	ldi	r18, 0x00	; 0
     b78:	30 e0       	ldi	r19, 0x00	; 0
     b7a:	4c e0       	ldi	r20, 0x0C	; 12
     b7c:	52 e4       	ldi	r21, 0x42	; 66
     b7e:	66 81       	ldd	r22, Z+6	; 0x06
     b80:	77 81       	ldd	r23, Z+7	; 0x07
     b82:	80 85       	ldd	r24, Z+8	; 0x08
     b84:	91 85       	ldd	r25, Z+9	; 0x09
     b86:	0e 94 8b 1d 	call	0x3b16	; 0x3b16 <__mulsf3>
     b8a:	d8 01       	movw	r26, r16
     b8c:	52 96       	adiw	r26, 0x12	; 18
     b8e:	2d 91       	ld	r18, X+
     b90:	3d 91       	ld	r19, X+
     b92:	4d 91       	ld	r20, X+
     b94:	5c 91       	ld	r21, X
     b96:	55 97       	sbiw	r26, 0x15	; 21
     b98:	0e 94 d9 1b 	call	0x37b2	; 0x37b2 <__addsf3>
     b9c:	f8 01       	movw	r30, r16
     b9e:	62 87       	std	Z+10, r22	; 0x0a
     ba0:	73 87       	std	Z+11, r23	; 0x0b
     ba2:	84 87       	std	Z+12, r24	; 0x0c
     ba4:	95 87       	std	Z+13, r25	; 0x0d
     ba6:	0e 81       	ldd	r16, Y+6	; 0x06
     ba8:	1f 81       	ldd	r17, Y+7	; 0x07
     baa:	d8 01       	movw	r26, r16
     bac:	ed 91       	ld	r30, X+
     bae:	fc 91       	ld	r31, X
     bb0:	06 80       	ldd	r0, Z+6	; 0x06
     bb2:	f7 81       	ldd	r31, Z+7	; 0x07
     bb4:	e0 2d       	mov	r30, r0
     bb6:	b4 e0       	ldi	r27, 0x04	; 4
     bb8:	e9 39       	cpi	r30, 0x99	; 153
     bba:	fb 07       	cpc	r31, r27
     bbc:	09 f0       	breq	.+2      	; 0xbc0 <_ZN8Robotarm9grabBlockEv+0x16c>
     bbe:	d3 c0       	rjmp	.+422    	; 0xd66 <_ZN8Robotarm9grabBlockEv+0x312>
     bc0:	f8 01       	movw	r30, r16
     bc2:	86 89       	ldd	r24, Z+22	; 0x16
     bc4:	8f 33       	cpi	r24, 0x3F	; 63
     bc6:	c0 f0       	brcs	.+48     	; 0xbf8 <_ZN8Robotarm9grabBlockEv+0x1a4>
     bc8:	20 e0       	ldi	r18, 0x00	; 0
     bca:	30 e0       	ldi	r19, 0x00	; 0
     bcc:	4c e7       	ldi	r20, 0x7C	; 124
     bce:	52 e4       	ldi	r21, 0x42	; 66
     bd0:	66 81       	ldd	r22, Z+6	; 0x06
     bd2:	77 81       	ldd	r23, Z+7	; 0x07
     bd4:	80 85       	ldd	r24, Z+8	; 0x08
     bd6:	91 85       	ldd	r25, Z+9	; 0x09
     bd8:	0e 94 8b 1d 	call	0x3b16	; 0x3b16 <__mulsf3>
     bdc:	d8 01       	movw	r26, r16
     bde:	52 96       	adiw	r26, 0x12	; 18
     be0:	2d 91       	ld	r18, X+
     be2:	3d 91       	ld	r19, X+
     be4:	4d 91       	ld	r20, X+
     be6:	5c 91       	ld	r21, X
     be8:	55 97       	sbiw	r26, 0x15	; 21
     bea:	0e 94 d9 1b 	call	0x37b2	; 0x37b2 <__addsf3>
     bee:	f8 01       	movw	r30, r16
     bf0:	62 87       	std	Z+10, r22	; 0x0a
     bf2:	73 87       	std	Z+11, r23	; 0x0b
     bf4:	84 87       	std	Z+12, r24	; 0x0c
     bf6:	95 87       	std	Z+13, r25	; 0x0d
     bf8:	8c ed       	ldi	r24, 0xDC	; 220
     bfa:	95 e0       	ldi	r25, 0x05	; 5
     bfc:	0e 94 ac 12 	call	0x2558	; 0x2558 <vTaskDelay>
     c00:	0c 85       	ldd	r16, Y+12	; 0x0c
     c02:	1d 85       	ldd	r17, Y+13	; 0x0d
     c04:	d8 01       	movw	r26, r16
     c06:	ed 91       	ld	r30, X+
     c08:	fc 91       	ld	r31, X
     c0a:	06 80       	ldd	r0, Z+6	; 0x06
     c0c:	f7 81       	ldd	r31, Z+7	; 0x07
     c0e:	e0 2d       	mov	r30, r0
     c10:	b4 e0       	ldi	r27, 0x04	; 4
     c12:	e9 39       	cpi	r30, 0x99	; 153
     c14:	fb 07       	cpc	r31, r27
     c16:	09 f0       	breq	.+2      	; 0xc1a <_ZN8Robotarm9grabBlockEv+0x1c6>
     c18:	b2 c0       	rjmp	.+356    	; 0xd7e <_ZN8Robotarm9grabBlockEv+0x32a>
     c1a:	f8 01       	movw	r30, r16
     c1c:	86 89       	ldd	r24, Z+22	; 0x16
     c1e:	8f 33       	cpi	r24, 0x3F	; 63
     c20:	c0 f0       	brcs	.+48     	; 0xc52 <_ZN8Robotarm9grabBlockEv+0x1fe>
     c22:	20 e0       	ldi	r18, 0x00	; 0
     c24:	30 e0       	ldi	r19, 0x00	; 0
     c26:	4c e7       	ldi	r20, 0x7C	; 124
     c28:	52 e4       	ldi	r21, 0x42	; 66
     c2a:	66 81       	ldd	r22, Z+6	; 0x06
     c2c:	77 81       	ldd	r23, Z+7	; 0x07
     c2e:	80 85       	ldd	r24, Z+8	; 0x08
     c30:	91 85       	ldd	r25, Z+9	; 0x09
     c32:	0e 94 8b 1d 	call	0x3b16	; 0x3b16 <__mulsf3>
     c36:	d8 01       	movw	r26, r16
     c38:	52 96       	adiw	r26, 0x12	; 18
     c3a:	2d 91       	ld	r18, X+
     c3c:	3d 91       	ld	r19, X+
     c3e:	4d 91       	ld	r20, X+
     c40:	5c 91       	ld	r21, X
     c42:	55 97       	sbiw	r26, 0x15	; 21
     c44:	0e 94 d9 1b 	call	0x37b2	; 0x37b2 <__addsf3>
     c48:	f8 01       	movw	r30, r16
     c4a:	62 87       	std	Z+10, r22	; 0x0a
     c4c:	73 87       	std	Z+11, r23	; 0x0b
     c4e:	84 87       	std	Z+12, r24	; 0x0c
     c50:	95 87       	std	Z+13, r25	; 0x0d
     c52:	8a ef       	ldi	r24, 0xFA	; 250
     c54:	90 e0       	ldi	r25, 0x00	; 0
     c56:	0e 94 ac 12 	call	0x2558	; 0x2558 <vTaskDelay>
     c5a:	0c 81       	ldd	r16, Y+4	; 0x04
     c5c:	1d 81       	ldd	r17, Y+5	; 0x05
     c5e:	d8 01       	movw	r26, r16
     c60:	ed 91       	ld	r30, X+
     c62:	fc 91       	ld	r31, X
     c64:	06 80       	ldd	r0, Z+6	; 0x06
     c66:	f7 81       	ldd	r31, Z+7	; 0x07
     c68:	e0 2d       	mov	r30, r0
     c6a:	b4 e0       	ldi	r27, 0x04	; 4
     c6c:	e9 39       	cpi	r30, 0x99	; 153
     c6e:	fb 07       	cpc	r31, r27
     c70:	09 f0       	breq	.+2      	; 0xc74 <_ZN8Robotarm9grabBlockEv+0x220>
     c72:	81 c0       	rjmp	.+258    	; 0xd76 <_ZN8Robotarm9grabBlockEv+0x322>
     c74:	f8 01       	movw	r30, r16
     c76:	86 89       	ldd	r24, Z+22	; 0x16
     c78:	86 34       	cpi	r24, 0x46	; 70
     c7a:	c0 f0       	brcs	.+48     	; 0xcac <_ZN8Robotarm9grabBlockEv+0x258>
     c7c:	20 e0       	ldi	r18, 0x00	; 0
     c7e:	30 e0       	ldi	r19, 0x00	; 0
     c80:	4c e8       	ldi	r20, 0x8C	; 140
     c82:	52 e4       	ldi	r21, 0x42	; 66
     c84:	66 81       	ldd	r22, Z+6	; 0x06
     c86:	77 81       	ldd	r23, Z+7	; 0x07
     c88:	80 85       	ldd	r24, Z+8	; 0x08
     c8a:	91 85       	ldd	r25, Z+9	; 0x09
     c8c:	0e 94 8b 1d 	call	0x3b16	; 0x3b16 <__mulsf3>
     c90:	d8 01       	movw	r26, r16
     c92:	52 96       	adiw	r26, 0x12	; 18
     c94:	2d 91       	ld	r18, X+
     c96:	3d 91       	ld	r19, X+
     c98:	4d 91       	ld	r20, X+
     c9a:	5c 91       	ld	r21, X
     c9c:	55 97       	sbiw	r26, 0x15	; 21
     c9e:	0e 94 d9 1b 	call	0x37b2	; 0x37b2 <__addsf3>
     ca2:	f8 01       	movw	r30, r16
     ca4:	62 87       	std	Z+10, r22	; 0x0a
     ca6:	73 87       	std	Z+11, r23	; 0x0b
     ca8:	84 87       	std	Z+12, r24	; 0x0c
     caa:	95 87       	std	Z+13, r25	; 0x0d
     cac:	0e 81       	ldd	r16, Y+6	; 0x06
     cae:	1f 81       	ldd	r17, Y+7	; 0x07
     cb0:	d8 01       	movw	r26, r16
     cb2:	ed 91       	ld	r30, X+
     cb4:	fc 91       	ld	r31, X
     cb6:	06 80       	ldd	r0, Z+6	; 0x06
     cb8:	f7 81       	ldd	r31, Z+7	; 0x07
     cba:	e0 2d       	mov	r30, r0
     cbc:	b4 e0       	ldi	r27, 0x04	; 4
     cbe:	e9 39       	cpi	r30, 0x99	; 153
     cc0:	fb 07       	cpc	r31, r27
     cc2:	09 f0       	breq	.+2      	; 0xcc6 <_ZN8Robotarm9grabBlockEv+0x272>
     cc4:	67 c0       	rjmp	.+206    	; 0xd94 <_ZN8Robotarm9grabBlockEv+0x340>
     cc6:	f8 01       	movw	r30, r16
     cc8:	86 89       	ldd	r24, Z+22	; 0x16
     cca:	86 34       	cpi	r24, 0x46	; 70
     ccc:	c0 f0       	brcs	.+48     	; 0xcfe <_ZN8Robotarm9grabBlockEv+0x2aa>
     cce:	20 e0       	ldi	r18, 0x00	; 0
     cd0:	30 e0       	ldi	r19, 0x00	; 0
     cd2:	4c e8       	ldi	r20, 0x8C	; 140
     cd4:	52 e4       	ldi	r21, 0x42	; 66
     cd6:	66 81       	ldd	r22, Z+6	; 0x06
     cd8:	77 81       	ldd	r23, Z+7	; 0x07
     cda:	80 85       	ldd	r24, Z+8	; 0x08
     cdc:	91 85       	ldd	r25, Z+9	; 0x09
     cde:	0e 94 8b 1d 	call	0x3b16	; 0x3b16 <__mulsf3>
     ce2:	d8 01       	movw	r26, r16
     ce4:	52 96       	adiw	r26, 0x12	; 18
     ce6:	2d 91       	ld	r18, X+
     ce8:	3d 91       	ld	r19, X+
     cea:	4d 91       	ld	r20, X+
     cec:	5c 91       	ld	r21, X
     cee:	55 97       	sbiw	r26, 0x15	; 21
     cf0:	0e 94 d9 1b 	call	0x37b2	; 0x37b2 <__addsf3>
     cf4:	f8 01       	movw	r30, r16
     cf6:	62 87       	std	Z+10, r22	; 0x0a
     cf8:	73 87       	std	Z+11, r23	; 0x0b
     cfa:	84 87       	std	Z+12, r24	; 0x0c
     cfc:	95 87       	std	Z+13, r25	; 0x0d
     cfe:	08 84       	ldd	r0, Y+8	; 0x08
     d00:	d9 85       	ldd	r29, Y+9	; 0x09
     d02:	c0 2d       	mov	r28, r0
     d04:	e8 81       	ld	r30, Y
     d06:	f9 81       	ldd	r31, Y+1	; 0x01
     d08:	06 80       	ldd	r0, Z+6	; 0x06
     d0a:	f7 81       	ldd	r31, Z+7	; 0x07
     d0c:	e0 2d       	mov	r30, r0
     d0e:	84 e0       	ldi	r24, 0x04	; 4
     d10:	e9 39       	cpi	r30, 0x99	; 153
     d12:	f8 07       	cpc	r31, r24
     d14:	c1 f5       	brne	.+112    	; 0xd86 <_ZN8Robotarm9grabBlockEv+0x332>
     d16:	8e 89       	ldd	r24, Y+22	; 0x16
     d18:	86 34       	cpi	r24, 0x46	; 70
     d1a:	a0 f0       	brcs	.+40     	; 0xd44 <_ZN8Robotarm9grabBlockEv+0x2f0>
     d1c:	20 e0       	ldi	r18, 0x00	; 0
     d1e:	30 e0       	ldi	r19, 0x00	; 0
     d20:	4c e8       	ldi	r20, 0x8C	; 140
     d22:	52 e4       	ldi	r21, 0x42	; 66
     d24:	6e 81       	ldd	r22, Y+6	; 0x06
     d26:	7f 81       	ldd	r23, Y+7	; 0x07
     d28:	88 85       	ldd	r24, Y+8	; 0x08
     d2a:	99 85       	ldd	r25, Y+9	; 0x09
     d2c:	0e 94 8b 1d 	call	0x3b16	; 0x3b16 <__mulsf3>
     d30:	2a 89       	ldd	r18, Y+18	; 0x12
     d32:	3b 89       	ldd	r19, Y+19	; 0x13
     d34:	4c 89       	ldd	r20, Y+20	; 0x14
     d36:	5d 89       	ldd	r21, Y+21	; 0x15
     d38:	0e 94 d9 1b 	call	0x37b2	; 0x37b2 <__addsf3>
     d3c:	6a 87       	std	Y+10, r22	; 0x0a
     d3e:	7b 87       	std	Y+11, r23	; 0x0b
     d40:	8c 87       	std	Y+12, r24	; 0x0c
     d42:	9d 87       	std	Y+13, r25	; 0x0d
     d44:	df 91       	pop	r29
     d46:	cf 91       	pop	r28
     d48:	1f 91       	pop	r17
     d4a:	0f 91       	pop	r16
     d4c:	08 95       	ret
     d4e:	68 e2       	ldi	r22, 0x28	; 40
     d50:	c8 01       	movw	r24, r16
     d52:	19 95       	eicall
     d54:	ad ce       	rjmp	.-678    	; 0xab0 <_ZN8Robotarm9grabBlockEv+0x5c>
     d56:	63 e2       	ldi	r22, 0x23	; 35
     d58:	c8 01       	movw	r24, r16
     d5a:	19 95       	eicall
     d5c:	24 cf       	rjmp	.-440    	; 0xba6 <_ZN8Robotarm9grabBlockEv+0x152>
     d5e:	60 e0       	ldi	r22, 0x00	; 0
     d60:	c8 01       	movw	r24, r16
     d62:	19 95       	eicall
     d64:	f3 ce       	rjmp	.-538    	; 0xb4c <_ZN8Robotarm9grabBlockEv+0xf8>
     d66:	6f e3       	ldi	r22, 0x3F	; 63
     d68:	c8 01       	movw	r24, r16
     d6a:	19 95       	eicall
     d6c:	45 cf       	rjmp	.-374    	; 0xbf8 <_ZN8Robotarm9grabBlockEv+0x1a4>
     d6e:	6a e5       	ldi	r22, 0x5A	; 90
     d70:	c8 01       	movw	r24, r16
     d72:	19 95       	eicall
     d74:	c6 ce       	rjmp	.-628    	; 0xb02 <_ZN8Robotarm9grabBlockEv+0xae>
     d76:	66 e4       	ldi	r22, 0x46	; 70
     d78:	c8 01       	movw	r24, r16
     d7a:	19 95       	eicall
     d7c:	97 cf       	rjmp	.-210    	; 0xcac <_ZN8Robotarm9grabBlockEv+0x258>
     d7e:	6f e3       	ldi	r22, 0x3F	; 63
     d80:	c8 01       	movw	r24, r16
     d82:	19 95       	eicall
     d84:	66 cf       	rjmp	.-308    	; 0xc52 <_ZN8Robotarm9grabBlockEv+0x1fe>
     d86:	66 e4       	ldi	r22, 0x46	; 70
     d88:	ce 01       	movw	r24, r28
     d8a:	df 91       	pop	r29
     d8c:	cf 91       	pop	r28
     d8e:	1f 91       	pop	r17
     d90:	0f 91       	pop	r16
     d92:	19 94       	eijmp
     d94:	66 e4       	ldi	r22, 0x46	; 70
     d96:	c8 01       	movw	r24, r16
     d98:	19 95       	eicall
     d9a:	b1 cf       	rjmp	.-158    	; 0xcfe <_ZN8Robotarm9grabBlockEv+0x2aa>

00000d9c <_ZN8Robotarm18ArmDownReleaseItemEv>:
	motors_[0]->SetDegrees(180);
	ArmDownReleaseItem();
}

void Robotarm::ArmDownReleaseItem()
{
     d9c:	0f 93       	push	r16
     d9e:	1f 93       	push	r17
     da0:	cf 93       	push	r28
     da2:	df 93       	push	r29
     da4:	ec 01       	movw	r28, r24
	vTaskDelay( 1500 / portTICK_RATE_MS );
     da6:	8c ed       	ldi	r24, 0xDC	; 220
     da8:	95 e0       	ldi	r25, 0x05	; 5
     daa:	0e 94 ac 12 	call	0x2558	; 0x2558 <vTaskDelay>
	motors_[1]->SetDegrees(35);
     dae:	0c 81       	ldd	r16, Y+4	; 0x04
     db0:	1d 81       	ldd	r17, Y+5	; 0x05
     db2:	d8 01       	movw	r26, r16
     db4:	ed 91       	ld	r30, X+
     db6:	fc 91       	ld	r31, X
     db8:	06 80       	ldd	r0, Z+6	; 0x06
     dba:	f7 81       	ldd	r31, Z+7	; 0x07
     dbc:	e0 2d       	mov	r30, r0
     dbe:	b4 e0       	ldi	r27, 0x04	; 4
     dc0:	e9 39       	cpi	r30, 0x99	; 153
     dc2:	fb 07       	cpc	r31, r27
     dc4:	09 f0       	breq	.+2      	; 0xdc8 <_ZN8Robotarm18ArmDownReleaseItemEv+0x2c>
     dc6:	f3 c0       	rjmp	.+486    	; 0xfae <_ZN8Robotarm18ArmDownReleaseItemEv+0x212>
	*    @param uint8_t	degrees to turn
	*    @return void Nothing
	*/
	virtual void SetDegrees( uint8_t degrees )
	{
		if ( maxDegrees_ >= degrees )
     dc8:	f8 01       	movw	r30, r16
     dca:	86 89       	ldd	r24, Z+22	; 0x16
     dcc:	83 32       	cpi	r24, 0x23	; 35
     dce:	c0 f0       	brcs	.+48     	; 0xe00 <_ZN8Robotarm18ArmDownReleaseItemEv+0x64>
		{
			percent_ = percentPrDeg * degrees + startpercent_;
     dd0:	20 e0       	ldi	r18, 0x00	; 0
     dd2:	30 e0       	ldi	r19, 0x00	; 0
     dd4:	4c e0       	ldi	r20, 0x0C	; 12
     dd6:	52 e4       	ldi	r21, 0x42	; 66
     dd8:	66 81       	ldd	r22, Z+6	; 0x06
     dda:	77 81       	ldd	r23, Z+7	; 0x07
     ddc:	80 85       	ldd	r24, Z+8	; 0x08
     dde:	91 85       	ldd	r25, Z+9	; 0x09
     de0:	0e 94 8b 1d 	call	0x3b16	; 0x3b16 <__mulsf3>
     de4:	d8 01       	movw	r26, r16
     de6:	52 96       	adiw	r26, 0x12	; 18
     de8:	2d 91       	ld	r18, X+
     dea:	3d 91       	ld	r19, X+
     dec:	4d 91       	ld	r20, X+
     dee:	5c 91       	ld	r21, X
     df0:	55 97       	sbiw	r26, 0x15	; 21
     df2:	0e 94 d9 1b 	call	0x37b2	; 0x37b2 <__addsf3>
     df6:	f8 01       	movw	r30, r16
     df8:	62 87       	std	Z+10, r22	; 0x0a
     dfa:	73 87       	std	Z+11, r23	; 0x0b
     dfc:	84 87       	std	Z+12, r24	; 0x0c
     dfe:	95 87       	std	Z+13, r25	; 0x0d
	motors_[2]->SetDegrees(40);
     e00:	0e 81       	ldd	r16, Y+6	; 0x06
     e02:	1f 81       	ldd	r17, Y+7	; 0x07
     e04:	d8 01       	movw	r26, r16
     e06:	ed 91       	ld	r30, X+
     e08:	fc 91       	ld	r31, X
     e0a:	06 80       	ldd	r0, Z+6	; 0x06
     e0c:	f7 81       	ldd	r31, Z+7	; 0x07
     e0e:	e0 2d       	mov	r30, r0
     e10:	b4 e0       	ldi	r27, 0x04	; 4
     e12:	e9 39       	cpi	r30, 0x99	; 153
     e14:	fb 07       	cpc	r31, r27
     e16:	09 f0       	breq	.+2      	; 0xe1a <_ZN8Robotarm18ArmDownReleaseItemEv+0x7e>
     e18:	c6 c0       	rjmp	.+396    	; 0xfa6 <_ZN8Robotarm18ArmDownReleaseItemEv+0x20a>
	*    @param uint8_t	degrees to turn
	*    @return void Nothing
	*/
	virtual void SetDegrees( uint8_t degrees )
	{
		if ( maxDegrees_ >= degrees )
     e1a:	f8 01       	movw	r30, r16
     e1c:	86 89       	ldd	r24, Z+22	; 0x16
     e1e:	88 32       	cpi	r24, 0x28	; 40
     e20:	c0 f0       	brcs	.+48     	; 0xe52 <_ZN8Robotarm18ArmDownReleaseItemEv+0xb6>
		{
			percent_ = percentPrDeg * degrees + startpercent_;
     e22:	20 e0       	ldi	r18, 0x00	; 0
     e24:	30 e0       	ldi	r19, 0x00	; 0
     e26:	40 e2       	ldi	r20, 0x20	; 32
     e28:	52 e4       	ldi	r21, 0x42	; 66
     e2a:	66 81       	ldd	r22, Z+6	; 0x06
     e2c:	77 81       	ldd	r23, Z+7	; 0x07
     e2e:	80 85       	ldd	r24, Z+8	; 0x08
     e30:	91 85       	ldd	r25, Z+9	; 0x09
     e32:	0e 94 8b 1d 	call	0x3b16	; 0x3b16 <__mulsf3>
     e36:	d8 01       	movw	r26, r16
     e38:	52 96       	adiw	r26, 0x12	; 18
     e3a:	2d 91       	ld	r18, X+
     e3c:	3d 91       	ld	r19, X+
     e3e:	4d 91       	ld	r20, X+
     e40:	5c 91       	ld	r21, X
     e42:	55 97       	sbiw	r26, 0x15	; 21
     e44:	0e 94 d9 1b 	call	0x37b2	; 0x37b2 <__addsf3>
     e48:	f8 01       	movw	r30, r16
     e4a:	62 87       	std	Z+10, r22	; 0x0a
     e4c:	73 87       	std	Z+11, r23	; 0x0b
     e4e:	84 87       	std	Z+12, r24	; 0x0c
     e50:	95 87       	std	Z+13, r25	; 0x0d
	vTaskDelay( 1500 / portTICK_RATE_MS );
     e52:	8c ed       	ldi	r24, 0xDC	; 220
     e54:	95 e0       	ldi	r25, 0x05	; 5
     e56:	0e 94 ac 12 	call	0x2558	; 0x2558 <vTaskDelay>
	motors_[5]->SetDegrees(0);
     e5a:	0c 85       	ldd	r16, Y+12	; 0x0c
     e5c:	1d 85       	ldd	r17, Y+13	; 0x0d
     e5e:	d8 01       	movw	r26, r16
     e60:	ed 91       	ld	r30, X+
     e62:	fc 91       	ld	r31, X
     e64:	06 80       	ldd	r0, Z+6	; 0x06
     e66:	f7 81       	ldd	r31, Z+7	; 0x07
     e68:	e0 2d       	mov	r30, r0
     e6a:	b4 e0       	ldi	r27, 0x04	; 4
     e6c:	e9 39       	cpi	r30, 0x99	; 153
     e6e:	fb 07       	cpc	r31, r27
     e70:	09 f0       	breq	.+2      	; 0xe74 <_ZN8Robotarm18ArmDownReleaseItemEv+0xd8>
     e72:	b4 c0       	rjmp	.+360    	; 0xfdc <_ZN8Robotarm18ArmDownReleaseItemEv+0x240>
     e74:	20 e0       	ldi	r18, 0x00	; 0
     e76:	30 e0       	ldi	r19, 0x00	; 0
     e78:	a9 01       	movw	r20, r18
     e7a:	f8 01       	movw	r30, r16
     e7c:	66 81       	ldd	r22, Z+6	; 0x06
     e7e:	77 81       	ldd	r23, Z+7	; 0x07
     e80:	80 85       	ldd	r24, Z+8	; 0x08
     e82:	91 85       	ldd	r25, Z+9	; 0x09
     e84:	0e 94 8b 1d 	call	0x3b16	; 0x3b16 <__mulsf3>
     e88:	d8 01       	movw	r26, r16
     e8a:	52 96       	adiw	r26, 0x12	; 18
     e8c:	2d 91       	ld	r18, X+
     e8e:	3d 91       	ld	r19, X+
     e90:	4d 91       	ld	r20, X+
     e92:	5c 91       	ld	r21, X
     e94:	55 97       	sbiw	r26, 0x15	; 21
     e96:	0e 94 d9 1b 	call	0x37b2	; 0x37b2 <__addsf3>
     e9a:	f8 01       	movw	r30, r16
     e9c:	62 87       	std	Z+10, r22	; 0x0a
     e9e:	73 87       	std	Z+11, r23	; 0x0b
     ea0:	84 87       	std	Z+12, r24	; 0x0c
     ea2:	95 87       	std	Z+13, r25	; 0x0d
	vTaskDelay( 250 / portTICK_RATE_MS );
     ea4:	8a ef       	ldi	r24, 0xFA	; 250
     ea6:	90 e0       	ldi	r25, 0x00	; 0
     ea8:	0e 94 ac 12 	call	0x2558	; 0x2558 <vTaskDelay>
	motors_[1]->SetDegrees(90);
     eac:	0c 81       	ldd	r16, Y+4	; 0x04
     eae:	1d 81       	ldd	r17, Y+5	; 0x05
     eb0:	d8 01       	movw	r26, r16
     eb2:	ed 91       	ld	r30, X+
     eb4:	fc 91       	ld	r31, X
     eb6:	06 80       	ldd	r0, Z+6	; 0x06
     eb8:	f7 81       	ldd	r31, Z+7	; 0x07
     eba:	e0 2d       	mov	r30, r0
     ebc:	b4 e0       	ldi	r27, 0x04	; 4
     ebe:	e9 39       	cpi	r30, 0x99	; 153
     ec0:	fb 07       	cpc	r31, r27
     ec2:	09 f0       	breq	.+2      	; 0xec6 <_ZN8Robotarm18ArmDownReleaseItemEv+0x12a>
     ec4:	87 c0       	rjmp	.+270    	; 0xfd4 <_ZN8Robotarm18ArmDownReleaseItemEv+0x238>
	*    @param uint8_t	degrees to turn
	*    @return void Nothing
	*/
	virtual void SetDegrees( uint8_t degrees )
	{
		if ( maxDegrees_ >= degrees )
     ec6:	f8 01       	movw	r30, r16
     ec8:	86 89       	ldd	r24, Z+22	; 0x16
     eca:	8a 35       	cpi	r24, 0x5A	; 90
     ecc:	c0 f0       	brcs	.+48     	; 0xefe <_ZN8Robotarm18ArmDownReleaseItemEv+0x162>
		{
			percent_ = percentPrDeg * degrees + startpercent_;
     ece:	20 e0       	ldi	r18, 0x00	; 0
     ed0:	30 e0       	ldi	r19, 0x00	; 0
     ed2:	44 eb       	ldi	r20, 0xB4	; 180
     ed4:	52 e4       	ldi	r21, 0x42	; 66
     ed6:	66 81       	ldd	r22, Z+6	; 0x06
     ed8:	77 81       	ldd	r23, Z+7	; 0x07
     eda:	80 85       	ldd	r24, Z+8	; 0x08
     edc:	91 85       	ldd	r25, Z+9	; 0x09
     ede:	0e 94 8b 1d 	call	0x3b16	; 0x3b16 <__mulsf3>
     ee2:	d8 01       	movw	r26, r16
     ee4:	52 96       	adiw	r26, 0x12	; 18
     ee6:	2d 91       	ld	r18, X+
     ee8:	3d 91       	ld	r19, X+
     eea:	4d 91       	ld	r20, X+
     eec:	5c 91       	ld	r21, X
     eee:	55 97       	sbiw	r26, 0x15	; 21
     ef0:	0e 94 d9 1b 	call	0x37b2	; 0x37b2 <__addsf3>
     ef4:	f8 01       	movw	r30, r16
     ef6:	62 87       	std	Z+10, r22	; 0x0a
     ef8:	73 87       	std	Z+11, r23	; 0x0b
     efa:	84 87       	std	Z+12, r24	; 0x0c
     efc:	95 87       	std	Z+13, r25	; 0x0d
	motors_[2]->SetDegrees(90);
     efe:	0e 81       	ldd	r16, Y+6	; 0x06
     f00:	1f 81       	ldd	r17, Y+7	; 0x07
     f02:	d8 01       	movw	r26, r16
     f04:	ed 91       	ld	r30, X+
     f06:	fc 91       	ld	r31, X
     f08:	06 80       	ldd	r0, Z+6	; 0x06
     f0a:	f7 81       	ldd	r31, Z+7	; 0x07
     f0c:	e0 2d       	mov	r30, r0
     f0e:	b4 e0       	ldi	r27, 0x04	; 4
     f10:	e9 39       	cpi	r30, 0x99	; 153
     f12:	fb 07       	cpc	r31, r27
     f14:	09 f0       	breq	.+2      	; 0xf18 <_ZN8Robotarm18ArmDownReleaseItemEv+0x17c>
     f16:	5a c0       	rjmp	.+180    	; 0xfcc <_ZN8Robotarm18ArmDownReleaseItemEv+0x230>
	*    @param uint8_t	degrees to turn
	*    @return void Nothing
	*/
	virtual void SetDegrees( uint8_t degrees )
	{
		if ( maxDegrees_ >= degrees )
     f18:	f8 01       	movw	r30, r16
     f1a:	86 89       	ldd	r24, Z+22	; 0x16
     f1c:	8a 35       	cpi	r24, 0x5A	; 90
     f1e:	c0 f0       	brcs	.+48     	; 0xf50 <_ZN8Robotarm18ArmDownReleaseItemEv+0x1b4>
		{
			percent_ = percentPrDeg * degrees + startpercent_;
     f20:	20 e0       	ldi	r18, 0x00	; 0
     f22:	30 e0       	ldi	r19, 0x00	; 0
     f24:	44 eb       	ldi	r20, 0xB4	; 180
     f26:	52 e4       	ldi	r21, 0x42	; 66
     f28:	66 81       	ldd	r22, Z+6	; 0x06
     f2a:	77 81       	ldd	r23, Z+7	; 0x07
     f2c:	80 85       	ldd	r24, Z+8	; 0x08
     f2e:	91 85       	ldd	r25, Z+9	; 0x09
     f30:	0e 94 8b 1d 	call	0x3b16	; 0x3b16 <__mulsf3>
     f34:	d8 01       	movw	r26, r16
     f36:	52 96       	adiw	r26, 0x12	; 18
     f38:	2d 91       	ld	r18, X+
     f3a:	3d 91       	ld	r19, X+
     f3c:	4d 91       	ld	r20, X+
     f3e:	5c 91       	ld	r21, X
     f40:	55 97       	sbiw	r26, 0x15	; 21
     f42:	0e 94 d9 1b 	call	0x37b2	; 0x37b2 <__addsf3>
     f46:	f8 01       	movw	r30, r16
     f48:	62 87       	std	Z+10, r22	; 0x0a
     f4a:	73 87       	std	Z+11, r23	; 0x0b
     f4c:	84 87       	std	Z+12, r24	; 0x0c
     f4e:	95 87       	std	Z+13, r25	; 0x0d
	motors_[3]->SetDegrees(90);
     f50:	08 84       	ldd	r0, Y+8	; 0x08
     f52:	d9 85       	ldd	r29, Y+9	; 0x09
     f54:	c0 2d       	mov	r28, r0
     f56:	e8 81       	ld	r30, Y
     f58:	f9 81       	ldd	r31, Y+1	; 0x01
     f5a:	06 80       	ldd	r0, Z+6	; 0x06
     f5c:	f7 81       	ldd	r31, Z+7	; 0x07
     f5e:	e0 2d       	mov	r30, r0
     f60:	84 e0       	ldi	r24, 0x04	; 4
     f62:	e9 39       	cpi	r30, 0x99	; 153
     f64:	f8 07       	cpc	r31, r24
     f66:	39 f5       	brne	.+78     	; 0xfb6 <_ZN8Robotarm18ArmDownReleaseItemEv+0x21a>
	*    @param uint8_t	degrees to turn
	*    @return void Nothing
	*/
	virtual void SetDegrees( uint8_t degrees )
	{
		if ( maxDegrees_ >= degrees )
     f68:	8e 89       	ldd	r24, Y+22	; 0x16
     f6a:	8a 35       	cpi	r24, 0x5A	; 90
     f6c:	a0 f0       	brcs	.+40     	; 0xf96 <_ZN8Robotarm18ArmDownReleaseItemEv+0x1fa>
		{
			percent_ = percentPrDeg * degrees + startpercent_;
     f6e:	20 e0       	ldi	r18, 0x00	; 0
     f70:	30 e0       	ldi	r19, 0x00	; 0
     f72:	44 eb       	ldi	r20, 0xB4	; 180
     f74:	52 e4       	ldi	r21, 0x42	; 66
     f76:	6e 81       	ldd	r22, Y+6	; 0x06
     f78:	7f 81       	ldd	r23, Y+7	; 0x07
     f7a:	88 85       	ldd	r24, Y+8	; 0x08
     f7c:	99 85       	ldd	r25, Y+9	; 0x09
     f7e:	0e 94 8b 1d 	call	0x3b16	; 0x3b16 <__mulsf3>
     f82:	2a 89       	ldd	r18, Y+18	; 0x12
     f84:	3b 89       	ldd	r19, Y+19	; 0x13
     f86:	4c 89       	ldd	r20, Y+20	; 0x14
     f88:	5d 89       	ldd	r21, Y+21	; 0x15
     f8a:	0e 94 d9 1b 	call	0x37b2	; 0x37b2 <__addsf3>
     f8e:	6a 87       	std	Y+10, r22	; 0x0a
     f90:	7b 87       	std	Y+11, r23	; 0x0b
     f92:	8c 87       	std	Y+12, r24	; 0x0c
     f94:	9d 87       	std	Y+13, r25	; 0x0d
	vTaskDelay( 250 / portTICK_RATE_MS );
     f96:	8a ef       	ldi	r24, 0xFA	; 250
     f98:	90 e0       	ldi	r25, 0x00	; 0
}
     f9a:	df 91       	pop	r29
     f9c:	cf 91       	pop	r28
     f9e:	1f 91       	pop	r17
     fa0:	0f 91       	pop	r16
	motors_[5]->SetDegrees(0);
	vTaskDelay( 250 / portTICK_RATE_MS );
	motors_[1]->SetDegrees(90);
	motors_[2]->SetDegrees(90);
	motors_[3]->SetDegrees(90);
	vTaskDelay( 250 / portTICK_RATE_MS );
     fa2:	0c 94 ac 12 	jmp	0x2558	; 0x2558 <vTaskDelay>

void Robotarm::ArmDownReleaseItem()
{
	vTaskDelay( 1500 / portTICK_RATE_MS );
	motors_[1]->SetDegrees(35);
	motors_[2]->SetDegrees(40);
     fa6:	68 e2       	ldi	r22, 0x28	; 40
     fa8:	c8 01       	movw	r24, r16
     faa:	19 95       	eicall
     fac:	52 cf       	rjmp	.-348    	; 0xe52 <_ZN8Robotarm18ArmDownReleaseItemEv+0xb6>
}

void Robotarm::ArmDownReleaseItem()
{
	vTaskDelay( 1500 / portTICK_RATE_MS );
	motors_[1]->SetDegrees(35);
     fae:	63 e2       	ldi	r22, 0x23	; 35
     fb0:	c8 01       	movw	r24, r16
     fb2:	19 95       	eicall
     fb4:	25 cf       	rjmp	.-438    	; 0xe00 <_ZN8Robotarm18ArmDownReleaseItemEv+0x64>
	vTaskDelay( 1500 / portTICK_RATE_MS );
	motors_[5]->SetDegrees(0);
	vTaskDelay( 250 / portTICK_RATE_MS );
	motors_[1]->SetDegrees(90);
	motors_[2]->SetDegrees(90);
	motors_[3]->SetDegrees(90);
     fb6:	6a e5       	ldi	r22, 0x5A	; 90
     fb8:	ce 01       	movw	r24, r28
     fba:	19 95       	eicall
	vTaskDelay( 250 / portTICK_RATE_MS );
     fbc:	8a ef       	ldi	r24, 0xFA	; 250
     fbe:	90 e0       	ldi	r25, 0x00	; 0
}
     fc0:	df 91       	pop	r29
     fc2:	cf 91       	pop	r28
     fc4:	1f 91       	pop	r17
     fc6:	0f 91       	pop	r16
	motors_[5]->SetDegrees(0);
	vTaskDelay( 250 / portTICK_RATE_MS );
	motors_[1]->SetDegrees(90);
	motors_[2]->SetDegrees(90);
	motors_[3]->SetDegrees(90);
	vTaskDelay( 250 / portTICK_RATE_MS );
     fc8:	0c 94 ac 12 	jmp	0x2558	; 0x2558 <vTaskDelay>
	motors_[2]->SetDegrees(40);
	vTaskDelay( 1500 / portTICK_RATE_MS );
	motors_[5]->SetDegrees(0);
	vTaskDelay( 250 / portTICK_RATE_MS );
	motors_[1]->SetDegrees(90);
	motors_[2]->SetDegrees(90);
     fcc:	6a e5       	ldi	r22, 0x5A	; 90
     fce:	c8 01       	movw	r24, r16
     fd0:	19 95       	eicall
     fd2:	be cf       	rjmp	.-132    	; 0xf50 <_ZN8Robotarm18ArmDownReleaseItemEv+0x1b4>
	motors_[1]->SetDegrees(35);
	motors_[2]->SetDegrees(40);
	vTaskDelay( 1500 / portTICK_RATE_MS );
	motors_[5]->SetDegrees(0);
	vTaskDelay( 250 / portTICK_RATE_MS );
	motors_[1]->SetDegrees(90);
     fd4:	6a e5       	ldi	r22, 0x5A	; 90
     fd6:	c8 01       	movw	r24, r16
     fd8:	19 95       	eicall
     fda:	91 cf       	rjmp	.-222    	; 0xefe <_ZN8Robotarm18ArmDownReleaseItemEv+0x162>
{
	vTaskDelay( 1500 / portTICK_RATE_MS );
	motors_[1]->SetDegrees(35);
	motors_[2]->SetDegrees(40);
	vTaskDelay( 1500 / portTICK_RATE_MS );
	motors_[5]->SetDegrees(0);
     fdc:	60 e0       	ldi	r22, 0x00	; 0
     fde:	c8 01       	movw	r24, r16
     fe0:	19 95       	eicall
     fe2:	60 cf       	rjmp	.-320    	; 0xea4 <_ZN8Robotarm18ArmDownReleaseItemEv+0x108>

00000fe4 <_ZN8Robotarm8MoveItemEh>:
	/* Create task to control motors */
	xTaskCreate(this->startMotorImpl,  ( signed char * ) "Motors", configMAIN_STACK_SIZE, this, tskIDLE_PRIORITY, NULL);
}

void Robotarm::MoveItem( uint8_t color )
{
     fe4:	0f 93       	push	r16
     fe6:	1f 93       	push	r17
     fe8:	cf 93       	push	r28
     fea:	df 93       	push	r29
     fec:	ec 01       	movw	r28, r24
	switch ( color )
     fee:	62 30       	cpi	r22, 0x02	; 2
     ff0:	09 f4       	brne	.+2      	; 0xff4 <_ZN8Robotarm8MoveItemEh+0x10>
     ff2:	b9 c0       	rjmp	.+370    	; 0x1166 <_ZN8Robotarm8MoveItemEh+0x182>
     ff4:	18 f1       	brcs	.+70     	; 0x103c <_ZN8Robotarm8MoveItemEh+0x58>
     ff6:	64 30       	cpi	r22, 0x04	; 4
     ff8:	09 f4       	brne	.+2      	; 0xffc <_ZN8Robotarm8MoveItemEh+0x18>
     ffa:	5e c0       	rjmp	.+188    	; 0x10b8 <_ZN8Robotarm8MoveItemEh+0xd4>
     ffc:	08 f4       	brcc	.+2      	; 0x1000 <_ZN8Robotarm8MoveItemEh+0x1c>
     ffe:	98 c0       	rjmp	.+304    	; 0x1130 <_ZN8Robotarm8MoveItemEh+0x14c>
    1000:	65 30       	cpi	r22, 0x05	; 5
    1002:	09 f0       	breq	.+2      	; 0x1006 <_ZN8Robotarm8MoveItemEh+0x22>
    1004:	74 c0       	rjmp	.+232    	; 0x10ee <_ZN8Robotarm8MoveItemEh+0x10a>
		moveBlockToZoneFive();
		vTaskDelay( 500 / portTICK_RATE_MS );
		break;
		
		case 5U:
		grabBlock();
    1006:	26 dd       	rcall	.-1460   	; 0xa54 <_ZN8Robotarm9grabBlockEv>
		vTaskDelay( 500 / portTICK_RATE_MS );
    1008:	84 ef       	ldi	r24, 0xF4	; 244
    100a:	91 e0       	ldi	r25, 0x01	; 1
    100c:	0e 94 ac 12 	call	0x2558	; 0x2558 <vTaskDelay>
	ArmDownReleaseItem();
}

void Robotarm::moveBlockToZoneSix()
{
	motors_[0]->SetDegrees(180);
    1010:	0a 81       	ldd	r16, Y+2	; 0x02
    1012:	1b 81       	ldd	r17, Y+3	; 0x03
    1014:	d8 01       	movw	r26, r16
    1016:	ed 91       	ld	r30, X+
    1018:	fc 91       	ld	r31, X
    101a:	06 80       	ldd	r0, Z+6	; 0x06
    101c:	f7 81       	ldd	r31, Z+7	; 0x07
    101e:	e0 2d       	mov	r30, r0
    1020:	b4 e0       	ldi	r27, 0x04	; 4
    1022:	e9 39       	cpi	r30, 0x99	; 153
    1024:	fb 07       	cpc	r31, r27
    1026:	09 f0       	breq	.+2      	; 0x102a <_ZN8Robotarm8MoveItemEh+0x46>
    1028:	c9 c0       	rjmp	.+402    	; 0x11bc <_ZN8Robotarm8MoveItemEh+0x1d8>
	*    @param uint8_t	degrees to turn
	*    @return void Nothing
	*/
	virtual void SetDegrees( uint8_t degrees )
	{
		if ( maxDegrees_ >= degrees )
    102a:	f8 01       	movw	r30, r16
    102c:	86 89       	ldd	r24, Z+22	; 0x16
    102e:	84 3b       	cpi	r24, 0xB4	; 180
    1030:	c8 f1       	brcs	.+114    	; 0x10a4 <_ZN8Robotarm8MoveItemEh+0xc0>
		{
			percent_ = percentPrDeg * degrees + startpercent_;
    1032:	20 e0       	ldi	r18, 0x00	; 0
    1034:	30 e0       	ldi	r19, 0x00	; 0
    1036:	44 e3       	ldi	r20, 0x34	; 52
    1038:	53 e4       	ldi	r21, 0x43	; 67
    103a:	20 c0       	rjmp	.+64     	; 0x107c <_ZN8Robotarm8MoveItemEh+0x98>
	xTaskCreate(this->startMotorImpl,  ( signed char * ) "Motors", configMAIN_STACK_SIZE, this, tskIDLE_PRIORITY, NULL);
}

void Robotarm::MoveItem( uint8_t color )
{
	switch ( color )
    103c:	66 23       	and	r22, r22
    103e:	09 f4       	brne	.+2      	; 0x1042 <_ZN8Robotarm8MoveItemEh+0x5e>
    1040:	5b c0       	rjmp	.+182    	; 0x10f8 <_ZN8Robotarm8MoveItemEh+0x114>
    1042:	61 30       	cpi	r22, 0x01	; 1
    1044:	09 f0       	breq	.+2      	; 0x1048 <_ZN8Robotarm8MoveItemEh+0x64>
		moveBlockToZoneOne();
		vTaskDelay( 500 / portTICK_RATE_MS );
		break;
		
		case 1U:
		grabBlock();
    1046:	53 c0       	rjmp	.+166    	; 0x10ee <_ZN8Robotarm8MoveItemEh+0x10a>
    1048:	05 dd       	rcall	.-1526   	; 0xa54 <_ZN8Robotarm9grabBlockEv>
		vTaskDelay( 500 / portTICK_RATE_MS );
    104a:	84 ef       	ldi	r24, 0xF4	; 244
    104c:	91 e0       	ldi	r25, 0x01	; 1
    104e:	0e 94 ac 12 	call	0x2558	; 0x2558 <vTaskDelay>
	ArmDownReleaseItem();
}

void Robotarm::moveBlockToZoneTwo()
{
	motors_[0]->SetDegrees(68);
    1052:	0a 81       	ldd	r16, Y+2	; 0x02
    1054:	1b 81       	ldd	r17, Y+3	; 0x03
    1056:	d8 01       	movw	r26, r16
    1058:	ed 91       	ld	r30, X+
    105a:	fc 91       	ld	r31, X
    105c:	06 80       	ldd	r0, Z+6	; 0x06
    105e:	f7 81       	ldd	r31, Z+7	; 0x07
    1060:	e0 2d       	mov	r30, r0
    1062:	b4 e0       	ldi	r27, 0x04	; 4
    1064:	e9 39       	cpi	r30, 0x99	; 153
    1066:	fb 07       	cpc	r31, r27
    1068:	09 f0       	breq	.+2      	; 0x106c <_ZN8Robotarm8MoveItemEh+0x88>
    106a:	98 c0       	rjmp	.+304    	; 0x119c <_ZN8Robotarm8MoveItemEh+0x1b8>
	*    @param uint8_t	degrees to turn
	*    @return void Nothing
	*/
	virtual void SetDegrees( uint8_t degrees )
	{
		if ( maxDegrees_ >= degrees )
    106c:	f8 01       	movw	r30, r16
    106e:	86 89       	ldd	r24, Z+22	; 0x16
    1070:	84 34       	cpi	r24, 0x44	; 68
    1072:	c0 f0       	brcs	.+48     	; 0x10a4 <_ZN8Robotarm8MoveItemEh+0xc0>
		{
			percent_ = percentPrDeg * degrees + startpercent_;
    1074:	20 e0       	ldi	r18, 0x00	; 0
    1076:	30 e0       	ldi	r19, 0x00	; 0
    1078:	48 e8       	ldi	r20, 0x88	; 136
    107a:	52 e4       	ldi	r21, 0x42	; 66
    107c:	66 81       	ldd	r22, Z+6	; 0x06
    107e:	77 81       	ldd	r23, Z+7	; 0x07
    1080:	80 85       	ldd	r24, Z+8	; 0x08
    1082:	91 85       	ldd	r25, Z+9	; 0x09
    1084:	0e 94 8b 1d 	call	0x3b16	; 0x3b16 <__mulsf3>
    1088:	d8 01       	movw	r26, r16
    108a:	52 96       	adiw	r26, 0x12	; 18
    108c:	2d 91       	ld	r18, X+
    108e:	3d 91       	ld	r19, X+
    1090:	4d 91       	ld	r20, X+
    1092:	5c 91       	ld	r21, X
    1094:	55 97       	sbiw	r26, 0x15	; 21
    1096:	0e 94 d9 1b 	call	0x37b2	; 0x37b2 <__addsf3>
    109a:	f8 01       	movw	r30, r16
    109c:	62 87       	std	Z+10, r22	; 0x0a
    109e:	73 87       	std	Z+11, r23	; 0x0b
    10a0:	84 87       	std	Z+12, r24	; 0x0c
}

void Robotarm::moveBlockToZoneOne()
{
	motors_[0]->SetDegrees(40);
	ArmDownReleaseItem();
    10a2:	95 87       	std	Z+13, r25	; 0x0d
    10a4:	ce 01       	movw	r24, r28
    10a6:	7a de       	rcall	.-780    	; 0xd9c <_ZN8Robotarm18ArmDownReleaseItemEv>
	{
		case 0U:
		grabBlock();
		vTaskDelay( 500 / portTICK_RATE_MS ); // This might not be needed!!! it can be added in Robotarm!!!! we will seeee later
		moveBlockToZoneOne();
		vTaskDelay( 500 / portTICK_RATE_MS );
    10a8:	84 ef       	ldi	r24, 0xF4	; 244
    10aa:	91 e0       	ldi	r25, 0x01	; 1
		break;
		
		default:
		break;
	}
}
    10ac:	df 91       	pop	r29
    10ae:	cf 91       	pop	r28
    10b0:	1f 91       	pop	r17
	{
		case 0U:
		grabBlock();
		vTaskDelay( 500 / portTICK_RATE_MS ); // This might not be needed!!! it can be added in Robotarm!!!! we will seeee later
		moveBlockToZoneOne();
		vTaskDelay( 500 / portTICK_RATE_MS );
    10b2:	0f 91       	pop	r16
    10b4:	0c 94 ac 12 	jmp	0x2558	; 0x2558 <vTaskDelay>
		moveBlockToZoneFour();
		vTaskDelay( 500 / portTICK_RATE_MS );
		break;
		
		case 4U:
		grabBlock();
    10b8:	cd dc       	rcall	.-1638   	; 0xa54 <_ZN8Robotarm9grabBlockEv>
		vTaskDelay( 500 / portTICK_RATE_MS );
    10ba:	84 ef       	ldi	r24, 0xF4	; 244
    10bc:	91 e0       	ldi	r25, 0x01	; 1
    10be:	0e 94 ac 12 	call	0x2558	; 0x2558 <vTaskDelay>
	ArmDownReleaseItem();
}

void Robotarm::moveBlockToZoneFive()
{
	motors_[0]->SetDegrees(152);
    10c2:	0a 81       	ldd	r16, Y+2	; 0x02
    10c4:	1b 81       	ldd	r17, Y+3	; 0x03
    10c6:	d8 01       	movw	r26, r16
    10c8:	ed 91       	ld	r30, X+
    10ca:	fc 91       	ld	r31, X
    10cc:	06 80       	ldd	r0, Z+6	; 0x06
    10ce:	f7 81       	ldd	r31, Z+7	; 0x07
    10d0:	e0 2d       	mov	r30, r0
    10d2:	b4 e0       	ldi	r27, 0x04	; 4
    10d4:	e9 39       	cpi	r30, 0x99	; 153
    10d6:	fb 07       	cpc	r31, r27
    10d8:	09 f0       	breq	.+2      	; 0x10dc <_ZN8Robotarm8MoveItemEh+0xf8>
    10da:	74 c0       	rjmp	.+232    	; 0x11c4 <_ZN8Robotarm8MoveItemEh+0x1e0>
	*    @param uint8_t	degrees to turn
	*    @return void Nothing
	*/
	virtual void SetDegrees( uint8_t degrees )
	{
		if ( maxDegrees_ >= degrees )
    10dc:	f8 01       	movw	r30, r16
    10de:	86 89       	ldd	r24, Z+22	; 0x16
    10e0:	88 39       	cpi	r24, 0x98	; 152
    10e2:	00 f3       	brcs	.-64     	; 0x10a4 <_ZN8Robotarm8MoveItemEh+0xc0>
		{
			percent_ = percentPrDeg * degrees + startpercent_;
    10e4:	20 e0       	ldi	r18, 0x00	; 0
    10e6:	30 e0       	ldi	r19, 0x00	; 0
    10e8:	48 e1       	ldi	r20, 0x18	; 24
    10ea:	53 e4       	ldi	r21, 0x43	; 67
    10ec:	c7 cf       	rjmp	.-114    	; 0x107c <_ZN8Robotarm8MoveItemEh+0x98>
		break;
		
		default:
		break;
	}
}
    10ee:	df 91       	pop	r29
    10f0:	cf 91       	pop	r28
    10f2:	1f 91       	pop	r17
    10f4:	0f 91       	pop	r16
void Robotarm::MoveItem( uint8_t color )
{
	switch ( color )
	{
		case 0U:
		grabBlock();
    10f6:	08 95       	ret
    10f8:	ad dc       	rcall	.-1702   	; 0xa54 <_ZN8Robotarm9grabBlockEv>
		vTaskDelay( 500 / portTICK_RATE_MS ); // This might not be needed!!! it can be added in Robotarm!!!! we will seeee later
    10fa:	84 ef       	ldi	r24, 0xF4	; 244
    10fc:	91 e0       	ldi	r25, 0x01	; 1
    10fe:	0e 94 ac 12 	call	0x2558	; 0x2558 <vTaskDelay>
	motors_[3]->SetDegrees(70);
}

void Robotarm::moveBlockToZoneOne()
{
	motors_[0]->SetDegrees(40);
    1102:	0a 81       	ldd	r16, Y+2	; 0x02
    1104:	1b 81       	ldd	r17, Y+3	; 0x03
    1106:	d8 01       	movw	r26, r16
    1108:	ed 91       	ld	r30, X+
    110a:	fc 91       	ld	r31, X
    110c:	06 80       	ldd	r0, Z+6	; 0x06
    110e:	f7 81       	ldd	r31, Z+7	; 0x07
    1110:	e0 2d       	mov	r30, r0
    1112:	b4 e0       	ldi	r27, 0x04	; 4
    1114:	e9 39       	cpi	r30, 0x99	; 153
    1116:	fb 07       	cpc	r31, r27
    1118:	09 f0       	breq	.+2      	; 0x111c <_ZN8Robotarm8MoveItemEh+0x138>
    111a:	4c c0       	rjmp	.+152    	; 0x11b4 <_ZN8Robotarm8MoveItemEh+0x1d0>
	*    @param uint8_t	degrees to turn
	*    @return void Nothing
	*/
	virtual void SetDegrees( uint8_t degrees )
	{
		if ( maxDegrees_ >= degrees )
    111c:	f8 01       	movw	r30, r16
    111e:	86 89       	ldd	r24, Z+22	; 0x16
    1120:	88 32       	cpi	r24, 0x28	; 40
    1122:	08 f4       	brcc	.+2      	; 0x1126 <_ZN8Robotarm8MoveItemEh+0x142>
    1124:	bf cf       	rjmp	.-130    	; 0x10a4 <_ZN8Robotarm8MoveItemEh+0xc0>
		{
			percent_ = percentPrDeg * degrees + startpercent_;
    1126:	20 e0       	ldi	r18, 0x00	; 0
    1128:	30 e0       	ldi	r19, 0x00	; 0
    112a:	40 e2       	ldi	r20, 0x20	; 32
    112c:	52 e4       	ldi	r21, 0x42	; 66
		moveBlockToZoneThree();
		vTaskDelay( 500 / portTICK_RATE_MS );
		break;
		
		case 3U:
		grabBlock();
    112e:	a6 cf       	rjmp	.-180    	; 0x107c <_ZN8Robotarm8MoveItemEh+0x98>
    1130:	91 dc       	rcall	.-1758   	; 0xa54 <_ZN8Robotarm9grabBlockEv>
		vTaskDelay( 500 / portTICK_RATE_MS );
    1132:	84 ef       	ldi	r24, 0xF4	; 244
    1134:	91 e0       	ldi	r25, 0x01	; 1
    1136:	0e 94 ac 12 	call	0x2558	; 0x2558 <vTaskDelay>
	ArmDownReleaseItem();
}

void Robotarm::moveBlockToZoneFour()
{
	motors_[0]->SetDegrees(124);
    113a:	0a 81       	ldd	r16, Y+2	; 0x02
    113c:	1b 81       	ldd	r17, Y+3	; 0x03
    113e:	d8 01       	movw	r26, r16
    1140:	ed 91       	ld	r30, X+
    1142:	fc 91       	ld	r31, X
    1144:	06 80       	ldd	r0, Z+6	; 0x06
    1146:	f7 81       	ldd	r31, Z+7	; 0x07
    1148:	e0 2d       	mov	r30, r0
    114a:	b4 e0       	ldi	r27, 0x04	; 4
    114c:	e9 39       	cpi	r30, 0x99	; 153
    114e:	fb 07       	cpc	r31, r27
    1150:	69 f5       	brne	.+90     	; 0x11ac <_ZN8Robotarm8MoveItemEh+0x1c8>
	*    @param uint8_t	degrees to turn
	*    @return void Nothing
	*/
	virtual void SetDegrees( uint8_t degrees )
	{
		if ( maxDegrees_ >= degrees )
    1152:	f8 01       	movw	r30, r16
    1154:	86 89       	ldd	r24, Z+22	; 0x16
    1156:	8c 37       	cpi	r24, 0x7C	; 124
    1158:	08 f4       	brcc	.+2      	; 0x115c <_ZN8Robotarm8MoveItemEh+0x178>
		{
			percent_ = percentPrDeg * degrees + startpercent_;
    115a:	a4 cf       	rjmp	.-184    	; 0x10a4 <_ZN8Robotarm8MoveItemEh+0xc0>
    115c:	20 e0       	ldi	r18, 0x00	; 0
    115e:	30 e0       	ldi	r19, 0x00	; 0
    1160:	48 ef       	ldi	r20, 0xF8	; 248
    1162:	52 e4       	ldi	r21, 0x42	; 66
		moveBlockToZoneTwo();
		vTaskDelay( 500 / portTICK_RATE_MS );
		break;
		
		case 2U:
		grabBlock();
    1164:	8b cf       	rjmp	.-234    	; 0x107c <_ZN8Robotarm8MoveItemEh+0x98>
    1166:	76 dc       	rcall	.-1812   	; 0xa54 <_ZN8Robotarm9grabBlockEv>
		vTaskDelay( 500 / portTICK_RATE_MS );
    1168:	84 ef       	ldi	r24, 0xF4	; 244
    116a:	91 e0       	ldi	r25, 0x01	; 1
    116c:	0e 94 ac 12 	call	0x2558	; 0x2558 <vTaskDelay>
	ArmDownReleaseItem();
}

void Robotarm::moveBlockToZoneThree()
{
	motors_[0]->SetDegrees(96);
    1170:	0a 81       	ldd	r16, Y+2	; 0x02
    1172:	1b 81       	ldd	r17, Y+3	; 0x03
    1174:	d8 01       	movw	r26, r16
    1176:	ed 91       	ld	r30, X+
    1178:	fc 91       	ld	r31, X
    117a:	06 80       	ldd	r0, Z+6	; 0x06
    117c:	f7 81       	ldd	r31, Z+7	; 0x07
    117e:	e0 2d       	mov	r30, r0
    1180:	b4 e0       	ldi	r27, 0x04	; 4
    1182:	e9 39       	cpi	r30, 0x99	; 153
    1184:	fb 07       	cpc	r31, r27
    1186:	71 f4       	brne	.+28     	; 0x11a4 <_ZN8Robotarm8MoveItemEh+0x1c0>
	*    @param uint8_t	degrees to turn
	*    @return void Nothing
	*/
	virtual void SetDegrees( uint8_t degrees )
	{
		if ( maxDegrees_ >= degrees )
    1188:	f8 01       	movw	r30, r16
    118a:	86 89       	ldd	r24, Z+22	; 0x16
    118c:	80 36       	cpi	r24, 0x60	; 96
    118e:	08 f4       	brcc	.+2      	; 0x1192 <_ZN8Robotarm8MoveItemEh+0x1ae>
    1190:	89 cf       	rjmp	.-238    	; 0x10a4 <_ZN8Robotarm8MoveItemEh+0xc0>
		{
			percent_ = percentPrDeg * degrees + startpercent_;
    1192:	20 e0       	ldi	r18, 0x00	; 0
    1194:	30 e0       	ldi	r19, 0x00	; 0
    1196:	40 ec       	ldi	r20, 0xC0	; 192
    1198:	52 e4       	ldi	r21, 0x42	; 66
    119a:	70 cf       	rjmp	.-288    	; 0x107c <_ZN8Robotarm8MoveItemEh+0x98>
	ArmDownReleaseItem();
}

void Robotarm::moveBlockToZoneTwo()
{
	motors_[0]->SetDegrees(68);
    119c:	64 e4       	ldi	r22, 0x44	; 68
    119e:	c8 01       	movw	r24, r16
    11a0:	19 95       	eicall
    11a2:	80 cf       	rjmp	.-256    	; 0x10a4 <_ZN8Robotarm8MoveItemEh+0xc0>
	ArmDownReleaseItem();
}

void Robotarm::moveBlockToZoneThree()
{
	motors_[0]->SetDegrees(96);
    11a4:	60 e6       	ldi	r22, 0x60	; 96
    11a6:	c8 01       	movw	r24, r16
    11a8:	19 95       	eicall
    11aa:	7c cf       	rjmp	.-264    	; 0x10a4 <_ZN8Robotarm8MoveItemEh+0xc0>
	ArmDownReleaseItem();
}

void Robotarm::moveBlockToZoneFour()
{
	motors_[0]->SetDegrees(124);
    11ac:	6c e7       	ldi	r22, 0x7C	; 124
    11ae:	c8 01       	movw	r24, r16
    11b0:	19 95       	eicall
    11b2:	78 cf       	rjmp	.-272    	; 0x10a4 <_ZN8Robotarm8MoveItemEh+0xc0>
	motors_[3]->SetDegrees(70);
}

void Robotarm::moveBlockToZoneOne()
{
	motors_[0]->SetDegrees(40);
    11b4:	68 e2       	ldi	r22, 0x28	; 40
    11b6:	c8 01       	movw	r24, r16
    11b8:	19 95       	eicall
    11ba:	74 cf       	rjmp	.-280    	; 0x10a4 <_ZN8Robotarm8MoveItemEh+0xc0>
	ArmDownReleaseItem();
}

void Robotarm::moveBlockToZoneSix()
{
	motors_[0]->SetDegrees(180);
    11bc:	64 eb       	ldi	r22, 0xB4	; 180
    11be:	c8 01       	movw	r24, r16
    11c0:	19 95       	eicall
    11c2:	70 cf       	rjmp	.-288    	; 0x10a4 <_ZN8Robotarm8MoveItemEh+0xc0>
	ArmDownReleaseItem();
}

void Robotarm::moveBlockToZoneFive()
{
	motors_[0]->SetDegrees(152);
    11c4:	68 e9       	ldi	r22, 0x98	; 152
    11c6:	c8 01       	movw	r24, r16
    11c8:	19 95       	eicall
    11ca:	6c cf       	rjmp	.-296    	; 0x10a4 <_ZN8Robotarm8MoveItemEh+0xc0>

000011cc <_ZN2M1D1Ev>:
	SetDegrees( 90 );
	tmr1Ptr_->setDutyCycleComA( percent_ );
	oldPercent_ = percent_;
} 

M1::~M1()
    11cc:	08 95       	ret

000011ce <_ZN2M1D0Ev>:
{
}
    11ce:	72 cb       	rjmp	.-2332   	; 0x8b4 <_ZdlPv>

000011d0 <_ZN2M19TurnMotorEv>:

void M1::TurnMotor()
{
    11d0:	4f 92       	push	r4
    11d2:	5f 92       	push	r5
    11d4:	6f 92       	push	r6
    11d6:	7f 92       	push	r7
    11d8:	8f 92       	push	r8
    11da:	9f 92       	push	r9
    11dc:	af 92       	push	r10
    11de:	bf 92       	push	r11
    11e0:	cf 92       	push	r12
    11e2:	df 92       	push	r13
    11e4:	ef 92       	push	r14
    11e6:	ff 92       	push	r15
    11e8:	cf 93       	push	r28
    11ea:	df 93       	push	r29
    11ec:	ec 01       	movw	r28, r24
	if ( percent_ > oldPercent_ + PERCENT_PR_TICK )
    11ee:	8a 84       	ldd	r8, Y+10	; 0x0a
    11f0:	9b 84       	ldd	r9, Y+11	; 0x0b
    11f2:	ac 84       	ldd	r10, Y+12	; 0x0c
    11f4:	bd 84       	ldd	r11, Y+13	; 0x0d
    11f6:	ce 84       	ldd	r12, Y+14	; 0x0e
    11f8:	df 84       	ldd	r13, Y+15	; 0x0f
    11fa:	e8 88       	ldd	r14, Y+16	; 0x10
    11fc:	f9 88       	ldd	r15, Y+17	; 0x11
    11fe:	20 e0       	ldi	r18, 0x00	; 0
    1200:	30 e0       	ldi	r19, 0x00	; 0
    1202:	40 e8       	ldi	r20, 0x80	; 128
    1204:	5d e3       	ldi	r21, 0x3D	; 61
    1206:	c7 01       	movw	r24, r14
    1208:	b6 01       	movw	r22, r12
    120a:	0e 94 d9 1b 	call	0x37b2	; 0x37b2 <__addsf3>
    120e:	2b 01       	movw	r4, r22
    1210:	3c 01       	movw	r6, r24
    1212:	9b 01       	movw	r18, r22
    1214:	ac 01       	movw	r20, r24
    1216:	c5 01       	movw	r24, r10
    1218:	b4 01       	movw	r22, r8
    121a:	0e 94 87 1d 	call	0x3b0e	; 0x3b0e <__gesf2>
    121e:	18 16       	cp	r1, r24
    1220:	d4 f1       	brlt	.+116    	; 0x1296 <_ZN2M19TurnMotorEv+0xc6>
	{
		oldPercent_ += PERCENT_PR_TICK;
		tmr1Ptr_->setDutyCycleComA( oldPercent_ );
		vTaskDelay( delay_ / portTICK_RATE_MS );
	}
	else if ( percent_ < oldPercent_ )
    1222:	a7 01       	movw	r20, r14
    1224:	96 01       	movw	r18, r12
    1226:	c5 01       	movw	r24, r10
    1228:	b4 01       	movw	r22, r8
    122a:	0e 94 3d 1c 	call	0x387a	; 0x387a <__cmpsf2>
    122e:	87 fd       	sbrc	r24, 7
    1230:	0f c0       	rjmp	.+30     	; 0x1250 <_ZN2M19TurnMotorEv+0x80>
	{
		oldPercent_ -= PERCENT_PR_TICK;
		tmr1Ptr_->setDutyCycleComA( oldPercent_ );
		vTaskDelay( delay_ / portTICK_RATE_MS );
	}
}
    1232:	df 91       	pop	r29
    1234:	cf 91       	pop	r28
    1236:	ff 90       	pop	r15
    1238:	ef 90       	pop	r14
    123a:	df 90       	pop	r13
    123c:	cf 90       	pop	r12
    123e:	bf 90       	pop	r11
    1240:	af 90       	pop	r10
    1242:	9f 90       	pop	r9
    1244:	8f 90       	pop	r8
    1246:	7f 90       	pop	r7
    1248:	6f 90       	pop	r6
    124a:	5f 90       	pop	r5
    124c:	4f 90       	pop	r4
    124e:	08 95       	ret
		tmr1Ptr_->setDutyCycleComA( oldPercent_ );
		vTaskDelay( delay_ / portTICK_RATE_MS );
	}
	else if ( percent_ < oldPercent_ )
	{
		oldPercent_ -= PERCENT_PR_TICK;
    1250:	20 e0       	ldi	r18, 0x00	; 0
    1252:	30 e0       	ldi	r19, 0x00	; 0
    1254:	40 e8       	ldi	r20, 0x80	; 128
    1256:	5d e3       	ldi	r21, 0x3D	; 61
    1258:	c7 01       	movw	r24, r14
    125a:	b6 01       	movw	r22, r12
    125c:	0e 94 d8 1b 	call	0x37b0	; 0x37b0 <__subsf3>
    1260:	ab 01       	movw	r20, r22
    1262:	bc 01       	movw	r22, r24
    1264:	4e 87       	std	Y+14, r20	; 0x0e
    1266:	5f 87       	std	Y+15, r21	; 0x0f
    1268:	68 8b       	std	Y+16, r22	; 0x10
    126a:	79 8b       	std	Y+17, r23	; 0x11
		tmr1Ptr_->setDutyCycleComA( oldPercent_ );
    126c:	8a 81       	ldd	r24, Y+2	; 0x02
    126e:	9b 81       	ldd	r25, Y+3	; 0x03
    1270:	80 d3       	rcall	.+1792   	; 0x1972 <_ZN6Timer116setDutyCycleComAEf>
		vTaskDelay( delay_ / portTICK_RATE_MS );
    1272:	8f 89       	ldd	r24, Y+23	; 0x17
    1274:	98 8d       	ldd	r25, Y+24	; 0x18
	}
}
    1276:	df 91       	pop	r29
    1278:	cf 91       	pop	r28
    127a:	ff 90       	pop	r15
    127c:	ef 90       	pop	r14
    127e:	df 90       	pop	r13
    1280:	cf 90       	pop	r12
    1282:	bf 90       	pop	r11
    1284:	af 90       	pop	r10
    1286:	9f 90       	pop	r9
    1288:	8f 90       	pop	r8
    128a:	7f 90       	pop	r7
    128c:	6f 90       	pop	r6
    128e:	5f 90       	pop	r5
    1290:	4f 90       	pop	r4
	}
	else if ( percent_ < oldPercent_ )
	{
		oldPercent_ -= PERCENT_PR_TICK;
		tmr1Ptr_->setDutyCycleComA( oldPercent_ );
		vTaskDelay( delay_ / portTICK_RATE_MS );
    1292:	0c 94 ac 12 	jmp	0x2558	; 0x2558 <vTaskDelay>

void M1::TurnMotor()
{
	if ( percent_ > oldPercent_ + PERCENT_PR_TICK )
	{
		oldPercent_ += PERCENT_PR_TICK;
    1296:	4e 86       	std	Y+14, r4	; 0x0e
    1298:	5f 86       	std	Y+15, r5	; 0x0f
    129a:	68 8a       	std	Y+16, r6	; 0x10
    129c:	79 8a       	std	Y+17, r7	; 0x11
		tmr1Ptr_->setDutyCycleComA( oldPercent_ );
    129e:	b3 01       	movw	r22, r6
    12a0:	a2 01       	movw	r20, r4
    12a2:	e4 cf       	rjmp	.-56     	; 0x126c <_ZN2M19TurnMotorEv+0x9c>

000012a4 <_ZN2M1C1EP6Timer1>:
* Author: jespe
*/

#include "M1.h"

M1::M1( Timer1* tmr )
    12a4:	cf 93       	push	r28
    12a6:	df 93       	push	r29
    12a8:	ec 01       	movw	r28, r24
    12aa:	cb 01       	movw	r24, r22
    12ac:	20 eb       	ldi	r18, 0xB0	; 176
    12ae:	32 e0       	ldi	r19, 0x02	; 2
    12b0:	39 83       	std	Y+1, r19	; 0x01
    12b2:	28 83       	st	Y, r18
{
	/* Store timer pointer */
	tmr1Ptr_ = tmr;
    12b4:	7b 83       	std	Y+3, r23	; 0x03
    12b6:	6a 83       	std	Y+2, r22	; 0x02
	
	/* This value is number of percent to add or subtract pr degree. */
	percentPrDeg = 0.0555555555555556;
    12b8:	49 e3       	ldi	r20, 0x39	; 57
    12ba:	5e e8       	ldi	r21, 0x8E	; 142
    12bc:	63 e6       	ldi	r22, 0x63	; 99
    12be:	7d e3       	ldi	r23, 0x3D	; 61
    12c0:	4e 83       	std	Y+6, r20	; 0x06
    12c2:	5f 83       	std	Y+7, r21	; 0x07
    12c4:	68 87       	std	Y+8, r22	; 0x08
    12c6:	79 87       	std	Y+9, r23	; 0x09
	
	/* This value is the lowest duty cycle percentage needed to make motor turn. */
	startpercent_ = 2.5;
    12c8:	40 e0       	ldi	r20, 0x00	; 0
    12ca:	50 e0       	ldi	r21, 0x00	; 0
    12cc:	60 e2       	ldi	r22, 0x20	; 32
    12ce:	70 e4       	ldi	r23, 0x40	; 64
    12d0:	4a 8b       	std	Y+18, r20	; 0x12
    12d2:	5b 8b       	std	Y+19, r21	; 0x13
    12d4:	6c 8b       	std	Y+20, r22	; 0x14
    12d6:	7d 8b       	std	Y+21, r23	; 0x15
	
	/* This value is the delay on motor. A lower value makes motors go faster and higher value makes motors go slower. */
	delay_ = 10;
    12d8:	2a e0       	ldi	r18, 0x0A	; 10
    12da:	30 e0       	ldi	r19, 0x00	; 0
    12dc:	38 8f       	std	Y+24, r19	; 0x18
    12de:	2f 8b       	std	Y+23, r18	; 0x17
	
	/* This value is the maximum number of degrees the motor can turn */
	maxDegrees_ = 180;
    12e0:	24 eb       	ldi	r18, 0xB4	; 180
    12e2:	2e 8b       	std	Y+22, r18	; 0x16
    12e4:	40 e0       	ldi	r20, 0x00	; 0
    12e6:	50 e0       	ldi	r21, 0x00	; 0
    12e8:	60 ef       	ldi	r22, 0xF0	; 240
    12ea:	70 e4       	ldi	r23, 0x40	; 64
    12ec:	4a 87       	std	Y+10, r20	; 0x0a
    12ee:	5b 87       	std	Y+11, r21	; 0x0b
    12f0:	6c 87       	std	Y+12, r22	; 0x0c
    12f2:	7d 87       	std	Y+13, r23	; 0x0d
	
	/* Set motor to default startup value */
	SetDegrees( 90 );
	tmr1Ptr_->setDutyCycleComA( percent_ );
    12f4:	3e d3       	rcall	.+1660   	; 0x1972 <_ZN6Timer116setDutyCycleComAEf>
	oldPercent_ = percent_;
    12f6:	8a 85       	ldd	r24, Y+10	; 0x0a
    12f8:	9b 85       	ldd	r25, Y+11	; 0x0b
    12fa:	ac 85       	ldd	r26, Y+12	; 0x0c
    12fc:	bd 85       	ldd	r27, Y+13	; 0x0d
    12fe:	8e 87       	std	Y+14, r24	; 0x0e
    1300:	9f 87       	std	Y+15, r25	; 0x0f
    1302:	a8 8b       	std	Y+16, r26	; 0x10
    1304:	b9 8b       	std	Y+17, r27	; 0x11
} 
    1306:	df 91       	pop	r29
    1308:	cf 91       	pop	r28
    130a:	08 95       	ret

0000130c <_ZN2M2D1Ev>:
	SetDegrees( 90 );
	tmr1Ptr_->setDutyCycleComB( percent_ );
	oldPercent_ = percent_;
}

M2::~M2()
    130c:	08 95       	ret

0000130e <_ZN2M2D0Ev>:
{
}
    130e:	d2 ca       	rjmp	.-2652   	; 0x8b4 <_ZdlPv>

00001310 <_ZN2M29TurnMotorEv>:

void M2::TurnMotor()
{
    1310:	4f 92       	push	r4
    1312:	5f 92       	push	r5
    1314:	6f 92       	push	r6
    1316:	7f 92       	push	r7
    1318:	8f 92       	push	r8
    131a:	9f 92       	push	r9
    131c:	af 92       	push	r10
    131e:	bf 92       	push	r11
    1320:	cf 92       	push	r12
    1322:	df 92       	push	r13
    1324:	ef 92       	push	r14
    1326:	ff 92       	push	r15
    1328:	cf 93       	push	r28
    132a:	df 93       	push	r29
    132c:	ec 01       	movw	r28, r24
	if ( percent_ > oldPercent_ + PERCENT_PR_TICK )
    132e:	8a 84       	ldd	r8, Y+10	; 0x0a
    1330:	9b 84       	ldd	r9, Y+11	; 0x0b
    1332:	ac 84       	ldd	r10, Y+12	; 0x0c
    1334:	bd 84       	ldd	r11, Y+13	; 0x0d
    1336:	ce 84       	ldd	r12, Y+14	; 0x0e
    1338:	df 84       	ldd	r13, Y+15	; 0x0f
    133a:	e8 88       	ldd	r14, Y+16	; 0x10
    133c:	f9 88       	ldd	r15, Y+17	; 0x11
    133e:	20 e0       	ldi	r18, 0x00	; 0
    1340:	30 e0       	ldi	r19, 0x00	; 0
    1342:	40 e8       	ldi	r20, 0x80	; 128
    1344:	5d e3       	ldi	r21, 0x3D	; 61
    1346:	c7 01       	movw	r24, r14
    1348:	b6 01       	movw	r22, r12
    134a:	0e 94 d9 1b 	call	0x37b2	; 0x37b2 <__addsf3>
    134e:	2b 01       	movw	r4, r22
    1350:	3c 01       	movw	r6, r24
    1352:	9b 01       	movw	r18, r22
    1354:	ac 01       	movw	r20, r24
    1356:	c5 01       	movw	r24, r10
    1358:	b4 01       	movw	r22, r8
    135a:	0e 94 87 1d 	call	0x3b0e	; 0x3b0e <__gesf2>
    135e:	18 16       	cp	r1, r24
    1360:	d4 f1       	brlt	.+116    	; 0x13d6 <_ZN2M29TurnMotorEv+0xc6>
	{
		oldPercent_ += PERCENT_PR_TICK;
		tmr1Ptr_->setDutyCycleComB( oldPercent_ );
		vTaskDelay( delay_ / portTICK_RATE_MS );
	}
	else if ( percent_ < oldPercent_ )
    1362:	a7 01       	movw	r20, r14
    1364:	96 01       	movw	r18, r12
    1366:	c5 01       	movw	r24, r10
    1368:	b4 01       	movw	r22, r8
    136a:	0e 94 3d 1c 	call	0x387a	; 0x387a <__cmpsf2>
    136e:	87 fd       	sbrc	r24, 7
    1370:	0f c0       	rjmp	.+30     	; 0x1390 <_ZN2M29TurnMotorEv+0x80>
	{
		oldPercent_ -= PERCENT_PR_TICK;
		tmr1Ptr_->setDutyCycleComB( oldPercent_ );
		vTaskDelay( delay_ / portTICK_RATE_MS );
	}
}
    1372:	df 91       	pop	r29
    1374:	cf 91       	pop	r28
    1376:	ff 90       	pop	r15
    1378:	ef 90       	pop	r14
    137a:	df 90       	pop	r13
    137c:	cf 90       	pop	r12
    137e:	bf 90       	pop	r11
    1380:	af 90       	pop	r10
    1382:	9f 90       	pop	r9
    1384:	8f 90       	pop	r8
    1386:	7f 90       	pop	r7
    1388:	6f 90       	pop	r6
    138a:	5f 90       	pop	r5
    138c:	4f 90       	pop	r4
    138e:	08 95       	ret
		tmr1Ptr_->setDutyCycleComB( oldPercent_ );
		vTaskDelay( delay_ / portTICK_RATE_MS );
	}
	else if ( percent_ < oldPercent_ )
	{
		oldPercent_ -= PERCENT_PR_TICK;
    1390:	20 e0       	ldi	r18, 0x00	; 0
    1392:	30 e0       	ldi	r19, 0x00	; 0
    1394:	40 e8       	ldi	r20, 0x80	; 128
    1396:	5d e3       	ldi	r21, 0x3D	; 61
    1398:	c7 01       	movw	r24, r14
    139a:	b6 01       	movw	r22, r12
    139c:	0e 94 d8 1b 	call	0x37b0	; 0x37b0 <__subsf3>
    13a0:	ab 01       	movw	r20, r22
    13a2:	bc 01       	movw	r22, r24
    13a4:	4e 87       	std	Y+14, r20	; 0x0e
    13a6:	5f 87       	std	Y+15, r21	; 0x0f
    13a8:	68 8b       	std	Y+16, r22	; 0x10
    13aa:	79 8b       	std	Y+17, r23	; 0x11
		tmr1Ptr_->setDutyCycleComB( oldPercent_ );
    13ac:	8a 81       	ldd	r24, Y+2	; 0x02
    13ae:	9b 81       	ldd	r25, Y+3	; 0x03
    13b0:	09 d3       	rcall	.+1554   	; 0x19c4 <_ZN6Timer116setDutyCycleComBEf>
		vTaskDelay( delay_ / portTICK_RATE_MS );
    13b2:	8f 89       	ldd	r24, Y+23	; 0x17
    13b4:	98 8d       	ldd	r25, Y+24	; 0x18
	}
}
    13b6:	df 91       	pop	r29
    13b8:	cf 91       	pop	r28
    13ba:	ff 90       	pop	r15
    13bc:	ef 90       	pop	r14
    13be:	df 90       	pop	r13
    13c0:	cf 90       	pop	r12
    13c2:	bf 90       	pop	r11
    13c4:	af 90       	pop	r10
    13c6:	9f 90       	pop	r9
    13c8:	8f 90       	pop	r8
    13ca:	7f 90       	pop	r7
    13cc:	6f 90       	pop	r6
    13ce:	5f 90       	pop	r5
    13d0:	4f 90       	pop	r4
	}
	else if ( percent_ < oldPercent_ )
	{
		oldPercent_ -= PERCENT_PR_TICK;
		tmr1Ptr_->setDutyCycleComB( oldPercent_ );
		vTaskDelay( delay_ / portTICK_RATE_MS );
    13d2:	0c 94 ac 12 	jmp	0x2558	; 0x2558 <vTaskDelay>

void M2::TurnMotor()
{
	if ( percent_ > oldPercent_ + PERCENT_PR_TICK )
	{
		oldPercent_ += PERCENT_PR_TICK;
    13d6:	4e 86       	std	Y+14, r4	; 0x0e
    13d8:	5f 86       	std	Y+15, r5	; 0x0f
    13da:	68 8a       	std	Y+16, r6	; 0x10
    13dc:	79 8a       	std	Y+17, r7	; 0x11
		tmr1Ptr_->setDutyCycleComB( oldPercent_ );
    13de:	b3 01       	movw	r22, r6
    13e0:	a2 01       	movw	r20, r4
    13e2:	e4 cf       	rjmp	.-56     	; 0x13ac <_ZN2M29TurnMotorEv+0x9c>

000013e4 <_ZN2M2C1EP6Timer1>:
* Author: jespe
*/

#include "M2.h"

M2::M2( Timer1* tmr )
    13e4:	cf 93       	push	r28
    13e6:	df 93       	push	r29
    13e8:	ec 01       	movw	r28, r24
    13ea:	cb 01       	movw	r24, r22
    13ec:	2c eb       	ldi	r18, 0xBC	; 188
    13ee:	32 e0       	ldi	r19, 0x02	; 2
    13f0:	39 83       	std	Y+1, r19	; 0x01
    13f2:	28 83       	st	Y, r18
{
	/* Store timer pointer */
	tmr1Ptr_ = tmr;
    13f4:	7b 83       	std	Y+3, r23	; 0x03
    13f6:	6a 83       	std	Y+2, r22	; 0x02
	
	/* This value is number of percent to add or subtract pr degree. */
	percentPrDeg = 0.06;
    13f8:	4f e8       	ldi	r20, 0x8F	; 143
    13fa:	52 ec       	ldi	r21, 0xC2	; 194
    13fc:	65 e7       	ldi	r22, 0x75	; 117
    13fe:	7d e3       	ldi	r23, 0x3D	; 61
    1400:	4e 83       	std	Y+6, r20	; 0x06
    1402:	5f 83       	std	Y+7, r21	; 0x07
    1404:	68 87       	std	Y+8, r22	; 0x08
    1406:	79 87       	std	Y+9, r23	; 0x09

	/* This value is the lowest duty cycle percentage needed to make motor turn. */
	startpercent_ = 3;
    1408:	40 e0       	ldi	r20, 0x00	; 0
    140a:	50 e0       	ldi	r21, 0x00	; 0
    140c:	60 e4       	ldi	r22, 0x40	; 64
    140e:	70 e4       	ldi	r23, 0x40	; 64
    1410:	4a 8b       	std	Y+18, r20	; 0x12
    1412:	5b 8b       	std	Y+19, r21	; 0x13
    1414:	6c 8b       	std	Y+20, r22	; 0x14
    1416:	7d 8b       	std	Y+21, r23	; 0x15

	/* This value is the delay on motor. A lower value makes motors go faster and higher value makes motors go slower. Value is in MS */
	delay_ = 10;
    1418:	2a e0       	ldi	r18, 0x0A	; 10
    141a:	30 e0       	ldi	r19, 0x00	; 0
    141c:	38 8f       	std	Y+24, r19	; 0x18
    141e:	2f 8b       	std	Y+23, r18	; 0x17

	/* This value is the maximum number of degrees the motor can turn */
	maxDegrees_ = 150;
    1420:	26 e9       	ldi	r18, 0x96	; 150
    1422:	2e 8b       	std	Y+22, r18	; 0x16
    1424:	46 e6       	ldi	r20, 0x66	; 102
    1426:	56 e6       	ldi	r21, 0x66	; 102
    1428:	66 e0       	ldi	r22, 0x06	; 6
    142a:	71 e4       	ldi	r23, 0x41	; 65
    142c:	4a 87       	std	Y+10, r20	; 0x0a
    142e:	5b 87       	std	Y+11, r21	; 0x0b
    1430:	6c 87       	std	Y+12, r22	; 0x0c
    1432:	7d 87       	std	Y+13, r23	; 0x0d

	/* Set motor to default startup value */
	SetDegrees( 90 );
	tmr1Ptr_->setDutyCycleComB( percent_ );
    1434:	c7 d2       	rcall	.+1422   	; 0x19c4 <_ZN6Timer116setDutyCycleComBEf>
	oldPercent_ = percent_;
    1436:	8a 85       	ldd	r24, Y+10	; 0x0a
    1438:	9b 85       	ldd	r25, Y+11	; 0x0b
    143a:	ac 85       	ldd	r26, Y+12	; 0x0c
    143c:	bd 85       	ldd	r27, Y+13	; 0x0d
    143e:	8e 87       	std	Y+14, r24	; 0x0e
    1440:	9f 87       	std	Y+15, r25	; 0x0f
    1442:	a8 8b       	std	Y+16, r26	; 0x10
    1444:	b9 8b       	std	Y+17, r27	; 0x11
}
    1446:	df 91       	pop	r29
    1448:	cf 91       	pop	r28
    144a:	08 95       	ret

0000144c <_ZN2M3D1Ev>:
	SetDegrees( 90 );
	tmr1Ptr_->setDutyCycleComC( percent_ );
	oldPercent_ = percent_;	
}

M3::~M3()
    144c:	08 95       	ret

0000144e <_ZN2M3D0Ev>:
{
}
    144e:	32 ca       	rjmp	.-2972   	; 0x8b4 <_ZdlPv>

00001450 <_ZN2M39TurnMotorEv>:

void M3::TurnMotor()
{
    1450:	4f 92       	push	r4
    1452:	5f 92       	push	r5
    1454:	6f 92       	push	r6
    1456:	7f 92       	push	r7
    1458:	8f 92       	push	r8
    145a:	9f 92       	push	r9
    145c:	af 92       	push	r10
    145e:	bf 92       	push	r11
    1460:	cf 92       	push	r12
    1462:	df 92       	push	r13
    1464:	ef 92       	push	r14
    1466:	ff 92       	push	r15
    1468:	cf 93       	push	r28
    146a:	df 93       	push	r29
    146c:	ec 01       	movw	r28, r24
	if ( percent_ > oldPercent_ + PERCENT_PR_TICK )
    146e:	8a 84       	ldd	r8, Y+10	; 0x0a
    1470:	9b 84       	ldd	r9, Y+11	; 0x0b
    1472:	ac 84       	ldd	r10, Y+12	; 0x0c
    1474:	bd 84       	ldd	r11, Y+13	; 0x0d
    1476:	ce 84       	ldd	r12, Y+14	; 0x0e
    1478:	df 84       	ldd	r13, Y+15	; 0x0f
    147a:	e8 88       	ldd	r14, Y+16	; 0x10
    147c:	f9 88       	ldd	r15, Y+17	; 0x11
    147e:	20 e0       	ldi	r18, 0x00	; 0
    1480:	30 e0       	ldi	r19, 0x00	; 0
    1482:	40 e8       	ldi	r20, 0x80	; 128
    1484:	5d e3       	ldi	r21, 0x3D	; 61
    1486:	c7 01       	movw	r24, r14
    1488:	b6 01       	movw	r22, r12
    148a:	0e 94 d9 1b 	call	0x37b2	; 0x37b2 <__addsf3>
    148e:	2b 01       	movw	r4, r22
    1490:	3c 01       	movw	r6, r24
    1492:	9b 01       	movw	r18, r22
    1494:	ac 01       	movw	r20, r24
    1496:	c5 01       	movw	r24, r10
    1498:	b4 01       	movw	r22, r8
    149a:	0e 94 87 1d 	call	0x3b0e	; 0x3b0e <__gesf2>
    149e:	18 16       	cp	r1, r24
    14a0:	d4 f1       	brlt	.+116    	; 0x1516 <_ZN2M39TurnMotorEv+0xc6>
	{
		oldPercent_ += PERCENT_PR_TICK;
		tmr1Ptr_->setDutyCycleComC( oldPercent_ );
		vTaskDelay( delay_ / portTICK_RATE_MS );
	}
	else if ( percent_ < oldPercent_ )
    14a2:	a7 01       	movw	r20, r14
    14a4:	96 01       	movw	r18, r12
    14a6:	c5 01       	movw	r24, r10
    14a8:	b4 01       	movw	r22, r8
    14aa:	0e 94 3d 1c 	call	0x387a	; 0x387a <__cmpsf2>
    14ae:	87 fd       	sbrc	r24, 7
    14b0:	0f c0       	rjmp	.+30     	; 0x14d0 <_ZN2M39TurnMotorEv+0x80>
	{
		oldPercent_ -= PERCENT_PR_TICK;
		tmr1Ptr_->setDutyCycleComC( oldPercent_ );
		vTaskDelay( delay_ / portTICK_RATE_MS );
	}
}
    14b2:	df 91       	pop	r29
    14b4:	cf 91       	pop	r28
    14b6:	ff 90       	pop	r15
    14b8:	ef 90       	pop	r14
    14ba:	df 90       	pop	r13
    14bc:	cf 90       	pop	r12
    14be:	bf 90       	pop	r11
    14c0:	af 90       	pop	r10
    14c2:	9f 90       	pop	r9
    14c4:	8f 90       	pop	r8
    14c6:	7f 90       	pop	r7
    14c8:	6f 90       	pop	r6
    14ca:	5f 90       	pop	r5
    14cc:	4f 90       	pop	r4
    14ce:	08 95       	ret
		tmr1Ptr_->setDutyCycleComC( oldPercent_ );
		vTaskDelay( delay_ / portTICK_RATE_MS );
	}
	else if ( percent_ < oldPercent_ )
	{
		oldPercent_ -= PERCENT_PR_TICK;
    14d0:	20 e0       	ldi	r18, 0x00	; 0
    14d2:	30 e0       	ldi	r19, 0x00	; 0
    14d4:	40 e8       	ldi	r20, 0x80	; 128
    14d6:	5d e3       	ldi	r21, 0x3D	; 61
    14d8:	c7 01       	movw	r24, r14
    14da:	b6 01       	movw	r22, r12
    14dc:	0e 94 d8 1b 	call	0x37b0	; 0x37b0 <__subsf3>
    14e0:	ab 01       	movw	r20, r22
    14e2:	bc 01       	movw	r22, r24
    14e4:	4e 87       	std	Y+14, r20	; 0x0e
    14e6:	5f 87       	std	Y+15, r21	; 0x0f
    14e8:	68 8b       	std	Y+16, r22	; 0x10
    14ea:	79 8b       	std	Y+17, r23	; 0x11
		tmr1Ptr_->setDutyCycleComC( oldPercent_ );
    14ec:	8a 81       	ldd	r24, Y+2	; 0x02
    14ee:	9b 81       	ldd	r25, Y+3	; 0x03
    14f0:	92 d2       	rcall	.+1316   	; 0x1a16 <_ZN6Timer116setDutyCycleComCEf>
		vTaskDelay( delay_ / portTICK_RATE_MS );
    14f2:	8f 89       	ldd	r24, Y+23	; 0x17
    14f4:	98 8d       	ldd	r25, Y+24	; 0x18
	}
}
    14f6:	df 91       	pop	r29
    14f8:	cf 91       	pop	r28
    14fa:	ff 90       	pop	r15
    14fc:	ef 90       	pop	r14
    14fe:	df 90       	pop	r13
    1500:	cf 90       	pop	r12
    1502:	bf 90       	pop	r11
    1504:	af 90       	pop	r10
    1506:	9f 90       	pop	r9
    1508:	8f 90       	pop	r8
    150a:	7f 90       	pop	r7
    150c:	6f 90       	pop	r6
    150e:	5f 90       	pop	r5
    1510:	4f 90       	pop	r4
	}
	else if ( percent_ < oldPercent_ )
	{
		oldPercent_ -= PERCENT_PR_TICK;
		tmr1Ptr_->setDutyCycleComC( oldPercent_ );
		vTaskDelay( delay_ / portTICK_RATE_MS );
    1512:	0c 94 ac 12 	jmp	0x2558	; 0x2558 <vTaskDelay>

void M3::TurnMotor()
{
	if ( percent_ > oldPercent_ + PERCENT_PR_TICK )
	{
		oldPercent_ += PERCENT_PR_TICK;
    1516:	4e 86       	std	Y+14, r4	; 0x0e
    1518:	5f 86       	std	Y+15, r5	; 0x0f
    151a:	68 8a       	std	Y+16, r6	; 0x10
    151c:	79 8a       	std	Y+17, r7	; 0x11
		tmr1Ptr_->setDutyCycleComC( oldPercent_ );
    151e:	b3 01       	movw	r22, r6
    1520:	a2 01       	movw	r20, r4
    1522:	e4 cf       	rjmp	.-56     	; 0x14ec <_ZN2M39TurnMotorEv+0x9c>

00001524 <_ZN2M3C1EP6Timer1>:
*/

#include "M3.h"


M3::M3( Timer1* tmr )
    1524:	cf 93       	push	r28
    1526:	df 93       	push	r29
    1528:	ec 01       	movw	r28, r24
    152a:	cb 01       	movw	r24, r22
    152c:	28 ec       	ldi	r18, 0xC8	; 200
    152e:	32 e0       	ldi	r19, 0x02	; 2
    1530:	39 83       	std	Y+1, r19	; 0x01
    1532:	28 83       	st	Y, r18
{
	/* Store timer pointer */
	tmr1Ptr_ = tmr;
    1534:	7b 83       	std	Y+3, r23	; 0x03
    1536:	6a 83       	std	Y+2, r22	; 0x02
		
	/* This value is number of percent to add or subtract pr degree. */
	percentPrDeg = 0.0555555555555556;
    1538:	49 e3       	ldi	r20, 0x39	; 57
    153a:	5e e8       	ldi	r21, 0x8E	; 142
    153c:	63 e6       	ldi	r22, 0x63	; 99
    153e:	7d e3       	ldi	r23, 0x3D	; 61
    1540:	4e 83       	std	Y+6, r20	; 0x06
    1542:	5f 83       	std	Y+7, r21	; 0x07
    1544:	68 87       	std	Y+8, r22	; 0x08
    1546:	79 87       	std	Y+9, r23	; 0x09
	
	/* This value is the lowest duty cycle percentage needed to make motor turn. */
	startpercent_ = 2.5;
    1548:	40 e0       	ldi	r20, 0x00	; 0
    154a:	50 e0       	ldi	r21, 0x00	; 0
    154c:	60 e2       	ldi	r22, 0x20	; 32
    154e:	70 e4       	ldi	r23, 0x40	; 64
    1550:	4a 8b       	std	Y+18, r20	; 0x12
    1552:	5b 8b       	std	Y+19, r21	; 0x13
    1554:	6c 8b       	std	Y+20, r22	; 0x14
    1556:	7d 8b       	std	Y+21, r23	; 0x15

	/* This value is the delay on motor. A lower value makes motors go faster and higher value makes motors go slower. Value is in MS */
	delay_ = 10;
    1558:	2a e0       	ldi	r18, 0x0A	; 10
    155a:	30 e0       	ldi	r19, 0x00	; 0
    155c:	38 8f       	std	Y+24, r19	; 0x18
    155e:	2f 8b       	std	Y+23, r18	; 0x17
	
	/* This value is the maximum number of degrees the motor can turn */
	maxDegrees_ = 180;
    1560:	24 eb       	ldi	r18, 0xB4	; 180
    1562:	2e 8b       	std	Y+22, r18	; 0x16
    1564:	40 e0       	ldi	r20, 0x00	; 0
    1566:	50 e0       	ldi	r21, 0x00	; 0
    1568:	60 ef       	ldi	r22, 0xF0	; 240
    156a:	70 e4       	ldi	r23, 0x40	; 64
    156c:	4a 87       	std	Y+10, r20	; 0x0a
    156e:	5b 87       	std	Y+11, r21	; 0x0b
    1570:	6c 87       	std	Y+12, r22	; 0x0c
    1572:	7d 87       	std	Y+13, r23	; 0x0d
	
	/* Set motor to default startup value */
	SetDegrees( 90 );
	tmr1Ptr_->setDutyCycleComC( percent_ );
    1574:	50 d2       	rcall	.+1184   	; 0x1a16 <_ZN6Timer116setDutyCycleComCEf>
	oldPercent_ = percent_;	
    1576:	8a 85       	ldd	r24, Y+10	; 0x0a
    1578:	9b 85       	ldd	r25, Y+11	; 0x0b
    157a:	ac 85       	ldd	r26, Y+12	; 0x0c
    157c:	bd 85       	ldd	r27, Y+13	; 0x0d
    157e:	8e 87       	std	Y+14, r24	; 0x0e
    1580:	9f 87       	std	Y+15, r25	; 0x0f
    1582:	a8 8b       	std	Y+16, r26	; 0x10
    1584:	b9 8b       	std	Y+17, r27	; 0x11
}
    1586:	df 91       	pop	r29
    1588:	cf 91       	pop	r28
    158a:	08 95       	ret

0000158c <_ZN2M4D1Ev>:
	SetDegrees( 90 );
	tmr3Ptr_->setDutyCycleComA( percent_ );
	oldPercent_ = percent_;
}

M4::~M4()
    158c:	08 95       	ret

0000158e <_ZN2M4D0Ev>:
{
} 
    158e:	92 c9       	rjmp	.-3292   	; 0x8b4 <_ZdlPv>

00001590 <_ZN2M49TurnMotorEv>:

void M4::TurnMotor()
{
    1590:	4f 92       	push	r4
    1592:	5f 92       	push	r5
    1594:	6f 92       	push	r6
    1596:	7f 92       	push	r7
    1598:	8f 92       	push	r8
    159a:	9f 92       	push	r9
    159c:	af 92       	push	r10
    159e:	bf 92       	push	r11
    15a0:	cf 92       	push	r12
    15a2:	df 92       	push	r13
    15a4:	ef 92       	push	r14
    15a6:	ff 92       	push	r15
    15a8:	cf 93       	push	r28
    15aa:	df 93       	push	r29
    15ac:	ec 01       	movw	r28, r24
	if ( percent_ > oldPercent_ + PERCENT_PR_TICK )
    15ae:	8a 84       	ldd	r8, Y+10	; 0x0a
    15b0:	9b 84       	ldd	r9, Y+11	; 0x0b
    15b2:	ac 84       	ldd	r10, Y+12	; 0x0c
    15b4:	bd 84       	ldd	r11, Y+13	; 0x0d
    15b6:	ce 84       	ldd	r12, Y+14	; 0x0e
    15b8:	df 84       	ldd	r13, Y+15	; 0x0f
    15ba:	e8 88       	ldd	r14, Y+16	; 0x10
    15bc:	f9 88       	ldd	r15, Y+17	; 0x11
    15be:	20 e0       	ldi	r18, 0x00	; 0
    15c0:	30 e0       	ldi	r19, 0x00	; 0
    15c2:	40 e8       	ldi	r20, 0x80	; 128
    15c4:	5d e3       	ldi	r21, 0x3D	; 61
    15c6:	c7 01       	movw	r24, r14
    15c8:	b6 01       	movw	r22, r12
    15ca:	0e 94 d9 1b 	call	0x37b2	; 0x37b2 <__addsf3>
    15ce:	2b 01       	movw	r4, r22
    15d0:	3c 01       	movw	r6, r24
    15d2:	9b 01       	movw	r18, r22
    15d4:	ac 01       	movw	r20, r24
    15d6:	c5 01       	movw	r24, r10
    15d8:	b4 01       	movw	r22, r8
    15da:	0e 94 87 1d 	call	0x3b0e	; 0x3b0e <__gesf2>
    15de:	18 16       	cp	r1, r24
    15e0:	cc f1       	brlt	.+114    	; 0x1654 <_ZN2M49TurnMotorEv+0xc4>
	{
		oldPercent_ += PERCENT_PR_TICK;
		tmr3Ptr_->setDutyCycleComA( oldPercent_ );
		vTaskDelay( 10 / portTICK_RATE_MS );
	}
	else if ( percent_ < oldPercent_ )
    15e2:	a7 01       	movw	r20, r14
    15e4:	96 01       	movw	r18, r12
    15e6:	c5 01       	movw	r24, r10
    15e8:	b4 01       	movw	r22, r8
    15ea:	0e 94 3d 1c 	call	0x387a	; 0x387a <__cmpsf2>
    15ee:	87 fd       	sbrc	r24, 7
    15f0:	0f c0       	rjmp	.+30     	; 0x1610 <_ZN2M49TurnMotorEv+0x80>
	{
		oldPercent_ -= PERCENT_PR_TICK;
		tmr3Ptr_->setDutyCycleComA( oldPercent_ );
		vTaskDelay( 10 / portTICK_RATE_MS );
	}
}
    15f2:	df 91       	pop	r29
    15f4:	cf 91       	pop	r28
    15f6:	ff 90       	pop	r15
    15f8:	ef 90       	pop	r14
    15fa:	df 90       	pop	r13
    15fc:	cf 90       	pop	r12
    15fe:	bf 90       	pop	r11
    1600:	af 90       	pop	r10
    1602:	9f 90       	pop	r9
    1604:	8f 90       	pop	r8
    1606:	7f 90       	pop	r7
    1608:	6f 90       	pop	r6
    160a:	5f 90       	pop	r5
    160c:	4f 90       	pop	r4
    160e:	08 95       	ret
		tmr3Ptr_->setDutyCycleComA( oldPercent_ );
		vTaskDelay( 10 / portTICK_RATE_MS );
	}
	else if ( percent_ < oldPercent_ )
	{
		oldPercent_ -= PERCENT_PR_TICK;
    1610:	20 e0       	ldi	r18, 0x00	; 0
    1612:	30 e0       	ldi	r19, 0x00	; 0
    1614:	40 e8       	ldi	r20, 0x80	; 128
    1616:	5d e3       	ldi	r21, 0x3D	; 61
    1618:	c7 01       	movw	r24, r14
    161a:	b6 01       	movw	r22, r12
    161c:	0e 94 d8 1b 	call	0x37b0	; 0x37b0 <__subsf3>
    1620:	ab 01       	movw	r20, r22
    1622:	bc 01       	movw	r22, r24
    1624:	4e 87       	std	Y+14, r20	; 0x0e
    1626:	5f 87       	std	Y+15, r21	; 0x0f
    1628:	68 8b       	std	Y+16, r22	; 0x10
    162a:	79 8b       	std	Y+17, r23	; 0x11
		tmr3Ptr_->setDutyCycleComA( oldPercent_ );
    162c:	8c 81       	ldd	r24, Y+4	; 0x04
    162e:	9d 81       	ldd	r25, Y+5	; 0x05
    1630:	41 d2       	rcall	.+1154   	; 0x1ab4 <_ZN6Timer516setDutyCycleComAEf>
		vTaskDelay( 10 / portTICK_RATE_MS );
    1632:	8a e0       	ldi	r24, 0x0A	; 10
    1634:	90 e0       	ldi	r25, 0x00	; 0
	}
}
    1636:	df 91       	pop	r29
    1638:	cf 91       	pop	r28
    163a:	ff 90       	pop	r15
    163c:	ef 90       	pop	r14
    163e:	df 90       	pop	r13
    1640:	cf 90       	pop	r12
    1642:	bf 90       	pop	r11
    1644:	af 90       	pop	r10
    1646:	9f 90       	pop	r9
    1648:	8f 90       	pop	r8
    164a:	7f 90       	pop	r7
    164c:	6f 90       	pop	r6
    164e:	5f 90       	pop	r5
	}
	else if ( percent_ < oldPercent_ )
	{
		oldPercent_ -= PERCENT_PR_TICK;
		tmr3Ptr_->setDutyCycleComA( oldPercent_ );
		vTaskDelay( 10 / portTICK_RATE_MS );
    1650:	4f 90       	pop	r4
    1652:	82 c7       	rjmp	.+3844   	; 0x2558 <vTaskDelay>

void M4::TurnMotor()
{
	if ( percent_ > oldPercent_ + PERCENT_PR_TICK )
	{
		oldPercent_ += PERCENT_PR_TICK;
    1654:	4e 86       	std	Y+14, r4	; 0x0e
    1656:	5f 86       	std	Y+15, r5	; 0x0f
    1658:	68 8a       	std	Y+16, r6	; 0x10
    165a:	79 8a       	std	Y+17, r7	; 0x11
		tmr3Ptr_->setDutyCycleComA( oldPercent_ );
    165c:	b3 01       	movw	r22, r6
    165e:	a2 01       	movw	r20, r4
    1660:	e5 cf       	rjmp	.-54     	; 0x162c <_ZN2M49TurnMotorEv+0x9c>

00001662 <_ZN2M4C1EP6Timer5>:
* Author: jespe
*/

#include "M4.h"

M4::M4( Timer5* tmr )
    1662:	cf 93       	push	r28
    1664:	df 93       	push	r29
    1666:	ec 01       	movw	r28, r24
    1668:	cb 01       	movw	r24, r22
    166a:	24 ed       	ldi	r18, 0xD4	; 212
    166c:	32 e0       	ldi	r19, 0x02	; 2
    166e:	39 83       	std	Y+1, r19	; 0x01
    1670:	28 83       	st	Y, r18
{
	/* Store timer pointer */
	tmr3Ptr_ = tmr;
    1672:	7d 83       	std	Y+5, r23	; 0x05
    1674:	6c 83       	std	Y+4, r22	; 0x04
	
	/* This value is number of percent to add or subtract pr degree. */
	percentPrDeg = 0.0555555555555556;
    1676:	49 e3       	ldi	r20, 0x39	; 57
    1678:	5e e8       	ldi	r21, 0x8E	; 142
    167a:	63 e6       	ldi	r22, 0x63	; 99
    167c:	7d e3       	ldi	r23, 0x3D	; 61
    167e:	4e 83       	std	Y+6, r20	; 0x06
    1680:	5f 83       	std	Y+7, r21	; 0x07
    1682:	68 87       	std	Y+8, r22	; 0x08
    1684:	79 87       	std	Y+9, r23	; 0x09
	
	/* This value is the lowest duty cycle percentage needed to make motor turn. */
	startpercent_ = 2.5;
    1686:	40 e0       	ldi	r20, 0x00	; 0
    1688:	50 e0       	ldi	r21, 0x00	; 0
    168a:	60 e2       	ldi	r22, 0x20	; 32
    168c:	70 e4       	ldi	r23, 0x40	; 64
    168e:	4a 8b       	std	Y+18, r20	; 0x12
    1690:	5b 8b       	std	Y+19, r21	; 0x13
    1692:	6c 8b       	std	Y+20, r22	; 0x14
    1694:	7d 8b       	std	Y+21, r23	; 0x15
		
	/* This value is the delay on motor. A lower value makes motors go faster and higher value makes motors go slower. Value is in MS */
	delay_ = 5;
    1696:	25 e0       	ldi	r18, 0x05	; 5
    1698:	30 e0       	ldi	r19, 0x00	; 0
    169a:	38 8f       	std	Y+24, r19	; 0x18
    169c:	2f 8b       	std	Y+23, r18	; 0x17
	
	/* This value is the maximum number of degrees the motor can turn */
	maxDegrees_ = 180;
    169e:	24 eb       	ldi	r18, 0xB4	; 180
    16a0:	2e 8b       	std	Y+22, r18	; 0x16
    16a2:	40 e0       	ldi	r20, 0x00	; 0
    16a4:	50 e0       	ldi	r21, 0x00	; 0
    16a6:	60 ef       	ldi	r22, 0xF0	; 240
    16a8:	70 e4       	ldi	r23, 0x40	; 64
    16aa:	4a 87       	std	Y+10, r20	; 0x0a
    16ac:	5b 87       	std	Y+11, r21	; 0x0b
    16ae:	6c 87       	std	Y+12, r22	; 0x0c
    16b0:	7d 87       	std	Y+13, r23	; 0x0d
	
	/* Set motor to default startup value */
	SetDegrees( 90 );
	tmr3Ptr_->setDutyCycleComA( percent_ );
    16b2:	00 d2       	rcall	.+1024   	; 0x1ab4 <_ZN6Timer516setDutyCycleComAEf>
	oldPercent_ = percent_;
    16b4:	8a 85       	ldd	r24, Y+10	; 0x0a
    16b6:	9b 85       	ldd	r25, Y+11	; 0x0b
    16b8:	ac 85       	ldd	r26, Y+12	; 0x0c
    16ba:	bd 85       	ldd	r27, Y+13	; 0x0d
    16bc:	8e 87       	std	Y+14, r24	; 0x0e
    16be:	9f 87       	std	Y+15, r25	; 0x0f
    16c0:	a8 8b       	std	Y+16, r26	; 0x10
    16c2:	b9 8b       	std	Y+17, r27	; 0x11
}
    16c4:	df 91       	pop	r29
    16c6:	cf 91       	pop	r28
    16c8:	08 95       	ret

000016ca <_ZN2M5D1Ev>:
	SetDegrees( 0 );
	tmr3Ptr_->setDutyCycleComB( percent_ );
	oldPercent_ = percent_;
}

M5::~M5()
    16ca:	08 95       	ret

000016cc <_ZN2M5D0Ev>:
{
}
    16cc:	f3 c8       	rjmp	.-3610   	; 0x8b4 <_ZdlPv>

000016ce <_ZN2M59TurnMotorEv>:

void M5::TurnMotor()
{
    16ce:	4f 92       	push	r4
    16d0:	5f 92       	push	r5
    16d2:	6f 92       	push	r6
    16d4:	7f 92       	push	r7
    16d6:	8f 92       	push	r8
    16d8:	9f 92       	push	r9
    16da:	af 92       	push	r10
    16dc:	bf 92       	push	r11
    16de:	cf 92       	push	r12
    16e0:	df 92       	push	r13
    16e2:	ef 92       	push	r14
    16e4:	ff 92       	push	r15
    16e6:	cf 93       	push	r28
    16e8:	df 93       	push	r29
    16ea:	ec 01       	movw	r28, r24
	if ( percent_ > oldPercent_ + PERCENT_PR_TICK )
    16ec:	8a 84       	ldd	r8, Y+10	; 0x0a
    16ee:	9b 84       	ldd	r9, Y+11	; 0x0b
    16f0:	ac 84       	ldd	r10, Y+12	; 0x0c
    16f2:	bd 84       	ldd	r11, Y+13	; 0x0d
    16f4:	ce 84       	ldd	r12, Y+14	; 0x0e
    16f6:	df 84       	ldd	r13, Y+15	; 0x0f
    16f8:	e8 88       	ldd	r14, Y+16	; 0x10
    16fa:	f9 88       	ldd	r15, Y+17	; 0x11
    16fc:	20 e0       	ldi	r18, 0x00	; 0
    16fe:	30 e0       	ldi	r19, 0x00	; 0
    1700:	40 e8       	ldi	r20, 0x80	; 128
    1702:	5d e3       	ldi	r21, 0x3D	; 61
    1704:	c7 01       	movw	r24, r14
    1706:	b6 01       	movw	r22, r12
    1708:	0e 94 d9 1b 	call	0x37b2	; 0x37b2 <__addsf3>
    170c:	2b 01       	movw	r4, r22
    170e:	3c 01       	movw	r6, r24
    1710:	9b 01       	movw	r18, r22
    1712:	ac 01       	movw	r20, r24
    1714:	c5 01       	movw	r24, r10
    1716:	b4 01       	movw	r22, r8
    1718:	0e 94 87 1d 	call	0x3b0e	; 0x3b0e <__gesf2>
    171c:	18 16       	cp	r1, r24
    171e:	cc f1       	brlt	.+114    	; 0x1792 <_ZN2M59TurnMotorEv+0xc4>
	{
		oldPercent_ += PERCENT_PR_TICK;
		tmr3Ptr_->setDutyCycleComB( oldPercent_ );
		vTaskDelay( delay_ / portTICK_RATE_MS );
	}
	else if ( percent_ < oldPercent_ )
    1720:	a7 01       	movw	r20, r14
    1722:	96 01       	movw	r18, r12
    1724:	c5 01       	movw	r24, r10
    1726:	b4 01       	movw	r22, r8
    1728:	0e 94 3d 1c 	call	0x387a	; 0x387a <__cmpsf2>
    172c:	87 fd       	sbrc	r24, 7
    172e:	0f c0       	rjmp	.+30     	; 0x174e <_ZN2M59TurnMotorEv+0x80>
	{
		oldPercent_ -= PERCENT_PR_TICK;
		tmr3Ptr_->setDutyCycleComB( oldPercent_ );
		vTaskDelay( delay_ / portTICK_RATE_MS );
	}
}
    1730:	df 91       	pop	r29
    1732:	cf 91       	pop	r28
    1734:	ff 90       	pop	r15
    1736:	ef 90       	pop	r14
    1738:	df 90       	pop	r13
    173a:	cf 90       	pop	r12
    173c:	bf 90       	pop	r11
    173e:	af 90       	pop	r10
    1740:	9f 90       	pop	r9
    1742:	8f 90       	pop	r8
    1744:	7f 90       	pop	r7
    1746:	6f 90       	pop	r6
    1748:	5f 90       	pop	r5
    174a:	4f 90       	pop	r4
    174c:	08 95       	ret
		tmr3Ptr_->setDutyCycleComB( oldPercent_ );
		vTaskDelay( delay_ / portTICK_RATE_MS );
	}
	else if ( percent_ < oldPercent_ )
	{
		oldPercent_ -= PERCENT_PR_TICK;
    174e:	20 e0       	ldi	r18, 0x00	; 0
    1750:	30 e0       	ldi	r19, 0x00	; 0
    1752:	40 e8       	ldi	r20, 0x80	; 128
    1754:	5d e3       	ldi	r21, 0x3D	; 61
    1756:	c7 01       	movw	r24, r14
    1758:	b6 01       	movw	r22, r12
    175a:	0e 94 d8 1b 	call	0x37b0	; 0x37b0 <__subsf3>
    175e:	ab 01       	movw	r20, r22
    1760:	bc 01       	movw	r22, r24
    1762:	4e 87       	std	Y+14, r20	; 0x0e
    1764:	5f 87       	std	Y+15, r21	; 0x0f
    1766:	68 8b       	std	Y+16, r22	; 0x10
    1768:	79 8b       	std	Y+17, r23	; 0x11
		tmr3Ptr_->setDutyCycleComB( oldPercent_ );
    176a:	8c 81       	ldd	r24, Y+4	; 0x04
    176c:	9d 81       	ldd	r25, Y+5	; 0x05
    176e:	cb d1       	rcall	.+918    	; 0x1b06 <_ZN6Timer516setDutyCycleComBEf>
		vTaskDelay( delay_ / portTICK_RATE_MS );
    1770:	8f 89       	ldd	r24, Y+23	; 0x17
    1772:	98 8d       	ldd	r25, Y+24	; 0x18
	}
}
    1774:	df 91       	pop	r29
    1776:	cf 91       	pop	r28
    1778:	ff 90       	pop	r15
    177a:	ef 90       	pop	r14
    177c:	df 90       	pop	r13
    177e:	cf 90       	pop	r12
    1780:	bf 90       	pop	r11
    1782:	af 90       	pop	r10
    1784:	9f 90       	pop	r9
    1786:	8f 90       	pop	r8
    1788:	7f 90       	pop	r7
    178a:	6f 90       	pop	r6
    178c:	5f 90       	pop	r5
	}
	else if ( percent_ < oldPercent_ )
	{
		oldPercent_ -= PERCENT_PR_TICK;
		tmr3Ptr_->setDutyCycleComB( oldPercent_ );
		vTaskDelay( delay_ / portTICK_RATE_MS );
    178e:	4f 90       	pop	r4
    1790:	e3 c6       	rjmp	.+3526   	; 0x2558 <vTaskDelay>

void M5::TurnMotor()
{
	if ( percent_ > oldPercent_ + PERCENT_PR_TICK )
	{
		oldPercent_ += PERCENT_PR_TICK;
    1792:	4e 86       	std	Y+14, r4	; 0x0e
    1794:	5f 86       	std	Y+15, r5	; 0x0f
    1796:	68 8a       	std	Y+16, r6	; 0x10
    1798:	79 8a       	std	Y+17, r7	; 0x11
		tmr3Ptr_->setDutyCycleComB( oldPercent_ );
    179a:	b3 01       	movw	r22, r6
    179c:	a2 01       	movw	r20, r4
    179e:	e5 cf       	rjmp	.-54     	; 0x176a <_ZN2M59TurnMotorEv+0x9c>

000017a0 <_ZN2M5C1EP6Timer5>:
* Author: jespe
*/

#include "M5.h"

M5::M5( Timer5* tmr )
    17a0:	cf 93       	push	r28
    17a2:	df 93       	push	r29
    17a4:	ec 01       	movw	r28, r24
    17a6:	cb 01       	movw	r24, r22
    17a8:	20 ee       	ldi	r18, 0xE0	; 224
    17aa:	32 e0       	ldi	r19, 0x02	; 2
    17ac:	39 83       	std	Y+1, r19	; 0x01
    17ae:	28 83       	st	Y, r18
{
	/* Store timer pointer */
	tmr3Ptr_ = tmr;
    17b0:	7d 83       	std	Y+5, r23	; 0x05
    17b2:	6c 83       	std	Y+4, r22	; 0x04
	
	/* This value is number of percent to add or subtract pr degree. */
	percentPrDeg = 0.0555555555555556;
    17b4:	49 e3       	ldi	r20, 0x39	; 57
    17b6:	5e e8       	ldi	r21, 0x8E	; 142
    17b8:	63 e6       	ldi	r22, 0x63	; 99
    17ba:	7d e3       	ldi	r23, 0x3D	; 61
    17bc:	4e 83       	std	Y+6, r20	; 0x06
    17be:	5f 83       	std	Y+7, r21	; 0x07
    17c0:	68 87       	std	Y+8, r22	; 0x08
    17c2:	79 87       	std	Y+9, r23	; 0x09
	
	/* This value is the lowest duty cycle percentage needed to make motor turn. */
	startpercent_ = 2.5;
    17c4:	40 e0       	ldi	r20, 0x00	; 0
    17c6:	50 e0       	ldi	r21, 0x00	; 0
    17c8:	60 e2       	ldi	r22, 0x20	; 32
    17ca:	70 e4       	ldi	r23, 0x40	; 64
    17cc:	4a 8b       	std	Y+18, r20	; 0x12
    17ce:	5b 8b       	std	Y+19, r21	; 0x13
    17d0:	6c 8b       	std	Y+20, r22	; 0x14
    17d2:	7d 8b       	std	Y+21, r23	; 0x15
	
	/* This value is the delay on motor. A lower value makes motors go faster and higher value makes motors go slower. Value is in MS */
	delay_ = 1;
    17d4:	21 e0       	ldi	r18, 0x01	; 1
    17d6:	30 e0       	ldi	r19, 0x00	; 0
    17d8:	38 8f       	std	Y+24, r19	; 0x18
    17da:	2f 8b       	std	Y+23, r18	; 0x17
	
	/* This value is the maximum number of degrees the motor can turn */
	maxDegrees_ = 180;
    17dc:	24 eb       	ldi	r18, 0xB4	; 180
    17de:	2e 8b       	std	Y+22, r18	; 0x16
    17e0:	4a 87       	std	Y+10, r20	; 0x0a
    17e2:	5b 87       	std	Y+11, r21	; 0x0b
    17e4:	6c 87       	std	Y+12, r22	; 0x0c
    17e6:	7d 87       	std	Y+13, r23	; 0x0d
	
	/* Set motor to default startup value */
	SetDegrees( 0 );
	tmr3Ptr_->setDutyCycleComB( percent_ );
    17e8:	8e d1       	rcall	.+796    	; 0x1b06 <_ZN6Timer516setDutyCycleComBEf>
	oldPercent_ = percent_;
    17ea:	8a 85       	ldd	r24, Y+10	; 0x0a
    17ec:	9b 85       	ldd	r25, Y+11	; 0x0b
    17ee:	ac 85       	ldd	r26, Y+12	; 0x0c
    17f0:	bd 85       	ldd	r27, Y+13	; 0x0d
    17f2:	8e 87       	std	Y+14, r24	; 0x0e
    17f4:	9f 87       	std	Y+15, r25	; 0x0f
    17f6:	a8 8b       	std	Y+16, r26	; 0x10
    17f8:	b9 8b       	std	Y+17, r27	; 0x11
}
    17fa:	df 91       	pop	r29
    17fc:	cf 91       	pop	r28
    17fe:	08 95       	ret

00001800 <_ZN2M6D1Ev>:
	SetDegrees( 0 );
	tmr3Ptr_->setDutyCycleComC( percent_ );
	oldPercent_ = percent_;
}

M6::~M6()
    1800:	08 95       	ret

00001802 <_ZN2M6D0Ev>:
{
}
    1802:	58 c8       	rjmp	.-3920   	; 0x8b4 <_ZdlPv>

00001804 <_ZN2M69TurnMotorEv>:

void M6::TurnMotor()
{
    1804:	4f 92       	push	r4
    1806:	5f 92       	push	r5
    1808:	6f 92       	push	r6
    180a:	7f 92       	push	r7
    180c:	8f 92       	push	r8
    180e:	9f 92       	push	r9
    1810:	af 92       	push	r10
    1812:	bf 92       	push	r11
    1814:	cf 92       	push	r12
    1816:	df 92       	push	r13
    1818:	ef 92       	push	r14
    181a:	ff 92       	push	r15
    181c:	cf 93       	push	r28
    181e:	df 93       	push	r29
    1820:	ec 01       	movw	r28, r24
	if ( percent_ > oldPercent_ + PERCENT_PR_TICK )
    1822:	8a 84       	ldd	r8, Y+10	; 0x0a
    1824:	9b 84       	ldd	r9, Y+11	; 0x0b
    1826:	ac 84       	ldd	r10, Y+12	; 0x0c
    1828:	bd 84       	ldd	r11, Y+13	; 0x0d
    182a:	ce 84       	ldd	r12, Y+14	; 0x0e
    182c:	df 84       	ldd	r13, Y+15	; 0x0f
    182e:	e8 88       	ldd	r14, Y+16	; 0x10
    1830:	f9 88       	ldd	r15, Y+17	; 0x11
    1832:	20 e0       	ldi	r18, 0x00	; 0
    1834:	30 e0       	ldi	r19, 0x00	; 0
    1836:	40 e8       	ldi	r20, 0x80	; 128
    1838:	5d e3       	ldi	r21, 0x3D	; 61
    183a:	c7 01       	movw	r24, r14
    183c:	b6 01       	movw	r22, r12
    183e:	0e 94 d9 1b 	call	0x37b2	; 0x37b2 <__addsf3>
    1842:	2b 01       	movw	r4, r22
    1844:	3c 01       	movw	r6, r24
    1846:	9b 01       	movw	r18, r22
    1848:	ac 01       	movw	r20, r24
    184a:	c5 01       	movw	r24, r10
    184c:	b4 01       	movw	r22, r8
    184e:	0e 94 87 1d 	call	0x3b0e	; 0x3b0e <__gesf2>
    1852:	18 16       	cp	r1, r24
    1854:	cc f1       	brlt	.+114    	; 0x18c8 <_ZN2M69TurnMotorEv+0xc4>
	{
		oldPercent_ += 0.0625;
		tmr3Ptr_->setDutyCycleComC( oldPercent_ );
		vTaskDelay( delay_ / portTICK_RATE_MS );
	}
	else if ( percent_ < oldPercent_ )
    1856:	a7 01       	movw	r20, r14
    1858:	96 01       	movw	r18, r12
    185a:	c5 01       	movw	r24, r10
    185c:	b4 01       	movw	r22, r8
    185e:	0e 94 3d 1c 	call	0x387a	; 0x387a <__cmpsf2>
    1862:	87 fd       	sbrc	r24, 7
    1864:	0f c0       	rjmp	.+30     	; 0x1884 <_ZN2M69TurnMotorEv+0x80>
	{
		oldPercent_ -= 0.0625;
		tmr3Ptr_->setDutyCycleComC( oldPercent_ );
		vTaskDelay( delay_ / portTICK_RATE_MS );
	}
}
    1866:	df 91       	pop	r29
    1868:	cf 91       	pop	r28
    186a:	ff 90       	pop	r15
    186c:	ef 90       	pop	r14
    186e:	df 90       	pop	r13
    1870:	cf 90       	pop	r12
    1872:	bf 90       	pop	r11
    1874:	af 90       	pop	r10
    1876:	9f 90       	pop	r9
    1878:	8f 90       	pop	r8
    187a:	7f 90       	pop	r7
    187c:	6f 90       	pop	r6
    187e:	5f 90       	pop	r5
    1880:	4f 90       	pop	r4
    1882:	08 95       	ret
		tmr3Ptr_->setDutyCycleComC( oldPercent_ );
		vTaskDelay( delay_ / portTICK_RATE_MS );
	}
	else if ( percent_ < oldPercent_ )
	{
		oldPercent_ -= 0.0625;
    1884:	20 e0       	ldi	r18, 0x00	; 0
    1886:	30 e0       	ldi	r19, 0x00	; 0
    1888:	40 e8       	ldi	r20, 0x80	; 128
    188a:	5d e3       	ldi	r21, 0x3D	; 61
    188c:	c7 01       	movw	r24, r14
    188e:	b6 01       	movw	r22, r12
    1890:	0e 94 d8 1b 	call	0x37b0	; 0x37b0 <__subsf3>
    1894:	ab 01       	movw	r20, r22
    1896:	bc 01       	movw	r22, r24
    1898:	4e 87       	std	Y+14, r20	; 0x0e
    189a:	5f 87       	std	Y+15, r21	; 0x0f
    189c:	68 8b       	std	Y+16, r22	; 0x10
    189e:	79 8b       	std	Y+17, r23	; 0x11
		tmr3Ptr_->setDutyCycleComC( oldPercent_ );
    18a0:	8c 81       	ldd	r24, Y+4	; 0x04
    18a2:	9d 81       	ldd	r25, Y+5	; 0x05
    18a4:	59 d1       	rcall	.+690    	; 0x1b58 <_ZN6Timer516setDutyCycleComCEf>
		vTaskDelay( delay_ / portTICK_RATE_MS );
    18a6:	8f 89       	ldd	r24, Y+23	; 0x17
    18a8:	98 8d       	ldd	r25, Y+24	; 0x18
	}
}
    18aa:	df 91       	pop	r29
    18ac:	cf 91       	pop	r28
    18ae:	ff 90       	pop	r15
    18b0:	ef 90       	pop	r14
    18b2:	df 90       	pop	r13
    18b4:	cf 90       	pop	r12
    18b6:	bf 90       	pop	r11
    18b8:	af 90       	pop	r10
    18ba:	9f 90       	pop	r9
    18bc:	8f 90       	pop	r8
    18be:	7f 90       	pop	r7
    18c0:	6f 90       	pop	r6
    18c2:	5f 90       	pop	r5
	}
	else if ( percent_ < oldPercent_ )
	{
		oldPercent_ -= 0.0625;
		tmr3Ptr_->setDutyCycleComC( oldPercent_ );
		vTaskDelay( delay_ / portTICK_RATE_MS );
    18c4:	4f 90       	pop	r4
    18c6:	48 c6       	rjmp	.+3216   	; 0x2558 <vTaskDelay>

void M6::TurnMotor()
{
	if ( percent_ > oldPercent_ + PERCENT_PR_TICK )
	{
		oldPercent_ += 0.0625;
    18c8:	4e 86       	std	Y+14, r4	; 0x0e
    18ca:	5f 86       	std	Y+15, r5	; 0x0f
    18cc:	68 8a       	std	Y+16, r6	; 0x10
    18ce:	79 8a       	std	Y+17, r7	; 0x11
		tmr3Ptr_->setDutyCycleComC( oldPercent_ );
    18d0:	b3 01       	movw	r22, r6
    18d2:	a2 01       	movw	r20, r4
    18d4:	e5 cf       	rjmp	.-54     	; 0x18a0 <_ZN2M69TurnMotorEv+0x9c>

000018d6 <_ZN2M6C1EP6Timer5>:
* Author: jespe
*/

#include "M6.h"

M6::M6( Timer5* tmr )
    18d6:	cf 93       	push	r28
    18d8:	df 93       	push	r29
    18da:	ec 01       	movw	r28, r24
    18dc:	cb 01       	movw	r24, r22
    18de:	2c ee       	ldi	r18, 0xEC	; 236
    18e0:	32 e0       	ldi	r19, 0x02	; 2
    18e2:	39 83       	std	Y+1, r19	; 0x01
    18e4:	28 83       	st	Y, r18
{
	/* Store timer pointer */
	tmr3Ptr_ = tmr;
    18e6:	7d 83       	std	Y+5, r23	; 0x05
    18e8:	6c 83       	std	Y+4, r22	; 0x04
	
	/* This value is number of percent to add or subtract pr degree. */
	percentPrDeg = 0.07936507936507;
    18ea:	49 e2       	ldi	r20, 0x29	; 41
    18ec:	5a e8       	ldi	r21, 0x8A	; 138
    18ee:	62 ea       	ldi	r22, 0xA2	; 162
    18f0:	7d e3       	ldi	r23, 0x3D	; 61
    18f2:	4e 83       	std	Y+6, r20	; 0x06
    18f4:	5f 83       	std	Y+7, r21	; 0x07
    18f6:	68 87       	std	Y+8, r22	; 0x08
    18f8:	79 87       	std	Y+9, r23	; 0x09
	
	/* This value is the lowest duty cycle percentage needed to make motor turn. */
	startpercent_ = 2.5;
    18fa:	40 e0       	ldi	r20, 0x00	; 0
    18fc:	50 e0       	ldi	r21, 0x00	; 0
    18fe:	60 e2       	ldi	r22, 0x20	; 32
    1900:	70 e4       	ldi	r23, 0x40	; 64
    1902:	4a 8b       	std	Y+18, r20	; 0x12
    1904:	5b 8b       	std	Y+19, r21	; 0x13
    1906:	6c 8b       	std	Y+20, r22	; 0x14
    1908:	7d 8b       	std	Y+21, r23	; 0x15
	
	/* This value is the delay on motor. A lower value makes motors go faster and higher value makes motors go slower. Value is in MS */
	delay_ = 1;
    190a:	21 e0       	ldi	r18, 0x01	; 1
    190c:	30 e0       	ldi	r19, 0x00	; 0
    190e:	38 8f       	std	Y+24, r19	; 0x18
    1910:	2f 8b       	std	Y+23, r18	; 0x17
	
	/* This value is the maximum number of degrees the motor can turn */
	maxDegrees_ = 63;
    1912:	2f e3       	ldi	r18, 0x3F	; 63
    1914:	2e 8b       	std	Y+22, r18	; 0x16
    1916:	4a 87       	std	Y+10, r20	; 0x0a
    1918:	5b 87       	std	Y+11, r21	; 0x0b
    191a:	6c 87       	std	Y+12, r22	; 0x0c
    191c:	7d 87       	std	Y+13, r23	; 0x0d
	
	/* Set motor to default startup value */
	SetDegrees( 0 );
	tmr3Ptr_->setDutyCycleComC( percent_ );
    191e:	1c d1       	rcall	.+568    	; 0x1b58 <_ZN6Timer516setDutyCycleComCEf>
	oldPercent_ = percent_;
    1920:	8a 85       	ldd	r24, Y+10	; 0x0a
    1922:	9b 85       	ldd	r25, Y+11	; 0x0b
    1924:	ac 85       	ldd	r26, Y+12	; 0x0c
    1926:	bd 85       	ldd	r27, Y+13	; 0x0d
    1928:	8e 87       	std	Y+14, r24	; 0x0e
    192a:	9f 87       	std	Y+15, r25	; 0x0f
    192c:	a8 8b       	std	Y+16, r26	; 0x10
    192e:	b9 8b       	std	Y+17, r27	; 0x11
}
    1930:	df 91       	pop	r29
    1932:	cf 91       	pop	r28
    1934:	08 95       	ret

00001936 <_ZN6Timer1C1Ev>:
#include <avr/io.h>

Timer1::Timer1()
{
	// Set all needed ports to outputs
	ROBOTARM_M1_OUT_PORT |= ( 1 << ROBOTARM_M1_OUT_PIN );
    1936:	25 9a       	sbi	0x04, 5	; 4
	ROBOTARM_M2_OUT_PORT |= ( 1 << ROBOTARM_M2_OUT_PIN );
    1938:	26 9a       	sbi	0x04, 6	; 4
	ROBOTARM_M3_OUT_PORT |= ( 1 << ROBOTARM_M3_OUT_PIN );
    193a:	27 9a       	sbi	0x04, 7	; 4
		
	// Set timer to run in PWM, Phase Correct mode with 50 Hz freq. 
	TCCR1A = ( 1 << COM1A1 ) | ( 1 << COM1B1 ) | ( 1 << COM1C1 ) | ( 0 << WGM10 ) | ( 0 << WGM11 );
    193c:	88 ea       	ldi	r24, 0xA8	; 168
    193e:	80 93 80 00 	sts	0x0080, r24	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
	TCCR1B = ( 1 << WGM13 ) | ( 0 << CS10 )  | ( 1 << CS12 );
    1942:	84 e1       	ldi	r24, 0x14	; 20
    1944:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x700081>
	TCCR1C = 0;
    1948:	10 92 82 00 	sts	0x0082, r1	; 0x800082 <__TEXT_REGION_LENGTH__+0x700082>
	ICR1 = 622;
    194c:	8e e6       	ldi	r24, 0x6E	; 110
    194e:	92 e0       	ldi	r25, 0x02	; 2
    1950:	90 93 87 00 	sts	0x0087, r25	; 0x800087 <__TEXT_REGION_LENGTH__+0x700087>
    1954:	80 93 86 00 	sts	0x0086, r24	; 0x800086 <__TEXT_REGION_LENGTH__+0x700086>
	
	OCR1A = 0;
    1958:	10 92 89 00 	sts	0x0089, r1	; 0x800089 <__TEXT_REGION_LENGTH__+0x700089>
    195c:	10 92 88 00 	sts	0x0088, r1	; 0x800088 <__TEXT_REGION_LENGTH__+0x700088>
	OCR1B = 0;
    1960:	10 92 8b 00 	sts	0x008B, r1	; 0x80008b <__TEXT_REGION_LENGTH__+0x70008b>
    1964:	10 92 8a 00 	sts	0x008A, r1	; 0x80008a <__TEXT_REGION_LENGTH__+0x70008a>
	OCR1C = 0;
    1968:	10 92 8d 00 	sts	0x008D, r1	; 0x80008d <__TEXT_REGION_LENGTH__+0x70008d>
    196c:	10 92 8c 00 	sts	0x008C, r1	; 0x80008c <__TEXT_REGION_LENGTH__+0x70008c>
    1970:	08 95       	ret

00001972 <_ZN6Timer116setDutyCycleComAEf>:
}

void Timer1::setDutyCycleComA( float dutyCycle )
{
    1972:	cf 92       	push	r12
    1974:	df 92       	push	r13
    1976:	ef 92       	push	r14
    1978:	ff 92       	push	r15
    197a:	6a 01       	movw	r12, r20
    197c:	7b 01       	movw	r14, r22
	float percent = ICR1/100;
    197e:	20 91 86 00 	lds	r18, 0x0086	; 0x800086 <__TEXT_REGION_LENGTH__+0x700086>
    1982:	30 91 87 00 	lds	r19, 0x0087	; 0x800087 <__TEXT_REGION_LENGTH__+0x700087>
	OCR1A = (uint8_t)percent*dutyCycle;
    1986:	36 95       	lsr	r19
    1988:	27 95       	ror	r18
    198a:	36 95       	lsr	r19
    198c:	27 95       	ror	r18
    198e:	ab e7       	ldi	r26, 0x7B	; 123
    1990:	b4 e1       	ldi	r27, 0x14	; 20
    1992:	0e 94 10 1e 	call	0x3c20	; 0x3c20 <__umulhisi3>
    1996:	96 95       	lsr	r25
    1998:	87 95       	ror	r24
    199a:	68 2f       	mov	r22, r24
    199c:	70 e0       	ldi	r23, 0x00	; 0
    199e:	80 e0       	ldi	r24, 0x00	; 0
    19a0:	90 e0       	ldi	r25, 0x00	; 0
    19a2:	0e 94 d7 1c 	call	0x39ae	; 0x39ae <__floatsisf>
    19a6:	a7 01       	movw	r20, r14
    19a8:	96 01       	movw	r18, r12
    19aa:	0e 94 8b 1d 	call	0x3b16	; 0x3b16 <__mulsf3>
    19ae:	0e 94 a9 1c 	call	0x3952	; 0x3952 <__fixunssfsi>
    19b2:	70 93 89 00 	sts	0x0089, r23	; 0x800089 <__TEXT_REGION_LENGTH__+0x700089>
    19b6:	60 93 88 00 	sts	0x0088, r22	; 0x800088 <__TEXT_REGION_LENGTH__+0x700088>
}
    19ba:	ff 90       	pop	r15
    19bc:	ef 90       	pop	r14
    19be:	df 90       	pop	r13
    19c0:	cf 90       	pop	r12
    19c2:	08 95       	ret

000019c4 <_ZN6Timer116setDutyCycleComBEf>:

void Timer1::setDutyCycleComB( float dutyCycle )
{
    19c4:	cf 92       	push	r12
    19c6:	df 92       	push	r13
    19c8:	ef 92       	push	r14
    19ca:	ff 92       	push	r15
    19cc:	6a 01       	movw	r12, r20
    19ce:	7b 01       	movw	r14, r22
	float percent = ICR1/100;
    19d0:	20 91 86 00 	lds	r18, 0x0086	; 0x800086 <__TEXT_REGION_LENGTH__+0x700086>
    19d4:	30 91 87 00 	lds	r19, 0x0087	; 0x800087 <__TEXT_REGION_LENGTH__+0x700087>
	OCR1B = (uint8_t)percent*dutyCycle;
    19d8:	36 95       	lsr	r19
    19da:	27 95       	ror	r18
    19dc:	36 95       	lsr	r19
    19de:	27 95       	ror	r18
    19e0:	ab e7       	ldi	r26, 0x7B	; 123
    19e2:	b4 e1       	ldi	r27, 0x14	; 20
    19e4:	0e 94 10 1e 	call	0x3c20	; 0x3c20 <__umulhisi3>
    19e8:	96 95       	lsr	r25
    19ea:	87 95       	ror	r24
    19ec:	68 2f       	mov	r22, r24
    19ee:	70 e0       	ldi	r23, 0x00	; 0
    19f0:	80 e0       	ldi	r24, 0x00	; 0
    19f2:	90 e0       	ldi	r25, 0x00	; 0
    19f4:	0e 94 d7 1c 	call	0x39ae	; 0x39ae <__floatsisf>
    19f8:	a7 01       	movw	r20, r14
    19fa:	96 01       	movw	r18, r12
    19fc:	0e 94 8b 1d 	call	0x3b16	; 0x3b16 <__mulsf3>
    1a00:	0e 94 a9 1c 	call	0x3952	; 0x3952 <__fixunssfsi>
    1a04:	70 93 8b 00 	sts	0x008B, r23	; 0x80008b <__TEXT_REGION_LENGTH__+0x70008b>
    1a08:	60 93 8a 00 	sts	0x008A, r22	; 0x80008a <__TEXT_REGION_LENGTH__+0x70008a>
}
    1a0c:	ff 90       	pop	r15
    1a0e:	ef 90       	pop	r14
    1a10:	df 90       	pop	r13
    1a12:	cf 90       	pop	r12
    1a14:	08 95       	ret

00001a16 <_ZN6Timer116setDutyCycleComCEf>:

void Timer1::setDutyCycleComC( float dutyCycle )
{
    1a16:	cf 92       	push	r12
    1a18:	df 92       	push	r13
    1a1a:	ef 92       	push	r14
    1a1c:	ff 92       	push	r15
    1a1e:	6a 01       	movw	r12, r20
    1a20:	7b 01       	movw	r14, r22
	float percent = ICR1/100;
    1a22:	20 91 86 00 	lds	r18, 0x0086	; 0x800086 <__TEXT_REGION_LENGTH__+0x700086>
    1a26:	30 91 87 00 	lds	r19, 0x0087	; 0x800087 <__TEXT_REGION_LENGTH__+0x700087>
	OCR1C = (uint8_t)percent*dutyCycle;
    1a2a:	36 95       	lsr	r19
    1a2c:	27 95       	ror	r18
    1a2e:	36 95       	lsr	r19
    1a30:	27 95       	ror	r18
    1a32:	ab e7       	ldi	r26, 0x7B	; 123
    1a34:	b4 e1       	ldi	r27, 0x14	; 20
    1a36:	0e 94 10 1e 	call	0x3c20	; 0x3c20 <__umulhisi3>
    1a3a:	96 95       	lsr	r25
    1a3c:	87 95       	ror	r24
    1a3e:	68 2f       	mov	r22, r24
    1a40:	70 e0       	ldi	r23, 0x00	; 0
    1a42:	80 e0       	ldi	r24, 0x00	; 0
    1a44:	90 e0       	ldi	r25, 0x00	; 0
    1a46:	0e 94 d7 1c 	call	0x39ae	; 0x39ae <__floatsisf>
    1a4a:	a7 01       	movw	r20, r14
    1a4c:	96 01       	movw	r18, r12
    1a4e:	0e 94 8b 1d 	call	0x3b16	; 0x3b16 <__mulsf3>
    1a52:	0e 94 a9 1c 	call	0x3952	; 0x3952 <__fixunssfsi>
    1a56:	70 93 8d 00 	sts	0x008D, r23	; 0x80008d <__TEXT_REGION_LENGTH__+0x70008d>
    1a5a:	60 93 8c 00 	sts	0x008C, r22	; 0x80008c <__TEXT_REGION_LENGTH__+0x70008c>
    1a5e:	ff 90       	pop	r15
    1a60:	ef 90       	pop	r14
    1a62:	df 90       	pop	r13
    1a64:	cf 90       	pop	r12
    1a66:	08 95       	ret

00001a68 <_ZN6Timer5C1Ev>:
#include <avr/io.h>

Timer5::Timer5()
{
	// Set all needed ports to outputs
	ROBOTARM_M4_OUT_PORT |= ( 1 << ROBOTARM_M4_OUT_PIN );
    1a68:	ea e0       	ldi	r30, 0x0A	; 10
    1a6a:	f1 e0       	ldi	r31, 0x01	; 1
    1a6c:	80 81       	ld	r24, Z
    1a6e:	88 60       	ori	r24, 0x08	; 8
    1a70:	80 83       	st	Z, r24
	ROBOTARM_M5_OUT_PORT |= ( 1 << ROBOTARM_M5_OUT_PIN );
    1a72:	80 81       	ld	r24, Z
    1a74:	80 61       	ori	r24, 0x10	; 16
    1a76:	80 83       	st	Z, r24
	ROBOTARM_M6_OUT_PORT |= ( 1 << ROBOTARM_M6_OUT_PIN );
    1a78:	80 81       	ld	r24, Z
    1a7a:	80 62       	ori	r24, 0x20	; 32
    1a7c:	80 83       	st	Z, r24
	
	// Set timer to run in PWM, Phase Correct mode with 50 Hz freq.
	TCCR5A = ( 1 << COM3A1 ) | ( 1 << COM3B1 ) | ( 1 << COM3C1 ) | ( 0 << WGM30 ) | ( 0 << WGM31 );
    1a7e:	88 ea       	ldi	r24, 0xA8	; 168
    1a80:	80 93 20 01 	sts	0x0120, r24	; 0x800120 <__TEXT_REGION_LENGTH__+0x700120>
	TCCR5B = ( 1 << WGM33 ) | ( 0 << CS30 )  | ( 1 << CS32 );
    1a84:	84 e1       	ldi	r24, 0x14	; 20
    1a86:	80 93 21 01 	sts	0x0121, r24	; 0x800121 <__TEXT_REGION_LENGTH__+0x700121>
	TCCR5C = 0;
    1a8a:	10 92 22 01 	sts	0x0122, r1	; 0x800122 <__TEXT_REGION_LENGTH__+0x700122>
	ICR5 = 622;
    1a8e:	8e e6       	ldi	r24, 0x6E	; 110
    1a90:	92 e0       	ldi	r25, 0x02	; 2
    1a92:	90 93 27 01 	sts	0x0127, r25	; 0x800127 <__TEXT_REGION_LENGTH__+0x700127>
    1a96:	80 93 26 01 	sts	0x0126, r24	; 0x800126 <__TEXT_REGION_LENGTH__+0x700126>
	
	OCR5A = 0;
    1a9a:	10 92 29 01 	sts	0x0129, r1	; 0x800129 <__TEXT_REGION_LENGTH__+0x700129>
    1a9e:	10 92 28 01 	sts	0x0128, r1	; 0x800128 <__TEXT_REGION_LENGTH__+0x700128>
	OCR5B = 0;
    1aa2:	10 92 2b 01 	sts	0x012B, r1	; 0x80012b <__TEXT_REGION_LENGTH__+0x70012b>
    1aa6:	10 92 2a 01 	sts	0x012A, r1	; 0x80012a <__TEXT_REGION_LENGTH__+0x70012a>
	OCR5C = 0;
    1aaa:	10 92 2d 01 	sts	0x012D, r1	; 0x80012d <__TEXT_REGION_LENGTH__+0x70012d>
    1aae:	10 92 2c 01 	sts	0x012C, r1	; 0x80012c <__TEXT_REGION_LENGTH__+0x70012c>
    1ab2:	08 95       	ret

00001ab4 <_ZN6Timer516setDutyCycleComAEf>:
}

void Timer5::setDutyCycleComA( float dutyCycle )
{
    1ab4:	cf 92       	push	r12
    1ab6:	df 92       	push	r13
    1ab8:	ef 92       	push	r14
    1aba:	ff 92       	push	r15
    1abc:	6a 01       	movw	r12, r20
    1abe:	7b 01       	movw	r14, r22
	float percent = ICR5/100;
    1ac0:	20 91 26 01 	lds	r18, 0x0126	; 0x800126 <__TEXT_REGION_LENGTH__+0x700126>
    1ac4:	30 91 27 01 	lds	r19, 0x0127	; 0x800127 <__TEXT_REGION_LENGTH__+0x700127>
	OCR5A = (uint8_t)percent*dutyCycle;
    1ac8:	36 95       	lsr	r19
    1aca:	27 95       	ror	r18
    1acc:	36 95       	lsr	r19
    1ace:	27 95       	ror	r18
    1ad0:	ab e7       	ldi	r26, 0x7B	; 123
    1ad2:	b4 e1       	ldi	r27, 0x14	; 20
    1ad4:	0e 94 10 1e 	call	0x3c20	; 0x3c20 <__umulhisi3>
    1ad8:	96 95       	lsr	r25
    1ada:	87 95       	ror	r24
    1adc:	68 2f       	mov	r22, r24
    1ade:	70 e0       	ldi	r23, 0x00	; 0
    1ae0:	80 e0       	ldi	r24, 0x00	; 0
    1ae2:	90 e0       	ldi	r25, 0x00	; 0
    1ae4:	0e 94 d7 1c 	call	0x39ae	; 0x39ae <__floatsisf>
    1ae8:	a7 01       	movw	r20, r14
    1aea:	96 01       	movw	r18, r12
    1aec:	0e 94 8b 1d 	call	0x3b16	; 0x3b16 <__mulsf3>
    1af0:	0e 94 a9 1c 	call	0x3952	; 0x3952 <__fixunssfsi>
    1af4:	70 93 29 01 	sts	0x0129, r23	; 0x800129 <__TEXT_REGION_LENGTH__+0x700129>
    1af8:	60 93 28 01 	sts	0x0128, r22	; 0x800128 <__TEXT_REGION_LENGTH__+0x700128>
}
    1afc:	ff 90       	pop	r15
    1afe:	ef 90       	pop	r14
    1b00:	df 90       	pop	r13
    1b02:	cf 90       	pop	r12
    1b04:	08 95       	ret

00001b06 <_ZN6Timer516setDutyCycleComBEf>:

void Timer5::setDutyCycleComB( float dutyCycle )
{
    1b06:	cf 92       	push	r12
    1b08:	df 92       	push	r13
    1b0a:	ef 92       	push	r14
    1b0c:	ff 92       	push	r15
    1b0e:	6a 01       	movw	r12, r20
    1b10:	7b 01       	movw	r14, r22
	float percent = ICR5/100;
    1b12:	20 91 26 01 	lds	r18, 0x0126	; 0x800126 <__TEXT_REGION_LENGTH__+0x700126>
    1b16:	30 91 27 01 	lds	r19, 0x0127	; 0x800127 <__TEXT_REGION_LENGTH__+0x700127>
	OCR5B = (uint8_t)percent*dutyCycle;
    1b1a:	36 95       	lsr	r19
    1b1c:	27 95       	ror	r18
    1b1e:	36 95       	lsr	r19
    1b20:	27 95       	ror	r18
    1b22:	ab e7       	ldi	r26, 0x7B	; 123
    1b24:	b4 e1       	ldi	r27, 0x14	; 20
    1b26:	0e 94 10 1e 	call	0x3c20	; 0x3c20 <__umulhisi3>
    1b2a:	96 95       	lsr	r25
    1b2c:	87 95       	ror	r24
    1b2e:	68 2f       	mov	r22, r24
    1b30:	70 e0       	ldi	r23, 0x00	; 0
    1b32:	80 e0       	ldi	r24, 0x00	; 0
    1b34:	90 e0       	ldi	r25, 0x00	; 0
    1b36:	0e 94 d7 1c 	call	0x39ae	; 0x39ae <__floatsisf>
    1b3a:	a7 01       	movw	r20, r14
    1b3c:	96 01       	movw	r18, r12
    1b3e:	0e 94 8b 1d 	call	0x3b16	; 0x3b16 <__mulsf3>
    1b42:	0e 94 a9 1c 	call	0x3952	; 0x3952 <__fixunssfsi>
    1b46:	70 93 2b 01 	sts	0x012B, r23	; 0x80012b <__TEXT_REGION_LENGTH__+0x70012b>
    1b4a:	60 93 2a 01 	sts	0x012A, r22	; 0x80012a <__TEXT_REGION_LENGTH__+0x70012a>
}
    1b4e:	ff 90       	pop	r15
    1b50:	ef 90       	pop	r14
    1b52:	df 90       	pop	r13
    1b54:	cf 90       	pop	r12
    1b56:	08 95       	ret

00001b58 <_ZN6Timer516setDutyCycleComCEf>:

void Timer5::setDutyCycleComC( float dutyCycle )
{
    1b58:	cf 92       	push	r12
    1b5a:	df 92       	push	r13
    1b5c:	ef 92       	push	r14
    1b5e:	ff 92       	push	r15
    1b60:	6a 01       	movw	r12, r20
    1b62:	7b 01       	movw	r14, r22
	float percent = ICR5/100;
    1b64:	20 91 26 01 	lds	r18, 0x0126	; 0x800126 <__TEXT_REGION_LENGTH__+0x700126>
    1b68:	30 91 27 01 	lds	r19, 0x0127	; 0x800127 <__TEXT_REGION_LENGTH__+0x700127>
	OCR5C = (uint8_t)percent*dutyCycle;
    1b6c:	36 95       	lsr	r19
    1b6e:	27 95       	ror	r18
    1b70:	36 95       	lsr	r19
    1b72:	27 95       	ror	r18
    1b74:	ab e7       	ldi	r26, 0x7B	; 123
    1b76:	b4 e1       	ldi	r27, 0x14	; 20
    1b78:	0e 94 10 1e 	call	0x3c20	; 0x3c20 <__umulhisi3>
    1b7c:	96 95       	lsr	r25
    1b7e:	87 95       	ror	r24
    1b80:	68 2f       	mov	r22, r24
    1b82:	70 e0       	ldi	r23, 0x00	; 0
    1b84:	80 e0       	ldi	r24, 0x00	; 0
    1b86:	90 e0       	ldi	r25, 0x00	; 0
    1b88:	0e 94 d7 1c 	call	0x39ae	; 0x39ae <__floatsisf>
    1b8c:	a7 01       	movw	r20, r14
    1b8e:	96 01       	movw	r18, r12
    1b90:	0e 94 8b 1d 	call	0x3b16	; 0x3b16 <__mulsf3>
    1b94:	0e 94 a9 1c 	call	0x3952	; 0x3952 <__fixunssfsi>
    1b98:	70 93 2d 01 	sts	0x012D, r23	; 0x80012d <__TEXT_REGION_LENGTH__+0x70012d>
    1b9c:	60 93 2c 01 	sts	0x012C, r22	; 0x80012c <__TEXT_REGION_LENGTH__+0x70012c>
    1ba0:	ff 90       	pop	r15
    1ba2:	ef 90       	pop	r14
    1ba4:	df 90       	pop	r13
    1ba6:	cf 90       	pop	r12
    1ba8:	08 95       	ret

00001baa <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
    1baa:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
    1bac:	03 96       	adiw	r24, 0x03	; 3
    1bae:	92 83       	std	Z+2, r25	; 0x02
    1bb0:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    1bb2:	2f ef       	ldi	r18, 0xFF	; 255
    1bb4:	3f ef       	ldi	r19, 0xFF	; 255
    1bb6:	34 83       	std	Z+4, r19	; 0x04
    1bb8:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
    1bba:	96 83       	std	Z+6, r25	; 0x06
    1bbc:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
    1bbe:	90 87       	std	Z+8, r25	; 0x08
    1bc0:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
    1bc2:	10 82       	st	Z, r1
    1bc4:	08 95       	ret

00001bc6 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    1bc6:	fc 01       	movw	r30, r24
    1bc8:	11 86       	std	Z+9, r1	; 0x09
    1bca:	10 86       	std	Z+8, r1	; 0x08
    1bcc:	08 95       	ret

00001bce <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
    1bce:	cf 93       	push	r28
    1bd0:	df 93       	push	r29
    1bd2:	fc 01       	movw	r30, r24
    1bd4:	db 01       	movw	r26, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
    1bd6:	21 81       	ldd	r18, Z+1	; 0x01
    1bd8:	32 81       	ldd	r19, Z+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
    1bda:	e9 01       	movw	r28, r18
    1bdc:	8a 81       	ldd	r24, Y+2	; 0x02
    1bde:	9b 81       	ldd	r25, Y+3	; 0x03
    1be0:	13 96       	adiw	r26, 0x03	; 3
    1be2:	9c 93       	st	X, r25
    1be4:	8e 93       	st	-X, r24
    1be6:	12 97       	sbiw	r26, 0x02	; 2
	pxNewListItem->pxPrevious = pxList->pxIndex;
    1be8:	81 81       	ldd	r24, Z+1	; 0x01
    1bea:	92 81       	ldd	r25, Z+2	; 0x02
    1bec:	15 96       	adiw	r26, 0x05	; 5
    1bee:	9c 93       	st	X, r25
    1bf0:	8e 93       	st	-X, r24
    1bf2:	14 97       	sbiw	r26, 0x04	; 4
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    1bf4:	8a 81       	ldd	r24, Y+2	; 0x02
    1bf6:	9b 81       	ldd	r25, Y+3	; 0x03
    1bf8:	ec 01       	movw	r28, r24
    1bfa:	7d 83       	std	Y+5, r23	; 0x05
    1bfc:	6c 83       	std	Y+4, r22	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
    1bfe:	e9 01       	movw	r28, r18
    1c00:	7b 83       	std	Y+3, r23	; 0x03
    1c02:	6a 83       	std	Y+2, r22	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
    1c04:	72 83       	std	Z+2, r23	; 0x02
    1c06:	61 83       	std	Z+1, r22	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1c08:	19 96       	adiw	r26, 0x09	; 9
    1c0a:	fc 93       	st	X, r31
    1c0c:	ee 93       	st	-X, r30
    1c0e:	18 97       	sbiw	r26, 0x08	; 8

	( pxList->uxNumberOfItems )++;
    1c10:	80 81       	ld	r24, Z
    1c12:	8f 5f       	subi	r24, 0xFF	; 255
    1c14:	80 83       	st	Z, r24
}
    1c16:	df 91       	pop	r29
    1c18:	cf 91       	pop	r28
    1c1a:	08 95       	ret

00001c1c <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
    1c1c:	cf 93       	push	r28
    1c1e:	df 93       	push	r29
    1c20:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
    1c22:	48 81       	ld	r20, Y
    1c24:	59 81       	ldd	r21, Y+1	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    1c26:	4f 3f       	cpi	r20, 0xFF	; 255
    1c28:	2f ef       	ldi	r18, 0xFF	; 255
    1c2a:	52 07       	cpc	r21, r18
    1c2c:	31 f4       	brne	.+12     	; 0x1c3a <vListInsert+0x1e>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    1c2e:	dc 01       	movw	r26, r24
    1c30:	17 96       	adiw	r26, 0x07	; 7
    1c32:	ed 91       	ld	r30, X+
    1c34:	fc 91       	ld	r31, X
    1c36:	18 97       	sbiw	r26, 0x08	; 8
    1c38:	0d c0       	rjmp	.+26     	; 0x1c54 <vListInsert+0x38>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    1c3a:	fc 01       	movw	r30, r24
    1c3c:	33 96       	adiw	r30, 0x03	; 3
    1c3e:	03 c0       	rjmp	.+6      	; 0x1c46 <vListInsert+0x2a>
    1c40:	02 80       	ldd	r0, Z+2	; 0x02
    1c42:	f3 81       	ldd	r31, Z+3	; 0x03
    1c44:	e0 2d       	mov	r30, r0
    1c46:	a2 81       	ldd	r26, Z+2	; 0x02
    1c48:	b3 81       	ldd	r27, Z+3	; 0x03
    1c4a:	2d 91       	ld	r18, X+
    1c4c:	3c 91       	ld	r19, X
    1c4e:	42 17       	cp	r20, r18
    1c50:	53 07       	cpc	r21, r19
    1c52:	b0 f7       	brcc	.-20     	; 0x1c40 <vListInsert+0x24>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    1c54:	a2 81       	ldd	r26, Z+2	; 0x02
    1c56:	b3 81       	ldd	r27, Z+3	; 0x03
    1c58:	bb 83       	std	Y+3, r27	; 0x03
    1c5a:	aa 83       	std	Y+2, r26	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    1c5c:	15 96       	adiw	r26, 0x05	; 5
    1c5e:	dc 93       	st	X, r29
    1c60:	ce 93       	st	-X, r28
    1c62:	14 97       	sbiw	r26, 0x04	; 4
	pxNewListItem->pxPrevious = pxIterator;
    1c64:	fd 83       	std	Y+5, r31	; 0x05
    1c66:	ec 83       	std	Y+4, r30	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    1c68:	d3 83       	std	Z+3, r29	; 0x03
    1c6a:	c2 83       	std	Z+2, r28	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1c6c:	99 87       	std	Y+9, r25	; 0x09
    1c6e:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    1c70:	fc 01       	movw	r30, r24
    1c72:	20 81       	ld	r18, Z
    1c74:	2f 5f       	subi	r18, 0xFF	; 255
    1c76:	20 83       	st	Z, r18
}
    1c78:	df 91       	pop	r29
    1c7a:	cf 91       	pop	r28
    1c7c:	08 95       	ret

00001c7e <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
    1c7e:	fc 01       	movw	r30, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    1c80:	a2 81       	ldd	r26, Z+2	; 0x02
    1c82:	b3 81       	ldd	r27, Z+3	; 0x03
    1c84:	84 81       	ldd	r24, Z+4	; 0x04
    1c86:	95 81       	ldd	r25, Z+5	; 0x05
    1c88:	15 96       	adiw	r26, 0x05	; 5
    1c8a:	9c 93       	st	X, r25
    1c8c:	8e 93       	st	-X, r24
    1c8e:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    1c90:	a4 81       	ldd	r26, Z+4	; 0x04
    1c92:	b5 81       	ldd	r27, Z+5	; 0x05
    1c94:	82 81       	ldd	r24, Z+2	; 0x02
    1c96:	93 81       	ldd	r25, Z+3	; 0x03
    1c98:	13 96       	adiw	r26, 0x03	; 3
    1c9a:	9c 93       	st	X, r25
    1c9c:	8e 93       	st	-X, r24
    1c9e:	12 97       	sbiw	r26, 0x02	; 2
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    1ca0:	a0 85       	ldd	r26, Z+8	; 0x08
    1ca2:	b1 85       	ldd	r27, Z+9	; 0x09

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    1ca4:	11 96       	adiw	r26, 0x01	; 1
    1ca6:	8d 91       	ld	r24, X+
    1ca8:	9c 91       	ld	r25, X
    1caa:	12 97       	sbiw	r26, 0x02	; 2
    1cac:	e8 17       	cp	r30, r24
    1cae:	f9 07       	cpc	r31, r25
    1cb0:	31 f4       	brne	.+12     	; 0x1cbe <vListRemove+0x40>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    1cb2:	84 81       	ldd	r24, Z+4	; 0x04
    1cb4:	95 81       	ldd	r25, Z+5	; 0x05
    1cb6:	12 96       	adiw	r26, 0x02	; 2
    1cb8:	9c 93       	st	X, r25
    1cba:	8e 93       	st	-X, r24
    1cbc:	11 97       	sbiw	r26, 0x01	; 1
	}

	pxItemToRemove->pvContainer = NULL;
    1cbe:	11 86       	std	Z+9, r1	; 0x09
    1cc0:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    1cc2:	8c 91       	ld	r24, X
    1cc4:	81 50       	subi	r24, 0x01	; 1
    1cc6:	8c 93       	st	X, r24
    1cc8:	08 95       	ret

00001cca <prvSetupTimerInterrupt>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    1cca:	8a ef       	ldi	r24, 0xFA	; 250
    1ccc:	87 bd       	out	0x27, r24	; 39
    1cce:	82 e0       	ldi	r24, 0x02	; 2
    1cd0:	84 bd       	out	0x24, r24	; 36
    1cd2:	93 e0       	ldi	r25, 0x03	; 3
    1cd4:	95 bd       	out	0x25, r25	; 37
    1cd6:	80 93 6e 00 	sts	0x006E, r24	; 0x80006e <__TEXT_REGION_LENGTH__+0x70006e>
    1cda:	08 95       	ret

00001cdc <pxPortInitialiseStack>:
    1cdc:	31 e1       	ldi	r19, 0x11	; 17
    1cde:	fc 01       	movw	r30, r24
    1ce0:	30 83       	st	Z, r19
    1ce2:	31 97       	sbiw	r30, 0x01	; 1
    1ce4:	22 e2       	ldi	r18, 0x22	; 34
    1ce6:	20 83       	st	Z, r18
    1ce8:	31 97       	sbiw	r30, 0x01	; 1
    1cea:	a3 e3       	ldi	r26, 0x33	; 51
    1cec:	a0 83       	st	Z, r26
    1cee:	31 97       	sbiw	r30, 0x01	; 1
    1cf0:	60 83       	st	Z, r22
    1cf2:	31 97       	sbiw	r30, 0x01	; 1
    1cf4:	70 83       	st	Z, r23
    1cf6:	31 97       	sbiw	r30, 0x01	; 1
    1cf8:	10 82       	st	Z, r1
    1cfa:	31 97       	sbiw	r30, 0x01	; 1
    1cfc:	10 82       	st	Z, r1
    1cfe:	31 97       	sbiw	r30, 0x01	; 1
    1d00:	60 e8       	ldi	r22, 0x80	; 128
    1d02:	60 83       	st	Z, r22
    1d04:	31 97       	sbiw	r30, 0x01	; 1
    1d06:	10 82       	st	Z, r1
    1d08:	31 97       	sbiw	r30, 0x01	; 1
    1d0a:	10 82       	st	Z, r1
    1d0c:	31 97       	sbiw	r30, 0x01	; 1
    1d0e:	10 82       	st	Z, r1
    1d10:	31 97       	sbiw	r30, 0x01	; 1
    1d12:	62 e0       	ldi	r22, 0x02	; 2
    1d14:	60 83       	st	Z, r22
    1d16:	31 97       	sbiw	r30, 0x01	; 1
    1d18:	63 e0       	ldi	r22, 0x03	; 3
    1d1a:	60 83       	st	Z, r22
    1d1c:	31 97       	sbiw	r30, 0x01	; 1
    1d1e:	64 e0       	ldi	r22, 0x04	; 4
    1d20:	60 83       	st	Z, r22
    1d22:	31 97       	sbiw	r30, 0x01	; 1
    1d24:	65 e0       	ldi	r22, 0x05	; 5
    1d26:	60 83       	st	Z, r22
    1d28:	31 97       	sbiw	r30, 0x01	; 1
    1d2a:	66 e0       	ldi	r22, 0x06	; 6
    1d2c:	60 83       	st	Z, r22
    1d2e:	31 97       	sbiw	r30, 0x01	; 1
    1d30:	67 e0       	ldi	r22, 0x07	; 7
    1d32:	60 83       	st	Z, r22
    1d34:	31 97       	sbiw	r30, 0x01	; 1
    1d36:	68 e0       	ldi	r22, 0x08	; 8
    1d38:	60 83       	st	Z, r22
    1d3a:	31 97       	sbiw	r30, 0x01	; 1
    1d3c:	69 e0       	ldi	r22, 0x09	; 9
    1d3e:	60 83       	st	Z, r22
    1d40:	31 97       	sbiw	r30, 0x01	; 1
    1d42:	60 e1       	ldi	r22, 0x10	; 16
    1d44:	60 83       	st	Z, r22
    1d46:	31 97       	sbiw	r30, 0x01	; 1
    1d48:	30 83       	st	Z, r19
    1d4a:	31 97       	sbiw	r30, 0x01	; 1
    1d4c:	32 e1       	ldi	r19, 0x12	; 18
    1d4e:	30 83       	st	Z, r19
    1d50:	31 97       	sbiw	r30, 0x01	; 1
    1d52:	33 e1       	ldi	r19, 0x13	; 19
    1d54:	30 83       	st	Z, r19
    1d56:	31 97       	sbiw	r30, 0x01	; 1
    1d58:	34 e1       	ldi	r19, 0x14	; 20
    1d5a:	30 83       	st	Z, r19
    1d5c:	31 97       	sbiw	r30, 0x01	; 1
    1d5e:	35 e1       	ldi	r19, 0x15	; 21
    1d60:	30 83       	st	Z, r19
    1d62:	31 97       	sbiw	r30, 0x01	; 1
    1d64:	36 e1       	ldi	r19, 0x16	; 22
    1d66:	30 83       	st	Z, r19
    1d68:	31 97       	sbiw	r30, 0x01	; 1
    1d6a:	37 e1       	ldi	r19, 0x17	; 23
    1d6c:	30 83       	st	Z, r19
    1d6e:	31 97       	sbiw	r30, 0x01	; 1
    1d70:	38 e1       	ldi	r19, 0x18	; 24
    1d72:	30 83       	st	Z, r19
    1d74:	31 97       	sbiw	r30, 0x01	; 1
    1d76:	39 e1       	ldi	r19, 0x19	; 25
    1d78:	30 83       	st	Z, r19
    1d7a:	31 97       	sbiw	r30, 0x01	; 1
    1d7c:	30 e2       	ldi	r19, 0x20	; 32
    1d7e:	30 83       	st	Z, r19
    1d80:	31 97       	sbiw	r30, 0x01	; 1
    1d82:	31 e2       	ldi	r19, 0x21	; 33
    1d84:	30 83       	st	Z, r19
    1d86:	31 97       	sbiw	r30, 0x01	; 1
    1d88:	20 83       	st	Z, r18
    1d8a:	31 97       	sbiw	r30, 0x01	; 1
    1d8c:	23 e2       	ldi	r18, 0x23	; 35
    1d8e:	20 83       	st	Z, r18
    1d90:	31 97       	sbiw	r30, 0x01	; 1
    1d92:	40 83       	st	Z, r20
    1d94:	31 97       	sbiw	r30, 0x01	; 1
    1d96:	50 83       	st	Z, r21
    1d98:	31 97       	sbiw	r30, 0x01	; 1
    1d9a:	26 e2       	ldi	r18, 0x26	; 38
    1d9c:	20 83       	st	Z, r18
    1d9e:	31 97       	sbiw	r30, 0x01	; 1
    1da0:	27 e2       	ldi	r18, 0x27	; 39
    1da2:	20 83       	st	Z, r18
    1da4:	31 97       	sbiw	r30, 0x01	; 1
    1da6:	28 e2       	ldi	r18, 0x28	; 40
    1da8:	20 83       	st	Z, r18
    1daa:	31 97       	sbiw	r30, 0x01	; 1
    1dac:	29 e2       	ldi	r18, 0x29	; 41
    1dae:	20 83       	st	Z, r18
    1db0:	31 97       	sbiw	r30, 0x01	; 1
    1db2:	20 e3       	ldi	r18, 0x30	; 48
    1db4:	20 83       	st	Z, r18
    1db6:	31 97       	sbiw	r30, 0x01	; 1
    1db8:	21 e3       	ldi	r18, 0x31	; 49
    1dba:	20 83       	st	Z, r18
    1dbc:	89 97       	sbiw	r24, 0x29	; 41
    1dbe:	08 95       	ret

00001dc0 <xPortStartScheduler>:
    1dc0:	84 df       	rcall	.-248    	; 0x1cca <prvSetupTimerInterrupt>
    1dc2:	a0 91 de 12 	lds	r26, 0x12DE	; 0x8012de <pxCurrentTCB>
    1dc6:	b0 91 df 12 	lds	r27, 0x12DF	; 0x8012df <pxCurrentTCB+0x1>
    1dca:	cd 91       	ld	r28, X+
    1dcc:	cd bf       	out	0x3d, r28	; 61
    1dce:	dd 91       	ld	r29, X+
    1dd0:	de bf       	out	0x3e, r29	; 62
    1dd2:	ff 91       	pop	r31
    1dd4:	ef 91       	pop	r30
    1dd6:	df 91       	pop	r29
    1dd8:	cf 91       	pop	r28
    1dda:	bf 91       	pop	r27
    1ddc:	af 91       	pop	r26
    1dde:	9f 91       	pop	r25
    1de0:	8f 91       	pop	r24
    1de2:	7f 91       	pop	r23
    1de4:	6f 91       	pop	r22
    1de6:	5f 91       	pop	r21
    1de8:	4f 91       	pop	r20
    1dea:	3f 91       	pop	r19
    1dec:	2f 91       	pop	r18
    1dee:	1f 91       	pop	r17
    1df0:	0f 91       	pop	r16
    1df2:	ff 90       	pop	r15
    1df4:	ef 90       	pop	r14
    1df6:	df 90       	pop	r13
    1df8:	cf 90       	pop	r12
    1dfa:	bf 90       	pop	r11
    1dfc:	af 90       	pop	r10
    1dfe:	9f 90       	pop	r9
    1e00:	8f 90       	pop	r8
    1e02:	7f 90       	pop	r7
    1e04:	6f 90       	pop	r6
    1e06:	5f 90       	pop	r5
    1e08:	4f 90       	pop	r4
    1e0a:	3f 90       	pop	r3
    1e0c:	2f 90       	pop	r2
    1e0e:	1f 90       	pop	r1
    1e10:	0f 90       	pop	r0
    1e12:	0c be       	out	0x3c, r0	; 60
    1e14:	0f 90       	pop	r0
    1e16:	0b be       	out	0x3b, r0	; 59
    1e18:	0f 90       	pop	r0
    1e1a:	0f be       	out	0x3f, r0	; 63
    1e1c:	0f 90       	pop	r0
    1e1e:	08 95       	ret
    1e20:	81 e0       	ldi	r24, 0x01	; 1
    1e22:	08 95       	ret

00001e24 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    1e24:	0f 92       	push	r0
    1e26:	0f b6       	in	r0, 0x3f	; 63
    1e28:	f8 94       	cli
    1e2a:	0f 92       	push	r0
    1e2c:	0b b6       	in	r0, 0x3b	; 59
    1e2e:	0f 92       	push	r0
    1e30:	0c b6       	in	r0, 0x3c	; 60
    1e32:	0f 92       	push	r0
    1e34:	1f 92       	push	r1
    1e36:	11 24       	eor	r1, r1
    1e38:	2f 92       	push	r2
    1e3a:	3f 92       	push	r3
    1e3c:	4f 92       	push	r4
    1e3e:	5f 92       	push	r5
    1e40:	6f 92       	push	r6
    1e42:	7f 92       	push	r7
    1e44:	8f 92       	push	r8
    1e46:	9f 92       	push	r9
    1e48:	af 92       	push	r10
    1e4a:	bf 92       	push	r11
    1e4c:	cf 92       	push	r12
    1e4e:	df 92       	push	r13
    1e50:	ef 92       	push	r14
    1e52:	ff 92       	push	r15
    1e54:	0f 93       	push	r16
    1e56:	1f 93       	push	r17
    1e58:	2f 93       	push	r18
    1e5a:	3f 93       	push	r19
    1e5c:	4f 93       	push	r20
    1e5e:	5f 93       	push	r21
    1e60:	6f 93       	push	r22
    1e62:	7f 93       	push	r23
    1e64:	8f 93       	push	r24
    1e66:	9f 93       	push	r25
    1e68:	af 93       	push	r26
    1e6a:	bf 93       	push	r27
    1e6c:	cf 93       	push	r28
    1e6e:	df 93       	push	r29
    1e70:	ef 93       	push	r30
    1e72:	ff 93       	push	r31
    1e74:	a0 91 de 12 	lds	r26, 0x12DE	; 0x8012de <pxCurrentTCB>
    1e78:	b0 91 df 12 	lds	r27, 0x12DF	; 0x8012df <pxCurrentTCB+0x1>
    1e7c:	0d b6       	in	r0, 0x3d	; 61
    1e7e:	0d 92       	st	X+, r0
    1e80:	0e b6       	in	r0, 0x3e	; 62
    1e82:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    1e84:	86 d3       	rcall	.+1804   	; 0x2592 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1e86:	a0 91 de 12 	lds	r26, 0x12DE	; 0x8012de <pxCurrentTCB>
    1e8a:	b0 91 df 12 	lds	r27, 0x12DF	; 0x8012df <pxCurrentTCB+0x1>
    1e8e:	cd 91       	ld	r28, X+
    1e90:	cd bf       	out	0x3d, r28	; 61
    1e92:	dd 91       	ld	r29, X+
    1e94:	de bf       	out	0x3e, r29	; 62
    1e96:	ff 91       	pop	r31
    1e98:	ef 91       	pop	r30
    1e9a:	df 91       	pop	r29
    1e9c:	cf 91       	pop	r28
    1e9e:	bf 91       	pop	r27
    1ea0:	af 91       	pop	r26
    1ea2:	9f 91       	pop	r25
    1ea4:	8f 91       	pop	r24
    1ea6:	7f 91       	pop	r23
    1ea8:	6f 91       	pop	r22
    1eaa:	5f 91       	pop	r21
    1eac:	4f 91       	pop	r20
    1eae:	3f 91       	pop	r19
    1eb0:	2f 91       	pop	r18
    1eb2:	1f 91       	pop	r17
    1eb4:	0f 91       	pop	r16
    1eb6:	ff 90       	pop	r15
    1eb8:	ef 90       	pop	r14
    1eba:	df 90       	pop	r13
    1ebc:	cf 90       	pop	r12
    1ebe:	bf 90       	pop	r11
    1ec0:	af 90       	pop	r10
    1ec2:	9f 90       	pop	r9
    1ec4:	8f 90       	pop	r8
    1ec6:	7f 90       	pop	r7
    1ec8:	6f 90       	pop	r6
    1eca:	5f 90       	pop	r5
    1ecc:	4f 90       	pop	r4
    1ece:	3f 90       	pop	r3
    1ed0:	2f 90       	pop	r2
    1ed2:	1f 90       	pop	r1
    1ed4:	0f 90       	pop	r0
    1ed6:	0c be       	out	0x3c, r0	; 60
    1ed8:	0f 90       	pop	r0
    1eda:	0b be       	out	0x3b, r0	; 59
    1edc:	0f 90       	pop	r0
    1ede:	0f be       	out	0x3f, r0	; 63
    1ee0:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1ee2:	08 95       	ret

00001ee4 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    1ee4:	0f 92       	push	r0
    1ee6:	0f b6       	in	r0, 0x3f	; 63
    1ee8:	f8 94       	cli
    1eea:	0f 92       	push	r0
    1eec:	0b b6       	in	r0, 0x3b	; 59
    1eee:	0f 92       	push	r0
    1ef0:	0c b6       	in	r0, 0x3c	; 60
    1ef2:	0f 92       	push	r0
    1ef4:	1f 92       	push	r1
    1ef6:	11 24       	eor	r1, r1
    1ef8:	2f 92       	push	r2
    1efa:	3f 92       	push	r3
    1efc:	4f 92       	push	r4
    1efe:	5f 92       	push	r5
    1f00:	6f 92       	push	r6
    1f02:	7f 92       	push	r7
    1f04:	8f 92       	push	r8
    1f06:	9f 92       	push	r9
    1f08:	af 92       	push	r10
    1f0a:	bf 92       	push	r11
    1f0c:	cf 92       	push	r12
    1f0e:	df 92       	push	r13
    1f10:	ef 92       	push	r14
    1f12:	ff 92       	push	r15
    1f14:	0f 93       	push	r16
    1f16:	1f 93       	push	r17
    1f18:	2f 93       	push	r18
    1f1a:	3f 93       	push	r19
    1f1c:	4f 93       	push	r20
    1f1e:	5f 93       	push	r21
    1f20:	6f 93       	push	r22
    1f22:	7f 93       	push	r23
    1f24:	8f 93       	push	r24
    1f26:	9f 93       	push	r25
    1f28:	af 93       	push	r26
    1f2a:	bf 93       	push	r27
    1f2c:	cf 93       	push	r28
    1f2e:	df 93       	push	r29
    1f30:	ef 93       	push	r30
    1f32:	ff 93       	push	r31
    1f34:	a0 91 de 12 	lds	r26, 0x12DE	; 0x8012de <pxCurrentTCB>
    1f38:	b0 91 df 12 	lds	r27, 0x12DF	; 0x8012df <pxCurrentTCB+0x1>
    1f3c:	0d b6       	in	r0, 0x3d	; 61
    1f3e:	0d 92       	st	X+, r0
    1f40:	0e b6       	in	r0, 0x3e	; 62
    1f42:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    1f44:	f1 d1       	rcall	.+994    	; 0x2328 <vTaskIncrementTick>
	vTaskSwitchContext();
    1f46:	25 d3       	rcall	.+1610   	; 0x2592 <vTaskSwitchContext>
    1f48:	a0 91 de 12 	lds	r26, 0x12DE	; 0x8012de <pxCurrentTCB>
	portRESTORE_CONTEXT();
    1f4c:	b0 91 df 12 	lds	r27, 0x12DF	; 0x8012df <pxCurrentTCB+0x1>
    1f50:	cd 91       	ld	r28, X+
    1f52:	cd bf       	out	0x3d, r28	; 61
    1f54:	dd 91       	ld	r29, X+
    1f56:	de bf       	out	0x3e, r29	; 62
    1f58:	ff 91       	pop	r31
    1f5a:	ef 91       	pop	r30
    1f5c:	df 91       	pop	r29
    1f5e:	cf 91       	pop	r28
    1f60:	bf 91       	pop	r27
    1f62:	af 91       	pop	r26
    1f64:	9f 91       	pop	r25
    1f66:	8f 91       	pop	r24
    1f68:	7f 91       	pop	r23
    1f6a:	6f 91       	pop	r22
    1f6c:	5f 91       	pop	r21
    1f6e:	4f 91       	pop	r20
    1f70:	3f 91       	pop	r19
    1f72:	2f 91       	pop	r18
    1f74:	1f 91       	pop	r17
    1f76:	0f 91       	pop	r16
    1f78:	ff 90       	pop	r15
    1f7a:	ef 90       	pop	r14
    1f7c:	df 90       	pop	r13
    1f7e:	cf 90       	pop	r12
    1f80:	bf 90       	pop	r11
    1f82:	af 90       	pop	r10
    1f84:	9f 90       	pop	r9
    1f86:	8f 90       	pop	r8
    1f88:	7f 90       	pop	r7
    1f8a:	6f 90       	pop	r6
    1f8c:	5f 90       	pop	r5
    1f8e:	4f 90       	pop	r4
    1f90:	3f 90       	pop	r3
    1f92:	2f 90       	pop	r2
    1f94:	1f 90       	pop	r1
    1f96:	0f 90       	pop	r0
    1f98:	0c be       	out	0x3c, r0	; 60
    1f9a:	0f 90       	pop	r0
    1f9c:	0b be       	out	0x3b, r0	; 59
    1f9e:	0f 90       	pop	r0
    1fa0:	0f be       	out	0x3f, r0	; 63
    1fa2:	0f 90       	pop	r0
    1fa4:	08 95       	ret

00001fa6 <__vector_21>:
	asm volatile ( "ret" );
    1fa6:	9e df       	rcall	.-196    	; 0x1ee4 <vPortYieldFromTick>
//	void SIG_OUTPUT_COMPARE1A( void )
	void TIMER0_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER0_COMPA_vect( void )
	{
		vPortYieldFromTick();
		asm volatile ( "reti" );
    1fa8:	18 95       	reti

00001faa <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    1faa:	cf 93       	push	r28
    1fac:	df 93       	push	r29
    1fae:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
    1fb0:	b5 d1       	rcall	.+874    	; 0x231c <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
    1fb2:	20 91 09 03 	lds	r18, 0x0309	; 0x800309 <xNextFreeByte>
    1fb6:	30 91 0a 03 	lds	r19, 0x030A	; 0x80030a <xNextFreeByte+0x1>
    1fba:	c9 01       	movw	r24, r18
    1fbc:	8c 0f       	add	r24, r28
    1fbe:	9d 1f       	adc	r25, r29
    1fc0:	80 3a       	cpi	r24, 0xA0	; 160
    1fc2:	4f e0       	ldi	r20, 0x0F	; 15
    1fc4:	94 07       	cpc	r25, r20
    1fc6:	58 f4       	brcc	.+22     	; 0x1fde <pvPortMalloc+0x34>
    1fc8:	28 17       	cp	r18, r24
    1fca:	39 07       	cpc	r19, r25
    1fcc:	58 f4       	brcc	.+22     	; 0x1fe4 <pvPortMalloc+0x3a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
    1fce:	e9 01       	movw	r28, r18
    1fd0:	c5 5f       	subi	r28, 0xF5	; 245
    1fd2:	dc 4f       	sbci	r29, 0xFC	; 252
			xNextFreeByte += xWantedSize;			
    1fd4:	90 93 0a 03 	sts	0x030A, r25	; 0x80030a <xNextFreeByte+0x1>
    1fd8:	80 93 09 03 	sts	0x0309, r24	; 0x800309 <xNextFreeByte>
    1fdc:	05 c0       	rjmp	.+10     	; 0x1fe8 <pvPortMalloc+0x3e>
static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL; 
    1fde:	c0 e0       	ldi	r28, 0x00	; 0
    1fe0:	d0 e0       	ldi	r29, 0x00	; 0
    1fe2:	02 c0       	rjmp	.+4      	; 0x1fe8 <pvPortMalloc+0x3e>
    1fe4:	c0 e0       	ldi	r28, 0x00	; 0
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
			xNextFreeByte += xWantedSize;			
		}	
	}
	xTaskResumeAll();
    1fe6:	d0 e0       	ldi	r29, 0x00	; 0
    1fe8:	46 d2       	rcall	.+1164   	; 0x2476 <xTaskResumeAll>
		}
	}
	#endif	

	return pvReturn;
}
    1fea:	ce 01       	movw	r24, r28
    1fec:	df 91       	pop	r29
    1fee:	cf 91       	pop	r28
    1ff0:	08 95       	ret

00001ff2 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    1ff2:	08 95       	ret

00001ff4 <prvIdleTask>:
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
		}
	}
    1ff4:	80 91 d5 12 	lds	r24, 0x12D5	; 0x8012d5 <pxReadyTasksLists>
    1ff8:	82 30       	cpi	r24, 0x02	; 2
    1ffa:	e0 f3       	brcs	.-8      	; 0x1ff4 <prvIdleTask>
    1ffc:	13 df       	rcall	.-474    	; 0x1e24 <vPortYield>
    1ffe:	fa cf       	rjmp	.-12     	; 0x1ff4 <prvIdleTask>

00002000 <prvAllocateTCBAndStack>:
    2000:	ef 92       	push	r14
    2002:	ff 92       	push	r15
    2004:	0f 93       	push	r16
    2006:	1f 93       	push	r17
    2008:	cf 93       	push	r28
    200a:	df 93       	push	r29
    200c:	7c 01       	movw	r14, r24
    200e:	eb 01       	movw	r28, r22
    2010:	81 e2       	ldi	r24, 0x21	; 33
    2012:	90 e0       	ldi	r25, 0x00	; 0
    2014:	ca df       	rcall	.-108    	; 0x1faa <pvPortMalloc>
    2016:	8c 01       	movw	r16, r24
    2018:	89 2b       	or	r24, r25
    201a:	a9 f0       	breq	.+42     	; 0x2046 <prvAllocateTCBAndStack+0x46>
    201c:	20 97       	sbiw	r28, 0x00	; 0
    201e:	19 f4       	brne	.+6      	; 0x2026 <prvAllocateTCBAndStack+0x26>
    2020:	c7 01       	movw	r24, r14
    2022:	c3 df       	rcall	.-122    	; 0x1faa <pvPortMalloc>
    2024:	01 c0       	rjmp	.+2      	; 0x2028 <prvAllocateTCBAndStack+0x28>
    2026:	ce 01       	movw	r24, r28
    2028:	f8 01       	movw	r30, r16
    202a:	90 8f       	std	Z+24, r25	; 0x18
    202c:	87 8b       	std	Z+23, r24	; 0x17
    202e:	00 97       	sbiw	r24, 0x00	; 0
    2030:	29 f4       	brne	.+10     	; 0x203c <prvAllocateTCBAndStack+0x3c>
    2032:	c8 01       	movw	r24, r16
    2034:	de df       	rcall	.-68     	; 0x1ff2 <vPortFree>
    2036:	00 e0       	ldi	r16, 0x00	; 0
    2038:	10 e0       	ldi	r17, 0x00	; 0
    203a:	05 c0       	rjmp	.+10     	; 0x2046 <prvAllocateTCBAndStack+0x46>
    203c:	a7 01       	movw	r20, r14
    203e:	65 ea       	ldi	r22, 0xA5	; 165
    2040:	70 e0       	ldi	r23, 0x00	; 0
    2042:	0e 94 48 1f 	call	0x3e90	; 0x3e90 <memset>
    2046:	c8 01       	movw	r24, r16
    2048:	df 91       	pop	r29
    204a:	cf 91       	pop	r28
    204c:	1f 91       	pop	r17
    204e:	0f 91       	pop	r16
    2050:	ff 90       	pop	r15
    2052:	ef 90       	pop	r14
    2054:	08 95       	ret

00002056 <prvInitialiseTCBVariables>:
    2056:	1f 93       	push	r17
    2058:	cf 93       	push	r28
    205a:	df 93       	push	r29
    205c:	ec 01       	movw	r28, r24
    205e:	14 2f       	mov	r17, r20
    2060:	48 e0       	ldi	r20, 0x08	; 8
    2062:	50 e0       	ldi	r21, 0x00	; 0
    2064:	49 96       	adiw	r24, 0x19	; 25
    2066:	0e 94 4f 1f 	call	0x3e9e	; 0x3e9e <strncpy>
    206a:	18 a2       	std	Y+32, r1	; 0x20
    206c:	11 11       	cpse	r17, r1
    206e:	10 e0       	ldi	r17, 0x00	; 0
    2070:	1e 8b       	std	Y+22, r17	; 0x16
    2072:	ce 01       	movw	r24, r28
    2074:	02 96       	adiw	r24, 0x02	; 2
    2076:	a7 dd       	rcall	.-1202   	; 0x1bc6 <vListInitialiseItem>
    2078:	ce 01       	movw	r24, r28
    207a:	0c 96       	adiw	r24, 0x0c	; 12
    207c:	a4 dd       	rcall	.-1208   	; 0x1bc6 <vListInitialiseItem>
    207e:	d9 87       	std	Y+9, r29	; 0x09
    2080:	c8 87       	std	Y+8, r28	; 0x08
    2082:	81 e0       	ldi	r24, 0x01	; 1
    2084:	90 e0       	ldi	r25, 0x00	; 0
    2086:	81 1b       	sub	r24, r17
    2088:	91 09       	sbc	r25, r1
    208a:	9d 87       	std	Y+13, r25	; 0x0d
    208c:	8c 87       	std	Y+12, r24	; 0x0c
    208e:	db 8b       	std	Y+19, r29	; 0x13
    2090:	ca 8b       	std	Y+18, r28	; 0x12
    2092:	df 91       	pop	r29
    2094:	cf 91       	pop	r28
    2096:	1f 91       	pop	r17
    2098:	08 95       	ret

0000209a <prvInitialiseTaskLists>:
    209a:	cf 93       	push	r28
    209c:	c0 e0       	ldi	r28, 0x00	; 0
    209e:	0f c0       	rjmp	.+30     	; 0x20be <prvInitialiseTaskLists+0x24>
    20a0:	8c 2f       	mov	r24, r28
    20a2:	90 e0       	ldi	r25, 0x00	; 0
    20a4:	9c 01       	movw	r18, r24
    20a6:	22 0f       	add	r18, r18
    20a8:	33 1f       	adc	r19, r19
    20aa:	22 0f       	add	r18, r18
    20ac:	33 1f       	adc	r19, r19
    20ae:	22 0f       	add	r18, r18
    20b0:	33 1f       	adc	r19, r19
    20b2:	82 0f       	add	r24, r18
    20b4:	93 1f       	adc	r25, r19
    20b6:	8b 52       	subi	r24, 0x2B	; 43
    20b8:	9d 4e       	sbci	r25, 0xED	; 237
    20ba:	77 dd       	rcall	.-1298   	; 0x1baa <vListInitialise>
    20bc:	cf 5f       	subi	r28, 0xFF	; 255
    20be:	cc 23       	and	r28, r28
    20c0:	79 f3       	breq	.-34     	; 0x20a0 <prvInitialiseTaskLists+0x6>
    20c2:	8c ec       	ldi	r24, 0xCC	; 204
    20c4:	92 e1       	ldi	r25, 0x12	; 18
    20c6:	71 dd       	rcall	.-1310   	; 0x1baa <vListInitialise>
    20c8:	83 ec       	ldi	r24, 0xC3	; 195
    20ca:	92 e1       	ldi	r25, 0x12	; 18
    20cc:	6e dd       	rcall	.-1316   	; 0x1baa <vListInitialise>
    20ce:	86 eb       	ldi	r24, 0xB6	; 182
    20d0:	92 e1       	ldi	r25, 0x12	; 18
    20d2:	6b dd       	rcall	.-1322   	; 0x1baa <vListInitialise>
    20d4:	8c ec       	ldi	r24, 0xCC	; 204
    20d6:	92 e1       	ldi	r25, 0x12	; 18
    20d8:	90 93 c2 12 	sts	0x12C2, r25	; 0x8012c2 <pxDelayedTaskList+0x1>
    20dc:	80 93 c1 12 	sts	0x12C1, r24	; 0x8012c1 <pxDelayedTaskList>
    20e0:	83 ec       	ldi	r24, 0xC3	; 195
    20e2:	92 e1       	ldi	r25, 0x12	; 18
    20e4:	90 93 c0 12 	sts	0x12C0, r25	; 0x8012c0 <pxOverflowDelayedTaskList+0x1>
    20e8:	80 93 bf 12 	sts	0x12BF, r24	; 0x8012bf <pxOverflowDelayedTaskList>
    20ec:	cf 91       	pop	r28
    20ee:	08 95       	ret

000020f0 <prvAddCurrentTaskToDelayedList>:
    20f0:	cf 93       	push	r28
    20f2:	df 93       	push	r29
    20f4:	ec 01       	movw	r28, r24
    20f6:	e0 91 de 12 	lds	r30, 0x12DE	; 0x8012de <pxCurrentTCB>
    20fa:	f0 91 df 12 	lds	r31, 0x12DF	; 0x8012df <pxCurrentTCB+0x1>
    20fe:	93 83       	std	Z+3, r25	; 0x03
    2100:	82 83       	std	Z+2, r24	; 0x02
    2102:	80 91 b3 12 	lds	r24, 0x12B3	; 0x8012b3 <xTickCount>
    2106:	90 91 b4 12 	lds	r25, 0x12B4	; 0x8012b4 <xTickCount+0x1>
    210a:	c8 17       	cp	r28, r24
    210c:	d9 07       	cpc	r29, r25
    210e:	60 f4       	brcc	.+24     	; 0x2128 <prvAddCurrentTaskToDelayedList+0x38>
    2110:	60 91 de 12 	lds	r22, 0x12DE	; 0x8012de <pxCurrentTCB>
    2114:	70 91 df 12 	lds	r23, 0x12DF	; 0x8012df <pxCurrentTCB+0x1>
    2118:	80 91 bf 12 	lds	r24, 0x12BF	; 0x8012bf <pxOverflowDelayedTaskList>
    211c:	90 91 c0 12 	lds	r25, 0x12C0	; 0x8012c0 <pxOverflowDelayedTaskList+0x1>
    2120:	6e 5f       	subi	r22, 0xFE	; 254
    2122:	7f 4f       	sbci	r23, 0xFF	; 255
    2124:	7b dd       	rcall	.-1290   	; 0x1c1c <vListInsert>
    2126:	16 c0       	rjmp	.+44     	; 0x2154 <prvAddCurrentTaskToDelayedList+0x64>
    2128:	60 91 de 12 	lds	r22, 0x12DE	; 0x8012de <pxCurrentTCB>
    212c:	70 91 df 12 	lds	r23, 0x12DF	; 0x8012df <pxCurrentTCB+0x1>
    2130:	80 91 c1 12 	lds	r24, 0x12C1	; 0x8012c1 <pxDelayedTaskList>
    2134:	90 91 c2 12 	lds	r25, 0x12C2	; 0x8012c2 <pxDelayedTaskList+0x1>
    2138:	6e 5f       	subi	r22, 0xFE	; 254
    213a:	7f 4f       	sbci	r23, 0xFF	; 255
    213c:	6f dd       	rcall	.-1314   	; 0x1c1c <vListInsert>
    213e:	80 91 0b 02 	lds	r24, 0x020B	; 0x80020b <xNextTaskUnblockTime>
    2142:	90 91 0c 02 	lds	r25, 0x020C	; 0x80020c <xNextTaskUnblockTime+0x1>
    2146:	c8 17       	cp	r28, r24
    2148:	d9 07       	cpc	r29, r25
    214a:	20 f4       	brcc	.+8      	; 0x2154 <prvAddCurrentTaskToDelayedList+0x64>
    214c:	d0 93 0c 02 	sts	0x020C, r29	; 0x80020c <xNextTaskUnblockTime+0x1>
    2150:	c0 93 0b 02 	sts	0x020B, r28	; 0x80020b <xNextTaskUnblockTime>
    2154:	df 91       	pop	r29
    2156:	cf 91       	pop	r28
    2158:	08 95       	ret

0000215a <xTaskGenericCreate>:
    215a:	2f 92       	push	r2
    215c:	3f 92       	push	r3
    215e:	4f 92       	push	r4
    2160:	5f 92       	push	r5
    2162:	7f 92       	push	r7
    2164:	8f 92       	push	r8
    2166:	9f 92       	push	r9
    2168:	af 92       	push	r10
    216a:	bf 92       	push	r11
    216c:	cf 92       	push	r12
    216e:	df 92       	push	r13
    2170:	ef 92       	push	r14
    2172:	ff 92       	push	r15
    2174:	0f 93       	push	r16
    2176:	1f 93       	push	r17
    2178:	cf 93       	push	r28
    217a:	df 93       	push	r29
    217c:	00 d0       	rcall	.+0      	; 0x217e <xTaskGenericCreate+0x24>
    217e:	1f 92       	push	r1
    2180:	cd b7       	in	r28, 0x3d	; 61
    2182:	de b7       	in	r29, 0x3e	; 62
    2184:	9a 83       	std	Y+2, r25	; 0x02
    2186:	89 83       	std	Y+1, r24	; 0x01
    2188:	4b 01       	movw	r8, r22
    218a:	5c 83       	std	Y+4, r21	; 0x04
    218c:	4b 83       	std	Y+3, r20	; 0x03
    218e:	19 01       	movw	r2, r18
    2190:	70 2e       	mov	r7, r16
    2192:	b6 01       	movw	r22, r12
    2194:	25 01       	movw	r4, r10
    2196:	ca 01       	movw	r24, r20
    2198:	33 df       	rcall	.-410    	; 0x2000 <prvAllocateTCBAndStack>
    219a:	5c 01       	movw	r10, r24
    219c:	00 97       	sbiw	r24, 0x00	; 0
    219e:	09 f4       	brne	.+2      	; 0x21a2 <xTaskGenericCreate+0x48>
    21a0:	6c c0       	rjmp	.+216    	; 0x227a <__stack+0x7b>
    21a2:	fc 01       	movw	r30, r24
    21a4:	c7 88       	ldd	r12, Z+23	; 0x17
    21a6:	d0 8c       	ldd	r13, Z+24	; 0x18
    21a8:	8b 81       	ldd	r24, Y+3	; 0x03
    21aa:	9c 81       	ldd	r25, Y+4	; 0x04
    21ac:	01 97       	sbiw	r24, 0x01	; 1
    21ae:	c8 0e       	add	r12, r24
    21b0:	d9 1e       	adc	r13, r25
    21b2:	0b 81       	ldd	r16, Y+3	; 0x03
    21b4:	1c 81       	ldd	r17, Y+4	; 0x04
    21b6:	92 01       	movw	r18, r4
    21b8:	47 2d       	mov	r20, r7
    21ba:	b4 01       	movw	r22, r8
    21bc:	c5 01       	movw	r24, r10
    21be:	4b df       	rcall	.-362    	; 0x2056 <prvInitialiseTCBVariables>
    21c0:	a1 01       	movw	r20, r2
    21c2:	69 81       	ldd	r22, Y+1	; 0x01
    21c4:	7a 81       	ldd	r23, Y+2	; 0x02
    21c6:	c6 01       	movw	r24, r12
    21c8:	89 dd       	rcall	.-1262   	; 0x1cdc <pxPortInitialiseStack>
    21ca:	f5 01       	movw	r30, r10
    21cc:	91 83       	std	Z+1, r25	; 0x01
    21ce:	80 83       	st	Z, r24
    21d0:	e1 14       	cp	r14, r1
    21d2:	f1 04       	cpc	r15, r1
    21d4:	19 f0       	breq	.+6      	; 0x21dc <xTaskGenericCreate+0x82>
    21d6:	f7 01       	movw	r30, r14
    21d8:	b1 82       	std	Z+1, r11	; 0x01
    21da:	a0 82       	st	Z, r10
    21dc:	0f b6       	in	r0, 0x3f	; 63
    21de:	f8 94       	cli
    21e0:	0f 92       	push	r0
    21e2:	80 91 b5 12 	lds	r24, 0x12B5	; 0x8012b5 <uxCurrentNumberOfTasks>
    21e6:	8f 5f       	subi	r24, 0xFF	; 255
    21e8:	80 93 b5 12 	sts	0x12B5, r24	; 0x8012b5 <uxCurrentNumberOfTasks>
    21ec:	80 91 de 12 	lds	r24, 0x12DE	; 0x8012de <pxCurrentTCB>
    21f0:	90 91 df 12 	lds	r25, 0x12DF	; 0x8012df <pxCurrentTCB+0x1>
    21f4:	89 2b       	or	r24, r25
    21f6:	51 f4       	brne	.+20     	; 0x220c <__stack+0xd>
    21f8:	b0 92 df 12 	sts	0x12DF, r11	; 0x8012df <pxCurrentTCB+0x1>
    21fc:	a0 92 de 12 	sts	0x12DE, r10	; 0x8012de <pxCurrentTCB>
    2200:	80 91 b5 12 	lds	r24, 0x12B5	; 0x8012b5 <uxCurrentNumberOfTasks>
    2204:	81 30       	cpi	r24, 0x01	; 1
    2206:	89 f4       	brne	.+34     	; 0x222a <__stack+0x2b>
    2208:	48 df       	rcall	.-368    	; 0x209a <prvInitialiseTaskLists>
    220a:	0f c0       	rjmp	.+30     	; 0x222a <__stack+0x2b>
    220c:	80 91 b0 12 	lds	r24, 0x12B0	; 0x8012b0 <xSchedulerRunning>
    2210:	81 11       	cpse	r24, r1
    2212:	0b c0       	rjmp	.+22     	; 0x222a <__stack+0x2b>
    2214:	e0 91 de 12 	lds	r30, 0x12DE	; 0x8012de <pxCurrentTCB>
    2218:	f0 91 df 12 	lds	r31, 0x12DF	; 0x8012df <pxCurrentTCB+0x1>
    221c:	86 89       	ldd	r24, Z+22	; 0x16
    221e:	78 16       	cp	r7, r24
    2220:	20 f0       	brcs	.+8      	; 0x222a <__stack+0x2b>
    2222:	b0 92 df 12 	sts	0x12DF, r11	; 0x8012df <pxCurrentTCB+0x1>
    2226:	a0 92 de 12 	sts	0x12DE, r10	; 0x8012de <pxCurrentTCB>
    222a:	f5 01       	movw	r30, r10
    222c:	86 89       	ldd	r24, Z+22	; 0x16
    222e:	90 91 b2 12 	lds	r25, 0x12B2	; 0x8012b2 <uxTopUsedPriority>
    2232:	98 17       	cp	r25, r24
    2234:	10 f4       	brcc	.+4      	; 0x223a <__stack+0x3b>
    2236:	80 93 b2 12 	sts	0x12B2, r24	; 0x8012b2 <uxTopUsedPriority>
    223a:	90 91 ab 12 	lds	r25, 0x12AB	; 0x8012ab <uxTCBNumber>
    223e:	9f 5f       	subi	r25, 0xFF	; 255
    2240:	90 93 ab 12 	sts	0x12AB, r25	; 0x8012ab <uxTCBNumber>
    2244:	90 91 b1 12 	lds	r25, 0x12B1	; 0x8012b1 <uxTopReadyPriority>
    2248:	98 17       	cp	r25, r24
    224a:	10 f4       	brcc	.+4      	; 0x2250 <__stack+0x51>
    224c:	80 93 b1 12 	sts	0x12B1, r24	; 0x8012b1 <uxTopReadyPriority>
    2250:	90 e0       	ldi	r25, 0x00	; 0
    2252:	b5 01       	movw	r22, r10
    2254:	6e 5f       	subi	r22, 0xFE	; 254
    2256:	7f 4f       	sbci	r23, 0xFF	; 255
    2258:	9c 01       	movw	r18, r24
    225a:	22 0f       	add	r18, r18
    225c:	33 1f       	adc	r19, r19
    225e:	22 0f       	add	r18, r18
    2260:	33 1f       	adc	r19, r19
    2262:	22 0f       	add	r18, r18
    2264:	33 1f       	adc	r19, r19
    2266:	82 0f       	add	r24, r18
    2268:	93 1f       	adc	r25, r19
    226a:	8b 52       	subi	r24, 0x2B	; 43
    226c:	9d 4e       	sbci	r25, 0xED	; 237
    226e:	af dc       	rcall	.-1698   	; 0x1bce <vListInsertEnd>
    2270:	0f 90       	pop	r0
    2272:	0f be       	out	0x3f, r0	; 63
    2274:	f1 e0       	ldi	r31, 0x01	; 1
    2276:	f9 83       	std	Y+1, r31	; 0x01
    2278:	02 c0       	rjmp	.+4      	; 0x227e <__stack+0x7f>
    227a:	8f ef       	ldi	r24, 0xFF	; 255
    227c:	89 83       	std	Y+1, r24	; 0x01
    227e:	e9 81       	ldd	r30, Y+1	; 0x01
    2280:	e1 30       	cpi	r30, 0x01	; 1
    2282:	61 f4       	brne	.+24     	; 0x229c <__stack+0x9d>
    2284:	80 91 b0 12 	lds	r24, 0x12B0	; 0x8012b0 <xSchedulerRunning>
    2288:	88 23       	and	r24, r24
    228a:	41 f0       	breq	.+16     	; 0x229c <__stack+0x9d>
    228c:	e0 91 de 12 	lds	r30, 0x12DE	; 0x8012de <pxCurrentTCB>
    2290:	f0 91 df 12 	lds	r31, 0x12DF	; 0x8012df <pxCurrentTCB+0x1>
    2294:	86 89       	ldd	r24, Z+22	; 0x16
    2296:	87 15       	cp	r24, r7
    2298:	08 f4       	brcc	.+2      	; 0x229c <__stack+0x9d>
    229a:	c4 dd       	rcall	.-1144   	; 0x1e24 <vPortYield>
    229c:	89 81       	ldd	r24, Y+1	; 0x01
    229e:	0f 90       	pop	r0
    22a0:	0f 90       	pop	r0
    22a2:	0f 90       	pop	r0
    22a4:	0f 90       	pop	r0
    22a6:	df 91       	pop	r29
    22a8:	cf 91       	pop	r28
    22aa:	1f 91       	pop	r17
    22ac:	0f 91       	pop	r16
    22ae:	ff 90       	pop	r15
    22b0:	ef 90       	pop	r14
    22b2:	df 90       	pop	r13
    22b4:	cf 90       	pop	r12
    22b6:	bf 90       	pop	r11
    22b8:	af 90       	pop	r10
    22ba:	9f 90       	pop	r9
    22bc:	8f 90       	pop	r8
    22be:	7f 90       	pop	r7
    22c0:	5f 90       	pop	r5
    22c2:	4f 90       	pop	r4
    22c4:	3f 90       	pop	r3
    22c6:	2f 90       	pop	r2
    22c8:	08 95       	ret

000022ca <vTaskStartScheduler>:
    22ca:	af 92       	push	r10
    22cc:	bf 92       	push	r11
    22ce:	cf 92       	push	r12
    22d0:	df 92       	push	r13
    22d2:	ef 92       	push	r14
    22d4:	ff 92       	push	r15
    22d6:	0f 93       	push	r16
    22d8:	a1 2c       	mov	r10, r1
    22da:	b1 2c       	mov	r11, r1
    22dc:	c1 2c       	mov	r12, r1
    22de:	d1 2c       	mov	r13, r1
    22e0:	e1 2c       	mov	r14, r1
    22e2:	f1 2c       	mov	r15, r1
    22e4:	00 e0       	ldi	r16, 0x00	; 0
    22e6:	20 e0       	ldi	r18, 0x00	; 0
    22e8:	30 e0       	ldi	r19, 0x00	; 0
    22ea:	45 e5       	ldi	r20, 0x55	; 85
    22ec:	50 e0       	ldi	r21, 0x00	; 0
    22ee:	64 ef       	ldi	r22, 0xF4	; 244
    22f0:	72 e0       	ldi	r23, 0x02	; 2
    22f2:	8a ef       	ldi	r24, 0xFA	; 250
    22f4:	9f e0       	ldi	r25, 0x0F	; 15
    22f6:	31 df       	rcall	.-414    	; 0x215a <xTaskGenericCreate>
    22f8:	81 30       	cpi	r24, 0x01	; 1
    22fa:	41 f4       	brne	.+16     	; 0x230c <vTaskStartScheduler+0x42>
    22fc:	f8 94       	cli
    22fe:	80 93 b0 12 	sts	0x12B0, r24	; 0x8012b0 <xSchedulerRunning>
    2302:	10 92 b4 12 	sts	0x12B4, r1	; 0x8012b4 <xTickCount+0x1>
    2306:	10 92 b3 12 	sts	0x12B3, r1	; 0x8012b3 <xTickCount>
    230a:	5a dd       	rcall	.-1356   	; 0x1dc0 <xPortStartScheduler>
    230c:	0f 91       	pop	r16
    230e:	ff 90       	pop	r15
    2310:	ef 90       	pop	r14
    2312:	df 90       	pop	r13
    2314:	cf 90       	pop	r12
    2316:	bf 90       	pop	r11
    2318:	af 90       	pop	r10
    231a:	08 95       	ret

0000231c <vTaskSuspendAll>:
    231c:	80 91 af 12 	lds	r24, 0x12AF	; 0x8012af <uxSchedulerSuspended>
    2320:	8f 5f       	subi	r24, 0xFF	; 255
    2322:	80 93 af 12 	sts	0x12AF, r24	; 0x8012af <uxSchedulerSuspended>
    2326:	08 95       	ret

00002328 <vTaskIncrementTick>:
    2328:	0f 93       	push	r16
    232a:	1f 93       	push	r17
    232c:	cf 93       	push	r28
    232e:	df 93       	push	r29
    2330:	80 91 af 12 	lds	r24, 0x12AF	; 0x8012af <uxSchedulerSuspended>
    2334:	81 11       	cpse	r24, r1
    2336:	95 c0       	rjmp	.+298    	; 0x2462 <vTaskIncrementTick+0x13a>
    2338:	80 91 b3 12 	lds	r24, 0x12B3	; 0x8012b3 <xTickCount>
    233c:	90 91 b4 12 	lds	r25, 0x12B4	; 0x8012b4 <xTickCount+0x1>
    2340:	01 96       	adiw	r24, 0x01	; 1
    2342:	90 93 b4 12 	sts	0x12B4, r25	; 0x8012b4 <xTickCount+0x1>
    2346:	80 93 b3 12 	sts	0x12B3, r24	; 0x8012b3 <xTickCount>
    234a:	80 91 b3 12 	lds	r24, 0x12B3	; 0x8012b3 <xTickCount>
    234e:	90 91 b4 12 	lds	r25, 0x12B4	; 0x8012b4 <xTickCount+0x1>
    2352:	89 2b       	or	r24, r25
    2354:	99 f5       	brne	.+102    	; 0x23bc <vTaskIncrementTick+0x94>
    2356:	80 91 c1 12 	lds	r24, 0x12C1	; 0x8012c1 <pxDelayedTaskList>
    235a:	90 91 c2 12 	lds	r25, 0x12C2	; 0x8012c2 <pxDelayedTaskList+0x1>
    235e:	20 91 bf 12 	lds	r18, 0x12BF	; 0x8012bf <pxOverflowDelayedTaskList>
    2362:	30 91 c0 12 	lds	r19, 0x12C0	; 0x8012c0 <pxOverflowDelayedTaskList+0x1>
    2366:	30 93 c2 12 	sts	0x12C2, r19	; 0x8012c2 <pxDelayedTaskList+0x1>
    236a:	20 93 c1 12 	sts	0x12C1, r18	; 0x8012c1 <pxDelayedTaskList>
    236e:	90 93 c0 12 	sts	0x12C0, r25	; 0x8012c0 <pxOverflowDelayedTaskList+0x1>
    2372:	80 93 bf 12 	sts	0x12BF, r24	; 0x8012bf <pxOverflowDelayedTaskList>
    2376:	80 91 ac 12 	lds	r24, 0x12AC	; 0x8012ac <xNumOfOverflows>
    237a:	8f 5f       	subi	r24, 0xFF	; 255
    237c:	80 93 ac 12 	sts	0x12AC, r24	; 0x8012ac <xNumOfOverflows>
    2380:	e0 91 c1 12 	lds	r30, 0x12C1	; 0x8012c1 <pxDelayedTaskList>
    2384:	f0 91 c2 12 	lds	r31, 0x12C2	; 0x8012c2 <pxDelayedTaskList+0x1>
    2388:	80 81       	ld	r24, Z
    238a:	81 11       	cpse	r24, r1
    238c:	07 c0       	rjmp	.+14     	; 0x239c <vTaskIncrementTick+0x74>
    238e:	8f ef       	ldi	r24, 0xFF	; 255
    2390:	9f ef       	ldi	r25, 0xFF	; 255
    2392:	90 93 0c 02 	sts	0x020C, r25	; 0x80020c <xNextTaskUnblockTime+0x1>
    2396:	80 93 0b 02 	sts	0x020B, r24	; 0x80020b <xNextTaskUnblockTime>
    239a:	10 c0       	rjmp	.+32     	; 0x23bc <vTaskIncrementTick+0x94>
    239c:	e0 91 c1 12 	lds	r30, 0x12C1	; 0x8012c1 <pxDelayedTaskList>
    23a0:	f0 91 c2 12 	lds	r31, 0x12C2	; 0x8012c2 <pxDelayedTaskList+0x1>
    23a4:	05 80       	ldd	r0, Z+5	; 0x05
    23a6:	f6 81       	ldd	r31, Z+6	; 0x06
    23a8:	e0 2d       	mov	r30, r0
    23aa:	06 80       	ldd	r0, Z+6	; 0x06
    23ac:	f7 81       	ldd	r31, Z+7	; 0x07
    23ae:	e0 2d       	mov	r30, r0
    23b0:	82 81       	ldd	r24, Z+2	; 0x02
    23b2:	93 81       	ldd	r25, Z+3	; 0x03
    23b4:	90 93 0c 02 	sts	0x020C, r25	; 0x80020c <xNextTaskUnblockTime+0x1>
    23b8:	80 93 0b 02 	sts	0x020B, r24	; 0x80020b <xNextTaskUnblockTime>
    23bc:	20 91 b3 12 	lds	r18, 0x12B3	; 0x8012b3 <xTickCount>
    23c0:	30 91 b4 12 	lds	r19, 0x12B4	; 0x8012b4 <xTickCount+0x1>
    23c4:	80 91 0b 02 	lds	r24, 0x020B	; 0x80020b <xNextTaskUnblockTime>
    23c8:	90 91 0c 02 	lds	r25, 0x020C	; 0x80020c <xNextTaskUnblockTime+0x1>
    23cc:	28 17       	cp	r18, r24
    23ce:	39 07       	cpc	r19, r25
    23d0:	08 f4       	brcc	.+2      	; 0x23d4 <vTaskIncrementTick+0xac>
    23d2:	4c c0       	rjmp	.+152    	; 0x246c <vTaskIncrementTick+0x144>
    23d4:	e0 91 c1 12 	lds	r30, 0x12C1	; 0x8012c1 <pxDelayedTaskList>
    23d8:	f0 91 c2 12 	lds	r31, 0x12C2	; 0x8012c2 <pxDelayedTaskList+0x1>
    23dc:	80 81       	ld	r24, Z
    23de:	81 11       	cpse	r24, r1
    23e0:	07 c0       	rjmp	.+14     	; 0x23f0 <vTaskIncrementTick+0xc8>
    23e2:	8f ef       	ldi	r24, 0xFF	; 255
    23e4:	9f ef       	ldi	r25, 0xFF	; 255
    23e6:	90 93 0c 02 	sts	0x020C, r25	; 0x80020c <xNextTaskUnblockTime+0x1>
    23ea:	80 93 0b 02 	sts	0x020B, r24	; 0x80020b <xNextTaskUnblockTime>
    23ee:	3e c0       	rjmp	.+124    	; 0x246c <vTaskIncrementTick+0x144>
    23f0:	e0 91 c1 12 	lds	r30, 0x12C1	; 0x8012c1 <pxDelayedTaskList>
    23f4:	f0 91 c2 12 	lds	r31, 0x12C2	; 0x8012c2 <pxDelayedTaskList+0x1>
    23f8:	05 80       	ldd	r0, Z+5	; 0x05
    23fa:	f6 81       	ldd	r31, Z+6	; 0x06
    23fc:	e0 2d       	mov	r30, r0
    23fe:	c6 81       	ldd	r28, Z+6	; 0x06
    2400:	d7 81       	ldd	r29, Z+7	; 0x07
    2402:	8a 81       	ldd	r24, Y+2	; 0x02
    2404:	9b 81       	ldd	r25, Y+3	; 0x03
    2406:	20 91 b3 12 	lds	r18, 0x12B3	; 0x8012b3 <xTickCount>
    240a:	30 91 b4 12 	lds	r19, 0x12B4	; 0x8012b4 <xTickCount+0x1>
    240e:	28 17       	cp	r18, r24
    2410:	39 07       	cpc	r19, r25
    2412:	28 f4       	brcc	.+10     	; 0x241e <vTaskIncrementTick+0xf6>
    2414:	90 93 0c 02 	sts	0x020C, r25	; 0x80020c <xNextTaskUnblockTime+0x1>
    2418:	80 93 0b 02 	sts	0x020B, r24	; 0x80020b <xNextTaskUnblockTime>
    241c:	27 c0       	rjmp	.+78     	; 0x246c <vTaskIncrementTick+0x144>
    241e:	8e 01       	movw	r16, r28
    2420:	0e 5f       	subi	r16, 0xFE	; 254
    2422:	1f 4f       	sbci	r17, 0xFF	; 255
    2424:	c8 01       	movw	r24, r16
    2426:	2b dc       	rcall	.-1962   	; 0x1c7e <vListRemove>
    2428:	8c 89       	ldd	r24, Y+20	; 0x14
    242a:	9d 89       	ldd	r25, Y+21	; 0x15
    242c:	89 2b       	or	r24, r25
    242e:	19 f0       	breq	.+6      	; 0x2436 <vTaskIncrementTick+0x10e>
    2430:	ce 01       	movw	r24, r28
    2432:	0c 96       	adiw	r24, 0x0c	; 12
    2434:	24 dc       	rcall	.-1976   	; 0x1c7e <vListRemove>
    2436:	8e 89       	ldd	r24, Y+22	; 0x16
    2438:	90 91 b1 12 	lds	r25, 0x12B1	; 0x8012b1 <uxTopReadyPriority>
    243c:	98 17       	cp	r25, r24
    243e:	10 f4       	brcc	.+4      	; 0x2444 <vTaskIncrementTick+0x11c>
    2440:	80 93 b1 12 	sts	0x12B1, r24	; 0x8012b1 <uxTopReadyPriority>
    2444:	90 e0       	ldi	r25, 0x00	; 0
    2446:	9c 01       	movw	r18, r24
    2448:	22 0f       	add	r18, r18
    244a:	33 1f       	adc	r19, r19
    244c:	22 0f       	add	r18, r18
    244e:	33 1f       	adc	r19, r19
    2450:	22 0f       	add	r18, r18
    2452:	33 1f       	adc	r19, r19
    2454:	82 0f       	add	r24, r18
    2456:	93 1f       	adc	r25, r19
    2458:	b8 01       	movw	r22, r16
    245a:	8b 52       	subi	r24, 0x2B	; 43
    245c:	9d 4e       	sbci	r25, 0xED	; 237
    245e:	b7 db       	rcall	.-2194   	; 0x1bce <vListInsertEnd>
    2460:	b9 cf       	rjmp	.-142    	; 0x23d4 <vTaskIncrementTick+0xac>
    2462:	80 91 ae 12 	lds	r24, 0x12AE	; 0x8012ae <uxMissedTicks>
    2466:	8f 5f       	subi	r24, 0xFF	; 255
    2468:	80 93 ae 12 	sts	0x12AE, r24	; 0x8012ae <uxMissedTicks>
    246c:	df 91       	pop	r29
    246e:	cf 91       	pop	r28
    2470:	1f 91       	pop	r17
    2472:	0f 91       	pop	r16
    2474:	08 95       	ret

00002476 <xTaskResumeAll>:
    2476:	ff 92       	push	r15
    2478:	0f 93       	push	r16
    247a:	1f 93       	push	r17
    247c:	cf 93       	push	r28
    247e:	df 93       	push	r29
    2480:	0f b6       	in	r0, 0x3f	; 63
    2482:	f8 94       	cli
    2484:	0f 92       	push	r0
    2486:	80 91 af 12 	lds	r24, 0x12AF	; 0x8012af <uxSchedulerSuspended>
    248a:	81 50       	subi	r24, 0x01	; 1
    248c:	80 93 af 12 	sts	0x12AF, r24	; 0x8012af <uxSchedulerSuspended>
    2490:	80 91 af 12 	lds	r24, 0x12AF	; 0x8012af <uxSchedulerSuspended>
    2494:	81 11       	cpse	r24, r1
    2496:	55 c0       	rjmp	.+170    	; 0x2542 <xTaskResumeAll+0xcc>
    2498:	80 91 b5 12 	lds	r24, 0x12B5	; 0x8012b5 <uxCurrentNumberOfTasks>
    249c:	81 11       	cpse	r24, r1
    249e:	2f c0       	rjmp	.+94     	; 0x24fe <xTaskResumeAll+0x88>
    24a0:	53 c0       	rjmp	.+166    	; 0x2548 <xTaskResumeAll+0xd2>
    24a2:	e0 91 bb 12 	lds	r30, 0x12BB	; 0x8012bb <xPendingReadyList+0x5>
    24a6:	f0 91 bc 12 	lds	r31, 0x12BC	; 0x8012bc <xPendingReadyList+0x6>
    24aa:	c6 81       	ldd	r28, Z+6	; 0x06
    24ac:	d7 81       	ldd	r29, Z+7	; 0x07
    24ae:	ce 01       	movw	r24, r28
    24b0:	0c 96       	adiw	r24, 0x0c	; 12
    24b2:	e5 db       	rcall	.-2102   	; 0x1c7e <vListRemove>
    24b4:	8e 01       	movw	r16, r28
    24b6:	0e 5f       	subi	r16, 0xFE	; 254
    24b8:	1f 4f       	sbci	r17, 0xFF	; 255
    24ba:	c8 01       	movw	r24, r16
    24bc:	e0 db       	rcall	.-2112   	; 0x1c7e <vListRemove>
    24be:	8e 89       	ldd	r24, Y+22	; 0x16
    24c0:	90 91 b1 12 	lds	r25, 0x12B1	; 0x8012b1 <uxTopReadyPriority>
    24c4:	98 17       	cp	r25, r24
    24c6:	10 f4       	brcc	.+4      	; 0x24cc <xTaskResumeAll+0x56>
    24c8:	80 93 b1 12 	sts	0x12B1, r24	; 0x8012b1 <uxTopReadyPriority>
    24cc:	90 e0       	ldi	r25, 0x00	; 0
    24ce:	9c 01       	movw	r18, r24
    24d0:	22 0f       	add	r18, r18
    24d2:	33 1f       	adc	r19, r19
    24d4:	22 0f       	add	r18, r18
    24d6:	33 1f       	adc	r19, r19
    24d8:	22 0f       	add	r18, r18
    24da:	33 1f       	adc	r19, r19
    24dc:	82 0f       	add	r24, r18
    24de:	93 1f       	adc	r25, r19
    24e0:	b8 01       	movw	r22, r16
    24e2:	8b 52       	subi	r24, 0x2B	; 43
    24e4:	9d 4e       	sbci	r25, 0xED	; 237
    24e6:	73 db       	rcall	.-2330   	; 0x1bce <vListInsertEnd>
    24e8:	9e 89       	ldd	r25, Y+22	; 0x16
    24ea:	e0 91 de 12 	lds	r30, 0x12DE	; 0x8012de <pxCurrentTCB>
    24ee:	f0 91 df 12 	lds	r31, 0x12DF	; 0x8012df <pxCurrentTCB+0x1>
    24f2:	86 89       	ldd	r24, Z+22	; 0x16
    24f4:	98 17       	cp	r25, r24
    24f6:	20 f0       	brcs	.+8      	; 0x2500 <xTaskResumeAll+0x8a>
    24f8:	ff 24       	eor	r15, r15
    24fa:	f3 94       	inc	r15
    24fc:	01 c0       	rjmp	.+2      	; 0x2500 <xTaskResumeAll+0x8a>
    24fe:	f1 2c       	mov	r15, r1
    2500:	80 91 b6 12 	lds	r24, 0x12B6	; 0x8012b6 <xPendingReadyList>
    2504:	81 11       	cpse	r24, r1
    2506:	cd cf       	rjmp	.-102    	; 0x24a2 <xTaskResumeAll+0x2c>
    2508:	80 91 ae 12 	lds	r24, 0x12AE	; 0x8012ae <uxMissedTicks>
    250c:	81 11       	cpse	r24, r1
    250e:	07 c0       	rjmp	.+14     	; 0x251e <xTaskResumeAll+0xa8>
    2510:	0c c0       	rjmp	.+24     	; 0x252a <xTaskResumeAll+0xb4>
    2512:	0a df       	rcall	.-492    	; 0x2328 <vTaskIncrementTick>
    2514:	80 91 ae 12 	lds	r24, 0x12AE	; 0x8012ae <uxMissedTicks>
    2518:	81 50       	subi	r24, 0x01	; 1
    251a:	80 93 ae 12 	sts	0x12AE, r24	; 0x8012ae <uxMissedTicks>
    251e:	80 91 ae 12 	lds	r24, 0x12AE	; 0x8012ae <uxMissedTicks>
    2522:	81 11       	cpse	r24, r1
    2524:	f6 cf       	rjmp	.-20     	; 0x2512 <xTaskResumeAll+0x9c>
    2526:	ff 24       	eor	r15, r15
    2528:	f3 94       	inc	r15
    252a:	81 e0       	ldi	r24, 0x01	; 1
    252c:	f8 16       	cp	r15, r24
    252e:	21 f0       	breq	.+8      	; 0x2538 <xTaskResumeAll+0xc2>
    2530:	80 91 ad 12 	lds	r24, 0x12AD	; 0x8012ad <xMissedYield>
    2534:	81 30       	cpi	r24, 0x01	; 1
    2536:	39 f4       	brne	.+14     	; 0x2546 <xTaskResumeAll+0xd0>
    2538:	10 92 ad 12 	sts	0x12AD, r1	; 0x8012ad <xMissedYield>
    253c:	73 dc       	rcall	.-1818   	; 0x1e24 <vPortYield>
    253e:	81 e0       	ldi	r24, 0x01	; 1
    2540:	03 c0       	rjmp	.+6      	; 0x2548 <xTaskResumeAll+0xd2>
    2542:	80 e0       	ldi	r24, 0x00	; 0
    2544:	01 c0       	rjmp	.+2      	; 0x2548 <xTaskResumeAll+0xd2>
    2546:	80 e0       	ldi	r24, 0x00	; 0
    2548:	0f 90       	pop	r0
    254a:	0f be       	out	0x3f, r0	; 63
    254c:	df 91       	pop	r29
    254e:	cf 91       	pop	r28
    2550:	1f 91       	pop	r17
    2552:	0f 91       	pop	r16
    2554:	ff 90       	pop	r15
    2556:	08 95       	ret

00002558 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    2558:	cf 93       	push	r28
    255a:	df 93       	push	r29
    255c:	ec 01       	movw	r28, r24
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    255e:	89 2b       	or	r24, r25
    2560:	89 f0       	breq	.+34     	; 0x2584 <vTaskDelay+0x2c>
		{
			vTaskSuspendAll();
    2562:	dc de       	rcall	.-584    	; 0x231c <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    2564:	80 91 b3 12 	lds	r24, 0x12B3	; 0x8012b3 <xTickCount>
    2568:	90 91 b4 12 	lds	r25, 0x12B4	; 0x8012b4 <xTickCount+0x1>
    256c:	c8 0f       	add	r28, r24
    256e:	d9 1f       	adc	r29, r25

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2570:	80 91 de 12 	lds	r24, 0x12DE	; 0x8012de <pxCurrentTCB>
    2574:	90 91 df 12 	lds	r25, 0x12DF	; 0x8012df <pxCurrentTCB+0x1>
    2578:	02 96       	adiw	r24, 0x02	; 2
    257a:	81 db       	rcall	.-2302   	; 0x1c7e <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    257c:	ce 01       	movw	r24, r28
    257e:	b8 dd       	rcall	.-1168   	; 0x20f0 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    2580:	7a df       	rcall	.-268    	; 0x2476 <xTaskResumeAll>
    2582:	01 c0       	rjmp	.+2      	; 0x2586 <vTaskDelay+0x2e>
#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    2584:	80 e0       	ldi	r24, 0x00	; 0
			xAlreadyYielded = xTaskResumeAll();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    2586:	81 11       	cpse	r24, r1
    2588:	01 c0       	rjmp	.+2      	; 0x258c <vTaskDelay+0x34>
		{
			portYIELD_WITHIN_API();
    258a:	4c dc       	rcall	.-1896   	; 0x1e24 <vPortYield>
    258c:	df 91       	pop	r29
		}
	}
    258e:	cf 91       	pop	r28
    2590:	08 95       	ret

00002592 <vTaskSwitchContext>:
    2592:	80 91 af 12 	lds	r24, 0x12AF	; 0x8012af <uxSchedulerSuspended>
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    2596:	88 23       	and	r24, r24
    2598:	49 f0       	breq	.+18     	; 0x25ac <vTaskSwitchContext+0x1a>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    259a:	81 e0       	ldi	r24, 0x01	; 1
    259c:	80 93 ad 12 	sts	0x12AD, r24	; 0x8012ad <xMissedYield>
    25a0:	08 95       	ret
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    25a2:	80 91 b1 12 	lds	r24, 0x12B1	; 0x8012b1 <uxTopReadyPriority>
    25a6:	81 50       	subi	r24, 0x01	; 1
    25a8:	80 93 b1 12 	sts	0x12B1, r24	; 0x8012b1 <uxTopReadyPriority>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    25ac:	80 91 b1 12 	lds	r24, 0x12B1	; 0x8012b1 <uxTopReadyPriority>
    25b0:	90 e0       	ldi	r25, 0x00	; 0
    25b2:	fc 01       	movw	r30, r24
    25b4:	ee 0f       	add	r30, r30
    25b6:	ff 1f       	adc	r31, r31
    25b8:	ee 0f       	add	r30, r30
    25ba:	ff 1f       	adc	r31, r31
    25bc:	ee 0f       	add	r30, r30
    25be:	ff 1f       	adc	r31, r31
    25c0:	8e 0f       	add	r24, r30
    25c2:	9f 1f       	adc	r25, r31
    25c4:	fc 01       	movw	r30, r24
    25c6:	eb 52       	subi	r30, 0x2B	; 43
    25c8:	fd 4e       	sbci	r31, 0xED	; 237
    25ca:	80 81       	ld	r24, Z
    25cc:	88 23       	and	r24, r24
    25ce:	49 f3       	breq	.-46     	; 0x25a2 <vTaskSwitchContext+0x10>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    25d0:	80 91 b1 12 	lds	r24, 0x12B1	; 0x8012b1 <uxTopReadyPriority>
    25d4:	90 e0       	ldi	r25, 0x00	; 0
    25d6:	9c 01       	movw	r18, r24
    25d8:	22 0f       	add	r18, r18
    25da:	33 1f       	adc	r19, r19
    25dc:	22 0f       	add	r18, r18
    25de:	33 1f       	adc	r19, r19
    25e0:	22 0f       	add	r18, r18
    25e2:	33 1f       	adc	r19, r19
    25e4:	28 0f       	add	r18, r24
    25e6:	39 1f       	adc	r19, r25
    25e8:	d9 01       	movw	r26, r18
    25ea:	ab 52       	subi	r26, 0x2B	; 43
    25ec:	bd 4e       	sbci	r27, 0xED	; 237
    25ee:	11 96       	adiw	r26, 0x01	; 1
    25f0:	ed 91       	ld	r30, X+
    25f2:	fc 91       	ld	r31, X
    25f4:	12 97       	sbiw	r26, 0x02	; 2
    25f6:	02 80       	ldd	r0, Z+2	; 0x02
    25f8:	f3 81       	ldd	r31, Z+3	; 0x03
    25fa:	e0 2d       	mov	r30, r0
    25fc:	12 96       	adiw	r26, 0x02	; 2
    25fe:	fc 93       	st	X, r31
    2600:	ee 93       	st	-X, r30
    2602:	11 97       	sbiw	r26, 0x01	; 1
    2604:	28 52       	subi	r18, 0x28	; 40
    2606:	3d 4e       	sbci	r19, 0xED	; 237
    2608:	e2 17       	cp	r30, r18
    260a:	f3 07       	cpc	r31, r19
    260c:	29 f4       	brne	.+10     	; 0x2618 <vTaskSwitchContext+0x86>
    260e:	22 81       	ldd	r18, Z+2	; 0x02
    2610:	33 81       	ldd	r19, Z+3	; 0x03
    2612:	fd 01       	movw	r30, r26
    2614:	32 83       	std	Z+2, r19	; 0x02
    2616:	21 83       	std	Z+1, r18	; 0x01
    2618:	fc 01       	movw	r30, r24
    261a:	ee 0f       	add	r30, r30
    261c:	ff 1f       	adc	r31, r31
    261e:	ee 0f       	add	r30, r30
    2620:	ff 1f       	adc	r31, r31
    2622:	ee 0f       	add	r30, r30
    2624:	ff 1f       	adc	r31, r31
    2626:	8e 0f       	add	r24, r30
    2628:	9f 1f       	adc	r25, r31
    262a:	fc 01       	movw	r30, r24
    262c:	eb 52       	subi	r30, 0x2B	; 43
    262e:	fd 4e       	sbci	r31, 0xED	; 237
    2630:	01 80       	ldd	r0, Z+1	; 0x01
    2632:	f2 81       	ldd	r31, Z+2	; 0x02
    2634:	e0 2d       	mov	r30, r0
    2636:	86 81       	ldd	r24, Z+6	; 0x06
    2638:	97 81       	ldd	r25, Z+7	; 0x07
    263a:	90 93 df 12 	sts	0x12DF, r25	; 0x8012df <pxCurrentTCB+0x1>
    263e:	80 93 de 12 	sts	0x12DE, r24	; 0x8012de <pxCurrentTCB>
    2642:	08 95       	ret

00002644 <_Z11DisplayInitv>:
	_NOP();
	WR_PORT |= (1 << WR_BIT);
	_NOP();
	
	// Set chip select to low
	CS_PORT_Dispay |= (1 << CS_BIT);
    2644:	83 b3       	in	r24, 0x13	; 19
    2646:	87 60       	ori	r24, 0x07	; 7
    2648:	83 bb       	out	0x13, r24	; 19
    264a:	57 9a       	sbi	0x0a, 7	; 10
    264c:	8f ef       	ldi	r24, 0xFF	; 255
    264e:	81 b9       	out	0x01, r24	; 1
    2650:	87 b9       	out	0x07, r24	; 7
    2652:	84 b3       	in	r24, 0x14	; 20
    2654:	87 60       	ori	r24, 0x07	; 7
    2656:	84 bb       	out	0x14, r24	; 20
    2658:	5f 9a       	sbi	0x0b, 7	; 11
    265a:	a0 98       	cbi	0x14, 0	; 20
    265c:	2f ef       	ldi	r18, 0xFF	; 255
    265e:	89 e6       	ldi	r24, 0x69	; 105
    2660:	98 e1       	ldi	r25, 0x18	; 24
    2662:	21 50       	subi	r18, 0x01	; 1
    2664:	80 40       	sbci	r24, 0x00	; 0
    2666:	90 40       	sbci	r25, 0x00	; 0
    2668:	e1 f7       	brne	.-8      	; 0x2662 <_Z11DisplayInitv+0x1e>
    266a:	00 c0       	rjmp	.+0      	; 0x266c <_Z11DisplayInitv+0x28>
    266c:	00 00       	nop
    266e:	a0 9a       	sbi	0x14, 0	; 20
    2670:	2f ef       	ldi	r18, 0xFF	; 255
    2672:	89 e6       	ldi	r24, 0x69	; 105
    2674:	98 e1       	ldi	r25, 0x18	; 24
    2676:	21 50       	subi	r18, 0x01	; 1
    2678:	80 40       	sbci	r24, 0x00	; 0
    267a:	90 40       	sbci	r25, 0x00	; 0
    267c:	e1 f7       	brne	.-8      	; 0x2676 <_Z11DisplayInitv+0x32>
    267e:	00 c0       	rjmp	.+0      	; 0x2680 <_Z11DisplayInitv+0x3c>
    2680:	00 00       	nop
    2682:	5f 98       	cbi	0x0b, 7	; 11
    2684:	a1 98       	cbi	0x14, 1	; 20
    2686:	00 00       	nop
    2688:	12 b8       	out	0x02, r1	; 2
    268a:	8a e3       	ldi	r24, 0x3A	; 58
    268c:	88 b9       	out	0x08, r24	; 8
    268e:	a2 98       	cbi	0x14, 2	; 20
    2690:	00 00       	nop
    2692:	a2 9a       	sbi	0x14, 2	; 20
    2694:	00 00       	nop
    2696:	a1 9a       	sbi	0x14, 1	; 20
    2698:	5f 9a       	sbi	0x0b, 7	; 11
    269a:	a1 98       	cbi	0x14, 1	; 20
    269c:	00 00       	nop
    269e:	12 b8       	out	0x02, r1	; 2
    26a0:	85 e0       	ldi	r24, 0x05	; 5
    26a2:	88 b9       	out	0x08, r24	; 8
    26a4:	a2 98       	cbi	0x14, 2	; 20
    26a6:	00 00       	nop
    26a8:	a2 9a       	sbi	0x14, 2	; 20
    26aa:	00 00       	nop
    26ac:	a1 9a       	sbi	0x14, 1	; 20
    26ae:	5f 98       	cbi	0x0b, 7	; 11
    26b0:	a1 98       	cbi	0x14, 1	; 20
    26b2:	00 00       	nop
    26b4:	12 b8       	out	0x02, r1	; 2
    26b6:	86 e3       	ldi	r24, 0x36	; 54
    26b8:	88 b9       	out	0x08, r24	; 8
    26ba:	a2 98       	cbi	0x14, 2	; 20
    26bc:	00 00       	nop
    26be:	a2 9a       	sbi	0x14, 2	; 20
    26c0:	00 00       	nop
    26c2:	a1 9a       	sbi	0x14, 1	; 20
    26c4:	5f 9a       	sbi	0x0b, 7	; 11
    26c6:	a1 98       	cbi	0x14, 1	; 20
    26c8:	00 00       	nop
    26ca:	12 b8       	out	0x02, r1	; 2
    26cc:	88 e0       	ldi	r24, 0x08	; 8
    26ce:	88 b9       	out	0x08, r24	; 8
    26d0:	a2 98       	cbi	0x14, 2	; 20
    26d2:	00 00       	nop
    26d4:	a2 9a       	sbi	0x14, 2	; 20
    26d6:	00 00       	nop
    26d8:	a1 9a       	sbi	0x14, 1	; 20
    26da:	5f 98       	cbi	0x0b, 7	; 11
    26dc:	a1 98       	cbi	0x14, 1	; 20
    26de:	00 00       	nop
    26e0:	12 b8       	out	0x02, r1	; 2
    26e2:	81 e1       	ldi	r24, 0x11	; 17
    26e4:	88 b9       	out	0x08, r24	; 8
    26e6:	a2 98       	cbi	0x14, 2	; 20
    26e8:	00 00       	nop
    26ea:	a2 9a       	sbi	0x14, 2	; 20
    26ec:	00 00       	nop
    26ee:	a1 9a       	sbi	0x14, 1	; 20
    26f0:	5f 98       	cbi	0x0b, 7	; 11
    26f2:	a1 98       	cbi	0x14, 1	; 20
    26f4:	00 00       	nop
    26f6:	12 b8       	out	0x02, r1	; 2
    26f8:	89 e2       	ldi	r24, 0x29	; 41
    26fa:	88 b9       	out	0x08, r24	; 8
    26fc:	a2 98       	cbi	0x14, 2	; 20
    26fe:	00 00       	nop
    2700:	a2 9a       	sbi	0x14, 2	; 20
    2702:	00 00       	nop
    2704:	a1 9a       	sbi	0x14, 1	; 20
    2706:	08 95       	ret

00002708 <_Z13FillRectanglejjjjhhh>:
// Fills rectangle with specified color
// (StartX,StartY) = Upper left corner. X horizontal (0-319) , Y vertical (0-239).
// Height (1-240) is vertical. Width (1-320) is horizontal.
// R-G-B = 5-6-5 bits.
void FillRectangle(unsigned int StartX, unsigned int StartY, unsigned int Width, unsigned int Height, unsigned char Blue, unsigned char Green, unsigned char Red)
{
    2708:	cf 92       	push	r12
    270a:	df 92       	push	r13
    270c:	ef 92       	push	r14
    270e:	0f 93       	push	r16
	SetPageAddress(StartX,StartX+Width-1);
    2710:	fa 01       	movw	r30, r20
    2712:	31 97       	sbiw	r30, 0x01	; 1
    2714:	e8 0f       	add	r30, r24
    2716:	f9 1f       	adc	r31, r25
}

// Set Page Address (0-319), Start > End
void SetPageAddress(unsigned int Start, unsigned int End)
{
	if (Start < End)
    2718:	8e 17       	cp	r24, r30
    271a:	9f 07       	cpc	r25, r31
    271c:	08 f4       	brcc	.+2      	; 0x2720 <_Z13FillRectanglejjjjhhh+0x18>
    271e:	51 c0       	rjmp	.+162    	; 0x27c2 <_Z13FillRectanglejjjjhhh+0xba>
// Height (1-240) is vertical. Width (1-320) is horizontal.
// R-G-B = 5-6-5 bits.
void FillRectangle(unsigned int StartX, unsigned int StartY, unsigned int Width, unsigned int Height, unsigned char Blue, unsigned char Green, unsigned char Red)
{
	SetPageAddress(StartX,StartX+Width-1);
	SetColumnAddress(StartY,StartY+Height-1);
    2720:	c9 01       	movw	r24, r18
    2722:	01 97       	sbiw	r24, 0x01	; 1
    2724:	86 0f       	add	r24, r22
    2726:	97 1f       	adc	r25, r23
}

// Set Column Address (0-239), Start > End
void SetColumnAddress(unsigned int Start, unsigned int End)
{
	if (Start < End)
    2728:	68 17       	cp	r22, r24
    272a:	79 07       	cpc	r23, r25
    272c:	08 f4       	brcc	.+2      	; 0x2730 <_Z13FillRectanglejjjjhhh+0x28>
    272e:	84 c0       	rjmp	.+264    	; 0x2838 <_Z13FillRectanglejjjjhhh+0x130>

// ILI 9341 data sheet, page 238
void WriteCommand(unsigned int command)
{
	// Set DC port to command
	DC_PORT &= ~(1 << DC_BIT);
    2730:	5f 98       	cbi	0x0b, 7	; 11
	
	// Set chip select to high - Then wait min 15 ns for chip select setup.
	CS_PORT_Dispay &= ~(1 << CS_BIT);	
    2732:	a1 98       	cbi	0x14, 1	; 20
	_NOP();
    2734:	00 00       	nop
	
	// Set databus
	DATA_PORT_HIGH = command >> 8U;
    2736:	12 b8       	out	0x02, r1	; 2
	DATA_PORT_LOW = command;
    2738:	8c e2       	ldi	r24, 0x2C	; 44
    273a:	88 b9       	out	0x08, r24	; 8
	
	//Set WR port to 0 to start transmission - wait 15 nano sec - Set WR port to 1 to end transmission. 
	WR_PORT &= ~(1 << WR_BIT);
    273c:	a2 98       	cbi	0x14, 2	; 20
	_NOP();
    273e:	00 00       	nop
	WR_PORT |= (1 << WR_BIT);
    2740:	a2 9a       	sbi	0x14, 2	; 20
	_NOP();
    2742:	00 00       	nop
	
	// Set chip select to low
	CS_PORT_Dispay |= (1 << CS_BIT);
    2744:	a1 9a       	sbi	0x14, 1	; 20
{
	SetPageAddress(StartX,StartX+Width-1);
	SetColumnAddress(StartY,StartY+Height-1);
	MemoryWrite();
	
	for (uint32_t counter = 0; counter < (uint32_t)Width*Height; counter++)
    2746:	da 01       	movw	r26, r20
    2748:	0e 94 10 1e 	call	0x3c20	; 0x3c20 <__umulhisi3>
    274c:	ab 01       	movw	r20, r22
    274e:	bc 01       	movw	r22, r24
    2750:	41 15       	cp	r20, r1
    2752:	51 05       	cpc	r21, r1
    2754:	61 05       	cpc	r22, r1
    2756:	71 05       	cpc	r23, r1
    2758:	21 f1       	breq	.+72     	; 0x27a2 <_Z13FillRectanglejjjjhhh+0x9a>
    275a:	20 e2       	ldi	r18, 0x20	; 32
    275c:	e2 9e       	mul	r14, r18
    275e:	c0 01       	movw	r24, r0
    2760:	11 24       	eor	r1, r1
    2762:	80 2b       	or	r24, r16
    2764:	d1 2c       	mov	r13, r1
    2766:	dc 2c       	mov	r13, r12
    2768:	cc 24       	eor	r12, r12
    276a:	dd 0c       	add	r13, r13
    276c:	dd 0c       	add	r13, r13
    276e:	dd 0c       	add	r13, r13
    2770:	8c 29       	or	r24, r12
    2772:	9d 29       	or	r25, r13
    2774:	29 2f       	mov	r18, r25
    2776:	c8 2e       	mov	r12, r24
    2778:	80 e0       	ldi	r24, 0x00	; 0
    277a:	90 e0       	ldi	r25, 0x00	; 0
    277c:	dc 01       	movw	r26, r24

// ILI 9341 data sheet, page 238
void WriteData(unsigned int data)
{
	// Set DC port to data
	DC_PORT |= (1 << DC_BIT);
    277e:	5f 9a       	sbi	0x0b, 7	; 11
	
	// Set chip select to high - Then wait min 15 ns for chip select setup. 
	CS_PORT_Dispay &= ~(1 << CS_BIT);
    2780:	a1 98       	cbi	0x14, 1	; 20
	_NOP();
    2782:	00 00       	nop
		
	// Set databus
	DATA_PORT_HIGH = data >> 8U;
    2784:	22 b9       	out	0x02, r18	; 2
	DATA_PORT_LOW = data;
    2786:	c8 b8       	out	0x08, r12	; 8
	
	//Set WR port to 0 to start transmission - wait 15 nano sec - Set WR port to 1 to end transmission.
	WR_PORT &= ~(1 << WR_BIT);
    2788:	a2 98       	cbi	0x14, 2	; 20
	_NOP();
    278a:	00 00       	nop
	WR_PORT |= (1 << WR_BIT);
    278c:	a2 9a       	sbi	0x14, 2	; 20
	_NOP();
    278e:	00 00       	nop
	
	// Set chip select to low
	CS_PORT_Dispay |= (1 << CS_BIT);
    2790:	a1 9a       	sbi	0x14, 1	; 20
{
	SetPageAddress(StartX,StartX+Width-1);
	SetColumnAddress(StartY,StartY+Height-1);
	MemoryWrite();
	
	for (uint32_t counter = 0; counter < (uint32_t)Width*Height; counter++)
    2792:	01 96       	adiw	r24, 0x01	; 1
    2794:	a1 1d       	adc	r26, r1
    2796:	b1 1d       	adc	r27, r1
    2798:	84 17       	cp	r24, r20
    279a:	95 07       	cpc	r25, r21
    279c:	a6 07       	cpc	r26, r22
    279e:	b7 07       	cpc	r27, r23
    27a0:	71 f7       	brne	.-36     	; 0x277e <_Z13FillRectanglejjjjhhh+0x76>

// ILI 9341 data sheet, page 238
void WriteCommand(unsigned int command)
{
	// Set DC port to command
	DC_PORT &= ~(1 << DC_BIT);
    27a2:	5f 98       	cbi	0x0b, 7	; 11
	
	// Set chip select to high - Then wait min 15 ns for chip select setup.
	CS_PORT_Dispay &= ~(1 << CS_BIT);	
    27a4:	a1 98       	cbi	0x14, 1	; 20
	_NOP();
    27a6:	00 00       	nop
	
	// Set databus
	DATA_PORT_HIGH = command >> 8U;
    27a8:	12 b8       	out	0x02, r1	; 2
	DATA_PORT_LOW = command;
    27aa:	81 e1       	ldi	r24, 0x11	; 17
    27ac:	88 b9       	out	0x08, r24	; 8
	
	//Set WR port to 0 to start transmission - wait 15 nano sec - Set WR port to 1 to end transmission. 
	WR_PORT &= ~(1 << WR_BIT);
    27ae:	a2 98       	cbi	0x14, 2	; 20
	_NOP();
    27b0:	00 00       	nop
	WR_PORT |= (1 << WR_BIT);
    27b2:	a2 9a       	sbi	0x14, 2	; 20
	_NOP();
    27b4:	00 00       	nop
	
	// Set chip select to low
	CS_PORT_Dispay |= (1 << CS_BIT);
    27b6:	a1 9a       	sbi	0x14, 1	; 20
	for (uint32_t counter = 0; counter < (uint32_t)Width*Height; counter++)
	{
		WritePixel(Red,Green,Blue);
	}
	SleepOut();
}
    27b8:	0f 91       	pop	r16
    27ba:	ef 90       	pop	r14
    27bc:	df 90       	pop	r13
    27be:	cf 90       	pop	r12
    27c0:	08 95       	ret

// ILI 9341 data sheet, page 238
void WriteCommand(unsigned int command)
{
	// Set DC port to command
	DC_PORT &= ~(1 << DC_BIT);
    27c2:	5f 98       	cbi	0x0b, 7	; 11
	
	// Set chip select to high - Then wait min 15 ns for chip select setup.
	CS_PORT_Dispay &= ~(1 << CS_BIT);	
    27c4:	a1 98       	cbi	0x14, 1	; 20
	_NOP();
    27c6:	00 00       	nop
	
	// Set databus
	DATA_PORT_HIGH = command >> 8U;
    27c8:	12 b8       	out	0x02, r1	; 2
	DATA_PORT_LOW = command;
    27ca:	ab e2       	ldi	r26, 0x2B	; 43
    27cc:	a8 b9       	out	0x08, r26	; 8
	
	//Set WR port to 0 to start transmission - wait 15 nano sec - Set WR port to 1 to end transmission. 
	WR_PORT &= ~(1 << WR_BIT);
    27ce:	a2 98       	cbi	0x14, 2	; 20
	_NOP();
    27d0:	00 00       	nop
	WR_PORT |= (1 << WR_BIT);
    27d2:	a2 9a       	sbi	0x14, 2	; 20
	_NOP();
    27d4:	00 00       	nop
	
	// Set chip select to low
	CS_PORT_Dispay |= (1 << CS_BIT);
    27d6:	a1 9a       	sbi	0x14, 1	; 20

// ILI 9341 data sheet, page 238
void WriteData(unsigned int data)
{
	// Set DC port to data
	DC_PORT |= (1 << DC_BIT);
    27d8:	5f 9a       	sbi	0x0b, 7	; 11
	
	// Set chip select to high - Then wait min 15 ns for chip select setup. 
	CS_PORT_Dispay &= ~(1 << CS_BIT);
    27da:	a1 98       	cbi	0x14, 1	; 20
	_NOP();
    27dc:	00 00       	nop
		
	// Set databus
	DATA_PORT_HIGH = data >> 8U;
    27de:	12 b8       	out	0x02, r1	; 2
	DATA_PORT_LOW = data;
    27e0:	98 b9       	out	0x08, r25	; 8
	
	//Set WR port to 0 to start transmission - wait 15 nano sec - Set WR port to 1 to end transmission.
	WR_PORT &= ~(1 << WR_BIT);
    27e2:	a2 98       	cbi	0x14, 2	; 20
	_NOP();
    27e4:	00 00       	nop
	WR_PORT |= (1 << WR_BIT);
    27e6:	a2 9a       	sbi	0x14, 2	; 20
	_NOP();
    27e8:	00 00       	nop
	
	// Set chip select to low
	CS_PORT_Dispay |= (1 << CS_BIT);
    27ea:	a1 9a       	sbi	0x14, 1	; 20

// ILI 9341 data sheet, page 238
void WriteData(unsigned int data)
{
	// Set DC port to data
	DC_PORT |= (1 << DC_BIT);
    27ec:	5f 9a       	sbi	0x0b, 7	; 11
	
	// Set chip select to high - Then wait min 15 ns for chip select setup. 
	CS_PORT_Dispay &= ~(1 << CS_BIT);
    27ee:	a1 98       	cbi	0x14, 1	; 20
	_NOP();
    27f0:	00 00       	nop
		
	// Set databus
	DATA_PORT_HIGH = data >> 8U;
    27f2:	92 b9       	out	0x02, r25	; 2
	DATA_PORT_LOW = data;
    27f4:	88 b9       	out	0x08, r24	; 8
	
	//Set WR port to 0 to start transmission - wait 15 nano sec - Set WR port to 1 to end transmission.
	WR_PORT &= ~(1 << WR_BIT);
    27f6:	a2 98       	cbi	0x14, 2	; 20
	_NOP();
    27f8:	00 00       	nop
	WR_PORT |= (1 << WR_BIT);
    27fa:	a2 9a       	sbi	0x14, 2	; 20
	_NOP();
    27fc:	00 00       	nop
	
	// Set chip select to low
	CS_PORT_Dispay |= (1 << CS_BIT);
    27fe:	a1 9a       	sbi	0x14, 1	; 20

// ILI 9341 data sheet, page 238
void WriteData(unsigned int data)
{
	// Set DC port to data
	DC_PORT |= (1 << DC_BIT);
    2800:	5f 9a       	sbi	0x0b, 7	; 11
	
	// Set chip select to high - Then wait min 15 ns for chip select setup. 
	CS_PORT_Dispay &= ~(1 << CS_BIT);
    2802:	a1 98       	cbi	0x14, 1	; 20
	_NOP();
    2804:	00 00       	nop
		
	// Set databus
	DATA_PORT_HIGH = data >> 8U;
    2806:	12 b8       	out	0x02, r1	; 2
	DATA_PORT_LOW = data;
    2808:	f8 b9       	out	0x08, r31	; 8
	
	//Set WR port to 0 to start transmission - wait 15 nano sec - Set WR port to 1 to end transmission.
	WR_PORT &= ~(1 << WR_BIT);
    280a:	a2 98       	cbi	0x14, 2	; 20
	_NOP();
    280c:	00 00       	nop
	WR_PORT |= (1 << WR_BIT);
    280e:	a2 9a       	sbi	0x14, 2	; 20
	_NOP();
    2810:	00 00       	nop
	
	// Set chip select to low
	CS_PORT_Dispay |= (1 << CS_BIT);
    2812:	a1 9a       	sbi	0x14, 1	; 20

// ILI 9341 data sheet, page 238
void WriteData(unsigned int data)
{
	// Set DC port to data
	DC_PORT |= (1 << DC_BIT);
    2814:	5f 9a       	sbi	0x0b, 7	; 11
	
	// Set chip select to high - Then wait min 15 ns for chip select setup. 
	CS_PORT_Dispay &= ~(1 << CS_BIT);
    2816:	a1 98       	cbi	0x14, 1	; 20
	_NOP();
    2818:	00 00       	nop
		
	// Set databus
	DATA_PORT_HIGH = data >> 8U;
    281a:	f2 b9       	out	0x02, r31	; 2
	DATA_PORT_LOW = data;
    281c:	e8 b9       	out	0x08, r30	; 8
	
	//Set WR port to 0 to start transmission - wait 15 nano sec - Set WR port to 1 to end transmission.
	WR_PORT &= ~(1 << WR_BIT);
    281e:	a2 98       	cbi	0x14, 2	; 20
	_NOP();
    2820:	00 00       	nop
	WR_PORT |= (1 << WR_BIT);
    2822:	a2 9a       	sbi	0x14, 2	; 20
	_NOP();
    2824:	00 00       	nop
	
	// Set chip select to low
	CS_PORT_Dispay |= (1 << CS_BIT);
    2826:	a1 9a       	sbi	0x14, 1	; 20
// Height (1-240) is vertical. Width (1-320) is horizontal.
// R-G-B = 5-6-5 bits.
void FillRectangle(unsigned int StartX, unsigned int StartY, unsigned int Width, unsigned int Height, unsigned char Blue, unsigned char Green, unsigned char Red)
{
	SetPageAddress(StartX,StartX+Width-1);
	SetColumnAddress(StartY,StartY+Height-1);
    2828:	c9 01       	movw	r24, r18
    282a:	01 97       	sbiw	r24, 0x01	; 1
    282c:	86 0f       	add	r24, r22
    282e:	97 1f       	adc	r25, r23
}

// Set Column Address (0-239), Start > End
void SetColumnAddress(unsigned int Start, unsigned int End)
{
	if (Start < End)
    2830:	68 17       	cp	r22, r24
    2832:	79 07       	cpc	r23, r25
    2834:	08 f0       	brcs	.+2      	; 0x2838 <_Z13FillRectanglejjjjhhh+0x130>
    2836:	7c cf       	rjmp	.-264    	; 0x2730 <_Z13FillRectanglejjjjhhh+0x28>

// ILI 9341 data sheet, page 238
void WriteCommand(unsigned int command)
{
	// Set DC port to command
	DC_PORT &= ~(1 << DC_BIT);
    2838:	5f 98       	cbi	0x0b, 7	; 11
	
	// Set chip select to high - Then wait min 15 ns for chip select setup.
	CS_PORT_Dispay &= ~(1 << CS_BIT);	
    283a:	a1 98       	cbi	0x14, 1	; 20
	_NOP();
    283c:	00 00       	nop
	
	// Set databus
	DATA_PORT_HIGH = command >> 8U;
    283e:	12 b8       	out	0x02, r1	; 2
	DATA_PORT_LOW = command;
    2840:	ea e2       	ldi	r30, 0x2A	; 42
    2842:	e8 b9       	out	0x08, r30	; 8
	
	//Set WR port to 0 to start transmission - wait 15 nano sec - Set WR port to 1 to end transmission. 
	WR_PORT &= ~(1 << WR_BIT);
    2844:	a2 98       	cbi	0x14, 2	; 20
	_NOP();
    2846:	00 00       	nop
	WR_PORT |= (1 << WR_BIT);
    2848:	a2 9a       	sbi	0x14, 2	; 20
	_NOP();
    284a:	00 00       	nop
	
	// Set chip select to low
	CS_PORT_Dispay |= (1 << CS_BIT);
    284c:	a1 9a       	sbi	0x14, 1	; 20

// ILI 9341 data sheet, page 238
void WriteData(unsigned int data)
{
	// Set DC port to data
	DC_PORT |= (1 << DC_BIT);
    284e:	5f 9a       	sbi	0x0b, 7	; 11
	
	// Set chip select to high - Then wait min 15 ns for chip select setup. 
	CS_PORT_Dispay &= ~(1 << CS_BIT);
    2850:	a1 98       	cbi	0x14, 1	; 20
	_NOP();
    2852:	00 00       	nop
		
	// Set databus
	DATA_PORT_HIGH = data >> 8U;
    2854:	12 b8       	out	0x02, r1	; 2
	DATA_PORT_LOW = data;
    2856:	78 b9       	out	0x08, r23	; 8
	
	//Set WR port to 0 to start transmission - wait 15 nano sec - Set WR port to 1 to end transmission.
	WR_PORT &= ~(1 << WR_BIT);
    2858:	a2 98       	cbi	0x14, 2	; 20
	_NOP();
    285a:	00 00       	nop
	WR_PORT |= (1 << WR_BIT);
    285c:	a2 9a       	sbi	0x14, 2	; 20
	_NOP();
    285e:	00 00       	nop
	
	// Set chip select to low
	CS_PORT_Dispay |= (1 << CS_BIT);
    2860:	a1 9a       	sbi	0x14, 1	; 20

// ILI 9341 data sheet, page 238
void WriteData(unsigned int data)
{
	// Set DC port to data
	DC_PORT |= (1 << DC_BIT);
    2862:	5f 9a       	sbi	0x0b, 7	; 11
	
	// Set chip select to high - Then wait min 15 ns for chip select setup. 
	CS_PORT_Dispay &= ~(1 << CS_BIT);
    2864:	a1 98       	cbi	0x14, 1	; 20
	_NOP();
    2866:	00 00       	nop
		
	// Set databus
	DATA_PORT_HIGH = data >> 8U;
    2868:	72 b9       	out	0x02, r23	; 2
	DATA_PORT_LOW = data;
    286a:	68 b9       	out	0x08, r22	; 8
	
	//Set WR port to 0 to start transmission - wait 15 nano sec - Set WR port to 1 to end transmission.
	WR_PORT &= ~(1 << WR_BIT);
    286c:	a2 98       	cbi	0x14, 2	; 20
	_NOP();
    286e:	00 00       	nop
	WR_PORT |= (1 << WR_BIT);
    2870:	a2 9a       	sbi	0x14, 2	; 20
	_NOP();
    2872:	00 00       	nop
	
	// Set chip select to low
	CS_PORT_Dispay |= (1 << CS_BIT);
    2874:	a1 9a       	sbi	0x14, 1	; 20

// ILI 9341 data sheet, page 238
void WriteData(unsigned int data)
{
	// Set DC port to data
	DC_PORT |= (1 << DC_BIT);
    2876:	5f 9a       	sbi	0x0b, 7	; 11
	
	// Set chip select to high - Then wait min 15 ns for chip select setup. 
	CS_PORT_Dispay &= ~(1 << CS_BIT);
    2878:	a1 98       	cbi	0x14, 1	; 20
	_NOP();
    287a:	00 00       	nop
		
	// Set databus
	DATA_PORT_HIGH = data >> 8U;
    287c:	12 b8       	out	0x02, r1	; 2
	DATA_PORT_LOW = data;
    287e:	98 b9       	out	0x08, r25	; 8
	
	//Set WR port to 0 to start transmission - wait 15 nano sec - Set WR port to 1 to end transmission.
	WR_PORT &= ~(1 << WR_BIT);
    2880:	a2 98       	cbi	0x14, 2	; 20
	_NOP();
    2882:	00 00       	nop
	WR_PORT |= (1 << WR_BIT);
    2884:	a2 9a       	sbi	0x14, 2	; 20
	_NOP();
    2886:	00 00       	nop
	
	// Set chip select to low
	CS_PORT_Dispay |= (1 << CS_BIT);
    2888:	a1 9a       	sbi	0x14, 1	; 20

// ILI 9341 data sheet, page 238
void WriteData(unsigned int data)
{
	// Set DC port to data
	DC_PORT |= (1 << DC_BIT);
    288a:	5f 9a       	sbi	0x0b, 7	; 11
	
	// Set chip select to high - Then wait min 15 ns for chip select setup. 
	CS_PORT_Dispay &= ~(1 << CS_BIT);
    288c:	a1 98       	cbi	0x14, 1	; 20
	_NOP();
    288e:	00 00       	nop
		
	// Set databus
	DATA_PORT_HIGH = data >> 8U;
    2890:	92 b9       	out	0x02, r25	; 2
	DATA_PORT_LOW = data;
    2892:	88 b9       	out	0x08, r24	; 8
	
	//Set WR port to 0 to start transmission - wait 15 nano sec - Set WR port to 1 to end transmission.
	WR_PORT &= ~(1 << WR_BIT);
    2894:	a2 98       	cbi	0x14, 2	; 20
	_NOP();
    2896:	00 00       	nop
	WR_PORT |= (1 << WR_BIT);
    2898:	a2 9a       	sbi	0x14, 2	; 20
	_NOP();
    289a:	00 00       	nop
	
	// Set chip select to low
	CS_PORT_Dispay |= (1 << CS_BIT);
    289c:	a1 9a       	sbi	0x14, 1	; 20
    289e:	48 cf       	rjmp	.-368    	; 0x2730 <_Z13FillRectanglejjjjhhh+0x28>

000028a0 <_ZN11TouchscreenC1Ev>:
	flashRed = ButtonClass(0,0,320,240,255,0,0);
	
	DisplayInit();
}

Touchscreen::~Touchscreen()
    28a0:	0f 93       	push	r16
    28a2:	1f 93       	push	r17
    28a4:	cf 93       	push	r28
    28a6:	df 93       	push	r29
    28a8:	1f 92       	push	r1
    28aa:	1f 92       	push	r1
    28ac:	cd b7       	in	r28, 0x3d	; 61
    28ae:	de b7       	in	r29, 0x3e	; 62
    28b0:	8c 01       	movw	r16, r24
    28b2:	38 d1       	rcall	.+624    	; 0x2b24 <_ZN11TouchDriverC1Ev>
    28b4:	f8 01       	movw	r30, r16
    28b6:	12 82       	std	Z+2, r1	; 0x02
    28b8:	13 82       	std	Z+3, r1	; 0x03
    28ba:	14 82       	std	Z+4, r1	; 0x04
    28bc:	15 82       	std	Z+5, r1	; 0x05
    28be:	16 82       	std	Z+6, r1	; 0x06
    28c0:	17 82       	std	Z+7, r1	; 0x07
    28c2:	10 86       	std	Z+8, r1	; 0x08
    28c4:	12 86       	std	Z+10, r1	; 0x0a
    28c6:	11 86       	std	Z+9, r1	; 0x09
    28c8:	13 86       	std	Z+11, r1	; 0x0b
    28ca:	14 86       	std	Z+12, r1	; 0x0c
    28cc:	15 86       	std	Z+13, r1	; 0x0d
    28ce:	16 86       	std	Z+14, r1	; 0x0e
    28d0:	17 86       	std	Z+15, r1	; 0x0f
    28d2:	10 8a       	std	Z+16, r1	; 0x10
    28d4:	11 8a       	std	Z+17, r1	; 0x11
    28d6:	12 8a       	std	Z+18, r1	; 0x12
    28d8:	14 8a       	std	Z+20, r1	; 0x14
    28da:	13 8a       	std	Z+19, r1	; 0x13
    28dc:	15 8a       	std	Z+21, r1	; 0x15
    28de:	16 8a       	std	Z+22, r1	; 0x16
    28e0:	17 8a       	std	Z+23, r1	; 0x17
    28e2:	10 8e       	std	Z+24, r1	; 0x18
    28e4:	11 8e       	std	Z+25, r1	; 0x19
    28e6:	12 8e       	std	Z+26, r1	; 0x1a
    28e8:	13 8e       	std	Z+27, r1	; 0x1b
    28ea:	14 8e       	std	Z+28, r1	; 0x1c
    28ec:	16 8e       	std	Z+30, r1	; 0x1e
    28ee:	15 8e       	std	Z+29, r1	; 0x1d
    28f0:	17 8e       	std	Z+31, r1	; 0x1f
    28f2:	ce 01       	movw	r24, r28
    28f4:	01 96       	adiw	r24, 0x01	; 1
    28f6:	16 d1       	rcall	.+556    	; 0x2b24 <_ZN11TouchDriverC1Ev>
    28f8:	89 81       	ldd	r24, Y+1	; 0x01
    28fa:	9a 81       	ldd	r25, Y+2	; 0x02
    28fc:	f8 01       	movw	r30, r16
    28fe:	91 83       	std	Z+1, r25	; 0x01
    2900:	80 83       	st	Z, r24
    2902:	ce 01       	movw	r24, r28
    2904:	01 96       	adiw	r24, 0x01	; 1
    2906:	20 d1       	rcall	.+576    	; 0x2b48 <_ZN11TouchDriverD1Ev>
    2908:	84 e1       	ldi	r24, 0x14	; 20
    290a:	f8 01       	movw	r30, r16
    290c:	82 83       	std	Z+2, r24	; 0x02
    290e:	46 e4       	ldi	r20, 0x46	; 70
    2910:	43 83       	std	Z+3, r20	; 0x03
    2912:	84 e6       	ldi	r24, 0x64	; 100
    2914:	84 83       	std	Z+4, r24	; 0x04
    2916:	85 83       	std	Z+5, r24	; 0x05
    2918:	9d e1       	ldi	r25, 0x1D	; 29
    291a:	96 83       	std	Z+6, r25	; 0x06
    291c:	2a ee       	ldi	r18, 0xEA	; 234
    291e:	27 83       	std	Z+7, r18	; 0x07
    2920:	32 e0       	ldi	r19, 0x02	; 2
    2922:	30 87       	std	Z+8, r19	; 0x08
    2924:	68 e7       	ldi	r22, 0x78	; 120
    2926:	70 e0       	ldi	r23, 0x00	; 0
    2928:	72 87       	std	Z+10, r23	; 0x0a
    292a:	61 87       	std	Z+9, r22	; 0x09
    292c:	9a ea       	ldi	r25, 0xAA	; 170
    292e:	93 87       	std	Z+11, r25	; 0x0b
    2930:	58 ec       	ldi	r21, 0xC8	; 200
    2932:	54 87       	std	Z+12, r21	; 0x0c
    2934:	45 87       	std	Z+13, r20	; 0x0d
    2936:	86 87       	std	Z+14, r24	; 0x0e
    2938:	87 87       	std	Z+15, r24	; 0x0f
    293a:	8c e2       	ldi	r24, 0x2C	; 44
    293c:	80 8b       	std	Z+16, r24	; 0x10
    293e:	31 8b       	std	Z+17, r19	; 0x11
    2940:	22 8b       	std	Z+18, r18	; 0x12
    2942:	2c e2       	ldi	r18, 0x2C	; 44
    2944:	31 e0       	ldi	r19, 0x01	; 1
    2946:	34 8b       	std	Z+20, r19	; 0x14
    2948:	23 8b       	std	Z+19, r18	; 0x13
    294a:	95 8b       	std	Z+21, r25	; 0x15
    294c:	16 8a       	std	Z+22, r1	; 0x16
    294e:	17 8a       	std	Z+23, r1	; 0x17
    2950:	80 ef       	ldi	r24, 0xF0	; 240
    2952:	80 8f       	std	Z+24, r24	; 0x18
    2954:	90 e4       	ldi	r25, 0x40	; 64
    2956:	91 8f       	std	Z+25, r25	; 0x19
    2958:	9f ef       	ldi	r25, 0xFF	; 255
    295a:	92 8f       	std	Z+26, r25	; 0x1a
    295c:	13 8e       	std	Z+27, r1	; 0x1b
    295e:	14 8e       	std	Z+28, r1	; 0x1c
    2960:	20 e4       	ldi	r18, 0x40	; 64
    2962:	31 e0       	ldi	r19, 0x01	; 1
    2964:	36 8f       	std	Z+30, r19	; 0x1e
    2966:	25 8f       	std	Z+29, r18	; 0x1d
    2968:	87 8f       	std	Z+31, r24	; 0x1f
    296a:	6c de       	rcall	.-808    	; 0x2644 <_Z11DisplayInitv>
    296c:	0f 90       	pop	r0
    296e:	0f 90       	pop	r0
    2970:	df 91       	pop	r29
    2972:	cf 91       	pop	r28
    2974:	1f 91       	pop	r17
    2976:	0f 91       	pop	r16
    2978:	08 95       	ret

0000297a <_ZN11Touchscreen12checkButtonsEv>:
{
}

uint8_t Touchscreen::checkButtons(void)
{
    297a:	cf 92       	push	r12
    297c:	df 92       	push	r13
    297e:	ef 92       	push	r14
    2980:	ff 92       	push	r15
    2982:	0f 93       	push	r16
    2984:	1f 93       	push	r17
    2986:	cf 93       	push	r28
    2988:	df 93       	push	r29
    298a:	1f 92       	push	r1
    298c:	1f 92       	push	r1
    298e:	cd b7       	in	r28, 0x3d	; 61
    2990:	de b7       	in	r29, 0x3e	; 62
    2992:	8c 01       	movw	r16, r24
	uint8_t x = 0;
    2994:	1a 82       	std	Y+2, r1	; 0x02
	uint8_t y = 0;
    2996:	19 82       	std	Y+1, r1	; 0x01
	
	// receive x and y by call by reference
	TouchDriv.getCoordinates(&x, &y);
    2998:	ae 01       	movw	r20, r28
    299a:	4f 5f       	subi	r20, 0xFF	; 255
    299c:	5f 4f       	sbci	r21, 0xFF	; 255
    299e:	be 01       	movw	r22, r28
    29a0:	6e 5f       	subi	r22, 0xFE	; 254
    29a2:	7f 4f       	sbci	r23, 0xFF	; 255
    29a4:	de d0       	rcall	.+444    	; 0x2b62 <_ZN11TouchDriver14getCoordinatesEPhS0_>
	//SendInteger(y);
	//SendString("\r\n");
	
	// Check if touch is in between buttons on display. 1.33 is the scaling factor between touch and display.
	// Max Touch Res is 255 while display is 320
	if (x > blueBnt.startX/1.33 && x < blueBnt.endX/1.33 && y > blueBnt.startY && y < blueBnt.endY)
    29a6:	6a 81       	ldd	r22, Y+2	; 0x02
    29a8:	70 e0       	ldi	r23, 0x00	; 0
    29aa:	80 e0       	ldi	r24, 0x00	; 0
    29ac:	90 e0       	ldi	r25, 0x00	; 0
    29ae:	ff d7       	rcall	.+4094   	; 0x39ae <__floatsisf>
    29b0:	6b 01       	movw	r12, r22
    29b2:	7c 01       	movw	r14, r24
    29b4:	f8 01       	movw	r30, r16
    29b6:	62 81       	ldd	r22, Z+2	; 0x02
    29b8:	70 e0       	ldi	r23, 0x00	; 0
    29ba:	80 e0       	ldi	r24, 0x00	; 0
    29bc:	90 e0       	ldi	r25, 0x00	; 0
    29be:	f7 d7       	rcall	.+4078   	; 0x39ae <__floatsisf>
    29c0:	21 e7       	ldi	r18, 0x71	; 113
    29c2:	3d e3       	ldi	r19, 0x3D	; 61
    29c4:	4a ea       	ldi	r20, 0xAA	; 170
    29c6:	5f e3       	ldi	r21, 0x3F	; 63
    29c8:	5c d7       	rcall	.+3768   	; 0x3882 <__divsf3>
    29ca:	9b 01       	movw	r18, r22
    29cc:	ac 01       	movw	r20, r24
    29ce:	c7 01       	movw	r24, r14
    29d0:	b6 01       	movw	r22, r12
    29d2:	0e 94 87 1d 	call	0x3b0e	; 0x3b0e <__gesf2>
    29d6:	18 16       	cp	r1, r24
    29d8:	dc f4       	brge	.+54     	; 0x2a10 <_ZN11Touchscreen12checkButtonsEv+0x96>
    29da:	f8 01       	movw	r30, r16
    29dc:	61 85       	ldd	r22, Z+9	; 0x09
    29de:	72 85       	ldd	r23, Z+10	; 0x0a
    29e0:	80 e0       	ldi	r24, 0x00	; 0
    29e2:	90 e0       	ldi	r25, 0x00	; 0
    29e4:	e2 d7       	rcall	.+4036   	; 0x39aa <__floatunsisf>
    29e6:	21 e7       	ldi	r18, 0x71	; 113
    29e8:	3d e3       	ldi	r19, 0x3D	; 61
    29ea:	4a ea       	ldi	r20, 0xAA	; 170
    29ec:	5f e3       	ldi	r21, 0x3F	; 63
    29ee:	49 d7       	rcall	.+3730   	; 0x3882 <__divsf3>
    29f0:	9b 01       	movw	r18, r22
    29f2:	ac 01       	movw	r20, r24
    29f4:	c7 01       	movw	r24, r14
    29f6:	b6 01       	movw	r22, r12
    29f8:	40 d7       	rcall	.+3712   	; 0x387a <__cmpsf2>
    29fa:	87 ff       	sbrs	r24, 7
    29fc:	09 c0       	rjmp	.+18     	; 0x2a10 <_ZN11Touchscreen12checkButtonsEv+0x96>
    29fe:	89 81       	ldd	r24, Y+1	; 0x01
    2a00:	f8 01       	movw	r30, r16
    2a02:	93 81       	ldd	r25, Z+3	; 0x03
    2a04:	98 17       	cp	r25, r24
    2a06:	20 f4       	brcc	.+8      	; 0x2a10 <_ZN11Touchscreen12checkButtonsEv+0x96>
    2a08:	93 85       	ldd	r25, Z+11	; 0x0b
    2a0a:	89 17       	cp	r24, r25
    2a0c:	08 f4       	brcc	.+2      	; 0x2a10 <_ZN11Touchscreen12checkButtonsEv+0x96>
    2a0e:	3b c0       	rjmp	.+118    	; 0x2a86 <_ZN11Touchscreen12checkButtonsEv+0x10c>
	{
		return 1;
	}
	else if (x > greenBnt.startX/1.33 && x < greenBnt.endX/1.33 && y > greenBnt.startY && y < greenBnt.endY)
    2a10:	f8 01       	movw	r30, r16
    2a12:	64 85       	ldd	r22, Z+12	; 0x0c
    2a14:	70 e0       	ldi	r23, 0x00	; 0
    2a16:	80 e0       	ldi	r24, 0x00	; 0
    2a18:	90 e0       	ldi	r25, 0x00	; 0
    2a1a:	c9 d7       	rcall	.+3986   	; 0x39ae <__floatsisf>
    2a1c:	21 e7       	ldi	r18, 0x71	; 113
    2a1e:	3d e3       	ldi	r19, 0x3D	; 61
    2a20:	4a ea       	ldi	r20, 0xAA	; 170
    2a22:	5f e3       	ldi	r21, 0x3F	; 63
    2a24:	2e d7       	rcall	.+3676   	; 0x3882 <__divsf3>
    2a26:	9b 01       	movw	r18, r22
    2a28:	ac 01       	movw	r20, r24
    2a2a:	c7 01       	movw	r24, r14
    2a2c:	b6 01       	movw	r22, r12
    2a2e:	0e 94 87 1d 	call	0x3b0e	; 0x3b0e <__gesf2>
    2a32:	18 16       	cp	r1, r24
    2a34:	e4 f4       	brge	.+56     	; 0x2a6e <_ZN11Touchscreen12checkButtonsEv+0xf4>
    2a36:	f8 01       	movw	r30, r16
    2a38:	63 89       	ldd	r22, Z+19	; 0x13
    2a3a:	74 89       	ldd	r23, Z+20	; 0x14
    2a3c:	80 e0       	ldi	r24, 0x00	; 0
    2a3e:	90 e0       	ldi	r25, 0x00	; 0
    2a40:	b4 d7       	rcall	.+3944   	; 0x39aa <__floatunsisf>
    2a42:	21 e7       	ldi	r18, 0x71	; 113
    2a44:	3d e3       	ldi	r19, 0x3D	; 61
    2a46:	4a ea       	ldi	r20, 0xAA	; 170
    2a48:	5f e3       	ldi	r21, 0x3F	; 63
    2a4a:	1b d7       	rcall	.+3638   	; 0x3882 <__divsf3>
    2a4c:	9b 01       	movw	r18, r22
    2a4e:	ac 01       	movw	r20, r24
    2a50:	c7 01       	movw	r24, r14
    2a52:	b6 01       	movw	r22, r12
    2a54:	12 d7       	rcall	.+3620   	; 0x387a <__cmpsf2>
    2a56:	87 ff       	sbrs	r24, 7
    2a58:	0a c0       	rjmp	.+20     	; 0x2a6e <_ZN11Touchscreen12checkButtonsEv+0xf4>
    2a5a:	89 81       	ldd	r24, Y+1	; 0x01
    2a5c:	f8 01       	movw	r30, r16
    2a5e:	95 85       	ldd	r25, Z+13	; 0x0d
    2a60:	98 17       	cp	r25, r24
    2a62:	28 f4       	brcc	.+10     	; 0x2a6e <_ZN11Touchscreen12checkButtonsEv+0xf4>
    2a64:	95 89       	ldd	r25, Z+21	; 0x15
    2a66:	89 17       	cp	r24, r25
    2a68:	10 f4       	brcc	.+4      	; 0x2a6e <_ZN11Touchscreen12checkButtonsEv+0xf4>
    2a6a:	82 e0       	ldi	r24, 0x02	; 2
	{
		return 2;
    2a6c:	01 c0       	rjmp	.+2      	; 0x2a70 <_ZN11Touchscreen12checkButtonsEv+0xf6>
    2a6e:	80 e0       	ldi	r24, 0x00	; 0
	}
	else
	{
		return 0;
    2a70:	0f 90       	pop	r0
	}
	
}
    2a72:	0f 90       	pop	r0
    2a74:	df 91       	pop	r29
    2a76:	cf 91       	pop	r28
    2a78:	1f 91       	pop	r17
    2a7a:	0f 91       	pop	r16
    2a7c:	ff 90       	pop	r15
    2a7e:	ef 90       	pop	r14
    2a80:	df 90       	pop	r13
    2a82:	cf 90       	pop	r12
    2a84:	08 95       	ret
    2a86:	81 e0       	ldi	r24, 0x01	; 1
	
	// Check if touch is in between buttons on display. 1.33 is the scaling factor between touch and display.
	// Max Touch Res is 255 while display is 320
	if (x > blueBnt.startX/1.33 && x < blueBnt.endX/1.33 && y > blueBnt.startY && y < blueBnt.endY)
	{
		return 1;
    2a88:	f3 cf       	rjmp	.-26     	; 0x2a70 <_ZN11Touchscreen12checkButtonsEv+0xf6>

00002a8a <_ZN11Touchscreen11clearScreenEv>:
    2a8a:	cf 92       	push	r12
	}
	
}

void Touchscreen::clearScreen(void)
{
    2a8c:	ef 92       	push	r14
    2a8e:	0f 93       	push	r16
	// Full Screen White
	FillRectangle(0,0,320,240,255,255,255);
    2a90:	cc 24       	eor	r12, r12
    2a92:	ca 94       	dec	r12
    2a94:	ee 24       	eor	r14, r14
    2a96:	ea 94       	dec	r14
    2a98:	0f ef       	ldi	r16, 0xFF	; 255
    2a9a:	20 ef       	ldi	r18, 0xF0	; 240
    2a9c:	30 e0       	ldi	r19, 0x00	; 0
    2a9e:	40 e4       	ldi	r20, 0x40	; 64
    2aa0:	51 e0       	ldi	r21, 0x01	; 1
    2aa2:	60 e0       	ldi	r22, 0x00	; 0
    2aa4:	70 e0       	ldi	r23, 0x00	; 0
    2aa6:	80 e0       	ldi	r24, 0x00	; 0
    2aa8:	90 e0       	ldi	r25, 0x00	; 0
    2aaa:	2e de       	rcall	.-932    	; 0x2708 <_Z13FillRectanglejjjjhhh>
}
    2aac:	0f 91       	pop	r16
    2aae:	ef 90       	pop	r14
    2ab0:	cf 90       	pop	r12
    2ab2:	08 95       	ret

00002ab4 <_ZN11Touchscreen23presentButtonsOnDisplayEv>:

void Touchscreen::presentButtonsOnDisplay(void)
{
    2ab4:	cf 92       	push	r12
    2ab6:	ef 92       	push	r14
    2ab8:	0f 93       	push	r16
    2aba:	cf 93       	push	r28
    2abc:	df 93       	push	r29
    2abe:	ec 01       	movw	r28, r24
	
	// Button One
	FillRectangle(blueBnt.startX, blueBnt.startY, blueBnt.width, blueBnt.height, blueBnt.colorRed, blueBnt.colorGreen, blueBnt.colorBlue);
    2ac0:	2c 81       	ldd	r18, Y+4	; 0x04
    2ac2:	30 e0       	ldi	r19, 0x00	; 0
    2ac4:	4d 81       	ldd	r20, Y+5	; 0x05
    2ac6:	50 e0       	ldi	r21, 0x00	; 0
    2ac8:	6b 81       	ldd	r22, Y+3	; 0x03
    2aca:	70 e0       	ldi	r23, 0x00	; 0
    2acc:	8a 81       	ldd	r24, Y+2	; 0x02
    2ace:	cf 80       	ldd	r12, Y+7	; 0x07
    2ad0:	e8 84       	ldd	r14, Y+8	; 0x08
    2ad2:	0e 81       	ldd	r16, Y+6	; 0x06
    2ad4:	90 e0       	ldi	r25, 0x00	; 0
    2ad6:	18 de       	rcall	.-976    	; 0x2708 <_Z13FillRectanglejjjjhhh>

	// Button Two
	FillRectangle(greenBnt.startX, greenBnt.startY, greenBnt.width, greenBnt.height, greenBnt.colorRed, greenBnt.colorGreen, greenBnt.colorBlue);
    2ad8:	2e 85       	ldd	r18, Y+14	; 0x0e
    2ada:	30 e0       	ldi	r19, 0x00	; 0
    2adc:	4f 85       	ldd	r20, Y+15	; 0x0f
    2ade:	50 e0       	ldi	r21, 0x00	; 0
    2ae0:	6d 85       	ldd	r22, Y+13	; 0x0d
    2ae2:	70 e0       	ldi	r23, 0x00	; 0
    2ae4:	8c 85       	ldd	r24, Y+12	; 0x0c
    2ae6:	c9 88       	ldd	r12, Y+17	; 0x11
    2ae8:	ea 88       	ldd	r14, Y+18	; 0x12
    2aea:	08 89       	ldd	r16, Y+16	; 0x10
    2aec:	90 e0       	ldi	r25, 0x00	; 0
    2aee:	0c de       	rcall	.-1000   	; 0x2708 <_Z13FillRectanglejjjjhhh>
}
    2af0:	df 91       	pop	r29
    2af2:	cf 91       	pop	r28
    2af4:	0f 91       	pop	r16
    2af6:	ef 90       	pop	r14
    2af8:	cf 90       	pop	r12
    2afa:	08 95       	ret

00002afc <_ZN11Touchscreen17flashRedOnDisplayEv>:

void Touchscreen::flashRedOnDisplay(void)
{
    2afc:	cf 92       	push	r12
    2afe:	ef 92       	push	r14
    2b00:	0f 93       	push	r16
    2b02:	fc 01       	movw	r30, r24
	FillRectangle(flashRed.startX, flashRed.startY, flashRed.width, flashRed.height, flashRed.colorRed, flashRed.colorGreen, flashRed.colorBlue);
    2b04:	20 8d       	ldd	r18, Z+24	; 0x18
    2b06:	30 e0       	ldi	r19, 0x00	; 0
    2b08:	41 8d       	ldd	r20, Z+25	; 0x19
    2b0a:	50 e0       	ldi	r21, 0x00	; 0
    2b0c:	67 89       	ldd	r22, Z+23	; 0x17
    2b0e:	70 e0       	ldi	r23, 0x00	; 0
    2b10:	86 89       	ldd	r24, Z+22	; 0x16
    2b12:	c3 8c       	ldd	r12, Z+27	; 0x1b
    2b14:	e4 8c       	ldd	r14, Z+28	; 0x1c
    2b16:	02 8d       	ldd	r16, Z+26	; 0x1a
    2b18:	90 e0       	ldi	r25, 0x00	; 0
    2b1a:	f6 dd       	rcall	.-1044   	; 0x2708 <_Z13FillRectanglejjjjhhh>
}
    2b1c:	0f 91       	pop	r16
    2b1e:	ef 90       	pop	r14
    2b20:	cf 90       	pop	r12
    2b22:	08 95       	ret

00002b24 <_ZN11TouchDriverC1Ev>:
	// Enable Interrupt
	EICRB = 0b00000010;
	EIMSK |= 0b00010000;
	
	// Enable global Interrupts
	sei();
    2b24:	2c e9       	ldi	r18, 0x9C	; 156
    2b26:	fc 01       	movw	r30, r24
    2b28:	20 83       	st	Z, r18
    2b2a:	2c ed       	ldi	r18, 0xDC	; 220
    2b2c:	21 83       	std	Z+1, r18	; 0x01
    2b2e:	e1 e0       	ldi	r30, 0x01	; 1
    2b30:	f1 e0       	ldi	r31, 0x01	; 1
    2b32:	80 81       	ld	r24, Z
    2b34:	88 60       	ori	r24, 0x08	; 8
    2b36:	80 83       	st	Z, r24
    2b38:	6b 9a       	sbi	0x0d, 3	; 13
    2b3a:	9d 9a       	sbi	0x13, 5	; 19
    2b3c:	82 e0       	ldi	r24, 0x02	; 2
    2b3e:	80 93 6a 00 	sts	0x006A, r24	; 0x80006a <__TEXT_REGION_LENGTH__+0x70006a>
    2b42:	ec 9a       	sbi	0x1d, 4	; 29
    2b44:	78 94       	sei
    2b46:	08 95       	ret

00002b48 <_ZN11TouchDriverD1Ev>:
    2b48:	08 95       	ret

00002b4a <__vector_5>:
	
}

ISR (INT4_vect)
{
    2b4a:	1f 92       	push	r1
    2b4c:	0f 92       	push	r0
    2b4e:	0f b6       	in	r0, 0x3f	; 63
    2b50:	0f 92       	push	r0
    2b52:	11 24       	eor	r1, r1
	eIntHappend = 0;
    2b54:	10 92 0d 02 	sts	0x020D, r1	; 0x80020d <eIntHappend>
}
    2b58:	0f 90       	pop	r0
    2b5a:	0f be       	out	0x3f, r0	; 63
    2b5c:	0f 90       	pop	r0
    2b5e:	1f 90       	pop	r1
    2b60:	18 95       	reti

00002b62 <_ZN11TouchDriver14getCoordinatesEPhS0_>:

void TouchDriver::getCoordinates(uint8_t *x_ptr, uint8_t *y_ptr)
{	
    2b62:	2f 92       	push	r2
    2b64:	3f 92       	push	r3
    2b66:	4f 92       	push	r4
    2b68:	5f 92       	push	r5
    2b6a:	6f 92       	push	r6
    2b6c:	7f 92       	push	r7
    2b6e:	8f 92       	push	r8
    2b70:	9f 92       	push	r9
    2b72:	af 92       	push	r10
    2b74:	bf 92       	push	r11
    2b76:	cf 92       	push	r12
    2b78:	df 92       	push	r13
    2b7a:	ef 92       	push	r14
    2b7c:	ff 92       	push	r15
    2b7e:	0f 93       	push	r16
    2b80:	1f 93       	push	r17
    2b82:	cf 93       	push	r28
    2b84:	df 93       	push	r29
    2b86:	cd b7       	in	r28, 0x3d	; 61
    2b88:	de b7       	in	r29, 0x3e	; 62
    2b8a:	a5 97       	sbiw	r28, 0x25	; 37
    2b8c:	0f b6       	in	r0, 0x3f	; 63
    2b8e:	f8 94       	cli
    2b90:	de bf       	out	0x3e, r29	; 62
    2b92:	0f be       	out	0x3f, r0	; 63
    2b94:	cd bf       	out	0x3d, r28	; 61
    2b96:	20 e0       	ldi	r18, 0x00	; 0
    2b98:	31 e0       	ldi	r19, 0x01	; 1
    2b9a:	04 c0       	rjmp	.+8      	; 0x2ba4 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x42>
    2b9c:	21 50       	subi	r18, 0x01	; 1
    2b9e:	31 09       	sbc	r19, r1
	uint16_t timeout = 0;
	while(eIntHappend != 0)
	{
		timeout++;
		if (timeout > 255)
    2ba0:	09 f4       	brne	.+2      	; 0x2ba4 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x42>
    2ba2:	a1 c5       	rjmp	.+2882   	; 0x36e6 <_ZN11TouchDriver14getCoordinatesEPhS0_+0xb84>
}

void TouchDriver::getCoordinates(uint8_t *x_ptr, uint8_t *y_ptr)
{	
	uint16_t timeout = 0;
	while(eIntHappend != 0)
    2ba4:	d0 90 0d 02 	lds	r13, 0x020D	; 0x80020d <eIntHappend>
    2ba8:	d1 10       	cpse	r13, r1
    2baa:	f8 cf       	rjmp	.-16     	; 0x2b9c <_ZN11TouchDriver14getCoordinatesEPhS0_+0x3a>
    uint8_t dinByte = 0;
    
	// Makes is easy to toggle between receiveing x and y coordinates
    if (coord == 'X')
    {
        dinByte = dinXByte;
    2bac:	fc 01       	movw	r30, r24
    2bae:	70 80       	ld	r7, Z
    else{
        return 255;
    }
    
    // ChipSelect Set to 0    
    CS_PORT &= ~CS_PIN;
    2bb0:	73 98       	cbi	0x0e, 3	; 14
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    2bb2:	fa e2       	ldi	r31, 0x2A	; 42
    2bb4:	fa 95       	dec	r31
    2bb6:	f1 f7       	brne	.-4      	; 0x2bb4 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x52>
    2bb8:	00 c0       	rjmp	.+0      	; 0x2bba <_ZN11TouchDriver14getCoordinatesEPhS0_+0x58>
    2bba:	27 2d       	mov	r18, r7
    2bbc:	30 e0       	ldi	r19, 0x00	; 0
    2bbe:	ea e2       	ldi	r30, 0x2A	; 42
    2bc0:	ea 95       	dec	r30
    2bc2:	f1 f7       	brne	.-4      	; 0x2bc0 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x5e>
    2bc4:	00 c0       	rjmp	.+0      	; 0x2bc6 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x64>
    // DIN byte and pulse DCLK for Read X
    for (int i = 7; i >= 0; i--)
    {
        _delay_us(delayTime);
        
        DIN_PORT |= (((dinByte >> i)  & 0x01) << 5);
    2bc6:	64 b2       	in	r6, 0x14	; 20
    2bc8:	69 01       	movw	r12, r18
    2bca:	cc 0c       	add	r12, r12
    2bcc:	cd 2c       	mov	r12, r13
    2bce:	cc 1c       	adc	r12, r12
    2bd0:	dd 08       	sbc	r13, r13
    2bd2:	cc 0c       	add	r12, r12
    2bd4:	dd 1c       	adc	r13, r13
    2bd6:	c2 94       	swap	r12
    2bd8:	d2 94       	swap	r13
    2bda:	e0 ef       	ldi	r30, 0xF0	; 240
    2bdc:	de 22       	and	r13, r30
    2bde:	dc 24       	eor	r13, r12
    2be0:	ce 22       	and	r12, r30
    2be2:	dc 24       	eor	r13, r12
    2be4:	c6 28       	or	r12, r6
    2be6:	c4 ba       	out	0x14, r12	; 20
        
        CLK_PORT |= CLK_PIN;
    2be8:	30 91 02 01 	lds	r19, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    2bec:	38 60       	ori	r19, 0x08	; 8
    2bee:	30 93 02 01 	sts	0x0102, r19	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    2bf2:	fa e2       	ldi	r31, 0x2A	; 42
    2bf4:	fa 95       	dec	r31
    2bf6:	f1 f7       	brne	.-4      	; 0x2bf4 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x92>
    2bf8:	00 c0       	rjmp	.+0      	; 0x2bfa <_ZN11TouchDriver14getCoordinatesEPhS0_+0x98>
		
        _delay_us(delayTime);
        
        CLK_PORT &= ~CLK_PIN;
    2bfa:	30 91 02 01 	lds	r19, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    2bfe:	37 7f       	andi	r19, 0xF7	; 247
    2c00:	30 93 02 01 	sts	0x0102, r19	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
        DIN_PORT &= ~BIT6_SHIFTED;
    2c04:	a5 98       	cbi	0x14, 5	; 20
    2c06:	ea e2       	ldi	r30, 0x2A	; 42
    2c08:	ea 95       	dec	r30
    2c0a:	f1 f7       	brne	.-4      	; 0x2c08 <_ZN11TouchDriver14getCoordinatesEPhS0_+0xa6>
    2c0c:	00 c0       	rjmp	.+0      	; 0x2c0e <_ZN11TouchDriver14getCoordinatesEPhS0_+0xac>
    // DIN byte and pulse DCLK for Read X
    for (int i = 7; i >= 0; i--)
    {
        _delay_us(delayTime);
        
        DIN_PORT |= (((dinByte >> i)  & 0x01) << 5);
    2c0e:	34 b3       	in	r19, 0x14	; 20
    2c10:	76 fa       	bst	r7, 6
    2c12:	ee 24       	eor	r14, r14
    2c14:	e0 f8       	bld	r14, 0
    2c16:	f1 2c       	mov	r15, r1
    2c18:	ee 0c       	add	r14, r14
    2c1a:	ff 1c       	adc	r15, r15
    2c1c:	e2 94       	swap	r14
    2c1e:	f2 94       	swap	r15
    2c20:	f0 ef       	ldi	r31, 0xF0	; 240
    2c22:	ff 22       	and	r15, r31
    2c24:	fe 24       	eor	r15, r14
    2c26:	ef 22       	and	r14, r31
    2c28:	fe 24       	eor	r15, r14
    2c2a:	e3 2a       	or	r14, r19
    2c2c:	e4 ba       	out	0x14, r14	; 20
        
        CLK_PORT |= CLK_PIN;
    2c2e:	30 91 02 01 	lds	r19, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    2c32:	38 60       	ori	r19, 0x08	; 8
    2c34:	30 93 02 01 	sts	0x0102, r19	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    2c38:	fa e2       	ldi	r31, 0x2A	; 42
    2c3a:	fa 95       	dec	r31
    2c3c:	f1 f7       	brne	.-4      	; 0x2c3a <_ZN11TouchDriver14getCoordinatesEPhS0_+0xd8>
    2c3e:	00 c0       	rjmp	.+0      	; 0x2c40 <_ZN11TouchDriver14getCoordinatesEPhS0_+0xde>
		
        _delay_us(delayTime);
        
        CLK_PORT &= ~CLK_PIN;
    2c40:	30 91 02 01 	lds	r19, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    2c44:	37 7f       	andi	r19, 0xF7	; 247
    2c46:	30 93 02 01 	sts	0x0102, r19	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
        DIN_PORT &= ~BIT6_SHIFTED;
    2c4a:	a5 98       	cbi	0x14, 5	; 20
    2c4c:	ea e2       	ldi	r30, 0x2A	; 42
    2c4e:	ea 95       	dec	r30
    2c50:	f1 f7       	brne	.-4      	; 0x2c4e <_ZN11TouchDriver14getCoordinatesEPhS0_+0xec>
    2c52:	00 c0       	rjmp	.+0      	; 0x2c54 <_ZN11TouchDriver14getCoordinatesEPhS0_+0xf2>
    // DIN byte and pulse DCLK for Read X
    for (int i = 7; i >= 0; i--)
    {
        _delay_us(delayTime);
        
        DIN_PORT |= (((dinByte >> i)  & 0x01) << 5);
    2c54:	34 b3       	in	r19, 0x14	; 20
    2c56:	75 fa       	bst	r7, 5
    2c58:	00 27       	eor	r16, r16
    2c5a:	00 f9       	bld	r16, 0
    2c5c:	10 e0       	ldi	r17, 0x00	; 0
    2c5e:	00 0f       	add	r16, r16
    2c60:	11 1f       	adc	r17, r17
    2c62:	02 95       	swap	r16
    2c64:	12 95       	swap	r17
    2c66:	10 7f       	andi	r17, 0xF0	; 240
    2c68:	10 27       	eor	r17, r16
    2c6a:	00 7f       	andi	r16, 0xF0	; 240
    2c6c:	10 27       	eor	r17, r16
    2c6e:	03 2b       	or	r16, r19
    2c70:	04 bb       	out	0x14, r16	; 20
        
        CLK_PORT |= CLK_PIN;
    2c72:	30 91 02 01 	lds	r19, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    2c76:	38 60       	ori	r19, 0x08	; 8
    2c78:	30 93 02 01 	sts	0x0102, r19	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    2c7c:	fa e2       	ldi	r31, 0x2A	; 42
    2c7e:	fa 95       	dec	r31
    2c80:	f1 f7       	brne	.-4      	; 0x2c7e <_ZN11TouchDriver14getCoordinatesEPhS0_+0x11c>
    2c82:	00 c0       	rjmp	.+0      	; 0x2c84 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x122>
		
        _delay_us(delayTime);
        
        CLK_PORT &= ~CLK_PIN;
    2c84:	30 91 02 01 	lds	r19, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    2c88:	37 7f       	andi	r19, 0xF7	; 247
    2c8a:	30 93 02 01 	sts	0x0102, r19	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
        DIN_PORT &= ~BIT6_SHIFTED;
    2c8e:	a5 98       	cbi	0x14, 5	; 20
    2c90:	ea e2       	ldi	r30, 0x2A	; 42
    2c92:	ea 95       	dec	r30
    2c94:	f1 f7       	brne	.-4      	; 0x2c92 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x130>
    2c96:	00 c0       	rjmp	.+0      	; 0x2c98 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x136>
    // DIN byte and pulse DCLK for Read X
    for (int i = 7; i >= 0; i--)
    {
        _delay_us(delayTime);
        
        DIN_PORT |= (((dinByte >> i)  & 0x01) << 5);
    2c98:	34 b3       	in	r19, 0x14	; 20
    2c9a:	74 fa       	bst	r7, 4
    2c9c:	ff 27       	eor	r31, r31
    2c9e:	f0 f9       	bld	r31, 0
    2ca0:	fc a3       	std	Y+36, r31	; 0x24
    2ca2:	1d a2       	std	Y+37, r1	; 0x25
    2ca4:	ec a1       	ldd	r30, Y+36	; 0x24
    2ca6:	fd a1       	ldd	r31, Y+37	; 0x25
    2ca8:	ee 0f       	add	r30, r30
    2caa:	ff 1f       	adc	r31, r31
    2cac:	e2 95       	swap	r30
    2cae:	f2 95       	swap	r31
    2cb0:	f0 7f       	andi	r31, 0xF0	; 240
    2cb2:	fe 27       	eor	r31, r30
    2cb4:	e0 7f       	andi	r30, 0xF0	; 240
    2cb6:	fe 27       	eor	r31, r30
    2cb8:	fd a3       	std	Y+37, r31	; 0x25
    2cba:	ec a3       	std	Y+36, r30	; 0x24
    2cbc:	e3 2b       	or	r30, r19
    2cbe:	e4 bb       	out	0x14, r30	; 20
        
        CLK_PORT |= CLK_PIN;
    2cc0:	30 91 02 01 	lds	r19, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    2cc4:	38 60       	ori	r19, 0x08	; 8
    2cc6:	30 93 02 01 	sts	0x0102, r19	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    2cca:	fa e2       	ldi	r31, 0x2A	; 42
    2ccc:	fa 95       	dec	r31
    2cce:	f1 f7       	brne	.-4      	; 0x2ccc <_ZN11TouchDriver14getCoordinatesEPhS0_+0x16a>
    2cd0:	00 c0       	rjmp	.+0      	; 0x2cd2 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x170>
		
        _delay_us(delayTime);
        
        CLK_PORT &= ~CLK_PIN;
    2cd2:	30 91 02 01 	lds	r19, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    2cd6:	37 7f       	andi	r19, 0xF7	; 247
    2cd8:	30 93 02 01 	sts	0x0102, r19	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
        DIN_PORT &= ~BIT6_SHIFTED;
    2cdc:	a5 98       	cbi	0x14, 5	; 20
    2cde:	ea e2       	ldi	r30, 0x2A	; 42
    2ce0:	ea 95       	dec	r30
    2ce2:	f1 f7       	brne	.-4      	; 0x2ce0 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x17e>
    2ce4:	00 c0       	rjmp	.+0      	; 0x2ce6 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x184>
    // DIN byte and pulse DCLK for Read X
    for (int i = 7; i >= 0; i--)
    {
        _delay_us(delayTime);
        
        DIN_PORT |= (((dinByte >> i)  & 0x01) << 5);
    2ce6:	34 b3       	in	r19, 0x14	; 20
    2ce8:	73 fa       	bst	r7, 3
    2cea:	aa 27       	eor	r26, r26
    2cec:	a0 f9       	bld	r26, 0
    2cee:	b0 e0       	ldi	r27, 0x00	; 0
    2cf0:	aa 0f       	add	r26, r26
    2cf2:	bb 1f       	adc	r27, r27
    2cf4:	a2 95       	swap	r26
    2cf6:	b2 95       	swap	r27
    2cf8:	b0 7f       	andi	r27, 0xF0	; 240
    2cfa:	ba 27       	eor	r27, r26
    2cfc:	a0 7f       	andi	r26, 0xF0	; 240
    2cfe:	ba 27       	eor	r27, r26
    2d00:	a3 2b       	or	r26, r19
    2d02:	a4 bb       	out	0x14, r26	; 20
        
        CLK_PORT |= CLK_PIN;
    2d04:	30 91 02 01 	lds	r19, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    2d08:	38 60       	ori	r19, 0x08	; 8
    2d0a:	30 93 02 01 	sts	0x0102, r19	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    2d0e:	fa e2       	ldi	r31, 0x2A	; 42
    2d10:	fa 95       	dec	r31
    2d12:	f1 f7       	brne	.-4      	; 0x2d10 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x1ae>
    2d14:	00 c0       	rjmp	.+0      	; 0x2d16 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x1b4>
		
        _delay_us(delayTime);
        
        CLK_PORT &= ~CLK_PIN;
    2d16:	30 91 02 01 	lds	r19, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    2d1a:	37 7f       	andi	r19, 0xF7	; 247
    2d1c:	30 93 02 01 	sts	0x0102, r19	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
        DIN_PORT &= ~BIT6_SHIFTED;
    2d20:	a5 98       	cbi	0x14, 5	; 20
    2d22:	ea e2       	ldi	r30, 0x2A	; 42
    2d24:	ea 95       	dec	r30
    2d26:	f1 f7       	brne	.-4      	; 0x2d24 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x1c2>
    2d28:	00 c0       	rjmp	.+0      	; 0x2d2a <_ZN11TouchDriver14getCoordinatesEPhS0_+0x1c8>
    // DIN byte and pulse DCLK for Read X
    for (int i = 7; i >= 0; i--)
    {
        _delay_us(delayTime);
        
        DIN_PORT |= (((dinByte >> i)  & 0x01) << 5);
    2d2a:	34 b3       	in	r19, 0x14	; 20
    2d2c:	72 fa       	bst	r7, 2
    2d2e:	ee 27       	eor	r30, r30
    2d30:	e0 f9       	bld	r30, 0
    2d32:	f0 e0       	ldi	r31, 0x00	; 0
    2d34:	ee 0f       	add	r30, r30
    2d36:	ff 1f       	adc	r31, r31
    2d38:	e2 95       	swap	r30
    2d3a:	f2 95       	swap	r31
    2d3c:	f0 7f       	andi	r31, 0xF0	; 240
    2d3e:	fe 27       	eor	r31, r30
    2d40:	e0 7f       	andi	r30, 0xF0	; 240
    2d42:	fe 27       	eor	r31, r30
    2d44:	e3 2b       	or	r30, r19
    2d46:	e4 bb       	out	0x14, r30	; 20
        
        CLK_PORT |= CLK_PIN;
    2d48:	30 91 02 01 	lds	r19, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    2d4c:	38 60       	ori	r19, 0x08	; 8
    2d4e:	30 93 02 01 	sts	0x0102, r19	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    2d52:	fa e2       	ldi	r31, 0x2A	; 42
    2d54:	fa 95       	dec	r31
    2d56:	f1 f7       	brne	.-4      	; 0x2d54 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x1f2>
    2d58:	00 c0       	rjmp	.+0      	; 0x2d5a <_ZN11TouchDriver14getCoordinatesEPhS0_+0x1f8>
		
        _delay_us(delayTime);
        
        CLK_PORT &= ~CLK_PIN;
    2d5a:	30 91 02 01 	lds	r19, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    2d5e:	37 7f       	andi	r19, 0xF7	; 247
    2d60:	30 93 02 01 	sts	0x0102, r19	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
        DIN_PORT &= ~BIT6_SHIFTED;
    2d64:	a5 98       	cbi	0x14, 5	; 20
    2d66:	ea e2       	ldi	r30, 0x2A	; 42
    2d68:	ea 95       	dec	r30
    2d6a:	f1 f7       	brne	.-4      	; 0x2d68 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x206>
    2d6c:	00 c0       	rjmp	.+0      	; 0x2d6e <_ZN11TouchDriver14getCoordinatesEPhS0_+0x20c>
    // DIN byte and pulse DCLK for Read X
    for (int i = 7; i >= 0; i--)
    {
        _delay_us(delayTime);
        
        DIN_PORT |= (((dinByte >> i)  & 0x01) << 5);
    2d6e:	34 b3       	in	r19, 0x14	; 20
    2d70:	71 fa       	bst	r7, 1
    2d72:	aa 24       	eor	r10, r10
    2d74:	a0 f8       	bld	r10, 0
    2d76:	b1 2c       	mov	r11, r1
    2d78:	aa 0c       	add	r10, r10
    2d7a:	bb 1c       	adc	r11, r11
    2d7c:	a2 94       	swap	r10
    2d7e:	b2 94       	swap	r11
    2d80:	20 ef       	ldi	r18, 0xF0	; 240
    2d82:	b2 22       	and	r11, r18
    2d84:	ba 24       	eor	r11, r10
    2d86:	a2 22       	and	r10, r18
    2d88:	ba 24       	eor	r11, r10
    2d8a:	a3 2a       	or	r10, r19
    2d8c:	a4 ba       	out	0x14, r10	; 20
        
        CLK_PORT |= CLK_PIN;
    2d8e:	20 91 02 01 	lds	r18, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    2d92:	28 60       	ori	r18, 0x08	; 8
    2d94:	20 93 02 01 	sts	0x0102, r18	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    2d98:	fa e2       	ldi	r31, 0x2A	; 42
    2d9a:	fa 95       	dec	r31
    2d9c:	f1 f7       	brne	.-4      	; 0x2d9a <_ZN11TouchDriver14getCoordinatesEPhS0_+0x238>
    2d9e:	00 c0       	rjmp	.+0      	; 0x2da0 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x23e>
		
        _delay_us(delayTime);
        
        CLK_PORT &= ~CLK_PIN;
    2da0:	20 91 02 01 	lds	r18, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    2da4:	27 7f       	andi	r18, 0xF7	; 247
    2da6:	20 93 02 01 	sts	0x0102, r18	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
        DIN_PORT &= ~BIT6_SHIFTED;
    2daa:	a5 98       	cbi	0x14, 5	; 20
    2dac:	2a e2       	ldi	r18, 0x2A	; 42
    2dae:	2a 95       	dec	r18
    2db0:	f1 f7       	brne	.-4      	; 0x2dae <_ZN11TouchDriver14getCoordinatesEPhS0_+0x24c>
    2db2:	00 c0       	rjmp	.+0      	; 0x2db4 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x252>
    // DIN byte and pulse DCLK for Read X
    for (int i = 7; i >= 0; i--)
    {
        _delay_us(delayTime);
        
        DIN_PORT |= (((dinByte >> i)  & 0x01) << 5);
    2db4:	24 b3       	in	r18, 0x14	; 20
    2db6:	70 fa       	bst	r7, 0
    2db8:	88 24       	eor	r8, r8
    2dba:	80 f8       	bld	r8, 0
    2dbc:	91 2c       	mov	r9, r1
    2dbe:	88 0c       	add	r8, r8
    2dc0:	99 1c       	adc	r9, r9
    2dc2:	82 94       	swap	r8
    2dc4:	92 94       	swap	r9
    2dc6:	30 ef       	ldi	r19, 0xF0	; 240
    2dc8:	93 22       	and	r9, r19
    2dca:	98 24       	eor	r9, r8
    2dcc:	83 22       	and	r8, r19
    2dce:	98 24       	eor	r9, r8
    2dd0:	82 2a       	or	r8, r18
    2dd2:	84 ba       	out	0x14, r8	; 20
        
        CLK_PORT |= CLK_PIN;
    2dd4:	20 91 02 01 	lds	r18, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    2dd8:	28 60       	ori	r18, 0x08	; 8
    2dda:	20 93 02 01 	sts	0x0102, r18	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    2dde:	3a e2       	ldi	r19, 0x2A	; 42
    2de0:	3a 95       	dec	r19
    2de2:	f1 f7       	brne	.-4      	; 0x2de0 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x27e>
    2de4:	00 c0       	rjmp	.+0      	; 0x2de6 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x284>
		
        _delay_us(delayTime);
        
        CLK_PORT &= ~CLK_PIN;
    2de6:	20 91 02 01 	lds	r18, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    2dea:	27 7f       	andi	r18, 0xF7	; 247
    2dec:	20 93 02 01 	sts	0x0102, r18	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
        DIN_PORT &= ~BIT6_SHIFTED;
    2df0:	a5 98       	cbi	0x14, 5	; 20
    2df2:	ea e2       	ldi	r30, 0x2A	; 42
    2df4:	ea 95       	dec	r30
    2df6:	f1 f7       	brne	.-4      	; 0x2df4 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x292>
    2df8:	00 c0       	rjmp	.+0      	; 0x2dfa <_ZN11TouchDriver14getCoordinatesEPhS0_+0x298>
    // Systematically read DOUT
    for (int i = 7; i >= 0; i--)
    {
        _delay_us(delayTime);
        
        CLK_PORT |= CLK_PIN;
    2dfa:	20 91 02 01 	lds	r18, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    2dfe:	28 60       	ori	r18, 0x08	; 8
    2e00:	20 93 02 01 	sts	0x0102, r18	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    2e04:	fa e2       	ldi	r31, 0x2A	; 42
    2e06:	fa 95       	dec	r31
    2e08:	f1 f7       	brne	.-4      	; 0x2e06 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x2a4>
    2e0a:	00 c0       	rjmp	.+0      	; 0x2e0c <_ZN11TouchDriver14getCoordinatesEPhS0_+0x2aa>
        _delay_us(delayTime);
        CLK_PORT &= ~CLK_PIN;
    2e0c:	20 91 02 01 	lds	r18, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    2e10:	27 7f       	andi	r18, 0xF7	; 247
    2e12:	20 93 02 01 	sts	0x0102, r18	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    2e16:	25 e0       	ldi	r18, 0x05	; 5
    2e18:	2a 95       	dec	r18
    2e1a:	f1 f7       	brne	.-4      	; 0x2e18 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x2b6>
    2e1c:	00 00       	nop
        _delay_us(1);
        
        bool temp = (PINE & (1U << 5));
    2e1e:	2c b1       	in	r18, 0x0c	; 12
    2e20:	3a e2       	ldi	r19, 0x2A	; 42
    2e22:	3a 95       	dec	r19
    2e24:	f1 f7       	brne	.-4      	; 0x2e22 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x2c0>
    2e26:	00 c0       	rjmp	.+0      	; 0x2e28 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x2c6>
    // Systematically read DOUT
    for (int i = 7; i >= 0; i--)
    {
        _delay_us(delayTime);
        
        CLK_PORT |= CLK_PIN;
    2e28:	30 91 02 01 	lds	r19, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    2e2c:	38 60       	ori	r19, 0x08	; 8
    2e2e:	30 93 02 01 	sts	0x0102, r19	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    2e32:	ea e2       	ldi	r30, 0x2A	; 42
    2e34:	ea 95       	dec	r30
    2e36:	f1 f7       	brne	.-4      	; 0x2e34 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x2d2>
    2e38:	00 c0       	rjmp	.+0      	; 0x2e3a <_ZN11TouchDriver14getCoordinatesEPhS0_+0x2d8>
        _delay_us(delayTime);
        CLK_PORT &= ~CLK_PIN;
    2e3a:	30 91 02 01 	lds	r19, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    2e3e:	37 7f       	andi	r19, 0xF7	; 247
    2e40:	30 93 02 01 	sts	0x0102, r19	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    2e44:	f5 e0       	ldi	r31, 0x05	; 5
    2e46:	fa 95       	dec	r31
    2e48:	f1 f7       	brne	.-4      	; 0x2e46 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x2e4>
    2e4a:	00 00       	nop
        _delay_us(1);
        
        bool temp = (PINE & (1U << 5));
    2e4c:	3c b1       	in	r19, 0x0c	; 12
        
        result |= (temp << i);
    2e4e:	35 fb       	bst	r19, 5
    2e50:	44 24       	eor	r4, r4
    2e52:	40 f8       	bld	r4, 0
    2e54:	51 2c       	mov	r5, r1
    2e56:	00 24       	eor	r0, r0
    2e58:	56 94       	lsr	r5
    2e5a:	47 94       	ror	r4
    2e5c:	07 94       	ror	r0
    2e5e:	56 94       	lsr	r5
    2e60:	47 94       	ror	r4
    2e62:	07 94       	ror	r0
    2e64:	54 2c       	mov	r5, r4
    2e66:	40 2c       	mov	r4, r0
    2e68:	25 fb       	bst	r18, 5
    2e6a:	22 24       	eor	r2, r2
    2e6c:	20 f8       	bld	r2, 0
    2e6e:	31 2c       	mov	r3, r1
    2e70:	36 94       	lsr	r3
    2e72:	32 2c       	mov	r3, r2
    2e74:	22 24       	eor	r2, r2
    2e76:	37 94       	ror	r3
    2e78:	27 94       	ror	r2
    2e7a:	42 28       	or	r4, r2
    2e7c:	2a e2       	ldi	r18, 0x2A	; 42
    2e7e:	2a 95       	dec	r18
    2e80:	f1 f7       	brne	.-4      	; 0x2e7e <_ZN11TouchDriver14getCoordinatesEPhS0_+0x31c>
    2e82:	00 c0       	rjmp	.+0      	; 0x2e84 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x322>
    // Systematically read DOUT
    for (int i = 7; i >= 0; i--)
    {
        _delay_us(delayTime);
        
        CLK_PORT |= CLK_PIN;
    2e84:	20 91 02 01 	lds	r18, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    2e88:	28 60       	ori	r18, 0x08	; 8
    2e8a:	20 93 02 01 	sts	0x0102, r18	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    2e8e:	3a e2       	ldi	r19, 0x2A	; 42
    2e90:	3a 95       	dec	r19
    2e92:	f1 f7       	brne	.-4      	; 0x2e90 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x32e>
    2e94:	00 c0       	rjmp	.+0      	; 0x2e96 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x334>
        _delay_us(delayTime);
        CLK_PORT &= ~CLK_PIN;
    2e96:	20 91 02 01 	lds	r18, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    2e9a:	27 7f       	andi	r18, 0xF7	; 247
    2e9c:	20 93 02 01 	sts	0x0102, r18	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    2ea0:	e5 e0       	ldi	r30, 0x05	; 5
    2ea2:	ea 95       	dec	r30
    2ea4:	f1 f7       	brne	.-4      	; 0x2ea2 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x340>
    2ea6:	00 00       	nop
        _delay_us(1);
        
        bool temp = (PINE & (1U << 5));
    2ea8:	2c b1       	in	r18, 0x0c	; 12
        
        result |= (temp << i);
    2eaa:	20 72       	andi	r18, 0x20	; 32
    2eac:	42 2a       	or	r4, r18
    2eae:	fa e2       	ldi	r31, 0x2A	; 42
    2eb0:	fa 95       	dec	r31
    2eb2:	f1 f7       	brne	.-4      	; 0x2eb0 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x34e>
    2eb4:	00 c0       	rjmp	.+0      	; 0x2eb6 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x354>
    // Systematically read DOUT
    for (int i = 7; i >= 0; i--)
    {
        _delay_us(delayTime);
        
        CLK_PORT |= CLK_PIN;
    2eb6:	20 91 02 01 	lds	r18, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    2eba:	28 60       	ori	r18, 0x08	; 8
    2ebc:	20 93 02 01 	sts	0x0102, r18	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    2ec0:	2a e2       	ldi	r18, 0x2A	; 42
    2ec2:	2a 95       	dec	r18
    2ec4:	f1 f7       	brne	.-4      	; 0x2ec2 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x360>
    2ec6:	00 c0       	rjmp	.+0      	; 0x2ec8 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x366>
        _delay_us(delayTime);
        CLK_PORT &= ~CLK_PIN;
    2ec8:	20 91 02 01 	lds	r18, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    2ecc:	27 7f       	andi	r18, 0xF7	; 247
    2ece:	20 93 02 01 	sts	0x0102, r18	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    2ed2:	35 e0       	ldi	r19, 0x05	; 5
    2ed4:	3a 95       	dec	r19
    2ed6:	f1 f7       	brne	.-4      	; 0x2ed4 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x372>
    2ed8:	00 00       	nop
        _delay_us(1);
        
        bool temp = (PINE & (1U << 5));
    2eda:	2c b1       	in	r18, 0x0c	; 12
        
        result |= (temp << i);
    2edc:	25 fb       	bst	r18, 5
    2ede:	22 27       	eor	r18, r18
    2ee0:	20 f9       	bld	r18, 0
    2ee2:	29 83       	std	Y+1, r18	; 0x01
    2ee4:	1a 82       	std	Y+2, r1	; 0x02
    2ee6:	29 81       	ldd	r18, Y+1	; 0x01
    2ee8:	3a 81       	ldd	r19, Y+2	; 0x02
    2eea:	22 95       	swap	r18
    2eec:	32 95       	swap	r19
    2eee:	30 7f       	andi	r19, 0xF0	; 240
    2ef0:	32 27       	eor	r19, r18
    2ef2:	20 7f       	andi	r18, 0xF0	; 240
    2ef4:	32 27       	eor	r19, r18
    2ef6:	42 2a       	or	r4, r18
    2ef8:	ea e2       	ldi	r30, 0x2A	; 42
    2efa:	ea 95       	dec	r30
    2efc:	f1 f7       	brne	.-4      	; 0x2efa <_ZN11TouchDriver14getCoordinatesEPhS0_+0x398>
    2efe:	00 c0       	rjmp	.+0      	; 0x2f00 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x39e>
    // Systematically read DOUT
    for (int i = 7; i >= 0; i--)
    {
        _delay_us(delayTime);
        
        CLK_PORT |= CLK_PIN;
    2f00:	20 91 02 01 	lds	r18, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    2f04:	28 60       	ori	r18, 0x08	; 8
    2f06:	20 93 02 01 	sts	0x0102, r18	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    2f0a:	fa e2       	ldi	r31, 0x2A	; 42
    2f0c:	fa 95       	dec	r31
    2f0e:	f1 f7       	brne	.-4      	; 0x2f0c <_ZN11TouchDriver14getCoordinatesEPhS0_+0x3aa>
    2f10:	00 c0       	rjmp	.+0      	; 0x2f12 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x3b0>
        _delay_us(delayTime);
        CLK_PORT &= ~CLK_PIN;
    2f12:	20 91 02 01 	lds	r18, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    2f16:	27 7f       	andi	r18, 0xF7	; 247
    2f18:	20 93 02 01 	sts	0x0102, r18	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    2f1c:	25 e0       	ldi	r18, 0x05	; 5
    2f1e:	2a 95       	dec	r18
    2f20:	f1 f7       	brne	.-4      	; 0x2f1e <_ZN11TouchDriver14getCoordinatesEPhS0_+0x3bc>
    2f22:	00 00       	nop
        _delay_us(1);
        
        bool temp = (PINE & (1U << 5));
    2f24:	2c b1       	in	r18, 0x0c	; 12
        
        result |= (temp << i);
    2f26:	25 fb       	bst	r18, 5
    2f28:	22 27       	eor	r18, r18
    2f2a:	20 f9       	bld	r18, 0
    2f2c:	2b 83       	std	Y+3, r18	; 0x03
    2f2e:	1c 82       	std	Y+4, r1	; 0x04
    2f30:	eb 81       	ldd	r30, Y+3	; 0x03
    2f32:	fc 81       	ldd	r31, Y+4	; 0x04
    2f34:	ee 0f       	add	r30, r30
    2f36:	ff 1f       	adc	r31, r31
    2f38:	ee 0f       	add	r30, r30
    2f3a:	ff 1f       	adc	r31, r31
    2f3c:	ee 0f       	add	r30, r30
    2f3e:	ff 1f       	adc	r31, r31
    2f40:	4e 2a       	or	r4, r30
    2f42:	3a e2       	ldi	r19, 0x2A	; 42
    2f44:	3a 95       	dec	r19
    2f46:	f1 f7       	brne	.-4      	; 0x2f44 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x3e2>
    2f48:	00 c0       	rjmp	.+0      	; 0x2f4a <_ZN11TouchDriver14getCoordinatesEPhS0_+0x3e8>
    // Systematically read DOUT
    for (int i = 7; i >= 0; i--)
    {
        _delay_us(delayTime);
        
        CLK_PORT |= CLK_PIN;
    2f4a:	20 91 02 01 	lds	r18, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    2f4e:	28 60       	ori	r18, 0x08	; 8
    2f50:	20 93 02 01 	sts	0x0102, r18	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    2f54:	ea e2       	ldi	r30, 0x2A	; 42
    2f56:	ea 95       	dec	r30
    2f58:	f1 f7       	brne	.-4      	; 0x2f56 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x3f4>
    2f5a:	00 c0       	rjmp	.+0      	; 0x2f5c <_ZN11TouchDriver14getCoordinatesEPhS0_+0x3fa>
        _delay_us(delayTime);
        CLK_PORT &= ~CLK_PIN;
    2f5c:	20 91 02 01 	lds	r18, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    2f60:	27 7f       	andi	r18, 0xF7	; 247
    2f62:	20 93 02 01 	sts	0x0102, r18	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    2f66:	f5 e0       	ldi	r31, 0x05	; 5
    2f68:	fa 95       	dec	r31
    2f6a:	f1 f7       	brne	.-4      	; 0x2f68 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x406>
    2f6c:	00 00       	nop
        _delay_us(1);
        
        bool temp = (PINE & (1U << 5));
    2f6e:	2c b1       	in	r18, 0x0c	; 12
        
        result |= (temp << i);
    2f70:	25 fb       	bst	r18, 5
    2f72:	22 27       	eor	r18, r18
    2f74:	20 f9       	bld	r18, 0
    2f76:	2d 83       	std	Y+5, r18	; 0x05
    2f78:	1e 82       	std	Y+6, r1	; 0x06
    2f7a:	ad 81       	ldd	r26, Y+5	; 0x05
    2f7c:	be 81       	ldd	r27, Y+6	; 0x06
    2f7e:	aa 0f       	add	r26, r26
    2f80:	bb 1f       	adc	r27, r27
    2f82:	aa 0f       	add	r26, r26
    2f84:	bb 1f       	adc	r27, r27
    2f86:	4a 2a       	or	r4, r26
    2f88:	2a e2       	ldi	r18, 0x2A	; 42
    2f8a:	2a 95       	dec	r18
    2f8c:	f1 f7       	brne	.-4      	; 0x2f8a <_ZN11TouchDriver14getCoordinatesEPhS0_+0x428>
    2f8e:	00 c0       	rjmp	.+0      	; 0x2f90 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x42e>
    // Systematically read DOUT
    for (int i = 7; i >= 0; i--)
    {
        _delay_us(delayTime);
        
        CLK_PORT |= CLK_PIN;
    2f90:	20 91 02 01 	lds	r18, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    2f94:	28 60       	ori	r18, 0x08	; 8
    2f96:	20 93 02 01 	sts	0x0102, r18	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    2f9a:	3a e2       	ldi	r19, 0x2A	; 42
    2f9c:	3a 95       	dec	r19
    2f9e:	f1 f7       	brne	.-4      	; 0x2f9c <_ZN11TouchDriver14getCoordinatesEPhS0_+0x43a>
    2fa0:	00 c0       	rjmp	.+0      	; 0x2fa2 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x440>
        _delay_us(delayTime);
        CLK_PORT &= ~CLK_PIN;
    2fa2:	20 91 02 01 	lds	r18, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    2fa6:	27 7f       	andi	r18, 0xF7	; 247
    2fa8:	20 93 02 01 	sts	0x0102, r18	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    2fac:	e5 e0       	ldi	r30, 0x05	; 5
    2fae:	ea 95       	dec	r30
    2fb0:	f1 f7       	brne	.-4      	; 0x2fae <_ZN11TouchDriver14getCoordinatesEPhS0_+0x44c>
    2fb2:	00 00       	nop
        _delay_us(1);
        
        bool temp = (PINE & (1U << 5));
    2fb4:	2c b1       	in	r18, 0x0c	; 12
        
        result |= (temp << i);
    2fb6:	25 fb       	bst	r18, 5
    2fb8:	22 27       	eor	r18, r18
    2fba:	20 f9       	bld	r18, 0
    2fbc:	2f 83       	std	Y+7, r18	; 0x07
    2fbe:	18 86       	std	Y+8, r1	; 0x08
    2fc0:	2f 81       	ldd	r18, Y+7	; 0x07
    2fc2:	38 85       	ldd	r19, Y+8	; 0x08
    2fc4:	22 0f       	add	r18, r18
    2fc6:	33 1f       	adc	r19, r19
    2fc8:	3a 83       	std	Y+2, r19	; 0x02
    2fca:	29 83       	std	Y+1, r18	; 0x01
    2fcc:	24 29       	or	r18, r4
    2fce:	29 83       	std	Y+1, r18	; 0x01
    2fd0:	3a e2       	ldi	r19, 0x2A	; 42
    2fd2:	3a 95       	dec	r19
    2fd4:	f1 f7       	brne	.-4      	; 0x2fd2 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x470>
    2fd6:	00 c0       	rjmp	.+0      	; 0x2fd8 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x476>
    // Systematically read DOUT
    for (int i = 7; i >= 0; i--)
    {
        _delay_us(delayTime);
        
        CLK_PORT |= CLK_PIN;
    2fd8:	20 91 02 01 	lds	r18, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    2fdc:	28 60       	ori	r18, 0x08	; 8
    2fde:	20 93 02 01 	sts	0x0102, r18	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    2fe2:	ea e2       	ldi	r30, 0x2A	; 42
    2fe4:	ea 95       	dec	r30
    2fe6:	f1 f7       	brne	.-4      	; 0x2fe4 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x482>
    2fe8:	00 c0       	rjmp	.+0      	; 0x2fea <_ZN11TouchDriver14getCoordinatesEPhS0_+0x488>
        _delay_us(delayTime);
        CLK_PORT &= ~CLK_PIN;
    2fea:	20 91 02 01 	lds	r18, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    2fee:	27 7f       	andi	r18, 0xF7	; 247
    2ff0:	20 93 02 01 	sts	0x0102, r18	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    2ff4:	f5 e0       	ldi	r31, 0x05	; 5
    2ff6:	fa 95       	dec	r31
    2ff8:	f1 f7       	brne	.-4      	; 0x2ff6 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x494>
    2ffa:	00 00       	nop
        _delay_us(1);
        
        bool temp = (PINE & (1U << 5));
    2ffc:	4c b0       	in	r4, 0x0c	; 12
    2ffe:	2a e2       	ldi	r18, 0x2A	; 42
    3000:	2a 95       	dec	r18
    3002:	f1 f7       	brne	.-4      	; 0x3000 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x49e>
    3004:	00 c0       	rjmp	.+0      	; 0x3006 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x4a4>
    
    for (int i = 7; i >= 0; i--)
    {
        
        _delay_us(delayTime);
        CLK_PORT |= CLK_PIN;
    3006:	20 91 02 01 	lds	r18, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    300a:	28 60       	ori	r18, 0x08	; 8
    300c:	20 93 02 01 	sts	0x0102, r18	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    3010:	3a e2       	ldi	r19, 0x2A	; 42
    3012:	3a 95       	dec	r19
    3014:	f1 f7       	brne	.-4      	; 0x3012 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x4b0>
    3016:	00 c0       	rjmp	.+0      	; 0x3018 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x4b6>
        _delay_us(delayTime);
        CLK_PORT &= ~CLK_PIN;
    3018:	20 91 02 01 	lds	r18, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    301c:	27 7f       	andi	r18, 0xF7	; 247
    301e:	20 93 02 01 	sts	0x0102, r18	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    3022:	ea e2       	ldi	r30, 0x2A	; 42
    3024:	ea 95       	dec	r30
    3026:	f1 f7       	brne	.-4      	; 0x3024 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x4c2>
    3028:	00 c0       	rjmp	.+0      	; 0x302a <_ZN11TouchDriver14getCoordinatesEPhS0_+0x4c8>
    
    for (int i = 7; i >= 0; i--)
    {
        
        _delay_us(delayTime);
        CLK_PORT |= CLK_PIN;
    302a:	20 91 02 01 	lds	r18, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    302e:	28 60       	ori	r18, 0x08	; 8
    3030:	20 93 02 01 	sts	0x0102, r18	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    3034:	fa e2       	ldi	r31, 0x2A	; 42
    3036:	fa 95       	dec	r31
    3038:	f1 f7       	brne	.-4      	; 0x3036 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x4d4>
    303a:	00 c0       	rjmp	.+0      	; 0x303c <_ZN11TouchDriver14getCoordinatesEPhS0_+0x4da>
        _delay_us(delayTime);
        CLK_PORT &= ~CLK_PIN;
    303c:	20 91 02 01 	lds	r18, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    3040:	27 7f       	andi	r18, 0xF7	; 247
    3042:	20 93 02 01 	sts	0x0102, r18	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    3046:	2a e2       	ldi	r18, 0x2A	; 42
    3048:	2a 95       	dec	r18
    304a:	f1 f7       	brne	.-4      	; 0x3048 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x4e6>
    304c:	00 c0       	rjmp	.+0      	; 0x304e <_ZN11TouchDriver14getCoordinatesEPhS0_+0x4ec>
    
    for (int i = 7; i >= 0; i--)
    {
        
        _delay_us(delayTime);
        CLK_PORT |= CLK_PIN;
    304e:	20 91 02 01 	lds	r18, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    3052:	28 60       	ori	r18, 0x08	; 8
    3054:	20 93 02 01 	sts	0x0102, r18	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    3058:	3a e2       	ldi	r19, 0x2A	; 42
    305a:	3a 95       	dec	r19
    305c:	f1 f7       	brne	.-4      	; 0x305a <_ZN11TouchDriver14getCoordinatesEPhS0_+0x4f8>
    305e:	00 c0       	rjmp	.+0      	; 0x3060 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x4fe>
        _delay_us(delayTime);
        CLK_PORT &= ~CLK_PIN;
    3060:	20 91 02 01 	lds	r18, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    3064:	27 7f       	andi	r18, 0xF7	; 247
    3066:	20 93 02 01 	sts	0x0102, r18	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    306a:	ea e2       	ldi	r30, 0x2A	; 42
    306c:	ea 95       	dec	r30
    306e:	f1 f7       	brne	.-4      	; 0x306c <_ZN11TouchDriver14getCoordinatesEPhS0_+0x50a>
    3070:	00 c0       	rjmp	.+0      	; 0x3072 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x510>
    
    for (int i = 7; i >= 0; i--)
    {
        
        _delay_us(delayTime);
        CLK_PORT |= CLK_PIN;
    3072:	20 91 02 01 	lds	r18, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    3076:	28 60       	ori	r18, 0x08	; 8
    3078:	20 93 02 01 	sts	0x0102, r18	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    307c:	fa e2       	ldi	r31, 0x2A	; 42
    307e:	fa 95       	dec	r31
    3080:	f1 f7       	brne	.-4      	; 0x307e <_ZN11TouchDriver14getCoordinatesEPhS0_+0x51c>
    3082:	00 c0       	rjmp	.+0      	; 0x3084 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x522>
        _delay_us(delayTime);
        CLK_PORT &= ~CLK_PIN;
    3084:	20 91 02 01 	lds	r18, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    3088:	27 7f       	andi	r18, 0xF7	; 247
    308a:	20 93 02 01 	sts	0x0102, r18	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    308e:	2a e2       	ldi	r18, 0x2A	; 42
    3090:	2a 95       	dec	r18
    3092:	f1 f7       	brne	.-4      	; 0x3090 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x52e>
    3094:	00 c0       	rjmp	.+0      	; 0x3096 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x534>
    
    for (int i = 7; i >= 0; i--)
    {
        
        _delay_us(delayTime);
        CLK_PORT |= CLK_PIN;
    3096:	20 91 02 01 	lds	r18, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    309a:	28 60       	ori	r18, 0x08	; 8
    309c:	20 93 02 01 	sts	0x0102, r18	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    30a0:	3a e2       	ldi	r19, 0x2A	; 42
    30a2:	3a 95       	dec	r19
    30a4:	f1 f7       	brne	.-4      	; 0x30a2 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x540>
    30a6:	00 c0       	rjmp	.+0      	; 0x30a8 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x546>
        _delay_us(delayTime);
        CLK_PORT &= ~CLK_PIN;
    30a8:	20 91 02 01 	lds	r18, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    30ac:	27 7f       	andi	r18, 0xF7	; 247
    30ae:	20 93 02 01 	sts	0x0102, r18	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    30b2:	ea e2       	ldi	r30, 0x2A	; 42
    30b4:	ea 95       	dec	r30
    30b6:	f1 f7       	brne	.-4      	; 0x30b4 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x552>
    30b8:	00 c0       	rjmp	.+0      	; 0x30ba <_ZN11TouchDriver14getCoordinatesEPhS0_+0x558>
    
    for (int i = 7; i >= 0; i--)
    {
        
        _delay_us(delayTime);
        CLK_PORT |= CLK_PIN;
    30ba:	20 91 02 01 	lds	r18, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    30be:	28 60       	ori	r18, 0x08	; 8
    30c0:	20 93 02 01 	sts	0x0102, r18	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    30c4:	fa e2       	ldi	r31, 0x2A	; 42
    30c6:	fa 95       	dec	r31
    30c8:	f1 f7       	brne	.-4      	; 0x30c6 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x564>
    30ca:	00 c0       	rjmp	.+0      	; 0x30cc <_ZN11TouchDriver14getCoordinatesEPhS0_+0x56a>
        _delay_us(delayTime);
        CLK_PORT &= ~CLK_PIN;
    30cc:	20 91 02 01 	lds	r18, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    30d0:	27 7f       	andi	r18, 0xF7	; 247
    30d2:	20 93 02 01 	sts	0x0102, r18	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    30d6:	2a e2       	ldi	r18, 0x2A	; 42
    30d8:	2a 95       	dec	r18
    30da:	f1 f7       	brne	.-4      	; 0x30d8 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x576>
    30dc:	00 c0       	rjmp	.+0      	; 0x30de <_ZN11TouchDriver14getCoordinatesEPhS0_+0x57c>
    
    for (int i = 7; i >= 0; i--)
    {
        
        _delay_us(delayTime);
        CLK_PORT |= CLK_PIN;
    30de:	20 91 02 01 	lds	r18, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    30e2:	28 60       	ori	r18, 0x08	; 8
    30e4:	20 93 02 01 	sts	0x0102, r18	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    30e8:	3a e2       	ldi	r19, 0x2A	; 42
    30ea:	3a 95       	dec	r19
    30ec:	f1 f7       	brne	.-4      	; 0x30ea <_ZN11TouchDriver14getCoordinatesEPhS0_+0x588>
    30ee:	00 c0       	rjmp	.+0      	; 0x30f0 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x58e>
        _delay_us(delayTime);
        CLK_PORT &= ~CLK_PIN;
    30f0:	20 91 02 01 	lds	r18, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    30f4:	27 7f       	andi	r18, 0xF7	; 247
    30f6:	20 93 02 01 	sts	0x0102, r18	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    30fa:	ea e2       	ldi	r30, 0x2A	; 42
    30fc:	ea 95       	dec	r30
    30fe:	f1 f7       	brne	.-4      	; 0x30fc <_ZN11TouchDriver14getCoordinatesEPhS0_+0x59a>
    3100:	00 c0       	rjmp	.+0      	; 0x3102 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x5a0>
    
    for (int i = 7; i >= 0; i--)
    {
        
        _delay_us(delayTime);
        CLK_PORT |= CLK_PIN;
    3102:	20 91 02 01 	lds	r18, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    3106:	28 60       	ori	r18, 0x08	; 8
    3108:	20 93 02 01 	sts	0x0102, r18	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    310c:	fa e2       	ldi	r31, 0x2A	; 42
    310e:	fa 95       	dec	r31
    3110:	f1 f7       	brne	.-4      	; 0x310e <_ZN11TouchDriver14getCoordinatesEPhS0_+0x5ac>
    3112:	00 c0       	rjmp	.+0      	; 0x3114 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x5b2>
        _delay_us(delayTime);
        CLK_PORT &= ~CLK_PIN;
    3114:	20 91 02 01 	lds	r18, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    3118:	27 7f       	andi	r18, 0xF7	; 247
    311a:	20 93 02 01 	sts	0x0102, r18	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    }
    
    CS_PORT |= CS_PIN;
    311e:	73 9a       	sbi	0x0e, 3	; 14
		if (timeout > 255)
		{
			return;
		}
	}
	*x_ptr = readTouch('X');
    3120:	45 fa       	bst	r4, 5
    3122:	44 24       	eor	r4, r4
    3124:	40 f8       	bld	r4, 0
    3126:	29 81       	ldd	r18, Y+1	; 0x01
    3128:	42 2a       	or	r4, r18
    312a:	40 94       	com	r4
    312c:	fb 01       	movw	r30, r22
    312e:	40 82       	st	Z, r4
    {
        dinByte = dinXByte;
        
    }else if (coord == 'Y')
    {
        dinByte = dinYByte;
    3130:	fc 01       	movw	r30, r24
    3132:	61 81       	ldd	r22, Z+1	; 0x01
    else{
        return 255;
    }
    
    // ChipSelect Set to 0    
    CS_PORT &= ~CS_PIN;
    3134:	73 98       	cbi	0x0e, 3	; 14
    3136:	fa e2       	ldi	r31, 0x2A	; 42
    3138:	fa 95       	dec	r31
    313a:	f1 f7       	brne	.-4      	; 0x3138 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x5d6>
    313c:	00 c0       	rjmp	.+0      	; 0x313e <_ZN11TouchDriver14getCoordinatesEPhS0_+0x5dc>
    313e:	86 2f       	mov	r24, r22
    3140:	90 e0       	ldi	r25, 0x00	; 0
    3142:	2a e2       	ldi	r18, 0x2A	; 42
    3144:	2a 95       	dec	r18
    3146:	f1 f7       	brne	.-4      	; 0x3144 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x5e2>
    3148:	00 c0       	rjmp	.+0      	; 0x314a <_ZN11TouchDriver14getCoordinatesEPhS0_+0x5e8>
    // DIN byte and pulse DCLK for Read X
    for (int i = 7; i >= 0; i--)
    {
        _delay_us(delayTime);
        
        DIN_PORT |= (((dinByte >> i)  & 0x01) << 5);
    314a:	74 b3       	in	r23, 0x14	; 20
    314c:	9c 01       	movw	r18, r24
    314e:	22 0f       	add	r18, r18
    3150:	23 2f       	mov	r18, r19
    3152:	22 1f       	adc	r18, r18
    3154:	33 0b       	sbc	r19, r19
    3156:	22 0f       	add	r18, r18
    3158:	33 1f       	adc	r19, r19
    315a:	22 95       	swap	r18
    315c:	32 95       	swap	r19
    315e:	30 7f       	andi	r19, 0xF0	; 240
    3160:	32 27       	eor	r19, r18
    3162:	20 7f       	andi	r18, 0xF0	; 240
    3164:	32 27       	eor	r19, r18
    3166:	27 2b       	or	r18, r23
    3168:	24 bb       	out	0x14, r18	; 20
        
        CLK_PORT |= CLK_PIN;
    316a:	90 91 02 01 	lds	r25, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    316e:	98 60       	ori	r25, 0x08	; 8
    3170:	90 93 02 01 	sts	0x0102, r25	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    3174:	3a e2       	ldi	r19, 0x2A	; 42
    3176:	3a 95       	dec	r19
    3178:	f1 f7       	brne	.-4      	; 0x3176 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x614>
    317a:	00 c0       	rjmp	.+0      	; 0x317c <_ZN11TouchDriver14getCoordinatesEPhS0_+0x61a>
		
        _delay_us(delayTime);
        
        CLK_PORT &= ~CLK_PIN;
    317c:	90 91 02 01 	lds	r25, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    3180:	97 7f       	andi	r25, 0xF7	; 247
    3182:	90 93 02 01 	sts	0x0102, r25	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
        DIN_PORT &= ~BIT6_SHIFTED;
    3186:	a5 98       	cbi	0x14, 5	; 20
    3188:	ea e2       	ldi	r30, 0x2A	; 42
    318a:	ea 95       	dec	r30
    318c:	f1 f7       	brne	.-4      	; 0x318a <_ZN11TouchDriver14getCoordinatesEPhS0_+0x628>
    318e:	00 c0       	rjmp	.+0      	; 0x3190 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x62e>
    // DIN byte and pulse DCLK for Read X
    for (int i = 7; i >= 0; i--)
    {
        _delay_us(delayTime);
        
        DIN_PORT |= (((dinByte >> i)  & 0x01) << 5);
    3190:	94 b3       	in	r25, 0x14	; 20
    3192:	66 fb       	bst	r22, 6
    3194:	ff 27       	eor	r31, r31
    3196:	f0 f9       	bld	r31, 0
    3198:	f9 87       	std	Y+9, r31	; 0x09
    319a:	1a 86       	std	Y+10, r1	; 0x0a
    319c:	29 85       	ldd	r18, Y+9	; 0x09
    319e:	3a 85       	ldd	r19, Y+10	; 0x0a
    31a0:	22 0f       	add	r18, r18
    31a2:	33 1f       	adc	r19, r19
    31a4:	22 95       	swap	r18
    31a6:	32 95       	swap	r19
    31a8:	30 7f       	andi	r19, 0xF0	; 240
    31aa:	32 27       	eor	r19, r18
    31ac:	20 7f       	andi	r18, 0xF0	; 240
    31ae:	32 27       	eor	r19, r18
    31b0:	29 2b       	or	r18, r25
    31b2:	24 bb       	out	0x14, r18	; 20
        
        CLK_PORT |= CLK_PIN;
    31b4:	90 91 02 01 	lds	r25, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    31b8:	98 60       	ori	r25, 0x08	; 8
    31ba:	90 93 02 01 	sts	0x0102, r25	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    31be:	2a e2       	ldi	r18, 0x2A	; 42
    31c0:	2a 95       	dec	r18
    31c2:	f1 f7       	brne	.-4      	; 0x31c0 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x65e>
    31c4:	00 c0       	rjmp	.+0      	; 0x31c6 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x664>
		
        _delay_us(delayTime);
        
        CLK_PORT &= ~CLK_PIN;
    31c6:	90 91 02 01 	lds	r25, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    31ca:	97 7f       	andi	r25, 0xF7	; 247
    31cc:	90 93 02 01 	sts	0x0102, r25	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
        DIN_PORT &= ~BIT6_SHIFTED;
    31d0:	a5 98       	cbi	0x14, 5	; 20
    31d2:	3a e2       	ldi	r19, 0x2A	; 42
    31d4:	3a 95       	dec	r19
    31d6:	f1 f7       	brne	.-4      	; 0x31d4 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x672>
    31d8:	00 c0       	rjmp	.+0      	; 0x31da <_ZN11TouchDriver14getCoordinatesEPhS0_+0x678>
    // DIN byte and pulse DCLK for Read X
    for (int i = 7; i >= 0; i--)
    {
        _delay_us(delayTime);
        
        DIN_PORT |= (((dinByte >> i)  & 0x01) << 5);
    31da:	94 b3       	in	r25, 0x14	; 20
    31dc:	65 fb       	bst	r22, 5
    31de:	ee 27       	eor	r30, r30
    31e0:	e0 f9       	bld	r30, 0
    31e2:	eb 87       	std	Y+11, r30	; 0x0b
    31e4:	1c 86       	std	Y+12, r1	; 0x0c
    31e6:	2b 85       	ldd	r18, Y+11	; 0x0b
    31e8:	3c 85       	ldd	r19, Y+12	; 0x0c
    31ea:	22 0f       	add	r18, r18
    31ec:	33 1f       	adc	r19, r19
    31ee:	22 95       	swap	r18
    31f0:	32 95       	swap	r19
    31f2:	30 7f       	andi	r19, 0xF0	; 240
    31f4:	32 27       	eor	r19, r18
    31f6:	20 7f       	andi	r18, 0xF0	; 240
    31f8:	32 27       	eor	r19, r18
    31fa:	29 2b       	or	r18, r25
    31fc:	24 bb       	out	0x14, r18	; 20
        
        CLK_PORT |= CLK_PIN;
    31fe:	90 91 02 01 	lds	r25, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    3202:	98 60       	ori	r25, 0x08	; 8
    3204:	90 93 02 01 	sts	0x0102, r25	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    3208:	fa e2       	ldi	r31, 0x2A	; 42
    320a:	fa 95       	dec	r31
    320c:	f1 f7       	brne	.-4      	; 0x320a <_ZN11TouchDriver14getCoordinatesEPhS0_+0x6a8>
    320e:	00 c0       	rjmp	.+0      	; 0x3210 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x6ae>
		
        _delay_us(delayTime);
        
        CLK_PORT &= ~CLK_PIN;
    3210:	90 91 02 01 	lds	r25, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    3214:	97 7f       	andi	r25, 0xF7	; 247
    3216:	90 93 02 01 	sts	0x0102, r25	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
        DIN_PORT &= ~BIT6_SHIFTED;
    321a:	a5 98       	cbi	0x14, 5	; 20
    321c:	2a e2       	ldi	r18, 0x2A	; 42
    321e:	2a 95       	dec	r18
    3220:	f1 f7       	brne	.-4      	; 0x321e <_ZN11TouchDriver14getCoordinatesEPhS0_+0x6bc>
    3222:	00 c0       	rjmp	.+0      	; 0x3224 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x6c2>
    // DIN byte and pulse DCLK for Read X
    for (int i = 7; i >= 0; i--)
    {
        _delay_us(delayTime);
        
        DIN_PORT |= (((dinByte >> i)  & 0x01) << 5);
    3224:	94 b3       	in	r25, 0x14	; 20
    3226:	64 fb       	bst	r22, 4
    3228:	33 27       	eor	r19, r19
    322a:	30 f9       	bld	r19, 0
    322c:	3d 87       	std	Y+13, r19	; 0x0d
    322e:	1e 86       	std	Y+14, r1	; 0x0e
    3230:	2d 85       	ldd	r18, Y+13	; 0x0d
    3232:	3e 85       	ldd	r19, Y+14	; 0x0e
    3234:	22 0f       	add	r18, r18
    3236:	33 1f       	adc	r19, r19
    3238:	22 95       	swap	r18
    323a:	32 95       	swap	r19
    323c:	30 7f       	andi	r19, 0xF0	; 240
    323e:	32 27       	eor	r19, r18
    3240:	20 7f       	andi	r18, 0xF0	; 240
    3242:	32 27       	eor	r19, r18
    3244:	29 2b       	or	r18, r25
    3246:	24 bb       	out	0x14, r18	; 20
        
        CLK_PORT |= CLK_PIN;
    3248:	90 91 02 01 	lds	r25, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    324c:	98 60       	ori	r25, 0x08	; 8
    324e:	90 93 02 01 	sts	0x0102, r25	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    3252:	ea e2       	ldi	r30, 0x2A	; 42
    3254:	ea 95       	dec	r30
    3256:	f1 f7       	brne	.-4      	; 0x3254 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x6f2>
    3258:	00 c0       	rjmp	.+0      	; 0x325a <_ZN11TouchDriver14getCoordinatesEPhS0_+0x6f8>
		
        _delay_us(delayTime);
        
        CLK_PORT &= ~CLK_PIN;
    325a:	90 91 02 01 	lds	r25, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    325e:	97 7f       	andi	r25, 0xF7	; 247
    3260:	90 93 02 01 	sts	0x0102, r25	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
        DIN_PORT &= ~BIT6_SHIFTED;
    3264:	a5 98       	cbi	0x14, 5	; 20
    3266:	fa e2       	ldi	r31, 0x2A	; 42
    3268:	fa 95       	dec	r31
    326a:	f1 f7       	brne	.-4      	; 0x3268 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x706>
    326c:	00 c0       	rjmp	.+0      	; 0x326e <_ZN11TouchDriver14getCoordinatesEPhS0_+0x70c>
    // DIN byte and pulse DCLK for Read X
    for (int i = 7; i >= 0; i--)
    {
        _delay_us(delayTime);
        
        DIN_PORT |= (((dinByte >> i)  & 0x01) << 5);
    326e:	94 b3       	in	r25, 0x14	; 20
    3270:	63 fb       	bst	r22, 3
    3272:	22 27       	eor	r18, r18
    3274:	20 f9       	bld	r18, 0
    3276:	2f 87       	std	Y+15, r18	; 0x0f
    3278:	18 8a       	std	Y+16, r1	; 0x10
    327a:	2f 85       	ldd	r18, Y+15	; 0x0f
    327c:	38 89       	ldd	r19, Y+16	; 0x10
    327e:	22 0f       	add	r18, r18
    3280:	33 1f       	adc	r19, r19
    3282:	22 95       	swap	r18
    3284:	32 95       	swap	r19
    3286:	30 7f       	andi	r19, 0xF0	; 240
    3288:	32 27       	eor	r19, r18
    328a:	20 7f       	andi	r18, 0xF0	; 240
    328c:	32 27       	eor	r19, r18
    328e:	29 2b       	or	r18, r25
    3290:	24 bb       	out	0x14, r18	; 20
        
        CLK_PORT |= CLK_PIN;
    3292:	90 91 02 01 	lds	r25, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    3296:	98 60       	ori	r25, 0x08	; 8
    3298:	90 93 02 01 	sts	0x0102, r25	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    329c:	3a e2       	ldi	r19, 0x2A	; 42
    329e:	3a 95       	dec	r19
    32a0:	f1 f7       	brne	.-4      	; 0x329e <_ZN11TouchDriver14getCoordinatesEPhS0_+0x73c>
    32a2:	00 c0       	rjmp	.+0      	; 0x32a4 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x742>
		
        _delay_us(delayTime);
        
        CLK_PORT &= ~CLK_PIN;
    32a4:	90 91 02 01 	lds	r25, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    32a8:	97 7f       	andi	r25, 0xF7	; 247
    32aa:	90 93 02 01 	sts	0x0102, r25	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
        DIN_PORT &= ~BIT6_SHIFTED;
    32ae:	a5 98       	cbi	0x14, 5	; 20
    32b0:	ea e2       	ldi	r30, 0x2A	; 42
    32b2:	ea 95       	dec	r30
    32b4:	f1 f7       	brne	.-4      	; 0x32b2 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x750>
    32b6:	00 c0       	rjmp	.+0      	; 0x32b8 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x756>
    // DIN byte and pulse DCLK for Read X
    for (int i = 7; i >= 0; i--)
    {
        _delay_us(delayTime);
        
        DIN_PORT |= (((dinByte >> i)  & 0x01) << 5);
    32b8:	94 b3       	in	r25, 0x14	; 20
    32ba:	62 fb       	bst	r22, 2
    32bc:	ff 27       	eor	r31, r31
    32be:	f0 f9       	bld	r31, 0
    32c0:	f9 8b       	std	Y+17, r31	; 0x11
    32c2:	1a 8a       	std	Y+18, r1	; 0x12
    32c4:	29 89       	ldd	r18, Y+17	; 0x11
    32c6:	3a 89       	ldd	r19, Y+18	; 0x12
    32c8:	22 0f       	add	r18, r18
    32ca:	33 1f       	adc	r19, r19
    32cc:	22 95       	swap	r18
    32ce:	32 95       	swap	r19
    32d0:	30 7f       	andi	r19, 0xF0	; 240
    32d2:	32 27       	eor	r19, r18
    32d4:	20 7f       	andi	r18, 0xF0	; 240
    32d6:	32 27       	eor	r19, r18
    32d8:	29 2b       	or	r18, r25
    32da:	24 bb       	out	0x14, r18	; 20
        
        CLK_PORT |= CLK_PIN;
    32dc:	90 91 02 01 	lds	r25, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    32e0:	98 60       	ori	r25, 0x08	; 8
    32e2:	90 93 02 01 	sts	0x0102, r25	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    32e6:	2a e2       	ldi	r18, 0x2A	; 42
    32e8:	2a 95       	dec	r18
    32ea:	f1 f7       	brne	.-4      	; 0x32e8 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x786>
    32ec:	00 c0       	rjmp	.+0      	; 0x32ee <_ZN11TouchDriver14getCoordinatesEPhS0_+0x78c>
		
        _delay_us(delayTime);
        
        CLK_PORT &= ~CLK_PIN;
    32ee:	90 91 02 01 	lds	r25, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    32f2:	97 7f       	andi	r25, 0xF7	; 247
    32f4:	90 93 02 01 	sts	0x0102, r25	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
        DIN_PORT &= ~BIT6_SHIFTED;
    32f8:	a5 98       	cbi	0x14, 5	; 20
    32fa:	3a e2       	ldi	r19, 0x2A	; 42
    32fc:	3a 95       	dec	r19
    32fe:	f1 f7       	brne	.-4      	; 0x32fc <_ZN11TouchDriver14getCoordinatesEPhS0_+0x79a>
    3300:	00 c0       	rjmp	.+0      	; 0x3302 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x7a0>
    // DIN byte and pulse DCLK for Read X
    for (int i = 7; i >= 0; i--)
    {
        _delay_us(delayTime);
        
        DIN_PORT |= (((dinByte >> i)  & 0x01) << 5);
    3302:	24 b3       	in	r18, 0x14	; 20
    3304:	61 fb       	bst	r22, 1
    3306:	ee 27       	eor	r30, r30
    3308:	e0 f9       	bld	r30, 0
    330a:	eb 8b       	std	Y+19, r30	; 0x13
    330c:	1c 8a       	std	Y+20, r1	; 0x14
    330e:	8b 89       	ldd	r24, Y+19	; 0x13
    3310:	9c 89       	ldd	r25, Y+20	; 0x14
    3312:	88 0f       	add	r24, r24
    3314:	99 1f       	adc	r25, r25
    3316:	82 95       	swap	r24
    3318:	92 95       	swap	r25
    331a:	90 7f       	andi	r25, 0xF0	; 240
    331c:	98 27       	eor	r25, r24
    331e:	80 7f       	andi	r24, 0xF0	; 240
    3320:	98 27       	eor	r25, r24
    3322:	82 2b       	or	r24, r18
    3324:	84 bb       	out	0x14, r24	; 20
        
        CLK_PORT |= CLK_PIN;
    3326:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    332a:	88 60       	ori	r24, 0x08	; 8
    332c:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    3330:	fa e2       	ldi	r31, 0x2A	; 42
    3332:	fa 95       	dec	r31
    3334:	f1 f7       	brne	.-4      	; 0x3332 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x7d0>
    3336:	00 c0       	rjmp	.+0      	; 0x3338 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x7d6>
		
        _delay_us(delayTime);
        
        CLK_PORT &= ~CLK_PIN;
    3338:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    333c:	87 7f       	andi	r24, 0xF7	; 247
    333e:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
        DIN_PORT &= ~BIT6_SHIFTED;
    3342:	a5 98       	cbi	0x14, 5	; 20
    3344:	2a e2       	ldi	r18, 0x2A	; 42
    3346:	2a 95       	dec	r18
    3348:	f1 f7       	brne	.-4      	; 0x3346 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x7e4>
    334a:	00 c0       	rjmp	.+0      	; 0x334c <_ZN11TouchDriver14getCoordinatesEPhS0_+0x7ea>
    // DIN byte and pulse DCLK for Read X
    for (int i = 7; i >= 0; i--)
    {
        _delay_us(delayTime);
        
        DIN_PORT |= (((dinByte >> i)  & 0x01) << 5);
    334c:	24 b3       	in	r18, 0x14	; 20
    334e:	61 70       	andi	r22, 0x01	; 1
    3350:	6d 8b       	std	Y+21, r22	; 0x15
    3352:	1e 8a       	std	Y+22, r1	; 0x16
    3354:	8d 89       	ldd	r24, Y+21	; 0x15
    3356:	9e 89       	ldd	r25, Y+22	; 0x16
    3358:	88 0f       	add	r24, r24
    335a:	99 1f       	adc	r25, r25
    335c:	82 95       	swap	r24
    335e:	92 95       	swap	r25
    3360:	90 7f       	andi	r25, 0xF0	; 240
    3362:	98 27       	eor	r25, r24
    3364:	80 7f       	andi	r24, 0xF0	; 240
    3366:	98 27       	eor	r25, r24
    3368:	82 2b       	or	r24, r18
    336a:	84 bb       	out	0x14, r24	; 20
        
        CLK_PORT |= CLK_PIN;
    336c:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    3370:	88 60       	ori	r24, 0x08	; 8
    3372:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    3376:	3a e2       	ldi	r19, 0x2A	; 42
    3378:	3a 95       	dec	r19
    337a:	f1 f7       	brne	.-4      	; 0x3378 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x816>
    337c:	00 c0       	rjmp	.+0      	; 0x337e <_ZN11TouchDriver14getCoordinatesEPhS0_+0x81c>
		
        _delay_us(delayTime);
        
        CLK_PORT &= ~CLK_PIN;
    337e:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    3382:	87 7f       	andi	r24, 0xF7	; 247
    3384:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
        DIN_PORT &= ~BIT6_SHIFTED;
    3388:	a5 98       	cbi	0x14, 5	; 20
    338a:	8a e2       	ldi	r24, 0x2A	; 42
    338c:	8a 95       	dec	r24
    338e:	f1 f7       	brne	.-4      	; 0x338c <_ZN11TouchDriver14getCoordinatesEPhS0_+0x82a>
    3390:	00 c0       	rjmp	.+0      	; 0x3392 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x830>
    // Systematically read DOUT
    for (int i = 7; i >= 0; i--)
    {
        _delay_us(delayTime);
        
        CLK_PORT |= CLK_PIN;
    3392:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    3396:	88 60       	ori	r24, 0x08	; 8
    3398:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    339c:	9a e2       	ldi	r25, 0x2A	; 42
    339e:	9a 95       	dec	r25
    33a0:	f1 f7       	brne	.-4      	; 0x339e <_ZN11TouchDriver14getCoordinatesEPhS0_+0x83c>
    33a2:	00 c0       	rjmp	.+0      	; 0x33a4 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x842>
        _delay_us(delayTime);
        CLK_PORT &= ~CLK_PIN;
    33a4:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    33a8:	87 7f       	andi	r24, 0xF7	; 247
    33aa:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    33ae:	e5 e0       	ldi	r30, 0x05	; 5
    33b0:	ea 95       	dec	r30
    33b2:	f1 f7       	brne	.-4      	; 0x33b0 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x84e>
    33b4:	00 00       	nop
        _delay_us(1);
        
        bool temp = (PINE & (1U << 5));
    33b6:	9c b1       	in	r25, 0x0c	; 12
    33b8:	fa e2       	ldi	r31, 0x2A	; 42
    33ba:	fa 95       	dec	r31
    33bc:	f1 f7       	brne	.-4      	; 0x33ba <_ZN11TouchDriver14getCoordinatesEPhS0_+0x858>
    33be:	00 c0       	rjmp	.+0      	; 0x33c0 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x85e>
    // Systematically read DOUT
    for (int i = 7; i >= 0; i--)
    {
        _delay_us(delayTime);
        
        CLK_PORT |= CLK_PIN;
    33c0:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    33c4:	88 60       	ori	r24, 0x08	; 8
    33c6:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    33ca:	2a e2       	ldi	r18, 0x2A	; 42
    33cc:	2a 95       	dec	r18
    33ce:	f1 f7       	brne	.-4      	; 0x33cc <_ZN11TouchDriver14getCoordinatesEPhS0_+0x86a>
    33d0:	00 c0       	rjmp	.+0      	; 0x33d2 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x870>
        _delay_us(delayTime);
        CLK_PORT &= ~CLK_PIN;
    33d2:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    33d6:	87 7f       	andi	r24, 0xF7	; 247
    33d8:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    33dc:	35 e0       	ldi	r19, 0x05	; 5
    33de:	3a 95       	dec	r19
    33e0:	f1 f7       	brne	.-4      	; 0x33de <_ZN11TouchDriver14getCoordinatesEPhS0_+0x87c>
    33e2:	00 00       	nop
        _delay_us(1);
        
        bool temp = (PINE & (1U << 5));
    33e4:	8c b1       	in	r24, 0x0c	; 12
        
        result |= (temp << i);
    33e6:	85 fb       	bst	r24, 5
    33e8:	88 27       	eor	r24, r24
    33ea:	80 f9       	bld	r24, 0
    33ec:	8f 8b       	std	Y+23, r24	; 0x17
    33ee:	18 8e       	std	Y+24, r1	; 0x18
    33f0:	2f 89       	ldd	r18, Y+23	; 0x17
    33f2:	38 8d       	ldd	r19, Y+24	; 0x18
    33f4:	00 24       	eor	r0, r0
    33f6:	36 95       	lsr	r19
    33f8:	27 95       	ror	r18
    33fa:	07 94       	ror	r0
    33fc:	36 95       	lsr	r19
    33fe:	27 95       	ror	r18
    3400:	07 94       	ror	r0
    3402:	32 2f       	mov	r19, r18
    3404:	20 2d       	mov	r18, r0
    3406:	95 fb       	bst	r25, 5
    3408:	99 27       	eor	r25, r25
    340a:	90 f9       	bld	r25, 0
    340c:	99 8f       	std	Y+25, r25	; 0x19
    340e:	1a 8e       	std	Y+26, r1	; 0x1a
    3410:	89 8d       	ldd	r24, Y+25	; 0x19
    3412:	9a 8d       	ldd	r25, Y+26	; 0x1a
    3414:	96 95       	lsr	r25
    3416:	98 2f       	mov	r25, r24
    3418:	88 27       	eor	r24, r24
    341a:	97 95       	ror	r25
    341c:	87 95       	ror	r24
    341e:	82 2b       	or	r24, r18
    3420:	9a e2       	ldi	r25, 0x2A	; 42
    3422:	9a 95       	dec	r25
    3424:	f1 f7       	brne	.-4      	; 0x3422 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x8c0>
    3426:	00 c0       	rjmp	.+0      	; 0x3428 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x8c6>
    // Systematically read DOUT
    for (int i = 7; i >= 0; i--)
    {
        _delay_us(delayTime);
        
        CLK_PORT |= CLK_PIN;
    3428:	90 91 02 01 	lds	r25, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    342c:	98 60       	ori	r25, 0x08	; 8
    342e:	90 93 02 01 	sts	0x0102, r25	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    3432:	ea e2       	ldi	r30, 0x2A	; 42
    3434:	ea 95       	dec	r30
    3436:	f1 f7       	brne	.-4      	; 0x3434 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x8d2>
    3438:	00 c0       	rjmp	.+0      	; 0x343a <_ZN11TouchDriver14getCoordinatesEPhS0_+0x8d8>
        _delay_us(delayTime);
        CLK_PORT &= ~CLK_PIN;
    343a:	90 91 02 01 	lds	r25, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    343e:	97 7f       	andi	r25, 0xF7	; 247
    3440:	90 93 02 01 	sts	0x0102, r25	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    3444:	f5 e0       	ldi	r31, 0x05	; 5
    3446:	fa 95       	dec	r31
    3448:	f1 f7       	brne	.-4      	; 0x3446 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x8e4>
    344a:	00 00       	nop
        _delay_us(1);
        
        bool temp = (PINE & (1U << 5));
    344c:	9c b1       	in	r25, 0x0c	; 12
        
        result |= (temp << i);
    344e:	90 72       	andi	r25, 0x20	; 32
    3450:	89 2b       	or	r24, r25
    3452:	2a e2       	ldi	r18, 0x2A	; 42
    3454:	2a 95       	dec	r18
    3456:	f1 f7       	brne	.-4      	; 0x3454 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x8f2>
    3458:	00 c0       	rjmp	.+0      	; 0x345a <_ZN11TouchDriver14getCoordinatesEPhS0_+0x8f8>
    // Systematically read DOUT
    for (int i = 7; i >= 0; i--)
    {
        _delay_us(delayTime);
        
        CLK_PORT |= CLK_PIN;
    345a:	90 91 02 01 	lds	r25, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    345e:	98 60       	ori	r25, 0x08	; 8
    3460:	90 93 02 01 	sts	0x0102, r25	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    3464:	3a e2       	ldi	r19, 0x2A	; 42
    3466:	3a 95       	dec	r19
    3468:	f1 f7       	brne	.-4      	; 0x3466 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x904>
    346a:	00 c0       	rjmp	.+0      	; 0x346c <_ZN11TouchDriver14getCoordinatesEPhS0_+0x90a>
        _delay_us(delayTime);
        CLK_PORT &= ~CLK_PIN;
    346c:	90 91 02 01 	lds	r25, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    3470:	97 7f       	andi	r25, 0xF7	; 247
    3472:	90 93 02 01 	sts	0x0102, r25	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    3476:	95 e0       	ldi	r25, 0x05	; 5
    3478:	9a 95       	dec	r25
    347a:	f1 f7       	brne	.-4      	; 0x3478 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x916>
    347c:	00 00       	nop
        _delay_us(1);
        
        bool temp = (PINE & (1U << 5));
    347e:	9c b1       	in	r25, 0x0c	; 12
        
        result |= (temp << i);
    3480:	95 fb       	bst	r25, 5
    3482:	99 27       	eor	r25, r25
    3484:	90 f9       	bld	r25, 0
    3486:	9b 8f       	std	Y+27, r25	; 0x1b
    3488:	1c 8e       	std	Y+28, r1	; 0x1c
    348a:	6b 8d       	ldd	r22, Y+27	; 0x1b
    348c:	7c 8d       	ldd	r23, Y+28	; 0x1c
    348e:	62 95       	swap	r22
    3490:	72 95       	swap	r23
    3492:	70 7f       	andi	r23, 0xF0	; 240
    3494:	76 27       	eor	r23, r22
    3496:	60 7f       	andi	r22, 0xF0	; 240
    3498:	76 27       	eor	r23, r22
    349a:	28 2f       	mov	r18, r24
    349c:	26 2b       	or	r18, r22
    349e:	ea e2       	ldi	r30, 0x2A	; 42
    34a0:	ea 95       	dec	r30
    34a2:	f1 f7       	brne	.-4      	; 0x34a0 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x93e>
    34a4:	00 c0       	rjmp	.+0      	; 0x34a6 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x944>
    // Systematically read DOUT
    for (int i = 7; i >= 0; i--)
    {
        _delay_us(delayTime);
        
        CLK_PORT |= CLK_PIN;
    34a6:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    34aa:	88 60       	ori	r24, 0x08	; 8
    34ac:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    34b0:	fa e2       	ldi	r31, 0x2A	; 42
    34b2:	fa 95       	dec	r31
    34b4:	f1 f7       	brne	.-4      	; 0x34b2 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x950>
    34b6:	00 c0       	rjmp	.+0      	; 0x34b8 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x956>
        _delay_us(delayTime);
        CLK_PORT &= ~CLK_PIN;
    34b8:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    34bc:	87 7f       	andi	r24, 0xF7	; 247
    34be:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    34c2:	35 e0       	ldi	r19, 0x05	; 5
    34c4:	3a 95       	dec	r19
    34c6:	f1 f7       	brne	.-4      	; 0x34c4 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x962>
    34c8:	00 00       	nop
        _delay_us(1);
        
        bool temp = (PINE & (1U << 5));
    34ca:	8c b1       	in	r24, 0x0c	; 12
        
        result |= (temp << i);
    34cc:	85 fb       	bst	r24, 5
    34ce:	88 27       	eor	r24, r24
    34d0:	80 f9       	bld	r24, 0
    34d2:	8d 8f       	std	Y+29, r24	; 0x1d
    34d4:	1e 8e       	std	Y+30, r1	; 0x1e
    34d6:	6d 8d       	ldd	r22, Y+29	; 0x1d
    34d8:	7e 8d       	ldd	r23, Y+30	; 0x1e
    34da:	66 0f       	add	r22, r22
    34dc:	77 1f       	adc	r23, r23
    34de:	66 0f       	add	r22, r22
    34e0:	77 1f       	adc	r23, r23
    34e2:	66 0f       	add	r22, r22
    34e4:	77 1f       	adc	r23, r23
    34e6:	62 2b       	or	r22, r18
    34e8:	8a e2       	ldi	r24, 0x2A	; 42
    34ea:	8a 95       	dec	r24
    34ec:	f1 f7       	brne	.-4      	; 0x34ea <_ZN11TouchDriver14getCoordinatesEPhS0_+0x988>
    34ee:	00 c0       	rjmp	.+0      	; 0x34f0 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x98e>
    // Systematically read DOUT
    for (int i = 7; i >= 0; i--)
    {
        _delay_us(delayTime);
        
        CLK_PORT |= CLK_PIN;
    34f0:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    34f4:	88 60       	ori	r24, 0x08	; 8
    34f6:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    34fa:	9a e2       	ldi	r25, 0x2A	; 42
    34fc:	9a 95       	dec	r25
    34fe:	f1 f7       	brne	.-4      	; 0x34fc <_ZN11TouchDriver14getCoordinatesEPhS0_+0x99a>
    3500:	00 c0       	rjmp	.+0      	; 0x3502 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x9a0>
        _delay_us(delayTime);
        CLK_PORT &= ~CLK_PIN;
    3502:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    3506:	87 7f       	andi	r24, 0xF7	; 247
    3508:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    350c:	e5 e0       	ldi	r30, 0x05	; 5
    350e:	ea 95       	dec	r30
    3510:	f1 f7       	brne	.-4      	; 0x350e <_ZN11TouchDriver14getCoordinatesEPhS0_+0x9ac>
    3512:	00 00       	nop
        _delay_us(1);
        
        bool temp = (PINE & (1U << 5));
    3514:	8c b1       	in	r24, 0x0c	; 12
        
        result |= (temp << i);
    3516:	85 fb       	bst	r24, 5
    3518:	88 27       	eor	r24, r24
    351a:	80 f9       	bld	r24, 0
    351c:	8f 8f       	std	Y+31, r24	; 0x1f
    351e:	18 a2       	std	Y+32, r1	; 0x20
    3520:	2f 8d       	ldd	r18, Y+31	; 0x1f
    3522:	38 a1       	ldd	r19, Y+32	; 0x20
    3524:	22 0f       	add	r18, r18
    3526:	33 1f       	adc	r19, r19
    3528:	22 0f       	add	r18, r18
    352a:	33 1f       	adc	r19, r19
    352c:	26 2b       	or	r18, r22
    352e:	fa e2       	ldi	r31, 0x2A	; 42
    3530:	fa 95       	dec	r31
    3532:	f1 f7       	brne	.-4      	; 0x3530 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x9ce>
    3534:	00 c0       	rjmp	.+0      	; 0x3536 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x9d4>
    // Systematically read DOUT
    for (int i = 7; i >= 0; i--)
    {
        _delay_us(delayTime);
        
        CLK_PORT |= CLK_PIN;
    3536:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    353a:	88 60       	ori	r24, 0x08	; 8
    353c:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    3540:	3a e2       	ldi	r19, 0x2A	; 42
    3542:	3a 95       	dec	r19
    3544:	f1 f7       	brne	.-4      	; 0x3542 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x9e0>
    3546:	00 c0       	rjmp	.+0      	; 0x3548 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x9e6>
        _delay_us(delayTime);
        CLK_PORT &= ~CLK_PIN;
    3548:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    354c:	87 7f       	andi	r24, 0xF7	; 247
    354e:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    3552:	85 e0       	ldi	r24, 0x05	; 5
    3554:	8a 95       	dec	r24
    3556:	f1 f7       	brne	.-4      	; 0x3554 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x9f2>
    3558:	00 00       	nop
        _delay_us(1);
        
        bool temp = (PINE & (1U << 5));
    355a:	8c b1       	in	r24, 0x0c	; 12
        
        result |= (temp << i);
    355c:	85 fb       	bst	r24, 5
    355e:	88 27       	eor	r24, r24
    3560:	80 f9       	bld	r24, 0
    3562:	89 a3       	std	Y+33, r24	; 0x21
    3564:	1a a2       	std	Y+34, r1	; 0x22
    3566:	89 a1       	ldd	r24, Y+33	; 0x21
    3568:	9a a1       	ldd	r25, Y+34	; 0x22
    356a:	88 0f       	add	r24, r24
    356c:	99 1f       	adc	r25, r25
    356e:	28 2b       	or	r18, r24
    3570:	9a e2       	ldi	r25, 0x2A	; 42
    3572:	9a 95       	dec	r25
    3574:	f1 f7       	brne	.-4      	; 0x3572 <_ZN11TouchDriver14getCoordinatesEPhS0_+0xa10>
    3576:	00 c0       	rjmp	.+0      	; 0x3578 <_ZN11TouchDriver14getCoordinatesEPhS0_+0xa16>
    // Systematically read DOUT
    for (int i = 7; i >= 0; i--)
    {
        _delay_us(delayTime);
        
        CLK_PORT |= CLK_PIN;
    3578:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    357c:	88 60       	ori	r24, 0x08	; 8
    357e:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    3582:	ea e2       	ldi	r30, 0x2A	; 42
    3584:	ea 95       	dec	r30
    3586:	f1 f7       	brne	.-4      	; 0x3584 <_ZN11TouchDriver14getCoordinatesEPhS0_+0xa22>
    3588:	00 c0       	rjmp	.+0      	; 0x358a <_ZN11TouchDriver14getCoordinatesEPhS0_+0xa28>
        _delay_us(delayTime);
        CLK_PORT &= ~CLK_PIN;
    358a:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    358e:	87 7f       	andi	r24, 0xF7	; 247
    3590:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    3594:	f5 e0       	ldi	r31, 0x05	; 5
    3596:	fa 95       	dec	r31
    3598:	f1 f7       	brne	.-4      	; 0x3596 <_ZN11TouchDriver14getCoordinatesEPhS0_+0xa34>
    359a:	00 00       	nop
        _delay_us(1);
        
        bool temp = (PINE & (1U << 5));
    359c:	8c b1       	in	r24, 0x0c	; 12
    359e:	3a e2       	ldi	r19, 0x2A	; 42
    35a0:	3a 95       	dec	r19
    35a2:	f1 f7       	brne	.-4      	; 0x35a0 <_ZN11TouchDriver14getCoordinatesEPhS0_+0xa3e>
    35a4:	00 c0       	rjmp	.+0      	; 0x35a6 <_ZN11TouchDriver14getCoordinatesEPhS0_+0xa44>
    
    for (int i = 7; i >= 0; i--)
    {
        
        _delay_us(delayTime);
        CLK_PORT |= CLK_PIN;
    35a6:	90 91 02 01 	lds	r25, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    35aa:	98 60       	ori	r25, 0x08	; 8
    35ac:	90 93 02 01 	sts	0x0102, r25	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    35b0:	9a e2       	ldi	r25, 0x2A	; 42
    35b2:	9a 95       	dec	r25
    35b4:	f1 f7       	brne	.-4      	; 0x35b2 <_ZN11TouchDriver14getCoordinatesEPhS0_+0xa50>
    35b6:	00 c0       	rjmp	.+0      	; 0x35b8 <_ZN11TouchDriver14getCoordinatesEPhS0_+0xa56>
        _delay_us(delayTime);
        CLK_PORT &= ~CLK_PIN;
    35b8:	90 91 02 01 	lds	r25, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    35bc:	97 7f       	andi	r25, 0xF7	; 247
    35be:	90 93 02 01 	sts	0x0102, r25	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    35c2:	ea e2       	ldi	r30, 0x2A	; 42
    35c4:	ea 95       	dec	r30
    35c6:	f1 f7       	brne	.-4      	; 0x35c4 <_ZN11TouchDriver14getCoordinatesEPhS0_+0xa62>
    35c8:	00 c0       	rjmp	.+0      	; 0x35ca <_ZN11TouchDriver14getCoordinatesEPhS0_+0xa68>
    
    for (int i = 7; i >= 0; i--)
    {
        
        _delay_us(delayTime);
        CLK_PORT |= CLK_PIN;
    35ca:	90 91 02 01 	lds	r25, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    35ce:	98 60       	ori	r25, 0x08	; 8
    35d0:	90 93 02 01 	sts	0x0102, r25	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    35d4:	fa e2       	ldi	r31, 0x2A	; 42
    35d6:	fa 95       	dec	r31
    35d8:	f1 f7       	brne	.-4      	; 0x35d6 <_ZN11TouchDriver14getCoordinatesEPhS0_+0xa74>
    35da:	00 c0       	rjmp	.+0      	; 0x35dc <_ZN11TouchDriver14getCoordinatesEPhS0_+0xa7a>
        _delay_us(delayTime);
        CLK_PORT &= ~CLK_PIN;
    35dc:	90 91 02 01 	lds	r25, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    35e0:	97 7f       	andi	r25, 0xF7	; 247
    35e2:	90 93 02 01 	sts	0x0102, r25	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    35e6:	3a e2       	ldi	r19, 0x2A	; 42
    35e8:	3a 95       	dec	r19
    35ea:	f1 f7       	brne	.-4      	; 0x35e8 <_ZN11TouchDriver14getCoordinatesEPhS0_+0xa86>
    35ec:	00 c0       	rjmp	.+0      	; 0x35ee <_ZN11TouchDriver14getCoordinatesEPhS0_+0xa8c>
    
    for (int i = 7; i >= 0; i--)
    {
        
        _delay_us(delayTime);
        CLK_PORT |= CLK_PIN;
    35ee:	90 91 02 01 	lds	r25, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    35f2:	98 60       	ori	r25, 0x08	; 8
    35f4:	90 93 02 01 	sts	0x0102, r25	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    35f8:	9a e2       	ldi	r25, 0x2A	; 42
    35fa:	9a 95       	dec	r25
    35fc:	f1 f7       	brne	.-4      	; 0x35fa <_ZN11TouchDriver14getCoordinatesEPhS0_+0xa98>
    35fe:	00 c0       	rjmp	.+0      	; 0x3600 <_ZN11TouchDriver14getCoordinatesEPhS0_+0xa9e>
        _delay_us(delayTime);
        CLK_PORT &= ~CLK_PIN;
    3600:	90 91 02 01 	lds	r25, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    3604:	97 7f       	andi	r25, 0xF7	; 247
    3606:	90 93 02 01 	sts	0x0102, r25	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    360a:	ea e2       	ldi	r30, 0x2A	; 42
    360c:	ea 95       	dec	r30
    360e:	f1 f7       	brne	.-4      	; 0x360c <_ZN11TouchDriver14getCoordinatesEPhS0_+0xaaa>
    3610:	00 c0       	rjmp	.+0      	; 0x3612 <_ZN11TouchDriver14getCoordinatesEPhS0_+0xab0>
    
    for (int i = 7; i >= 0; i--)
    {
        
        _delay_us(delayTime);
        CLK_PORT |= CLK_PIN;
    3612:	90 91 02 01 	lds	r25, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    3616:	98 60       	ori	r25, 0x08	; 8
    3618:	90 93 02 01 	sts	0x0102, r25	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    361c:	fa e2       	ldi	r31, 0x2A	; 42
    361e:	fa 95       	dec	r31
    3620:	f1 f7       	brne	.-4      	; 0x361e <_ZN11TouchDriver14getCoordinatesEPhS0_+0xabc>
    3622:	00 c0       	rjmp	.+0      	; 0x3624 <_ZN11TouchDriver14getCoordinatesEPhS0_+0xac2>
        _delay_us(delayTime);
        CLK_PORT &= ~CLK_PIN;
    3624:	90 91 02 01 	lds	r25, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    3628:	97 7f       	andi	r25, 0xF7	; 247
    362a:	90 93 02 01 	sts	0x0102, r25	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    362e:	3a e2       	ldi	r19, 0x2A	; 42
    3630:	3a 95       	dec	r19
    3632:	f1 f7       	brne	.-4      	; 0x3630 <_ZN11TouchDriver14getCoordinatesEPhS0_+0xace>
    3634:	00 c0       	rjmp	.+0      	; 0x3636 <_ZN11TouchDriver14getCoordinatesEPhS0_+0xad4>
    
    for (int i = 7; i >= 0; i--)
    {
        
        _delay_us(delayTime);
        CLK_PORT |= CLK_PIN;
    3636:	90 91 02 01 	lds	r25, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    363a:	98 60       	ori	r25, 0x08	; 8
    363c:	90 93 02 01 	sts	0x0102, r25	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    3640:	9a e2       	ldi	r25, 0x2A	; 42
    3642:	9a 95       	dec	r25
    3644:	f1 f7       	brne	.-4      	; 0x3642 <_ZN11TouchDriver14getCoordinatesEPhS0_+0xae0>
    3646:	00 c0       	rjmp	.+0      	; 0x3648 <_ZN11TouchDriver14getCoordinatesEPhS0_+0xae6>
        _delay_us(delayTime);
        CLK_PORT &= ~CLK_PIN;
    3648:	90 91 02 01 	lds	r25, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    364c:	97 7f       	andi	r25, 0xF7	; 247
    364e:	90 93 02 01 	sts	0x0102, r25	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    3652:	ea e2       	ldi	r30, 0x2A	; 42
    3654:	ea 95       	dec	r30
    3656:	f1 f7       	brne	.-4      	; 0x3654 <_ZN11TouchDriver14getCoordinatesEPhS0_+0xaf2>
    3658:	00 c0       	rjmp	.+0      	; 0x365a <_ZN11TouchDriver14getCoordinatesEPhS0_+0xaf8>
    
    for (int i = 7; i >= 0; i--)
    {
        
        _delay_us(delayTime);
        CLK_PORT |= CLK_PIN;
    365a:	90 91 02 01 	lds	r25, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    365e:	98 60       	ori	r25, 0x08	; 8
    3660:	90 93 02 01 	sts	0x0102, r25	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    3664:	fa e2       	ldi	r31, 0x2A	; 42
    3666:	fa 95       	dec	r31
    3668:	f1 f7       	brne	.-4      	; 0x3666 <_ZN11TouchDriver14getCoordinatesEPhS0_+0xb04>
    366a:	00 c0       	rjmp	.+0      	; 0x366c <_ZN11TouchDriver14getCoordinatesEPhS0_+0xb0a>
        _delay_us(delayTime);
        CLK_PORT &= ~CLK_PIN;
    366c:	90 91 02 01 	lds	r25, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    3670:	97 7f       	andi	r25, 0xF7	; 247
    3672:	90 93 02 01 	sts	0x0102, r25	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    3676:	3a e2       	ldi	r19, 0x2A	; 42
    3678:	3a 95       	dec	r19
    367a:	f1 f7       	brne	.-4      	; 0x3678 <_ZN11TouchDriver14getCoordinatesEPhS0_+0xb16>
    367c:	00 c0       	rjmp	.+0      	; 0x367e <_ZN11TouchDriver14getCoordinatesEPhS0_+0xb1c>
    
    for (int i = 7; i >= 0; i--)
    {
        
        _delay_us(delayTime);
        CLK_PORT |= CLK_PIN;
    367e:	90 91 02 01 	lds	r25, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    3682:	98 60       	ori	r25, 0x08	; 8
    3684:	90 93 02 01 	sts	0x0102, r25	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    3688:	9a e2       	ldi	r25, 0x2A	; 42
    368a:	9a 95       	dec	r25
    368c:	f1 f7       	brne	.-4      	; 0x368a <_ZN11TouchDriver14getCoordinatesEPhS0_+0xb28>
    368e:	00 c0       	rjmp	.+0      	; 0x3690 <_ZN11TouchDriver14getCoordinatesEPhS0_+0xb2e>
        _delay_us(delayTime);
        CLK_PORT &= ~CLK_PIN;
    3690:	90 91 02 01 	lds	r25, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    3694:	97 7f       	andi	r25, 0xF7	; 247
    3696:	90 93 02 01 	sts	0x0102, r25	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    369a:	ea e2       	ldi	r30, 0x2A	; 42
    369c:	ea 95       	dec	r30
    369e:	f1 f7       	brne	.-4      	; 0x369c <_ZN11TouchDriver14getCoordinatesEPhS0_+0xb3a>
    36a0:	00 c0       	rjmp	.+0      	; 0x36a2 <_ZN11TouchDriver14getCoordinatesEPhS0_+0xb40>
    
    for (int i = 7; i >= 0; i--)
    {
        
        _delay_us(delayTime);
        CLK_PORT |= CLK_PIN;
    36a2:	90 91 02 01 	lds	r25, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    36a6:	98 60       	ori	r25, 0x08	; 8
    36a8:	90 93 02 01 	sts	0x0102, r25	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    36ac:	fa e2       	ldi	r31, 0x2A	; 42
    36ae:	fa 95       	dec	r31
    36b0:	f1 f7       	brne	.-4      	; 0x36ae <_ZN11TouchDriver14getCoordinatesEPhS0_+0xb4c>
    36b2:	00 c0       	rjmp	.+0      	; 0x36b4 <_ZN11TouchDriver14getCoordinatesEPhS0_+0xb52>
        _delay_us(delayTime);
        CLK_PORT &= ~CLK_PIN;
    36b4:	90 91 02 01 	lds	r25, 0x0102	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    36b8:	97 7f       	andi	r25, 0xF7	; 247
    36ba:	90 93 02 01 	sts	0x0102, r25	; 0x800102 <__TEXT_REGION_LENGTH__+0x700102>
    }
    
    CS_PORT |= CS_PIN;
    36be:	73 9a       	sbi	0x0e, 3	; 14
		{
			return;
		}
	}
	*x_ptr = readTouch('X');
	*y_ptr = readTouch('Y');
    36c0:	85 fb       	bst	r24, 5
    36c2:	88 27       	eor	r24, r24
    36c4:	80 f9       	bld	r24, 0
    36c6:	28 2b       	or	r18, r24
    36c8:	20 95       	com	r18
    36ca:	fa 01       	movw	r30, r20
    36cc:	20 83       	st	Z, r18
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    36ce:	ff ef       	ldi	r31, 0xFF	; 255
    36d0:	20 e7       	ldi	r18, 0x70	; 112
    36d2:	32 e0       	ldi	r19, 0x02	; 2
    36d4:	f1 50       	subi	r31, 0x01	; 1
    36d6:	20 40       	sbci	r18, 0x00	; 0
    36d8:	30 40       	sbci	r19, 0x00	; 0
    36da:	e1 f7       	brne	.-8      	; 0x36d4 <_ZN11TouchDriver14getCoordinatesEPhS0_+0xb72>
    36dc:	00 c0       	rjmp	.+0      	; 0x36de <_ZN11TouchDriver14getCoordinatesEPhS0_+0xb7c>
    36de:	00 00       	nop
	_delay_ms( 50 );
	eIntHappend = 255;
    36e0:	8f ef       	ldi	r24, 0xFF	; 255
    36e2:	80 93 0d 02 	sts	0x020D, r24	; 0x80020d <eIntHappend>
	
}
    36e6:	a5 96       	adiw	r28, 0x25	; 37
    36e8:	0f b6       	in	r0, 0x3f	; 63
    36ea:	f8 94       	cli
    36ec:	de bf       	out	0x3e, r29	; 62
    36ee:	0f be       	out	0x3f, r0	; 63
    36f0:	cd bf       	out	0x3d, r28	; 61
    36f2:	df 91       	pop	r29
    36f4:	cf 91       	pop	r28
    36f6:	1f 91       	pop	r17
    36f8:	0f 91       	pop	r16
    36fa:	ff 90       	pop	r15
    36fc:	ef 90       	pop	r14
    36fe:	df 90       	pop	r13
    3700:	cf 90       	pop	r12
    3702:	bf 90       	pop	r11
    3704:	af 90       	pop	r10
    3706:	9f 90       	pop	r9
    3708:	8f 90       	pop	r8
    370a:	7f 90       	pop	r7
    370c:	6f 90       	pop	r6
    370e:	5f 90       	pop	r5
    3710:	4f 90       	pop	r4
    3712:	3f 90       	pop	r3
    3714:	2f 90       	pop	r2
    3716:	08 95       	ret

00003718 <_Z8InitUARTmhc>:
	BaudRate: Wanted Baud Rate (300-115200).
	Databits: Wanted number of Data Bits (5-8).
	Parity: 'E' (Even parity), 'O' (Odd parity), otherwise No Parity.
*************************************************************************/
void InitUART(unsigned long BaudRate, unsigned char DataBit, char Parity)
{
    3718:	0f 93       	push	r16
    371a:	1f 93       	push	r17
    371c:	52 2f       	mov	r21, r18
  if ((BaudRate >= 300) && (BaudRate <= 115200) && (DataBit >=5) && (DataBit <= 8))
    371e:	8b 01       	movw	r16, r22
    3720:	9c 01       	movw	r18, r24
    3722:	0c 52       	subi	r16, 0x2C	; 44
    3724:	11 40       	sbci	r17, 0x01	; 1
    3726:	21 09       	sbc	r18, r1
    3728:	31 09       	sbc	r19, r1
    372a:	05 3d       	cpi	r16, 0xD5	; 213
    372c:	10 4c       	sbci	r17, 0xC0	; 192
    372e:	21 40       	sbci	r18, 0x01	; 1
    3730:	31 05       	cpc	r19, r1
    3732:	78 f5       	brcc	.+94     	; 0x3792 <_Z8InitUARTmhc+0x7a>
    3734:	45 50       	subi	r20, 0x05	; 5
    3736:	44 30       	cpi	r20, 0x04	; 4
    3738:	60 f5       	brcc	.+88     	; 0x3792 <_Z8InitUARTmhc+0x7a>
  { 
    // "Normal" clock, no multiprocessor mode (= default)
    UCSR0A = 0b00100000;
    373a:	20 e2       	ldi	r18, 0x20	; 32
    373c:	20 93 c0 00 	sts	0x00C0, r18	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7000c0>
    // No interrupts enabled
    // Receiver enabled
    // Transmitter enabled
    // No 9 bit operation
    UCSR0B = 0b00011000;	
    3740:	28 e1       	ldi	r18, 0x18	; 24
    3742:	20 93 c1 00 	sts	0x00C1, r18	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7000c1>
    // Asynchronous operation, 1 stop bit
    // Bit 2 and bit 1 controls the number of data bits
    UCSR0C = (DataBit-5)<<1;
    3746:	44 0f       	add	r20, r20
    3748:	40 93 c2 00 	sts	0x00C2, r20	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7000c2>
	// Set parity bits (if parity used)
	if (Parity == 'E')
    374c:	55 34       	cpi	r21, 0x45	; 69
    374e:	21 f1       	breq	.+72     	; 0x3798 <_Z8InitUARTmhc+0x80>
      UCSR0C |= 0b00100000;
    else if (Parity == 'O')	  
    3750:	5f 34       	cpi	r21, 0x4F	; 79
    3752:	41 f1       	breq	.+80     	; 0x37a4 <_Z8InitUARTmhc+0x8c>
      UCSR0C |= 0b00110000;	
    // Set Baud Rate according to the parameter BaudRate:
    UBRR0 = XTAL/(16*BaudRate) - 1;
    3754:	dc 01       	movw	r26, r24
    3756:	cb 01       	movw	r24, r22
    3758:	88 0f       	add	r24, r24
    375a:	99 1f       	adc	r25, r25
    375c:	aa 1f       	adc	r26, r26
    375e:	bb 1f       	adc	r27, r27
    3760:	88 0f       	add	r24, r24
    3762:	99 1f       	adc	r25, r25
    3764:	aa 1f       	adc	r26, r26
    3766:	bb 1f       	adc	r27, r27
    3768:	9c 01       	movw	r18, r24
    376a:	ad 01       	movw	r20, r26
    376c:	22 0f       	add	r18, r18
    376e:	33 1f       	adc	r19, r19
    3770:	44 1f       	adc	r20, r20
    3772:	55 1f       	adc	r21, r21
    3774:	22 0f       	add	r18, r18
    3776:	33 1f       	adc	r19, r19
    3778:	44 1f       	adc	r20, r20
    377a:	55 1f       	adc	r21, r21
    377c:	60 e0       	ldi	r22, 0x00	; 0
    377e:	74 e2       	ldi	r23, 0x24	; 36
    3780:	84 ef       	ldi	r24, 0xF4	; 244
    3782:	90 e0       	ldi	r25, 0x00	; 0
    3784:	2b d2       	rcall	.+1110   	; 0x3bdc <__udivmodsi4>
    3786:	21 50       	subi	r18, 0x01	; 1
    3788:	31 09       	sbc	r19, r1
    378a:	30 93 c5 00 	sts	0x00C5, r19	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7000c5>
    378e:	20 93 c4 00 	sts	0x00C4, r18	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7000c4>
  }  
}
    3792:	1f 91       	pop	r17
    3794:	0f 91       	pop	r16
    3796:	08 95       	ret
    // Asynchronous operation, 1 stop bit
    // Bit 2 and bit 1 controls the number of data bits
    UCSR0C = (DataBit-5)<<1;
	// Set parity bits (if parity used)
	if (Parity == 'E')
      UCSR0C |= 0b00100000;
    3798:	20 91 c2 00 	lds	r18, 0x00C2	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7000c2>
    379c:	20 62       	ori	r18, 0x20	; 32
    379e:	20 93 c2 00 	sts	0x00C2, r18	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7000c2>
    37a2:	d8 cf       	rjmp	.-80     	; 0x3754 <_Z8InitUARTmhc+0x3c>
    else if (Parity == 'O')	  
      UCSR0C |= 0b00110000;	
    37a4:	20 91 c2 00 	lds	r18, 0x00C2	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7000c2>
    37a8:	20 63       	ori	r18, 0x30	; 48
    37aa:	20 93 c2 00 	sts	0x00C2, r18	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7000c2>
    37ae:	d2 cf       	rjmp	.-92     	; 0x3754 <_Z8InitUARTmhc+0x3c>

000037b0 <__subsf3>:
    37b0:	50 58       	subi	r21, 0x80	; 128

000037b2 <__addsf3>:
    37b2:	bb 27       	eor	r27, r27
    37b4:	aa 27       	eor	r26, r26
    37b6:	0e d0       	rcall	.+28     	; 0x37d4 <__addsf3x>
    37b8:	70 c1       	rjmp	.+736    	; 0x3a9a <__fp_round>
    37ba:	61 d1       	rcall	.+706    	; 0x3a7e <__fp_pscA>
    37bc:	30 f0       	brcs	.+12     	; 0x37ca <__addsf3+0x18>
    37be:	66 d1       	rcall	.+716    	; 0x3a8c <__fp_pscB>
    37c0:	20 f0       	brcs	.+8      	; 0x37ca <__addsf3+0x18>
    37c2:	31 f4       	brne	.+12     	; 0x37d0 <__addsf3+0x1e>
    37c4:	9f 3f       	cpi	r25, 0xFF	; 255
    37c6:	11 f4       	brne	.+4      	; 0x37cc <__addsf3+0x1a>
    37c8:	1e f4       	brtc	.+6      	; 0x37d0 <__addsf3+0x1e>
    37ca:	56 c1       	rjmp	.+684    	; 0x3a78 <__fp_nan>
    37cc:	0e f4       	brtc	.+2      	; 0x37d0 <__addsf3+0x1e>
    37ce:	e0 95       	com	r30
    37d0:	e7 fb       	bst	r30, 7
    37d2:	4c c1       	rjmp	.+664    	; 0x3a6c <__fp_inf>

000037d4 <__addsf3x>:
    37d4:	e9 2f       	mov	r30, r25
    37d6:	72 d1       	rcall	.+740    	; 0x3abc <__fp_split3>
    37d8:	80 f3       	brcs	.-32     	; 0x37ba <__addsf3+0x8>
    37da:	ba 17       	cp	r27, r26
    37dc:	62 07       	cpc	r22, r18
    37de:	73 07       	cpc	r23, r19
    37e0:	84 07       	cpc	r24, r20
    37e2:	95 07       	cpc	r25, r21
    37e4:	18 f0       	brcs	.+6      	; 0x37ec <__addsf3x+0x18>
    37e6:	71 f4       	brne	.+28     	; 0x3804 <__addsf3x+0x30>
    37e8:	9e f5       	brtc	.+102    	; 0x3850 <__addsf3x+0x7c>
    37ea:	8a c1       	rjmp	.+788    	; 0x3b00 <__fp_zero>
    37ec:	0e f4       	brtc	.+2      	; 0x37f0 <__addsf3x+0x1c>
    37ee:	e0 95       	com	r30
    37f0:	0b 2e       	mov	r0, r27
    37f2:	ba 2f       	mov	r27, r26
    37f4:	a0 2d       	mov	r26, r0
    37f6:	0b 01       	movw	r0, r22
    37f8:	b9 01       	movw	r22, r18
    37fa:	90 01       	movw	r18, r0
    37fc:	0c 01       	movw	r0, r24
    37fe:	ca 01       	movw	r24, r20
    3800:	a0 01       	movw	r20, r0
    3802:	11 24       	eor	r1, r1
    3804:	ff 27       	eor	r31, r31
    3806:	59 1b       	sub	r21, r25
    3808:	99 f0       	breq	.+38     	; 0x3830 <__addsf3x+0x5c>
    380a:	59 3f       	cpi	r21, 0xF9	; 249
    380c:	50 f4       	brcc	.+20     	; 0x3822 <__addsf3x+0x4e>
    380e:	50 3e       	cpi	r21, 0xE0	; 224
    3810:	68 f1       	brcs	.+90     	; 0x386c <__addsf3x+0x98>
    3812:	1a 16       	cp	r1, r26
    3814:	f0 40       	sbci	r31, 0x00	; 0
    3816:	a2 2f       	mov	r26, r18
    3818:	23 2f       	mov	r18, r19
    381a:	34 2f       	mov	r19, r20
    381c:	44 27       	eor	r20, r20
    381e:	58 5f       	subi	r21, 0xF8	; 248
    3820:	f3 cf       	rjmp	.-26     	; 0x3808 <__addsf3x+0x34>
    3822:	46 95       	lsr	r20
    3824:	37 95       	ror	r19
    3826:	27 95       	ror	r18
    3828:	a7 95       	ror	r26
    382a:	f0 40       	sbci	r31, 0x00	; 0
    382c:	53 95       	inc	r21
    382e:	c9 f7       	brne	.-14     	; 0x3822 <__addsf3x+0x4e>
    3830:	7e f4       	brtc	.+30     	; 0x3850 <__addsf3x+0x7c>
    3832:	1f 16       	cp	r1, r31
    3834:	ba 0b       	sbc	r27, r26
    3836:	62 0b       	sbc	r22, r18
    3838:	73 0b       	sbc	r23, r19
    383a:	84 0b       	sbc	r24, r20
    383c:	ba f0       	brmi	.+46     	; 0x386c <__addsf3x+0x98>
    383e:	91 50       	subi	r25, 0x01	; 1
    3840:	a1 f0       	breq	.+40     	; 0x386a <__addsf3x+0x96>
    3842:	ff 0f       	add	r31, r31
    3844:	bb 1f       	adc	r27, r27
    3846:	66 1f       	adc	r22, r22
    3848:	77 1f       	adc	r23, r23
    384a:	88 1f       	adc	r24, r24
    384c:	c2 f7       	brpl	.-16     	; 0x383e <__addsf3x+0x6a>
    384e:	0e c0       	rjmp	.+28     	; 0x386c <__addsf3x+0x98>
    3850:	ba 0f       	add	r27, r26
    3852:	62 1f       	adc	r22, r18
    3854:	73 1f       	adc	r23, r19
    3856:	84 1f       	adc	r24, r20
    3858:	48 f4       	brcc	.+18     	; 0x386c <__addsf3x+0x98>
    385a:	87 95       	ror	r24
    385c:	77 95       	ror	r23
    385e:	67 95       	ror	r22
    3860:	b7 95       	ror	r27
    3862:	f7 95       	ror	r31
    3864:	9e 3f       	cpi	r25, 0xFE	; 254
    3866:	08 f0       	brcs	.+2      	; 0x386a <__addsf3x+0x96>
    3868:	b3 cf       	rjmp	.-154    	; 0x37d0 <__addsf3+0x1e>
    386a:	93 95       	inc	r25
    386c:	88 0f       	add	r24, r24
    386e:	08 f0       	brcs	.+2      	; 0x3872 <__addsf3x+0x9e>
    3870:	99 27       	eor	r25, r25
    3872:	ee 0f       	add	r30, r30
    3874:	97 95       	ror	r25
    3876:	87 95       	ror	r24
    3878:	08 95       	ret

0000387a <__cmpsf2>:
    387a:	d4 d0       	rcall	.+424    	; 0x3a24 <__fp_cmp>
    387c:	08 f4       	brcc	.+2      	; 0x3880 <__cmpsf2+0x6>
    387e:	81 e0       	ldi	r24, 0x01	; 1
    3880:	08 95       	ret

00003882 <__divsf3>:
    3882:	0c d0       	rcall	.+24     	; 0x389c <__divsf3x>
    3884:	0a c1       	rjmp	.+532    	; 0x3a9a <__fp_round>
    3886:	02 d1       	rcall	.+516    	; 0x3a8c <__fp_pscB>
    3888:	40 f0       	brcs	.+16     	; 0x389a <__divsf3+0x18>
    388a:	f9 d0       	rcall	.+498    	; 0x3a7e <__fp_pscA>
    388c:	30 f0       	brcs	.+12     	; 0x389a <__divsf3+0x18>
    388e:	21 f4       	brne	.+8      	; 0x3898 <__divsf3+0x16>
    3890:	5f 3f       	cpi	r21, 0xFF	; 255
    3892:	19 f0       	breq	.+6      	; 0x389a <__divsf3+0x18>
    3894:	eb c0       	rjmp	.+470    	; 0x3a6c <__fp_inf>
    3896:	51 11       	cpse	r21, r1
    3898:	34 c1       	rjmp	.+616    	; 0x3b02 <__fp_szero>
    389a:	ee c0       	rjmp	.+476    	; 0x3a78 <__fp_nan>

0000389c <__divsf3x>:
    389c:	0f d1       	rcall	.+542    	; 0x3abc <__fp_split3>
    389e:	98 f3       	brcs	.-26     	; 0x3886 <__divsf3+0x4>

000038a0 <__divsf3_pse>:
    38a0:	99 23       	and	r25, r25
    38a2:	c9 f3       	breq	.-14     	; 0x3896 <__divsf3+0x14>
    38a4:	55 23       	and	r21, r21
    38a6:	b1 f3       	breq	.-20     	; 0x3894 <__divsf3+0x12>
    38a8:	95 1b       	sub	r25, r21
    38aa:	55 0b       	sbc	r21, r21
    38ac:	bb 27       	eor	r27, r27
    38ae:	aa 27       	eor	r26, r26
    38b0:	62 17       	cp	r22, r18
    38b2:	73 07       	cpc	r23, r19
    38b4:	84 07       	cpc	r24, r20
    38b6:	38 f0       	brcs	.+14     	; 0x38c6 <__divsf3_pse+0x26>
    38b8:	9f 5f       	subi	r25, 0xFF	; 255
    38ba:	5f 4f       	sbci	r21, 0xFF	; 255
    38bc:	22 0f       	add	r18, r18
    38be:	33 1f       	adc	r19, r19
    38c0:	44 1f       	adc	r20, r20
    38c2:	aa 1f       	adc	r26, r26
    38c4:	a9 f3       	breq	.-22     	; 0x38b0 <__divsf3_pse+0x10>
    38c6:	33 d0       	rcall	.+102    	; 0x392e <__divsf3_pse+0x8e>
    38c8:	0e 2e       	mov	r0, r30
    38ca:	3a f0       	brmi	.+14     	; 0x38da <__divsf3_pse+0x3a>
    38cc:	e0 e8       	ldi	r30, 0x80	; 128
    38ce:	30 d0       	rcall	.+96     	; 0x3930 <__divsf3_pse+0x90>
    38d0:	91 50       	subi	r25, 0x01	; 1
    38d2:	50 40       	sbci	r21, 0x00	; 0
    38d4:	e6 95       	lsr	r30
    38d6:	00 1c       	adc	r0, r0
    38d8:	ca f7       	brpl	.-14     	; 0x38cc <__divsf3_pse+0x2c>
    38da:	29 d0       	rcall	.+82     	; 0x392e <__divsf3_pse+0x8e>
    38dc:	fe 2f       	mov	r31, r30
    38de:	27 d0       	rcall	.+78     	; 0x392e <__divsf3_pse+0x8e>
    38e0:	66 0f       	add	r22, r22
    38e2:	77 1f       	adc	r23, r23
    38e4:	88 1f       	adc	r24, r24
    38e6:	bb 1f       	adc	r27, r27
    38e8:	26 17       	cp	r18, r22
    38ea:	37 07       	cpc	r19, r23
    38ec:	48 07       	cpc	r20, r24
    38ee:	ab 07       	cpc	r26, r27
    38f0:	b0 e8       	ldi	r27, 0x80	; 128
    38f2:	09 f0       	breq	.+2      	; 0x38f6 <__divsf3_pse+0x56>
    38f4:	bb 0b       	sbc	r27, r27
    38f6:	80 2d       	mov	r24, r0
    38f8:	bf 01       	movw	r22, r30
    38fa:	ff 27       	eor	r31, r31
    38fc:	93 58       	subi	r25, 0x83	; 131
    38fe:	5f 4f       	sbci	r21, 0xFF	; 255
    3900:	2a f0       	brmi	.+10     	; 0x390c <__divsf3_pse+0x6c>
    3902:	9e 3f       	cpi	r25, 0xFE	; 254
    3904:	51 05       	cpc	r21, r1
    3906:	68 f0       	brcs	.+26     	; 0x3922 <__divsf3_pse+0x82>
    3908:	b1 c0       	rjmp	.+354    	; 0x3a6c <__fp_inf>
    390a:	fb c0       	rjmp	.+502    	; 0x3b02 <__fp_szero>
    390c:	5f 3f       	cpi	r21, 0xFF	; 255
    390e:	ec f3       	brlt	.-6      	; 0x390a <__divsf3_pse+0x6a>
    3910:	98 3e       	cpi	r25, 0xE8	; 232
    3912:	dc f3       	brlt	.-10     	; 0x390a <__divsf3_pse+0x6a>
    3914:	86 95       	lsr	r24
    3916:	77 95       	ror	r23
    3918:	67 95       	ror	r22
    391a:	b7 95       	ror	r27
    391c:	f7 95       	ror	r31
    391e:	9f 5f       	subi	r25, 0xFF	; 255
    3920:	c9 f7       	brne	.-14     	; 0x3914 <__divsf3_pse+0x74>
    3922:	88 0f       	add	r24, r24
    3924:	91 1d       	adc	r25, r1
    3926:	96 95       	lsr	r25
    3928:	87 95       	ror	r24
    392a:	97 f9       	bld	r25, 7
    392c:	08 95       	ret
    392e:	e1 e0       	ldi	r30, 0x01	; 1
    3930:	66 0f       	add	r22, r22
    3932:	77 1f       	adc	r23, r23
    3934:	88 1f       	adc	r24, r24
    3936:	bb 1f       	adc	r27, r27
    3938:	62 17       	cp	r22, r18
    393a:	73 07       	cpc	r23, r19
    393c:	84 07       	cpc	r24, r20
    393e:	ba 07       	cpc	r27, r26
    3940:	20 f0       	brcs	.+8      	; 0x394a <__divsf3_pse+0xaa>
    3942:	62 1b       	sub	r22, r18
    3944:	73 0b       	sbc	r23, r19
    3946:	84 0b       	sbc	r24, r20
    3948:	ba 0b       	sbc	r27, r26
    394a:	ee 1f       	adc	r30, r30
    394c:	88 f7       	brcc	.-30     	; 0x3930 <__divsf3_pse+0x90>
    394e:	e0 95       	com	r30
    3950:	08 95       	ret

00003952 <__fixunssfsi>:
    3952:	bc d0       	rcall	.+376    	; 0x3acc <__fp_splitA>
    3954:	88 f0       	brcs	.+34     	; 0x3978 <__fixunssfsi+0x26>
    3956:	9f 57       	subi	r25, 0x7F	; 127
    3958:	90 f0       	brcs	.+36     	; 0x397e <__fixunssfsi+0x2c>
    395a:	b9 2f       	mov	r27, r25
    395c:	99 27       	eor	r25, r25
    395e:	b7 51       	subi	r27, 0x17	; 23
    3960:	a0 f0       	brcs	.+40     	; 0x398a <__fixunssfsi+0x38>
    3962:	d1 f0       	breq	.+52     	; 0x3998 <__fixunssfsi+0x46>
    3964:	66 0f       	add	r22, r22
    3966:	77 1f       	adc	r23, r23
    3968:	88 1f       	adc	r24, r24
    396a:	99 1f       	adc	r25, r25
    396c:	1a f0       	brmi	.+6      	; 0x3974 <__fixunssfsi+0x22>
    396e:	ba 95       	dec	r27
    3970:	c9 f7       	brne	.-14     	; 0x3964 <__fixunssfsi+0x12>
    3972:	12 c0       	rjmp	.+36     	; 0x3998 <__fixunssfsi+0x46>
    3974:	b1 30       	cpi	r27, 0x01	; 1
    3976:	81 f0       	breq	.+32     	; 0x3998 <__fixunssfsi+0x46>
    3978:	c3 d0       	rcall	.+390    	; 0x3b00 <__fp_zero>
    397a:	b1 e0       	ldi	r27, 0x01	; 1
    397c:	08 95       	ret
    397e:	c0 c0       	rjmp	.+384    	; 0x3b00 <__fp_zero>
    3980:	67 2f       	mov	r22, r23
    3982:	78 2f       	mov	r23, r24
    3984:	88 27       	eor	r24, r24
    3986:	b8 5f       	subi	r27, 0xF8	; 248
    3988:	39 f0       	breq	.+14     	; 0x3998 <__fixunssfsi+0x46>
    398a:	b9 3f       	cpi	r27, 0xF9	; 249
    398c:	cc f3       	brlt	.-14     	; 0x3980 <__fixunssfsi+0x2e>
    398e:	86 95       	lsr	r24
    3990:	77 95       	ror	r23
    3992:	67 95       	ror	r22
    3994:	b3 95       	inc	r27
    3996:	d9 f7       	brne	.-10     	; 0x398e <__fixunssfsi+0x3c>
    3998:	3e f4       	brtc	.+14     	; 0x39a8 <__fixunssfsi+0x56>
    399a:	90 95       	com	r25
    399c:	80 95       	com	r24
    399e:	70 95       	com	r23
    39a0:	61 95       	neg	r22
    39a2:	7f 4f       	sbci	r23, 0xFF	; 255
    39a4:	8f 4f       	sbci	r24, 0xFF	; 255
    39a6:	9f 4f       	sbci	r25, 0xFF	; 255
    39a8:	08 95       	ret

000039aa <__floatunsisf>:
    39aa:	e8 94       	clt
    39ac:	09 c0       	rjmp	.+18     	; 0x39c0 <__floatsisf+0x12>

000039ae <__floatsisf>:
    39ae:	97 fb       	bst	r25, 7
    39b0:	3e f4       	brtc	.+14     	; 0x39c0 <__floatsisf+0x12>
    39b2:	90 95       	com	r25
    39b4:	80 95       	com	r24
    39b6:	70 95       	com	r23
    39b8:	61 95       	neg	r22
    39ba:	7f 4f       	sbci	r23, 0xFF	; 255
    39bc:	8f 4f       	sbci	r24, 0xFF	; 255
    39be:	9f 4f       	sbci	r25, 0xFF	; 255
    39c0:	99 23       	and	r25, r25
    39c2:	a9 f0       	breq	.+42     	; 0x39ee <__floatsisf+0x40>
    39c4:	f9 2f       	mov	r31, r25
    39c6:	96 e9       	ldi	r25, 0x96	; 150
    39c8:	bb 27       	eor	r27, r27
    39ca:	93 95       	inc	r25
    39cc:	f6 95       	lsr	r31
    39ce:	87 95       	ror	r24
    39d0:	77 95       	ror	r23
    39d2:	67 95       	ror	r22
    39d4:	b7 95       	ror	r27
    39d6:	f1 11       	cpse	r31, r1
    39d8:	f8 cf       	rjmp	.-16     	; 0x39ca <__floatsisf+0x1c>
    39da:	fa f4       	brpl	.+62     	; 0x3a1a <__floatsisf+0x6c>
    39dc:	bb 0f       	add	r27, r27
    39de:	11 f4       	brne	.+4      	; 0x39e4 <__floatsisf+0x36>
    39e0:	60 ff       	sbrs	r22, 0
    39e2:	1b c0       	rjmp	.+54     	; 0x3a1a <__floatsisf+0x6c>
    39e4:	6f 5f       	subi	r22, 0xFF	; 255
    39e6:	7f 4f       	sbci	r23, 0xFF	; 255
    39e8:	8f 4f       	sbci	r24, 0xFF	; 255
    39ea:	9f 4f       	sbci	r25, 0xFF	; 255
    39ec:	16 c0       	rjmp	.+44     	; 0x3a1a <__floatsisf+0x6c>
    39ee:	88 23       	and	r24, r24
    39f0:	11 f0       	breq	.+4      	; 0x39f6 <__floatsisf+0x48>
    39f2:	96 e9       	ldi	r25, 0x96	; 150
    39f4:	11 c0       	rjmp	.+34     	; 0x3a18 <__floatsisf+0x6a>
    39f6:	77 23       	and	r23, r23
    39f8:	21 f0       	breq	.+8      	; 0x3a02 <__floatsisf+0x54>
    39fa:	9e e8       	ldi	r25, 0x8E	; 142
    39fc:	87 2f       	mov	r24, r23
    39fe:	76 2f       	mov	r23, r22
    3a00:	05 c0       	rjmp	.+10     	; 0x3a0c <__floatsisf+0x5e>
    3a02:	66 23       	and	r22, r22
    3a04:	71 f0       	breq	.+28     	; 0x3a22 <__floatsisf+0x74>
    3a06:	96 e8       	ldi	r25, 0x86	; 134
    3a08:	86 2f       	mov	r24, r22
    3a0a:	70 e0       	ldi	r23, 0x00	; 0
    3a0c:	60 e0       	ldi	r22, 0x00	; 0
    3a0e:	2a f0       	brmi	.+10     	; 0x3a1a <__floatsisf+0x6c>
    3a10:	9a 95       	dec	r25
    3a12:	66 0f       	add	r22, r22
    3a14:	77 1f       	adc	r23, r23
    3a16:	88 1f       	adc	r24, r24
    3a18:	da f7       	brpl	.-10     	; 0x3a10 <__floatsisf+0x62>
    3a1a:	88 0f       	add	r24, r24
    3a1c:	96 95       	lsr	r25
    3a1e:	87 95       	ror	r24
    3a20:	97 f9       	bld	r25, 7
    3a22:	08 95       	ret

00003a24 <__fp_cmp>:
    3a24:	99 0f       	add	r25, r25
    3a26:	00 08       	sbc	r0, r0
    3a28:	55 0f       	add	r21, r21
    3a2a:	aa 0b       	sbc	r26, r26
    3a2c:	e0 e8       	ldi	r30, 0x80	; 128
    3a2e:	fe ef       	ldi	r31, 0xFE	; 254
    3a30:	16 16       	cp	r1, r22
    3a32:	17 06       	cpc	r1, r23
    3a34:	e8 07       	cpc	r30, r24
    3a36:	f9 07       	cpc	r31, r25
    3a38:	c0 f0       	brcs	.+48     	; 0x3a6a <__fp_cmp+0x46>
    3a3a:	12 16       	cp	r1, r18
    3a3c:	13 06       	cpc	r1, r19
    3a3e:	e4 07       	cpc	r30, r20
    3a40:	f5 07       	cpc	r31, r21
    3a42:	98 f0       	brcs	.+38     	; 0x3a6a <__fp_cmp+0x46>
    3a44:	62 1b       	sub	r22, r18
    3a46:	73 0b       	sbc	r23, r19
    3a48:	84 0b       	sbc	r24, r20
    3a4a:	95 0b       	sbc	r25, r21
    3a4c:	39 f4       	brne	.+14     	; 0x3a5c <__fp_cmp+0x38>
    3a4e:	0a 26       	eor	r0, r26
    3a50:	61 f0       	breq	.+24     	; 0x3a6a <__fp_cmp+0x46>
    3a52:	23 2b       	or	r18, r19
    3a54:	24 2b       	or	r18, r20
    3a56:	25 2b       	or	r18, r21
    3a58:	21 f4       	brne	.+8      	; 0x3a62 <__fp_cmp+0x3e>
    3a5a:	08 95       	ret
    3a5c:	0a 26       	eor	r0, r26
    3a5e:	09 f4       	brne	.+2      	; 0x3a62 <__fp_cmp+0x3e>
    3a60:	a1 40       	sbci	r26, 0x01	; 1
    3a62:	a6 95       	lsr	r26
    3a64:	8f ef       	ldi	r24, 0xFF	; 255
    3a66:	81 1d       	adc	r24, r1
    3a68:	81 1d       	adc	r24, r1
    3a6a:	08 95       	ret

00003a6c <__fp_inf>:
    3a6c:	97 f9       	bld	r25, 7
    3a6e:	9f 67       	ori	r25, 0x7F	; 127
    3a70:	80 e8       	ldi	r24, 0x80	; 128
    3a72:	70 e0       	ldi	r23, 0x00	; 0
    3a74:	60 e0       	ldi	r22, 0x00	; 0
    3a76:	08 95       	ret

00003a78 <__fp_nan>:
    3a78:	9f ef       	ldi	r25, 0xFF	; 255
    3a7a:	80 ec       	ldi	r24, 0xC0	; 192
    3a7c:	08 95       	ret

00003a7e <__fp_pscA>:
    3a7e:	00 24       	eor	r0, r0
    3a80:	0a 94       	dec	r0
    3a82:	16 16       	cp	r1, r22
    3a84:	17 06       	cpc	r1, r23
    3a86:	18 06       	cpc	r1, r24
    3a88:	09 06       	cpc	r0, r25
    3a8a:	08 95       	ret

00003a8c <__fp_pscB>:
    3a8c:	00 24       	eor	r0, r0
    3a8e:	0a 94       	dec	r0
    3a90:	12 16       	cp	r1, r18
    3a92:	13 06       	cpc	r1, r19
    3a94:	14 06       	cpc	r1, r20
    3a96:	05 06       	cpc	r0, r21
    3a98:	08 95       	ret

00003a9a <__fp_round>:
    3a9a:	09 2e       	mov	r0, r25
    3a9c:	03 94       	inc	r0
    3a9e:	00 0c       	add	r0, r0
    3aa0:	11 f4       	brne	.+4      	; 0x3aa6 <__fp_round+0xc>
    3aa2:	88 23       	and	r24, r24
    3aa4:	52 f0       	brmi	.+20     	; 0x3aba <__fp_round+0x20>
    3aa6:	bb 0f       	add	r27, r27
    3aa8:	40 f4       	brcc	.+16     	; 0x3aba <__fp_round+0x20>
    3aaa:	bf 2b       	or	r27, r31
    3aac:	11 f4       	brne	.+4      	; 0x3ab2 <__fp_round+0x18>
    3aae:	60 ff       	sbrs	r22, 0
    3ab0:	04 c0       	rjmp	.+8      	; 0x3aba <__fp_round+0x20>
    3ab2:	6f 5f       	subi	r22, 0xFF	; 255
    3ab4:	7f 4f       	sbci	r23, 0xFF	; 255
    3ab6:	8f 4f       	sbci	r24, 0xFF	; 255
    3ab8:	9f 4f       	sbci	r25, 0xFF	; 255
    3aba:	08 95       	ret

00003abc <__fp_split3>:
    3abc:	57 fd       	sbrc	r21, 7
    3abe:	90 58       	subi	r25, 0x80	; 128
    3ac0:	44 0f       	add	r20, r20
    3ac2:	55 1f       	adc	r21, r21
    3ac4:	59 f0       	breq	.+22     	; 0x3adc <__fp_splitA+0x10>
    3ac6:	5f 3f       	cpi	r21, 0xFF	; 255
    3ac8:	71 f0       	breq	.+28     	; 0x3ae6 <__fp_splitA+0x1a>
    3aca:	47 95       	ror	r20

00003acc <__fp_splitA>:
    3acc:	88 0f       	add	r24, r24
    3ace:	97 fb       	bst	r25, 7
    3ad0:	99 1f       	adc	r25, r25
    3ad2:	61 f0       	breq	.+24     	; 0x3aec <__fp_splitA+0x20>
    3ad4:	9f 3f       	cpi	r25, 0xFF	; 255
    3ad6:	79 f0       	breq	.+30     	; 0x3af6 <__fp_splitA+0x2a>
    3ad8:	87 95       	ror	r24
    3ada:	08 95       	ret
    3adc:	12 16       	cp	r1, r18
    3ade:	13 06       	cpc	r1, r19
    3ae0:	14 06       	cpc	r1, r20
    3ae2:	55 1f       	adc	r21, r21
    3ae4:	f2 cf       	rjmp	.-28     	; 0x3aca <__fp_split3+0xe>
    3ae6:	46 95       	lsr	r20
    3ae8:	f1 df       	rcall	.-30     	; 0x3acc <__fp_splitA>
    3aea:	08 c0       	rjmp	.+16     	; 0x3afc <__fp_splitA+0x30>
    3aec:	16 16       	cp	r1, r22
    3aee:	17 06       	cpc	r1, r23
    3af0:	18 06       	cpc	r1, r24
    3af2:	99 1f       	adc	r25, r25
    3af4:	f1 cf       	rjmp	.-30     	; 0x3ad8 <__fp_splitA+0xc>
    3af6:	86 95       	lsr	r24
    3af8:	71 05       	cpc	r23, r1
    3afa:	61 05       	cpc	r22, r1
    3afc:	08 94       	sec
    3afe:	08 95       	ret

00003b00 <__fp_zero>:
    3b00:	e8 94       	clt

00003b02 <__fp_szero>:
    3b02:	bb 27       	eor	r27, r27
    3b04:	66 27       	eor	r22, r22
    3b06:	77 27       	eor	r23, r23
    3b08:	cb 01       	movw	r24, r22
    3b0a:	97 f9       	bld	r25, 7
    3b0c:	08 95       	ret

00003b0e <__gesf2>:
    3b0e:	8a df       	rcall	.-236    	; 0x3a24 <__fp_cmp>
    3b10:	08 f4       	brcc	.+2      	; 0x3b14 <__gesf2+0x6>
    3b12:	8f ef       	ldi	r24, 0xFF	; 255
    3b14:	08 95       	ret

00003b16 <__mulsf3>:
    3b16:	0b d0       	rcall	.+22     	; 0x3b2e <__mulsf3x>
    3b18:	c0 cf       	rjmp	.-128    	; 0x3a9a <__fp_round>
    3b1a:	b1 df       	rcall	.-158    	; 0x3a7e <__fp_pscA>
    3b1c:	28 f0       	brcs	.+10     	; 0x3b28 <__mulsf3+0x12>
    3b1e:	b6 df       	rcall	.-148    	; 0x3a8c <__fp_pscB>
    3b20:	18 f0       	brcs	.+6      	; 0x3b28 <__mulsf3+0x12>
    3b22:	95 23       	and	r25, r21
    3b24:	09 f0       	breq	.+2      	; 0x3b28 <__mulsf3+0x12>
    3b26:	a2 cf       	rjmp	.-188    	; 0x3a6c <__fp_inf>
    3b28:	a7 cf       	rjmp	.-178    	; 0x3a78 <__fp_nan>
    3b2a:	11 24       	eor	r1, r1
    3b2c:	ea cf       	rjmp	.-44     	; 0x3b02 <__fp_szero>

00003b2e <__mulsf3x>:
    3b2e:	c6 df       	rcall	.-116    	; 0x3abc <__fp_split3>
    3b30:	a0 f3       	brcs	.-24     	; 0x3b1a <__mulsf3+0x4>

00003b32 <__mulsf3_pse>:
    3b32:	95 9f       	mul	r25, r21
    3b34:	d1 f3       	breq	.-12     	; 0x3b2a <__mulsf3+0x14>
    3b36:	95 0f       	add	r25, r21
    3b38:	50 e0       	ldi	r21, 0x00	; 0
    3b3a:	55 1f       	adc	r21, r21
    3b3c:	62 9f       	mul	r22, r18
    3b3e:	f0 01       	movw	r30, r0
    3b40:	72 9f       	mul	r23, r18
    3b42:	bb 27       	eor	r27, r27
    3b44:	f0 0d       	add	r31, r0
    3b46:	b1 1d       	adc	r27, r1
    3b48:	63 9f       	mul	r22, r19
    3b4a:	aa 27       	eor	r26, r26
    3b4c:	f0 0d       	add	r31, r0
    3b4e:	b1 1d       	adc	r27, r1
    3b50:	aa 1f       	adc	r26, r26
    3b52:	64 9f       	mul	r22, r20
    3b54:	66 27       	eor	r22, r22
    3b56:	b0 0d       	add	r27, r0
    3b58:	a1 1d       	adc	r26, r1
    3b5a:	66 1f       	adc	r22, r22
    3b5c:	82 9f       	mul	r24, r18
    3b5e:	22 27       	eor	r18, r18
    3b60:	b0 0d       	add	r27, r0
    3b62:	a1 1d       	adc	r26, r1
    3b64:	62 1f       	adc	r22, r18
    3b66:	73 9f       	mul	r23, r19
    3b68:	b0 0d       	add	r27, r0
    3b6a:	a1 1d       	adc	r26, r1
    3b6c:	62 1f       	adc	r22, r18
    3b6e:	83 9f       	mul	r24, r19
    3b70:	a0 0d       	add	r26, r0
    3b72:	61 1d       	adc	r22, r1
    3b74:	22 1f       	adc	r18, r18
    3b76:	74 9f       	mul	r23, r20
    3b78:	33 27       	eor	r19, r19
    3b7a:	a0 0d       	add	r26, r0
    3b7c:	61 1d       	adc	r22, r1
    3b7e:	23 1f       	adc	r18, r19
    3b80:	84 9f       	mul	r24, r20
    3b82:	60 0d       	add	r22, r0
    3b84:	21 1d       	adc	r18, r1
    3b86:	82 2f       	mov	r24, r18
    3b88:	76 2f       	mov	r23, r22
    3b8a:	6a 2f       	mov	r22, r26
    3b8c:	11 24       	eor	r1, r1
    3b8e:	9f 57       	subi	r25, 0x7F	; 127
    3b90:	50 40       	sbci	r21, 0x00	; 0
    3b92:	8a f0       	brmi	.+34     	; 0x3bb6 <__mulsf3_pse+0x84>
    3b94:	e1 f0       	breq	.+56     	; 0x3bce <__mulsf3_pse+0x9c>
    3b96:	88 23       	and	r24, r24
    3b98:	4a f0       	brmi	.+18     	; 0x3bac <__mulsf3_pse+0x7a>
    3b9a:	ee 0f       	add	r30, r30
    3b9c:	ff 1f       	adc	r31, r31
    3b9e:	bb 1f       	adc	r27, r27
    3ba0:	66 1f       	adc	r22, r22
    3ba2:	77 1f       	adc	r23, r23
    3ba4:	88 1f       	adc	r24, r24
    3ba6:	91 50       	subi	r25, 0x01	; 1
    3ba8:	50 40       	sbci	r21, 0x00	; 0
    3baa:	a9 f7       	brne	.-22     	; 0x3b96 <__mulsf3_pse+0x64>
    3bac:	9e 3f       	cpi	r25, 0xFE	; 254
    3bae:	51 05       	cpc	r21, r1
    3bb0:	70 f0       	brcs	.+28     	; 0x3bce <__mulsf3_pse+0x9c>
    3bb2:	5c cf       	rjmp	.-328    	; 0x3a6c <__fp_inf>
    3bb4:	a6 cf       	rjmp	.-180    	; 0x3b02 <__fp_szero>
    3bb6:	5f 3f       	cpi	r21, 0xFF	; 255
    3bb8:	ec f3       	brlt	.-6      	; 0x3bb4 <__mulsf3_pse+0x82>
    3bba:	98 3e       	cpi	r25, 0xE8	; 232
    3bbc:	dc f3       	brlt	.-10     	; 0x3bb4 <__mulsf3_pse+0x82>
    3bbe:	86 95       	lsr	r24
    3bc0:	77 95       	ror	r23
    3bc2:	67 95       	ror	r22
    3bc4:	b7 95       	ror	r27
    3bc6:	f7 95       	ror	r31
    3bc8:	e7 95       	ror	r30
    3bca:	9f 5f       	subi	r25, 0xFF	; 255
    3bcc:	c1 f7       	brne	.-16     	; 0x3bbe <__mulsf3_pse+0x8c>
    3bce:	fe 2b       	or	r31, r30
    3bd0:	88 0f       	add	r24, r24
    3bd2:	91 1d       	adc	r25, r1
    3bd4:	96 95       	lsr	r25
    3bd6:	87 95       	ror	r24
    3bd8:	97 f9       	bld	r25, 7
    3bda:	08 95       	ret

00003bdc <__udivmodsi4>:
    3bdc:	a1 e2       	ldi	r26, 0x21	; 33
    3bde:	1a 2e       	mov	r1, r26
    3be0:	aa 1b       	sub	r26, r26
    3be2:	bb 1b       	sub	r27, r27
    3be4:	fd 01       	movw	r30, r26
    3be6:	0d c0       	rjmp	.+26     	; 0x3c02 <__udivmodsi4_ep>

00003be8 <__udivmodsi4_loop>:
    3be8:	aa 1f       	adc	r26, r26
    3bea:	bb 1f       	adc	r27, r27
    3bec:	ee 1f       	adc	r30, r30
    3bee:	ff 1f       	adc	r31, r31
    3bf0:	a2 17       	cp	r26, r18
    3bf2:	b3 07       	cpc	r27, r19
    3bf4:	e4 07       	cpc	r30, r20
    3bf6:	f5 07       	cpc	r31, r21
    3bf8:	20 f0       	brcs	.+8      	; 0x3c02 <__udivmodsi4_ep>
    3bfa:	a2 1b       	sub	r26, r18
    3bfc:	b3 0b       	sbc	r27, r19
    3bfe:	e4 0b       	sbc	r30, r20
    3c00:	f5 0b       	sbc	r31, r21

00003c02 <__udivmodsi4_ep>:
    3c02:	66 1f       	adc	r22, r22
    3c04:	77 1f       	adc	r23, r23
    3c06:	88 1f       	adc	r24, r24
    3c08:	99 1f       	adc	r25, r25
    3c0a:	1a 94       	dec	r1
    3c0c:	69 f7       	brne	.-38     	; 0x3be8 <__udivmodsi4_loop>
    3c0e:	60 95       	com	r22
    3c10:	70 95       	com	r23
    3c12:	80 95       	com	r24
    3c14:	90 95       	com	r25
    3c16:	9b 01       	movw	r18, r22
    3c18:	ac 01       	movw	r20, r24
    3c1a:	bd 01       	movw	r22, r26
    3c1c:	cf 01       	movw	r24, r30
    3c1e:	08 95       	ret

00003c20 <__umulhisi3>:
    3c20:	a2 9f       	mul	r26, r18
    3c22:	b0 01       	movw	r22, r0
    3c24:	b3 9f       	mul	r27, r19
    3c26:	c0 01       	movw	r24, r0
    3c28:	a3 9f       	mul	r26, r19
    3c2a:	70 0d       	add	r23, r0
    3c2c:	81 1d       	adc	r24, r1
    3c2e:	11 24       	eor	r1, r1
    3c30:	91 1d       	adc	r25, r1
    3c32:	b2 9f       	mul	r27, r18
    3c34:	70 0d       	add	r23, r0
    3c36:	81 1d       	adc	r24, r1
    3c38:	11 24       	eor	r1, r1
    3c3a:	91 1d       	adc	r25, r1
    3c3c:	08 95       	ret

00003c3e <__tablejump2__>:
    3c3e:	ee 0f       	add	r30, r30
    3c40:	ff 1f       	adc	r31, r31
    3c42:	88 1f       	adc	r24, r24
    3c44:	8b bf       	out	0x3b, r24	; 59
    3c46:	07 90       	elpm	r0, Z+
    3c48:	f6 91       	elpm	r31, Z
    3c4a:	e0 2d       	mov	r30, r0
    3c4c:	19 94       	eijmp

00003c4e <malloc>:
    3c4e:	0f 93       	push	r16
    3c50:	1f 93       	push	r17
    3c52:	cf 93       	push	r28
    3c54:	df 93       	push	r29
    3c56:	82 30       	cpi	r24, 0x02	; 2
    3c58:	91 05       	cpc	r25, r1
    3c5a:	10 f4       	brcc	.+4      	; 0x3c60 <malloc+0x12>
    3c5c:	82 e0       	ldi	r24, 0x02	; 2
    3c5e:	90 e0       	ldi	r25, 0x00	; 0
    3c60:	e0 91 e2 12 	lds	r30, 0x12E2	; 0x8012e2 <__flp>
    3c64:	f0 91 e3 12 	lds	r31, 0x12E3	; 0x8012e3 <__flp+0x1>
    3c68:	20 e0       	ldi	r18, 0x00	; 0
    3c6a:	30 e0       	ldi	r19, 0x00	; 0
    3c6c:	a0 e0       	ldi	r26, 0x00	; 0
    3c6e:	b0 e0       	ldi	r27, 0x00	; 0
    3c70:	30 97       	sbiw	r30, 0x00	; 0
    3c72:	19 f1       	breq	.+70     	; 0x3cba <malloc+0x6c>
    3c74:	40 81       	ld	r20, Z
    3c76:	51 81       	ldd	r21, Z+1	; 0x01
    3c78:	02 81       	ldd	r16, Z+2	; 0x02
    3c7a:	13 81       	ldd	r17, Z+3	; 0x03
    3c7c:	48 17       	cp	r20, r24
    3c7e:	59 07       	cpc	r21, r25
    3c80:	c8 f0       	brcs	.+50     	; 0x3cb4 <malloc+0x66>
    3c82:	84 17       	cp	r24, r20
    3c84:	95 07       	cpc	r25, r21
    3c86:	69 f4       	brne	.+26     	; 0x3ca2 <malloc+0x54>
    3c88:	10 97       	sbiw	r26, 0x00	; 0
    3c8a:	31 f0       	breq	.+12     	; 0x3c98 <malloc+0x4a>
    3c8c:	12 96       	adiw	r26, 0x02	; 2
    3c8e:	0c 93       	st	X, r16
    3c90:	12 97       	sbiw	r26, 0x02	; 2
    3c92:	13 96       	adiw	r26, 0x03	; 3
    3c94:	1c 93       	st	X, r17
    3c96:	27 c0       	rjmp	.+78     	; 0x3ce6 <malloc+0x98>
    3c98:	00 93 e2 12 	sts	0x12E2, r16	; 0x8012e2 <__flp>
    3c9c:	10 93 e3 12 	sts	0x12E3, r17	; 0x8012e3 <__flp+0x1>
    3ca0:	22 c0       	rjmp	.+68     	; 0x3ce6 <malloc+0x98>
    3ca2:	21 15       	cp	r18, r1
    3ca4:	31 05       	cpc	r19, r1
    3ca6:	19 f0       	breq	.+6      	; 0x3cae <malloc+0x60>
    3ca8:	42 17       	cp	r20, r18
    3caa:	53 07       	cpc	r21, r19
    3cac:	18 f4       	brcc	.+6      	; 0x3cb4 <malloc+0x66>
    3cae:	9a 01       	movw	r18, r20
    3cb0:	bd 01       	movw	r22, r26
    3cb2:	ef 01       	movw	r28, r30
    3cb4:	df 01       	movw	r26, r30
    3cb6:	f8 01       	movw	r30, r16
    3cb8:	db cf       	rjmp	.-74     	; 0x3c70 <malloc+0x22>
    3cba:	21 15       	cp	r18, r1
    3cbc:	31 05       	cpc	r19, r1
    3cbe:	f9 f0       	breq	.+62     	; 0x3cfe <malloc+0xb0>
    3cc0:	28 1b       	sub	r18, r24
    3cc2:	39 0b       	sbc	r19, r25
    3cc4:	24 30       	cpi	r18, 0x04	; 4
    3cc6:	31 05       	cpc	r19, r1
    3cc8:	80 f4       	brcc	.+32     	; 0x3cea <malloc+0x9c>
    3cca:	8a 81       	ldd	r24, Y+2	; 0x02
    3ccc:	9b 81       	ldd	r25, Y+3	; 0x03
    3cce:	61 15       	cp	r22, r1
    3cd0:	71 05       	cpc	r23, r1
    3cd2:	21 f0       	breq	.+8      	; 0x3cdc <malloc+0x8e>
    3cd4:	fb 01       	movw	r30, r22
    3cd6:	93 83       	std	Z+3, r25	; 0x03
    3cd8:	82 83       	std	Z+2, r24	; 0x02
    3cda:	04 c0       	rjmp	.+8      	; 0x3ce4 <malloc+0x96>
    3cdc:	90 93 e3 12 	sts	0x12E3, r25	; 0x8012e3 <__flp+0x1>
    3ce0:	80 93 e2 12 	sts	0x12E2, r24	; 0x8012e2 <__flp>
    3ce4:	fe 01       	movw	r30, r28
    3ce6:	32 96       	adiw	r30, 0x02	; 2
    3ce8:	44 c0       	rjmp	.+136    	; 0x3d72 <malloc+0x124>
    3cea:	fe 01       	movw	r30, r28
    3cec:	e2 0f       	add	r30, r18
    3cee:	f3 1f       	adc	r31, r19
    3cf0:	81 93       	st	Z+, r24
    3cf2:	91 93       	st	Z+, r25
    3cf4:	22 50       	subi	r18, 0x02	; 2
    3cf6:	31 09       	sbc	r19, r1
    3cf8:	39 83       	std	Y+1, r19	; 0x01
    3cfa:	28 83       	st	Y, r18
    3cfc:	3a c0       	rjmp	.+116    	; 0x3d72 <malloc+0x124>
    3cfe:	20 91 e0 12 	lds	r18, 0x12E0	; 0x8012e0 <__brkval>
    3d02:	30 91 e1 12 	lds	r19, 0x12E1	; 0x8012e1 <__brkval+0x1>
    3d06:	23 2b       	or	r18, r19
    3d08:	41 f4       	brne	.+16     	; 0x3d1a <malloc+0xcc>
    3d0a:	20 91 02 02 	lds	r18, 0x0202	; 0x800202 <__malloc_heap_start>
    3d0e:	30 91 03 02 	lds	r19, 0x0203	; 0x800203 <__malloc_heap_start+0x1>
    3d12:	30 93 e1 12 	sts	0x12E1, r19	; 0x8012e1 <__brkval+0x1>
    3d16:	20 93 e0 12 	sts	0x12E0, r18	; 0x8012e0 <__brkval>
    3d1a:	20 91 00 02 	lds	r18, 0x0200	; 0x800200 <__DATA_REGION_ORIGIN__>
    3d1e:	30 91 01 02 	lds	r19, 0x0201	; 0x800201 <__DATA_REGION_ORIGIN__+0x1>
    3d22:	21 15       	cp	r18, r1
    3d24:	31 05       	cpc	r19, r1
    3d26:	41 f4       	brne	.+16     	; 0x3d38 <malloc+0xea>
    3d28:	2d b7       	in	r18, 0x3d	; 61
    3d2a:	3e b7       	in	r19, 0x3e	; 62
    3d2c:	40 91 04 02 	lds	r20, 0x0204	; 0x800204 <__malloc_margin>
    3d30:	50 91 05 02 	lds	r21, 0x0205	; 0x800205 <__malloc_margin+0x1>
    3d34:	24 1b       	sub	r18, r20
    3d36:	35 0b       	sbc	r19, r21
    3d38:	e0 91 e0 12 	lds	r30, 0x12E0	; 0x8012e0 <__brkval>
    3d3c:	f0 91 e1 12 	lds	r31, 0x12E1	; 0x8012e1 <__brkval+0x1>
    3d40:	e2 17       	cp	r30, r18
    3d42:	f3 07       	cpc	r31, r19
    3d44:	a0 f4       	brcc	.+40     	; 0x3d6e <malloc+0x120>
    3d46:	2e 1b       	sub	r18, r30
    3d48:	3f 0b       	sbc	r19, r31
    3d4a:	28 17       	cp	r18, r24
    3d4c:	39 07       	cpc	r19, r25
    3d4e:	78 f0       	brcs	.+30     	; 0x3d6e <malloc+0x120>
    3d50:	ac 01       	movw	r20, r24
    3d52:	4e 5f       	subi	r20, 0xFE	; 254
    3d54:	5f 4f       	sbci	r21, 0xFF	; 255
    3d56:	24 17       	cp	r18, r20
    3d58:	35 07       	cpc	r19, r21
    3d5a:	48 f0       	brcs	.+18     	; 0x3d6e <malloc+0x120>
    3d5c:	4e 0f       	add	r20, r30
    3d5e:	5f 1f       	adc	r21, r31
    3d60:	50 93 e1 12 	sts	0x12E1, r21	; 0x8012e1 <__brkval+0x1>
    3d64:	40 93 e0 12 	sts	0x12E0, r20	; 0x8012e0 <__brkval>
    3d68:	81 93       	st	Z+, r24
    3d6a:	91 93       	st	Z+, r25
    3d6c:	02 c0       	rjmp	.+4      	; 0x3d72 <malloc+0x124>
    3d6e:	e0 e0       	ldi	r30, 0x00	; 0
    3d70:	f0 e0       	ldi	r31, 0x00	; 0
    3d72:	cf 01       	movw	r24, r30
    3d74:	df 91       	pop	r29
    3d76:	cf 91       	pop	r28
    3d78:	1f 91       	pop	r17
    3d7a:	0f 91       	pop	r16
    3d7c:	08 95       	ret

00003d7e <free>:
    3d7e:	cf 93       	push	r28
    3d80:	df 93       	push	r29
    3d82:	00 97       	sbiw	r24, 0x00	; 0
    3d84:	09 f4       	brne	.+2      	; 0x3d88 <free+0xa>
    3d86:	81 c0       	rjmp	.+258    	; 0x3e8a <free+0x10c>
    3d88:	fc 01       	movw	r30, r24
    3d8a:	32 97       	sbiw	r30, 0x02	; 2
    3d8c:	13 82       	std	Z+3, r1	; 0x03
    3d8e:	12 82       	std	Z+2, r1	; 0x02
    3d90:	a0 91 e2 12 	lds	r26, 0x12E2	; 0x8012e2 <__flp>
    3d94:	b0 91 e3 12 	lds	r27, 0x12E3	; 0x8012e3 <__flp+0x1>
    3d98:	10 97       	sbiw	r26, 0x00	; 0
    3d9a:	81 f4       	brne	.+32     	; 0x3dbc <free+0x3e>
    3d9c:	20 81       	ld	r18, Z
    3d9e:	31 81       	ldd	r19, Z+1	; 0x01
    3da0:	82 0f       	add	r24, r18
    3da2:	93 1f       	adc	r25, r19
    3da4:	20 91 e0 12 	lds	r18, 0x12E0	; 0x8012e0 <__brkval>
    3da8:	30 91 e1 12 	lds	r19, 0x12E1	; 0x8012e1 <__brkval+0x1>
    3dac:	28 17       	cp	r18, r24
    3dae:	39 07       	cpc	r19, r25
    3db0:	51 f5       	brne	.+84     	; 0x3e06 <free+0x88>
    3db2:	f0 93 e1 12 	sts	0x12E1, r31	; 0x8012e1 <__brkval+0x1>
    3db6:	e0 93 e0 12 	sts	0x12E0, r30	; 0x8012e0 <__brkval>
    3dba:	67 c0       	rjmp	.+206    	; 0x3e8a <free+0x10c>
    3dbc:	ed 01       	movw	r28, r26
    3dbe:	20 e0       	ldi	r18, 0x00	; 0
    3dc0:	30 e0       	ldi	r19, 0x00	; 0
    3dc2:	ce 17       	cp	r28, r30
    3dc4:	df 07       	cpc	r29, r31
    3dc6:	40 f4       	brcc	.+16     	; 0x3dd8 <free+0x5a>
    3dc8:	4a 81       	ldd	r20, Y+2	; 0x02
    3dca:	5b 81       	ldd	r21, Y+3	; 0x03
    3dcc:	9e 01       	movw	r18, r28
    3dce:	41 15       	cp	r20, r1
    3dd0:	51 05       	cpc	r21, r1
    3dd2:	f1 f0       	breq	.+60     	; 0x3e10 <free+0x92>
    3dd4:	ea 01       	movw	r28, r20
    3dd6:	f5 cf       	rjmp	.-22     	; 0x3dc2 <free+0x44>
    3dd8:	d3 83       	std	Z+3, r29	; 0x03
    3dda:	c2 83       	std	Z+2, r28	; 0x02
    3ddc:	40 81       	ld	r20, Z
    3dde:	51 81       	ldd	r21, Z+1	; 0x01
    3de0:	84 0f       	add	r24, r20
    3de2:	95 1f       	adc	r25, r21
    3de4:	c8 17       	cp	r28, r24
    3de6:	d9 07       	cpc	r29, r25
    3de8:	59 f4       	brne	.+22     	; 0x3e00 <free+0x82>
    3dea:	88 81       	ld	r24, Y
    3dec:	99 81       	ldd	r25, Y+1	; 0x01
    3dee:	84 0f       	add	r24, r20
    3df0:	95 1f       	adc	r25, r21
    3df2:	02 96       	adiw	r24, 0x02	; 2
    3df4:	91 83       	std	Z+1, r25	; 0x01
    3df6:	80 83       	st	Z, r24
    3df8:	8a 81       	ldd	r24, Y+2	; 0x02
    3dfa:	9b 81       	ldd	r25, Y+3	; 0x03
    3dfc:	93 83       	std	Z+3, r25	; 0x03
    3dfe:	82 83       	std	Z+2, r24	; 0x02
    3e00:	21 15       	cp	r18, r1
    3e02:	31 05       	cpc	r19, r1
    3e04:	29 f4       	brne	.+10     	; 0x3e10 <free+0x92>
    3e06:	f0 93 e3 12 	sts	0x12E3, r31	; 0x8012e3 <__flp+0x1>
    3e0a:	e0 93 e2 12 	sts	0x12E2, r30	; 0x8012e2 <__flp>
    3e0e:	3d c0       	rjmp	.+122    	; 0x3e8a <free+0x10c>
    3e10:	e9 01       	movw	r28, r18
    3e12:	fb 83       	std	Y+3, r31	; 0x03
    3e14:	ea 83       	std	Y+2, r30	; 0x02
    3e16:	49 91       	ld	r20, Y+
    3e18:	59 91       	ld	r21, Y+
    3e1a:	c4 0f       	add	r28, r20
    3e1c:	d5 1f       	adc	r29, r21
    3e1e:	ec 17       	cp	r30, r28
    3e20:	fd 07       	cpc	r31, r29
    3e22:	61 f4       	brne	.+24     	; 0x3e3c <free+0xbe>
    3e24:	80 81       	ld	r24, Z
    3e26:	91 81       	ldd	r25, Z+1	; 0x01
    3e28:	84 0f       	add	r24, r20
    3e2a:	95 1f       	adc	r25, r21
    3e2c:	02 96       	adiw	r24, 0x02	; 2
    3e2e:	e9 01       	movw	r28, r18
    3e30:	99 83       	std	Y+1, r25	; 0x01
    3e32:	88 83       	st	Y, r24
    3e34:	82 81       	ldd	r24, Z+2	; 0x02
    3e36:	93 81       	ldd	r25, Z+3	; 0x03
    3e38:	9b 83       	std	Y+3, r25	; 0x03
    3e3a:	8a 83       	std	Y+2, r24	; 0x02
    3e3c:	e0 e0       	ldi	r30, 0x00	; 0
    3e3e:	f0 e0       	ldi	r31, 0x00	; 0
    3e40:	12 96       	adiw	r26, 0x02	; 2
    3e42:	8d 91       	ld	r24, X+
    3e44:	9c 91       	ld	r25, X
    3e46:	13 97       	sbiw	r26, 0x03	; 3
    3e48:	00 97       	sbiw	r24, 0x00	; 0
    3e4a:	19 f0       	breq	.+6      	; 0x3e52 <free+0xd4>
    3e4c:	fd 01       	movw	r30, r26
    3e4e:	dc 01       	movw	r26, r24
    3e50:	f7 cf       	rjmp	.-18     	; 0x3e40 <free+0xc2>
    3e52:	8d 91       	ld	r24, X+
    3e54:	9c 91       	ld	r25, X
    3e56:	11 97       	sbiw	r26, 0x01	; 1
    3e58:	9d 01       	movw	r18, r26
    3e5a:	2e 5f       	subi	r18, 0xFE	; 254
    3e5c:	3f 4f       	sbci	r19, 0xFF	; 255
    3e5e:	82 0f       	add	r24, r18
    3e60:	93 1f       	adc	r25, r19
    3e62:	20 91 e0 12 	lds	r18, 0x12E0	; 0x8012e0 <__brkval>
    3e66:	30 91 e1 12 	lds	r19, 0x12E1	; 0x8012e1 <__brkval+0x1>
    3e6a:	28 17       	cp	r18, r24
    3e6c:	39 07       	cpc	r19, r25
    3e6e:	69 f4       	brne	.+26     	; 0x3e8a <free+0x10c>
    3e70:	30 97       	sbiw	r30, 0x00	; 0
    3e72:	29 f4       	brne	.+10     	; 0x3e7e <free+0x100>
    3e74:	10 92 e3 12 	sts	0x12E3, r1	; 0x8012e3 <__flp+0x1>
    3e78:	10 92 e2 12 	sts	0x12E2, r1	; 0x8012e2 <__flp>
    3e7c:	02 c0       	rjmp	.+4      	; 0x3e82 <free+0x104>
    3e7e:	13 82       	std	Z+3, r1	; 0x03
    3e80:	12 82       	std	Z+2, r1	; 0x02
    3e82:	b0 93 e1 12 	sts	0x12E1, r27	; 0x8012e1 <__brkval+0x1>
    3e86:	a0 93 e0 12 	sts	0x12E0, r26	; 0x8012e0 <__brkval>
    3e8a:	df 91       	pop	r29
    3e8c:	cf 91       	pop	r28
    3e8e:	08 95       	ret

00003e90 <memset>:
    3e90:	dc 01       	movw	r26, r24
    3e92:	01 c0       	rjmp	.+2      	; 0x3e96 <memset+0x6>
    3e94:	6d 93       	st	X+, r22
    3e96:	41 50       	subi	r20, 0x01	; 1
    3e98:	50 40       	sbci	r21, 0x00	; 0
    3e9a:	e0 f7       	brcc	.-8      	; 0x3e94 <memset+0x4>
    3e9c:	08 95       	ret

00003e9e <strncpy>:
    3e9e:	fb 01       	movw	r30, r22
    3ea0:	dc 01       	movw	r26, r24
    3ea2:	41 50       	subi	r20, 0x01	; 1
    3ea4:	50 40       	sbci	r21, 0x00	; 0
    3ea6:	48 f0       	brcs	.+18     	; 0x3eba <strncpy+0x1c>
    3ea8:	01 90       	ld	r0, Z+
    3eaa:	0d 92       	st	X+, r0
    3eac:	00 20       	and	r0, r0
    3eae:	c9 f7       	brne	.-14     	; 0x3ea2 <strncpy+0x4>
    3eb0:	01 c0       	rjmp	.+2      	; 0x3eb4 <strncpy+0x16>
    3eb2:	1d 92       	st	X+, r1
    3eb4:	41 50       	subi	r20, 0x01	; 1
    3eb6:	50 40       	sbci	r21, 0x00	; 0
    3eb8:	e0 f7       	brcc	.-8      	; 0x3eb2 <strncpy+0x14>
    3eba:	08 95       	ret

00003ebc <__do_global_dtors>:
    3ebc:	10 e0       	ldi	r17, 0x00	; 0
    3ebe:	c3 e7       	ldi	r28, 0x73	; 115
    3ec0:	d0 e0       	ldi	r29, 0x00	; 0
    3ec2:	00 e0       	ldi	r16, 0x00	; 0
    3ec4:	05 c0       	rjmp	.+10     	; 0x3ed0 <__do_global_dtors+0x14>
    3ec6:	80 2f       	mov	r24, r16
    3ec8:	fe 01       	movw	r30, r28
    3eca:	b9 de       	rcall	.-654    	; 0x3c3e <__tablejump2__>
    3ecc:	21 96       	adiw	r28, 0x01	; 1
    3ece:	01 1d       	adc	r16, r1
    3ed0:	c4 37       	cpi	r28, 0x74	; 116
    3ed2:	d1 07       	cpc	r29, r17
    3ed4:	80 e0       	ldi	r24, 0x00	; 0
    3ed6:	08 07       	cpc	r16, r24
    3ed8:	b1 f7       	brne	.-20     	; 0x3ec6 <__do_global_dtors+0xa>
    3eda:	f8 94       	cli

00003edc <__stop_program>:
    3edc:	ff cf       	rjmp	.-2      	; 0x3edc <__stop_program>
