
RobotSorter.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000008e  00800200  00003092  00003126  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00003092  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000006a5  0080028e  0080028e  000031b4  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000031b4  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  000031e4  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000006c8  00000000  00000000  00003224  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000091b0  00000000  00000000  000038ec  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000037b9  00000000  00000000  0000ca9c  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00003ddd  00000000  00000000  00010255  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  0000138c  00000000  00000000  00014034  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00002460  00000000  00000000  000153c0  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000047fb  00000000  00000000  00017820  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000005b0  00000000  00000000  0001c01b  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	eb c0       	rjmp	.+470    	; 0x1d8 <__dtors_end>
       2:	00 00       	nop
       4:	19 c1       	rjmp	.+562    	; 0x238 <__bad_interrupt>
       6:	00 00       	nop
       8:	17 c1       	rjmp	.+558    	; 0x238 <__bad_interrupt>
       a:	00 00       	nop
       c:	15 c1       	rjmp	.+554    	; 0x238 <__bad_interrupt>
       e:	00 00       	nop
      10:	13 c1       	rjmp	.+550    	; 0x238 <__bad_interrupt>
      12:	00 00       	nop
      14:	0c 94 15 14 	jmp	0x282a	; 0x282a <__vector_5>
      18:	0f c1       	rjmp	.+542    	; 0x238 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	0d c1       	rjmp	.+538    	; 0x238 <__bad_interrupt>
      1e:	00 00       	nop
      20:	0b c1       	rjmp	.+534    	; 0x238 <__bad_interrupt>
      22:	00 00       	nop
      24:	09 c1       	rjmp	.+530    	; 0x238 <__bad_interrupt>
      26:	00 00       	nop
      28:	07 c1       	rjmp	.+526    	; 0x238 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	05 c1       	rjmp	.+522    	; 0x238 <__bad_interrupt>
      2e:	00 00       	nop
      30:	03 c1       	rjmp	.+518    	; 0x238 <__bad_interrupt>
      32:	00 00       	nop
      34:	01 c1       	rjmp	.+514    	; 0x238 <__bad_interrupt>
      36:	00 00       	nop
      38:	ff c0       	rjmp	.+510    	; 0x238 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	fd c0       	rjmp	.+506    	; 0x238 <__bad_interrupt>
      3e:	00 00       	nop
      40:	fb c0       	rjmp	.+502    	; 0x238 <__bad_interrupt>
      42:	00 00       	nop
      44:	f9 c0       	rjmp	.+498    	; 0x238 <__bad_interrupt>
      46:	00 00       	nop
      48:	f7 c0       	rjmp	.+494    	; 0x238 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	f5 c0       	rjmp	.+490    	; 0x238 <__bad_interrupt>
      4e:	00 00       	nop
      50:	f3 c0       	rjmp	.+486    	; 0x238 <__bad_interrupt>
      52:	00 00       	nop
      54:	0c 94 91 0e 	jmp	0x1d22	; 0x1d22 <__vector_21>
      58:	ef c0       	rjmp	.+478    	; 0x238 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	ed c0       	rjmp	.+474    	; 0x238 <__bad_interrupt>
      5e:	00 00       	nop
      60:	eb c0       	rjmp	.+470    	; 0x238 <__bad_interrupt>
      62:	00 00       	nop
      64:	e9 c0       	rjmp	.+466    	; 0x238 <__bad_interrupt>
      66:	00 00       	nop
      68:	e7 c0       	rjmp	.+462    	; 0x238 <__bad_interrupt>
      6a:	00 00       	nop
      6c:	e5 c0       	rjmp	.+458    	; 0x238 <__bad_interrupt>
      6e:	00 00       	nop
      70:	e3 c0       	rjmp	.+454    	; 0x238 <__bad_interrupt>
      72:	00 00       	nop
      74:	e1 c0       	rjmp	.+450    	; 0x238 <__bad_interrupt>
      76:	00 00       	nop
      78:	df c0       	rjmp	.+446    	; 0x238 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	dd c0       	rjmp	.+442    	; 0x238 <__bad_interrupt>
      7e:	00 00       	nop
      80:	db c0       	rjmp	.+438    	; 0x238 <__bad_interrupt>
      82:	00 00       	nop
      84:	d9 c0       	rjmp	.+434    	; 0x238 <__bad_interrupt>
      86:	00 00       	nop
      88:	d7 c0       	rjmp	.+430    	; 0x238 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	d5 c0       	rjmp	.+426    	; 0x238 <__bad_interrupt>
      8e:	00 00       	nop
      90:	d3 c0       	rjmp	.+422    	; 0x238 <__bad_interrupt>
      92:	00 00       	nop
      94:	d1 c0       	rjmp	.+418    	; 0x238 <__bad_interrupt>
      96:	00 00       	nop
      98:	cf c0       	rjmp	.+414    	; 0x238 <__bad_interrupt>
      9a:	00 00       	nop
      9c:	cd c0       	rjmp	.+410    	; 0x238 <__bad_interrupt>
      9e:	00 00       	nop
      a0:	cb c0       	rjmp	.+406    	; 0x238 <__bad_interrupt>
      a2:	00 00       	nop
      a4:	df c2       	rjmp	.+1470   	; 0x664 <__vector_41>
      a6:	00 00       	nop
      a8:	c7 c0       	rjmp	.+398    	; 0x238 <__bad_interrupt>
      aa:	00 00       	nop
      ac:	c5 c0       	rjmp	.+394    	; 0x238 <__bad_interrupt>
      ae:	00 00       	nop
      b0:	c3 c0       	rjmp	.+390    	; 0x238 <__bad_interrupt>
      b2:	00 00       	nop
      b4:	b2 c2       	rjmp	.+1380   	; 0x61a <__vector_45>
      b6:	00 00       	nop
      b8:	bf c0       	rjmp	.+382    	; 0x238 <__bad_interrupt>
      ba:	00 00       	nop
      bc:	bd c0       	rjmp	.+378    	; 0x238 <__bad_interrupt>
      be:	00 00       	nop
      c0:	bb c0       	rjmp	.+374    	; 0x238 <__bad_interrupt>
      c2:	00 00       	nop
      c4:	b9 c0       	rjmp	.+370    	; 0x238 <__bad_interrupt>
      c6:	00 00       	nop
      c8:	b7 c0       	rjmp	.+366    	; 0x238 <__bad_interrupt>
      ca:	00 00       	nop
      cc:	b5 c0       	rjmp	.+362    	; 0x238 <__bad_interrupt>
      ce:	00 00       	nop
      d0:	b3 c0       	rjmp	.+358    	; 0x238 <__bad_interrupt>
      d2:	00 00       	nop
      d4:	b1 c0       	rjmp	.+354    	; 0x238 <__bad_interrupt>
      d6:	00 00       	nop
      d8:	af c0       	rjmp	.+350    	; 0x238 <__bad_interrupt>
      da:	00 00       	nop
      dc:	ad c0       	rjmp	.+346    	; 0x238 <__bad_interrupt>
      de:	00 00       	nop
      e0:	ab c0       	rjmp	.+342    	; 0x238 <__bad_interrupt>
      e2:	00 00       	nop
      e4:	24 04       	cpc	r2, r4
      e6:	20 04       	cpc	r2, r0
      e8:	28 04       	cpc	r2, r8
      ea:	26 04       	cpc	r2, r6
      ec:	28 04       	cpc	r2, r8
      ee:	28 04       	cpc	r2, r8
      f0:	28 04       	cpc	r2, r8
      f2:	22 04       	cpc	r2, r2
      f4:	28 04       	cpc	r2, r8
      f6:	28 04       	cpc	r2, r8
      f8:	28 04       	cpc	r2, r8
      fa:	28 04       	cpc	r2, r8
      fc:	28 04       	cpc	r2, r8
      fe:	28 04       	cpc	r2, r8
     100:	28 04       	cpc	r2, r8
     102:	28 04       	cpc	r2, r8
     104:	1c 04       	cpc	r1, r12
     106:	18 04       	cpc	r1, r8
     108:	28 04       	cpc	r2, r8
     10a:	1e 04       	cpc	r1, r14
     10c:	28 04       	cpc	r2, r8
     10e:	28 04       	cpc	r2, r8
     110:	28 04       	cpc	r2, r8
     112:	1a 04       	cpc	r1, r10
     114:	28 04       	cpc	r2, r8
     116:	28 04       	cpc	r2, r8
     118:	28 04       	cpc	r2, r8
     11a:	28 04       	cpc	r2, r8
     11c:	28 04       	cpc	r2, r8
     11e:	28 04       	cpc	r2, r8
     120:	28 04       	cpc	r2, r8
     122:	28 04       	cpc	r2, r8
     124:	28 04       	cpc	r2, r8
     126:	28 04       	cpc	r2, r8
     128:	28 04       	cpc	r2, r8
     12a:	28 04       	cpc	r2, r8
     12c:	28 04       	cpc	r2, r8
     12e:	28 04       	cpc	r2, r8
     130:	28 04       	cpc	r2, r8
     132:	28 04       	cpc	r2, r8
     134:	28 04       	cpc	r2, r8
     136:	28 04       	cpc	r2, r8
     138:	28 04       	cpc	r2, r8
     13a:	28 04       	cpc	r2, r8
     13c:	28 04       	cpc	r2, r8
     13e:	28 04       	cpc	r2, r8
     140:	28 04       	cpc	r2, r8
     142:	28 04       	cpc	r2, r8
     144:	0c 04       	cpc	r0, r12
     146:	0a 04       	cpc	r0, r10
     148:	28 04       	cpc	r2, r8
     14a:	0e 04       	cpc	r0, r14
     14c:	28 04       	cpc	r2, r8
     14e:	28 04       	cpc	r2, r8
     150:	28 04       	cpc	r2, r8
     152:	2a 04       	cpc	r2, r10
     154:	28 04       	cpc	r2, r8
     156:	28 04       	cpc	r2, r8
     158:	28 04       	cpc	r2, r8
     15a:	28 04       	cpc	r2, r8
     15c:	28 04       	cpc	r2, r8
     15e:	28 04       	cpc	r2, r8
     160:	28 04       	cpc	r2, r8
     162:	28 04       	cpc	r2, r8
     164:	28 04       	cpc	r2, r8
     166:	28 04       	cpc	r2, r8
     168:	28 04       	cpc	r2, r8
     16a:	28 04       	cpc	r2, r8
     16c:	28 04       	cpc	r2, r8
     16e:	28 04       	cpc	r2, r8
     170:	28 04       	cpc	r2, r8
     172:	28 04       	cpc	r2, r8
     174:	28 04       	cpc	r2, r8
     176:	28 04       	cpc	r2, r8
     178:	28 04       	cpc	r2, r8
     17a:	28 04       	cpc	r2, r8
     17c:	28 04       	cpc	r2, r8
     17e:	28 04       	cpc	r2, r8
     180:	28 04       	cpc	r2, r8
     182:	28 04       	cpc	r2, r8
     184:	28 04       	cpc	r2, r8
     186:	28 04       	cpc	r2, r8
     188:	28 04       	cpc	r2, r8
     18a:	28 04       	cpc	r2, r8
     18c:	28 04       	cpc	r2, r8
     18e:	28 04       	cpc	r2, r8
     190:	28 04       	cpc	r2, r8
     192:	28 04       	cpc	r2, r8
     194:	28 04       	cpc	r2, r8
     196:	28 04       	cpc	r2, r8
     198:	28 04       	cpc	r2, r8
     19a:	28 04       	cpc	r2, r8
     19c:	28 04       	cpc	r2, r8
     19e:	28 04       	cpc	r2, r8
     1a0:	28 04       	cpc	r2, r8
     1a2:	28 04       	cpc	r2, r8
     1a4:	28 04       	cpc	r2, r8
     1a6:	28 04       	cpc	r2, r8
     1a8:	28 04       	cpc	r2, r8
     1aa:	28 04       	cpc	r2, r8
     1ac:	28 04       	cpc	r2, r8
     1ae:	28 04       	cpc	r2, r8
     1b0:	28 04       	cpc	r2, r8
     1b2:	28 04       	cpc	r2, r8
     1b4:	28 04       	cpc	r2, r8
     1b6:	28 04       	cpc	r2, r8
     1b8:	28 04       	cpc	r2, r8
     1ba:	28 04       	cpc	r2, r8
     1bc:	28 04       	cpc	r2, r8
     1be:	28 04       	cpc	r2, r8
     1c0:	28 04       	cpc	r2, r8
     1c2:	28 04       	cpc	r2, r8
     1c4:	14 04       	cpc	r1, r4
     1c6:	10 04       	cpc	r1, r0
     1c8:	28 04       	cpc	r2, r8
     1ca:	16 04       	cpc	r1, r6
     1cc:	28 04       	cpc	r2, r8
     1ce:	28 04       	cpc	r2, r8
     1d0:	28 04       	cpc	r2, r8
     1d2:	12 04       	cpc	r1, r2

000001d4 <__ctors_start>:
     1d4:	44 05       	cpc	r20, r4

000001d6 <__ctors_end>:
     1d6:	4a 05       	cpc	r20, r10

000001d8 <__dtors_end>:
     1d8:	11 24       	eor	r1, r1
     1da:	1f be       	out	0x3f, r1	; 63
     1dc:	cf ef       	ldi	r28, 0xFF	; 255
     1de:	d1 e2       	ldi	r29, 0x21	; 33
     1e0:	de bf       	out	0x3e, r29	; 62
     1e2:	cd bf       	out	0x3d, r28	; 61
     1e4:	00 e0       	ldi	r16, 0x00	; 0
     1e6:	0c bf       	out	0x3c, r16	; 60

000001e8 <__do_copy_data>:
     1e8:	12 e0       	ldi	r17, 0x02	; 2
     1ea:	a0 e0       	ldi	r26, 0x00	; 0
     1ec:	b2 e0       	ldi	r27, 0x02	; 2
     1ee:	e2 e9       	ldi	r30, 0x92	; 146
     1f0:	f0 e3       	ldi	r31, 0x30	; 48
     1f2:	00 e0       	ldi	r16, 0x00	; 0
     1f4:	0b bf       	out	0x3b, r16	; 59
     1f6:	02 c0       	rjmp	.+4      	; 0x1fc <__do_copy_data+0x14>
     1f8:	07 90       	elpm	r0, Z+
     1fa:	0d 92       	st	X+, r0
     1fc:	ae 38       	cpi	r26, 0x8E	; 142
     1fe:	b1 07       	cpc	r27, r17
     200:	d9 f7       	brne	.-10     	; 0x1f8 <__do_copy_data+0x10>

00000202 <__do_clear_bss>:
     202:	29 e0       	ldi	r18, 0x09	; 9
     204:	ae e8       	ldi	r26, 0x8E	; 142
     206:	b2 e0       	ldi	r27, 0x02	; 2
     208:	01 c0       	rjmp	.+2      	; 0x20c <.do_clear_bss_start>

0000020a <.do_clear_bss_loop>:
     20a:	1d 92       	st	X+, r1

0000020c <.do_clear_bss_start>:
     20c:	a3 33       	cpi	r26, 0x33	; 51
     20e:	b2 07       	cpc	r27, r18
     210:	e1 f7       	brne	.-8      	; 0x20a <.do_clear_bss_loop>

00000212 <__do_global_ctors>:
     212:	10 e0       	ldi	r17, 0x00	; 0
     214:	cb ee       	ldi	r28, 0xEB	; 235
     216:	d0 e0       	ldi	r29, 0x00	; 0
     218:	00 e0       	ldi	r16, 0x00	; 0
     21a:	06 c0       	rjmp	.+12     	; 0x228 <__do_global_ctors+0x16>
     21c:	21 97       	sbiw	r28, 0x01	; 1
     21e:	01 09       	sbc	r16, r1
     220:	80 2f       	mov	r24, r16
     222:	fe 01       	movw	r30, r28
     224:	0e 94 ea 16 	call	0x2dd4	; 0x2dd4 <__tablejump2__>
     228:	ca 3e       	cpi	r28, 0xEA	; 234
     22a:	d1 07       	cpc	r29, r17
     22c:	80 e0       	ldi	r24, 0x00	; 0
     22e:	08 07       	cpc	r16, r24
     230:	a9 f7       	brne	.-22     	; 0x21c <__do_global_ctors+0xa>
     232:	0c d4       	rcall	.+2072   	; 0xa4c <main>
     234:	0c 94 38 18 	jmp	0x3070	; 0x3070 <__do_global_dtors>

00000238 <__bad_interrupt>:
     238:	e3 ce       	rjmp	.-570    	; 0x0 <__vectors>

0000023a <_ZN5ColorC1Ev>:
}

uint8_t Color::getColorIndex( void )
{
	return _colorIndex;
}
     23a:	08 95       	ret

0000023c <_ZN5ColorD1Ev>:
     23c:	08 95       	ret

0000023e <_ZN5Color12getRedPeriodEv>:
     23e:	fc 01       	movw	r30, r24
     240:	80 81       	ld	r24, Z
     242:	91 81       	ldd	r25, Z+1	; 0x01
     244:	08 95       	ret

00000246 <_ZN5Color13getBluePeriodEv>:
     246:	fc 01       	movw	r30, r24
     248:	82 81       	ldd	r24, Z+2	; 0x02
     24a:	93 81       	ldd	r25, Z+3	; 0x03
     24c:	08 95       	ret

0000024e <_ZN5Color14getGreenPeriodEv>:
     24e:	fc 01       	movw	r30, r24
     250:	84 81       	ldd	r24, Z+4	; 0x04
     252:	95 81       	ldd	r25, Z+5	; 0x05
     254:	08 95       	ret

00000256 <_ZN5Color14getWhitePeriodEv>:
     256:	fc 01       	movw	r30, r24
     258:	86 81       	ldd	r24, Z+6	; 0x06
     25a:	97 81       	ldd	r25, Z+7	; 0x07
     25c:	08 95       	ret

0000025e <_ZN5Color12setRedPeriodEj>:

void Color::setRedPeriod( uint16_t redPeriod )
{
	_redPeriod = redPeriod;
     25e:	fc 01       	movw	r30, r24
     260:	71 83       	std	Z+1, r23	; 0x01
     262:	60 83       	st	Z, r22
     264:	08 95       	ret

00000266 <_ZN5Color13setBluePeriodEj>:
}

void Color::setBluePeriod( uint16_t bluePeriod )
{
	_bluePeriod = bluePeriod;
     266:	fc 01       	movw	r30, r24
     268:	73 83       	std	Z+3, r23	; 0x03
     26a:	62 83       	std	Z+2, r22	; 0x02
     26c:	08 95       	ret

0000026e <_ZN5Color14setGreenPeriodEj>:
}

void Color::setGreenPeriod( uint16_t greenPeriod )
{
	_greenPeriod = greenPeriod;
     26e:	fc 01       	movw	r30, r24
     270:	75 83       	std	Z+5, r23	; 0x05
     272:	64 83       	std	Z+4, r22	; 0x04
     274:	08 95       	ret

00000276 <_ZN5Color14setWhitePeriodEj>:
}

void Color::setWhitePeriod( uint16_t whitePeriod )
{
	_whitePeriod = whitePeriod;
     276:	fc 01       	movw	r30, r24
     278:	77 83       	std	Z+7, r23	; 0x07
     27a:	66 83       	std	Z+6, r22	; 0x06
     27c:	08 95       	ret

0000027e <_ZN5Color13setColorIndexEh>:
}

void Color::setColorIndex( uint8_t index )
{
	_colorIndex = index;
     27e:	fc 01       	movw	r30, r24
     280:	60 87       	std	Z+8, r22	; 0x08
     282:	08 95       	ret

00000284 <_ZN11ColorSensorD1Ev>:
	setFilter( noFilter );
	setFrequencyscaling( scaling );
}

// default destructor
ColorSensor::~ColorSensor()
     284:	0f 93       	push	r16
     286:	1f 93       	push	r17
     288:	cf 93       	push	r28
     28a:	df 93       	push	r29
     28c:	8c 01       	movw	r16, r24
     28e:	0f 5f       	subi	r16, 0xFF	; 255
     290:	1f 4f       	sbci	r17, 0xFF	; 255
     292:	51 f0       	breq	.+20     	; 0x2a8 <_ZN11ColorSensorD1Ev+0x24>
     294:	ec 01       	movw	r28, r24
     296:	c5 5a       	subi	r28, 0xA5	; 165
     298:	df 4f       	sbci	r29, 0xFF	; 255
     29a:	c0 17       	cp	r28, r16
     29c:	d1 07       	cpc	r29, r17
     29e:	21 f0       	breq	.+8      	; 0x2a8 <_ZN11ColorSensorD1Ev+0x24>
     2a0:	29 97       	sbiw	r28, 0x09	; 9
     2a2:	ce 01       	movw	r24, r28
     2a4:	cb df       	rcall	.-106    	; 0x23c <_ZN5ColorD1Ev>
     2a6:	f9 cf       	rjmp	.-14     	; 0x29a <_ZN11ColorSensorD1Ev+0x16>
{	
}
     2a8:	df 91       	pop	r29
     2aa:	cf 91       	pop	r28
     2ac:	1f 91       	pop	r17
     2ae:	0f 91       	pop	r16
     2b0:	08 95       	ret

000002b2 <_ZN11ColorSensor9setFilterE6Filter>:
	}
}

void ColorSensor::setFilter( Filter filter_ )
{
	switch ( filter_ )
     2b2:	61 30       	cpi	r22, 0x01	; 1
     2b4:	31 f0       	breq	.+12     	; 0x2c2 <_ZN11ColorSensor9setFilterE6Filter+0x10>
     2b6:	00 f1       	brcs	.+64     	; 0x2f8 <_ZN11ColorSensor9setFilterE6Filter+0x46>
     2b8:	62 30       	cpi	r22, 0x02	; 2
     2ba:	a9 f0       	breq	.+42     	; 0x2e6 <_ZN11ColorSensor9setFilterE6Filter+0x34>
     2bc:	63 30       	cpi	r22, 0x03	; 3
     2be:	51 f0       	breq	.+20     	; 0x2d4 <_ZN11ColorSensor9setFilterE6Filter+0x22>
     2c0:	08 95       	ret
	{
	case redFilter:
		COLORSENSOR_S2_PORT &= ~( COLORSENSOR_S2_PIN );
     2c2:	e8 e0       	ldi	r30, 0x08	; 8
     2c4:	f1 e0       	ldi	r31, 0x01	; 1
     2c6:	80 81       	ld	r24, Z
     2c8:	8a 7f       	andi	r24, 0xFA	; 250
     2ca:	80 83       	st	Z, r24
		COLORSENSOR_S3_PORT &= ~( COLORSENSOR_S3_PIN );
     2cc:	80 81       	ld	r24, Z
     2ce:	8b 7f       	andi	r24, 0xFB	; 251
     2d0:	80 83       	st	Z, r24
		break;
     2d2:	08 95       	ret

	case blueFilter:
		COLORSENSOR_S2_PORT &= ~( COLORSENSOR_S2_PIN );
     2d4:	e8 e0       	ldi	r30, 0x08	; 8
     2d6:	f1 e0       	ldi	r31, 0x01	; 1
     2d8:	80 81       	ld	r24, Z
     2da:	8a 7f       	andi	r24, 0xFA	; 250
     2dc:	80 83       	st	Z, r24
		COLORSENSOR_S3_PORT |= COLORSENSOR_S3_PIN;
     2de:	80 81       	ld	r24, Z
     2e0:	84 60       	ori	r24, 0x04	; 4
     2e2:	80 83       	st	Z, r24
		break;
     2e4:	08 95       	ret

	case greenFilter:
		COLORSENSOR_S2_PORT |= COLORSENSOR_S2_PIN;
     2e6:	e8 e0       	ldi	r30, 0x08	; 8
     2e8:	f1 e0       	ldi	r31, 0x01	; 1
     2ea:	80 81       	ld	r24, Z
     2ec:	85 60       	ori	r24, 0x05	; 5
     2ee:	80 83       	st	Z, r24
		COLORSENSOR_S3_PORT |= COLORSENSOR_S3_PIN;
     2f0:	80 81       	ld	r24, Z
     2f2:	84 60       	ori	r24, 0x04	; 4
     2f4:	80 83       	st	Z, r24
		break;
     2f6:	08 95       	ret

	case noFilter:
		COLORSENSOR_S2_PORT |= COLORSENSOR_S2_PIN;
     2f8:	e8 e0       	ldi	r30, 0x08	; 8
     2fa:	f1 e0       	ldi	r31, 0x01	; 1
     2fc:	80 81       	ld	r24, Z
     2fe:	85 60       	ori	r24, 0x05	; 5
     300:	80 83       	st	Z, r24
		COLORSENSOR_S3_PORT &= ~( COLORSENSOR_S3_PIN );
     302:	80 81       	ld	r24, Z
     304:	8b 7f       	andi	r24, 0xFB	; 251
     306:	80 83       	st	Z, r24
     308:	08 95       	ret

0000030a <_ZN11ColorSensor8getColorEv>:
ColorSensor::~ColorSensor()
{	
}

uint8_t ColorSensor::getColor()
{
     30a:	6f 92       	push	r6
     30c:	7f 92       	push	r7
     30e:	8f 92       	push	r8
     310:	9f 92       	push	r9
     312:	af 92       	push	r10
     314:	bf 92       	push	r11
     316:	cf 92       	push	r12
     318:	df 92       	push	r13
     31a:	ef 92       	push	r14
     31c:	ff 92       	push	r15
     31e:	0f 93       	push	r16
     320:	1f 93       	push	r17
     322:	cf 93       	push	r28
     324:	df 93       	push	r29
     326:	8c 01       	movw	r16, r24
	uint8_t result = 255;
	
	// Get period values from all filters
	setFilter( redFilter );
     328:	61 e0       	ldi	r22, 0x01	; 1
     32a:	c3 df       	rcall	.-122    	; 0x2b2 <_ZN11ColorSensor9setFilterE6Filter>
	uint16_t redPeriod = frequency_.getPeriod();
     32c:	c8 01       	movw	r24, r16
     32e:	43 d1       	rcall	.+646    	; 0x5b6 <_ZN6Timer49getPeriodEv>
     330:	7c 01       	movw	r14, r24

	setFilter( blueFilter );
     332:	63 e0       	ldi	r22, 0x03	; 3
     334:	c8 01       	movw	r24, r16
	uint16_t bluePeriod = frequency_.getPeriod();  
     336:	bd df       	rcall	.-134    	; 0x2b2 <_ZN11ColorSensor9setFilterE6Filter>
     338:	c8 01       	movw	r24, r16
     33a:	3d d1       	rcall	.+634    	; 0x5b6 <_ZN6Timer49getPeriodEv>

	setFilter( greenFilter );
     33c:	6c 01       	movw	r12, r24
     33e:	62 e0       	ldi	r22, 0x02	; 2
     340:	c8 01       	movw	r24, r16
	uint16_t greenPeriod = frequency_.getPeriod();
     342:	b7 df       	rcall	.-146    	; 0x2b2 <_ZN11ColorSensor9setFilterE6Filter>
     344:	c8 01       	movw	r24, r16
	
	setFilter( noFilter );
     346:	37 d1       	rcall	.+622    	; 0x5b6 <_ZN6Timer49getPeriodEv>
     348:	5c 01       	movw	r10, r24
     34a:	60 e0       	ldi	r22, 0x00	; 0
     34c:	c8 01       	movw	r24, r16
	uint16_t whitePeriod = frequency_.getPeriod();
     34e:	b1 df       	rcall	.-158    	; 0x2b2 <_ZN11ColorSensor9setFilterE6Filter>
     350:	c8 01       	movw	r24, r16
     352:	31 d1       	rcall	.+610    	; 0x5b6 <_ZN6Timer49getPeriodEv>
     354:	4c 01       	movw	r8, r24
	
	// Check all stored colors against read values	
	for ( uint8_t index = 0U; index < 10; index++)
     356:	71 2c       	mov	r7, r1
     358:	89 e0       	ldi	r24, 0x09	; 9
     35a:	87 15       	cp	r24, r7
     35c:	08 f4       	brcc	.+2      	; 0x360 <_ZN11ColorSensor8getColorEv+0x56>
     35e:	5a c0       	rjmp	.+180    	; 0x414 <__LOCK_REGION_LENGTH__+0x14>
	{		
		if ( _colors[index].getRedPeriod() + 5 > redPeriod && _colors[index].getRedPeriod() - 5 < redPeriod )
     360:	c7 2d       	mov	r28, r7
     362:	d0 e0       	ldi	r29, 0x00	; 0
     364:	ce 01       	movw	r24, r28
     366:	88 0f       	add	r24, r24
     368:	99 1f       	adc	r25, r25
     36a:	88 0f       	add	r24, r24
     36c:	99 1f       	adc	r25, r25
     36e:	88 0f       	add	r24, r24
     370:	99 1f       	adc	r25, r25
     372:	c8 0f       	add	r28, r24
     374:	d9 1f       	adc	r29, r25
     376:	21 96       	adiw	r28, 0x01	; 1
     378:	c0 0f       	add	r28, r16
     37a:	d1 1f       	adc	r29, r17
     37c:	ce 01       	movw	r24, r28
     37e:	5f df       	rcall	.-322    	; 0x23e <_ZN5Color12getRedPeriodEv>
     380:	05 96       	adiw	r24, 0x05	; 5
     382:	e8 16       	cp	r14, r24
     384:	f9 06       	cpc	r15, r25
     386:	48 f4       	brcc	.+18     	; 0x39a <_ZN11ColorSensor8getColorEv+0x90>
     388:	ce 01       	movw	r24, r28
     38a:	59 df       	rcall	.-334    	; 0x23e <_ZN5Color12getRedPeriodEv>
     38c:	05 97       	sbiw	r24, 0x05	; 5
     38e:	8e 15       	cp	r24, r14
     390:	9f 05       	cpc	r25, r15
     392:	28 f4       	brcc	.+10     	; 0x39e <_ZN11ColorSensor8getColorEv+0x94>
     394:	66 24       	eor	r6, r6
     396:	63 94       	inc	r6
     398:	03 c0       	rjmp	.+6      	; 0x3a0 <_ZN11ColorSensor8getColorEv+0x96>
     39a:	61 2c       	mov	r6, r1
     39c:	01 c0       	rjmp	.+2      	; 0x3a0 <_ZN11ColorSensor8getColorEv+0x96>
     39e:	61 2c       	mov	r6, r1
		{
			if ( _colors[index].getBluePeriod() + 5 > bluePeriod && _colors[index].getBluePeriod() - 5 < bluePeriod )
     3a0:	66 20       	and	r6, r6
     3a2:	b1 f1       	breq	.+108    	; 0x410 <__LOCK_REGION_LENGTH__+0x10>
     3a4:	ce 01       	movw	r24, r28
     3a6:	4f df       	rcall	.-354    	; 0x246 <_ZN5Color13getBluePeriodEv>
     3a8:	05 96       	adiw	r24, 0x05	; 5
     3aa:	c8 16       	cp	r12, r24
     3ac:	d9 06       	cpc	r13, r25
     3ae:	38 f4       	brcc	.+14     	; 0x3be <_ZN11ColorSensor8getColorEv+0xb4>
     3b0:	ce 01       	movw	r24, r28
     3b2:	49 df       	rcall	.-366    	; 0x246 <_ZN5Color13getBluePeriodEv>
     3b4:	05 97       	sbiw	r24, 0x05	; 5
     3b6:	8c 15       	cp	r24, r12
     3b8:	9d 05       	cpc	r25, r13
     3ba:	18 f4       	brcc	.+6      	; 0x3c2 <_ZN11ColorSensor8getColorEv+0xb8>
     3bc:	03 c0       	rjmp	.+6      	; 0x3c4 <_ZN11ColorSensor8getColorEv+0xba>
     3be:	61 2c       	mov	r6, r1
     3c0:	01 c0       	rjmp	.+2      	; 0x3c4 <_ZN11ColorSensor8getColorEv+0xba>
     3c2:	61 2c       	mov	r6, r1
			{
				if ( _colors[index].getGreenPeriod() + 5 > greenPeriod && _colors[index].getGreenPeriod() - 5 < greenPeriod )
     3c4:	66 20       	and	r6, r6
     3c6:	21 f1       	breq	.+72     	; 0x410 <__LOCK_REGION_LENGTH__+0x10>
     3c8:	ce 01       	movw	r24, r28
     3ca:	41 df       	rcall	.-382    	; 0x24e <_ZN5Color14getGreenPeriodEv>
     3cc:	05 96       	adiw	r24, 0x05	; 5
     3ce:	a8 16       	cp	r10, r24
     3d0:	b9 06       	cpc	r11, r25
     3d2:	38 f4       	brcc	.+14     	; 0x3e2 <_ZN11ColorSensor8getColorEv+0xd8>
     3d4:	ce 01       	movw	r24, r28
     3d6:	3b df       	rcall	.-394    	; 0x24e <_ZN5Color14getGreenPeriodEv>
     3d8:	05 97       	sbiw	r24, 0x05	; 5
     3da:	8a 15       	cp	r24, r10
     3dc:	9b 05       	cpc	r25, r11
     3de:	18 f4       	brcc	.+6      	; 0x3e6 <_ZN11ColorSensor8getColorEv+0xdc>
     3e0:	03 c0       	rjmp	.+6      	; 0x3e8 <_ZN11ColorSensor8getColorEv+0xde>
     3e2:	61 2c       	mov	r6, r1
     3e4:	01 c0       	rjmp	.+2      	; 0x3e8 <_ZN11ColorSensor8getColorEv+0xde>
     3e6:	61 2c       	mov	r6, r1
				{
					if ( _colors[index].getWhitePeriod() + 2 > whitePeriod && _colors[index].getWhitePeriod() - 2 < whitePeriod )
     3e8:	66 20       	and	r6, r6
     3ea:	91 f0       	breq	.+36     	; 0x410 <__LOCK_REGION_LENGTH__+0x10>
     3ec:	ce 01       	movw	r24, r28
     3ee:	33 df       	rcall	.-410    	; 0x256 <_ZN5Color14getWhitePeriodEv>
     3f0:	02 96       	adiw	r24, 0x02	; 2
     3f2:	88 16       	cp	r8, r24
     3f4:	99 06       	cpc	r9, r25
     3f6:	38 f4       	brcc	.+14     	; 0x406 <__LOCK_REGION_LENGTH__+0x6>
     3f8:	ce 01       	movw	r24, r28
     3fa:	2d df       	rcall	.-422    	; 0x256 <_ZN5Color14getWhitePeriodEv>
     3fc:	02 97       	sbiw	r24, 0x02	; 2
     3fe:	88 15       	cp	r24, r8
     400:	99 05       	cpc	r25, r9
     402:	18 f4       	brcc	.+6      	; 0x40a <__LOCK_REGION_LENGTH__+0xa>
     404:	03 c0       	rjmp	.+6      	; 0x40c <__LOCK_REGION_LENGTH__+0xc>
     406:	61 2c       	mov	r6, r1
     408:	01 c0       	rjmp	.+2      	; 0x40c <__LOCK_REGION_LENGTH__+0xc>
     40a:	61 2c       	mov	r6, r1
     40c:	61 10       	cpse	r6, r1
     40e:	04 c0       	rjmp	.+8      	; 0x418 <__LOCK_REGION_LENGTH__+0x18>
	
	setFilter( noFilter );
	uint16_t whitePeriod = frequency_.getPeriod();
	
	// Check all stored colors against read values	
	for ( uint8_t index = 0U; index < 10; index++)
     410:	73 94       	inc	r7
     412:	a2 cf       	rjmp	.-188    	; 0x358 <_ZN11ColorSensor8getColorEv+0x4e>
{	
}

uint8_t ColorSensor::getColor()
{
	uint8_t result = 255;
     414:	77 24       	eor	r7, r7
     416:	7a 94       	dec	r7
		}
	}
	
	// Return value
	return result;
}
     418:	87 2d       	mov	r24, r7
     41a:	df 91       	pop	r29
     41c:	cf 91       	pop	r28
     41e:	1f 91       	pop	r17
     420:	0f 91       	pop	r16
     422:	ff 90       	pop	r15
     424:	ef 90       	pop	r14
     426:	df 90       	pop	r13
     428:	cf 90       	pop	r12
     42a:	bf 90       	pop	r11
     42c:	af 90       	pop	r10
     42e:	9f 90       	pop	r9
     430:	8f 90       	pop	r8
     432:	7f 90       	pop	r7
     434:	6f 90       	pop	r6
     436:	08 95       	ret

00000438 <_ZN11ColorSensor17addCalibrateColorEh>:

void ColorSensor::addCalibrateColor( uint8_t colorIndex )
{
     438:	ff 92       	push	r15
     43a:	0f 93       	push	r16
     43c:	1f 93       	push	r17
     43e:	cf 93       	push	r28
     440:	df 93       	push	r29
	if ( colorIndex < 10U )
     442:	6a 30       	cpi	r22, 0x0A	; 10
     444:	08 f0       	brcs	.+2      	; 0x448 <_ZN11ColorSensor17addCalibrateColorEh+0x10>
     446:	33 c0       	rjmp	.+102    	; 0x4ae <_ZN11ColorSensor17addCalibrateColorEh+0x76>
     448:	f6 2e       	mov	r15, r22
     44a:	ec 01       	movw	r28, r24
	{	
		// Set all colors
		setFilter( redFilter );
     44c:	61 e0       	ldi	r22, 0x01	; 1
     44e:	31 df       	rcall	.-414    	; 0x2b2 <_ZN11ColorSensor9setFilterE6Filter>
		_colors[colorIndex].setRedPeriod( frequency_.getPeriod() );
     450:	ce 01       	movw	r24, r28
     452:	b1 d0       	rcall	.+354    	; 0x5b6 <_ZN6Timer49getPeriodEv>
     454:	2f 2d       	mov	r18, r15
     456:	30 e0       	ldi	r19, 0x00	; 0
     458:	89 01       	movw	r16, r18
     45a:	00 0f       	add	r16, r16
     45c:	11 1f       	adc	r17, r17
     45e:	00 0f       	add	r16, r16
     460:	11 1f       	adc	r17, r17
     462:	00 0f       	add	r16, r16
     464:	11 1f       	adc	r17, r17
     466:	02 0f       	add	r16, r18
     468:	13 1f       	adc	r17, r19
     46a:	0f 5f       	subi	r16, 0xFF	; 255
     46c:	1f 4f       	sbci	r17, 0xFF	; 255
     46e:	0c 0f       	add	r16, r28
     470:	1d 1f       	adc	r17, r29
     472:	bc 01       	movw	r22, r24
     474:	c8 01       	movw	r24, r16
     476:	f3 de       	rcall	.-538    	; 0x25e <_ZN5Color12setRedPeriodEj>

		setFilter( blueFilter );
     478:	63 e0       	ldi	r22, 0x03	; 3
     47a:	ce 01       	movw	r24, r28
     47c:	1a df       	rcall	.-460    	; 0x2b2 <_ZN11ColorSensor9setFilterE6Filter>
		_colors[colorIndex].setBluePeriod( frequency_.getPeriod() );
     47e:	ce 01       	movw	r24, r28
     480:	9a d0       	rcall	.+308    	; 0x5b6 <_ZN6Timer49getPeriodEv>
     482:	bc 01       	movw	r22, r24
     484:	c8 01       	movw	r24, r16
     486:	ef de       	rcall	.-546    	; 0x266 <_ZN5Color13setBluePeriodEj>
		
		setFilter( greenFilter );
     488:	62 e0       	ldi	r22, 0x02	; 2
     48a:	ce 01       	movw	r24, r28
     48c:	12 df       	rcall	.-476    	; 0x2b2 <_ZN11ColorSensor9setFilterE6Filter>
		_colors[colorIndex].setGreenPeriod( frequency_.getPeriod() );
     48e:	ce 01       	movw	r24, r28
     490:	92 d0       	rcall	.+292    	; 0x5b6 <_ZN6Timer49getPeriodEv>
     492:	bc 01       	movw	r22, r24
     494:	c8 01       	movw	r24, r16
     496:	eb de       	rcall	.-554    	; 0x26e <_ZN5Color14setGreenPeriodEj>
		
		setFilter( noFilter );
     498:	60 e0       	ldi	r22, 0x00	; 0
     49a:	ce 01       	movw	r24, r28
     49c:	0a df       	rcall	.-492    	; 0x2b2 <_ZN11ColorSensor9setFilterE6Filter>
		_colors[colorIndex].setWhitePeriod( frequency_.getPeriod() );
     49e:	ce 01       	movw	r24, r28
     4a0:	8a d0       	rcall	.+276    	; 0x5b6 <_ZN6Timer49getPeriodEv>
     4a2:	bc 01       	movw	r22, r24
     4a4:	c8 01       	movw	r24, r16
     4a6:	e7 de       	rcall	.-562    	; 0x276 <_ZN5Color14setWhitePeriodEj>
     4a8:	6f 2d       	mov	r22, r15
     4aa:	c8 01       	movw	r24, r16
				
		// Set index
		_colors[colorIndex].setColorIndex( colorIndex );
     4ac:	e8 de       	rcall	.-560    	; 0x27e <_ZN5Color13setColorIndexEh>
     4ae:	df 91       	pop	r29
     4b0:	cf 91       	pop	r28
     4b2:	1f 91       	pop	r17
	}
	else
	{
		/* Cant add more colors. Increase size of array. */
	}
}
     4b4:	0f 91       	pop	r16
     4b6:	ff 90       	pop	r15
     4b8:	08 95       	ret

000004ba <_ZN11ColorSensor19setFrequencyscalingE16FrequencyScaling>:
     4ba:	61 30       	cpi	r22, 0x01	; 1
     4bc:	79 f0       	breq	.+30     	; 0x4dc <_ZN11ColorSensor19setFrequencyscalingE16FrequencyScaling+0x22>
     4be:	28 f0       	brcs	.+10     	; 0x4ca <_ZN11ColorSensor19setFrequencyscalingE16FrequencyScaling+0x10>
	}	
}

void ColorSensor::setFrequencyscaling( FrequencyScaling scaling )
{
	switch (scaling)
     4c0:	62 30       	cpi	r22, 0x02	; 2
     4c2:	a9 f0       	breq	.+42     	; 0x4ee <_ZN11ColorSensor19setFrequencyscalingE16FrequencyScaling+0x34>
     4c4:	63 30       	cpi	r22, 0x03	; 3
     4c6:	e1 f0       	breq	.+56     	; 0x500 <_ZN11ColorSensor19setFrequencyscalingE16FrequencyScaling+0x46>
     4c8:	08 95       	ret
	{
	case powerDown:
		COLORSENSOR_S0_PORT &= ~( COLORSENSOR_S0_PIN );
     4ca:	e8 e0       	ldi	r30, 0x08	; 8
     4cc:	f1 e0       	ldi	r31, 0x01	; 1
     4ce:	80 81       	ld	r24, Z
     4d0:	88 7f       	andi	r24, 0xF8	; 248
     4d2:	80 83       	st	Z, r24
		COLORSENSOR_S1_PORT &= ~( COLORSENSOR_S1_PIN );
     4d4:	80 81       	ld	r24, Z
     4d6:	89 7f       	andi	r24, 0xF9	; 249
     4d8:	80 83       	st	Z, r24
		break;
     4da:	08 95       	ret

	case twoPercent:
		COLORSENSOR_S0_PORT &= ~( COLORSENSOR_S0_PIN );
     4dc:	e8 e0       	ldi	r30, 0x08	; 8
     4de:	f1 e0       	ldi	r31, 0x01	; 1
     4e0:	80 81       	ld	r24, Z
     4e2:	88 7f       	andi	r24, 0xF8	; 248
     4e4:	80 83       	st	Z, r24
		COLORSENSOR_S1_PORT |= COLORSENSOR_S1_PIN;
     4e6:	80 81       	ld	r24, Z
     4e8:	86 60       	ori	r24, 0x06	; 6
     4ea:	80 83       	st	Z, r24
		break;
     4ec:	08 95       	ret

	case twentyPercent:
		COLORSENSOR_S0_PORT |= COLORSENSOR_S0_PIN;
     4ee:	e8 e0       	ldi	r30, 0x08	; 8
     4f0:	f1 e0       	ldi	r31, 0x01	; 1
     4f2:	80 81       	ld	r24, Z
     4f4:	87 60       	ori	r24, 0x07	; 7
     4f6:	80 83       	st	Z, r24
		COLORSENSOR_S1_PORT &= ~( COLORSENSOR_S1_PIN );
     4f8:	80 81       	ld	r24, Z
     4fa:	89 7f       	andi	r24, 0xF9	; 249
     4fc:	80 83       	st	Z, r24
		break;
     4fe:	08 95       	ret

	case hundredPercent:
		COLORSENSOR_S0_PORT |= COLORSENSOR_S0_PIN;
     500:	e8 e0       	ldi	r30, 0x08	; 8
     502:	f1 e0       	ldi	r31, 0x01	; 1
     504:	80 81       	ld	r24, Z
     506:	87 60       	ori	r24, 0x07	; 7
     508:	80 83       	st	Z, r24
		COLORSENSOR_S1_PORT |= COLORSENSOR_S1_PIN;
     50a:	80 81       	ld	r24, Z
     50c:	86 60       	ori	r24, 0x06	; 6
     50e:	80 83       	st	Z, r24
     510:	08 95       	ret

00000512 <_ZN11ColorSensorC1E16FrequencyScaling>:
#include "FreeRTOS.h"
#include "task.h"
#include "portmacro.h"

// default constructor
ColorSensor::ColorSensor( FrequencyScaling scaling )
     512:	bf 92       	push	r11
     514:	cf 92       	push	r12
     516:	df 92       	push	r13
     518:	ef 92       	push	r14
     51a:	ff 92       	push	r15
     51c:	0f 93       	push	r16
     51e:	1f 93       	push	r17
     520:	cf 93       	push	r28
     522:	df 93       	push	r29
     524:	1f 92       	push	r1
     526:	cd b7       	in	r28, 0x3d	; 61
     528:	de b7       	in	r29, 0x3e	; 62
     52a:	6c 01       	movw	r12, r24
     52c:	b6 2e       	mov	r11, r22
     52e:	26 d0       	rcall	.+76     	; 0x57c <_ZN6Timer4C1Ev>
     530:	76 01       	movw	r14, r12
     532:	8f ef       	ldi	r24, 0xFF	; 255
     534:	e8 1a       	sub	r14, r24
     536:	f8 0a       	sbc	r15, r24
     538:	09 e0       	ldi	r16, 0x09	; 9
     53a:	10 e0       	ldi	r17, 0x00	; 0
     53c:	0f 3f       	cpi	r16, 0xFF	; 255
     53e:	8f ef       	ldi	r24, 0xFF	; 255
     540:	18 07       	cpc	r17, r24
     542:	41 f0       	breq	.+16     	; 0x554 <_ZN11ColorSensorC1E16FrequencyScaling+0x42>
     544:	c7 01       	movw	r24, r14
     546:	79 de       	rcall	.-782    	; 0x23a <_ZN5ColorC1Ev>
     548:	89 e0       	ldi	r24, 0x09	; 9
     54a:	e8 0e       	add	r14, r24
     54c:	f1 1c       	adc	r15, r1
     54e:	01 50       	subi	r16, 0x01	; 1
     550:	11 09       	sbc	r17, r1
     552:	f4 cf       	rjmp	.-24     	; 0x53c <_ZN11ColorSensorC1E16FrequencyScaling+0x2a>
{
	frequency_ = Timer4();
     554:	ce 01       	movw	r24, r28
     556:	01 96       	adiw	r24, 0x01	; 1
     558:	11 d0       	rcall	.+34     	; 0x57c <_ZN6Timer4C1Ev>

	// Set default filter and scaling
	setFilter( noFilter );
     55a:	60 e0       	ldi	r22, 0x00	; 0
     55c:	c6 01       	movw	r24, r12
     55e:	a9 de       	rcall	.-686    	; 0x2b2 <_ZN11ColorSensor9setFilterE6Filter>
	setFrequencyscaling( scaling );
     560:	6b 2d       	mov	r22, r11
     562:	c6 01       	movw	r24, r12
     564:	aa df       	rcall	.-172    	; 0x4ba <_ZN11ColorSensor19setFrequencyscalingE16FrequencyScaling>
     566:	0f 90       	pop	r0
}
     568:	df 91       	pop	r29
     56a:	cf 91       	pop	r28
     56c:	1f 91       	pop	r17
     56e:	0f 91       	pop	r16
     570:	ff 90       	pop	r15
     572:	ef 90       	pop	r14
     574:	df 90       	pop	r13
     576:	cf 90       	pop	r12
     578:	bf 90       	pop	r11
     57a:	08 95       	ret

0000057c <_ZN6Timer4C1Ev>:
//volatile float tick = 0.000064;

Timer4::Timer4()
{
	// Set ports to the right values.
	COLORSENSOR_S0_PORT |= ( 1 << COLORSENSOR_S0_PIN );
     57c:	e8 e0       	ldi	r30, 0x08	; 8
     57e:	f1 e0       	ldi	r31, 0x01	; 1
     580:	80 81       	ld	r24, Z
     582:	80 68       	ori	r24, 0x80	; 128
     584:	80 83       	st	Z, r24
	COLORSENSOR_S1_PORT |= ( 1 << COLORSENSOR_S1_PIN );
     586:	80 81       	ld	r24, Z
     588:	80 64       	ori	r24, 0x40	; 64
     58a:	80 83       	st	Z, r24
	COLORSENSOR_S2_PORT |= ( 1 << COLORSENSOR_S2_PIN );
     58c:	80 81       	ld	r24, Z
     58e:	80 62       	ori	r24, 0x20	; 32
     590:	80 83       	st	Z, r24
	COLORSENSOR_S3_PORT |= ( 1 << COLORSENSOR_S3_PIN );
     592:	80 81       	ld	r24, Z
     594:	80 61       	ori	r24, 0x10	; 16
     596:	80 83       	st	Z, r24
	
	// Setup timer to normal mode and pre scaler to 64
	TCCR4A = 0U;
     598:	10 92 a0 00 	sts	0x00A0, r1	; 0x8000a0 <__TEXT_REGION_LENGTH__+0x7000a0>
	TCCR4B = ( 1 << ICNC4 ) | ( 1 << ICES4 ) | ( 1 << CS40 ) | ( 1 << CS41 );
     59c:	83 ec       	ldi	r24, 0xC3	; 195
     59e:	80 93 a1 00 	sts	0x00A1, r24	; 0x8000a1 <__TEXT_REGION_LENGTH__+0x7000a1>
	TCCR4C = 0U;
     5a2:	10 92 a2 00 	sts	0x00A2, r1	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
	
	// Clear flags and set counter to zero
	TIFR4 = ( 1 << ICF4 ) | ( 1 << TOV4 );
     5a6:	81 e2       	ldi	r24, 0x21	; 33
     5a8:	89 bb       	out	0x19, r24	; 25
	TCNT4 = 0;        
     5aa:	10 92 a5 00 	sts	0x00A5, r1	; 0x8000a5 <__TEXT_REGION_LENGTH__+0x7000a5>
     5ae:	10 92 a4 00 	sts	0x00A4, r1	; 0x8000a4 <__TEXT_REGION_LENGTH__+0x7000a4>

	// Enable global interrupts
    sei();
     5b2:	78 94       	sei
     5b4:	08 95       	ret

000005b6 <_ZN6Timer49getPeriodEv>:
}

uint16_t Timer4::getPeriod( void )
{
	// Reset all needed values
	first = true;
     5b6:	81 e0       	ldi	r24, 0x01	; 1
     5b8:	80 93 0a 02 	sts	0x020A, r24	; 0x80020a <first>
	oldValue = 0U;
     5bc:	10 92 95 02 	sts	0x0295, r1	; 0x800295 <oldValue+0x1>
     5c0:	10 92 94 02 	sts	0x0294, r1	; 0x800294 <oldValue>
	period = 0U;
     5c4:	10 92 8f 02 	sts	0x028F, r1	; 0x80028f <__data_end+0x1>
     5c8:	10 92 8e 02 	sts	0x028E, r1	; 0x80028e <__data_end>
	timeroverflow = 0;
     5cc:	10 92 90 02 	sts	0x0290, r1	; 0x800290 <timeroverflow>
     5d0:	10 92 91 02 	sts	0x0291, r1	; 0x800291 <timeroverflow+0x1>
     5d4:	10 92 92 02 	sts	0x0292, r1	; 0x800292 <timeroverflow+0x2>
     5d8:	10 92 93 02 	sts	0x0293, r1	; 0x800293 <timeroverflow+0x3>
	
	// Enable interrupt and clear pending
	TIFR4 = ( 1 << ICF4 ) | ( 1 << TOV4 );
     5dc:	81 e2       	ldi	r24, 0x21	; 33
     5de:	89 bb       	out	0x19, r24	; 25
	TIMSK4 = ( 1 << ICIE4 ) | ( 1 << TOIE4 );	
     5e0:	80 93 72 00 	sts	0x0072, r24	; 0x800072 <__TEXT_REGION_LENGTH__+0x700072>
	
	// Wait until measurement has been taken
	while ( period == 0U )
     5e4:	80 91 8e 02 	lds	r24, 0x028E	; 0x80028e <__data_end>
     5e8:	90 91 8f 02 	lds	r25, 0x028F	; 0x80028f <__data_end+0x1>
     5ec:	89 2b       	or	r24, r25
     5ee:	81 f4       	brne	.+32     	; 0x610 <_ZN6Timer49getPeriodEv+0x5a>
	{
		if ( timeroverflow > 10U )
     5f0:	80 91 90 02 	lds	r24, 0x0290	; 0x800290 <timeroverflow>
     5f4:	90 91 91 02 	lds	r25, 0x0291	; 0x800291 <timeroverflow+0x1>
     5f8:	a0 91 92 02 	lds	r26, 0x0292	; 0x800292 <timeroverflow+0x2>
     5fc:	b0 91 93 02 	lds	r27, 0x0293	; 0x800293 <timeroverflow+0x3>
     600:	0b 97       	sbiw	r24, 0x0b	; 11
     602:	a1 05       	cpc	r26, r1
     604:	b1 05       	cpc	r27, r1
     606:	70 f3       	brcs	.-36     	; 0x5e4 <_ZN6Timer49getPeriodEv+0x2e>
		{
			// Error - Disable interrupt and clear pending
			TIMSK4 = 0U;
     608:	10 92 72 00 	sts	0x0072, r1	; 0x800072 <__TEXT_REGION_LENGTH__+0x700072>
			TIFR4 = ( 1 << ICF4 ) | ( 1 << TOV4 );
     60c:	81 e2       	ldi	r24, 0x21	; 33
     60e:	89 bb       	out	0x19, r24	; 25
			break;
		}
	}
	
	return period;
     610:	80 91 8e 02 	lds	r24, 0x028E	; 0x80028e <__data_end>
     614:	90 91 8f 02 	lds	r25, 0x028F	; 0x80028f <__data_end+0x1>
}
     618:	08 95       	ret

0000061a <__vector_45>:

ISR(TIMER4_OVF_vect)
{
     61a:	1f 92       	push	r1
     61c:	0f 92       	push	r0
     61e:	0f b6       	in	r0, 0x3f	; 63
     620:	0f 92       	push	r0
     622:	11 24       	eor	r1, r1
     624:	8f 93       	push	r24
     626:	9f 93       	push	r25
     628:	af 93       	push	r26
     62a:	bf 93       	push	r27
	timeroverflow++;
     62c:	80 91 90 02 	lds	r24, 0x0290	; 0x800290 <timeroverflow>
     630:	90 91 91 02 	lds	r25, 0x0291	; 0x800291 <timeroverflow+0x1>
     634:	a0 91 92 02 	lds	r26, 0x0292	; 0x800292 <timeroverflow+0x2>
     638:	b0 91 93 02 	lds	r27, 0x0293	; 0x800293 <timeroverflow+0x3>
     63c:	01 96       	adiw	r24, 0x01	; 1
     63e:	a1 1d       	adc	r26, r1
     640:	b1 1d       	adc	r27, r1
     642:	80 93 90 02 	sts	0x0290, r24	; 0x800290 <timeroverflow>
     646:	90 93 91 02 	sts	0x0291, r25	; 0x800291 <timeroverflow+0x1>
     64a:	a0 93 92 02 	sts	0x0292, r26	; 0x800292 <timeroverflow+0x2>
     64e:	b0 93 93 02 	sts	0x0293, r27	; 0x800293 <timeroverflow+0x3>
}
     652:	bf 91       	pop	r27
     654:	af 91       	pop	r26
     656:	9f 91       	pop	r25
     658:	8f 91       	pop	r24
     65a:	0f 90       	pop	r0
     65c:	0f be       	out	0x3f, r0	; 63
     65e:	0f 90       	pop	r0
     660:	1f 90       	pop	r1
     662:	18 95       	reti

00000664 <__vector_41>:

ISR(TIMER4_CAPT_vect)
{
     664:	1f 92       	push	r1
     666:	0f 92       	push	r0
     668:	0f b6       	in	r0, 0x3f	; 63
     66a:	0f 92       	push	r0
     66c:	11 24       	eor	r1, r1
     66e:	0b b6       	in	r0, 0x3b	; 59
     670:	0f 92       	push	r0
     672:	cf 92       	push	r12
     674:	df 92       	push	r13
     676:	ef 92       	push	r14
     678:	ff 92       	push	r15
     67a:	0f 93       	push	r16
     67c:	1f 93       	push	r17
     67e:	2f 93       	push	r18
     680:	3f 93       	push	r19
     682:	4f 93       	push	r20
     684:	5f 93       	push	r21
     686:	6f 93       	push	r22
     688:	7f 93       	push	r23
     68a:	8f 93       	push	r24
     68c:	9f 93       	push	r25
     68e:	af 93       	push	r26
     690:	bf 93       	push	r27
     692:	ef 93       	push	r30
     694:	ff 93       	push	r31
	// Read value of timer
	uint16_t readValue = ICR4;
     696:	60 91 a6 00 	lds	r22, 0x00A6	; 0x8000a6 <__TEXT_REGION_LENGTH__+0x7000a6>
     69a:	70 91 a7 00 	lds	r23, 0x00A7	; 0x8000a7 <__TEXT_REGION_LENGTH__+0x7000a7>

	if ( first == true )
     69e:	80 91 0a 02 	lds	r24, 0x020A	; 0x80020a <first>
     6a2:	88 23       	and	r24, r24
     6a4:	79 f0       	breq	.+30     	; 0x6c4 <__vector_41+0x60>
	{
		timeroverflow = 0U;
     6a6:	10 92 90 02 	sts	0x0290, r1	; 0x800290 <timeroverflow>
     6aa:	10 92 91 02 	sts	0x0291, r1	; 0x800291 <timeroverflow+0x1>
     6ae:	10 92 92 02 	sts	0x0292, r1	; 0x800292 <timeroverflow+0x2>
     6b2:	10 92 93 02 	sts	0x0293, r1	; 0x800293 <timeroverflow+0x3>
		oldValue = readValue;
     6b6:	70 93 95 02 	sts	0x0295, r23	; 0x800295 <oldValue+0x1>
     6ba:	60 93 94 02 	sts	0x0294, r22	; 0x800294 <oldValue>
		first = false;
     6be:	10 92 0a 02 	sts	0x020A, r1	; 0x80020a <first>
		return;
     6c2:	81 c0       	rjmp	.+258    	; 0x7c6 <__vector_41+0x162>
	}
	
	// Check if overflow is pending
	if ( TIFR4 & ( 1 << TOV4 ))
     6c4:	c8 9b       	sbis	0x19, 0	; 25
     6c6:	13 c0       	rjmp	.+38     	; 0x6ee <__vector_41+0x8a>
	{
		timeroverflow++;
     6c8:	80 91 90 02 	lds	r24, 0x0290	; 0x800290 <timeroverflow>
     6cc:	90 91 91 02 	lds	r25, 0x0291	; 0x800291 <timeroverflow+0x1>
     6d0:	a0 91 92 02 	lds	r26, 0x0292	; 0x800292 <timeroverflow+0x2>
     6d4:	b0 91 93 02 	lds	r27, 0x0293	; 0x800293 <timeroverflow+0x3>
     6d8:	01 96       	adiw	r24, 0x01	; 1
     6da:	a1 1d       	adc	r26, r1
     6dc:	b1 1d       	adc	r27, r1
     6de:	80 93 90 02 	sts	0x0290, r24	; 0x800290 <timeroverflow>
     6e2:	90 93 91 02 	sts	0x0291, r25	; 0x800291 <timeroverflow+0x1>
     6e6:	a0 93 92 02 	sts	0x0292, r26	; 0x800292 <timeroverflow+0x2>
     6ea:	b0 93 93 02 	sts	0x0293, r27	; 0x800293 <timeroverflow+0x3>
	}
		
	// Disable interrupt and clear pending
	TIMSK4 = 0U;	
     6ee:	10 92 72 00 	sts	0x0072, r1	; 0x800072 <__TEXT_REGION_LENGTH__+0x700072>
	TIFR4 = ( 1 << ICF4 ) | ( 1 << TOV4 );		
     6f2:	81 e2       	ldi	r24, 0x21	; 33
     6f4:	89 bb       	out	0x19, r24	; 25
			
	// Calculate difference
	uint32_t diff = 0U;

	if ( readValue < oldValue )
     6f6:	80 91 94 02 	lds	r24, 0x0294	; 0x800294 <oldValue>
     6fa:	90 91 95 02 	lds	r25, 0x0295	; 0x800295 <oldValue+0x1>
     6fe:	68 17       	cp	r22, r24
     700:	79 07       	cpc	r23, r25
     702:	58 f5       	brcc	.+86     	; 0x75a <__vector_41+0xf6>
	{
		if ( timeroverflow != 0 )
     704:	80 91 90 02 	lds	r24, 0x0290	; 0x800290 <timeroverflow>
     708:	90 91 91 02 	lds	r25, 0x0291	; 0x800291 <timeroverflow+0x1>
     70c:	a0 91 92 02 	lds	r26, 0x0292	; 0x800292 <timeroverflow+0x2>
     710:	b0 91 93 02 	lds	r27, 0x0293	; 0x800293 <timeroverflow+0x3>
     714:	89 2b       	or	r24, r25
     716:	8a 2b       	or	r24, r26
     718:	8b 2b       	or	r24, r27
     71a:	99 f0       	breq	.+38     	; 0x742 <__vector_41+0xde>
		{
			timeroverflow--;
     71c:	80 91 90 02 	lds	r24, 0x0290	; 0x800290 <timeroverflow>
     720:	90 91 91 02 	lds	r25, 0x0291	; 0x800291 <timeroverflow+0x1>
     724:	a0 91 92 02 	lds	r26, 0x0292	; 0x800292 <timeroverflow+0x2>
     728:	b0 91 93 02 	lds	r27, 0x0293	; 0x800293 <timeroverflow+0x3>
     72c:	01 97       	sbiw	r24, 0x01	; 1
     72e:	a1 09       	sbc	r26, r1
     730:	b1 09       	sbc	r27, r1
     732:	80 93 90 02 	sts	0x0290, r24	; 0x800290 <timeroverflow>
     736:	90 93 91 02 	sts	0x0291, r25	; 0x800291 <timeroverflow+0x1>
     73a:	a0 93 92 02 	sts	0x0292, r26	; 0x800292 <timeroverflow+0x2>
     73e:	b0 93 93 02 	sts	0x0293, r27	; 0x800293 <timeroverflow+0x3>
		}
		diff = ( 0xFFFF - oldValue ) + readValue;
     742:	80 91 94 02 	lds	r24, 0x0294	; 0x800294 <oldValue>
     746:	90 91 95 02 	lds	r25, 0x0295	; 0x800295 <oldValue+0x1>
     74a:	68 1b       	sub	r22, r24
     74c:	79 0b       	sbc	r23, r25
     74e:	61 50       	subi	r22, 0x01	; 1
     750:	71 09       	sbc	r23, r1
     752:	cb 01       	movw	r24, r22
     754:	a0 e0       	ldi	r26, 0x00	; 0
     756:	b0 e0       	ldi	r27, 0x00	; 0
     758:	09 c0       	rjmp	.+18     	; 0x76c <__vector_41+0x108>
	}
	else
	{
		diff = readValue - oldValue;
     75a:	80 91 94 02 	lds	r24, 0x0294	; 0x800294 <oldValue>
     75e:	90 91 95 02 	lds	r25, 0x0295	; 0x800295 <oldValue+0x1>
     762:	68 1b       	sub	r22, r24
     764:	79 0b       	sbc	r23, r25
     766:	cb 01       	movw	r24, r22
     768:	a0 e0       	ldi	r26, 0x00	; 0
     76a:	b0 e0       	ldi	r27, 0x00	; 0
	}
	
	// Add timeroverflow to total diff
	diff += timeroverflow << 16U;
     76c:	40 91 90 02 	lds	r20, 0x0290	; 0x800290 <timeroverflow>
     770:	50 91 91 02 	lds	r21, 0x0291	; 0x800291 <timeroverflow+0x1>
     774:	60 91 92 02 	lds	r22, 0x0292	; 0x800292 <timeroverflow+0x2>
     778:	70 91 93 02 	lds	r23, 0x0293	; 0x800293 <timeroverflow+0x3>
     77c:	ba 01       	movw	r22, r20
     77e:	55 27       	eor	r21, r21
     780:	44 27       	eor	r20, r20
     782:	8a 01       	movw	r16, r20
     784:	9b 01       	movw	r18, r22
     786:	08 0f       	add	r16, r24
     788:	19 1f       	adc	r17, r25
     78a:	2a 1f       	adc	r18, r26
     78c:	3b 1f       	adc	r19, r27
     78e:	c9 01       	movw	r24, r18
     790:	b8 01       	movw	r22, r16
	
	// Calculate period
	period = diff * tick * 1000000;
     792:	c0 90 06 02 	lds	r12, 0x0206	; 0x800206 <tick>
     796:	d0 90 07 02 	lds	r13, 0x0207	; 0x800207 <tick+0x1>
     79a:	e0 90 08 02 	lds	r14, 0x0208	; 0x800208 <tick+0x2>
     79e:	f0 90 09 02 	lds	r15, 0x0209	; 0x800209 <tick+0x3>
     7a2:	0e 94 d1 15 	call	0x2ba2	; 0x2ba2 <__floatunsisf>
     7a6:	a7 01       	movw	r20, r14
     7a8:	96 01       	movw	r18, r12
     7aa:	0e 94 87 16 	call	0x2d0e	; 0x2d0e <__mulsf3>
     7ae:	20 e0       	ldi	r18, 0x00	; 0
     7b0:	34 e2       	ldi	r19, 0x24	; 36
     7b2:	44 e7       	ldi	r20, 0x74	; 116
     7b4:	59 e4       	ldi	r21, 0x49	; 73
     7b6:	0e 94 87 16 	call	0x2d0e	; 0x2d0e <__mulsf3>
     7ba:	0e 94 a5 15 	call	0x2b4a	; 0x2b4a <__fixunssfsi>
     7be:	70 93 8f 02 	sts	0x028F, r23	; 0x80028f <__data_end+0x1>
     7c2:	60 93 8e 02 	sts	0x028E, r22	; 0x80028e <__data_end>
     7c6:	ff 91       	pop	r31
     7c8:	ef 91       	pop	r30
     7ca:	bf 91       	pop	r27
     7cc:	af 91       	pop	r26
     7ce:	9f 91       	pop	r25
     7d0:	8f 91       	pop	r24
     7d2:	7f 91       	pop	r23
     7d4:	6f 91       	pop	r22
     7d6:	5f 91       	pop	r21
     7d8:	4f 91       	pop	r20
     7da:	3f 91       	pop	r19
     7dc:	2f 91       	pop	r18
     7de:	1f 91       	pop	r17
     7e0:	0f 91       	pop	r16
     7e2:	ff 90       	pop	r15
     7e4:	ef 90       	pop	r14
     7e6:	df 90       	pop	r13
     7e8:	cf 90       	pop	r12
     7ea:	0f 90       	pop	r0
     7ec:	0b be       	out	0x3b, r0	; 59
     7ee:	0f 90       	pop	r0
     7f0:	0f be       	out	0x3f, r0	; 63
     7f2:	0f 90       	pop	r0
     7f4:	1f 90       	pop	r1
     7f6:	18 95       	reti

000007f8 <_ZN6KeyPadC1Ev>:
/* RTOS include */
#include "FreeRTOS.h"
#include "task.h"
#include "portmacro.h"

 KeyPad::KeyPad()
     7f8:	08 95       	ret

000007fa <_ZN6KeyPad7findKeyEh>:
	return pressed_key;
}

char KeyPad::findKey(uint8_t pin_press)
{
	switch(pin_press) {
     7fa:	86 2f       	mov	r24, r22
     7fc:	90 e0       	ldi	r25, 0x00	; 0
     7fe:	fc 01       	movw	r30, r24
     800:	71 97       	sbiw	r30, 0x11	; 17
     802:	e8 37       	cpi	r30, 0x78	; 120
     804:	f1 05       	cpc	r31, r1
     806:	20 f5       	brcc	.+72     	; 0x850 <_ZN6KeyPad7findKeyEh+0x56>
     808:	88 27       	eor	r24, r24
     80a:	ee 58       	subi	r30, 0x8E	; 142
     80c:	ff 4f       	sbci	r31, 0xFF	; 255
     80e:	8f 4f       	sbci	r24, 0xFF	; 255
     810:	0c 94 ea 16 	jmp	0x2dd4	; 0x2dd4 <__tablejump2__>
		
		case 0b01000010  :
			return '1';
     814:	81 e3       	ldi	r24, 0x31	; 49
     816:	08 95       	ret
		case 0b01001000  :
			return '2';
		case 0b01000001  :
			return '3';
     818:	83 e3       	ldi	r24, 0x33	; 51
     81a:	08 95       	ret
		case 0b01000100  :
			return 'A';
     81c:	81 e4       	ldi	r24, 0x41	; 65
     81e:	08 95       	ret
			
		case 0b10000010  :
			return '4';
     820:	84 e3       	ldi	r24, 0x34	; 52
     822:	08 95       	ret
		case 0b10001000  :
			return '5';
     824:	85 e3       	ldi	r24, 0x35	; 53
     826:	08 95       	ret
		case 0b10000001  :
			return '6';
     828:	86 e3       	ldi	r24, 0x36	; 54
     82a:	08 95       	ret
		case 0b10000100  :
			return 'B';
     82c:	82 e4       	ldi	r24, 0x42	; 66
     82e:	08 95       	ret
			
		case 0b00100010  :
			return '7';
     830:	87 e3       	ldi	r24, 0x37	; 55
     832:	08 95       	ret
		case 0b00101000  :
			return '8';
     834:	88 e3       	ldi	r24, 0x38	; 56
     836:	08 95       	ret
		case 0b00100001  :
			return '9';
     838:	89 e3       	ldi	r24, 0x39	; 57
     83a:	08 95       	ret
		case 0b00100100  :
			return 'C';
     83c:	83 e4       	ldi	r24, 0x43	; 67
     83e:	08 95       	ret
			
		case 0b00010010  :
			return '*';
     840:	8a e2       	ldi	r24, 0x2A	; 42
     842:	08 95       	ret
		case 0b00011000  :
			return '0';
     844:	80 e3       	ldi	r24, 0x30	; 48
     846:	08 95       	ret
		case 0b00010001  :
			return '#';
     848:	83 e2       	ldi	r24, 0x23	; 35
     84a:	08 95       	ret
		case 0b00010100  :
			return 'D';
     84c:	84 e4       	ldi	r24, 0x44	; 68
     84e:	08 95       	ret
			
		
		// you can have any number of case statements.
		default : //Optional
			return 'E';
     850:	85 e4       	ldi	r24, 0x45	; 69
     852:	08 95       	ret
	switch(pin_press) {
		
		case 0b01000010  :
			return '1';
		case 0b01001000  :
			return '2';
     854:	82 e3       	ldi	r24, 0x32	; 50
		
		// you can have any number of case statements.
		default : //Optional
			return 'E';
	}
     856:	08 95       	ret

00000858 <_ZN6KeyPad12readKeyboardEv>:

 KeyPad::KeyPad()
{
}

char KeyPad::readKeyboard(){
     858:	ef 92       	push	r14
     85a:	ff 92       	push	r15
     85c:	0f 93       	push	r16
     85e:	1f 93       	push	r17
     860:	cf 93       	push	r28
     862:	8c 01       	movw	r16, r24
	
	uint8_t read_byte = 0; // Bytes to contain pressed char
	DDRK = 0b11110000; // Configure for Columns to be output and row to be input
     864:	80 ef       	ldi	r24, 0xF0	; 240
     866:	80 93 07 01 	sts	0x0107, r24	; 0x800107 <__TEXT_REGION_LENGTH__+0x700107>
	PORTK = 0b11110000; // Set Columns output to be high!
     86a:	80 93 08 01 	sts	0x0108, r24	; 0x800108 <__TEXT_REGION_LENGTH__+0x700108>
	
	vTaskDelay(8/portTICK_RATE_MS);	// Delays for allowing Pins to switch state from input to output and reverse
     86e:	88 e0       	ldi	r24, 0x08	; 8
     870:	90 e0       	ldi	r25, 0x00	; 0
     872:	0e 94 6a 11 	call	0x22d4	; 0x22d4 <vTaskDelay>
	
	
	while( (PINK & 0b00001111) == 0 )	// Wait for key pressed
     876:	80 91 06 01 	lds	r24, 0x0106	; 0x800106 <__TEXT_REGION_LENGTH__+0x700106>
     87a:	8f 70       	andi	r24, 0x0F	; 15
     87c:	e1 f3       	breq	.-8      	; 0x876 <_ZN6KeyPad12readKeyboardEv+0x1e>
	{	
	}
	
	read_byte = (PINK & 0b00001111); // Get row of pressed key
     87e:	0f 2e       	mov	r0, r31
     880:	f6 e0       	ldi	r31, 0x06	; 6
     882:	ef 2e       	mov	r14, r31
     884:	ff 24       	eor	r15, r15
     886:	f3 94       	inc	r15
     888:	f0 2d       	mov	r31, r0
     88a:	f7 01       	movw	r30, r14
     88c:	c0 81       	ld	r28, Z
     88e:	cf 70       	andi	r28, 0x0F	; 15
	
	DDRK = 0b00001111; // Switch Columns to be input and row to be output
     890:	8f e0       	ldi	r24, 0x0F	; 15
     892:	80 93 07 01 	sts	0x0107, r24	; 0x800107 <__TEXT_REGION_LENGTH__+0x700107>
	PORTK = 0b00001111; // Set Row outputs to be high!
     896:	80 93 08 01 	sts	0x0108, r24	; 0x800108 <__TEXT_REGION_LENGTH__+0x700108>
	
	vTaskDelay(8/portTICK_RATE_MS);
     89a:	88 e0       	ldi	r24, 0x08	; 8
     89c:	90 e0       	ldi	r25, 0x00	; 0
     89e:	0e 94 6a 11 	call	0x22d4	; 0x22d4 <vTaskDelay>
	
	//PORTA = 0;
	//DDRA = 0;
	char pressed_key = findKey(read_byte | (PINK & 0b11110000));
     8a2:	f7 01       	movw	r30, r14
     8a4:	60 81       	ld	r22, Z
     8a6:	60 7f       	andi	r22, 0xF0	; 240
     8a8:	6c 2b       	or	r22, r28
     8aa:	c8 01       	movw	r24, r16
     8ac:	a6 df       	rcall	.-180    	; 0x7fa <_ZN6KeyPad7findKeyEh>
	
	// Wait for no key pressed anymore
	
	while((PINK & 0b11110000) != 0)
     8ae:	90 91 06 01 	lds	r25, 0x0106	; 0x800106 <__TEXT_REGION_LENGTH__+0x700106>
     8b2:	90 7f       	andi	r25, 0xF0	; 240
     8b4:	e1 f7       	brne	.-8      	; 0x8ae <_ZN6KeyPad12readKeyboardEv+0x56>
	{
	}
	
	return pressed_key;
}
     8b6:	cf 91       	pop	r28
     8b8:	1f 91       	pop	r17
     8ba:	0f 91       	pop	r16
     8bc:	ff 90       	pop	r15
     8be:	ef 90       	pop	r14
     8c0:	08 95       	ret

000008c2 <_ZN14LoginInterfaceC1Ev>:
#include <stdlib.h>
#include <avr/io.h>
#include "KeyPad.h"
#include "LoginInterface.h"

 LoginInterface::LoginInterface()
     8c2:	0f 93       	push	r16
     8c4:	1f 93       	push	r17
     8c6:	cf 93       	push	r28
     8c8:	df 93       	push	r29
     8ca:	1f 92       	push	r1
     8cc:	cd b7       	in	r28, 0x3d	; 61
     8ce:	de b7       	in	r29, 0x3e	; 62
     8d0:	8c 01       	movw	r16, r24
     8d2:	92 df       	rcall	.-220    	; 0x7f8 <_ZN6KeyPadC1Ev>
 {
	 keypad = KeyPad();
     8d4:	ce 01       	movw	r24, r28
     8d6:	01 96       	adiw	r24, 0x01	; 1
     8d8:	8f df       	rcall	.-226    	; 0x7f8 <_ZN6KeyPadC1Ev>
	 // ASCII Used since static declaration is not supported before STD c++ 11
	 passWord[0] = 49; // 1
     8da:	81 e3       	ldi	r24, 0x31	; 49
     8dc:	f8 01       	movw	r30, r16
     8de:	81 83       	std	Z+1, r24	; 0x01
	 passWord[1] = 52; // 4
     8e0:	84 e3       	ldi	r24, 0x34	; 52
     8e2:	82 83       	std	Z+2, r24	; 0x02
	 passWord[2] = 55; // 7
     8e4:	87 e3       	ldi	r24, 0x37	; 55
     8e6:	83 83       	std	Z+3, r24	; 0x03
	 passWord[3] = 50; // 2
     8e8:	82 e3       	ldi	r24, 0x32	; 50
     8ea:	84 83       	std	Z+4, r24	; 0x04
	 
 }
     8ec:	0f 90       	pop	r0
     8ee:	df 91       	pop	r29
     8f0:	cf 91       	pop	r28
     8f2:	1f 91       	pop	r17
     8f4:	0f 91       	pop	r16
     8f6:	08 95       	ret

000008f8 <_ZN14LoginInterface17getstateOfMachineEv>:
 }
 
 char LoginInterface::getstateOfMachine()
 {
	 return stateOfMachine;
 }
     8f8:	fc 01       	movw	r30, r24
     8fa:	85 81       	ldd	r24, Z+5	; 0x05
     8fc:	08 95       	ret

000008fe <_ZN14LoginInterface17setstateOfMachineEc>:
 
 void LoginInterface::setstateOfMachine(char state)
 {
	 stateOfMachine = state;
     8fe:	fc 01       	movw	r30, r24
     900:	65 83       	std	Z+5, r22	; 0x05
     902:	08 95       	ret

00000904 <_ZN14LoginInterface10checkLoginEv>:
	 passWord[3] = 50; // 2
	 
 }
 
 bool LoginInterface::checkLogin()
 {
     904:	ef 92       	push	r14
     906:	ff 92       	push	r15
     908:	1f 93       	push	r17
     90a:	cf 93       	push	r28
     90c:	df 93       	push	r29
     90e:	00 d0       	rcall	.+0      	; 0x910 <_ZN14LoginInterface10checkLoginEv+0xc>
     910:	1f 92       	push	r1
     912:	cd b7       	in	r28, 0x3d	; 61
     914:	de b7       	in	r29, 0x3e	; 62
     916:	7c 01       	movw	r14, r24
	 uint8_t userPressed = 0;
     918:	10 e0       	ldi	r17, 0x00	; 0
     91a:	01 c0       	rjmp	.+2      	; 0x91e <_ZN14LoginInterface10checkLoginEv+0x1a>
	 {
		 char buf = keypad.readKeyboard();
		 
		 if (buf == 42)
		 {
			 userPressed = 0;
     91c:	10 e0       	ldi	r17, 0x00	; 0
 bool LoginInterface::checkLogin()
 {
	 uint8_t userPressed = 0;
	 uint8_t userPass[4];
	 
	 while(userPressed < 4)
     91e:	14 30       	cpi	r17, 0x04	; 4
     920:	68 f4       	brcc	.+26     	; 0x93c <_ZN14LoginInterface10checkLoginEv+0x38>
	 {
		 char buf = keypad.readKeyboard();
     922:	c7 01       	movw	r24, r14
     924:	99 df       	rcall	.-206    	; 0x858 <_ZN6KeyPad12readKeyboardEv>
		 
		 if (buf == 42)
     926:	8a 32       	cpi	r24, 0x2A	; 42
     928:	c9 f3       	breq	.-14     	; 0x91c <_ZN14LoginInterface10checkLoginEv+0x18>
		 {
			 userPressed = 0;
		 }else
		 {
			 userPass[userPressed] = buf;
     92a:	e1 e0       	ldi	r30, 0x01	; 1
     92c:	f0 e0       	ldi	r31, 0x00	; 0
     92e:	ec 0f       	add	r30, r28
     930:	fd 1f       	adc	r31, r29
     932:	e1 0f       	add	r30, r17
     934:	f1 1d       	adc	r31, r1
     936:	80 83       	st	Z, r24
			 userPressed++; 
     938:	1f 5f       	subi	r17, 0xFF	; 255
     93a:	f1 cf       	rjmp	.-30     	; 0x91e <_ZN14LoginInterface10checkLoginEv+0x1a>
     93c:	10 e0       	ldi	r17, 0x00	; 0
		 }
	 }
	 
	 for (uint8_t i = 0; i < 4; i++)
     93e:	14 30       	cpi	r17, 0x04	; 4
     940:	a0 f4       	brcc	.+40     	; 0x96a <_ZN14LoginInterface10checkLoginEv+0x66>
	 {
		 if (userPass[i] != passWord[i])
     942:	81 2f       	mov	r24, r17
     944:	90 e0       	ldi	r25, 0x00	; 0
     946:	e1 e0       	ldi	r30, 0x01	; 1
     948:	f0 e0       	ldi	r31, 0x00	; 0
     94a:	ec 0f       	add	r30, r28
     94c:	fd 1f       	adc	r31, r29
     94e:	e8 0f       	add	r30, r24
     950:	f9 1f       	adc	r31, r25
     952:	20 81       	ld	r18, Z
     954:	f7 01       	movw	r30, r14
     956:	e8 0f       	add	r30, r24
     958:	f9 1f       	adc	r31, r25
     95a:	81 81       	ldd	r24, Z+1	; 0x01
     95c:	28 17       	cp	r18, r24
     95e:	19 f0       	breq	.+6      	; 0x966 <_ZN14LoginInterface10checkLoginEv+0x62>
		 {
			 setstateOfMachine('L');
     960:	6c e4       	ldi	r22, 0x4C	; 76
     962:	c7 01       	movw	r24, r14
     964:	cc df       	rcall	.-104    	; 0x8fe <_ZN14LoginInterface17setstateOfMachineEc>
			 userPass[userPressed] = buf;
			 userPressed++; 
		 }
	 }
	 
	 for (uint8_t i = 0; i < 4; i++)
     966:	1f 5f       	subi	r17, 0xFF	; 255
		 if (userPass[i] != passWord[i])
		 {
			 setstateOfMachine('L');
		 }
	 }
	 if (getstateOfMachine() == 'L')
     968:	ea cf       	rjmp	.-44     	; 0x93e <_ZN14LoginInterface10checkLoginEv+0x3a>
     96a:	c7 01       	movw	r24, r14
     96c:	c5 df       	rcall	.-118    	; 0x8f8 <_ZN14LoginInterface17getstateOfMachineEv>
     96e:	8c 34       	cpi	r24, 0x4C	; 76
	 {
		 setstateOfMachine('U');
     970:	21 f4       	brne	.+8      	; 0x97a <_ZN14LoginInterface10checkLoginEv+0x76>
     972:	65 e5       	ldi	r22, 0x55	; 85
     974:	c7 01       	movw	r24, r14
     976:	c3 df       	rcall	.-122    	; 0x8fe <_ZN14LoginInterface17setstateOfMachineEc>
	 }else
	 {
		 setstateOfMachine('L');	
     978:	03 c0       	rjmp	.+6      	; 0x980 <_ZN14LoginInterface10checkLoginEv+0x7c>
     97a:	6c e4       	ldi	r22, 0x4C	; 76
     97c:	c7 01       	movw	r24, r14
     97e:	bf df       	rcall	.-130    	; 0x8fe <_ZN14LoginInterface17setstateOfMachineEc>
	 }
 }
     980:	0f 90       	pop	r0
     982:	0f 90       	pop	r0
     984:	0f 90       	pop	r0
     986:	0f 90       	pop	r0
     988:	df 91       	pop	r29
     98a:	cf 91       	pop	r28
     98c:	1f 91       	pop	r17
     98e:	ff 90       	pop	r15
     990:	ef 90       	pop	r14
     992:	08 95       	ret

00000994 <_Z11LoginKeyPadPv>:
void * operator new(size_t size);
void operator delete(void * ptr);

int __cxa_guard_acquire(__guard *g) {return !*(char *)(g);};
void __cxa_guard_release (__guard *g) {*(char *)g = 1;};
void __cxa_guard_abort (__guard *) {};
     994:	87 e9       	ldi	r24, 0x97	; 151
     996:	92 e0       	ldi	r25, 0x02	; 2
     998:	b5 df       	rcall	.-150    	; 0x904 <_ZN14LoginInterface10checkLoginEv>
     99a:	fc cf       	rjmp	.-8      	; 0x994 <_Z11LoginKeyPadPv>

0000099c <_Z10DisplayArmPv>:
     99c:	8d e9       	ldi	r24, 0x9D	; 157
     99e:	92 e0       	ldi	r25, 0x02	; 2
     9a0:	0e 94 c2 13 	call	0x2784	; 0x2784 <_ZN11Touchscreen11clearScreenEv>
     9a4:	87 e9       	ldi	r24, 0x97	; 151
     9a6:	92 e0       	ldi	r25, 0x02	; 2
     9a8:	a7 df       	rcall	.-178    	; 0x8f8 <_ZN14LoginInterface17getstateOfMachineEv>
     9aa:	85 35       	cpi	r24, 0x55	; 85
     9ac:	b9 f7       	brne	.-18     	; 0x99c <_Z10DisplayArmPv>
     9ae:	8d e9       	ldi	r24, 0x9D	; 157
     9b0:	92 e0       	ldi	r25, 0x02	; 2
     9b2:	0e 94 d7 13 	call	0x27ae	; 0x27ae <_ZN11Touchscreen23presentButtonsOnDisplayEv>
     9b6:	8d e9       	ldi	r24, 0x9D	; 157
     9b8:	92 e0       	ldi	r25, 0x02	; 2
     9ba:	0e 94 37 13 	call	0x266e	; 0x266e <_ZN11Touchscreen12checkButtonsEv>
     9be:	81 30       	cpi	r24, 0x01	; 1
     9c0:	19 f0       	breq	.+6      	; 0x9c8 <_Z10DisplayArmPv+0x2c>
     9c2:	82 30       	cpi	r24, 0x02	; 2
     9c4:	61 f0       	breq	.+24     	; 0x9de <_Z10DisplayArmPv+0x42>
     9c6:	ee cf       	rjmp	.-36     	; 0x9a4 <_Z10DisplayArmPv+0x8>
     9c8:	60 91 96 02 	lds	r22, 0x0296	; 0x800296 <colorIndex>
     9cc:	83 eb       	ldi	r24, 0xB3	; 179
     9ce:	92 e0       	ldi	r25, 0x02	; 2
     9d0:	33 dd       	rcall	.-1434   	; 0x438 <_ZN11ColorSensor17addCalibrateColorEh>
     9d2:	80 91 96 02 	lds	r24, 0x0296	; 0x800296 <colorIndex>
     9d6:	8f 5f       	subi	r24, 0xFF	; 255
     9d8:	80 93 96 02 	sts	0x0296, r24	; 0x800296 <colorIndex>
     9dc:	e3 cf       	rjmp	.-58     	; 0x9a4 <_Z10DisplayArmPv+0x8>
     9de:	83 eb       	ldi	r24, 0xB3	; 179
     9e0:	92 e0       	ldi	r25, 0x02	; 2
     9e2:	93 dc       	rcall	.-1754   	; 0x30a <_ZN11ColorSensor8getColorEv>
     9e4:	68 2f       	mov	r22, r24
     9e6:	8e e0       	ldi	r24, 0x0E	; 14
     9e8:	93 e0       	ldi	r25, 0x03	; 3
     9ea:	f6 d1       	rcall	.+1004   	; 0xdd8 <_ZN8Robotarm8MoveItemEh>
     9ec:	db cf       	rjmp	.-74     	; 0x9a4 <_Z10DisplayArmPv+0x8>

000009ee <_Z41__static_initialization_and_destruction_0ii>:
     9ee:	0f 93       	push	r16
     9f0:	1f 93       	push	r17
     9f2:	cf 93       	push	r28
     9f4:	df 93       	push	r29
     9f6:	ec 01       	movw	r28, r24
     9f8:	8b 01       	movw	r16, r22
     9fa:	01 97       	sbiw	r24, 0x01	; 1
     9fc:	89 f4       	brne	.+34     	; 0xa20 <_Z41__static_initialization_and_destruction_0ii+0x32>
     9fe:	6f 3f       	cpi	r22, 0xFF	; 255
     a00:	7f 4f       	sbci	r23, 0xFF	; 255
     a02:	71 f4       	brne	.+28     	; 0xa20 <_Z41__static_initialization_and_destruction_0ii+0x32>
     a04:	8e e0       	ldi	r24, 0x0E	; 14
     a06:	93 e0       	ldi	r25, 0x03	; 3
     a08:	61 d0       	rcall	.+194    	; 0xacc <_ZN8RobotarmC1Ev>
     a0a:	62 e0       	ldi	r22, 0x02	; 2
     a0c:	83 eb       	ldi	r24, 0xB3	; 179
     a0e:	92 e0       	ldi	r25, 0x02	; 2
     a10:	80 dd       	rcall	.-1280   	; 0x512 <_ZN11ColorSensorC1E16FrequencyScaling>
     a12:	8d e9       	ldi	r24, 0x9D	; 157
     a14:	92 e0       	ldi	r25, 0x02	; 2
     a16:	0e 94 cf 12 	call	0x259e	; 0x259e <_ZN11TouchscreenC1Ev>
     a1a:	87 e9       	ldi	r24, 0x97	; 151
     a1c:	92 e0       	ldi	r25, 0x02	; 2
     a1e:	51 df       	rcall	.-350    	; 0x8c2 <_ZN14LoginInterfaceC1Ev>
     a20:	cd 2b       	or	r28, r29
     a22:	31 f4       	brne	.+12     	; 0xa30 <_Z41__static_initialization_and_destruction_0ii+0x42>
     a24:	0f 3f       	cpi	r16, 0xFF	; 255
     a26:	1f 4f       	sbci	r17, 0xFF	; 255
     a28:	19 f4       	brne	.+6      	; 0xa30 <_Z41__static_initialization_and_destruction_0ii+0x42>
     a2a:	83 eb       	ldi	r24, 0xB3	; 179
     a2c:	92 e0       	ldi	r25, 0x02	; 2
     a2e:	2a dc       	rcall	.-1964   	; 0x284 <_ZN11ColorSensorD1Ev>
     a30:	df 91       	pop	r29
     a32:	cf 91       	pop	r28
     a34:	1f 91       	pop	r17
     a36:	0f 91       	pop	r16
     a38:	08 95       	ret

00000a3a <__cxa_pure_virtual>:
     a3a:	ff cf       	rjmp	.-2      	; 0xa3a <__cxa_pure_virtual>

00000a3c <_Znwj>:

void * operator new(size_t size)
{
	return malloc(size);
     a3c:	0c 94 01 17 	jmp	0x2e02	; 0x2e02 <malloc>
}
     a40:	08 95       	ret

00000a42 <_ZdlPv>:

void operator delete(void * ptr)
{
	ptr != NULL ? free(ptr) : void(0);
     a42:	00 97       	sbiw	r24, 0x00	; 0
     a44:	11 f0       	breq	.+4      	; 0xa4a <_ZdlPv+0x8>
     a46:	0c 94 99 17 	jmp	0x2f32	; 0x2f32 <free>
     a4a:	08 95       	ret

00000a4c <main>:
	}
}

int main(void)
{
	xTaskCreate(DisplayArm,  ( signed char * ) "Display + Arm Task", configMAIN_STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL);
     a4c:	a1 2c       	mov	r10, r1
     a4e:	b1 2c       	mov	r11, r1
     a50:	c1 2c       	mov	r12, r1
     a52:	d1 2c       	mov	r13, r1
     a54:	e1 2c       	mov	r14, r1
     a56:	f1 2c       	mov	r15, r1
     a58:	00 e0       	ldi	r16, 0x00	; 0
     a5a:	20 e0       	ldi	r18, 0x00	; 0
     a5c:	30 e0       	ldi	r19, 0x00	; 0
     a5e:	48 ec       	ldi	r20, 0xC8	; 200
     a60:	50 e0       	ldi	r21, 0x00	; 0
     a62:	6e e0       	ldi	r22, 0x0E	; 14
     a64:	72 e0       	ldi	r23, 0x02	; 2
     a66:	8e ec       	ldi	r24, 0xCE	; 206
     a68:	94 e0       	ldi	r25, 0x04	; 4
     a6a:	0e 94 6b 0f 	call	0x1ed6	; 0x1ed6 <xTaskGenericCreate>
	xTaskCreate(LoginKeyPad,  ( signed char * ) "Keypad Task", configMAIN_STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL);
     a6e:	20 e0       	ldi	r18, 0x00	; 0
     a70:	30 e0       	ldi	r19, 0x00	; 0
     a72:	48 ec       	ldi	r20, 0xC8	; 200
     a74:	50 e0       	ldi	r21, 0x00	; 0
     a76:	61 e2       	ldi	r22, 0x21	; 33
     a78:	72 e0       	ldi	r23, 0x02	; 2
     a7a:	8a ec       	ldi	r24, 0xCA	; 202
     a7c:	94 e0       	ldi	r25, 0x04	; 4
     a7e:	0e 94 6b 0f 	call	0x1ed6	; 0x1ed6 <xTaskGenericCreate>
	vTaskStartScheduler();
     a82:	0e 94 23 10 	call	0x2046	; 0x2046 <vTaskStartScheduler>
     a86:	ff cf       	rjmp	.-2      	; 0xa86 <main+0x3a>

00000a88 <_GLOBAL__sub_I___cxa_pure_virtual>:

	while (1)
	{
	}
}
     a88:	6f ef       	ldi	r22, 0xFF	; 255
     a8a:	7f ef       	ldi	r23, 0xFF	; 255
     a8c:	81 e0       	ldi	r24, 0x01	; 1
     a8e:	90 e0       	ldi	r25, 0x00	; 0
     a90:	ae cf       	rjmp	.-164    	; 0x9ee <_Z41__static_initialization_and_destruction_0ii>
     a92:	08 95       	ret

00000a94 <_GLOBAL__sub_D___cxa_pure_virtual>:
     a94:	6f ef       	ldi	r22, 0xFF	; 255
     a96:	7f ef       	ldi	r23, 0xFF	; 255
     a98:	80 e0       	ldi	r24, 0x00	; 0
     a9a:	90 e0       	ldi	r25, 0x00	; 0
     a9c:	a8 cf       	rjmp	.-176    	; 0x9ee <_Z41__static_initialization_and_destruction_0ii>
     a9e:	08 95       	ret

00000aa0 <_ZN8Robotarm14startMotorImplEPv>:
	motors_[3]->SetDegrees(90);
	vTaskDelay( 250 / portTICK_RATE_MS );
}

void Robotarm::startMotorImpl( void *_this )
{
     aa0:	8c 01       	movw	r16, r24
void Robotarm::MotorSpeedController()
{
	while(1)
	{
		/* Move all motors one step. */
		for ( uint8_t i = 0U; i < 6U; i++ )
     aa2:	c0 e0       	ldi	r28, 0x00	; 0
     aa4:	c6 30       	cpi	r28, 0x06	; 6
     aa6:	e8 f7       	brcc	.-6      	; 0xaa2 <_ZN8Robotarm14startMotorImplEPv+0x2>
		{
			motors_[i]->TurnMotor();
     aa8:	ec 2f       	mov	r30, r28
     aaa:	f0 e0       	ldi	r31, 0x00	; 0
     aac:	31 96       	adiw	r30, 0x01	; 1
     aae:	ee 0f       	add	r30, r30
     ab0:	ff 1f       	adc	r31, r31
     ab2:	e0 0f       	add	r30, r16
     ab4:	f1 1f       	adc	r31, r17
     ab6:	80 81       	ld	r24, Z
     ab8:	91 81       	ldd	r25, Z+1	; 0x01
     aba:	dc 01       	movw	r26, r24
     abc:	ed 91       	ld	r30, X+
     abe:	fc 91       	ld	r31, X
     ac0:	04 80       	ldd	r0, Z+4	; 0x04
     ac2:	f5 81       	ldd	r31, Z+5	; 0x05
     ac4:	e0 2d       	mov	r30, r0
     ac6:	19 95       	eicall
void Robotarm::MotorSpeedController()
{
	while(1)
	{
		/* Move all motors one step. */
		for ( uint8_t i = 0U; i < 6U; i++ )
     ac8:	cf 5f       	subi	r28, 0xFF	; 255
     aca:	ec cf       	rjmp	.-40     	; 0xaa4 <_ZN8Robotarm14startMotorImplEPv+0x4>

00000acc <_ZN8RobotarmC1Ev>:
/* RTOS include */
#include "FreeRTOS.h"
#include "task.h"
#include "portmacro.h"

Robotarm::Robotarm() : tmr1_(), tmr3_()
     acc:	af 92       	push	r10
     ace:	bf 92       	push	r11
     ad0:	cf 92       	push	r12
     ad2:	df 92       	push	r13
     ad4:	ef 92       	push	r14
     ad6:	ff 92       	push	r15
     ad8:	0f 93       	push	r16
     ada:	1f 93       	push	r17
     adc:	cf 93       	push	r28
     ade:	df 93       	push	r29
     ae0:	ec 01       	movw	r28, r24
     ae2:	d5 d5       	rcall	.+2986   	; 0x168e <_ZN6Timer1C1Ev>
     ae4:	8e 01       	movw	r16, r28
     ae6:	0f 5f       	subi	r16, 0xFF	; 255
     ae8:	1f 4f       	sbci	r17, 0xFF	; 255
     aea:	c8 01       	movw	r24, r16
     aec:	75 d6       	rcall	.+3306   	; 0x17d8 <_ZN6Timer5C1Ev>
{
	/* Create all motor objects */
	motors_[0] = new M1( &tmr1_ );
     aee:	89 e1       	ldi	r24, 0x19	; 25
     af0:	90 e0       	ldi	r25, 0x00	; 0
     af2:	a4 df       	rcall	.-184    	; 0xa3c <_Znwj>
     af4:	7c 01       	movw	r14, r24
     af6:	be 01       	movw	r22, r28
     af8:	66 d2       	rcall	.+1228   	; 0xfc6 <_ZN2M1C1EP6Timer1>
     afa:	fb 82       	std	Y+3, r15	; 0x03
     afc:	ea 82       	std	Y+2, r14	; 0x02
	motors_[1] = new M2( &tmr1_ );
     afe:	89 e1       	ldi	r24, 0x19	; 25
     b00:	90 e0       	ldi	r25, 0x00	; 0
     b02:	9c df       	rcall	.-200    	; 0xa3c <_Znwj>
     b04:	7c 01       	movw	r14, r24
     b06:	be 01       	movw	r22, r28
     b08:	04 d3       	rcall	.+1544   	; 0x1112 <_ZN2M2C1EP6Timer1>
     b0a:	fd 82       	std	Y+5, r15	; 0x05
     b0c:	ec 82       	std	Y+4, r14	; 0x04
	motors_[2] = new M3( &tmr1_ );
     b0e:	89 e1       	ldi	r24, 0x19	; 25
     b10:	90 e0       	ldi	r25, 0x00	; 0
     b12:	94 df       	rcall	.-216    	; 0xa3c <_Znwj>
     b14:	7c 01       	movw	r14, r24
     b16:	be 01       	movw	r22, r28
     b18:	a2 d3       	rcall	.+1860   	; 0x125e <_ZN2M3C1EP6Timer1>
     b1a:	ff 82       	std	Y+7, r15	; 0x07
     b1c:	ee 82       	std	Y+6, r14	; 0x06
	motors_[3] = new M4( &tmr3_ );
     b1e:	89 e1       	ldi	r24, 0x19	; 25
     b20:	90 e0       	ldi	r25, 0x00	; 0
     b22:	8c df       	rcall	.-232    	; 0xa3c <_Znwj>
     b24:	7c 01       	movw	r14, r24
     b26:	b8 01       	movw	r22, r16
     b28:	3e d4       	rcall	.+2172   	; 0x13a6 <_ZN2M4C1EP6Timer5>
     b2a:	f9 86       	std	Y+9, r15	; 0x09
     b2c:	e8 86       	std	Y+8, r14	; 0x08
	motors_[4] = new M5( &tmr3_ );
     b2e:	89 e1       	ldi	r24, 0x19	; 25
     b30:	90 e0       	ldi	r25, 0x00	; 0
     b32:	84 df       	rcall	.-248    	; 0xa3c <_Znwj>
     b34:	7c 01       	movw	r14, r24
     b36:	b8 01       	movw	r22, r16
     b38:	da d4       	rcall	.+2484   	; 0x14ee <_ZN2M5C1EP6Timer5>
     b3a:	fb 86       	std	Y+11, r15	; 0x0b
     b3c:	ea 86       	std	Y+10, r14	; 0x0a
	motors_[5] = new M6( &tmr3_ );
     b3e:	89 e1       	ldi	r24, 0x19	; 25
     b40:	90 e0       	ldi	r25, 0x00	; 0
     b42:	7c df       	rcall	.-264    	; 0xa3c <_Znwj>
     b44:	7c 01       	movw	r14, r24
     b46:	b8 01       	movw	r22, r16
     b48:	72 d5       	rcall	.+2788   	; 0x162e <_ZN2M6C1EP6Timer5>
     b4a:	fd 86       	std	Y+13, r15	; 0x0d
     b4c:	ec 86       	std	Y+12, r14	; 0x0c
     b4e:	a1 2c       	mov	r10, r1
     b50:	b1 2c       	mov	r11, r1
	
	/* Create task to control motors */
	xTaskCreate(this->startMotorImpl,  ( signed char * ) "Motors", configMAIN_STACK_SIZE, this, tskIDLE_PRIORITY, NULL);
     b52:	c1 2c       	mov	r12, r1
     b54:	d1 2c       	mov	r13, r1
     b56:	e1 2c       	mov	r14, r1
     b58:	f1 2c       	mov	r15, r1
     b5a:	00 e0       	ldi	r16, 0x00	; 0
     b5c:	9e 01       	movw	r18, r28
     b5e:	48 ec       	ldi	r20, 0xC8	; 200
     b60:	50 e0       	ldi	r21, 0x00	; 0
     b62:	6d e2       	ldi	r22, 0x2D	; 45
     b64:	72 e0       	ldi	r23, 0x02	; 2
     b66:	80 e5       	ldi	r24, 0x50	; 80
     b68:	95 e0       	ldi	r25, 0x05	; 5
     b6a:	0e 94 6b 0f 	call	0x1ed6	; 0x1ed6 <xTaskGenericCreate>
     b6e:	df 91       	pop	r29
     b70:	cf 91       	pop	r28
}
     b72:	1f 91       	pop	r17
     b74:	0f 91       	pop	r16
     b76:	ff 90       	pop	r15
     b78:	ef 90       	pop	r14
     b7a:	df 90       	pop	r13
     b7c:	cf 90       	pop	r12
     b7e:	bf 90       	pop	r11
     b80:	af 90       	pop	r10
     b82:	08 95       	ret

00000b84 <_ZN8Robotarm9grabBlockEv>:
     b84:	cf 93       	push	r28
     b86:	df 93       	push	r29
		break;
	}
}

void Robotarm::grabBlock()
{
     b88:	ec 01       	movw	r28, r24
	motors_[3]->SetDegrees(40);
     b8a:	88 85       	ldd	r24, Y+8	; 0x08
     b8c:	99 85       	ldd	r25, Y+9	; 0x09
     b8e:	dc 01       	movw	r26, r24
     b90:	ed 91       	ld	r30, X+
     b92:	fc 91       	ld	r31, X
     b94:	06 80       	ldd	r0, Z+6	; 0x06
     b96:	f7 81       	ldd	r31, Z+7	; 0x07
     b98:	e0 2d       	mov	r30, r0
     b9a:	68 e2       	ldi	r22, 0x28	; 40
     b9c:	19 95       	eicall
	motors_[4]->SetDegrees(90);
     b9e:	8a 85       	ldd	r24, Y+10	; 0x0a
     ba0:	9b 85       	ldd	r25, Y+11	; 0x0b
     ba2:	dc 01       	movw	r26, r24
     ba4:	ed 91       	ld	r30, X+
     ba6:	fc 91       	ld	r31, X
     ba8:	06 80       	ldd	r0, Z+6	; 0x06
     baa:	f7 81       	ldd	r31, Z+7	; 0x07
     bac:	e0 2d       	mov	r30, r0
     bae:	6a e5       	ldi	r22, 0x5A	; 90
     bb0:	19 95       	eicall
	motors_[0]->SetDegrees(0);
     bb2:	8a 81       	ldd	r24, Y+2	; 0x02
     bb4:	9b 81       	ldd	r25, Y+3	; 0x03
     bb6:	dc 01       	movw	r26, r24
     bb8:	ed 91       	ld	r30, X+
     bba:	fc 91       	ld	r31, X
     bbc:	06 80       	ldd	r0, Z+6	; 0x06
     bbe:	f7 81       	ldd	r31, Z+7	; 0x07
     bc0:	e0 2d       	mov	r30, r0
     bc2:	60 e0       	ldi	r22, 0x00	; 0
     bc4:	19 95       	eicall
	vTaskDelay( 1500 / portTICK_RATE_MS );
     bc6:	8c ed       	ldi	r24, 0xDC	; 220
     bc8:	95 e0       	ldi	r25, 0x05	; 5
     bca:	0e 94 6a 11 	call	0x22d4	; 0x22d4 <vTaskDelay>
	motors_[1]->SetDegrees(35);
     bce:	8c 81       	ldd	r24, Y+4	; 0x04
     bd0:	9d 81       	ldd	r25, Y+5	; 0x05
     bd2:	dc 01       	movw	r26, r24
     bd4:	ed 91       	ld	r30, X+
     bd6:	fc 91       	ld	r31, X
     bd8:	06 80       	ldd	r0, Z+6	; 0x06
     bda:	f7 81       	ldd	r31, Z+7	; 0x07
     bdc:	e0 2d       	mov	r30, r0
     bde:	63 e2       	ldi	r22, 0x23	; 35
     be0:	19 95       	eicall
	motors_[2]->SetDegrees(63);
     be2:	8e 81       	ldd	r24, Y+6	; 0x06
     be4:	9f 81       	ldd	r25, Y+7	; 0x07
     be6:	dc 01       	movw	r26, r24
     be8:	ed 91       	ld	r30, X+
     bea:	fc 91       	ld	r31, X
     bec:	06 80       	ldd	r0, Z+6	; 0x06
     bee:	f7 81       	ldd	r31, Z+7	; 0x07
     bf0:	e0 2d       	mov	r30, r0
     bf2:	6f e3       	ldi	r22, 0x3F	; 63
     bf4:	19 95       	eicall
	vTaskDelay( 1500 / portTICK_RATE_MS );
     bf6:	8c ed       	ldi	r24, 0xDC	; 220
     bf8:	95 e0       	ldi	r25, 0x05	; 5
     bfa:	0e 94 6a 11 	call	0x22d4	; 0x22d4 <vTaskDelay>
	motors_[5]->SetDegrees(63);
     bfe:	8c 85       	ldd	r24, Y+12	; 0x0c
     c00:	9d 85       	ldd	r25, Y+13	; 0x0d
     c02:	dc 01       	movw	r26, r24
     c04:	ed 91       	ld	r30, X+
     c06:	fc 91       	ld	r31, X
     c08:	06 80       	ldd	r0, Z+6	; 0x06
     c0a:	f7 81       	ldd	r31, Z+7	; 0x07
     c0c:	e0 2d       	mov	r30, r0
     c0e:	6f e3       	ldi	r22, 0x3F	; 63
     c10:	19 95       	eicall
	vTaskDelay( 250 / portTICK_RATE_MS );
     c12:	8a ef       	ldi	r24, 0xFA	; 250
     c14:	90 e0       	ldi	r25, 0x00	; 0
     c16:	0e 94 6a 11 	call	0x22d4	; 0x22d4 <vTaskDelay>
	motors_[1]->SetDegrees(70);
     c1a:	8c 81       	ldd	r24, Y+4	; 0x04
     c1c:	9d 81       	ldd	r25, Y+5	; 0x05
     c1e:	dc 01       	movw	r26, r24
     c20:	ed 91       	ld	r30, X+
     c22:	fc 91       	ld	r31, X
     c24:	06 80       	ldd	r0, Z+6	; 0x06
     c26:	f7 81       	ldd	r31, Z+7	; 0x07
     c28:	e0 2d       	mov	r30, r0
     c2a:	66 e4       	ldi	r22, 0x46	; 70
     c2c:	19 95       	eicall
	motors_[2]->SetDegrees(70);
     c2e:	8e 81       	ldd	r24, Y+6	; 0x06
     c30:	9f 81       	ldd	r25, Y+7	; 0x07
     c32:	dc 01       	movw	r26, r24
     c34:	ed 91       	ld	r30, X+
     c36:	fc 91       	ld	r31, X
     c38:	06 80       	ldd	r0, Z+6	; 0x06
     c3a:	f7 81       	ldd	r31, Z+7	; 0x07
     c3c:	e0 2d       	mov	r30, r0
     c3e:	66 e4       	ldi	r22, 0x46	; 70
     c40:	19 95       	eicall
	motors_[3]->SetDegrees(70);
     c42:	88 85       	ldd	r24, Y+8	; 0x08
     c44:	99 85       	ldd	r25, Y+9	; 0x09
     c46:	dc 01       	movw	r26, r24
     c48:	ed 91       	ld	r30, X+
     c4a:	fc 91       	ld	r31, X
     c4c:	06 80       	ldd	r0, Z+6	; 0x06
     c4e:	f7 81       	ldd	r31, Z+7	; 0x07
     c50:	e0 2d       	mov	r30, r0
     c52:	66 e4       	ldi	r22, 0x46	; 70
     c54:	19 95       	eicall
}
     c56:	df 91       	pop	r29
     c58:	cf 91       	pop	r28
     c5a:	08 95       	ret

00000c5c <_ZN8Robotarm18ArmDownReleaseItemEv>:
	motors_[0]->SetDegrees(180);
	ArmDownReleaseItem();
}

void Robotarm::ArmDownReleaseItem()
{
     c5c:	cf 93       	push	r28
     c5e:	df 93       	push	r29
     c60:	ec 01       	movw	r28, r24
	vTaskDelay( 1500 / portTICK_RATE_MS );
     c62:	8c ed       	ldi	r24, 0xDC	; 220
     c64:	95 e0       	ldi	r25, 0x05	; 5
     c66:	0e 94 6a 11 	call	0x22d4	; 0x22d4 <vTaskDelay>
	motors_[1]->SetDegrees(35);
     c6a:	8c 81       	ldd	r24, Y+4	; 0x04
     c6c:	9d 81       	ldd	r25, Y+5	; 0x05
     c6e:	dc 01       	movw	r26, r24
     c70:	ed 91       	ld	r30, X+
     c72:	fc 91       	ld	r31, X
     c74:	06 80       	ldd	r0, Z+6	; 0x06
     c76:	f7 81       	ldd	r31, Z+7	; 0x07
     c78:	e0 2d       	mov	r30, r0
     c7a:	63 e2       	ldi	r22, 0x23	; 35
     c7c:	19 95       	eicall
	motors_[2]->SetDegrees(40);
     c7e:	8e 81       	ldd	r24, Y+6	; 0x06
     c80:	9f 81       	ldd	r25, Y+7	; 0x07
     c82:	dc 01       	movw	r26, r24
     c84:	ed 91       	ld	r30, X+
     c86:	fc 91       	ld	r31, X
     c88:	06 80       	ldd	r0, Z+6	; 0x06
     c8a:	f7 81       	ldd	r31, Z+7	; 0x07
     c8c:	e0 2d       	mov	r30, r0
     c8e:	68 e2       	ldi	r22, 0x28	; 40
     c90:	19 95       	eicall
	vTaskDelay( 1500 / portTICK_RATE_MS );
     c92:	8c ed       	ldi	r24, 0xDC	; 220
     c94:	95 e0       	ldi	r25, 0x05	; 5
     c96:	0e 94 6a 11 	call	0x22d4	; 0x22d4 <vTaskDelay>
	motors_[5]->SetDegrees(0);
     c9a:	8c 85       	ldd	r24, Y+12	; 0x0c
     c9c:	9d 85       	ldd	r25, Y+13	; 0x0d
     c9e:	dc 01       	movw	r26, r24
     ca0:	ed 91       	ld	r30, X+
     ca2:	fc 91       	ld	r31, X
     ca4:	06 80       	ldd	r0, Z+6	; 0x06
     ca6:	f7 81       	ldd	r31, Z+7	; 0x07
     ca8:	e0 2d       	mov	r30, r0
     caa:	60 e0       	ldi	r22, 0x00	; 0
     cac:	19 95       	eicall
	vTaskDelay( 250 / portTICK_RATE_MS );
     cae:	8a ef       	ldi	r24, 0xFA	; 250
     cb0:	90 e0       	ldi	r25, 0x00	; 0
     cb2:	0e 94 6a 11 	call	0x22d4	; 0x22d4 <vTaskDelay>
	motors_[1]->SetDegrees(90);
     cb6:	8c 81       	ldd	r24, Y+4	; 0x04
     cb8:	9d 81       	ldd	r25, Y+5	; 0x05
     cba:	dc 01       	movw	r26, r24
     cbc:	ed 91       	ld	r30, X+
     cbe:	fc 91       	ld	r31, X
     cc0:	06 80       	ldd	r0, Z+6	; 0x06
     cc2:	f7 81       	ldd	r31, Z+7	; 0x07
     cc4:	e0 2d       	mov	r30, r0
     cc6:	6a e5       	ldi	r22, 0x5A	; 90
     cc8:	19 95       	eicall
	motors_[2]->SetDegrees(90);
     cca:	8e 81       	ldd	r24, Y+6	; 0x06
     ccc:	9f 81       	ldd	r25, Y+7	; 0x07
     cce:	dc 01       	movw	r26, r24
     cd0:	ed 91       	ld	r30, X+
     cd2:	fc 91       	ld	r31, X
     cd4:	06 80       	ldd	r0, Z+6	; 0x06
     cd6:	f7 81       	ldd	r31, Z+7	; 0x07
     cd8:	e0 2d       	mov	r30, r0
     cda:	6a e5       	ldi	r22, 0x5A	; 90
     cdc:	19 95       	eicall
	motors_[3]->SetDegrees(90);
     cde:	88 85       	ldd	r24, Y+8	; 0x08
     ce0:	99 85       	ldd	r25, Y+9	; 0x09
     ce2:	dc 01       	movw	r26, r24
     ce4:	ed 91       	ld	r30, X+
     ce6:	fc 91       	ld	r31, X
     ce8:	06 80       	ldd	r0, Z+6	; 0x06
     cea:	f7 81       	ldd	r31, Z+7	; 0x07
     cec:	e0 2d       	mov	r30, r0
     cee:	6a e5       	ldi	r22, 0x5A	; 90
     cf0:	19 95       	eicall
	vTaskDelay( 250 / portTICK_RATE_MS );
     cf2:	8a ef       	ldi	r24, 0xFA	; 250
     cf4:	90 e0       	ldi	r25, 0x00	; 0
     cf6:	0e 94 6a 11 	call	0x22d4	; 0x22d4 <vTaskDelay>
}
     cfa:	df 91       	pop	r29
     cfc:	cf 91       	pop	r28
     cfe:	08 95       	ret

00000d00 <_ZN8Robotarm18moveBlockToZoneOneEv>:
	motors_[2]->SetDegrees(70);
	motors_[3]->SetDegrees(70);
}

void Robotarm::moveBlockToZoneOne()
{
     d00:	cf 93       	push	r28
     d02:	df 93       	push	r29
     d04:	ec 01       	movw	r28, r24
	motors_[0]->SetDegrees(40);
     d06:	8a 81       	ldd	r24, Y+2	; 0x02
     d08:	9b 81       	ldd	r25, Y+3	; 0x03
     d0a:	dc 01       	movw	r26, r24
     d0c:	ed 91       	ld	r30, X+
     d0e:	fc 91       	ld	r31, X
     d10:	06 80       	ldd	r0, Z+6	; 0x06
     d12:	f7 81       	ldd	r31, Z+7	; 0x07
     d14:	e0 2d       	mov	r30, r0
     d16:	68 e2       	ldi	r22, 0x28	; 40
     d18:	19 95       	eicall
	ArmDownReleaseItem();
     d1a:	ce 01       	movw	r24, r28
     d1c:	9f df       	rcall	.-194    	; 0xc5c <_ZN8Robotarm18ArmDownReleaseItemEv>
}
     d1e:	df 91       	pop	r29
     d20:	cf 91       	pop	r28
     d22:	08 95       	ret

00000d24 <_ZN8Robotarm18moveBlockToZoneTwoEv>:

void Robotarm::moveBlockToZoneTwo()
{
     d24:	cf 93       	push	r28
     d26:	df 93       	push	r29
     d28:	ec 01       	movw	r28, r24
	motors_[0]->SetDegrees(68);
     d2a:	8a 81       	ldd	r24, Y+2	; 0x02
     d2c:	9b 81       	ldd	r25, Y+3	; 0x03
     d2e:	dc 01       	movw	r26, r24
     d30:	ed 91       	ld	r30, X+
     d32:	fc 91       	ld	r31, X
     d34:	06 80       	ldd	r0, Z+6	; 0x06
     d36:	f7 81       	ldd	r31, Z+7	; 0x07
     d38:	e0 2d       	mov	r30, r0
     d3a:	64 e4       	ldi	r22, 0x44	; 68
     d3c:	19 95       	eicall
	ArmDownReleaseItem();
     d3e:	ce 01       	movw	r24, r28
     d40:	8d df       	rcall	.-230    	; 0xc5c <_ZN8Robotarm18ArmDownReleaseItemEv>
}
     d42:	df 91       	pop	r29
     d44:	cf 91       	pop	r28
     d46:	08 95       	ret

00000d48 <_ZN8Robotarm20moveBlockToZoneThreeEv>:

void Robotarm::moveBlockToZoneThree()
{
     d48:	cf 93       	push	r28
     d4a:	df 93       	push	r29
     d4c:	ec 01       	movw	r28, r24
	motors_[0]->SetDegrees(96);
     d4e:	8a 81       	ldd	r24, Y+2	; 0x02
     d50:	9b 81       	ldd	r25, Y+3	; 0x03
     d52:	dc 01       	movw	r26, r24
     d54:	ed 91       	ld	r30, X+
     d56:	fc 91       	ld	r31, X
     d58:	06 80       	ldd	r0, Z+6	; 0x06
     d5a:	f7 81       	ldd	r31, Z+7	; 0x07
     d5c:	e0 2d       	mov	r30, r0
     d5e:	60 e6       	ldi	r22, 0x60	; 96
     d60:	19 95       	eicall
	ArmDownReleaseItem();
     d62:	ce 01       	movw	r24, r28
     d64:	7b df       	rcall	.-266    	; 0xc5c <_ZN8Robotarm18ArmDownReleaseItemEv>
}
     d66:	df 91       	pop	r29
     d68:	cf 91       	pop	r28
     d6a:	08 95       	ret

00000d6c <_ZN8Robotarm19moveBlockToZoneFourEv>:

void Robotarm::moveBlockToZoneFour()
{
     d6c:	cf 93       	push	r28
     d6e:	df 93       	push	r29
     d70:	ec 01       	movw	r28, r24
	motors_[0]->SetDegrees(124);
     d72:	8a 81       	ldd	r24, Y+2	; 0x02
     d74:	9b 81       	ldd	r25, Y+3	; 0x03
     d76:	dc 01       	movw	r26, r24
     d78:	ed 91       	ld	r30, X+
     d7a:	fc 91       	ld	r31, X
     d7c:	06 80       	ldd	r0, Z+6	; 0x06
     d7e:	f7 81       	ldd	r31, Z+7	; 0x07
     d80:	e0 2d       	mov	r30, r0
     d82:	6c e7       	ldi	r22, 0x7C	; 124
     d84:	19 95       	eicall
	ArmDownReleaseItem();
     d86:	ce 01       	movw	r24, r28
     d88:	69 df       	rcall	.-302    	; 0xc5c <_ZN8Robotarm18ArmDownReleaseItemEv>
}
     d8a:	df 91       	pop	r29
     d8c:	cf 91       	pop	r28
     d8e:	08 95       	ret

00000d90 <_ZN8Robotarm19moveBlockToZoneFiveEv>:

void Robotarm::moveBlockToZoneFive()
{
     d90:	cf 93       	push	r28
     d92:	df 93       	push	r29
     d94:	ec 01       	movw	r28, r24
	motors_[0]->SetDegrees(152);
     d96:	8a 81       	ldd	r24, Y+2	; 0x02
     d98:	9b 81       	ldd	r25, Y+3	; 0x03
     d9a:	dc 01       	movw	r26, r24
     d9c:	ed 91       	ld	r30, X+
     d9e:	fc 91       	ld	r31, X
     da0:	06 80       	ldd	r0, Z+6	; 0x06
     da2:	f7 81       	ldd	r31, Z+7	; 0x07
     da4:	e0 2d       	mov	r30, r0
     da6:	68 e9       	ldi	r22, 0x98	; 152
     da8:	19 95       	eicall
	ArmDownReleaseItem();
     daa:	ce 01       	movw	r24, r28
     dac:	57 df       	rcall	.-338    	; 0xc5c <_ZN8Robotarm18ArmDownReleaseItemEv>
}
     dae:	df 91       	pop	r29
     db0:	cf 91       	pop	r28
     db2:	08 95       	ret

00000db4 <_ZN8Robotarm18moveBlockToZoneSixEv>:

void Robotarm::moveBlockToZoneSix()
{
     db4:	cf 93       	push	r28
     db6:	df 93       	push	r29
     db8:	ec 01       	movw	r28, r24
	motors_[0]->SetDegrees(180);
     dba:	8a 81       	ldd	r24, Y+2	; 0x02
     dbc:	9b 81       	ldd	r25, Y+3	; 0x03
     dbe:	dc 01       	movw	r26, r24
     dc0:	ed 91       	ld	r30, X+
     dc2:	fc 91       	ld	r31, X
     dc4:	06 80       	ldd	r0, Z+6	; 0x06
     dc6:	f7 81       	ldd	r31, Z+7	; 0x07
     dc8:	e0 2d       	mov	r30, r0
     dca:	64 eb       	ldi	r22, 0xB4	; 180
     dcc:	19 95       	eicall
	ArmDownReleaseItem();
     dce:	ce 01       	movw	r24, r28
     dd0:	45 df       	rcall	.-374    	; 0xc5c <_ZN8Robotarm18ArmDownReleaseItemEv>
}
     dd2:	df 91       	pop	r29
     dd4:	cf 91       	pop	r28
     dd6:	08 95       	ret

00000dd8 <_ZN8Robotarm8MoveItemEh>:
	/* Create task to control motors */
	xTaskCreate(this->startMotorImpl,  ( signed char * ) "Motors", configMAIN_STACK_SIZE, this, tskIDLE_PRIORITY, NULL);
}

void Robotarm::MoveItem( uint8_t color )
{
     dd8:	cf 93       	push	r28
     dda:	df 93       	push	r29
     ddc:	ec 01       	movw	r28, r24
	switch ( color )
     dde:	62 30       	cpi	r22, 0x02	; 2
     de0:	29 f1       	breq	.+74     	; 0xe2c <_ZN8Robotarm8MoveItemEh+0x54>
     de2:	28 f4       	brcc	.+10     	; 0xdee <_ZN8Robotarm8MoveItemEh+0x16>
     de4:	66 23       	and	r22, r22
     de6:	51 f0       	breq	.+20     	; 0xdfc <_ZN8Robotarm8MoveItemEh+0x24>
     de8:	61 30       	cpi	r22, 0x01	; 1
     dea:	a1 f0       	breq	.+40     	; 0xe14 <_ZN8Robotarm8MoveItemEh+0x3c>
     dec:	4e c0       	rjmp	.+156    	; 0xe8a <_ZN8Robotarm8MoveItemEh+0xb2>
     dee:	64 30       	cpi	r22, 0x04	; 4
     df0:	a9 f1       	breq	.+106    	; 0xe5c <_ZN8Robotarm8MoveItemEh+0x84>
     df2:	40 f1       	brcs	.+80     	; 0xe44 <_ZN8Robotarm8MoveItemEh+0x6c>
     df4:	65 30       	cpi	r22, 0x05	; 5
     df6:	09 f4       	brne	.+2      	; 0xdfa <_ZN8Robotarm8MoveItemEh+0x22>
     df8:	3d c0       	rjmp	.+122    	; 0xe74 <_ZN8Robotarm8MoveItemEh+0x9c>
     dfa:	47 c0       	rjmp	.+142    	; 0xe8a <_ZN8Robotarm8MoveItemEh+0xb2>
	{
		case 0U:
		grabBlock();
     dfc:	c3 de       	rcall	.-634    	; 0xb84 <_ZN8Robotarm9grabBlockEv>
		vTaskDelay( 500 / portTICK_RATE_MS ); // This might not be needed!!! it can be added in Robotarm!!!! we will seeee later
     dfe:	84 ef       	ldi	r24, 0xF4	; 244
     e00:	91 e0       	ldi	r25, 0x01	; 1
     e02:	0e 94 6a 11 	call	0x22d4	; 0x22d4 <vTaskDelay>
		moveBlockToZoneOne();
     e06:	ce 01       	movw	r24, r28
     e08:	7b df       	rcall	.-266    	; 0xd00 <_ZN8Robotarm18moveBlockToZoneOneEv>
		vTaskDelay( 500 / portTICK_RATE_MS );
     e0a:	84 ef       	ldi	r24, 0xF4	; 244
     e0c:	91 e0       	ldi	r25, 0x01	; 1
     e0e:	0e 94 6a 11 	call	0x22d4	; 0x22d4 <vTaskDelay>
		break;
		
		case 1U:
		grabBlock();
     e12:	3b c0       	rjmp	.+118    	; 0xe8a <_ZN8Robotarm8MoveItemEh+0xb2>
     e14:	b7 de       	rcall	.-658    	; 0xb84 <_ZN8Robotarm9grabBlockEv>
		vTaskDelay( 500 / portTICK_RATE_MS );
     e16:	84 ef       	ldi	r24, 0xF4	; 244
     e18:	91 e0       	ldi	r25, 0x01	; 1
     e1a:	0e 94 6a 11 	call	0x22d4	; 0x22d4 <vTaskDelay>
		moveBlockToZoneTwo();
     e1e:	ce 01       	movw	r24, r28
     e20:	81 df       	rcall	.-254    	; 0xd24 <_ZN8Robotarm18moveBlockToZoneTwoEv>
		vTaskDelay( 500 / portTICK_RATE_MS );
     e22:	84 ef       	ldi	r24, 0xF4	; 244
     e24:	91 e0       	ldi	r25, 0x01	; 1
     e26:	0e 94 6a 11 	call	0x22d4	; 0x22d4 <vTaskDelay>
		break;
		
		case 2U:
		grabBlock();
     e2a:	2f c0       	rjmp	.+94     	; 0xe8a <_ZN8Robotarm8MoveItemEh+0xb2>
     e2c:	ab de       	rcall	.-682    	; 0xb84 <_ZN8Robotarm9grabBlockEv>
		vTaskDelay( 500 / portTICK_RATE_MS );
     e2e:	84 ef       	ldi	r24, 0xF4	; 244
     e30:	91 e0       	ldi	r25, 0x01	; 1
     e32:	0e 94 6a 11 	call	0x22d4	; 0x22d4 <vTaskDelay>
		moveBlockToZoneThree();
     e36:	ce 01       	movw	r24, r28
		vTaskDelay( 500 / portTICK_RATE_MS );
     e38:	87 df       	rcall	.-242    	; 0xd48 <_ZN8Robotarm20moveBlockToZoneThreeEv>
     e3a:	84 ef       	ldi	r24, 0xF4	; 244
     e3c:	91 e0       	ldi	r25, 0x01	; 1
     e3e:	0e 94 6a 11 	call	0x22d4	; 0x22d4 <vTaskDelay>
		break;
		
		case 3U:
		grabBlock();
     e42:	23 c0       	rjmp	.+70     	; 0xe8a <_ZN8Robotarm8MoveItemEh+0xb2>
		vTaskDelay( 500 / portTICK_RATE_MS );
     e44:	9f de       	rcall	.-706    	; 0xb84 <_ZN8Robotarm9grabBlockEv>
     e46:	84 ef       	ldi	r24, 0xF4	; 244
     e48:	91 e0       	ldi	r25, 0x01	; 1
     e4a:	0e 94 6a 11 	call	0x22d4	; 0x22d4 <vTaskDelay>
		moveBlockToZoneFour();
     e4e:	ce 01       	movw	r24, r28
		vTaskDelay( 500 / portTICK_RATE_MS );
     e50:	8d df       	rcall	.-230    	; 0xd6c <_ZN8Robotarm19moveBlockToZoneFourEv>
     e52:	84 ef       	ldi	r24, 0xF4	; 244
     e54:	91 e0       	ldi	r25, 0x01	; 1
		break;
     e56:	0e 94 6a 11 	call	0x22d4	; 0x22d4 <vTaskDelay>
		
		case 4U:
		grabBlock();
     e5a:	17 c0       	rjmp	.+46     	; 0xe8a <_ZN8Robotarm8MoveItemEh+0xb2>
		vTaskDelay( 500 / portTICK_RATE_MS );
     e5c:	93 de       	rcall	.-730    	; 0xb84 <_ZN8Robotarm9grabBlockEv>
     e5e:	84 ef       	ldi	r24, 0xF4	; 244
     e60:	91 e0       	ldi	r25, 0x01	; 1
		moveBlockToZoneFive();
     e62:	0e 94 6a 11 	call	0x22d4	; 0x22d4 <vTaskDelay>
     e66:	ce 01       	movw	r24, r28
		vTaskDelay( 500 / portTICK_RATE_MS );
     e68:	93 df       	rcall	.-218    	; 0xd90 <_ZN8Robotarm19moveBlockToZoneFiveEv>
     e6a:	84 ef       	ldi	r24, 0xF4	; 244
     e6c:	91 e0       	ldi	r25, 0x01	; 1
		break;
     e6e:	0e 94 6a 11 	call	0x22d4	; 0x22d4 <vTaskDelay>
		
		case 5U:
		grabBlock();
     e72:	0b c0       	rjmp	.+22     	; 0xe8a <_ZN8Robotarm8MoveItemEh+0xb2>
		vTaskDelay( 500 / portTICK_RATE_MS );
     e74:	87 de       	rcall	.-754    	; 0xb84 <_ZN8Robotarm9grabBlockEv>
     e76:	84 ef       	ldi	r24, 0xF4	; 244
     e78:	91 e0       	ldi	r25, 0x01	; 1
     e7a:	0e 94 6a 11 	call	0x22d4	; 0x22d4 <vTaskDelay>
		moveBlockToZoneSix();
     e7e:	ce 01       	movw	r24, r28
     e80:	99 df       	rcall	.-206    	; 0xdb4 <_ZN8Robotarm18moveBlockToZoneSixEv>
		vTaskDelay( 500 / portTICK_RATE_MS );
     e82:	84 ef       	ldi	r24, 0xF4	; 244
     e84:	91 e0       	ldi	r25, 0x01	; 1
     e86:	0e 94 6a 11 	call	0x22d4	; 0x22d4 <vTaskDelay>
		break;
		
		default:
		break;
	}
}
     e8a:	df 91       	pop	r29
     e8c:	cf 91       	pop	r28
     e8e:	08 95       	ret

00000e90 <_ZN5Motor10SetDegreesEh>:
	*	 can be used to turn motor at a specific speed set by \ref delay. C
	*	 Note that this function needs to run multiple times to work as intended.
	*    @param uint8_t	degrees to turn
	*    @return void Nothing
	*/
	virtual void SetDegrees( uint8_t degrees )
     e90:	cf 92       	push	r12
     e92:	df 92       	push	r13
     e94:	ef 92       	push	r14
     e96:	ff 92       	push	r15
     e98:	cf 93       	push	r28
     e9a:	df 93       	push	r29
	{
		if ( maxDegrees_ >= degrees )
     e9c:	fc 01       	movw	r30, r24
     e9e:	26 89       	ldd	r18, Z+22	; 0x16
     ea0:	26 17       	cp	r18, r22
     ea2:	c0 f0       	brcs	.+48     	; 0xed4 <_ZN5Motor10SetDegreesEh+0x44>
     ea4:	ec 01       	movw	r28, r24
		{
			percent_ = percentPrDeg * degrees + startpercent_;
     ea6:	c6 80       	ldd	r12, Z+6	; 0x06
     ea8:	d7 80       	ldd	r13, Z+7	; 0x07
     eaa:	e0 84       	ldd	r14, Z+8	; 0x08
     eac:	f1 84       	ldd	r15, Z+9	; 0x09
     eae:	70 e0       	ldi	r23, 0x00	; 0
     eb0:	80 e0       	ldi	r24, 0x00	; 0
     eb2:	90 e0       	ldi	r25, 0x00	; 0
     eb4:	0e 94 d3 15 	call	0x2ba6	; 0x2ba6 <__floatsisf>
     eb8:	a7 01       	movw	r20, r14
     eba:	96 01       	movw	r18, r12
     ebc:	0e 94 87 16 	call	0x2d0e	; 0x2d0e <__mulsf3>
     ec0:	2a 89       	ldd	r18, Y+18	; 0x12
     ec2:	3b 89       	ldd	r19, Y+19	; 0x13
     ec4:	4c 89       	ldd	r20, Y+20	; 0x14
     ec6:	5d 89       	ldd	r21, Y+21	; 0x15
     ec8:	0e 94 d5 14 	call	0x29aa	; 0x29aa <__addsf3>
     ecc:	6a 87       	std	Y+10, r22	; 0x0a
     ece:	7b 87       	std	Y+11, r23	; 0x0b
     ed0:	8c 87       	std	Y+12, r24	; 0x0c
     ed2:	9d 87       	std	Y+13, r25	; 0x0d
		}
	}
     ed4:	df 91       	pop	r29
     ed6:	cf 91       	pop	r28
     ed8:	ff 90       	pop	r15
     eda:	ef 90       	pop	r14
     edc:	df 90       	pop	r13
     ede:	cf 90       	pop	r12
     ee0:	08 95       	ret

00000ee2 <_ZN2M1D1Ev>:

class Motor
{
//functions
public:
	virtual ~Motor() {};
     ee2:	28 e3       	ldi	r18, 0x38	; 56
     ee4:	32 e0       	ldi	r19, 0x02	; 2
     ee6:	fc 01       	movw	r30, r24
     ee8:	31 83       	std	Z+1, r19	; 0x01
     eea:	20 83       	st	Z, r18
     eec:	08 95       	ret

00000eee <_ZN2M1D0Ev>:
	SetDegrees( 90 );
	tmr1Ptr_->setDutyCycleComA( percent_ );
	oldPercent_ = percent_;
} 

M1::~M1()
     eee:	cf 93       	push	r28
     ef0:	df 93       	push	r29
     ef2:	ec 01       	movw	r28, r24
{
}
     ef4:	f6 df       	rcall	.-20     	; 0xee2 <_ZN2M1D1Ev>
     ef6:	ce 01       	movw	r24, r28
     ef8:	a4 dd       	rcall	.-1208   	; 0xa42 <_ZdlPv>
     efa:	df 91       	pop	r29
     efc:	cf 91       	pop	r28
     efe:	08 95       	ret

00000f00 <_ZN2M19TurnMotorEv>:

void M1::TurnMotor()
{
     f00:	4f 92       	push	r4
     f02:	5f 92       	push	r5
     f04:	6f 92       	push	r6
     f06:	7f 92       	push	r7
     f08:	8f 92       	push	r8
     f0a:	9f 92       	push	r9
     f0c:	af 92       	push	r10
     f0e:	bf 92       	push	r11
     f10:	cf 92       	push	r12
     f12:	df 92       	push	r13
     f14:	ef 92       	push	r14
     f16:	ff 92       	push	r15
     f18:	cf 93       	push	r28
     f1a:	df 93       	push	r29
     f1c:	ec 01       	movw	r28, r24
	if ( percent_ > oldPercent_ + PERCENT_PR_TICK )
     f1e:	8a 84       	ldd	r8, Y+10	; 0x0a
     f20:	9b 84       	ldd	r9, Y+11	; 0x0b
     f22:	ac 84       	ldd	r10, Y+12	; 0x0c
     f24:	bd 84       	ldd	r11, Y+13	; 0x0d
     f26:	ce 84       	ldd	r12, Y+14	; 0x0e
     f28:	df 84       	ldd	r13, Y+15	; 0x0f
     f2a:	e8 88       	ldd	r14, Y+16	; 0x10
     f2c:	f9 88       	ldd	r15, Y+17	; 0x11
     f2e:	20 e0       	ldi	r18, 0x00	; 0
     f30:	30 e0       	ldi	r19, 0x00	; 0
     f32:	40 e8       	ldi	r20, 0x80	; 128
     f34:	5d e3       	ldi	r21, 0x3D	; 61
     f36:	c7 01       	movw	r24, r14
     f38:	b6 01       	movw	r22, r12
     f3a:	0e 94 d5 14 	call	0x29aa	; 0x29aa <__addsf3>
     f3e:	2b 01       	movw	r4, r22
     f40:	3c 01       	movw	r6, r24
     f42:	9b 01       	movw	r18, r22
     f44:	ac 01       	movw	r20, r24
     f46:	c5 01       	movw	r24, r10
     f48:	b4 01       	movw	r22, r8
     f4a:	0e 94 83 16 	call	0x2d06	; 0x2d06 <__gesf2>
     f4e:	18 16       	cp	r1, r24
     f50:	74 f4       	brge	.+28     	; 0xf6e <_ZN2M19TurnMotorEv+0x6e>
	{
		oldPercent_ += PERCENT_PR_TICK;
     f52:	4e 86       	std	Y+14, r4	; 0x0e
     f54:	5f 86       	std	Y+15, r5	; 0x0f
     f56:	68 8a       	std	Y+16, r6	; 0x10
     f58:	79 8a       	std	Y+17, r7	; 0x11
		tmr1Ptr_->setDutyCycleComA( oldPercent_ );
     f5a:	b3 01       	movw	r22, r6
     f5c:	a2 01       	movw	r20, r4
     f5e:	8a 81       	ldd	r24, Y+2	; 0x02
     f60:	9b 81       	ldd	r25, Y+3	; 0x03
     f62:	b9 d3       	rcall	.+1906   	; 0x16d6 <_ZN6Timer116setDutyCycleComAEf>
		vTaskDelay( delay_ / portTICK_RATE_MS );
     f64:	8f 89       	ldd	r24, Y+23	; 0x17
     f66:	98 8d       	ldd	r25, Y+24	; 0x18
     f68:	0e 94 6a 11 	call	0x22d4	; 0x22d4 <vTaskDelay>
     f6c:	1d c0       	rjmp	.+58     	; 0xfa8 <_ZN2M19TurnMotorEv+0xa8>
	}
	else if ( percent_ < oldPercent_ )
     f6e:	a7 01       	movw	r20, r14
     f70:	96 01       	movw	r18, r12
     f72:	c5 01       	movw	r24, r10
     f74:	b4 01       	movw	r22, r8
     f76:	0e 94 39 15 	call	0x2a72	; 0x2a72 <__cmpsf2>
     f7a:	88 23       	and	r24, r24
     f7c:	ac f4       	brge	.+42     	; 0xfa8 <_ZN2M19TurnMotorEv+0xa8>
	{
		oldPercent_ -= PERCENT_PR_TICK;
     f7e:	20 e0       	ldi	r18, 0x00	; 0
     f80:	30 e0       	ldi	r19, 0x00	; 0
     f82:	40 e8       	ldi	r20, 0x80	; 128
     f84:	5d e3       	ldi	r21, 0x3D	; 61
     f86:	c7 01       	movw	r24, r14
     f88:	b6 01       	movw	r22, r12
     f8a:	0e 94 d4 14 	call	0x29a8	; 0x29a8 <__subsf3>
     f8e:	ab 01       	movw	r20, r22
     f90:	bc 01       	movw	r22, r24
     f92:	4e 87       	std	Y+14, r20	; 0x0e
     f94:	5f 87       	std	Y+15, r21	; 0x0f
     f96:	68 8b       	std	Y+16, r22	; 0x10
     f98:	79 8b       	std	Y+17, r23	; 0x11
		tmr1Ptr_->setDutyCycleComA( oldPercent_ );
     f9a:	8a 81       	ldd	r24, Y+2	; 0x02
     f9c:	9b 81       	ldd	r25, Y+3	; 0x03
     f9e:	9b d3       	rcall	.+1846   	; 0x16d6 <_ZN6Timer116setDutyCycleComAEf>
		vTaskDelay( delay_ / portTICK_RATE_MS );
     fa0:	8f 89       	ldd	r24, Y+23	; 0x17
     fa2:	98 8d       	ldd	r25, Y+24	; 0x18
     fa4:	0e 94 6a 11 	call	0x22d4	; 0x22d4 <vTaskDelay>
	}
}
     fa8:	df 91       	pop	r29
     faa:	cf 91       	pop	r28
     fac:	ff 90       	pop	r15
     fae:	ef 90       	pop	r14
     fb0:	df 90       	pop	r13
     fb2:	cf 90       	pop	r12
     fb4:	bf 90       	pop	r11
     fb6:	af 90       	pop	r10
     fb8:	9f 90       	pop	r9
     fba:	8f 90       	pop	r8
     fbc:	7f 90       	pop	r7
     fbe:	6f 90       	pop	r6
     fc0:	5f 90       	pop	r5
     fc2:	4f 90       	pop	r4
     fc4:	08 95       	ret

00000fc6 <_ZN2M1C1EP6Timer1>:
* Author: jespe
*/

#include "M1.h"

M1::M1( Timer1* tmr )
     fc6:	cf 93       	push	r28
     fc8:	df 93       	push	r29
     fca:	ec 01       	movw	r28, r24
     fcc:	cb 01       	movw	r24, r22
     fce:	24 e4       	ldi	r18, 0x44	; 68
     fd0:	32 e0       	ldi	r19, 0x02	; 2
     fd2:	39 83       	std	Y+1, r19	; 0x01
     fd4:	28 83       	st	Y, r18
{
	/* Store timer pointer */
	tmr1Ptr_ = tmr;
     fd6:	7b 83       	std	Y+3, r23	; 0x03
     fd8:	6a 83       	std	Y+2, r22	; 0x02
	
	/* This value is number of percent to add or subtract pr degree. */
	percentPrDeg = 0.0555555555555556;
     fda:	49 e3       	ldi	r20, 0x39	; 57
     fdc:	5e e8       	ldi	r21, 0x8E	; 142
     fde:	63 e6       	ldi	r22, 0x63	; 99
     fe0:	7d e3       	ldi	r23, 0x3D	; 61
     fe2:	4e 83       	std	Y+6, r20	; 0x06
     fe4:	5f 83       	std	Y+7, r21	; 0x07
     fe6:	68 87       	std	Y+8, r22	; 0x08
     fe8:	79 87       	std	Y+9, r23	; 0x09
	
	/* This value is the lowest duty cycle percentage needed to make motor turn. */
	startpercent_ = 2.5;
     fea:	40 e0       	ldi	r20, 0x00	; 0
     fec:	50 e0       	ldi	r21, 0x00	; 0
     fee:	60 e2       	ldi	r22, 0x20	; 32
     ff0:	70 e4       	ldi	r23, 0x40	; 64
     ff2:	4a 8b       	std	Y+18, r20	; 0x12
     ff4:	5b 8b       	std	Y+19, r21	; 0x13
     ff6:	6c 8b       	std	Y+20, r22	; 0x14
     ff8:	7d 8b       	std	Y+21, r23	; 0x15
	
	/* This value is the delay on motor. A lower value makes motors go faster and higher value makes motors go slower. */
	delay_ = 10;
     ffa:	2a e0       	ldi	r18, 0x0A	; 10
     ffc:	30 e0       	ldi	r19, 0x00	; 0
     ffe:	38 8f       	std	Y+24, r19	; 0x18
    1000:	2f 8b       	std	Y+23, r18	; 0x17
	
	/* This value is the maximum number of degrees the motor can turn */
	maxDegrees_ = 180;
    1002:	24 eb       	ldi	r18, 0xB4	; 180
    1004:	2e 8b       	std	Y+22, r18	; 0x16
	*/
	virtual void SetDegrees( uint8_t degrees )
	{
		if ( maxDegrees_ >= degrees )
		{
			percent_ = percentPrDeg * degrees + startpercent_;
    1006:	40 e0       	ldi	r20, 0x00	; 0
    1008:	50 e0       	ldi	r21, 0x00	; 0
    100a:	60 ef       	ldi	r22, 0xF0	; 240
    100c:	70 e4       	ldi	r23, 0x40	; 64
    100e:	4a 87       	std	Y+10, r20	; 0x0a
    1010:	5b 87       	std	Y+11, r21	; 0x0b
    1012:	6c 87       	std	Y+12, r22	; 0x0c
    1014:	7d 87       	std	Y+13, r23	; 0x0d
	
	/* Set motor to default startup value */
	SetDegrees( 90 );
	tmr1Ptr_->setDutyCycleComA( percent_ );
    1016:	5f d3       	rcall	.+1726   	; 0x16d6 <_ZN6Timer116setDutyCycleComAEf>
	oldPercent_ = percent_;
    1018:	8a 85       	ldd	r24, Y+10	; 0x0a
    101a:	9b 85       	ldd	r25, Y+11	; 0x0b
    101c:	ac 85       	ldd	r26, Y+12	; 0x0c
    101e:	bd 85       	ldd	r27, Y+13	; 0x0d
    1020:	8e 87       	std	Y+14, r24	; 0x0e
    1022:	9f 87       	std	Y+15, r25	; 0x0f
    1024:	a8 8b       	std	Y+16, r26	; 0x10
    1026:	b9 8b       	std	Y+17, r27	; 0x11
} 
    1028:	df 91       	pop	r29
    102a:	cf 91       	pop	r28
    102c:	08 95       	ret

0000102e <_ZN2M2D1Ev>:

class Motor
{
//functions
public:
	virtual ~Motor() {};
    102e:	28 e3       	ldi	r18, 0x38	; 56
    1030:	32 e0       	ldi	r19, 0x02	; 2
    1032:	fc 01       	movw	r30, r24
    1034:	31 83       	std	Z+1, r19	; 0x01
    1036:	20 83       	st	Z, r18
    1038:	08 95       	ret

0000103a <_ZN2M2D0Ev>:
	SetDegrees( 90 );
	tmr1Ptr_->setDutyCycleComB( percent_ );
	oldPercent_ = percent_;
}

M2::~M2()
    103a:	cf 93       	push	r28
    103c:	df 93       	push	r29
    103e:	ec 01       	movw	r28, r24
{
}
    1040:	f6 df       	rcall	.-20     	; 0x102e <_ZN2M2D1Ev>
    1042:	ce 01       	movw	r24, r28
    1044:	fe dc       	rcall	.-1540   	; 0xa42 <_ZdlPv>
    1046:	df 91       	pop	r29
    1048:	cf 91       	pop	r28
    104a:	08 95       	ret

0000104c <_ZN2M29TurnMotorEv>:

void M2::TurnMotor()
{
    104c:	4f 92       	push	r4
    104e:	5f 92       	push	r5
    1050:	6f 92       	push	r6
    1052:	7f 92       	push	r7
    1054:	8f 92       	push	r8
    1056:	9f 92       	push	r9
    1058:	af 92       	push	r10
    105a:	bf 92       	push	r11
    105c:	cf 92       	push	r12
    105e:	df 92       	push	r13
    1060:	ef 92       	push	r14
    1062:	ff 92       	push	r15
    1064:	cf 93       	push	r28
    1066:	df 93       	push	r29
    1068:	ec 01       	movw	r28, r24
	if ( percent_ > oldPercent_ + PERCENT_PR_TICK )
    106a:	8a 84       	ldd	r8, Y+10	; 0x0a
    106c:	9b 84       	ldd	r9, Y+11	; 0x0b
    106e:	ac 84       	ldd	r10, Y+12	; 0x0c
    1070:	bd 84       	ldd	r11, Y+13	; 0x0d
    1072:	ce 84       	ldd	r12, Y+14	; 0x0e
    1074:	df 84       	ldd	r13, Y+15	; 0x0f
    1076:	e8 88       	ldd	r14, Y+16	; 0x10
    1078:	f9 88       	ldd	r15, Y+17	; 0x11
    107a:	20 e0       	ldi	r18, 0x00	; 0
    107c:	30 e0       	ldi	r19, 0x00	; 0
    107e:	40 e8       	ldi	r20, 0x80	; 128
    1080:	5d e3       	ldi	r21, 0x3D	; 61
    1082:	c7 01       	movw	r24, r14
    1084:	b6 01       	movw	r22, r12
    1086:	0e 94 d5 14 	call	0x29aa	; 0x29aa <__addsf3>
    108a:	2b 01       	movw	r4, r22
    108c:	3c 01       	movw	r6, r24
    108e:	9b 01       	movw	r18, r22
    1090:	ac 01       	movw	r20, r24
    1092:	c5 01       	movw	r24, r10
    1094:	b4 01       	movw	r22, r8
    1096:	0e 94 83 16 	call	0x2d06	; 0x2d06 <__gesf2>
    109a:	18 16       	cp	r1, r24
    109c:	74 f4       	brge	.+28     	; 0x10ba <_ZN2M29TurnMotorEv+0x6e>
	{
		oldPercent_ += PERCENT_PR_TICK;
    109e:	4e 86       	std	Y+14, r4	; 0x0e
    10a0:	5f 86       	std	Y+15, r5	; 0x0f
    10a2:	68 8a       	std	Y+16, r6	; 0x10
    10a4:	79 8a       	std	Y+17, r7	; 0x11
		tmr1Ptr_->setDutyCycleComB( oldPercent_ );
    10a6:	b3 01       	movw	r22, r6
    10a8:	a2 01       	movw	r20, r4
    10aa:	8a 81       	ldd	r24, Y+2	; 0x02
    10ac:	9b 81       	ldd	r25, Y+3	; 0x03
    10ae:	3e d3       	rcall	.+1660   	; 0x172c <_ZN6Timer116setDutyCycleComBEf>
		vTaskDelay( delay_ / portTICK_RATE_MS );
    10b0:	8f 89       	ldd	r24, Y+23	; 0x17
    10b2:	98 8d       	ldd	r25, Y+24	; 0x18
    10b4:	0e 94 6a 11 	call	0x22d4	; 0x22d4 <vTaskDelay>
    10b8:	1d c0       	rjmp	.+58     	; 0x10f4 <_ZN2M29TurnMotorEv+0xa8>
	}
	else if ( percent_ < oldPercent_ )
    10ba:	a7 01       	movw	r20, r14
    10bc:	96 01       	movw	r18, r12
    10be:	c5 01       	movw	r24, r10
    10c0:	b4 01       	movw	r22, r8
    10c2:	0e 94 39 15 	call	0x2a72	; 0x2a72 <__cmpsf2>
    10c6:	88 23       	and	r24, r24
    10c8:	ac f4       	brge	.+42     	; 0x10f4 <_ZN2M29TurnMotorEv+0xa8>
	{
		oldPercent_ -= PERCENT_PR_TICK;
    10ca:	20 e0       	ldi	r18, 0x00	; 0
    10cc:	30 e0       	ldi	r19, 0x00	; 0
    10ce:	40 e8       	ldi	r20, 0x80	; 128
    10d0:	5d e3       	ldi	r21, 0x3D	; 61
    10d2:	c7 01       	movw	r24, r14
    10d4:	b6 01       	movw	r22, r12
    10d6:	0e 94 d4 14 	call	0x29a8	; 0x29a8 <__subsf3>
    10da:	ab 01       	movw	r20, r22
    10dc:	bc 01       	movw	r22, r24
    10de:	4e 87       	std	Y+14, r20	; 0x0e
    10e0:	5f 87       	std	Y+15, r21	; 0x0f
    10e2:	68 8b       	std	Y+16, r22	; 0x10
    10e4:	79 8b       	std	Y+17, r23	; 0x11
		tmr1Ptr_->setDutyCycleComB( oldPercent_ );
    10e6:	8a 81       	ldd	r24, Y+2	; 0x02
    10e8:	9b 81       	ldd	r25, Y+3	; 0x03
    10ea:	20 d3       	rcall	.+1600   	; 0x172c <_ZN6Timer116setDutyCycleComBEf>
		vTaskDelay( delay_ / portTICK_RATE_MS );
    10ec:	8f 89       	ldd	r24, Y+23	; 0x17
    10ee:	98 8d       	ldd	r25, Y+24	; 0x18
    10f0:	0e 94 6a 11 	call	0x22d4	; 0x22d4 <vTaskDelay>
	}
}
    10f4:	df 91       	pop	r29
    10f6:	cf 91       	pop	r28
    10f8:	ff 90       	pop	r15
    10fa:	ef 90       	pop	r14
    10fc:	df 90       	pop	r13
    10fe:	cf 90       	pop	r12
    1100:	bf 90       	pop	r11
    1102:	af 90       	pop	r10
    1104:	9f 90       	pop	r9
    1106:	8f 90       	pop	r8
    1108:	7f 90       	pop	r7
    110a:	6f 90       	pop	r6
    110c:	5f 90       	pop	r5
    110e:	4f 90       	pop	r4
    1110:	08 95       	ret

00001112 <_ZN2M2C1EP6Timer1>:
* Author: jespe
*/

#include "M2.h"

M2::M2( Timer1* tmr )
    1112:	cf 93       	push	r28
    1114:	df 93       	push	r29
    1116:	ec 01       	movw	r28, r24
    1118:	cb 01       	movw	r24, r22
    111a:	20 e5       	ldi	r18, 0x50	; 80
    111c:	32 e0       	ldi	r19, 0x02	; 2
    111e:	39 83       	std	Y+1, r19	; 0x01
    1120:	28 83       	st	Y, r18
{
	/* Store timer pointer */
	tmr1Ptr_ = tmr;
    1122:	7b 83       	std	Y+3, r23	; 0x03
    1124:	6a 83       	std	Y+2, r22	; 0x02
	
	/* This value is number of percent to add or subtract pr degree. */
	percentPrDeg = 0.06;
    1126:	4f e8       	ldi	r20, 0x8F	; 143
    1128:	52 ec       	ldi	r21, 0xC2	; 194
    112a:	65 e7       	ldi	r22, 0x75	; 117
    112c:	7d e3       	ldi	r23, 0x3D	; 61
    112e:	4e 83       	std	Y+6, r20	; 0x06
    1130:	5f 83       	std	Y+7, r21	; 0x07
    1132:	68 87       	std	Y+8, r22	; 0x08
    1134:	79 87       	std	Y+9, r23	; 0x09

	/* This value is the lowest duty cycle percentage needed to make motor turn. */
	startpercent_ = 3;
    1136:	40 e0       	ldi	r20, 0x00	; 0
    1138:	50 e0       	ldi	r21, 0x00	; 0
    113a:	60 e4       	ldi	r22, 0x40	; 64
    113c:	70 e4       	ldi	r23, 0x40	; 64
    113e:	4a 8b       	std	Y+18, r20	; 0x12
    1140:	5b 8b       	std	Y+19, r21	; 0x13
    1142:	6c 8b       	std	Y+20, r22	; 0x14
    1144:	7d 8b       	std	Y+21, r23	; 0x15

	/* This value is the delay on motor. A lower value makes motors go faster and higher value makes motors go slower. Value is in MS */
	delay_ = 10;
    1146:	2a e0       	ldi	r18, 0x0A	; 10
    1148:	30 e0       	ldi	r19, 0x00	; 0
    114a:	38 8f       	std	Y+24, r19	; 0x18
    114c:	2f 8b       	std	Y+23, r18	; 0x17

	/* This value is the maximum number of degrees the motor can turn */
	maxDegrees_ = 150;
    114e:	26 e9       	ldi	r18, 0x96	; 150
    1150:	2e 8b       	std	Y+22, r18	; 0x16
	*/
	virtual void SetDegrees( uint8_t degrees )
	{
		if ( maxDegrees_ >= degrees )
		{
			percent_ = percentPrDeg * degrees + startpercent_;
    1152:	46 e6       	ldi	r20, 0x66	; 102
    1154:	56 e6       	ldi	r21, 0x66	; 102
    1156:	66 e0       	ldi	r22, 0x06	; 6
    1158:	71 e4       	ldi	r23, 0x41	; 65
    115a:	4a 87       	std	Y+10, r20	; 0x0a
    115c:	5b 87       	std	Y+11, r21	; 0x0b
    115e:	6c 87       	std	Y+12, r22	; 0x0c
    1160:	7d 87       	std	Y+13, r23	; 0x0d

	/* Set motor to default startup value */
	SetDegrees( 90 );
	tmr1Ptr_->setDutyCycleComB( percent_ );
    1162:	e4 d2       	rcall	.+1480   	; 0x172c <_ZN6Timer116setDutyCycleComBEf>
	oldPercent_ = percent_;
    1164:	8a 85       	ldd	r24, Y+10	; 0x0a
    1166:	9b 85       	ldd	r25, Y+11	; 0x0b
    1168:	ac 85       	ldd	r26, Y+12	; 0x0c
    116a:	bd 85       	ldd	r27, Y+13	; 0x0d
    116c:	8e 87       	std	Y+14, r24	; 0x0e
    116e:	9f 87       	std	Y+15, r25	; 0x0f
    1170:	a8 8b       	std	Y+16, r26	; 0x10
    1172:	b9 8b       	std	Y+17, r27	; 0x11
}
    1174:	df 91       	pop	r29
    1176:	cf 91       	pop	r28
    1178:	08 95       	ret

0000117a <_ZN2M3D1Ev>:

class Motor
{
//functions
public:
	virtual ~Motor() {};
    117a:	28 e3       	ldi	r18, 0x38	; 56
    117c:	32 e0       	ldi	r19, 0x02	; 2
    117e:	fc 01       	movw	r30, r24
    1180:	31 83       	std	Z+1, r19	; 0x01
    1182:	20 83       	st	Z, r18
    1184:	08 95       	ret

00001186 <_ZN2M3D0Ev>:
	SetDegrees( 90 );
	tmr1Ptr_->setDutyCycleComC( percent_ );
	oldPercent_ = percent_;	
}

M3::~M3()
    1186:	cf 93       	push	r28
    1188:	df 93       	push	r29
    118a:	ec 01       	movw	r28, r24
{
}
    118c:	f6 df       	rcall	.-20     	; 0x117a <_ZN2M3D1Ev>
    118e:	ce 01       	movw	r24, r28
    1190:	58 dc       	rcall	.-1872   	; 0xa42 <_ZdlPv>
    1192:	df 91       	pop	r29
    1194:	cf 91       	pop	r28
    1196:	08 95       	ret

00001198 <_ZN2M39TurnMotorEv>:

void M3::TurnMotor()
{
    1198:	4f 92       	push	r4
    119a:	5f 92       	push	r5
    119c:	6f 92       	push	r6
    119e:	7f 92       	push	r7
    11a0:	8f 92       	push	r8
    11a2:	9f 92       	push	r9
    11a4:	af 92       	push	r10
    11a6:	bf 92       	push	r11
    11a8:	cf 92       	push	r12
    11aa:	df 92       	push	r13
    11ac:	ef 92       	push	r14
    11ae:	ff 92       	push	r15
    11b0:	cf 93       	push	r28
    11b2:	df 93       	push	r29
    11b4:	ec 01       	movw	r28, r24
	if ( percent_ > oldPercent_ + PERCENT_PR_TICK )
    11b6:	8a 84       	ldd	r8, Y+10	; 0x0a
    11b8:	9b 84       	ldd	r9, Y+11	; 0x0b
    11ba:	ac 84       	ldd	r10, Y+12	; 0x0c
    11bc:	bd 84       	ldd	r11, Y+13	; 0x0d
    11be:	ce 84       	ldd	r12, Y+14	; 0x0e
    11c0:	df 84       	ldd	r13, Y+15	; 0x0f
    11c2:	e8 88       	ldd	r14, Y+16	; 0x10
    11c4:	f9 88       	ldd	r15, Y+17	; 0x11
    11c6:	20 e0       	ldi	r18, 0x00	; 0
    11c8:	30 e0       	ldi	r19, 0x00	; 0
    11ca:	40 e8       	ldi	r20, 0x80	; 128
    11cc:	5d e3       	ldi	r21, 0x3D	; 61
    11ce:	c7 01       	movw	r24, r14
    11d0:	b6 01       	movw	r22, r12
    11d2:	0e 94 d5 14 	call	0x29aa	; 0x29aa <__addsf3>
    11d6:	2b 01       	movw	r4, r22
    11d8:	3c 01       	movw	r6, r24
    11da:	9b 01       	movw	r18, r22
    11dc:	ac 01       	movw	r20, r24
    11de:	c5 01       	movw	r24, r10
    11e0:	b4 01       	movw	r22, r8
    11e2:	0e 94 83 16 	call	0x2d06	; 0x2d06 <__gesf2>
    11e6:	18 16       	cp	r1, r24
    11e8:	74 f4       	brge	.+28     	; 0x1206 <_ZN2M39TurnMotorEv+0x6e>
	{
		oldPercent_ += PERCENT_PR_TICK;
    11ea:	4e 86       	std	Y+14, r4	; 0x0e
    11ec:	5f 86       	std	Y+15, r5	; 0x0f
    11ee:	68 8a       	std	Y+16, r6	; 0x10
    11f0:	79 8a       	std	Y+17, r7	; 0x11
		tmr1Ptr_->setDutyCycleComC( oldPercent_ );
    11f2:	b3 01       	movw	r22, r6
    11f4:	a2 01       	movw	r20, r4
    11f6:	8a 81       	ldd	r24, Y+2	; 0x02
    11f8:	9b 81       	ldd	r25, Y+3	; 0x03
    11fa:	c3 d2       	rcall	.+1414   	; 0x1782 <_ZN6Timer116setDutyCycleComCEf>
		vTaskDelay( delay_ / portTICK_RATE_MS );
    11fc:	8f 89       	ldd	r24, Y+23	; 0x17
    11fe:	98 8d       	ldd	r25, Y+24	; 0x18
    1200:	0e 94 6a 11 	call	0x22d4	; 0x22d4 <vTaskDelay>
    1204:	1d c0       	rjmp	.+58     	; 0x1240 <_ZN2M39TurnMotorEv+0xa8>
	}
	else if ( percent_ < oldPercent_ )
    1206:	a7 01       	movw	r20, r14
    1208:	96 01       	movw	r18, r12
    120a:	c5 01       	movw	r24, r10
    120c:	b4 01       	movw	r22, r8
    120e:	0e 94 39 15 	call	0x2a72	; 0x2a72 <__cmpsf2>
    1212:	88 23       	and	r24, r24
    1214:	ac f4       	brge	.+42     	; 0x1240 <_ZN2M39TurnMotorEv+0xa8>
	{
		oldPercent_ -= PERCENT_PR_TICK;
    1216:	20 e0       	ldi	r18, 0x00	; 0
    1218:	30 e0       	ldi	r19, 0x00	; 0
    121a:	40 e8       	ldi	r20, 0x80	; 128
    121c:	5d e3       	ldi	r21, 0x3D	; 61
    121e:	c7 01       	movw	r24, r14
    1220:	b6 01       	movw	r22, r12
    1222:	0e 94 d4 14 	call	0x29a8	; 0x29a8 <__subsf3>
    1226:	ab 01       	movw	r20, r22
    1228:	bc 01       	movw	r22, r24
    122a:	4e 87       	std	Y+14, r20	; 0x0e
    122c:	5f 87       	std	Y+15, r21	; 0x0f
    122e:	68 8b       	std	Y+16, r22	; 0x10
    1230:	79 8b       	std	Y+17, r23	; 0x11
		tmr1Ptr_->setDutyCycleComC( oldPercent_ );
    1232:	8a 81       	ldd	r24, Y+2	; 0x02
    1234:	9b 81       	ldd	r25, Y+3	; 0x03
    1236:	a5 d2       	rcall	.+1354   	; 0x1782 <_ZN6Timer116setDutyCycleComCEf>
		vTaskDelay( delay_ / portTICK_RATE_MS );
    1238:	8f 89       	ldd	r24, Y+23	; 0x17
    123a:	98 8d       	ldd	r25, Y+24	; 0x18
    123c:	0e 94 6a 11 	call	0x22d4	; 0x22d4 <vTaskDelay>
	}
}
    1240:	df 91       	pop	r29
    1242:	cf 91       	pop	r28
    1244:	ff 90       	pop	r15
    1246:	ef 90       	pop	r14
    1248:	df 90       	pop	r13
    124a:	cf 90       	pop	r12
    124c:	bf 90       	pop	r11
    124e:	af 90       	pop	r10
    1250:	9f 90       	pop	r9
    1252:	8f 90       	pop	r8
    1254:	7f 90       	pop	r7
    1256:	6f 90       	pop	r6
    1258:	5f 90       	pop	r5
    125a:	4f 90       	pop	r4
    125c:	08 95       	ret

0000125e <_ZN2M3C1EP6Timer1>:
*/

#include "M3.h"


M3::M3( Timer1* tmr )
    125e:	cf 93       	push	r28
    1260:	df 93       	push	r29
    1262:	ec 01       	movw	r28, r24
    1264:	cb 01       	movw	r24, r22
    1266:	2c e5       	ldi	r18, 0x5C	; 92
    1268:	32 e0       	ldi	r19, 0x02	; 2
    126a:	39 83       	std	Y+1, r19	; 0x01
    126c:	28 83       	st	Y, r18
{
	/* Store timer pointer */
	tmr1Ptr_ = tmr;
    126e:	7b 83       	std	Y+3, r23	; 0x03
    1270:	6a 83       	std	Y+2, r22	; 0x02
		
	/* This value is number of percent to add or subtract pr degree. */
	percentPrDeg = 0.0555555555555556;
    1272:	49 e3       	ldi	r20, 0x39	; 57
    1274:	5e e8       	ldi	r21, 0x8E	; 142
    1276:	63 e6       	ldi	r22, 0x63	; 99
    1278:	7d e3       	ldi	r23, 0x3D	; 61
    127a:	4e 83       	std	Y+6, r20	; 0x06
    127c:	5f 83       	std	Y+7, r21	; 0x07
    127e:	68 87       	std	Y+8, r22	; 0x08
    1280:	79 87       	std	Y+9, r23	; 0x09
	
	/* This value is the lowest duty cycle percentage needed to make motor turn. */
	startpercent_ = 2.5;
    1282:	40 e0       	ldi	r20, 0x00	; 0
    1284:	50 e0       	ldi	r21, 0x00	; 0
    1286:	60 e2       	ldi	r22, 0x20	; 32
    1288:	70 e4       	ldi	r23, 0x40	; 64
    128a:	4a 8b       	std	Y+18, r20	; 0x12
    128c:	5b 8b       	std	Y+19, r21	; 0x13
    128e:	6c 8b       	std	Y+20, r22	; 0x14
    1290:	7d 8b       	std	Y+21, r23	; 0x15

	/* This value is the delay on motor. A lower value makes motors go faster and higher value makes motors go slower. Value is in MS */
	delay_ = 10;
    1292:	2a e0       	ldi	r18, 0x0A	; 10
    1294:	30 e0       	ldi	r19, 0x00	; 0
    1296:	38 8f       	std	Y+24, r19	; 0x18
    1298:	2f 8b       	std	Y+23, r18	; 0x17
	
	/* This value is the maximum number of degrees the motor can turn */
	maxDegrees_ = 180;
    129a:	24 eb       	ldi	r18, 0xB4	; 180
    129c:	2e 8b       	std	Y+22, r18	; 0x16
	*/
	virtual void SetDegrees( uint8_t degrees )
	{
		if ( maxDegrees_ >= degrees )
		{
			percent_ = percentPrDeg * degrees + startpercent_;
    129e:	40 e0       	ldi	r20, 0x00	; 0
    12a0:	50 e0       	ldi	r21, 0x00	; 0
    12a2:	60 ef       	ldi	r22, 0xF0	; 240
    12a4:	70 e4       	ldi	r23, 0x40	; 64
    12a6:	4a 87       	std	Y+10, r20	; 0x0a
    12a8:	5b 87       	std	Y+11, r21	; 0x0b
    12aa:	6c 87       	std	Y+12, r22	; 0x0c
    12ac:	7d 87       	std	Y+13, r23	; 0x0d
	
	/* Set motor to default startup value */
	SetDegrees( 90 );
	tmr1Ptr_->setDutyCycleComC( percent_ );
    12ae:	69 d2       	rcall	.+1234   	; 0x1782 <_ZN6Timer116setDutyCycleComCEf>
	oldPercent_ = percent_;	
    12b0:	8a 85       	ldd	r24, Y+10	; 0x0a
    12b2:	9b 85       	ldd	r25, Y+11	; 0x0b
    12b4:	ac 85       	ldd	r26, Y+12	; 0x0c
    12b6:	bd 85       	ldd	r27, Y+13	; 0x0d
    12b8:	8e 87       	std	Y+14, r24	; 0x0e
    12ba:	9f 87       	std	Y+15, r25	; 0x0f
    12bc:	a8 8b       	std	Y+16, r26	; 0x10
    12be:	b9 8b       	std	Y+17, r27	; 0x11
}
    12c0:	df 91       	pop	r29
    12c2:	cf 91       	pop	r28
    12c4:	08 95       	ret

000012c6 <_ZN2M4D1Ev>:

class Motor
{
//functions
public:
	virtual ~Motor() {};
    12c6:	28 e3       	ldi	r18, 0x38	; 56
    12c8:	32 e0       	ldi	r19, 0x02	; 2
    12ca:	fc 01       	movw	r30, r24
    12cc:	31 83       	std	Z+1, r19	; 0x01
    12ce:	20 83       	st	Z, r18
    12d0:	08 95       	ret

000012d2 <_ZN2M4D0Ev>:
	SetDegrees( 90 );
	tmr3Ptr_->setDutyCycleComA( percent_ );
	oldPercent_ = percent_;
}

M4::~M4()
    12d2:	cf 93       	push	r28
    12d4:	df 93       	push	r29
    12d6:	ec 01       	movw	r28, r24
{
} 
    12d8:	f6 df       	rcall	.-20     	; 0x12c6 <_ZN2M4D1Ev>
    12da:	ce 01       	movw	r24, r28
    12dc:	b2 db       	rcall	.-2204   	; 0xa42 <_ZdlPv>
    12de:	df 91       	pop	r29
    12e0:	cf 91       	pop	r28
    12e2:	08 95       	ret

000012e4 <_ZN2M49TurnMotorEv>:

void M4::TurnMotor()
{
    12e4:	4f 92       	push	r4
    12e6:	5f 92       	push	r5
    12e8:	6f 92       	push	r6
    12ea:	7f 92       	push	r7
    12ec:	8f 92       	push	r8
    12ee:	9f 92       	push	r9
    12f0:	af 92       	push	r10
    12f2:	bf 92       	push	r11
    12f4:	cf 92       	push	r12
    12f6:	df 92       	push	r13
    12f8:	ef 92       	push	r14
    12fa:	ff 92       	push	r15
    12fc:	cf 93       	push	r28
    12fe:	df 93       	push	r29
    1300:	ec 01       	movw	r28, r24
	if ( percent_ > oldPercent_ + PERCENT_PR_TICK )
    1302:	8a 84       	ldd	r8, Y+10	; 0x0a
    1304:	9b 84       	ldd	r9, Y+11	; 0x0b
    1306:	ac 84       	ldd	r10, Y+12	; 0x0c
    1308:	bd 84       	ldd	r11, Y+13	; 0x0d
    130a:	ce 84       	ldd	r12, Y+14	; 0x0e
    130c:	df 84       	ldd	r13, Y+15	; 0x0f
    130e:	e8 88       	ldd	r14, Y+16	; 0x10
    1310:	f9 88       	ldd	r15, Y+17	; 0x11
    1312:	20 e0       	ldi	r18, 0x00	; 0
    1314:	30 e0       	ldi	r19, 0x00	; 0
    1316:	40 e8       	ldi	r20, 0x80	; 128
    1318:	5d e3       	ldi	r21, 0x3D	; 61
    131a:	c7 01       	movw	r24, r14
    131c:	b6 01       	movw	r22, r12
    131e:	0e 94 d5 14 	call	0x29aa	; 0x29aa <__addsf3>
    1322:	2b 01       	movw	r4, r22
    1324:	3c 01       	movw	r6, r24
    1326:	9b 01       	movw	r18, r22
    1328:	ac 01       	movw	r20, r24
    132a:	c5 01       	movw	r24, r10
    132c:	b4 01       	movw	r22, r8
    132e:	0e 94 83 16 	call	0x2d06	; 0x2d06 <__gesf2>
    1332:	18 16       	cp	r1, r24
    1334:	6c f4       	brge	.+26     	; 0x1350 <_ZN2M49TurnMotorEv+0x6c>
	{
		oldPercent_ += PERCENT_PR_TICK;
    1336:	4e 86       	std	Y+14, r4	; 0x0e
    1338:	5f 86       	std	Y+15, r5	; 0x0f
    133a:	68 8a       	std	Y+16, r6	; 0x10
    133c:	79 8a       	std	Y+17, r7	; 0x11
		tmr3Ptr_->setDutyCycleComA( oldPercent_ );
    133e:	b3 01       	movw	r22, r6
    1340:	a2 01       	movw	r20, r4
    1342:	8c 81       	ldd	r24, Y+4	; 0x04
    1344:	9d 81       	ldd	r25, Y+5	; 0x05
    1346:	6e d2       	rcall	.+1244   	; 0x1824 <_ZN6Timer516setDutyCycleComAEf>
		vTaskDelay( 10 / portTICK_RATE_MS );
    1348:	8a e0       	ldi	r24, 0x0A	; 10
    134a:	90 e0       	ldi	r25, 0x00	; 0
    134c:	c3 d7       	rcall	.+3974   	; 0x22d4 <vTaskDelay>
    134e:	1c c0       	rjmp	.+56     	; 0x1388 <_ZN2M49TurnMotorEv+0xa4>
	}
	else if ( percent_ < oldPercent_ )
    1350:	a7 01       	movw	r20, r14
    1352:	96 01       	movw	r18, r12
    1354:	c5 01       	movw	r24, r10
    1356:	b4 01       	movw	r22, r8
    1358:	0e 94 39 15 	call	0x2a72	; 0x2a72 <__cmpsf2>
    135c:	88 23       	and	r24, r24
    135e:	a4 f4       	brge	.+40     	; 0x1388 <_ZN2M49TurnMotorEv+0xa4>
	{
		oldPercent_ -= PERCENT_PR_TICK;
    1360:	20 e0       	ldi	r18, 0x00	; 0
    1362:	30 e0       	ldi	r19, 0x00	; 0
    1364:	40 e8       	ldi	r20, 0x80	; 128
    1366:	5d e3       	ldi	r21, 0x3D	; 61
    1368:	c7 01       	movw	r24, r14
    136a:	b6 01       	movw	r22, r12
    136c:	0e 94 d4 14 	call	0x29a8	; 0x29a8 <__subsf3>
    1370:	ab 01       	movw	r20, r22
    1372:	bc 01       	movw	r22, r24
    1374:	4e 87       	std	Y+14, r20	; 0x0e
    1376:	5f 87       	std	Y+15, r21	; 0x0f
    1378:	68 8b       	std	Y+16, r22	; 0x10
    137a:	79 8b       	std	Y+17, r23	; 0x11
		tmr3Ptr_->setDutyCycleComA( oldPercent_ );
    137c:	8c 81       	ldd	r24, Y+4	; 0x04
    137e:	9d 81       	ldd	r25, Y+5	; 0x05
    1380:	51 d2       	rcall	.+1186   	; 0x1824 <_ZN6Timer516setDutyCycleComAEf>
		vTaskDelay( 10 / portTICK_RATE_MS );
    1382:	8a e0       	ldi	r24, 0x0A	; 10
    1384:	90 e0       	ldi	r25, 0x00	; 0
    1386:	a6 d7       	rcall	.+3916   	; 0x22d4 <vTaskDelay>
    1388:	df 91       	pop	r29
	}
}
    138a:	cf 91       	pop	r28
    138c:	ff 90       	pop	r15
    138e:	ef 90       	pop	r14
    1390:	df 90       	pop	r13
    1392:	cf 90       	pop	r12
    1394:	bf 90       	pop	r11
    1396:	af 90       	pop	r10
    1398:	9f 90       	pop	r9
    139a:	8f 90       	pop	r8
    139c:	7f 90       	pop	r7
    139e:	6f 90       	pop	r6
    13a0:	5f 90       	pop	r5
    13a2:	4f 90       	pop	r4
    13a4:	08 95       	ret

000013a6 <_ZN2M4C1EP6Timer5>:
    13a6:	cf 93       	push	r28
* Author: jespe
*/

#include "M4.h"

M4::M4( Timer5* tmr )
    13a8:	df 93       	push	r29
    13aa:	ec 01       	movw	r28, r24
    13ac:	cb 01       	movw	r24, r22
    13ae:	28 e6       	ldi	r18, 0x68	; 104
    13b0:	32 e0       	ldi	r19, 0x02	; 2
    13b2:	39 83       	std	Y+1, r19	; 0x01
    13b4:	28 83       	st	Y, r18
{
	/* Store timer pointer */
	tmr3Ptr_ = tmr;
    13b6:	7d 83       	std	Y+5, r23	; 0x05
    13b8:	6c 83       	std	Y+4, r22	; 0x04
	
	/* This value is number of percent to add or subtract pr degree. */
	percentPrDeg = 0.0555555555555556;
    13ba:	49 e3       	ldi	r20, 0x39	; 57
    13bc:	5e e8       	ldi	r21, 0x8E	; 142
    13be:	63 e6       	ldi	r22, 0x63	; 99
    13c0:	7d e3       	ldi	r23, 0x3D	; 61
    13c2:	4e 83       	std	Y+6, r20	; 0x06
    13c4:	5f 83       	std	Y+7, r21	; 0x07
    13c6:	68 87       	std	Y+8, r22	; 0x08
    13c8:	79 87       	std	Y+9, r23	; 0x09
	
	/* This value is the lowest duty cycle percentage needed to make motor turn. */
	startpercent_ = 2.5;
    13ca:	40 e0       	ldi	r20, 0x00	; 0
    13cc:	50 e0       	ldi	r21, 0x00	; 0
    13ce:	60 e2       	ldi	r22, 0x20	; 32
    13d0:	70 e4       	ldi	r23, 0x40	; 64
    13d2:	4a 8b       	std	Y+18, r20	; 0x12
    13d4:	5b 8b       	std	Y+19, r21	; 0x13
    13d6:	6c 8b       	std	Y+20, r22	; 0x14
    13d8:	7d 8b       	std	Y+21, r23	; 0x15
		
	/* This value is the delay on motor. A lower value makes motors go faster and higher value makes motors go slower. Value is in MS */
	delay_ = 5;
    13da:	25 e0       	ldi	r18, 0x05	; 5
    13dc:	30 e0       	ldi	r19, 0x00	; 0
    13de:	38 8f       	std	Y+24, r19	; 0x18
    13e0:	2f 8b       	std	Y+23, r18	; 0x17
	
	/* This value is the maximum number of degrees the motor can turn */
	maxDegrees_ = 180;
    13e2:	24 eb       	ldi	r18, 0xB4	; 180
    13e4:	2e 8b       	std	Y+22, r18	; 0x16
	*/
	virtual void SetDegrees( uint8_t degrees )
	{
		if ( maxDegrees_ >= degrees )
		{
			percent_ = percentPrDeg * degrees + startpercent_;
    13e6:	40 e0       	ldi	r20, 0x00	; 0
    13e8:	50 e0       	ldi	r21, 0x00	; 0
    13ea:	60 ef       	ldi	r22, 0xF0	; 240
    13ec:	70 e4       	ldi	r23, 0x40	; 64
    13ee:	4a 87       	std	Y+10, r20	; 0x0a
    13f0:	5b 87       	std	Y+11, r21	; 0x0b
    13f2:	6c 87       	std	Y+12, r22	; 0x0c
    13f4:	7d 87       	std	Y+13, r23	; 0x0d
	
	/* Set motor to default startup value */
	SetDegrees( 90 );
	tmr3Ptr_->setDutyCycleComA( percent_ );
    13f6:	16 d2       	rcall	.+1068   	; 0x1824 <_ZN6Timer516setDutyCycleComAEf>
	oldPercent_ = percent_;
    13f8:	8a 85       	ldd	r24, Y+10	; 0x0a
    13fa:	9b 85       	ldd	r25, Y+11	; 0x0b
    13fc:	ac 85       	ldd	r26, Y+12	; 0x0c
    13fe:	bd 85       	ldd	r27, Y+13	; 0x0d
    1400:	8e 87       	std	Y+14, r24	; 0x0e
    1402:	9f 87       	std	Y+15, r25	; 0x0f
    1404:	a8 8b       	std	Y+16, r26	; 0x10
    1406:	b9 8b       	std	Y+17, r27	; 0x11
}
    1408:	df 91       	pop	r29
    140a:	cf 91       	pop	r28
    140c:	08 95       	ret

0000140e <_ZN2M5D1Ev>:

class Motor
{
//functions
public:
	virtual ~Motor() {};
    140e:	28 e3       	ldi	r18, 0x38	; 56
    1410:	32 e0       	ldi	r19, 0x02	; 2
    1412:	fc 01       	movw	r30, r24
    1414:	31 83       	std	Z+1, r19	; 0x01
    1416:	20 83       	st	Z, r18
    1418:	08 95       	ret

0000141a <_ZN2M5D0Ev>:
	SetDegrees( 0 );
	tmr3Ptr_->setDutyCycleComB( percent_ );
	oldPercent_ = percent_;
}

M5::~M5()
    141a:	cf 93       	push	r28
    141c:	df 93       	push	r29
    141e:	ec 01       	movw	r28, r24
{
}
    1420:	f6 df       	rcall	.-20     	; 0x140e <_ZN2M5D1Ev>
    1422:	ce 01       	movw	r24, r28
    1424:	0e db       	rcall	.-2532   	; 0xa42 <_ZdlPv>
    1426:	df 91       	pop	r29
    1428:	cf 91       	pop	r28
    142a:	08 95       	ret

0000142c <_ZN2M59TurnMotorEv>:

void M5::TurnMotor()
{
    142c:	4f 92       	push	r4
    142e:	5f 92       	push	r5
    1430:	6f 92       	push	r6
    1432:	7f 92       	push	r7
    1434:	8f 92       	push	r8
    1436:	9f 92       	push	r9
    1438:	af 92       	push	r10
    143a:	bf 92       	push	r11
    143c:	cf 92       	push	r12
    143e:	df 92       	push	r13
    1440:	ef 92       	push	r14
    1442:	ff 92       	push	r15
    1444:	cf 93       	push	r28
    1446:	df 93       	push	r29
    1448:	ec 01       	movw	r28, r24
	if ( percent_ > oldPercent_ + PERCENT_PR_TICK )
    144a:	8a 84       	ldd	r8, Y+10	; 0x0a
    144c:	9b 84       	ldd	r9, Y+11	; 0x0b
    144e:	ac 84       	ldd	r10, Y+12	; 0x0c
    1450:	bd 84       	ldd	r11, Y+13	; 0x0d
    1452:	ce 84       	ldd	r12, Y+14	; 0x0e
    1454:	df 84       	ldd	r13, Y+15	; 0x0f
    1456:	e8 88       	ldd	r14, Y+16	; 0x10
    1458:	f9 88       	ldd	r15, Y+17	; 0x11
    145a:	20 e0       	ldi	r18, 0x00	; 0
    145c:	30 e0       	ldi	r19, 0x00	; 0
    145e:	40 e8       	ldi	r20, 0x80	; 128
    1460:	5d e3       	ldi	r21, 0x3D	; 61
    1462:	c7 01       	movw	r24, r14
    1464:	b6 01       	movw	r22, r12
    1466:	0e 94 d5 14 	call	0x29aa	; 0x29aa <__addsf3>
    146a:	2b 01       	movw	r4, r22
    146c:	3c 01       	movw	r6, r24
    146e:	9b 01       	movw	r18, r22
    1470:	ac 01       	movw	r20, r24
    1472:	c5 01       	movw	r24, r10
    1474:	b4 01       	movw	r22, r8
    1476:	0e 94 83 16 	call	0x2d06	; 0x2d06 <__gesf2>
    147a:	18 16       	cp	r1, r24
    147c:	6c f4       	brge	.+26     	; 0x1498 <_ZN2M59TurnMotorEv+0x6c>
	{
		oldPercent_ += PERCENT_PR_TICK;
    147e:	4e 86       	std	Y+14, r4	; 0x0e
    1480:	5f 86       	std	Y+15, r5	; 0x0f
    1482:	68 8a       	std	Y+16, r6	; 0x10
    1484:	79 8a       	std	Y+17, r7	; 0x11
		tmr3Ptr_->setDutyCycleComB( oldPercent_ );
    1486:	b3 01       	movw	r22, r6
    1488:	a2 01       	movw	r20, r4
    148a:	8c 81       	ldd	r24, Y+4	; 0x04
    148c:	9d 81       	ldd	r25, Y+5	; 0x05
    148e:	f5 d1       	rcall	.+1002   	; 0x187a <_ZN6Timer516setDutyCycleComBEf>
		vTaskDelay( delay_ / portTICK_RATE_MS );
    1490:	8f 89       	ldd	r24, Y+23	; 0x17
    1492:	98 8d       	ldd	r25, Y+24	; 0x18
    1494:	1f d7       	rcall	.+3646   	; 0x22d4 <vTaskDelay>
    1496:	1c c0       	rjmp	.+56     	; 0x14d0 <_ZN2M59TurnMotorEv+0xa4>
	}
	else if ( percent_ < oldPercent_ )
    1498:	a7 01       	movw	r20, r14
    149a:	96 01       	movw	r18, r12
    149c:	c5 01       	movw	r24, r10
    149e:	b4 01       	movw	r22, r8
    14a0:	0e 94 39 15 	call	0x2a72	; 0x2a72 <__cmpsf2>
    14a4:	88 23       	and	r24, r24
    14a6:	a4 f4       	brge	.+40     	; 0x14d0 <_ZN2M59TurnMotorEv+0xa4>
	{
		oldPercent_ -= PERCENT_PR_TICK;
    14a8:	20 e0       	ldi	r18, 0x00	; 0
    14aa:	30 e0       	ldi	r19, 0x00	; 0
    14ac:	40 e8       	ldi	r20, 0x80	; 128
    14ae:	5d e3       	ldi	r21, 0x3D	; 61
    14b0:	c7 01       	movw	r24, r14
    14b2:	b6 01       	movw	r22, r12
    14b4:	0e 94 d4 14 	call	0x29a8	; 0x29a8 <__subsf3>
    14b8:	ab 01       	movw	r20, r22
    14ba:	bc 01       	movw	r22, r24
    14bc:	4e 87       	std	Y+14, r20	; 0x0e
    14be:	5f 87       	std	Y+15, r21	; 0x0f
    14c0:	68 8b       	std	Y+16, r22	; 0x10
    14c2:	79 8b       	std	Y+17, r23	; 0x11
		tmr3Ptr_->setDutyCycleComB( oldPercent_ );
    14c4:	8c 81       	ldd	r24, Y+4	; 0x04
    14c6:	9d 81       	ldd	r25, Y+5	; 0x05
    14c8:	d8 d1       	rcall	.+944    	; 0x187a <_ZN6Timer516setDutyCycleComBEf>
		vTaskDelay( delay_ / portTICK_RATE_MS );
    14ca:	8f 89       	ldd	r24, Y+23	; 0x17
    14cc:	98 8d       	ldd	r25, Y+24	; 0x18
    14ce:	02 d7       	rcall	.+3588   	; 0x22d4 <vTaskDelay>
    14d0:	df 91       	pop	r29
	}
}
    14d2:	cf 91       	pop	r28
    14d4:	ff 90       	pop	r15
    14d6:	ef 90       	pop	r14
    14d8:	df 90       	pop	r13
    14da:	cf 90       	pop	r12
    14dc:	bf 90       	pop	r11
    14de:	af 90       	pop	r10
    14e0:	9f 90       	pop	r9
    14e2:	8f 90       	pop	r8
    14e4:	7f 90       	pop	r7
    14e6:	6f 90       	pop	r6
    14e8:	5f 90       	pop	r5
    14ea:	4f 90       	pop	r4
    14ec:	08 95       	ret

000014ee <_ZN2M5C1EP6Timer5>:
    14ee:	cf 93       	push	r28
* Author: jespe
*/

#include "M5.h"

M5::M5( Timer5* tmr )
    14f0:	df 93       	push	r29
    14f2:	ec 01       	movw	r28, r24
    14f4:	cb 01       	movw	r24, r22
    14f6:	24 e7       	ldi	r18, 0x74	; 116
    14f8:	32 e0       	ldi	r19, 0x02	; 2
    14fa:	39 83       	std	Y+1, r19	; 0x01
    14fc:	28 83       	st	Y, r18
{
	/* Store timer pointer */
	tmr3Ptr_ = tmr;
    14fe:	7d 83       	std	Y+5, r23	; 0x05
    1500:	6c 83       	std	Y+4, r22	; 0x04
	
	/* This value is number of percent to add or subtract pr degree. */
	percentPrDeg = 0.0555555555555556;
    1502:	49 e3       	ldi	r20, 0x39	; 57
    1504:	5e e8       	ldi	r21, 0x8E	; 142
    1506:	63 e6       	ldi	r22, 0x63	; 99
    1508:	7d e3       	ldi	r23, 0x3D	; 61
    150a:	4e 83       	std	Y+6, r20	; 0x06
    150c:	5f 83       	std	Y+7, r21	; 0x07
    150e:	68 87       	std	Y+8, r22	; 0x08
    1510:	79 87       	std	Y+9, r23	; 0x09
	
	/* This value is the lowest duty cycle percentage needed to make motor turn. */
	startpercent_ = 2.5;
    1512:	40 e0       	ldi	r20, 0x00	; 0
    1514:	50 e0       	ldi	r21, 0x00	; 0
    1516:	60 e2       	ldi	r22, 0x20	; 32
    1518:	70 e4       	ldi	r23, 0x40	; 64
    151a:	4a 8b       	std	Y+18, r20	; 0x12
    151c:	5b 8b       	std	Y+19, r21	; 0x13
    151e:	6c 8b       	std	Y+20, r22	; 0x14
    1520:	7d 8b       	std	Y+21, r23	; 0x15
	
	/* This value is the delay on motor. A lower value makes motors go faster and higher value makes motors go slower. Value is in MS */
	delay_ = 1;
    1522:	21 e0       	ldi	r18, 0x01	; 1
    1524:	30 e0       	ldi	r19, 0x00	; 0
    1526:	38 8f       	std	Y+24, r19	; 0x18
    1528:	2f 8b       	std	Y+23, r18	; 0x17
	
	/* This value is the maximum number of degrees the motor can turn */
	maxDegrees_ = 180;
    152a:	24 eb       	ldi	r18, 0xB4	; 180
    152c:	2e 8b       	std	Y+22, r18	; 0x16
	*/
	virtual void SetDegrees( uint8_t degrees )
	{
		if ( maxDegrees_ >= degrees )
		{
			percent_ = percentPrDeg * degrees + startpercent_;
    152e:	4a 87       	std	Y+10, r20	; 0x0a
    1530:	5b 87       	std	Y+11, r21	; 0x0b
    1532:	6c 87       	std	Y+12, r22	; 0x0c
    1534:	7d 87       	std	Y+13, r23	; 0x0d
	
	/* Set motor to default startup value */
	SetDegrees( 0 );
	tmr3Ptr_->setDutyCycleComB( percent_ );
    1536:	a1 d1       	rcall	.+834    	; 0x187a <_ZN6Timer516setDutyCycleComBEf>
	oldPercent_ = percent_;
    1538:	8a 85       	ldd	r24, Y+10	; 0x0a
    153a:	9b 85       	ldd	r25, Y+11	; 0x0b
    153c:	ac 85       	ldd	r26, Y+12	; 0x0c
    153e:	bd 85       	ldd	r27, Y+13	; 0x0d
    1540:	8e 87       	std	Y+14, r24	; 0x0e
    1542:	9f 87       	std	Y+15, r25	; 0x0f
    1544:	a8 8b       	std	Y+16, r26	; 0x10
    1546:	b9 8b       	std	Y+17, r27	; 0x11
}
    1548:	df 91       	pop	r29
    154a:	cf 91       	pop	r28
    154c:	08 95       	ret

0000154e <_ZN2M6D1Ev>:

class Motor
{
//functions
public:
	virtual ~Motor() {};
    154e:	28 e3       	ldi	r18, 0x38	; 56
    1550:	32 e0       	ldi	r19, 0x02	; 2
    1552:	fc 01       	movw	r30, r24
    1554:	31 83       	std	Z+1, r19	; 0x01
    1556:	20 83       	st	Z, r18
    1558:	08 95       	ret

0000155a <_ZN2M6D0Ev>:
	SetDegrees( 0 );
	tmr3Ptr_->setDutyCycleComC( percent_ );
	oldPercent_ = percent_;
}

M6::~M6()
    155a:	cf 93       	push	r28
    155c:	df 93       	push	r29
    155e:	ec 01       	movw	r28, r24
{
}
    1560:	f6 df       	rcall	.-20     	; 0x154e <_ZN2M6D1Ev>
    1562:	ce 01       	movw	r24, r28
    1564:	6e da       	rcall	.-2852   	; 0xa42 <_ZdlPv>
    1566:	df 91       	pop	r29
    1568:	cf 91       	pop	r28
    156a:	08 95       	ret

0000156c <_ZN2M69TurnMotorEv>:

void M6::TurnMotor()
{
    156c:	4f 92       	push	r4
    156e:	5f 92       	push	r5
    1570:	6f 92       	push	r6
    1572:	7f 92       	push	r7
    1574:	8f 92       	push	r8
    1576:	9f 92       	push	r9
    1578:	af 92       	push	r10
    157a:	bf 92       	push	r11
    157c:	cf 92       	push	r12
    157e:	df 92       	push	r13
    1580:	ef 92       	push	r14
    1582:	ff 92       	push	r15
    1584:	cf 93       	push	r28
    1586:	df 93       	push	r29
    1588:	ec 01       	movw	r28, r24
	if ( percent_ > oldPercent_ + PERCENT_PR_TICK )
    158a:	8a 84       	ldd	r8, Y+10	; 0x0a
    158c:	9b 84       	ldd	r9, Y+11	; 0x0b
    158e:	ac 84       	ldd	r10, Y+12	; 0x0c
    1590:	bd 84       	ldd	r11, Y+13	; 0x0d
    1592:	ce 84       	ldd	r12, Y+14	; 0x0e
    1594:	df 84       	ldd	r13, Y+15	; 0x0f
    1596:	e8 88       	ldd	r14, Y+16	; 0x10
    1598:	f9 88       	ldd	r15, Y+17	; 0x11
    159a:	20 e0       	ldi	r18, 0x00	; 0
    159c:	30 e0       	ldi	r19, 0x00	; 0
    159e:	40 e8       	ldi	r20, 0x80	; 128
    15a0:	5d e3       	ldi	r21, 0x3D	; 61
    15a2:	c7 01       	movw	r24, r14
    15a4:	b6 01       	movw	r22, r12
    15a6:	0e 94 d5 14 	call	0x29aa	; 0x29aa <__addsf3>
    15aa:	2b 01       	movw	r4, r22
    15ac:	3c 01       	movw	r6, r24
    15ae:	9b 01       	movw	r18, r22
    15b0:	ac 01       	movw	r20, r24
    15b2:	c5 01       	movw	r24, r10
    15b4:	b4 01       	movw	r22, r8
    15b6:	0e 94 83 16 	call	0x2d06	; 0x2d06 <__gesf2>
    15ba:	18 16       	cp	r1, r24
    15bc:	6c f4       	brge	.+26     	; 0x15d8 <_ZN2M69TurnMotorEv+0x6c>
	{
		oldPercent_ += 0.0625;
    15be:	4e 86       	std	Y+14, r4	; 0x0e
    15c0:	5f 86       	std	Y+15, r5	; 0x0f
    15c2:	68 8a       	std	Y+16, r6	; 0x10
    15c4:	79 8a       	std	Y+17, r7	; 0x11
		tmr3Ptr_->setDutyCycleComC( oldPercent_ );
    15c6:	b3 01       	movw	r22, r6
    15c8:	a2 01       	movw	r20, r4
    15ca:	8c 81       	ldd	r24, Y+4	; 0x04
    15cc:	9d 81       	ldd	r25, Y+5	; 0x05
    15ce:	80 d1       	rcall	.+768    	; 0x18d0 <_ZN6Timer516setDutyCycleComCEf>
		vTaskDelay( delay_ / portTICK_RATE_MS );
    15d0:	8f 89       	ldd	r24, Y+23	; 0x17
    15d2:	98 8d       	ldd	r25, Y+24	; 0x18
    15d4:	7f d6       	rcall	.+3326   	; 0x22d4 <vTaskDelay>
    15d6:	1c c0       	rjmp	.+56     	; 0x1610 <_ZN2M69TurnMotorEv+0xa4>
	}
	else if ( percent_ < oldPercent_ )
    15d8:	a7 01       	movw	r20, r14
    15da:	96 01       	movw	r18, r12
    15dc:	c5 01       	movw	r24, r10
    15de:	b4 01       	movw	r22, r8
    15e0:	0e 94 39 15 	call	0x2a72	; 0x2a72 <__cmpsf2>
    15e4:	88 23       	and	r24, r24
    15e6:	a4 f4       	brge	.+40     	; 0x1610 <_ZN2M69TurnMotorEv+0xa4>
	{
		oldPercent_ -= 0.0625;
    15e8:	20 e0       	ldi	r18, 0x00	; 0
    15ea:	30 e0       	ldi	r19, 0x00	; 0
    15ec:	40 e8       	ldi	r20, 0x80	; 128
    15ee:	5d e3       	ldi	r21, 0x3D	; 61
    15f0:	c7 01       	movw	r24, r14
    15f2:	b6 01       	movw	r22, r12
    15f4:	0e 94 d4 14 	call	0x29a8	; 0x29a8 <__subsf3>
    15f8:	ab 01       	movw	r20, r22
    15fa:	bc 01       	movw	r22, r24
    15fc:	4e 87       	std	Y+14, r20	; 0x0e
    15fe:	5f 87       	std	Y+15, r21	; 0x0f
    1600:	68 8b       	std	Y+16, r22	; 0x10
    1602:	79 8b       	std	Y+17, r23	; 0x11
		tmr3Ptr_->setDutyCycleComC( oldPercent_ );
    1604:	8c 81       	ldd	r24, Y+4	; 0x04
    1606:	9d 81       	ldd	r25, Y+5	; 0x05
    1608:	63 d1       	rcall	.+710    	; 0x18d0 <_ZN6Timer516setDutyCycleComCEf>
		vTaskDelay( delay_ / portTICK_RATE_MS );
    160a:	8f 89       	ldd	r24, Y+23	; 0x17
    160c:	98 8d       	ldd	r25, Y+24	; 0x18
    160e:	62 d6       	rcall	.+3268   	; 0x22d4 <vTaskDelay>
    1610:	df 91       	pop	r29
	}
}
    1612:	cf 91       	pop	r28
    1614:	ff 90       	pop	r15
    1616:	ef 90       	pop	r14
    1618:	df 90       	pop	r13
    161a:	cf 90       	pop	r12
    161c:	bf 90       	pop	r11
    161e:	af 90       	pop	r10
    1620:	9f 90       	pop	r9
    1622:	8f 90       	pop	r8
    1624:	7f 90       	pop	r7
    1626:	6f 90       	pop	r6
    1628:	5f 90       	pop	r5
    162a:	4f 90       	pop	r4
    162c:	08 95       	ret

0000162e <_ZN2M6C1EP6Timer5>:
    162e:	cf 93       	push	r28
* Author: jespe
*/

#include "M6.h"

M6::M6( Timer5* tmr )
    1630:	df 93       	push	r29
    1632:	ec 01       	movw	r28, r24
    1634:	cb 01       	movw	r24, r22
    1636:	20 e8       	ldi	r18, 0x80	; 128
    1638:	32 e0       	ldi	r19, 0x02	; 2
    163a:	39 83       	std	Y+1, r19	; 0x01
    163c:	28 83       	st	Y, r18
{
	/* Store timer pointer */
	tmr3Ptr_ = tmr;
    163e:	7d 83       	std	Y+5, r23	; 0x05
    1640:	6c 83       	std	Y+4, r22	; 0x04
	
	/* This value is number of percent to add or subtract pr degree. */
	percentPrDeg = 0.07936507936507;
    1642:	49 e2       	ldi	r20, 0x29	; 41
    1644:	5a e8       	ldi	r21, 0x8A	; 138
    1646:	62 ea       	ldi	r22, 0xA2	; 162
    1648:	7d e3       	ldi	r23, 0x3D	; 61
    164a:	4e 83       	std	Y+6, r20	; 0x06
    164c:	5f 83       	std	Y+7, r21	; 0x07
    164e:	68 87       	std	Y+8, r22	; 0x08
    1650:	79 87       	std	Y+9, r23	; 0x09
	
	/* This value is the lowest duty cycle percentage needed to make motor turn. */
	startpercent_ = 2.5;
    1652:	40 e0       	ldi	r20, 0x00	; 0
    1654:	50 e0       	ldi	r21, 0x00	; 0
    1656:	60 e2       	ldi	r22, 0x20	; 32
    1658:	70 e4       	ldi	r23, 0x40	; 64
    165a:	4a 8b       	std	Y+18, r20	; 0x12
    165c:	5b 8b       	std	Y+19, r21	; 0x13
    165e:	6c 8b       	std	Y+20, r22	; 0x14
    1660:	7d 8b       	std	Y+21, r23	; 0x15
	
	/* This value is the delay on motor. A lower value makes motors go faster and higher value makes motors go slower. Value is in MS */
	delay_ = 1;
    1662:	21 e0       	ldi	r18, 0x01	; 1
    1664:	30 e0       	ldi	r19, 0x00	; 0
    1666:	38 8f       	std	Y+24, r19	; 0x18
    1668:	2f 8b       	std	Y+23, r18	; 0x17
	
	/* This value is the maximum number of degrees the motor can turn */
	maxDegrees_ = 63;
    166a:	2f e3       	ldi	r18, 0x3F	; 63
    166c:	2e 8b       	std	Y+22, r18	; 0x16
	*/
	virtual void SetDegrees( uint8_t degrees )
	{
		if ( maxDegrees_ >= degrees )
		{
			percent_ = percentPrDeg * degrees + startpercent_;
    166e:	4a 87       	std	Y+10, r20	; 0x0a
    1670:	5b 87       	std	Y+11, r21	; 0x0b
    1672:	6c 87       	std	Y+12, r22	; 0x0c
    1674:	7d 87       	std	Y+13, r23	; 0x0d
	
	/* Set motor to default startup value */
	SetDegrees( 0 );
	tmr3Ptr_->setDutyCycleComC( percent_ );
    1676:	2c d1       	rcall	.+600    	; 0x18d0 <_ZN6Timer516setDutyCycleComCEf>
	oldPercent_ = percent_;
    1678:	8a 85       	ldd	r24, Y+10	; 0x0a
    167a:	9b 85       	ldd	r25, Y+11	; 0x0b
    167c:	ac 85       	ldd	r26, Y+12	; 0x0c
    167e:	bd 85       	ldd	r27, Y+13	; 0x0d
    1680:	8e 87       	std	Y+14, r24	; 0x0e
    1682:	9f 87       	std	Y+15, r25	; 0x0f
    1684:	a8 8b       	std	Y+16, r26	; 0x10
    1686:	b9 8b       	std	Y+17, r27	; 0x11
}
    1688:	df 91       	pop	r29
    168a:	cf 91       	pop	r28
    168c:	08 95       	ret

0000168e <_ZN6Timer1C1Ev>:
#include <avr/io.h>

Timer1::Timer1()
{
	// Set all needed ports to outputs
	ROBOTARM_M1_OUT_PORT |= ( 1 << ROBOTARM_M1_OUT_PIN );
    168e:	84 b1       	in	r24, 0x04	; 4
    1690:	80 62       	ori	r24, 0x20	; 32
    1692:	84 b9       	out	0x04, r24	; 4
	ROBOTARM_M2_OUT_PORT |= ( 1 << ROBOTARM_M2_OUT_PIN );
    1694:	84 b1       	in	r24, 0x04	; 4
    1696:	80 64       	ori	r24, 0x40	; 64
    1698:	84 b9       	out	0x04, r24	; 4
	ROBOTARM_M3_OUT_PORT |= ( 1 << ROBOTARM_M3_OUT_PIN );
    169a:	84 b1       	in	r24, 0x04	; 4
    169c:	80 68       	ori	r24, 0x80	; 128
    169e:	84 b9       	out	0x04, r24	; 4
		
	// Set timer to run in PWM, Phase Correct mode with 50 Hz freq. 
	TCCR1A = ( 1 << COM1A1 ) | ( 1 << COM1B1 ) | ( 1 << COM1C1 ) | ( 0 << WGM10 ) | ( 0 << WGM11 );
    16a0:	88 ea       	ldi	r24, 0xA8	; 168
    16a2:	80 93 80 00 	sts	0x0080, r24	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
	TCCR1B = ( 1 << WGM13 ) | ( 0 << CS10 )  | ( 1 << CS12 );
    16a6:	84 e1       	ldi	r24, 0x14	; 20
    16a8:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x700081>
	TCCR1C = 0;
    16ac:	10 92 82 00 	sts	0x0082, r1	; 0x800082 <__TEXT_REGION_LENGTH__+0x700082>
	ICR1 = 622;
    16b0:	8e e6       	ldi	r24, 0x6E	; 110
    16b2:	92 e0       	ldi	r25, 0x02	; 2
    16b4:	90 93 87 00 	sts	0x0087, r25	; 0x800087 <__TEXT_REGION_LENGTH__+0x700087>
    16b8:	80 93 86 00 	sts	0x0086, r24	; 0x800086 <__TEXT_REGION_LENGTH__+0x700086>
	
	OCR1A = 0;
    16bc:	10 92 89 00 	sts	0x0089, r1	; 0x800089 <__TEXT_REGION_LENGTH__+0x700089>
    16c0:	10 92 88 00 	sts	0x0088, r1	; 0x800088 <__TEXT_REGION_LENGTH__+0x700088>
	OCR1B = 0;
    16c4:	10 92 8b 00 	sts	0x008B, r1	; 0x80008b <__TEXT_REGION_LENGTH__+0x70008b>
    16c8:	10 92 8a 00 	sts	0x008A, r1	; 0x80008a <__TEXT_REGION_LENGTH__+0x70008a>
	OCR1C = 0;
    16cc:	10 92 8d 00 	sts	0x008D, r1	; 0x80008d <__TEXT_REGION_LENGTH__+0x70008d>
    16d0:	10 92 8c 00 	sts	0x008C, r1	; 0x80008c <__TEXT_REGION_LENGTH__+0x70008c>
    16d4:	08 95       	ret

000016d6 <_ZN6Timer116setDutyCycleComAEf>:
}

void Timer1::setDutyCycleComA( float dutyCycle )
{
    16d6:	cf 92       	push	r12
    16d8:	df 92       	push	r13
    16da:	ef 92       	push	r14
    16dc:	ff 92       	push	r15
    16de:	6a 01       	movw	r12, r20
    16e0:	7b 01       	movw	r14, r22
	float percent = ICR1/100;
    16e2:	20 91 86 00 	lds	r18, 0x0086	; 0x800086 <__TEXT_REGION_LENGTH__+0x700086>
    16e6:	30 91 87 00 	lds	r19, 0x0087	; 0x800087 <__TEXT_REGION_LENGTH__+0x700087>
    16ea:	36 95       	lsr	r19
    16ec:	27 95       	ror	r18
    16ee:	36 95       	lsr	r19
    16f0:	27 95       	ror	r18
    16f2:	ab e7       	ldi	r26, 0x7B	; 123
    16f4:	b4 e1       	ldi	r27, 0x14	; 20
    16f6:	0e 94 f2 16 	call	0x2de4	; 0x2de4 <__umulhisi3>
    16fa:	96 95       	lsr	r25
    16fc:	87 95       	ror	r24
	OCR1A = (uint8_t)percent*dutyCycle;
    16fe:	bc 01       	movw	r22, r24
    1700:	77 27       	eor	r23, r23
    1702:	07 2e       	mov	r0, r23
    1704:	00 0c       	add	r0, r0
    1706:	88 0b       	sbc	r24, r24
    1708:	99 0b       	sbc	r25, r25
    170a:	0e 94 d3 15 	call	0x2ba6	; 0x2ba6 <__floatsisf>
    170e:	a7 01       	movw	r20, r14
    1710:	96 01       	movw	r18, r12
    1712:	0e 94 87 16 	call	0x2d0e	; 0x2d0e <__mulsf3>
    1716:	0e 94 a5 15 	call	0x2b4a	; 0x2b4a <__fixunssfsi>
    171a:	70 93 89 00 	sts	0x0089, r23	; 0x800089 <__TEXT_REGION_LENGTH__+0x700089>
    171e:	60 93 88 00 	sts	0x0088, r22	; 0x800088 <__TEXT_REGION_LENGTH__+0x700088>
}
    1722:	ff 90       	pop	r15
    1724:	ef 90       	pop	r14
    1726:	df 90       	pop	r13
    1728:	cf 90       	pop	r12
    172a:	08 95       	ret

0000172c <_ZN6Timer116setDutyCycleComBEf>:

void Timer1::setDutyCycleComB( float dutyCycle )
{
    172c:	cf 92       	push	r12
    172e:	df 92       	push	r13
    1730:	ef 92       	push	r14
    1732:	ff 92       	push	r15
    1734:	6a 01       	movw	r12, r20
    1736:	7b 01       	movw	r14, r22
	float percent = ICR1/100;
    1738:	20 91 86 00 	lds	r18, 0x0086	; 0x800086 <__TEXT_REGION_LENGTH__+0x700086>
    173c:	30 91 87 00 	lds	r19, 0x0087	; 0x800087 <__TEXT_REGION_LENGTH__+0x700087>
    1740:	36 95       	lsr	r19
    1742:	27 95       	ror	r18
    1744:	36 95       	lsr	r19
    1746:	27 95       	ror	r18
    1748:	ab e7       	ldi	r26, 0x7B	; 123
    174a:	b4 e1       	ldi	r27, 0x14	; 20
    174c:	0e 94 f2 16 	call	0x2de4	; 0x2de4 <__umulhisi3>
    1750:	96 95       	lsr	r25
    1752:	87 95       	ror	r24
	OCR1B = (uint8_t)percent*dutyCycle;
    1754:	bc 01       	movw	r22, r24
    1756:	77 27       	eor	r23, r23
    1758:	07 2e       	mov	r0, r23
    175a:	00 0c       	add	r0, r0
    175c:	88 0b       	sbc	r24, r24
    175e:	99 0b       	sbc	r25, r25
    1760:	0e 94 d3 15 	call	0x2ba6	; 0x2ba6 <__floatsisf>
    1764:	a7 01       	movw	r20, r14
    1766:	96 01       	movw	r18, r12
    1768:	0e 94 87 16 	call	0x2d0e	; 0x2d0e <__mulsf3>
    176c:	0e 94 a5 15 	call	0x2b4a	; 0x2b4a <__fixunssfsi>
    1770:	70 93 8b 00 	sts	0x008B, r23	; 0x80008b <__TEXT_REGION_LENGTH__+0x70008b>
    1774:	60 93 8a 00 	sts	0x008A, r22	; 0x80008a <__TEXT_REGION_LENGTH__+0x70008a>
}
    1778:	ff 90       	pop	r15
    177a:	ef 90       	pop	r14
    177c:	df 90       	pop	r13
    177e:	cf 90       	pop	r12
    1780:	08 95       	ret

00001782 <_ZN6Timer116setDutyCycleComCEf>:

void Timer1::setDutyCycleComC( float dutyCycle )
{
    1782:	cf 92       	push	r12
    1784:	df 92       	push	r13
    1786:	ef 92       	push	r14
    1788:	ff 92       	push	r15
    178a:	6a 01       	movw	r12, r20
    178c:	7b 01       	movw	r14, r22
	float percent = ICR1/100;
    178e:	20 91 86 00 	lds	r18, 0x0086	; 0x800086 <__TEXT_REGION_LENGTH__+0x700086>
    1792:	30 91 87 00 	lds	r19, 0x0087	; 0x800087 <__TEXT_REGION_LENGTH__+0x700087>
    1796:	36 95       	lsr	r19
    1798:	27 95       	ror	r18
    179a:	36 95       	lsr	r19
    179c:	27 95       	ror	r18
    179e:	ab e7       	ldi	r26, 0x7B	; 123
    17a0:	b4 e1       	ldi	r27, 0x14	; 20
    17a2:	0e 94 f2 16 	call	0x2de4	; 0x2de4 <__umulhisi3>
    17a6:	96 95       	lsr	r25
    17a8:	87 95       	ror	r24
	OCR1C = (uint8_t)percent*dutyCycle;
    17aa:	bc 01       	movw	r22, r24
    17ac:	77 27       	eor	r23, r23
    17ae:	07 2e       	mov	r0, r23
    17b0:	00 0c       	add	r0, r0
    17b2:	88 0b       	sbc	r24, r24
    17b4:	99 0b       	sbc	r25, r25
    17b6:	0e 94 d3 15 	call	0x2ba6	; 0x2ba6 <__floatsisf>
    17ba:	a7 01       	movw	r20, r14
    17bc:	96 01       	movw	r18, r12
    17be:	0e 94 87 16 	call	0x2d0e	; 0x2d0e <__mulsf3>
    17c2:	0e 94 a5 15 	call	0x2b4a	; 0x2b4a <__fixunssfsi>
    17c6:	70 93 8d 00 	sts	0x008D, r23	; 0x80008d <__TEXT_REGION_LENGTH__+0x70008d>
    17ca:	60 93 8c 00 	sts	0x008C, r22	; 0x80008c <__TEXT_REGION_LENGTH__+0x70008c>
    17ce:	ff 90       	pop	r15
    17d0:	ef 90       	pop	r14
    17d2:	df 90       	pop	r13
    17d4:	cf 90       	pop	r12
    17d6:	08 95       	ret

000017d8 <_ZN6Timer5C1Ev>:
#include <avr/io.h>

Timer5::Timer5()
{
	// Set all needed ports to outputs
	ROBOTARM_M4_OUT_PORT |= ( 1 << ROBOTARM_M4_OUT_PIN );
    17d8:	ea e0       	ldi	r30, 0x0A	; 10
    17da:	f1 e0       	ldi	r31, 0x01	; 1
    17dc:	80 81       	ld	r24, Z
    17de:	88 60       	ori	r24, 0x08	; 8
    17e0:	80 83       	st	Z, r24
	ROBOTARM_M5_OUT_PORT |= ( 1 << ROBOTARM_M5_OUT_PIN );
    17e2:	80 81       	ld	r24, Z
    17e4:	80 61       	ori	r24, 0x10	; 16
    17e6:	80 83       	st	Z, r24
	ROBOTARM_M6_OUT_PORT |= ( 1 << ROBOTARM_M6_OUT_PIN );
    17e8:	80 81       	ld	r24, Z
    17ea:	80 62       	ori	r24, 0x20	; 32
    17ec:	80 83       	st	Z, r24
	
	// Set timer to run in PWM, Phase Correct mode with 50 Hz freq.
	TCCR5A = ( 1 << COM3A1 ) | ( 1 << COM3B1 ) | ( 1 << COM3C1 ) | ( 0 << WGM30 ) | ( 0 << WGM31 );
    17ee:	88 ea       	ldi	r24, 0xA8	; 168
    17f0:	80 93 20 01 	sts	0x0120, r24	; 0x800120 <__TEXT_REGION_LENGTH__+0x700120>
	TCCR5B = ( 1 << WGM33 ) | ( 0 << CS30 )  | ( 1 << CS32 );
    17f4:	84 e1       	ldi	r24, 0x14	; 20
    17f6:	80 93 21 01 	sts	0x0121, r24	; 0x800121 <__TEXT_REGION_LENGTH__+0x700121>
	TCCR5C = 0;
    17fa:	10 92 22 01 	sts	0x0122, r1	; 0x800122 <__TEXT_REGION_LENGTH__+0x700122>
	ICR5 = 622;
    17fe:	8e e6       	ldi	r24, 0x6E	; 110
    1800:	92 e0       	ldi	r25, 0x02	; 2
    1802:	90 93 27 01 	sts	0x0127, r25	; 0x800127 <__TEXT_REGION_LENGTH__+0x700127>
    1806:	80 93 26 01 	sts	0x0126, r24	; 0x800126 <__TEXT_REGION_LENGTH__+0x700126>
	
	OCR5A = 0;
    180a:	10 92 29 01 	sts	0x0129, r1	; 0x800129 <__TEXT_REGION_LENGTH__+0x700129>
    180e:	10 92 28 01 	sts	0x0128, r1	; 0x800128 <__TEXT_REGION_LENGTH__+0x700128>
	OCR5B = 0;
    1812:	10 92 2b 01 	sts	0x012B, r1	; 0x80012b <__TEXT_REGION_LENGTH__+0x70012b>
    1816:	10 92 2a 01 	sts	0x012A, r1	; 0x80012a <__TEXT_REGION_LENGTH__+0x70012a>
	OCR5C = 0;
    181a:	10 92 2d 01 	sts	0x012D, r1	; 0x80012d <__TEXT_REGION_LENGTH__+0x70012d>
    181e:	10 92 2c 01 	sts	0x012C, r1	; 0x80012c <__TEXT_REGION_LENGTH__+0x70012c>
    1822:	08 95       	ret

00001824 <_ZN6Timer516setDutyCycleComAEf>:
}

void Timer5::setDutyCycleComA( float dutyCycle )
{
    1824:	cf 92       	push	r12
    1826:	df 92       	push	r13
    1828:	ef 92       	push	r14
    182a:	ff 92       	push	r15
    182c:	6a 01       	movw	r12, r20
    182e:	7b 01       	movw	r14, r22
	float percent = ICR5/100;
    1830:	20 91 26 01 	lds	r18, 0x0126	; 0x800126 <__TEXT_REGION_LENGTH__+0x700126>
    1834:	30 91 27 01 	lds	r19, 0x0127	; 0x800127 <__TEXT_REGION_LENGTH__+0x700127>
    1838:	36 95       	lsr	r19
    183a:	27 95       	ror	r18
    183c:	36 95       	lsr	r19
    183e:	27 95       	ror	r18
    1840:	ab e7       	ldi	r26, 0x7B	; 123
    1842:	b4 e1       	ldi	r27, 0x14	; 20
    1844:	0e 94 f2 16 	call	0x2de4	; 0x2de4 <__umulhisi3>
    1848:	96 95       	lsr	r25
    184a:	87 95       	ror	r24
	OCR5A = (uint8_t)percent*dutyCycle;
    184c:	bc 01       	movw	r22, r24
    184e:	77 27       	eor	r23, r23
    1850:	07 2e       	mov	r0, r23
    1852:	00 0c       	add	r0, r0
    1854:	88 0b       	sbc	r24, r24
    1856:	99 0b       	sbc	r25, r25
    1858:	0e 94 d3 15 	call	0x2ba6	; 0x2ba6 <__floatsisf>
    185c:	a7 01       	movw	r20, r14
    185e:	96 01       	movw	r18, r12
    1860:	0e 94 87 16 	call	0x2d0e	; 0x2d0e <__mulsf3>
    1864:	0e 94 a5 15 	call	0x2b4a	; 0x2b4a <__fixunssfsi>
    1868:	70 93 29 01 	sts	0x0129, r23	; 0x800129 <__TEXT_REGION_LENGTH__+0x700129>
    186c:	60 93 28 01 	sts	0x0128, r22	; 0x800128 <__TEXT_REGION_LENGTH__+0x700128>
}
    1870:	ff 90       	pop	r15
    1872:	ef 90       	pop	r14
    1874:	df 90       	pop	r13
    1876:	cf 90       	pop	r12
    1878:	08 95       	ret

0000187a <_ZN6Timer516setDutyCycleComBEf>:

void Timer5::setDutyCycleComB( float dutyCycle )
{
    187a:	cf 92       	push	r12
    187c:	df 92       	push	r13
    187e:	ef 92       	push	r14
    1880:	ff 92       	push	r15
    1882:	6a 01       	movw	r12, r20
    1884:	7b 01       	movw	r14, r22
	float percent = ICR5/100;
    1886:	20 91 26 01 	lds	r18, 0x0126	; 0x800126 <__TEXT_REGION_LENGTH__+0x700126>
    188a:	30 91 27 01 	lds	r19, 0x0127	; 0x800127 <__TEXT_REGION_LENGTH__+0x700127>
    188e:	36 95       	lsr	r19
    1890:	27 95       	ror	r18
    1892:	36 95       	lsr	r19
    1894:	27 95       	ror	r18
    1896:	ab e7       	ldi	r26, 0x7B	; 123
    1898:	b4 e1       	ldi	r27, 0x14	; 20
    189a:	0e 94 f2 16 	call	0x2de4	; 0x2de4 <__umulhisi3>
    189e:	96 95       	lsr	r25
    18a0:	87 95       	ror	r24
	OCR5B = (uint8_t)percent*dutyCycle;
    18a2:	bc 01       	movw	r22, r24
    18a4:	77 27       	eor	r23, r23
    18a6:	07 2e       	mov	r0, r23
    18a8:	00 0c       	add	r0, r0
    18aa:	88 0b       	sbc	r24, r24
    18ac:	99 0b       	sbc	r25, r25
    18ae:	0e 94 d3 15 	call	0x2ba6	; 0x2ba6 <__floatsisf>
    18b2:	a7 01       	movw	r20, r14
    18b4:	96 01       	movw	r18, r12
    18b6:	0e 94 87 16 	call	0x2d0e	; 0x2d0e <__mulsf3>
    18ba:	0e 94 a5 15 	call	0x2b4a	; 0x2b4a <__fixunssfsi>
    18be:	70 93 2b 01 	sts	0x012B, r23	; 0x80012b <__TEXT_REGION_LENGTH__+0x70012b>
    18c2:	60 93 2a 01 	sts	0x012A, r22	; 0x80012a <__TEXT_REGION_LENGTH__+0x70012a>
}
    18c6:	ff 90       	pop	r15
    18c8:	ef 90       	pop	r14
    18ca:	df 90       	pop	r13
    18cc:	cf 90       	pop	r12
    18ce:	08 95       	ret

000018d0 <_ZN6Timer516setDutyCycleComCEf>:

void Timer5::setDutyCycleComC( float dutyCycle )
{
    18d0:	cf 92       	push	r12
    18d2:	df 92       	push	r13
    18d4:	ef 92       	push	r14
    18d6:	ff 92       	push	r15
    18d8:	6a 01       	movw	r12, r20
    18da:	7b 01       	movw	r14, r22
	float percent = ICR5/100;
    18dc:	20 91 26 01 	lds	r18, 0x0126	; 0x800126 <__TEXT_REGION_LENGTH__+0x700126>
    18e0:	30 91 27 01 	lds	r19, 0x0127	; 0x800127 <__TEXT_REGION_LENGTH__+0x700127>
    18e4:	36 95       	lsr	r19
    18e6:	27 95       	ror	r18
    18e8:	36 95       	lsr	r19
    18ea:	27 95       	ror	r18
    18ec:	ab e7       	ldi	r26, 0x7B	; 123
    18ee:	b4 e1       	ldi	r27, 0x14	; 20
    18f0:	0e 94 f2 16 	call	0x2de4	; 0x2de4 <__umulhisi3>
    18f4:	96 95       	lsr	r25
    18f6:	87 95       	ror	r24
	OCR5C = (uint8_t)percent*dutyCycle;
    18f8:	bc 01       	movw	r22, r24
    18fa:	77 27       	eor	r23, r23
    18fc:	07 2e       	mov	r0, r23
    18fe:	00 0c       	add	r0, r0
    1900:	88 0b       	sbc	r24, r24
    1902:	99 0b       	sbc	r25, r25
    1904:	0e 94 d3 15 	call	0x2ba6	; 0x2ba6 <__floatsisf>
    1908:	a7 01       	movw	r20, r14
    190a:	96 01       	movw	r18, r12
    190c:	0e 94 87 16 	call	0x2d0e	; 0x2d0e <__mulsf3>
    1910:	0e 94 a5 15 	call	0x2b4a	; 0x2b4a <__fixunssfsi>
    1914:	70 93 2d 01 	sts	0x012D, r23	; 0x80012d <__TEXT_REGION_LENGTH__+0x70012d>
    1918:	60 93 2c 01 	sts	0x012C, r22	; 0x80012c <__TEXT_REGION_LENGTH__+0x70012c>
    191c:	ff 90       	pop	r15
    191e:	ef 90       	pop	r14
    1920:	df 90       	pop	r13
    1922:	cf 90       	pop	r12
    1924:	08 95       	ret

00001926 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
    1926:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
    1928:	03 96       	adiw	r24, 0x03	; 3
    192a:	92 83       	std	Z+2, r25	; 0x02
    192c:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    192e:	2f ef       	ldi	r18, 0xFF	; 255
    1930:	3f ef       	ldi	r19, 0xFF	; 255
    1932:	34 83       	std	Z+4, r19	; 0x04
    1934:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
    1936:	96 83       	std	Z+6, r25	; 0x06
    1938:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
    193a:	90 87       	std	Z+8, r25	; 0x08
    193c:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
    193e:	10 82       	st	Z, r1
    1940:	08 95       	ret

00001942 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    1942:	fc 01       	movw	r30, r24
    1944:	11 86       	std	Z+9, r1	; 0x09
    1946:	10 86       	std	Z+8, r1	; 0x08
    1948:	08 95       	ret

0000194a <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
    194a:	cf 93       	push	r28
    194c:	df 93       	push	r29
    194e:	fc 01       	movw	r30, r24
    1950:	db 01       	movw	r26, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
    1952:	21 81       	ldd	r18, Z+1	; 0x01
    1954:	32 81       	ldd	r19, Z+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
    1956:	e9 01       	movw	r28, r18
    1958:	8a 81       	ldd	r24, Y+2	; 0x02
    195a:	9b 81       	ldd	r25, Y+3	; 0x03
    195c:	13 96       	adiw	r26, 0x03	; 3
    195e:	9c 93       	st	X, r25
    1960:	8e 93       	st	-X, r24
    1962:	12 97       	sbiw	r26, 0x02	; 2
	pxNewListItem->pxPrevious = pxList->pxIndex;
    1964:	81 81       	ldd	r24, Z+1	; 0x01
    1966:	92 81       	ldd	r25, Z+2	; 0x02
    1968:	15 96       	adiw	r26, 0x05	; 5
    196a:	9c 93       	st	X, r25
    196c:	8e 93       	st	-X, r24
    196e:	14 97       	sbiw	r26, 0x04	; 4
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    1970:	8a 81       	ldd	r24, Y+2	; 0x02
    1972:	9b 81       	ldd	r25, Y+3	; 0x03
    1974:	ec 01       	movw	r28, r24
    1976:	7d 83       	std	Y+5, r23	; 0x05
    1978:	6c 83       	std	Y+4, r22	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
    197a:	e9 01       	movw	r28, r18
    197c:	7b 83       	std	Y+3, r23	; 0x03
    197e:	6a 83       	std	Y+2, r22	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
    1980:	72 83       	std	Z+2, r23	; 0x02
    1982:	61 83       	std	Z+1, r22	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1984:	19 96       	adiw	r26, 0x09	; 9
    1986:	fc 93       	st	X, r31
    1988:	ee 93       	st	-X, r30
    198a:	18 97       	sbiw	r26, 0x08	; 8

	( pxList->uxNumberOfItems )++;
    198c:	80 81       	ld	r24, Z
    198e:	8f 5f       	subi	r24, 0xFF	; 255
    1990:	80 83       	st	Z, r24
}
    1992:	df 91       	pop	r29
    1994:	cf 91       	pop	r28
    1996:	08 95       	ret

00001998 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
    1998:	cf 93       	push	r28
    199a:	df 93       	push	r29
    199c:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
    199e:	48 81       	ld	r20, Y
    19a0:	59 81       	ldd	r21, Y+1	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    19a2:	4f 3f       	cpi	r20, 0xFF	; 255
    19a4:	2f ef       	ldi	r18, 0xFF	; 255
    19a6:	52 07       	cpc	r21, r18
    19a8:	31 f4       	brne	.+12     	; 0x19b6 <vListInsert+0x1e>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    19aa:	dc 01       	movw	r26, r24
    19ac:	17 96       	adiw	r26, 0x07	; 7
    19ae:	ed 91       	ld	r30, X+
    19b0:	fc 91       	ld	r31, X
    19b2:	18 97       	sbiw	r26, 0x08	; 8
    19b4:	0d c0       	rjmp	.+26     	; 0x19d0 <vListInsert+0x38>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    19b6:	fc 01       	movw	r30, r24
    19b8:	33 96       	adiw	r30, 0x03	; 3
    19ba:	03 c0       	rjmp	.+6      	; 0x19c2 <vListInsert+0x2a>
    19bc:	02 80       	ldd	r0, Z+2	; 0x02
    19be:	f3 81       	ldd	r31, Z+3	; 0x03
    19c0:	e0 2d       	mov	r30, r0
    19c2:	a2 81       	ldd	r26, Z+2	; 0x02
    19c4:	b3 81       	ldd	r27, Z+3	; 0x03
    19c6:	2d 91       	ld	r18, X+
    19c8:	3c 91       	ld	r19, X
    19ca:	42 17       	cp	r20, r18
    19cc:	53 07       	cpc	r21, r19
    19ce:	b0 f7       	brcc	.-20     	; 0x19bc <vListInsert+0x24>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    19d0:	a2 81       	ldd	r26, Z+2	; 0x02
    19d2:	b3 81       	ldd	r27, Z+3	; 0x03
    19d4:	bb 83       	std	Y+3, r27	; 0x03
    19d6:	aa 83       	std	Y+2, r26	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    19d8:	15 96       	adiw	r26, 0x05	; 5
    19da:	dc 93       	st	X, r29
    19dc:	ce 93       	st	-X, r28
    19de:	14 97       	sbiw	r26, 0x04	; 4
	pxNewListItem->pxPrevious = pxIterator;
    19e0:	fd 83       	std	Y+5, r31	; 0x05
    19e2:	ec 83       	std	Y+4, r30	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    19e4:	d3 83       	std	Z+3, r29	; 0x03
    19e6:	c2 83       	std	Z+2, r28	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    19e8:	99 87       	std	Y+9, r25	; 0x09
    19ea:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    19ec:	fc 01       	movw	r30, r24
    19ee:	20 81       	ld	r18, Z
    19f0:	2f 5f       	subi	r18, 0xFF	; 255
    19f2:	20 83       	st	Z, r18
}
    19f4:	df 91       	pop	r29
    19f6:	cf 91       	pop	r28
    19f8:	08 95       	ret

000019fa <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
    19fa:	fc 01       	movw	r30, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    19fc:	a2 81       	ldd	r26, Z+2	; 0x02
    19fe:	b3 81       	ldd	r27, Z+3	; 0x03
    1a00:	84 81       	ldd	r24, Z+4	; 0x04
    1a02:	95 81       	ldd	r25, Z+5	; 0x05
    1a04:	15 96       	adiw	r26, 0x05	; 5
    1a06:	9c 93       	st	X, r25
    1a08:	8e 93       	st	-X, r24
    1a0a:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    1a0c:	a4 81       	ldd	r26, Z+4	; 0x04
    1a0e:	b5 81       	ldd	r27, Z+5	; 0x05
    1a10:	82 81       	ldd	r24, Z+2	; 0x02
    1a12:	93 81       	ldd	r25, Z+3	; 0x03
    1a14:	13 96       	adiw	r26, 0x03	; 3
    1a16:	9c 93       	st	X, r25
    1a18:	8e 93       	st	-X, r24
    1a1a:	12 97       	sbiw	r26, 0x02	; 2
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    1a1c:	a0 85       	ldd	r26, Z+8	; 0x08
    1a1e:	b1 85       	ldd	r27, Z+9	; 0x09

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    1a20:	11 96       	adiw	r26, 0x01	; 1
    1a22:	8d 91       	ld	r24, X+
    1a24:	9c 91       	ld	r25, X
    1a26:	12 97       	sbiw	r26, 0x02	; 2
    1a28:	e8 17       	cp	r30, r24
    1a2a:	f9 07       	cpc	r31, r25
    1a2c:	31 f4       	brne	.+12     	; 0x1a3a <vListRemove+0x40>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    1a2e:	84 81       	ldd	r24, Z+4	; 0x04
    1a30:	95 81       	ldd	r25, Z+5	; 0x05
    1a32:	12 96       	adiw	r26, 0x02	; 2
    1a34:	9c 93       	st	X, r25
    1a36:	8e 93       	st	-X, r24
    1a38:	11 97       	sbiw	r26, 0x01	; 1
	}

	pxItemToRemove->pvContainer = NULL;
    1a3a:	11 86       	std	Z+9, r1	; 0x09
    1a3c:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    1a3e:	8c 91       	ld	r24, X
    1a40:	81 50       	subi	r24, 0x01	; 1
    1a42:	8c 93       	st	X, r24
    1a44:	08 95       	ret

00001a46 <prvSetupTimerInterrupt>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    1a46:	8a ef       	ldi	r24, 0xFA	; 250
    1a48:	87 bd       	out	0x27, r24	; 39
    1a4a:	82 e0       	ldi	r24, 0x02	; 2
    1a4c:	84 bd       	out	0x24, r24	; 36
    1a4e:	93 e0       	ldi	r25, 0x03	; 3
    1a50:	95 bd       	out	0x25, r25	; 37
    1a52:	80 93 6e 00 	sts	0x006E, r24	; 0x80006e <__TEXT_REGION_LENGTH__+0x70006e>
    1a56:	08 95       	ret

00001a58 <pxPortInitialiseStack>:
    1a58:	31 e1       	ldi	r19, 0x11	; 17
    1a5a:	fc 01       	movw	r30, r24
    1a5c:	30 83       	st	Z, r19
    1a5e:	31 97       	sbiw	r30, 0x01	; 1
    1a60:	22 e2       	ldi	r18, 0x22	; 34
    1a62:	20 83       	st	Z, r18
    1a64:	31 97       	sbiw	r30, 0x01	; 1
    1a66:	a3 e3       	ldi	r26, 0x33	; 51
    1a68:	a0 83       	st	Z, r26
    1a6a:	31 97       	sbiw	r30, 0x01	; 1
    1a6c:	60 83       	st	Z, r22
    1a6e:	31 97       	sbiw	r30, 0x01	; 1
    1a70:	70 83       	st	Z, r23
    1a72:	31 97       	sbiw	r30, 0x01	; 1
    1a74:	10 82       	st	Z, r1
    1a76:	31 97       	sbiw	r30, 0x01	; 1
    1a78:	10 82       	st	Z, r1
    1a7a:	31 97       	sbiw	r30, 0x01	; 1
    1a7c:	60 e8       	ldi	r22, 0x80	; 128
    1a7e:	60 83       	st	Z, r22
    1a80:	31 97       	sbiw	r30, 0x01	; 1
    1a82:	10 82       	st	Z, r1
    1a84:	31 97       	sbiw	r30, 0x01	; 1
    1a86:	10 82       	st	Z, r1
    1a88:	31 97       	sbiw	r30, 0x01	; 1
    1a8a:	10 82       	st	Z, r1
    1a8c:	31 97       	sbiw	r30, 0x01	; 1
    1a8e:	62 e0       	ldi	r22, 0x02	; 2
    1a90:	60 83       	st	Z, r22
    1a92:	31 97       	sbiw	r30, 0x01	; 1
    1a94:	63 e0       	ldi	r22, 0x03	; 3
    1a96:	60 83       	st	Z, r22
    1a98:	31 97       	sbiw	r30, 0x01	; 1
    1a9a:	64 e0       	ldi	r22, 0x04	; 4
    1a9c:	60 83       	st	Z, r22
    1a9e:	31 97       	sbiw	r30, 0x01	; 1
    1aa0:	65 e0       	ldi	r22, 0x05	; 5
    1aa2:	60 83       	st	Z, r22
    1aa4:	31 97       	sbiw	r30, 0x01	; 1
    1aa6:	66 e0       	ldi	r22, 0x06	; 6
    1aa8:	60 83       	st	Z, r22
    1aaa:	31 97       	sbiw	r30, 0x01	; 1
    1aac:	67 e0       	ldi	r22, 0x07	; 7
    1aae:	60 83       	st	Z, r22
    1ab0:	31 97       	sbiw	r30, 0x01	; 1
    1ab2:	68 e0       	ldi	r22, 0x08	; 8
    1ab4:	60 83       	st	Z, r22
    1ab6:	31 97       	sbiw	r30, 0x01	; 1
    1ab8:	69 e0       	ldi	r22, 0x09	; 9
    1aba:	60 83       	st	Z, r22
    1abc:	31 97       	sbiw	r30, 0x01	; 1
    1abe:	60 e1       	ldi	r22, 0x10	; 16
    1ac0:	60 83       	st	Z, r22
    1ac2:	31 97       	sbiw	r30, 0x01	; 1
    1ac4:	30 83       	st	Z, r19
    1ac6:	31 97       	sbiw	r30, 0x01	; 1
    1ac8:	32 e1       	ldi	r19, 0x12	; 18
    1aca:	30 83       	st	Z, r19
    1acc:	31 97       	sbiw	r30, 0x01	; 1
    1ace:	33 e1       	ldi	r19, 0x13	; 19
    1ad0:	30 83       	st	Z, r19
    1ad2:	31 97       	sbiw	r30, 0x01	; 1
    1ad4:	34 e1       	ldi	r19, 0x14	; 20
    1ad6:	30 83       	st	Z, r19
    1ad8:	31 97       	sbiw	r30, 0x01	; 1
    1ada:	35 e1       	ldi	r19, 0x15	; 21
    1adc:	30 83       	st	Z, r19
    1ade:	31 97       	sbiw	r30, 0x01	; 1
    1ae0:	36 e1       	ldi	r19, 0x16	; 22
    1ae2:	30 83       	st	Z, r19
    1ae4:	31 97       	sbiw	r30, 0x01	; 1
    1ae6:	37 e1       	ldi	r19, 0x17	; 23
    1ae8:	30 83       	st	Z, r19
    1aea:	31 97       	sbiw	r30, 0x01	; 1
    1aec:	38 e1       	ldi	r19, 0x18	; 24
    1aee:	30 83       	st	Z, r19
    1af0:	31 97       	sbiw	r30, 0x01	; 1
    1af2:	39 e1       	ldi	r19, 0x19	; 25
    1af4:	30 83       	st	Z, r19
    1af6:	31 97       	sbiw	r30, 0x01	; 1
    1af8:	30 e2       	ldi	r19, 0x20	; 32
    1afa:	30 83       	st	Z, r19
    1afc:	31 97       	sbiw	r30, 0x01	; 1
    1afe:	31 e2       	ldi	r19, 0x21	; 33
    1b00:	30 83       	st	Z, r19
    1b02:	31 97       	sbiw	r30, 0x01	; 1
    1b04:	20 83       	st	Z, r18
    1b06:	31 97       	sbiw	r30, 0x01	; 1
    1b08:	23 e2       	ldi	r18, 0x23	; 35
    1b0a:	20 83       	st	Z, r18
    1b0c:	31 97       	sbiw	r30, 0x01	; 1
    1b0e:	40 83       	st	Z, r20
    1b10:	31 97       	sbiw	r30, 0x01	; 1
    1b12:	50 83       	st	Z, r21
    1b14:	31 97       	sbiw	r30, 0x01	; 1
    1b16:	26 e2       	ldi	r18, 0x26	; 38
    1b18:	20 83       	st	Z, r18
    1b1a:	31 97       	sbiw	r30, 0x01	; 1
    1b1c:	27 e2       	ldi	r18, 0x27	; 39
    1b1e:	20 83       	st	Z, r18
    1b20:	31 97       	sbiw	r30, 0x01	; 1
    1b22:	28 e2       	ldi	r18, 0x28	; 40
    1b24:	20 83       	st	Z, r18
    1b26:	31 97       	sbiw	r30, 0x01	; 1
    1b28:	29 e2       	ldi	r18, 0x29	; 41
    1b2a:	20 83       	st	Z, r18
    1b2c:	31 97       	sbiw	r30, 0x01	; 1
    1b2e:	20 e3       	ldi	r18, 0x30	; 48
    1b30:	20 83       	st	Z, r18
    1b32:	31 97       	sbiw	r30, 0x01	; 1
    1b34:	21 e3       	ldi	r18, 0x31	; 49
    1b36:	20 83       	st	Z, r18
    1b38:	89 97       	sbiw	r24, 0x29	; 41
    1b3a:	08 95       	ret

00001b3c <xPortStartScheduler>:
    1b3c:	84 df       	rcall	.-248    	; 0x1a46 <prvSetupTimerInterrupt>
    1b3e:	a0 91 2d 09 	lds	r26, 0x092D	; 0x80092d <pxCurrentTCB>
    1b42:	b0 91 2e 09 	lds	r27, 0x092E	; 0x80092e <pxCurrentTCB+0x1>
    1b46:	cd 91       	ld	r28, X+
    1b48:	cd bf       	out	0x3d, r28	; 61
    1b4a:	dd 91       	ld	r29, X+
    1b4c:	de bf       	out	0x3e, r29	; 62
    1b4e:	ff 91       	pop	r31
    1b50:	ef 91       	pop	r30
    1b52:	df 91       	pop	r29
    1b54:	cf 91       	pop	r28
    1b56:	bf 91       	pop	r27
    1b58:	af 91       	pop	r26
    1b5a:	9f 91       	pop	r25
    1b5c:	8f 91       	pop	r24
    1b5e:	7f 91       	pop	r23
    1b60:	6f 91       	pop	r22
    1b62:	5f 91       	pop	r21
    1b64:	4f 91       	pop	r20
    1b66:	3f 91       	pop	r19
    1b68:	2f 91       	pop	r18
    1b6a:	1f 91       	pop	r17
    1b6c:	0f 91       	pop	r16
    1b6e:	ff 90       	pop	r15
    1b70:	ef 90       	pop	r14
    1b72:	df 90       	pop	r13
    1b74:	cf 90       	pop	r12
    1b76:	bf 90       	pop	r11
    1b78:	af 90       	pop	r10
    1b7a:	9f 90       	pop	r9
    1b7c:	8f 90       	pop	r8
    1b7e:	7f 90       	pop	r7
    1b80:	6f 90       	pop	r6
    1b82:	5f 90       	pop	r5
    1b84:	4f 90       	pop	r4
    1b86:	3f 90       	pop	r3
    1b88:	2f 90       	pop	r2
    1b8a:	1f 90       	pop	r1
    1b8c:	0f 90       	pop	r0
    1b8e:	0c be       	out	0x3c, r0	; 60
    1b90:	0f 90       	pop	r0
    1b92:	0b be       	out	0x3b, r0	; 59
    1b94:	0f 90       	pop	r0
    1b96:	0f be       	out	0x3f, r0	; 63
    1b98:	0f 90       	pop	r0
    1b9a:	08 95       	ret
    1b9c:	81 e0       	ldi	r24, 0x01	; 1
    1b9e:	08 95       	ret

00001ba0 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    1ba0:	0f 92       	push	r0
    1ba2:	0f b6       	in	r0, 0x3f	; 63
    1ba4:	f8 94       	cli
    1ba6:	0f 92       	push	r0
    1ba8:	0b b6       	in	r0, 0x3b	; 59
    1baa:	0f 92       	push	r0
    1bac:	0c b6       	in	r0, 0x3c	; 60
    1bae:	0f 92       	push	r0
    1bb0:	1f 92       	push	r1
    1bb2:	11 24       	eor	r1, r1
    1bb4:	2f 92       	push	r2
    1bb6:	3f 92       	push	r3
    1bb8:	4f 92       	push	r4
    1bba:	5f 92       	push	r5
    1bbc:	6f 92       	push	r6
    1bbe:	7f 92       	push	r7
    1bc0:	8f 92       	push	r8
    1bc2:	9f 92       	push	r9
    1bc4:	af 92       	push	r10
    1bc6:	bf 92       	push	r11
    1bc8:	cf 92       	push	r12
    1bca:	df 92       	push	r13
    1bcc:	ef 92       	push	r14
    1bce:	ff 92       	push	r15
    1bd0:	0f 93       	push	r16
    1bd2:	1f 93       	push	r17
    1bd4:	2f 93       	push	r18
    1bd6:	3f 93       	push	r19
    1bd8:	4f 93       	push	r20
    1bda:	5f 93       	push	r21
    1bdc:	6f 93       	push	r22
    1bde:	7f 93       	push	r23
    1be0:	8f 93       	push	r24
    1be2:	9f 93       	push	r25
    1be4:	af 93       	push	r26
    1be6:	bf 93       	push	r27
    1be8:	cf 93       	push	r28
    1bea:	df 93       	push	r29
    1bec:	ef 93       	push	r30
    1bee:	ff 93       	push	r31
    1bf0:	a0 91 2d 09 	lds	r26, 0x092D	; 0x80092d <pxCurrentTCB>
    1bf4:	b0 91 2e 09 	lds	r27, 0x092E	; 0x80092e <pxCurrentTCB+0x1>
    1bf8:	0d b6       	in	r0, 0x3d	; 61
    1bfa:	0d 92       	st	X+, r0
    1bfc:	0e b6       	in	r0, 0x3e	; 62
    1bfe:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    1c00:	86 d3       	rcall	.+1804   	; 0x230e <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1c02:	a0 91 2d 09 	lds	r26, 0x092D	; 0x80092d <pxCurrentTCB>
    1c06:	b0 91 2e 09 	lds	r27, 0x092E	; 0x80092e <pxCurrentTCB+0x1>
    1c0a:	cd 91       	ld	r28, X+
    1c0c:	cd bf       	out	0x3d, r28	; 61
    1c0e:	dd 91       	ld	r29, X+
    1c10:	de bf       	out	0x3e, r29	; 62
    1c12:	ff 91       	pop	r31
    1c14:	ef 91       	pop	r30
    1c16:	df 91       	pop	r29
    1c18:	cf 91       	pop	r28
    1c1a:	bf 91       	pop	r27
    1c1c:	af 91       	pop	r26
    1c1e:	9f 91       	pop	r25
    1c20:	8f 91       	pop	r24
    1c22:	7f 91       	pop	r23
    1c24:	6f 91       	pop	r22
    1c26:	5f 91       	pop	r21
    1c28:	4f 91       	pop	r20
    1c2a:	3f 91       	pop	r19
    1c2c:	2f 91       	pop	r18
    1c2e:	1f 91       	pop	r17
    1c30:	0f 91       	pop	r16
    1c32:	ff 90       	pop	r15
    1c34:	ef 90       	pop	r14
    1c36:	df 90       	pop	r13
    1c38:	cf 90       	pop	r12
    1c3a:	bf 90       	pop	r11
    1c3c:	af 90       	pop	r10
    1c3e:	9f 90       	pop	r9
    1c40:	8f 90       	pop	r8
    1c42:	7f 90       	pop	r7
    1c44:	6f 90       	pop	r6
    1c46:	5f 90       	pop	r5
    1c48:	4f 90       	pop	r4
    1c4a:	3f 90       	pop	r3
    1c4c:	2f 90       	pop	r2
    1c4e:	1f 90       	pop	r1
    1c50:	0f 90       	pop	r0
    1c52:	0c be       	out	0x3c, r0	; 60
    1c54:	0f 90       	pop	r0
    1c56:	0b be       	out	0x3b, r0	; 59
    1c58:	0f 90       	pop	r0
    1c5a:	0f be       	out	0x3f, r0	; 63
    1c5c:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1c5e:	08 95       	ret

00001c60 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    1c60:	0f 92       	push	r0
    1c62:	0f b6       	in	r0, 0x3f	; 63
    1c64:	f8 94       	cli
    1c66:	0f 92       	push	r0
    1c68:	0b b6       	in	r0, 0x3b	; 59
    1c6a:	0f 92       	push	r0
    1c6c:	0c b6       	in	r0, 0x3c	; 60
    1c6e:	0f 92       	push	r0
    1c70:	1f 92       	push	r1
    1c72:	11 24       	eor	r1, r1
    1c74:	2f 92       	push	r2
    1c76:	3f 92       	push	r3
    1c78:	4f 92       	push	r4
    1c7a:	5f 92       	push	r5
    1c7c:	6f 92       	push	r6
    1c7e:	7f 92       	push	r7
    1c80:	8f 92       	push	r8
    1c82:	9f 92       	push	r9
    1c84:	af 92       	push	r10
    1c86:	bf 92       	push	r11
    1c88:	cf 92       	push	r12
    1c8a:	df 92       	push	r13
    1c8c:	ef 92       	push	r14
    1c8e:	ff 92       	push	r15
    1c90:	0f 93       	push	r16
    1c92:	1f 93       	push	r17
    1c94:	2f 93       	push	r18
    1c96:	3f 93       	push	r19
    1c98:	4f 93       	push	r20
    1c9a:	5f 93       	push	r21
    1c9c:	6f 93       	push	r22
    1c9e:	7f 93       	push	r23
    1ca0:	8f 93       	push	r24
    1ca2:	9f 93       	push	r25
    1ca4:	af 93       	push	r26
    1ca6:	bf 93       	push	r27
    1ca8:	cf 93       	push	r28
    1caa:	df 93       	push	r29
    1cac:	ef 93       	push	r30
    1cae:	ff 93       	push	r31
    1cb0:	a0 91 2d 09 	lds	r26, 0x092D	; 0x80092d <pxCurrentTCB>
    1cb4:	b0 91 2e 09 	lds	r27, 0x092E	; 0x80092e <pxCurrentTCB+0x1>
    1cb8:	0d b6       	in	r0, 0x3d	; 61
    1cba:	0d 92       	st	X+, r0
    1cbc:	0e b6       	in	r0, 0x3e	; 62
    1cbe:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    1cc0:	f1 d1       	rcall	.+994    	; 0x20a4 <vTaskIncrementTick>
	vTaskSwitchContext();
    1cc2:	25 d3       	rcall	.+1610   	; 0x230e <vTaskSwitchContext>
    1cc4:	a0 91 2d 09 	lds	r26, 0x092D	; 0x80092d <pxCurrentTCB>
	portRESTORE_CONTEXT();
    1cc8:	b0 91 2e 09 	lds	r27, 0x092E	; 0x80092e <pxCurrentTCB+0x1>
    1ccc:	cd 91       	ld	r28, X+
    1cce:	cd bf       	out	0x3d, r28	; 61
    1cd0:	dd 91       	ld	r29, X+
    1cd2:	de bf       	out	0x3e, r29	; 62
    1cd4:	ff 91       	pop	r31
    1cd6:	ef 91       	pop	r30
    1cd8:	df 91       	pop	r29
    1cda:	cf 91       	pop	r28
    1cdc:	bf 91       	pop	r27
    1cde:	af 91       	pop	r26
    1ce0:	9f 91       	pop	r25
    1ce2:	8f 91       	pop	r24
    1ce4:	7f 91       	pop	r23
    1ce6:	6f 91       	pop	r22
    1ce8:	5f 91       	pop	r21
    1cea:	4f 91       	pop	r20
    1cec:	3f 91       	pop	r19
    1cee:	2f 91       	pop	r18
    1cf0:	1f 91       	pop	r17
    1cf2:	0f 91       	pop	r16
    1cf4:	ff 90       	pop	r15
    1cf6:	ef 90       	pop	r14
    1cf8:	df 90       	pop	r13
    1cfa:	cf 90       	pop	r12
    1cfc:	bf 90       	pop	r11
    1cfe:	af 90       	pop	r10
    1d00:	9f 90       	pop	r9
    1d02:	8f 90       	pop	r8
    1d04:	7f 90       	pop	r7
    1d06:	6f 90       	pop	r6
    1d08:	5f 90       	pop	r5
    1d0a:	4f 90       	pop	r4
    1d0c:	3f 90       	pop	r3
    1d0e:	2f 90       	pop	r2
    1d10:	1f 90       	pop	r1
    1d12:	0f 90       	pop	r0
    1d14:	0c be       	out	0x3c, r0	; 60
    1d16:	0f 90       	pop	r0
    1d18:	0b be       	out	0x3b, r0	; 59
    1d1a:	0f 90       	pop	r0
    1d1c:	0f be       	out	0x3f, r0	; 63
    1d1e:	0f 90       	pop	r0
    1d20:	08 95       	ret

00001d22 <__vector_21>:
	asm volatile ( "ret" );
    1d22:	9e df       	rcall	.-196    	; 0x1c60 <vPortYieldFromTick>
//	void SIG_OUTPUT_COMPARE1A( void )
	void TIMER0_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER0_COMPA_vect( void )
	{
		vPortYieldFromTick();
		asm volatile ( "reti" );
    1d24:	18 95       	reti

00001d26 <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    1d26:	cf 93       	push	r28
    1d28:	df 93       	push	r29
    1d2a:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
    1d2c:	b5 d1       	rcall	.+874    	; 0x2098 <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
    1d2e:	20 91 1c 03 	lds	r18, 0x031C	; 0x80031c <xNextFreeByte>
    1d32:	30 91 1d 03 	lds	r19, 0x031D	; 0x80031d <xNextFreeByte+0x1>
    1d36:	c9 01       	movw	r24, r18
    1d38:	8c 0f       	add	r24, r28
    1d3a:	9d 1f       	adc	r25, r29
    1d3c:	8c 3d       	cpi	r24, 0xDC	; 220
    1d3e:	45 e0       	ldi	r20, 0x05	; 5
    1d40:	94 07       	cpc	r25, r20
    1d42:	58 f4       	brcc	.+22     	; 0x1d5a <pvPortMalloc+0x34>
    1d44:	28 17       	cp	r18, r24
    1d46:	39 07       	cpc	r19, r25
    1d48:	58 f4       	brcc	.+22     	; 0x1d60 <pvPortMalloc+0x3a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
    1d4a:	e9 01       	movw	r28, r18
    1d4c:	c2 5e       	subi	r28, 0xE2	; 226
    1d4e:	dc 4f       	sbci	r29, 0xFC	; 252
			xNextFreeByte += xWantedSize;			
    1d50:	90 93 1d 03 	sts	0x031D, r25	; 0x80031d <xNextFreeByte+0x1>
    1d54:	80 93 1c 03 	sts	0x031C, r24	; 0x80031c <xNextFreeByte>
    1d58:	05 c0       	rjmp	.+10     	; 0x1d64 <pvPortMalloc+0x3e>
static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL; 
    1d5a:	c0 e0       	ldi	r28, 0x00	; 0
    1d5c:	d0 e0       	ldi	r29, 0x00	; 0
    1d5e:	02 c0       	rjmp	.+4      	; 0x1d64 <pvPortMalloc+0x3e>
    1d60:	c0 e0       	ldi	r28, 0x00	; 0
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
			xNextFreeByte += xWantedSize;			
		}	
	}
	xTaskResumeAll();
    1d62:	d0 e0       	ldi	r29, 0x00	; 0
    1d64:	46 d2       	rcall	.+1164   	; 0x21f2 <xTaskResumeAll>
		}
	}
	#endif	

	return pvReturn;
}
    1d66:	ce 01       	movw	r24, r28
    1d68:	df 91       	pop	r29
    1d6a:	cf 91       	pop	r28
    1d6c:	08 95       	ret

00001d6e <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    1d6e:	08 95       	ret

00001d70 <prvIdleTask>:
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
		}
	}
    1d70:	80 91 24 09 	lds	r24, 0x0924	; 0x800924 <pxReadyTasksLists>
    1d74:	82 30       	cpi	r24, 0x02	; 2
    1d76:	e0 f3       	brcs	.-8      	; 0x1d70 <prvIdleTask>
    1d78:	13 df       	rcall	.-474    	; 0x1ba0 <vPortYield>
    1d7a:	fa cf       	rjmp	.-12     	; 0x1d70 <prvIdleTask>

00001d7c <prvAllocateTCBAndStack>:
    1d7c:	ef 92       	push	r14
    1d7e:	ff 92       	push	r15
    1d80:	0f 93       	push	r16
    1d82:	1f 93       	push	r17
    1d84:	cf 93       	push	r28
    1d86:	df 93       	push	r29
    1d88:	7c 01       	movw	r14, r24
    1d8a:	eb 01       	movw	r28, r22
    1d8c:	81 e2       	ldi	r24, 0x21	; 33
    1d8e:	90 e0       	ldi	r25, 0x00	; 0
    1d90:	ca df       	rcall	.-108    	; 0x1d26 <pvPortMalloc>
    1d92:	8c 01       	movw	r16, r24
    1d94:	89 2b       	or	r24, r25
    1d96:	a9 f0       	breq	.+42     	; 0x1dc2 <prvAllocateTCBAndStack+0x46>
    1d98:	20 97       	sbiw	r28, 0x00	; 0
    1d9a:	19 f4       	brne	.+6      	; 0x1da2 <prvAllocateTCBAndStack+0x26>
    1d9c:	c7 01       	movw	r24, r14
    1d9e:	c3 df       	rcall	.-122    	; 0x1d26 <pvPortMalloc>
    1da0:	01 c0       	rjmp	.+2      	; 0x1da4 <prvAllocateTCBAndStack+0x28>
    1da2:	ce 01       	movw	r24, r28
    1da4:	f8 01       	movw	r30, r16
    1da6:	90 8f       	std	Z+24, r25	; 0x18
    1da8:	87 8b       	std	Z+23, r24	; 0x17
    1daa:	00 97       	sbiw	r24, 0x00	; 0
    1dac:	29 f4       	brne	.+10     	; 0x1db8 <prvAllocateTCBAndStack+0x3c>
    1dae:	c8 01       	movw	r24, r16
    1db0:	de df       	rcall	.-68     	; 0x1d6e <vPortFree>
    1db2:	00 e0       	ldi	r16, 0x00	; 0
    1db4:	10 e0       	ldi	r17, 0x00	; 0
    1db6:	05 c0       	rjmp	.+10     	; 0x1dc2 <prvAllocateTCBAndStack+0x46>
    1db8:	a7 01       	movw	r20, r14
    1dba:	65 ea       	ldi	r22, 0xA5	; 165
    1dbc:	70 e0       	ldi	r23, 0x00	; 0
    1dbe:	0e 94 22 18 	call	0x3044	; 0x3044 <memset>
    1dc2:	c8 01       	movw	r24, r16
    1dc4:	df 91       	pop	r29
    1dc6:	cf 91       	pop	r28
    1dc8:	1f 91       	pop	r17
    1dca:	0f 91       	pop	r16
    1dcc:	ff 90       	pop	r15
    1dce:	ef 90       	pop	r14
    1dd0:	08 95       	ret

00001dd2 <prvInitialiseTCBVariables>:
    1dd2:	1f 93       	push	r17
    1dd4:	cf 93       	push	r28
    1dd6:	df 93       	push	r29
    1dd8:	ec 01       	movw	r28, r24
    1dda:	14 2f       	mov	r17, r20
    1ddc:	48 e0       	ldi	r20, 0x08	; 8
    1dde:	50 e0       	ldi	r21, 0x00	; 0
    1de0:	49 96       	adiw	r24, 0x19	; 25
    1de2:	0e 94 29 18 	call	0x3052	; 0x3052 <strncpy>
    1de6:	18 a2       	std	Y+32, r1	; 0x20
    1de8:	11 11       	cpse	r17, r1
    1dea:	10 e0       	ldi	r17, 0x00	; 0
    1dec:	1e 8b       	std	Y+22, r17	; 0x16
    1dee:	ce 01       	movw	r24, r28
    1df0:	02 96       	adiw	r24, 0x02	; 2
    1df2:	a7 dd       	rcall	.-1202   	; 0x1942 <vListInitialiseItem>
    1df4:	ce 01       	movw	r24, r28
    1df6:	0c 96       	adiw	r24, 0x0c	; 12
    1df8:	a4 dd       	rcall	.-1208   	; 0x1942 <vListInitialiseItem>
    1dfa:	d9 87       	std	Y+9, r29	; 0x09
    1dfc:	c8 87       	std	Y+8, r28	; 0x08
    1dfe:	81 e0       	ldi	r24, 0x01	; 1
    1e00:	90 e0       	ldi	r25, 0x00	; 0
    1e02:	81 1b       	sub	r24, r17
    1e04:	91 09       	sbc	r25, r1
    1e06:	9d 87       	std	Y+13, r25	; 0x0d
    1e08:	8c 87       	std	Y+12, r24	; 0x0c
    1e0a:	db 8b       	std	Y+19, r29	; 0x13
    1e0c:	ca 8b       	std	Y+18, r28	; 0x12
    1e0e:	df 91       	pop	r29
    1e10:	cf 91       	pop	r28
    1e12:	1f 91       	pop	r17
    1e14:	08 95       	ret

00001e16 <prvInitialiseTaskLists>:
    1e16:	cf 93       	push	r28
    1e18:	c0 e0       	ldi	r28, 0x00	; 0
    1e1a:	0f c0       	rjmp	.+30     	; 0x1e3a <prvInitialiseTaskLists+0x24>
    1e1c:	8c 2f       	mov	r24, r28
    1e1e:	90 e0       	ldi	r25, 0x00	; 0
    1e20:	9c 01       	movw	r18, r24
    1e22:	22 0f       	add	r18, r18
    1e24:	33 1f       	adc	r19, r19
    1e26:	22 0f       	add	r18, r18
    1e28:	33 1f       	adc	r19, r19
    1e2a:	22 0f       	add	r18, r18
    1e2c:	33 1f       	adc	r19, r19
    1e2e:	82 0f       	add	r24, r18
    1e30:	93 1f       	adc	r25, r19
    1e32:	8c 5d       	subi	r24, 0xDC	; 220
    1e34:	96 4f       	sbci	r25, 0xF6	; 246
    1e36:	77 dd       	rcall	.-1298   	; 0x1926 <vListInitialise>
    1e38:	cf 5f       	subi	r28, 0xFF	; 255
    1e3a:	cc 23       	and	r28, r28
    1e3c:	79 f3       	breq	.-34     	; 0x1e1c <prvInitialiseTaskLists+0x6>
    1e3e:	8b e1       	ldi	r24, 0x1B	; 27
    1e40:	99 e0       	ldi	r25, 0x09	; 9
    1e42:	71 dd       	rcall	.-1310   	; 0x1926 <vListInitialise>
    1e44:	82 e1       	ldi	r24, 0x12	; 18
    1e46:	99 e0       	ldi	r25, 0x09	; 9
    1e48:	6e dd       	rcall	.-1316   	; 0x1926 <vListInitialise>
    1e4a:	85 e0       	ldi	r24, 0x05	; 5
    1e4c:	99 e0       	ldi	r25, 0x09	; 9
    1e4e:	6b dd       	rcall	.-1322   	; 0x1926 <vListInitialise>
    1e50:	8b e1       	ldi	r24, 0x1B	; 27
    1e52:	99 e0       	ldi	r25, 0x09	; 9
    1e54:	90 93 11 09 	sts	0x0911, r25	; 0x800911 <pxDelayedTaskList+0x1>
    1e58:	80 93 10 09 	sts	0x0910, r24	; 0x800910 <pxDelayedTaskList>
    1e5c:	82 e1       	ldi	r24, 0x12	; 18
    1e5e:	99 e0       	ldi	r25, 0x09	; 9
    1e60:	90 93 0f 09 	sts	0x090F, r25	; 0x80090f <pxOverflowDelayedTaskList+0x1>
    1e64:	80 93 0e 09 	sts	0x090E, r24	; 0x80090e <pxOverflowDelayedTaskList>
    1e68:	cf 91       	pop	r28
    1e6a:	08 95       	ret

00001e6c <prvAddCurrentTaskToDelayedList>:
    1e6c:	cf 93       	push	r28
    1e6e:	df 93       	push	r29
    1e70:	ec 01       	movw	r28, r24
    1e72:	e0 91 2d 09 	lds	r30, 0x092D	; 0x80092d <pxCurrentTCB>
    1e76:	f0 91 2e 09 	lds	r31, 0x092E	; 0x80092e <pxCurrentTCB+0x1>
    1e7a:	93 83       	std	Z+3, r25	; 0x03
    1e7c:	82 83       	std	Z+2, r24	; 0x02
    1e7e:	80 91 02 09 	lds	r24, 0x0902	; 0x800902 <xTickCount>
    1e82:	90 91 03 09 	lds	r25, 0x0903	; 0x800903 <xTickCount+0x1>
    1e86:	c8 17       	cp	r28, r24
    1e88:	d9 07       	cpc	r29, r25
    1e8a:	60 f4       	brcc	.+24     	; 0x1ea4 <prvAddCurrentTaskToDelayedList+0x38>
    1e8c:	60 91 2d 09 	lds	r22, 0x092D	; 0x80092d <pxCurrentTCB>
    1e90:	70 91 2e 09 	lds	r23, 0x092E	; 0x80092e <pxCurrentTCB+0x1>
    1e94:	80 91 0e 09 	lds	r24, 0x090E	; 0x80090e <pxOverflowDelayedTaskList>
    1e98:	90 91 0f 09 	lds	r25, 0x090F	; 0x80090f <pxOverflowDelayedTaskList+0x1>
    1e9c:	6e 5f       	subi	r22, 0xFE	; 254
    1e9e:	7f 4f       	sbci	r23, 0xFF	; 255
    1ea0:	7b dd       	rcall	.-1290   	; 0x1998 <vListInsert>
    1ea2:	16 c0       	rjmp	.+44     	; 0x1ed0 <prvAddCurrentTaskToDelayedList+0x64>
    1ea4:	60 91 2d 09 	lds	r22, 0x092D	; 0x80092d <pxCurrentTCB>
    1ea8:	70 91 2e 09 	lds	r23, 0x092E	; 0x80092e <pxCurrentTCB+0x1>
    1eac:	80 91 10 09 	lds	r24, 0x0910	; 0x800910 <pxDelayedTaskList>
    1eb0:	90 91 11 09 	lds	r25, 0x0911	; 0x800911 <pxDelayedTaskList+0x1>
    1eb4:	6e 5f       	subi	r22, 0xFE	; 254
    1eb6:	7f 4f       	sbci	r23, 0xFF	; 255
    1eb8:	6f dd       	rcall	.-1314   	; 0x1998 <vListInsert>
    1eba:	80 91 0b 02 	lds	r24, 0x020B	; 0x80020b <xNextTaskUnblockTime>
    1ebe:	90 91 0c 02 	lds	r25, 0x020C	; 0x80020c <xNextTaskUnblockTime+0x1>
    1ec2:	c8 17       	cp	r28, r24
    1ec4:	d9 07       	cpc	r29, r25
    1ec6:	20 f4       	brcc	.+8      	; 0x1ed0 <prvAddCurrentTaskToDelayedList+0x64>
    1ec8:	d0 93 0c 02 	sts	0x020C, r29	; 0x80020c <xNextTaskUnblockTime+0x1>
    1ecc:	c0 93 0b 02 	sts	0x020B, r28	; 0x80020b <xNextTaskUnblockTime>
    1ed0:	df 91       	pop	r29
    1ed2:	cf 91       	pop	r28
    1ed4:	08 95       	ret

00001ed6 <xTaskGenericCreate>:
    1ed6:	2f 92       	push	r2
    1ed8:	3f 92       	push	r3
    1eda:	4f 92       	push	r4
    1edc:	5f 92       	push	r5
    1ede:	7f 92       	push	r7
    1ee0:	8f 92       	push	r8
    1ee2:	9f 92       	push	r9
    1ee4:	af 92       	push	r10
    1ee6:	bf 92       	push	r11
    1ee8:	cf 92       	push	r12
    1eea:	df 92       	push	r13
    1eec:	ef 92       	push	r14
    1eee:	ff 92       	push	r15
    1ef0:	0f 93       	push	r16
    1ef2:	1f 93       	push	r17
    1ef4:	cf 93       	push	r28
    1ef6:	df 93       	push	r29
    1ef8:	00 d0       	rcall	.+0      	; 0x1efa <xTaskGenericCreate+0x24>
    1efa:	1f 92       	push	r1
    1efc:	cd b7       	in	r28, 0x3d	; 61
    1efe:	de b7       	in	r29, 0x3e	; 62
    1f00:	9a 83       	std	Y+2, r25	; 0x02
    1f02:	89 83       	std	Y+1, r24	; 0x01
    1f04:	4b 01       	movw	r8, r22
    1f06:	5c 83       	std	Y+4, r21	; 0x04
    1f08:	4b 83       	std	Y+3, r20	; 0x03
    1f0a:	19 01       	movw	r2, r18
    1f0c:	70 2e       	mov	r7, r16
    1f0e:	b6 01       	movw	r22, r12
    1f10:	25 01       	movw	r4, r10
    1f12:	ca 01       	movw	r24, r20
    1f14:	33 df       	rcall	.-410    	; 0x1d7c <prvAllocateTCBAndStack>
    1f16:	5c 01       	movw	r10, r24
    1f18:	00 97       	sbiw	r24, 0x00	; 0
    1f1a:	09 f4       	brne	.+2      	; 0x1f1e <xTaskGenericCreate+0x48>
    1f1c:	6c c0       	rjmp	.+216    	; 0x1ff6 <xTaskGenericCreate+0x120>
    1f1e:	fc 01       	movw	r30, r24
    1f20:	c7 88       	ldd	r12, Z+23	; 0x17
    1f22:	d0 8c       	ldd	r13, Z+24	; 0x18
    1f24:	8b 81       	ldd	r24, Y+3	; 0x03
    1f26:	9c 81       	ldd	r25, Y+4	; 0x04
    1f28:	01 97       	sbiw	r24, 0x01	; 1
    1f2a:	c8 0e       	add	r12, r24
    1f2c:	d9 1e       	adc	r13, r25
    1f2e:	0b 81       	ldd	r16, Y+3	; 0x03
    1f30:	1c 81       	ldd	r17, Y+4	; 0x04
    1f32:	92 01       	movw	r18, r4
    1f34:	47 2d       	mov	r20, r7
    1f36:	b4 01       	movw	r22, r8
    1f38:	c5 01       	movw	r24, r10
    1f3a:	4b df       	rcall	.-362    	; 0x1dd2 <prvInitialiseTCBVariables>
    1f3c:	a1 01       	movw	r20, r2
    1f3e:	69 81       	ldd	r22, Y+1	; 0x01
    1f40:	7a 81       	ldd	r23, Y+2	; 0x02
    1f42:	c6 01       	movw	r24, r12
    1f44:	89 dd       	rcall	.-1262   	; 0x1a58 <pxPortInitialiseStack>
    1f46:	f5 01       	movw	r30, r10
    1f48:	91 83       	std	Z+1, r25	; 0x01
    1f4a:	80 83       	st	Z, r24
    1f4c:	e1 14       	cp	r14, r1
    1f4e:	f1 04       	cpc	r15, r1
    1f50:	19 f0       	breq	.+6      	; 0x1f58 <xTaskGenericCreate+0x82>
    1f52:	f7 01       	movw	r30, r14
    1f54:	b1 82       	std	Z+1, r11	; 0x01
    1f56:	a0 82       	st	Z, r10
    1f58:	0f b6       	in	r0, 0x3f	; 63
    1f5a:	f8 94       	cli
    1f5c:	0f 92       	push	r0
    1f5e:	80 91 04 09 	lds	r24, 0x0904	; 0x800904 <uxCurrentNumberOfTasks>
    1f62:	8f 5f       	subi	r24, 0xFF	; 255
    1f64:	80 93 04 09 	sts	0x0904, r24	; 0x800904 <uxCurrentNumberOfTasks>
    1f68:	80 91 2d 09 	lds	r24, 0x092D	; 0x80092d <pxCurrentTCB>
    1f6c:	90 91 2e 09 	lds	r25, 0x092E	; 0x80092e <pxCurrentTCB+0x1>
    1f70:	89 2b       	or	r24, r25
    1f72:	51 f4       	brne	.+20     	; 0x1f88 <xTaskGenericCreate+0xb2>
    1f74:	b0 92 2e 09 	sts	0x092E, r11	; 0x80092e <pxCurrentTCB+0x1>
    1f78:	a0 92 2d 09 	sts	0x092D, r10	; 0x80092d <pxCurrentTCB>
    1f7c:	80 91 04 09 	lds	r24, 0x0904	; 0x800904 <uxCurrentNumberOfTasks>
    1f80:	81 30       	cpi	r24, 0x01	; 1
    1f82:	89 f4       	brne	.+34     	; 0x1fa6 <xTaskGenericCreate+0xd0>
    1f84:	48 df       	rcall	.-368    	; 0x1e16 <prvInitialiseTaskLists>
    1f86:	0f c0       	rjmp	.+30     	; 0x1fa6 <xTaskGenericCreate+0xd0>
    1f88:	80 91 ff 08 	lds	r24, 0x08FF	; 0x8008ff <xSchedulerRunning>
    1f8c:	81 11       	cpse	r24, r1
    1f8e:	0b c0       	rjmp	.+22     	; 0x1fa6 <xTaskGenericCreate+0xd0>
    1f90:	e0 91 2d 09 	lds	r30, 0x092D	; 0x80092d <pxCurrentTCB>
    1f94:	f0 91 2e 09 	lds	r31, 0x092E	; 0x80092e <pxCurrentTCB+0x1>
    1f98:	86 89       	ldd	r24, Z+22	; 0x16
    1f9a:	78 16       	cp	r7, r24
    1f9c:	20 f0       	brcs	.+8      	; 0x1fa6 <xTaskGenericCreate+0xd0>
    1f9e:	b0 92 2e 09 	sts	0x092E, r11	; 0x80092e <pxCurrentTCB+0x1>
    1fa2:	a0 92 2d 09 	sts	0x092D, r10	; 0x80092d <pxCurrentTCB>
    1fa6:	f5 01       	movw	r30, r10
    1fa8:	86 89       	ldd	r24, Z+22	; 0x16
    1faa:	90 91 01 09 	lds	r25, 0x0901	; 0x800901 <uxTopUsedPriority>
    1fae:	98 17       	cp	r25, r24
    1fb0:	10 f4       	brcc	.+4      	; 0x1fb6 <xTaskGenericCreate+0xe0>
    1fb2:	80 93 01 09 	sts	0x0901, r24	; 0x800901 <uxTopUsedPriority>
    1fb6:	90 91 fa 08 	lds	r25, 0x08FA	; 0x8008fa <uxTCBNumber>
    1fba:	9f 5f       	subi	r25, 0xFF	; 255
    1fbc:	90 93 fa 08 	sts	0x08FA, r25	; 0x8008fa <uxTCBNumber>
    1fc0:	90 91 00 09 	lds	r25, 0x0900	; 0x800900 <uxTopReadyPriority>
    1fc4:	98 17       	cp	r25, r24
    1fc6:	10 f4       	brcc	.+4      	; 0x1fcc <xTaskGenericCreate+0xf6>
    1fc8:	80 93 00 09 	sts	0x0900, r24	; 0x800900 <uxTopReadyPriority>
    1fcc:	90 e0       	ldi	r25, 0x00	; 0
    1fce:	b5 01       	movw	r22, r10
    1fd0:	6e 5f       	subi	r22, 0xFE	; 254
    1fd2:	7f 4f       	sbci	r23, 0xFF	; 255
    1fd4:	9c 01       	movw	r18, r24
    1fd6:	22 0f       	add	r18, r18
    1fd8:	33 1f       	adc	r19, r19
    1fda:	22 0f       	add	r18, r18
    1fdc:	33 1f       	adc	r19, r19
    1fde:	22 0f       	add	r18, r18
    1fe0:	33 1f       	adc	r19, r19
    1fe2:	82 0f       	add	r24, r18
    1fe4:	93 1f       	adc	r25, r19
    1fe6:	8c 5d       	subi	r24, 0xDC	; 220
    1fe8:	96 4f       	sbci	r25, 0xF6	; 246
    1fea:	af dc       	rcall	.-1698   	; 0x194a <vListInsertEnd>
    1fec:	0f 90       	pop	r0
    1fee:	0f be       	out	0x3f, r0	; 63
    1ff0:	f1 e0       	ldi	r31, 0x01	; 1
    1ff2:	f9 83       	std	Y+1, r31	; 0x01
    1ff4:	02 c0       	rjmp	.+4      	; 0x1ffa <xTaskGenericCreate+0x124>
    1ff6:	8f ef       	ldi	r24, 0xFF	; 255
    1ff8:	89 83       	std	Y+1, r24	; 0x01
    1ffa:	e9 81       	ldd	r30, Y+1	; 0x01
    1ffc:	e1 30       	cpi	r30, 0x01	; 1
    1ffe:	61 f4       	brne	.+24     	; 0x2018 <xTaskGenericCreate+0x142>
    2000:	80 91 ff 08 	lds	r24, 0x08FF	; 0x8008ff <xSchedulerRunning>
    2004:	88 23       	and	r24, r24
    2006:	41 f0       	breq	.+16     	; 0x2018 <xTaskGenericCreate+0x142>
    2008:	e0 91 2d 09 	lds	r30, 0x092D	; 0x80092d <pxCurrentTCB>
    200c:	f0 91 2e 09 	lds	r31, 0x092E	; 0x80092e <pxCurrentTCB+0x1>
    2010:	86 89       	ldd	r24, Z+22	; 0x16
    2012:	87 15       	cp	r24, r7
    2014:	08 f4       	brcc	.+2      	; 0x2018 <xTaskGenericCreate+0x142>
    2016:	c4 dd       	rcall	.-1144   	; 0x1ba0 <vPortYield>
    2018:	89 81       	ldd	r24, Y+1	; 0x01
    201a:	0f 90       	pop	r0
    201c:	0f 90       	pop	r0
    201e:	0f 90       	pop	r0
    2020:	0f 90       	pop	r0
    2022:	df 91       	pop	r29
    2024:	cf 91       	pop	r28
    2026:	1f 91       	pop	r17
    2028:	0f 91       	pop	r16
    202a:	ff 90       	pop	r15
    202c:	ef 90       	pop	r14
    202e:	df 90       	pop	r13
    2030:	cf 90       	pop	r12
    2032:	bf 90       	pop	r11
    2034:	af 90       	pop	r10
    2036:	9f 90       	pop	r9
    2038:	8f 90       	pop	r8
    203a:	7f 90       	pop	r7
    203c:	5f 90       	pop	r5
    203e:	4f 90       	pop	r4
    2040:	3f 90       	pop	r3
    2042:	2f 90       	pop	r2
    2044:	08 95       	ret

00002046 <vTaskStartScheduler>:
    2046:	af 92       	push	r10
    2048:	bf 92       	push	r11
    204a:	cf 92       	push	r12
    204c:	df 92       	push	r13
    204e:	ef 92       	push	r14
    2050:	ff 92       	push	r15
    2052:	0f 93       	push	r16
    2054:	a1 2c       	mov	r10, r1
    2056:	b1 2c       	mov	r11, r1
    2058:	c1 2c       	mov	r12, r1
    205a:	d1 2c       	mov	r13, r1
    205c:	e1 2c       	mov	r14, r1
    205e:	f1 2c       	mov	r15, r1
    2060:	00 e0       	ldi	r16, 0x00	; 0
    2062:	20 e0       	ldi	r18, 0x00	; 0
    2064:	30 e0       	ldi	r19, 0x00	; 0
    2066:	45 e5       	ldi	r20, 0x55	; 85
    2068:	50 e0       	ldi	r21, 0x00	; 0
    206a:	68 e8       	ldi	r22, 0x88	; 136
    206c:	72 e0       	ldi	r23, 0x02	; 2
    206e:	88 eb       	ldi	r24, 0xB8	; 184
    2070:	9e e0       	ldi	r25, 0x0E	; 14
    2072:	31 df       	rcall	.-414    	; 0x1ed6 <xTaskGenericCreate>
    2074:	81 30       	cpi	r24, 0x01	; 1
    2076:	41 f4       	brne	.+16     	; 0x2088 <vTaskStartScheduler+0x42>
    2078:	f8 94       	cli
    207a:	80 93 ff 08 	sts	0x08FF, r24	; 0x8008ff <xSchedulerRunning>
    207e:	10 92 03 09 	sts	0x0903, r1	; 0x800903 <xTickCount+0x1>
    2082:	10 92 02 09 	sts	0x0902, r1	; 0x800902 <xTickCount>
    2086:	5a dd       	rcall	.-1356   	; 0x1b3c <xPortStartScheduler>
    2088:	0f 91       	pop	r16
    208a:	ff 90       	pop	r15
    208c:	ef 90       	pop	r14
    208e:	df 90       	pop	r13
    2090:	cf 90       	pop	r12
    2092:	bf 90       	pop	r11
    2094:	af 90       	pop	r10
    2096:	08 95       	ret

00002098 <vTaskSuspendAll>:
    2098:	80 91 fe 08 	lds	r24, 0x08FE	; 0x8008fe <uxSchedulerSuspended>
    209c:	8f 5f       	subi	r24, 0xFF	; 255
    209e:	80 93 fe 08 	sts	0x08FE, r24	; 0x8008fe <uxSchedulerSuspended>
    20a2:	08 95       	ret

000020a4 <vTaskIncrementTick>:
    20a4:	0f 93       	push	r16
    20a6:	1f 93       	push	r17
    20a8:	cf 93       	push	r28
    20aa:	df 93       	push	r29
    20ac:	80 91 fe 08 	lds	r24, 0x08FE	; 0x8008fe <uxSchedulerSuspended>
    20b0:	81 11       	cpse	r24, r1
    20b2:	95 c0       	rjmp	.+298    	; 0x21de <vTaskIncrementTick+0x13a>
    20b4:	80 91 02 09 	lds	r24, 0x0902	; 0x800902 <xTickCount>
    20b8:	90 91 03 09 	lds	r25, 0x0903	; 0x800903 <xTickCount+0x1>
    20bc:	01 96       	adiw	r24, 0x01	; 1
    20be:	90 93 03 09 	sts	0x0903, r25	; 0x800903 <xTickCount+0x1>
    20c2:	80 93 02 09 	sts	0x0902, r24	; 0x800902 <xTickCount>
    20c6:	80 91 02 09 	lds	r24, 0x0902	; 0x800902 <xTickCount>
    20ca:	90 91 03 09 	lds	r25, 0x0903	; 0x800903 <xTickCount+0x1>
    20ce:	89 2b       	or	r24, r25
    20d0:	99 f5       	brne	.+102    	; 0x2138 <vTaskIncrementTick+0x94>
    20d2:	80 91 10 09 	lds	r24, 0x0910	; 0x800910 <pxDelayedTaskList>
    20d6:	90 91 11 09 	lds	r25, 0x0911	; 0x800911 <pxDelayedTaskList+0x1>
    20da:	20 91 0e 09 	lds	r18, 0x090E	; 0x80090e <pxOverflowDelayedTaskList>
    20de:	30 91 0f 09 	lds	r19, 0x090F	; 0x80090f <pxOverflowDelayedTaskList+0x1>
    20e2:	30 93 11 09 	sts	0x0911, r19	; 0x800911 <pxDelayedTaskList+0x1>
    20e6:	20 93 10 09 	sts	0x0910, r18	; 0x800910 <pxDelayedTaskList>
    20ea:	90 93 0f 09 	sts	0x090F, r25	; 0x80090f <pxOverflowDelayedTaskList+0x1>
    20ee:	80 93 0e 09 	sts	0x090E, r24	; 0x80090e <pxOverflowDelayedTaskList>
    20f2:	80 91 fb 08 	lds	r24, 0x08FB	; 0x8008fb <xNumOfOverflows>
    20f6:	8f 5f       	subi	r24, 0xFF	; 255
    20f8:	80 93 fb 08 	sts	0x08FB, r24	; 0x8008fb <xNumOfOverflows>
    20fc:	e0 91 10 09 	lds	r30, 0x0910	; 0x800910 <pxDelayedTaskList>
    2100:	f0 91 11 09 	lds	r31, 0x0911	; 0x800911 <pxDelayedTaskList+0x1>
    2104:	80 81       	ld	r24, Z
    2106:	81 11       	cpse	r24, r1
    2108:	07 c0       	rjmp	.+14     	; 0x2118 <vTaskIncrementTick+0x74>
    210a:	8f ef       	ldi	r24, 0xFF	; 255
    210c:	9f ef       	ldi	r25, 0xFF	; 255
    210e:	90 93 0c 02 	sts	0x020C, r25	; 0x80020c <xNextTaskUnblockTime+0x1>
    2112:	80 93 0b 02 	sts	0x020B, r24	; 0x80020b <xNextTaskUnblockTime>
    2116:	10 c0       	rjmp	.+32     	; 0x2138 <vTaskIncrementTick+0x94>
    2118:	e0 91 10 09 	lds	r30, 0x0910	; 0x800910 <pxDelayedTaskList>
    211c:	f0 91 11 09 	lds	r31, 0x0911	; 0x800911 <pxDelayedTaskList+0x1>
    2120:	05 80       	ldd	r0, Z+5	; 0x05
    2122:	f6 81       	ldd	r31, Z+6	; 0x06
    2124:	e0 2d       	mov	r30, r0
    2126:	06 80       	ldd	r0, Z+6	; 0x06
    2128:	f7 81       	ldd	r31, Z+7	; 0x07
    212a:	e0 2d       	mov	r30, r0
    212c:	82 81       	ldd	r24, Z+2	; 0x02
    212e:	93 81       	ldd	r25, Z+3	; 0x03
    2130:	90 93 0c 02 	sts	0x020C, r25	; 0x80020c <xNextTaskUnblockTime+0x1>
    2134:	80 93 0b 02 	sts	0x020B, r24	; 0x80020b <xNextTaskUnblockTime>
    2138:	20 91 02 09 	lds	r18, 0x0902	; 0x800902 <xTickCount>
    213c:	30 91 03 09 	lds	r19, 0x0903	; 0x800903 <xTickCount+0x1>
    2140:	80 91 0b 02 	lds	r24, 0x020B	; 0x80020b <xNextTaskUnblockTime>
    2144:	90 91 0c 02 	lds	r25, 0x020C	; 0x80020c <xNextTaskUnblockTime+0x1>
    2148:	28 17       	cp	r18, r24
    214a:	39 07       	cpc	r19, r25
    214c:	08 f4       	brcc	.+2      	; 0x2150 <vTaskIncrementTick+0xac>
    214e:	4c c0       	rjmp	.+152    	; 0x21e8 <vTaskIncrementTick+0x144>
    2150:	e0 91 10 09 	lds	r30, 0x0910	; 0x800910 <pxDelayedTaskList>
    2154:	f0 91 11 09 	lds	r31, 0x0911	; 0x800911 <pxDelayedTaskList+0x1>
    2158:	80 81       	ld	r24, Z
    215a:	81 11       	cpse	r24, r1
    215c:	07 c0       	rjmp	.+14     	; 0x216c <vTaskIncrementTick+0xc8>
    215e:	8f ef       	ldi	r24, 0xFF	; 255
    2160:	9f ef       	ldi	r25, 0xFF	; 255
    2162:	90 93 0c 02 	sts	0x020C, r25	; 0x80020c <xNextTaskUnblockTime+0x1>
    2166:	80 93 0b 02 	sts	0x020B, r24	; 0x80020b <xNextTaskUnblockTime>
    216a:	3e c0       	rjmp	.+124    	; 0x21e8 <vTaskIncrementTick+0x144>
    216c:	e0 91 10 09 	lds	r30, 0x0910	; 0x800910 <pxDelayedTaskList>
    2170:	f0 91 11 09 	lds	r31, 0x0911	; 0x800911 <pxDelayedTaskList+0x1>
    2174:	05 80       	ldd	r0, Z+5	; 0x05
    2176:	f6 81       	ldd	r31, Z+6	; 0x06
    2178:	e0 2d       	mov	r30, r0
    217a:	c6 81       	ldd	r28, Z+6	; 0x06
    217c:	d7 81       	ldd	r29, Z+7	; 0x07
    217e:	8a 81       	ldd	r24, Y+2	; 0x02
    2180:	9b 81       	ldd	r25, Y+3	; 0x03
    2182:	20 91 02 09 	lds	r18, 0x0902	; 0x800902 <xTickCount>
    2186:	30 91 03 09 	lds	r19, 0x0903	; 0x800903 <xTickCount+0x1>
    218a:	28 17       	cp	r18, r24
    218c:	39 07       	cpc	r19, r25
    218e:	28 f4       	brcc	.+10     	; 0x219a <vTaskIncrementTick+0xf6>
    2190:	90 93 0c 02 	sts	0x020C, r25	; 0x80020c <xNextTaskUnblockTime+0x1>
    2194:	80 93 0b 02 	sts	0x020B, r24	; 0x80020b <xNextTaskUnblockTime>
    2198:	27 c0       	rjmp	.+78     	; 0x21e8 <vTaskIncrementTick+0x144>
    219a:	8e 01       	movw	r16, r28
    219c:	0e 5f       	subi	r16, 0xFE	; 254
    219e:	1f 4f       	sbci	r17, 0xFF	; 255
    21a0:	c8 01       	movw	r24, r16
    21a2:	2b dc       	rcall	.-1962   	; 0x19fa <vListRemove>
    21a4:	8c 89       	ldd	r24, Y+20	; 0x14
    21a6:	9d 89       	ldd	r25, Y+21	; 0x15
    21a8:	89 2b       	or	r24, r25
    21aa:	19 f0       	breq	.+6      	; 0x21b2 <vTaskIncrementTick+0x10e>
    21ac:	ce 01       	movw	r24, r28
    21ae:	0c 96       	adiw	r24, 0x0c	; 12
    21b0:	24 dc       	rcall	.-1976   	; 0x19fa <vListRemove>
    21b2:	8e 89       	ldd	r24, Y+22	; 0x16
    21b4:	90 91 00 09 	lds	r25, 0x0900	; 0x800900 <uxTopReadyPriority>
    21b8:	98 17       	cp	r25, r24
    21ba:	10 f4       	brcc	.+4      	; 0x21c0 <vTaskIncrementTick+0x11c>
    21bc:	80 93 00 09 	sts	0x0900, r24	; 0x800900 <uxTopReadyPriority>
    21c0:	90 e0       	ldi	r25, 0x00	; 0
    21c2:	9c 01       	movw	r18, r24
    21c4:	22 0f       	add	r18, r18
    21c6:	33 1f       	adc	r19, r19
    21c8:	22 0f       	add	r18, r18
    21ca:	33 1f       	adc	r19, r19
    21cc:	22 0f       	add	r18, r18
    21ce:	33 1f       	adc	r19, r19
    21d0:	82 0f       	add	r24, r18
    21d2:	93 1f       	adc	r25, r19
    21d4:	b8 01       	movw	r22, r16
    21d6:	8c 5d       	subi	r24, 0xDC	; 220
    21d8:	96 4f       	sbci	r25, 0xF6	; 246
    21da:	b7 db       	rcall	.-2194   	; 0x194a <vListInsertEnd>
    21dc:	b9 cf       	rjmp	.-142    	; 0x2150 <vTaskIncrementTick+0xac>
    21de:	80 91 fd 08 	lds	r24, 0x08FD	; 0x8008fd <uxMissedTicks>
    21e2:	8f 5f       	subi	r24, 0xFF	; 255
    21e4:	80 93 fd 08 	sts	0x08FD, r24	; 0x8008fd <uxMissedTicks>
    21e8:	df 91       	pop	r29
    21ea:	cf 91       	pop	r28
    21ec:	1f 91       	pop	r17
    21ee:	0f 91       	pop	r16
    21f0:	08 95       	ret

000021f2 <xTaskResumeAll>:
    21f2:	ff 92       	push	r15
    21f4:	0f 93       	push	r16
    21f6:	1f 93       	push	r17
    21f8:	cf 93       	push	r28
    21fa:	df 93       	push	r29
    21fc:	0f b6       	in	r0, 0x3f	; 63
    21fe:	f8 94       	cli
    2200:	0f 92       	push	r0
    2202:	80 91 fe 08 	lds	r24, 0x08FE	; 0x8008fe <uxSchedulerSuspended>
    2206:	81 50       	subi	r24, 0x01	; 1
    2208:	80 93 fe 08 	sts	0x08FE, r24	; 0x8008fe <uxSchedulerSuspended>
    220c:	80 91 fe 08 	lds	r24, 0x08FE	; 0x8008fe <uxSchedulerSuspended>
    2210:	81 11       	cpse	r24, r1
    2212:	55 c0       	rjmp	.+170    	; 0x22be <__stack+0xbf>
    2214:	80 91 04 09 	lds	r24, 0x0904	; 0x800904 <uxCurrentNumberOfTasks>
    2218:	81 11       	cpse	r24, r1
    221a:	2f c0       	rjmp	.+94     	; 0x227a <__stack+0x7b>
    221c:	53 c0       	rjmp	.+166    	; 0x22c4 <__stack+0xc5>
    221e:	e0 91 0a 09 	lds	r30, 0x090A	; 0x80090a <xPendingReadyList+0x5>
    2222:	f0 91 0b 09 	lds	r31, 0x090B	; 0x80090b <xPendingReadyList+0x6>
    2226:	c6 81       	ldd	r28, Z+6	; 0x06
    2228:	d7 81       	ldd	r29, Z+7	; 0x07
    222a:	ce 01       	movw	r24, r28
    222c:	0c 96       	adiw	r24, 0x0c	; 12
    222e:	e5 db       	rcall	.-2102   	; 0x19fa <vListRemove>
    2230:	8e 01       	movw	r16, r28
    2232:	0e 5f       	subi	r16, 0xFE	; 254
    2234:	1f 4f       	sbci	r17, 0xFF	; 255
    2236:	c8 01       	movw	r24, r16
    2238:	e0 db       	rcall	.-2112   	; 0x19fa <vListRemove>
    223a:	8e 89       	ldd	r24, Y+22	; 0x16
    223c:	90 91 00 09 	lds	r25, 0x0900	; 0x800900 <uxTopReadyPriority>
    2240:	98 17       	cp	r25, r24
    2242:	10 f4       	brcc	.+4      	; 0x2248 <__stack+0x49>
    2244:	80 93 00 09 	sts	0x0900, r24	; 0x800900 <uxTopReadyPriority>
    2248:	90 e0       	ldi	r25, 0x00	; 0
    224a:	9c 01       	movw	r18, r24
    224c:	22 0f       	add	r18, r18
    224e:	33 1f       	adc	r19, r19
    2250:	22 0f       	add	r18, r18
    2252:	33 1f       	adc	r19, r19
    2254:	22 0f       	add	r18, r18
    2256:	33 1f       	adc	r19, r19
    2258:	82 0f       	add	r24, r18
    225a:	93 1f       	adc	r25, r19
    225c:	b8 01       	movw	r22, r16
    225e:	8c 5d       	subi	r24, 0xDC	; 220
    2260:	96 4f       	sbci	r25, 0xF6	; 246
    2262:	73 db       	rcall	.-2330   	; 0x194a <vListInsertEnd>
    2264:	9e 89       	ldd	r25, Y+22	; 0x16
    2266:	e0 91 2d 09 	lds	r30, 0x092D	; 0x80092d <pxCurrentTCB>
    226a:	f0 91 2e 09 	lds	r31, 0x092E	; 0x80092e <pxCurrentTCB+0x1>
    226e:	86 89       	ldd	r24, Z+22	; 0x16
    2270:	98 17       	cp	r25, r24
    2272:	20 f0       	brcs	.+8      	; 0x227c <__stack+0x7d>
    2274:	ff 24       	eor	r15, r15
    2276:	f3 94       	inc	r15
    2278:	01 c0       	rjmp	.+2      	; 0x227c <__stack+0x7d>
    227a:	f1 2c       	mov	r15, r1
    227c:	80 91 05 09 	lds	r24, 0x0905	; 0x800905 <xPendingReadyList>
    2280:	81 11       	cpse	r24, r1
    2282:	cd cf       	rjmp	.-102    	; 0x221e <__stack+0x1f>
    2284:	80 91 fd 08 	lds	r24, 0x08FD	; 0x8008fd <uxMissedTicks>
    2288:	81 11       	cpse	r24, r1
    228a:	07 c0       	rjmp	.+14     	; 0x229a <__stack+0x9b>
    228c:	0c c0       	rjmp	.+24     	; 0x22a6 <__stack+0xa7>
    228e:	0a df       	rcall	.-492    	; 0x20a4 <vTaskIncrementTick>
    2290:	80 91 fd 08 	lds	r24, 0x08FD	; 0x8008fd <uxMissedTicks>
    2294:	81 50       	subi	r24, 0x01	; 1
    2296:	80 93 fd 08 	sts	0x08FD, r24	; 0x8008fd <uxMissedTicks>
    229a:	80 91 fd 08 	lds	r24, 0x08FD	; 0x8008fd <uxMissedTicks>
    229e:	81 11       	cpse	r24, r1
    22a0:	f6 cf       	rjmp	.-20     	; 0x228e <__stack+0x8f>
    22a2:	ff 24       	eor	r15, r15
    22a4:	f3 94       	inc	r15
    22a6:	81 e0       	ldi	r24, 0x01	; 1
    22a8:	f8 16       	cp	r15, r24
    22aa:	21 f0       	breq	.+8      	; 0x22b4 <__stack+0xb5>
    22ac:	80 91 fc 08 	lds	r24, 0x08FC	; 0x8008fc <xMissedYield>
    22b0:	81 30       	cpi	r24, 0x01	; 1
    22b2:	39 f4       	brne	.+14     	; 0x22c2 <__stack+0xc3>
    22b4:	10 92 fc 08 	sts	0x08FC, r1	; 0x8008fc <xMissedYield>
    22b8:	73 dc       	rcall	.-1818   	; 0x1ba0 <vPortYield>
    22ba:	81 e0       	ldi	r24, 0x01	; 1
    22bc:	03 c0       	rjmp	.+6      	; 0x22c4 <__stack+0xc5>
    22be:	80 e0       	ldi	r24, 0x00	; 0
    22c0:	01 c0       	rjmp	.+2      	; 0x22c4 <__stack+0xc5>
    22c2:	80 e0       	ldi	r24, 0x00	; 0
    22c4:	0f 90       	pop	r0
    22c6:	0f be       	out	0x3f, r0	; 63
    22c8:	df 91       	pop	r29
    22ca:	cf 91       	pop	r28
    22cc:	1f 91       	pop	r17
    22ce:	0f 91       	pop	r16
    22d0:	ff 90       	pop	r15
    22d2:	08 95       	ret

000022d4 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    22d4:	cf 93       	push	r28
    22d6:	df 93       	push	r29
    22d8:	ec 01       	movw	r28, r24
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    22da:	89 2b       	or	r24, r25
    22dc:	89 f0       	breq	.+34     	; 0x2300 <vTaskDelay+0x2c>
		{
			vTaskSuspendAll();
    22de:	dc de       	rcall	.-584    	; 0x2098 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    22e0:	80 91 02 09 	lds	r24, 0x0902	; 0x800902 <xTickCount>
    22e4:	90 91 03 09 	lds	r25, 0x0903	; 0x800903 <xTickCount+0x1>
    22e8:	c8 0f       	add	r28, r24
    22ea:	d9 1f       	adc	r29, r25

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    22ec:	80 91 2d 09 	lds	r24, 0x092D	; 0x80092d <pxCurrentTCB>
    22f0:	90 91 2e 09 	lds	r25, 0x092E	; 0x80092e <pxCurrentTCB+0x1>
    22f4:	02 96       	adiw	r24, 0x02	; 2
    22f6:	81 db       	rcall	.-2302   	; 0x19fa <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    22f8:	ce 01       	movw	r24, r28
    22fa:	b8 dd       	rcall	.-1168   	; 0x1e6c <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    22fc:	7a df       	rcall	.-268    	; 0x21f2 <xTaskResumeAll>
    22fe:	01 c0       	rjmp	.+2      	; 0x2302 <vTaskDelay+0x2e>
#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    2300:	80 e0       	ldi	r24, 0x00	; 0
			xAlreadyYielded = xTaskResumeAll();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    2302:	81 11       	cpse	r24, r1
    2304:	01 c0       	rjmp	.+2      	; 0x2308 <vTaskDelay+0x34>
		{
			portYIELD_WITHIN_API();
    2306:	4c dc       	rcall	.-1896   	; 0x1ba0 <vPortYield>
    2308:	df 91       	pop	r29
		}
	}
    230a:	cf 91       	pop	r28
    230c:	08 95       	ret

0000230e <vTaskSwitchContext>:
    230e:	80 91 fe 08 	lds	r24, 0x08FE	; 0x8008fe <uxSchedulerSuspended>
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    2312:	88 23       	and	r24, r24
    2314:	49 f0       	breq	.+18     	; 0x2328 <vTaskSwitchContext+0x1a>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    2316:	81 e0       	ldi	r24, 0x01	; 1
    2318:	80 93 fc 08 	sts	0x08FC, r24	; 0x8008fc <xMissedYield>
    231c:	08 95       	ret
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    231e:	80 91 00 09 	lds	r24, 0x0900	; 0x800900 <uxTopReadyPriority>
    2322:	81 50       	subi	r24, 0x01	; 1
    2324:	80 93 00 09 	sts	0x0900, r24	; 0x800900 <uxTopReadyPriority>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    2328:	80 91 00 09 	lds	r24, 0x0900	; 0x800900 <uxTopReadyPriority>
    232c:	90 e0       	ldi	r25, 0x00	; 0
    232e:	fc 01       	movw	r30, r24
    2330:	ee 0f       	add	r30, r30
    2332:	ff 1f       	adc	r31, r31
    2334:	ee 0f       	add	r30, r30
    2336:	ff 1f       	adc	r31, r31
    2338:	ee 0f       	add	r30, r30
    233a:	ff 1f       	adc	r31, r31
    233c:	8e 0f       	add	r24, r30
    233e:	9f 1f       	adc	r25, r31
    2340:	fc 01       	movw	r30, r24
    2342:	ec 5d       	subi	r30, 0xDC	; 220
    2344:	f6 4f       	sbci	r31, 0xF6	; 246
    2346:	80 81       	ld	r24, Z
    2348:	88 23       	and	r24, r24
    234a:	49 f3       	breq	.-46     	; 0x231e <vTaskSwitchContext+0x10>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    234c:	80 91 00 09 	lds	r24, 0x0900	; 0x800900 <uxTopReadyPriority>
    2350:	90 e0       	ldi	r25, 0x00	; 0
    2352:	9c 01       	movw	r18, r24
    2354:	22 0f       	add	r18, r18
    2356:	33 1f       	adc	r19, r19
    2358:	22 0f       	add	r18, r18
    235a:	33 1f       	adc	r19, r19
    235c:	22 0f       	add	r18, r18
    235e:	33 1f       	adc	r19, r19
    2360:	28 0f       	add	r18, r24
    2362:	39 1f       	adc	r19, r25
    2364:	d9 01       	movw	r26, r18
    2366:	ac 5d       	subi	r26, 0xDC	; 220
    2368:	b6 4f       	sbci	r27, 0xF6	; 246
    236a:	11 96       	adiw	r26, 0x01	; 1
    236c:	ed 91       	ld	r30, X+
    236e:	fc 91       	ld	r31, X
    2370:	12 97       	sbiw	r26, 0x02	; 2
    2372:	02 80       	ldd	r0, Z+2	; 0x02
    2374:	f3 81       	ldd	r31, Z+3	; 0x03
    2376:	e0 2d       	mov	r30, r0
    2378:	12 96       	adiw	r26, 0x02	; 2
    237a:	fc 93       	st	X, r31
    237c:	ee 93       	st	-X, r30
    237e:	11 97       	sbiw	r26, 0x01	; 1
    2380:	29 5d       	subi	r18, 0xD9	; 217
    2382:	36 4f       	sbci	r19, 0xF6	; 246
    2384:	e2 17       	cp	r30, r18
    2386:	f3 07       	cpc	r31, r19
    2388:	29 f4       	brne	.+10     	; 0x2394 <vTaskSwitchContext+0x86>
    238a:	22 81       	ldd	r18, Z+2	; 0x02
    238c:	33 81       	ldd	r19, Z+3	; 0x03
    238e:	fd 01       	movw	r30, r26
    2390:	32 83       	std	Z+2, r19	; 0x02
    2392:	21 83       	std	Z+1, r18	; 0x01
    2394:	fc 01       	movw	r30, r24
    2396:	ee 0f       	add	r30, r30
    2398:	ff 1f       	adc	r31, r31
    239a:	ee 0f       	add	r30, r30
    239c:	ff 1f       	adc	r31, r31
    239e:	ee 0f       	add	r30, r30
    23a0:	ff 1f       	adc	r31, r31
    23a2:	8e 0f       	add	r24, r30
    23a4:	9f 1f       	adc	r25, r31
    23a6:	fc 01       	movw	r30, r24
    23a8:	ec 5d       	subi	r30, 0xDC	; 220
    23aa:	f6 4f       	sbci	r31, 0xF6	; 246
    23ac:	01 80       	ldd	r0, Z+1	; 0x01
    23ae:	f2 81       	ldd	r31, Z+2	; 0x02
    23b0:	e0 2d       	mov	r30, r0
    23b2:	86 81       	ldd	r24, Z+6	; 0x06
    23b4:	97 81       	ldd	r25, Z+7	; 0x07
    23b6:	90 93 2e 09 	sts	0x092E, r25	; 0x80092e <pxCurrentTCB+0x1>
    23ba:	80 93 2d 09 	sts	0x092D, r24	; 0x80092d <pxCurrentTCB>
    23be:	08 95       	ret

000023c0 <_Z12WriteCommandj>:
}

void DisplayOff()
{
	// Send command DisplayOff which is 0x28 in HEX.
	WriteCommand(0x28);
    23c0:	2b b1       	in	r18, 0x0b	; 11
    23c2:	2f 77       	andi	r18, 0x7F	; 127
    23c4:	2b b9       	out	0x0b, r18	; 11
    23c6:	24 b3       	in	r18, 0x14	; 20
    23c8:	2d 7f       	andi	r18, 0xFD	; 253
    23ca:	24 bb       	out	0x14, r18	; 20
    23cc:	00 00       	nop
    23ce:	92 b9       	out	0x02, r25	; 2
    23d0:	88 b9       	out	0x08, r24	; 8
    23d2:	84 b3       	in	r24, 0x14	; 20
    23d4:	8b 7f       	andi	r24, 0xFB	; 251
    23d6:	84 bb       	out	0x14, r24	; 20
    23d8:	00 00       	nop
    23da:	84 b3       	in	r24, 0x14	; 20
    23dc:	84 60       	ori	r24, 0x04	; 4
    23de:	84 bb       	out	0x14, r24	; 20
    23e0:	00 00       	nop
    23e2:	84 b3       	in	r24, 0x14	; 20
    23e4:	82 60       	ori	r24, 0x02	; 2
    23e6:	84 bb       	out	0x14, r24	; 20
    23e8:	08 95       	ret

000023ea <_Z9WriteDataj>:
    23ea:	2b b1       	in	r18, 0x0b	; 11
    23ec:	20 68       	ori	r18, 0x80	; 128
    23ee:	2b b9       	out	0x0b, r18	; 11
    23f0:	24 b3       	in	r18, 0x14	; 20
    23f2:	2d 7f       	andi	r18, 0xFD	; 253
    23f4:	24 bb       	out	0x14, r18	; 20
    23f6:	00 00       	nop
    23f8:	92 b9       	out	0x02, r25	; 2
    23fa:	88 b9       	out	0x08, r24	; 8
    23fc:	84 b3       	in	r24, 0x14	; 20
    23fe:	8b 7f       	andi	r24, 0xFB	; 251
    2400:	84 bb       	out	0x14, r24	; 20
    2402:	00 00       	nop
    2404:	84 b3       	in	r24, 0x14	; 20
    2406:	84 60       	ori	r24, 0x04	; 4
    2408:	84 bb       	out	0x14, r24	; 20
    240a:	00 00       	nop
    240c:	84 b3       	in	r24, 0x14	; 20
    240e:	82 60       	ori	r24, 0x02	; 2
    2410:	84 bb       	out	0x14, r24	; 20
    2412:	08 95       	ret

00002414 <_Z9DisplayOnv>:
}

void DisplayOn()
{
	// Send command DisplayOn which is 0x29 in HEX.
	WriteCommand(0x29);
    2414:	89 e2       	ldi	r24, 0x29	; 41
    2416:	90 e0       	ldi	r25, 0x00	; 0
    2418:	d3 cf       	rjmp	.-90     	; 0x23c0 <_Z12WriteCommandj>
    241a:	08 95       	ret

0000241c <_Z8SleepOutv>:
}

void SleepOut()
{
	// Send command SleepOut which is 0x11 in HEX. 
	WriteCommand(0x11);
    241c:	81 e1       	ldi	r24, 0x11	; 17
    241e:	90 e0       	ldi	r25, 0x00	; 0
    2420:	cf cf       	rjmp	.-98     	; 0x23c0 <_Z12WriteCommandj>
    2422:	08 95       	ret

00002424 <_Z19MemoryAccessControlh>:
}

void MemoryAccessControl(unsigned char parameter)
{
    2424:	cf 93       	push	r28
    2426:	c8 2f       	mov	r28, r24
	WriteCommand(0x36);
    2428:	86 e3       	ldi	r24, 0x36	; 54
    242a:	90 e0       	ldi	r25, 0x00	; 0
    242c:	c9 df       	rcall	.-110    	; 0x23c0 <_Z12WriteCommandj>
	WriteData(parameter);
    242e:	8c 2f       	mov	r24, r28
    2430:	90 e0       	ldi	r25, 0x00	; 0
    2432:	db df       	rcall	.-74     	; 0x23ea <_Z9WriteDataj>
}
    2434:	cf 91       	pop	r28
    2436:	08 95       	ret

00002438 <_Z20InterfacePixelFormath>:

void InterfacePixelFormat(unsigned char parameter)
{
    2438:	cf 93       	push	r28
    243a:	c8 2f       	mov	r28, r24
	WriteCommand(0x3A);
    243c:	8a e3       	ldi	r24, 0x3A	; 58
    243e:	90 e0       	ldi	r25, 0x00	; 0
    2440:	bf df       	rcall	.-130    	; 0x23c0 <_Z12WriteCommandj>
	WriteData(parameter);
    2442:	8c 2f       	mov	r24, r28
    2444:	90 e0       	ldi	r25, 0x00	; 0
    2446:	d1 df       	rcall	.-94     	; 0x23ea <_Z9WriteDataj>
}
    2448:	cf 91       	pop	r28
    244a:	08 95       	ret

0000244c <_Z11DisplayInitv>:

// Initializes (resets) the display
void DisplayInit()
{
	// Control pins are outputs
	DDRG |= 0b00000111;
    244c:	83 b3       	in	r24, 0x13	; 19
    244e:	87 60       	ori	r24, 0x07	; 7
    2450:	83 bb       	out	0x13, r24	; 19
	DDRD |= 0b10000000;
    2452:	8a b1       	in	r24, 0x0a	; 10
    2454:	80 68       	ori	r24, 0x80	; 128
    2456:	8a b9       	out	0x0a, r24	; 10
	
	// Data pins are outputs
	DDRA = 0xFF;
    2458:	8f ef       	ldi	r24, 0xFF	; 255
    245a:	81 b9       	out	0x01, r24	; 1
	DDRC = 0xFF;
    245c:	87 b9       	out	0x07, r24	; 7
	
	// All control pins high;
	PORTG |= 0b00000111;
    245e:	84 b3       	in	r24, 0x14	; 20
    2460:	87 60       	ori	r24, 0x07	; 7
    2462:	84 bb       	out	0x14, r24	; 20
	PORTD |= 0b10000000;
    2464:	8b b1       	in	r24, 0x0b	; 11
    2466:	80 68       	ori	r24, 0x80	; 128
    2468:	8b b9       	out	0x0b, r24	; 11
	
	// Pull reset pin - Wait min 10 uS
	RST_PORT &= ~(1 << RST_BIT);
    246a:	84 b3       	in	r24, 0x14	; 20
    246c:	8e 7f       	andi	r24, 0xFE	; 254
    246e:	84 bb       	out	0x14, r24	; 20
	vTaskDelay( 500 / portTICK_RATE_MS );
    2470:	84 ef       	ldi	r24, 0xF4	; 244
    2472:	91 e0       	ldi	r25, 0x01	; 1
    2474:	2f df       	rcall	.-418    	; 0x22d4 <vTaskDelay>
	RST_PORT |= (1 << RST_BIT);
    2476:	84 b3       	in	r24, 0x14	; 20
    2478:	81 60       	ori	r24, 0x01	; 1
    247a:	84 bb       	out	0x14, r24	; 20
	
	// Wait for display to be rdy
	vTaskDelay( 500 / portTICK_RATE_MS );
    247c:	84 ef       	ldi	r24, 0xF4	; 244
    247e:	91 e0       	ldi	r25, 0x01	; 1
    2480:	29 df       	rcall	.-430    	; 0x22d4 <vTaskDelay>
	
	// Set pixel interface and memoryaccesscontrol
	InterfacePixelFormat(0b00000101);
    2482:	85 e0       	ldi	r24, 0x05	; 5
    2484:	d9 df       	rcall	.-78     	; 0x2438 <_Z20InterfacePixelFormath>
	MemoryAccessControl(0b00001000);
    2486:	88 e0       	ldi	r24, 0x08	; 8
    2488:	cd df       	rcall	.-102    	; 0x2424 <_Z19MemoryAccessControlh>
	
	// Call sleepout and display on.
	SleepOut();
    248a:	c8 df       	rcall	.-112    	; 0x241c <_Z8SleepOutv>
    248c:	c3 cf       	rjmp	.-122    	; 0x2414 <_Z9DisplayOnv>
	DisplayOn();
    248e:	08 95       	ret

00002490 <_Z11MemoryWritev>:
    2490:	8c e2       	ldi	r24, 0x2C	; 44
    2492:	90 e0       	ldi	r25, 0x00	; 0
	WriteData(parameter);
}

void MemoryWrite()
{
	WriteCommand(0x2C);
    2494:	95 cf       	rjmp	.-214    	; 0x23c0 <_Z12WriteCommandj>
    2496:	08 95       	ret

00002498 <_Z10WritePixelhhh>:
}

// Red 0-31, Green 0-63, Blue 0-31
void WritePixel(unsigned char Red, unsigned char Green, unsigned char Blue)
{
	uint16_t toSend = (Red << 11U) | (Green << 5U) | (Blue);
    2498:	90 e0       	ldi	r25, 0x00	; 0
    249a:	98 2f       	mov	r25, r24
    249c:	88 27       	eor	r24, r24
    249e:	99 0f       	add	r25, r25
    24a0:	99 0f       	add	r25, r25
    24a2:	99 0f       	add	r25, r25
    24a4:	20 e2       	ldi	r18, 0x20	; 32
    24a6:	62 9f       	mul	r22, r18
    24a8:	b0 01       	movw	r22, r0
    24aa:	11 24       	eor	r1, r1
    24ac:	86 2b       	or	r24, r22
    24ae:	97 2b       	or	r25, r23
	WriteData(toSend);
    24b0:	84 2b       	or	r24, r20
    24b2:	9b cf       	rjmp	.-202    	; 0x23ea <_Z9WriteDataj>
    24b4:	08 95       	ret

000024b6 <_Z16SetColumnAddressjj>:
}

// Set Column Address (0-239), Start > End
void SetColumnAddress(unsigned int Start, unsigned int End)
{
    24b6:	0f 93       	push	r16
    24b8:	1f 93       	push	r17
    24ba:	cf 93       	push	r28
    24bc:	df 93       	push	r29
	if (Start < End)
    24be:	86 17       	cp	r24, r22
    24c0:	97 07       	cpc	r25, r23
    24c2:	78 f4       	brcc	.+30     	; 0x24e2 <_Z16SetColumnAddressjj+0x2c>
    24c4:	eb 01       	movw	r28, r22
    24c6:	8c 01       	movw	r16, r24
	{
		WriteCommand(0x2A);
    24c8:	8a e2       	ldi	r24, 0x2A	; 42
    24ca:	90 e0       	ldi	r25, 0x00	; 0
    24cc:	79 df       	rcall	.-270    	; 0x23c0 <_Z12WriteCommandj>
		WriteData(Start >> 8U);
    24ce:	81 2f       	mov	r24, r17
    24d0:	90 e0       	ldi	r25, 0x00	; 0
    24d2:	8b df       	rcall	.-234    	; 0x23ea <_Z9WriteDataj>
		WriteData(Start);
    24d4:	c8 01       	movw	r24, r16
    24d6:	89 df       	rcall	.-238    	; 0x23ea <_Z9WriteDataj>
		WriteData(End >> 8U);
    24d8:	8d 2f       	mov	r24, r29
    24da:	90 e0       	ldi	r25, 0x00	; 0
    24dc:	86 df       	rcall	.-244    	; 0x23ea <_Z9WriteDataj>
		WriteData(End);
    24de:	ce 01       	movw	r24, r28
    24e0:	84 df       	rcall	.-248    	; 0x23ea <_Z9WriteDataj>
    24e2:	df 91       	pop	r29
	}
}
    24e4:	cf 91       	pop	r28
    24e6:	1f 91       	pop	r17
    24e8:	0f 91       	pop	r16
    24ea:	08 95       	ret

000024ec <_Z14SetPageAddressjj>:
    24ec:	0f 93       	push	r16

// Set Page Address (0-319), Start > End
void SetPageAddress(unsigned int Start, unsigned int End)
{
    24ee:	1f 93       	push	r17
    24f0:	cf 93       	push	r28
    24f2:	df 93       	push	r29
	if (Start < End)
    24f4:	86 17       	cp	r24, r22
    24f6:	97 07       	cpc	r25, r23
    24f8:	78 f4       	brcc	.+30     	; 0x2518 <_Z14SetPageAddressjj+0x2c>
    24fa:	eb 01       	movw	r28, r22
    24fc:	8c 01       	movw	r16, r24
	{
		WriteCommand(0x2B);
    24fe:	8b e2       	ldi	r24, 0x2B	; 43
    2500:	90 e0       	ldi	r25, 0x00	; 0
    2502:	5e df       	rcall	.-324    	; 0x23c0 <_Z12WriteCommandj>
		WriteData(Start >> 8U);
    2504:	81 2f       	mov	r24, r17
    2506:	90 e0       	ldi	r25, 0x00	; 0
    2508:	70 df       	rcall	.-288    	; 0x23ea <_Z9WriteDataj>
		WriteData(Start);
    250a:	c8 01       	movw	r24, r16
    250c:	6e df       	rcall	.-292    	; 0x23ea <_Z9WriteDataj>
		WriteData(End >> 8U);
    250e:	8d 2f       	mov	r24, r29
    2510:	90 e0       	ldi	r25, 0x00	; 0
    2512:	6b df       	rcall	.-298    	; 0x23ea <_Z9WriteDataj>
		WriteData(End);
    2514:	ce 01       	movw	r24, r28
    2516:	69 df       	rcall	.-302    	; 0x23ea <_Z9WriteDataj>
    2518:	df 91       	pop	r29
	}
}
    251a:	cf 91       	pop	r28
    251c:	1f 91       	pop	r17
    251e:	0f 91       	pop	r16
    2520:	08 95       	ret

00002522 <_Z13FillRectanglejjjjhhh>:
    2522:	6f 92       	push	r6
// Fills rectangle with specified color
// (StartX,StartY) = Upper left corner. X horizontal (0-319) , Y vertical (0-239).
// Height (1-240) is vertical. Width (1-320) is horizontal.
// R-G-B = 5-6-5 bits.
void FillRectangle(unsigned int StartX, unsigned int StartY, unsigned int Width, unsigned int Height, unsigned char Blue, unsigned char Green, unsigned char Red)
{
    2524:	7f 92       	push	r7
    2526:	8f 92       	push	r8
    2528:	9f 92       	push	r9
    252a:	af 92       	push	r10
    252c:	bf 92       	push	r11
    252e:	cf 92       	push	r12
    2530:	ef 92       	push	r14
    2532:	0f 93       	push	r16
    2534:	cf 93       	push	r28
    2536:	df 93       	push	r29
    2538:	5b 01       	movw	r10, r22
    253a:	3a 01       	movw	r6, r20
    253c:	e9 01       	movw	r28, r18
	SetPageAddress(StartX,StartX+Width-1);
    253e:	bc 01       	movw	r22, r24
    2540:	64 0f       	add	r22, r20
    2542:	75 1f       	adc	r23, r21
    2544:	61 50       	subi	r22, 0x01	; 1
    2546:	71 09       	sbc	r23, r1
    2548:	d1 df       	rcall	.-94     	; 0x24ec <_Z14SetPageAddressjj>
	SetColumnAddress(StartY,StartY+Height-1);
    254a:	b5 01       	movw	r22, r10
    254c:	6c 0f       	add	r22, r28
    254e:	7d 1f       	adc	r23, r29
    2550:	61 50       	subi	r22, 0x01	; 1
    2552:	71 09       	sbc	r23, r1
    2554:	c5 01       	movw	r24, r10
	MemoryWrite();
    2556:	af df       	rcall	.-162    	; 0x24b6 <_Z16SetColumnAddressjj>
    2558:	9b df       	rcall	.-202    	; 0x2490 <_Z11MemoryWritev>
	
	for (uint32_t counter = 0; counter < (uint32_t)Width*Height; counter++)
    255a:	81 2c       	mov	r8, r1
    255c:	91 2c       	mov	r9, r1
    255e:	54 01       	movw	r10, r8
    2560:	93 01       	movw	r18, r6
    2562:	de 01       	movw	r26, r28
    2564:	3f d4       	rcall	.+2174   	; 0x2de4 <__umulhisi3>
    2566:	86 16       	cp	r8, r22
    2568:	97 06       	cpc	r9, r23
    256a:	a8 06       	cpc	r10, r24
    256c:	b9 06       	cpc	r11, r25
	{
		WritePixel(Red,Green,Blue);
    256e:	50 f4       	brcc	.+20     	; 0x2584 <_Z13FillRectanglejjjjhhh+0x62>
    2570:	40 2f       	mov	r20, r16
    2572:	6e 2d       	mov	r22, r14
    2574:	8c 2d       	mov	r24, r12
    2576:	90 df       	rcall	.-224    	; 0x2498 <_Z10WritePixelhhh>
{
	SetPageAddress(StartX,StartX+Width-1);
	SetColumnAddress(StartY,StartY+Height-1);
	MemoryWrite();
	
	for (uint32_t counter = 0; counter < (uint32_t)Width*Height; counter++)
    2578:	8f ef       	ldi	r24, 0xFF	; 255
    257a:	88 1a       	sub	r8, r24
    257c:	98 0a       	sbc	r9, r24
    257e:	a8 0a       	sbc	r10, r24
    2580:	b8 0a       	sbc	r11, r24
	{
		WritePixel(Red,Green,Blue);
	}
	SleepOut();
    2582:	ee cf       	rjmp	.-36     	; 0x2560 <_Z13FillRectanglejjjjhhh+0x3e>
    2584:	4b df       	rcall	.-362    	; 0x241c <_Z8SleepOutv>
}
    2586:	df 91       	pop	r29
    2588:	cf 91       	pop	r28
    258a:	0f 91       	pop	r16
    258c:	ef 90       	pop	r14
    258e:	cf 90       	pop	r12
    2590:	bf 90       	pop	r11
    2592:	af 90       	pop	r10
    2594:	9f 90       	pop	r9
    2596:	8f 90       	pop	r8
    2598:	7f 90       	pop	r7
    259a:	6f 90       	pop	r6
    259c:	08 95       	ret

0000259e <_ZN11TouchscreenC1Ev>:
#include "TouchDriver.h"
#include "TFTdriver.h"
#include "ButtonClass.h"


Touchscreen::Touchscreen()
    259e:	0f 93       	push	r16
    25a0:	1f 93       	push	r17
    25a2:	cf 93       	push	r28
    25a4:	df 93       	push	r29
    25a6:	cd b7       	in	r28, 0x3d	; 61
    25a8:	de b7       	in	r29, 0x3e	; 62
    25aa:	66 97       	sbiw	r28, 0x16	; 22
    25ac:	0f b6       	in	r0, 0x3f	; 63
    25ae:	f8 94       	cli
    25b0:	de bf       	out	0x3e, r29	; 62
    25b2:	0f be       	out	0x3f, r0	; 63
    25b4:	cd bf       	out	0x3d, r28	; 61
    25b6:	8c 01       	movw	r16, r24
    25b8:	36 d1       	rcall	.+620    	; 0x2826 <_ZN11TouchDriverC1Ev>
{
	
	public:
	ButtonClass()
	{
		startX = 0;
    25ba:	f8 01       	movw	r30, r16
    25bc:	12 82       	std	Z+2, r1	; 0x02
		startY = 0;
    25be:	13 82       	std	Z+3, r1	; 0x03
		height = 0;
    25c0:	14 82       	std	Z+4, r1	; 0x04
		width = 0;
    25c2:	15 82       	std	Z+5, r1	; 0x05
		colorRed = 0;
    25c4:	16 82       	std	Z+6, r1	; 0x06
		colorBlue = 0;
    25c6:	17 82       	std	Z+7, r1	; 0x07
		colorGreen = 0;
    25c8:	10 86       	std	Z+8, r1	; 0x08
		endX = 0;
    25ca:	12 86       	std	Z+10, r1	; 0x0a
    25cc:	11 86       	std	Z+9, r1	; 0x09
		endY = 0;
    25ce:	13 86       	std	Z+11, r1	; 0x0b
{
	
	public:
	ButtonClass()
	{
		startX = 0;
    25d0:	14 86       	std	Z+12, r1	; 0x0c
		startY = 0;
    25d2:	15 86       	std	Z+13, r1	; 0x0d
		height = 0;
    25d4:	16 86       	std	Z+14, r1	; 0x0e
		width = 0;
    25d6:	17 86       	std	Z+15, r1	; 0x0f
		colorRed = 0;
    25d8:	10 8a       	std	Z+16, r1	; 0x10
		colorBlue = 0;
    25da:	11 8a       	std	Z+17, r1	; 0x11
		colorGreen = 0;
    25dc:	12 8a       	std	Z+18, r1	; 0x12
		endX = 0;
    25de:	14 8a       	std	Z+20, r1	; 0x14
    25e0:	13 8a       	std	Z+19, r1	; 0x13
		endY = 0;
    25e2:	15 8a       	std	Z+21, r1	; 0x15
{
	TouchDriv = TouchDriver();
    25e4:	ce 01       	movw	r24, r28
    25e6:	45 96       	adiw	r24, 0x15	; 21
    25e8:	1e d1       	rcall	.+572    	; 0x2826 <_ZN11TouchDriverC1Ev>
    25ea:	8d 89       	ldd	r24, Y+21	; 0x15
    25ec:	9e 89       	ldd	r25, Y+22	; 0x16
    25ee:	d8 01       	movw	r26, r16
    25f0:	8d 93       	st	X+, r24
    25f2:	9d 93       	st	X+, r25
	}
	
	ButtonClass(uint8_t StartX, uint8_t StartY, uint16_t EndX, uint8_t EndY, uint8_t ColorRed, uint8_t ColorBlue, uint8_t ColorGreen)
	{
		startX = StartX;
    25f4:	84 e1       	ldi	r24, 0x14	; 20
    25f6:	8b 87       	std	Y+11, r24	; 0x0b
		startY = StartY;
    25f8:	46 e4       	ldi	r20, 0x46	; 70
    25fa:	4c 87       	std	Y+12, r20	; 0x0c
		endX = EndX;
    25fc:	88 e7       	ldi	r24, 0x78	; 120
    25fe:	90 e0       	ldi	r25, 0x00	; 0
    2600:	9b 8b       	std	Y+19, r25	; 0x13
    2602:	8a 8b       	std	Y+18, r24	; 0x12
		endY = EndY;
    2604:	3a ea       	ldi	r19, 0xAA	; 170
    2606:	3c 8b       	std	Y+20, r19	; 0x14
		width = EndX-StartX;
    2608:	84 e6       	ldi	r24, 0x64	; 100
    260a:	8e 87       	std	Y+14, r24	; 0x0e
		height = EndY-StartY;
    260c:	8d 87       	std	Y+13, r24	; 0x0d
		colorRed = ColorRed;
    260e:	9d e1       	ldi	r25, 0x1D	; 29
    2610:	9f 87       	std	Y+15, r25	; 0x0f
		colorBlue = ColorBlue;
    2612:	9a ee       	ldi	r25, 0xEA	; 234
    2614:	98 8b       	std	Y+16, r25	; 0x10
		colorGreen = ColorGreen;
    2616:	22 e0       	ldi	r18, 0x02	; 2
    2618:	29 8b       	std	Y+17, r18	; 0x11
	
	blueBnt = ButtonClass(20, 70, 120, 170, 29, 234, 2);
    261a:	5a e0       	ldi	r21, 0x0A	; 10
    261c:	fe 01       	movw	r30, r28
    261e:	3b 96       	adiw	r30, 0x0b	; 11
    2620:	01 90       	ld	r0, Z+
    2622:	0d 92       	st	X+, r0
    2624:	5a 95       	dec	r21
    2626:	e1 f7       	brne	.-8      	; 0x2620 <_ZN11TouchscreenC1Ev+0x82>
		endY = 0;
	}
	
	ButtonClass(uint8_t StartX, uint8_t StartY, uint16_t EndX, uint8_t EndY, uint8_t ColorRed, uint8_t ColorBlue, uint8_t ColorGreen)
	{
		startX = StartX;
    2628:	58 ec       	ldi	r21, 0xC8	; 200
    262a:	59 83       	std	Y+1, r21	; 0x01
		startY = StartY;
    262c:	4a 83       	std	Y+2, r20	; 0x02
		endX = EndX;
    262e:	4c e2       	ldi	r20, 0x2C	; 44
    2630:	51 e0       	ldi	r21, 0x01	; 1
    2632:	59 87       	std	Y+9, r21	; 0x09
    2634:	48 87       	std	Y+8, r20	; 0x08
		endY = EndY;
    2636:	3a 87       	std	Y+10, r19	; 0x0a
		width = EndX-StartX;
    2638:	8c 83       	std	Y+4, r24	; 0x04
		height = EndY-StartY;
    263a:	8b 83       	std	Y+3, r24	; 0x03
		colorRed = ColorRed;
    263c:	8c e2       	ldi	r24, 0x2C	; 44
    263e:	8d 83       	std	Y+5, r24	; 0x05
		colorBlue = ColorBlue;
    2640:	2e 83       	std	Y+6, r18	; 0x06
		colorGreen = ColorGreen;
    2642:	9f 83       	std	Y+7, r25	; 0x07
	greenBnt = ButtonClass(200, 70, 300, 170, 44, 2, 234);
    2644:	8a e0       	ldi	r24, 0x0A	; 10
    2646:	fe 01       	movw	r30, r28
    2648:	31 96       	adiw	r30, 0x01	; 1
    264a:	d8 01       	movw	r26, r16
    264c:	1c 96       	adiw	r26, 0x0c	; 12
    264e:	01 90       	ld	r0, Z+
    2650:	0d 92       	st	X+, r0
    2652:	8a 95       	dec	r24
	
	DisplayInit();
    2654:	e1 f7       	brne	.-8      	; 0x264e <_ZN11TouchscreenC1Ev+0xb0>
    2656:	fa de       	rcall	.-524    	; 0x244c <_Z11DisplayInitv>
}
    2658:	66 96       	adiw	r28, 0x16	; 22
    265a:	0f b6       	in	r0, 0x3f	; 63
    265c:	f8 94       	cli
    265e:	de bf       	out	0x3e, r29	; 62
    2660:	0f be       	out	0x3f, r0	; 63
    2662:	cd bf       	out	0x3d, r28	; 61
    2664:	df 91       	pop	r29
    2666:	cf 91       	pop	r28
    2668:	1f 91       	pop	r17
    266a:	0f 91       	pop	r16
    266c:	08 95       	ret

0000266e <_ZN11Touchscreen12checkButtonsEv>:


uint8_t Touchscreen::checkButtons(void)
{
    266e:	cf 92       	push	r12
    2670:	df 92       	push	r13
    2672:	ef 92       	push	r14
    2674:	ff 92       	push	r15
    2676:	0f 93       	push	r16
    2678:	1f 93       	push	r17
    267a:	cf 93       	push	r28
    267c:	df 93       	push	r29
    267e:	1f 92       	push	r1
    2680:	1f 92       	push	r1
    2682:	cd b7       	in	r28, 0x3d	; 61
    2684:	de b7       	in	r29, 0x3e	; 62
    2686:	8c 01       	movw	r16, r24
	uint8_t x = 0;
    2688:	19 82       	std	Y+1, r1	; 0x01
	uint8_t y = 0;
    268a:	1a 82       	std	Y+2, r1	; 0x02
	
	TouchDriv.getCoordinates(&x, &y);
    268c:	ae 01       	movw	r20, r28
    268e:	4e 5f       	subi	r20, 0xFE	; 254
    2690:	5f 4f       	sbci	r21, 0xFF	; 255
    2692:	be 01       	movw	r22, r28
    2694:	6f 5f       	subi	r22, 0xFF	; 255
    2696:	7f 4f       	sbci	r23, 0xFF	; 255
    2698:	63 d1       	rcall	.+710    	; 0x2960 <_ZN11TouchDriver14getCoordinatesEPhS0_>
	
	if (x > blueBnt.startX/1.33 && x < blueBnt.endX/1.33 && y > blueBnt.startY && y < blueBnt.endY)
    269a:	69 81       	ldd	r22, Y+1	; 0x01
    269c:	70 e0       	ldi	r23, 0x00	; 0
    269e:	80 e0       	ldi	r24, 0x00	; 0
    26a0:	90 e0       	ldi	r25, 0x00	; 0
    26a2:	81 d2       	rcall	.+1282   	; 0x2ba6 <__floatsisf>
    26a4:	6b 01       	movw	r12, r22
    26a6:	7c 01       	movw	r14, r24
    26a8:	f8 01       	movw	r30, r16
    26aa:	62 81       	ldd	r22, Z+2	; 0x02
    26ac:	70 e0       	ldi	r23, 0x00	; 0
    26ae:	80 e0       	ldi	r24, 0x00	; 0
    26b0:	90 e0       	ldi	r25, 0x00	; 0
    26b2:	79 d2       	rcall	.+1266   	; 0x2ba6 <__floatsisf>
    26b4:	21 e7       	ldi	r18, 0x71	; 113
    26b6:	3d e3       	ldi	r19, 0x3D	; 61
    26b8:	4a ea       	ldi	r20, 0xAA	; 170
    26ba:	5f e3       	ldi	r21, 0x3F	; 63
    26bc:	de d1       	rcall	.+956    	; 0x2a7a <__divsf3>
    26be:	9b 01       	movw	r18, r22
    26c0:	ac 01       	movw	r20, r24
    26c2:	c7 01       	movw	r24, r14
    26c4:	b6 01       	movw	r22, r12
    26c6:	1f d3       	rcall	.+1598   	; 0x2d06 <__gesf2>
    26c8:	18 16       	cp	r1, r24
    26ca:	d4 f4       	brge	.+52     	; 0x2700 <_ZN11Touchscreen12checkButtonsEv+0x92>
    26cc:	f8 01       	movw	r30, r16
    26ce:	61 85       	ldd	r22, Z+9	; 0x09
    26d0:	72 85       	ldd	r23, Z+10	; 0x0a
    26d2:	80 e0       	ldi	r24, 0x00	; 0
    26d4:	90 e0       	ldi	r25, 0x00	; 0
    26d6:	65 d2       	rcall	.+1226   	; 0x2ba2 <__floatunsisf>
    26d8:	21 e7       	ldi	r18, 0x71	; 113
    26da:	3d e3       	ldi	r19, 0x3D	; 61
    26dc:	4a ea       	ldi	r20, 0xAA	; 170
    26de:	5f e3       	ldi	r21, 0x3F	; 63
    26e0:	cc d1       	rcall	.+920    	; 0x2a7a <__divsf3>
    26e2:	9b 01       	movw	r18, r22
    26e4:	ac 01       	movw	r20, r24
    26e6:	c7 01       	movw	r24, r14
    26e8:	b6 01       	movw	r22, r12
    26ea:	c3 d1       	rcall	.+902    	; 0x2a72 <__cmpsf2>
    26ec:	88 23       	and	r24, r24
    26ee:	44 f4       	brge	.+16     	; 0x2700 <_ZN11Touchscreen12checkButtonsEv+0x92>
    26f0:	f8 01       	movw	r30, r16
    26f2:	93 81       	ldd	r25, Z+3	; 0x03
    26f4:	8a 81       	ldd	r24, Y+2	; 0x02
    26f6:	98 17       	cp	r25, r24
    26f8:	18 f4       	brcc	.+6      	; 0x2700 <_ZN11Touchscreen12checkButtonsEv+0x92>
    26fa:	93 85       	ldd	r25, Z+11	; 0x0b
    26fc:	89 17       	cp	r24, r25
	{
		return 1;
	}
	else if (x > greenBnt.startX/1.33 && x < greenBnt.endX/1.33 && y > greenBnt.startY && y < greenBnt.endY)
    26fe:	70 f1       	brcs	.+92     	; 0x275c <_ZN11Touchscreen12checkButtonsEv+0xee>
    2700:	f8 01       	movw	r30, r16
    2702:	64 85       	ldd	r22, Z+12	; 0x0c
    2704:	70 e0       	ldi	r23, 0x00	; 0
    2706:	80 e0       	ldi	r24, 0x00	; 0
    2708:	90 e0       	ldi	r25, 0x00	; 0
    270a:	4d d2       	rcall	.+1178   	; 0x2ba6 <__floatsisf>
    270c:	21 e7       	ldi	r18, 0x71	; 113
    270e:	3d e3       	ldi	r19, 0x3D	; 61
    2710:	4a ea       	ldi	r20, 0xAA	; 170
    2712:	5f e3       	ldi	r21, 0x3F	; 63
    2714:	b2 d1       	rcall	.+868    	; 0x2a7a <__divsf3>
    2716:	9b 01       	movw	r18, r22
    2718:	ac 01       	movw	r20, r24
    271a:	c7 01       	movw	r24, r14
    271c:	b6 01       	movw	r22, r12
    271e:	f3 d2       	rcall	.+1510   	; 0x2d06 <__gesf2>
    2720:	18 16       	cp	r1, r24
    2722:	f4 f4       	brge	.+60     	; 0x2760 <_ZN11Touchscreen12checkButtonsEv+0xf2>
    2724:	f8 01       	movw	r30, r16
    2726:	63 89       	ldd	r22, Z+19	; 0x13
    2728:	74 89       	ldd	r23, Z+20	; 0x14
    272a:	80 e0       	ldi	r24, 0x00	; 0
    272c:	90 e0       	ldi	r25, 0x00	; 0
    272e:	39 d2       	rcall	.+1138   	; 0x2ba2 <__floatunsisf>
    2730:	21 e7       	ldi	r18, 0x71	; 113
    2732:	3d e3       	ldi	r19, 0x3D	; 61
    2734:	4a ea       	ldi	r20, 0xAA	; 170
    2736:	5f e3       	ldi	r21, 0x3F	; 63
    2738:	a0 d1       	rcall	.+832    	; 0x2a7a <__divsf3>
    273a:	9b 01       	movw	r18, r22
    273c:	ac 01       	movw	r20, r24
    273e:	c7 01       	movw	r24, r14
    2740:	b6 01       	movw	r22, r12
    2742:	97 d1       	rcall	.+814    	; 0x2a72 <__cmpsf2>
    2744:	88 23       	and	r24, r24
    2746:	74 f4       	brge	.+28     	; 0x2764 <_ZN11Touchscreen12checkButtonsEv+0xf6>
    2748:	f8 01       	movw	r30, r16
    274a:	95 85       	ldd	r25, Z+13	; 0x0d
    274c:	8a 81       	ldd	r24, Y+2	; 0x02
    274e:	98 17       	cp	r25, r24
    2750:	58 f4       	brcc	.+22     	; 0x2768 <_ZN11Touchscreen12checkButtonsEv+0xfa>
    2752:	95 89       	ldd	r25, Z+21	; 0x15
    2754:	89 17       	cp	r24, r25
    2756:	50 f0       	brcs	.+20     	; 0x276c <_ZN11Touchscreen12checkButtonsEv+0xfe>
    2758:	80 e0       	ldi	r24, 0x00	; 0
	{
		return 2;
	}
	else
	{
		return 0;
    275a:	09 c0       	rjmp	.+18     	; 0x276e <_ZN11Touchscreen12checkButtonsEv+0x100>
    275c:	81 e0       	ldi	r24, 0x01	; 1
	
	TouchDriv.getCoordinates(&x, &y);
	
	if (x > blueBnt.startX/1.33 && x < blueBnt.endX/1.33 && y > blueBnt.startY && y < blueBnt.endY)
	{
		return 1;
    275e:	07 c0       	rjmp	.+14     	; 0x276e <_ZN11Touchscreen12checkButtonsEv+0x100>
    2760:	80 e0       	ldi	r24, 0x00	; 0
	{
		return 2;
	}
	else
	{
		return 0;
    2762:	05 c0       	rjmp	.+10     	; 0x276e <_ZN11Touchscreen12checkButtonsEv+0x100>
    2764:	80 e0       	ldi	r24, 0x00	; 0
    2766:	03 c0       	rjmp	.+6      	; 0x276e <_ZN11Touchscreen12checkButtonsEv+0x100>
    2768:	80 e0       	ldi	r24, 0x00	; 0
    276a:	01 c0       	rjmp	.+2      	; 0x276e <_ZN11Touchscreen12checkButtonsEv+0x100>
    276c:	82 e0       	ldi	r24, 0x02	; 2
	{
		return 1;
	}
	else if (x > greenBnt.startX/1.33 && x < greenBnt.endX/1.33 && y > greenBnt.startY && y < greenBnt.endY)
	{
		return 2;
    276e:	0f 90       	pop	r0
	else
	{
		return 0;
	}
	
}
    2770:	0f 90       	pop	r0
    2772:	df 91       	pop	r29
    2774:	cf 91       	pop	r28
    2776:	1f 91       	pop	r17
    2778:	0f 91       	pop	r16
    277a:	ff 90       	pop	r15
    277c:	ef 90       	pop	r14
    277e:	df 90       	pop	r13
    2780:	cf 90       	pop	r12
    2782:	08 95       	ret

00002784 <_ZN11Touchscreen11clearScreenEv>:
    2784:	cf 92       	push	r12

void Touchscreen::clearScreen(void)
{
    2786:	ef 92       	push	r14
    2788:	0f 93       	push	r16
	// Full Screen White
	FillRectangle(0,0,320,240,255,255,255);
    278a:	cc 24       	eor	r12, r12
    278c:	ca 94       	dec	r12
    278e:	ee 24       	eor	r14, r14
    2790:	ea 94       	dec	r14
    2792:	0f ef       	ldi	r16, 0xFF	; 255
    2794:	20 ef       	ldi	r18, 0xF0	; 240
    2796:	30 e0       	ldi	r19, 0x00	; 0
    2798:	40 e4       	ldi	r20, 0x40	; 64
    279a:	51 e0       	ldi	r21, 0x01	; 1
    279c:	60 e0       	ldi	r22, 0x00	; 0
    279e:	70 e0       	ldi	r23, 0x00	; 0
    27a0:	80 e0       	ldi	r24, 0x00	; 0
    27a2:	90 e0       	ldi	r25, 0x00	; 0
    27a4:	be de       	rcall	.-644    	; 0x2522 <_Z13FillRectanglejjjjhhh>
}
    27a6:	0f 91       	pop	r16
    27a8:	ef 90       	pop	r14
    27aa:	cf 90       	pop	r12
    27ac:	08 95       	ret

000027ae <_ZN11Touchscreen23presentButtonsOnDisplayEv>:

void Touchscreen::presentButtonsOnDisplay(void)
{
    27ae:	cf 92       	push	r12
    27b0:	ef 92       	push	r14
    27b2:	0f 93       	push	r16
    27b4:	cf 93       	push	r28
    27b6:	df 93       	push	r29
    27b8:	ec 01       	movw	r28, r24
	
	// Button One
	FillRectangle(blueBnt.startX, blueBnt.startY, blueBnt.width, blueBnt.height, blueBnt.colorRed, blueBnt.colorGreen, blueBnt.colorBlue);
    27ba:	cf 80       	ldd	r12, Y+7	; 0x07
    27bc:	e8 84       	ldd	r14, Y+8	; 0x08
    27be:	0e 81       	ldd	r16, Y+6	; 0x06
    27c0:	2c 81       	ldd	r18, Y+4	; 0x04
    27c2:	30 e0       	ldi	r19, 0x00	; 0
    27c4:	4d 81       	ldd	r20, Y+5	; 0x05
    27c6:	50 e0       	ldi	r21, 0x00	; 0
    27c8:	6b 81       	ldd	r22, Y+3	; 0x03
    27ca:	70 e0       	ldi	r23, 0x00	; 0
    27cc:	8a 81       	ldd	r24, Y+2	; 0x02
    27ce:	90 e0       	ldi	r25, 0x00	; 0
    27d0:	a8 de       	rcall	.-688    	; 0x2522 <_Z13FillRectanglejjjjhhh>

	// Button Two
	FillRectangle(greenBnt.startX, greenBnt.startY, greenBnt.width, greenBnt.height, greenBnt.colorRed, greenBnt.colorGreen, greenBnt.colorBlue);
    27d2:	c9 88       	ldd	r12, Y+17	; 0x11
    27d4:	ea 88       	ldd	r14, Y+18	; 0x12
    27d6:	08 89       	ldd	r16, Y+16	; 0x10
    27d8:	2e 85       	ldd	r18, Y+14	; 0x0e
    27da:	30 e0       	ldi	r19, 0x00	; 0
    27dc:	4f 85       	ldd	r20, Y+15	; 0x0f
    27de:	50 e0       	ldi	r21, 0x00	; 0
    27e0:	6d 85       	ldd	r22, Y+13	; 0x0d
    27e2:	70 e0       	ldi	r23, 0x00	; 0
    27e4:	8c 85       	ldd	r24, Y+12	; 0x0c
    27e6:	90 e0       	ldi	r25, 0x00	; 0
    27e8:	9c de       	rcall	.-712    	; 0x2522 <_Z13FillRectanglejjjjhhh>
}
    27ea:	df 91       	pop	r29
    27ec:	cf 91       	pop	r28
    27ee:	0f 91       	pop	r16
    27f0:	ef 90       	pop	r14
    27f2:	cf 90       	pop	r12
    27f4:	08 95       	ret

000027f6 <_ZN11TouchDriver15initTouchDriverEv>:
	/* MODE							= 12bit = High							*/
	/* SER/DFR						= Differential = Low					*/
	/* PD1/PD0						= Device always powered = 11			*/
	/************************************************************************/
	
	dinXByte = 0b10011100;
    27f6:	2c e9       	ldi	r18, 0x9C	; 156
    27f8:	fc 01       	movw	r30, r24
    27fa:	20 83       	st	Z, r18
	dinYByte = 0b11011100;
    27fc:	2c ed       	ldi	r18, 0xDC	; 220
    27fe:	21 83       	std	Z+1, r18	; 0x01
	
	DDRH |= BIT4;
    2800:	e1 e0       	ldi	r30, 0x01	; 1
    2802:	f1 e0       	ldi	r31, 0x01	; 1
    2804:	80 81       	ld	r24, Z
    2806:	84 60       	ori	r24, 0x04	; 4
    2808:	80 83       	st	Z, r24
	DDRE |= BIT4;
    280a:	8d b1       	in	r24, 0x0d	; 13
    280c:	84 60       	ori	r24, 0x04	; 4
    280e:	8d b9       	out	0x0d, r24	; 13
	DDRG |= BIT6;
    2810:	83 b3       	in	r24, 0x13	; 19
    2812:	86 60       	ori	r24, 0x06	; 6
    2814:	83 bb       	out	0x13, r24	; 19
	
	// Enable Interrupt
	EICRB = 00000010;
    2816:	88 e0       	ldi	r24, 0x08	; 8
    2818:	80 93 6a 00 	sts	0x006A, r24	; 0x80006a <__TEXT_REGION_LENGTH__+0x70006a>
	EIMSK |= 0b00010000;
    281c:	8d b3       	in	r24, 0x1d	; 29
    281e:	80 61       	ori	r24, 0x10	; 16
    2820:	8d bb       	out	0x1d, r24	; 29
	
	sei();
    2822:	78 94       	sei
    2824:	08 95       	ret

00002826 <_ZN11TouchDriverC1Ev>:
/* PE4 = IRQ (Not Used)													*/
/************************************************************************/

TouchDriver::TouchDriver()
{
	initTouchDriver();
    2826:	e7 cf       	rjmp	.-50     	; 0x27f6 <_ZN11TouchDriver15initTouchDriverEv>
    2828:	08 95       	ret

0000282a <__vector_5>:
	sei();
	
}

ISR (INT4_vect)
{
    282a:	1f 92       	push	r1
    282c:	0f 92       	push	r0
    282e:	0f b6       	in	r0, 0x3f	; 63
    2830:	0f 92       	push	r0
    2832:	11 24       	eor	r1, r1
	eIntHappend = 0;
    2834:	10 92 0d 02 	sts	0x020D, r1	; 0x80020d <eIntHappend>
}
    2838:	0f 90       	pop	r0
    283a:	0f be       	out	0x3f, r0	; 63
    283c:	0f 90       	pop	r0
    283e:	1f 90       	pop	r1
    2840:	18 95       	reti

00002842 <_ZN11TouchDriver9readTouchEc>:
}



uint8_t TouchDriver::readTouch(char coord)
{
    2842:	df 92       	push	r13
    2844:	ef 92       	push	r14
    2846:	ff 92       	push	r15
    2848:	0f 93       	push	r16
    284a:	1f 93       	push	r17
    284c:	cf 93       	push	r28
    284e:	df 93       	push	r29
	uint8_t delayTime = 8;
	uint8_t dinByte = 0;
	
	if (coord == 'X')
    2850:	68 35       	cpi	r22, 0x58	; 88
    2852:	19 f4       	brne	.+6      	; 0x285a <_ZN11TouchDriver9readTouchEc+0x18>
	{
		dinByte = dinXByte;
    2854:	fc 01       	movw	r30, r24
    2856:	d0 80       	ld	r13, Z
    2858:	05 c0       	rjmp	.+10     	; 0x2864 <_ZN11TouchDriver9readTouchEc+0x22>
		
	}else if (coord == 'Y')
    285a:	69 35       	cpi	r22, 0x59	; 89
    285c:	09 f0       	breq	.+2      	; 0x2860 <_ZN11TouchDriver9readTouchEc+0x1e>
    285e:	77 c0       	rjmp	.+238    	; 0x294e <_ZN11TouchDriver9readTouchEc+0x10c>
	{
		dinByte = dinYByte;
    2860:	fc 01       	movw	r30, r24
    2862:	d1 80       	ldd	r13, Z+1	; 0x01
	else{
		return 255;
	}
	
	// ChipSelect Set to 0	
	CS_PORT &= ~CS_PIN;
    2864:	8e b1       	in	r24, 0x0e	; 14
    2866:	8b 7f       	andi	r24, 0xFB	; 251
    2868:	8e b9       	out	0x0e, r24	; 14
	vTaskDelay( delayTime / portTICK_RATE_MS );
    286a:	88 e0       	ldi	r24, 0x08	; 8
    286c:	90 e0       	ldi	r25, 0x00	; 0
    286e:	32 dd       	rcall	.-1436   	; 0x22d4 <vTaskDelay>
	uint8_t result = 0;
	
	// DIN byte and pulse DCLK for Read X
	for (int i = 7; i >= 0; i--)
    2870:	c7 e0       	ldi	r28, 0x07	; 7
    2872:	d0 e0       	ldi	r29, 0x00	; 0
    2874:	dd 23       	and	r29, r29
    2876:	6c f1       	brlt	.+90     	; 0x28d2 <_ZN11TouchDriver9readTouchEc+0x90>
	{
		vTaskDelay( delayTime / portTICK_RATE_MS );
    2878:	88 e0       	ldi	r24, 0x08	; 8
    287a:	90 e0       	ldi	r25, 0x00	; 0
    287c:	2b dd       	rcall	.-1450   	; 0x22d4 <vTaskDelay>
		
		DIN_PORT |= (((dinByte >> i)  & 0x01) << 5);
    287e:	24 b3       	in	r18, 0x14	; 20
    2880:	8d 2d       	mov	r24, r13
    2882:	90 e0       	ldi	r25, 0x00	; 0
    2884:	0c 2e       	mov	r0, r28
    2886:	02 c0       	rjmp	.+4      	; 0x288c <_ZN11TouchDriver9readTouchEc+0x4a>
    2888:	95 95       	asr	r25
    288a:	87 95       	ror	r24
    288c:	0a 94       	dec	r0
    288e:	e2 f7       	brpl	.-8      	; 0x2888 <_ZN11TouchDriver9readTouchEc+0x46>
    2890:	81 70       	andi	r24, 0x01	; 1
    2892:	99 27       	eor	r25, r25
    2894:	88 0f       	add	r24, r24
    2896:	99 1f       	adc	r25, r25
    2898:	82 95       	swap	r24
    289a:	92 95       	swap	r25
    289c:	90 7f       	andi	r25, 0xF0	; 240
    289e:	98 27       	eor	r25, r24
    28a0:	80 7f       	andi	r24, 0xF0	; 240
    28a2:	98 27       	eor	r25, r24
    28a4:	82 2b       	or	r24, r18
    28a6:	84 bb       	out	0x14, r24	; 20
				
		CLK_PORT |= CLK_PIN;
    28a8:	68 94       	set
    28aa:	ee 24       	eor	r14, r14
    28ac:	e1 f8       	bld	r14, 1
    28ae:	ff 24       	eor	r15, r15
    28b0:	f3 94       	inc	r15
    28b2:	f7 01       	movw	r30, r14
    28b4:	80 81       	ld	r24, Z
    28b6:	84 60       	ori	r24, 0x04	; 4
    28b8:	80 83       	st	Z, r24
		vTaskDelay( delayTime / portTICK_RATE_MS );		
    28ba:	88 e0       	ldi	r24, 0x08	; 8
    28bc:	90 e0       	ldi	r25, 0x00	; 0
    28be:	0a dd       	rcall	.-1516   	; 0x22d4 <vTaskDelay>
		
		CLK_PORT &= ~CLK_PIN;
    28c0:	f7 01       	movw	r30, r14
    28c2:	80 81       	ld	r24, Z
    28c4:	8b 7f       	andi	r24, 0xFB	; 251
    28c6:	80 83       	st	Z, r24
		DIN_PORT &= ~BIT6;
    28c8:	84 b3       	in	r24, 0x14	; 20
    28ca:	89 7f       	andi	r24, 0xF9	; 249
    28cc:	84 bb       	out	0x14, r24	; 20
	CS_PORT &= ~CS_PIN;
	vTaskDelay( delayTime / portTICK_RATE_MS );
	uint8_t result = 0;
	
	// DIN byte and pulse DCLK for Read X
	for (int i = 7; i >= 0; i--)
    28ce:	21 97       	sbiw	r28, 0x01	; 1
    28d0:	d1 cf       	rjmp	.-94     	; 0x2874 <_ZN11TouchDriver9readTouchEc+0x32>
    28d2:	0f 2e       	mov	r0, r31
    28d4:	f7 e0       	ldi	r31, 0x07	; 7
    28d6:	ef 2e       	mov	r14, r31
    28d8:	f1 2c       	mov	r15, r1
    28da:	f0 2d       	mov	r31, r0
    28dc:	d1 2c       	mov	r13, r1
		DIN_PORT &= ~BIT6;
	}
			
	// Systematically read DOUT
	
	for (int i = 7; i >= 0; i--)
    28de:	ff 20       	and	r15, r15
	{
		vTaskDelay( delayTime / portTICK_RATE_MS );
    28e0:	fc f0       	brlt	.+62     	; 0x2920 <_ZN11TouchDriver9readTouchEc+0xde>
    28e2:	88 e0       	ldi	r24, 0x08	; 8
    28e4:	90 e0       	ldi	r25, 0x00	; 0
    28e6:	f6 dc       	rcall	.-1556   	; 0x22d4 <vTaskDelay>
		
		CLK_PORT |= CLK_PIN;
    28e8:	c2 e0       	ldi	r28, 0x02	; 2
    28ea:	d1 e0       	ldi	r29, 0x01	; 1
    28ec:	98 81       	ld	r25, Y
    28ee:	94 60       	ori	r25, 0x04	; 4
		vTaskDelay( delayTime / portTICK_RATE_MS );
    28f0:	98 83       	st	Y, r25
    28f2:	88 e0       	ldi	r24, 0x08	; 8
    28f4:	90 e0       	ldi	r25, 0x00	; 0
    28f6:	ee dc       	rcall	.-1572   	; 0x22d4 <vTaskDelay>
		
		CLK_PORT &= ~CLK_PIN;
    28f8:	98 81       	ld	r25, Y
    28fa:	9b 7f       	andi	r25, 0xFB	; 251
    28fc:	98 83       	st	Y, r25
		//_delay_us(1); IS THIS NEEDED MIKKEL?
		
		bool temp = (PINE & (1U << 5));
    28fe:	8c b1       	in	r24, 0x0c	; 12
		
		// Check this
		result |= (temp << i);
    2900:	85 fb       	bst	r24, 5
    2902:	00 27       	eor	r16, r16
    2904:	00 f9       	bld	r16, 0
    2906:	10 e0       	ldi	r17, 0x00	; 0
    2908:	c8 01       	movw	r24, r16
    290a:	0e 2c       	mov	r0, r14
    290c:	02 c0       	rjmp	.+4      	; 0x2912 <_ZN11TouchDriver9readTouchEc+0xd0>
    290e:	88 0f       	add	r24, r24
    2910:	99 1f       	adc	r25, r25
    2912:	0a 94       	dec	r0
    2914:	e2 f7       	brpl	.-8      	; 0x290e <_ZN11TouchDriver9readTouchEc+0xcc>
    2916:	d8 2a       	or	r13, r24
		DIN_PORT &= ~BIT6;
	}
			
	// Systematically read DOUT
	
	for (int i = 7; i >= 0; i--)
    2918:	f1 e0       	ldi	r31, 0x01	; 1
    291a:	ef 1a       	sub	r14, r31
    291c:	f1 08       	sbc	r15, r1
    291e:	df cf       	rjmp	.-66     	; 0x28de <_ZN11TouchDriver9readTouchEc+0x9c>
    2920:	c7 e0       	ldi	r28, 0x07	; 7
		
		// Check this
		result |= (temp << i);
	}
	
	for (int i = 7; i >= 0; i--)
    2922:	d0 e0       	ldi	r29, 0x00	; 0
    2924:	dd 23       	and	r29, r29
	{
		vTaskDelay( delayTime / portTICK_RATE_MS );		CLK_PORT |= CLK_PIN;
    2926:	6c f0       	brlt	.+26     	; 0x2942 <_ZN11TouchDriver9readTouchEc+0x100>
    2928:	88 e0       	ldi	r24, 0x08	; 8
    292a:	90 e0       	ldi	r25, 0x00	; 0
    292c:	d3 dc       	rcall	.-1626   	; 0x22d4 <vTaskDelay>
    292e:	e2 e0       	ldi	r30, 0x02	; 2
    2930:	f1 e0       	ldi	r31, 0x01	; 1
    2932:	90 81       	ld	r25, Z
    2934:	94 60       	ori	r25, 0x04	; 4
    2936:	90 83       	st	Z, r25
		CLK_PORT &= ~CLK_PIN;
    2938:	90 81       	ld	r25, Z
    293a:	9b 7f       	andi	r25, 0xFB	; 251
    293c:	90 83       	st	Z, r25
		
		// Check this
		result |= (temp << i);
	}
	
	for (int i = 7; i >= 0; i--)
    293e:	21 97       	sbiw	r28, 0x01	; 1
    2940:	f1 cf       	rjmp	.-30     	; 0x2924 <_ZN11TouchDriver9readTouchEc+0xe2>
		vTaskDelay( delayTime / portTICK_RATE_MS );		CLK_PORT |= CLK_PIN;
		CLK_PORT &= ~CLK_PIN;
		// Check this
	}
	
	CS_PORT |= CS_PIN;
    2942:	8e b1       	in	r24, 0x0e	; 14
    2944:	84 60       	ori	r24, 0x04	; 4
    2946:	8e b9       	out	0x0e, r24	; 14
		
	return ~result;
    2948:	8d 2d       	mov	r24, r13
    294a:	80 95       	com	r24
    294c:	01 c0       	rjmp	.+2      	; 0x2950 <_ZN11TouchDriver9readTouchEc+0x10e>
	}else if (coord == 'Y')
	{
		dinByte = dinYByte;
	}
	else{
		return 255;
    294e:	8f ef       	ldi	r24, 0xFF	; 255
	}
	
	CS_PORT |= CS_PIN;
		
	return ~result;
    2950:	df 91       	pop	r29
    2952:	cf 91       	pop	r28
    2954:	1f 91       	pop	r17
    2956:	0f 91       	pop	r16
    2958:	ff 90       	pop	r15
    295a:	ef 90       	pop	r14
    295c:	df 90       	pop	r13
    295e:	08 95       	ret

00002960 <_ZN11TouchDriver14getCoordinatesEPhS0_>:
{
	eIntHappend = 0;
}

void TouchDriver::getCoordinates(uint8_t *x_ptr, uint8_t *y_ptr)
{	
    2960:	ef 92       	push	r14
    2962:	ff 92       	push	r15
    2964:	0f 93       	push	r16
    2966:	1f 93       	push	r17
    2968:	cf 93       	push	r28
    296a:	df 93       	push	r29
    296c:	ec 01       	movw	r28, r24
    296e:	7b 01       	movw	r14, r22
    2970:	8a 01       	movw	r16, r20
	while(eIntHappend != 0);
    2972:	80 91 0d 02 	lds	r24, 0x020D	; 0x80020d <eIntHappend>
    2976:	81 11       	cpse	r24, r1
    2978:	fc cf       	rjmp	.-8      	; 0x2972 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x12>
	
	*x_ptr = readTouch('X');
    297a:	68 e5       	ldi	r22, 0x58	; 88
    297c:	ce 01       	movw	r24, r28
    297e:	61 df       	rcall	.-318    	; 0x2842 <_ZN11TouchDriver9readTouchEc>
    2980:	f7 01       	movw	r30, r14
    2982:	80 83       	st	Z, r24
	*y_ptr = readTouch('Y');
    2984:	69 e5       	ldi	r22, 0x59	; 89
    2986:	ce 01       	movw	r24, r28
    2988:	5c df       	rcall	.-328    	; 0x2842 <_ZN11TouchDriver9readTouchEc>
    298a:	f8 01       	movw	r30, r16
    298c:	80 83       	st	Z, r24
	
	vTaskDelay( 50 / portTICK_RATE_MS );
    298e:	82 e3       	ldi	r24, 0x32	; 50
    2990:	90 e0       	ldi	r25, 0x00	; 0
    2992:	a0 dc       	rcall	.-1728   	; 0x22d4 <vTaskDelay>
	eIntHappend = 255;
    2994:	8f ef       	ldi	r24, 0xFF	; 255
    2996:	80 93 0d 02 	sts	0x020D, r24	; 0x80020d <eIntHappend>
	
}
    299a:	df 91       	pop	r29
    299c:	cf 91       	pop	r28
    299e:	1f 91       	pop	r17
    29a0:	0f 91       	pop	r16
    29a2:	ff 90       	pop	r15
    29a4:	ef 90       	pop	r14
    29a6:	08 95       	ret

000029a8 <__subsf3>:
    29a8:	50 58       	subi	r21, 0x80	; 128

000029aa <__addsf3>:
    29aa:	bb 27       	eor	r27, r27
    29ac:	aa 27       	eor	r26, r26
    29ae:	0e d0       	rcall	.+28     	; 0x29cc <__addsf3x>
    29b0:	70 c1       	rjmp	.+736    	; 0x2c92 <__fp_round>
    29b2:	61 d1       	rcall	.+706    	; 0x2c76 <__fp_pscA>
    29b4:	30 f0       	brcs	.+12     	; 0x29c2 <__addsf3+0x18>
    29b6:	66 d1       	rcall	.+716    	; 0x2c84 <__fp_pscB>
    29b8:	20 f0       	brcs	.+8      	; 0x29c2 <__addsf3+0x18>
    29ba:	31 f4       	brne	.+12     	; 0x29c8 <__addsf3+0x1e>
    29bc:	9f 3f       	cpi	r25, 0xFF	; 255
    29be:	11 f4       	brne	.+4      	; 0x29c4 <__addsf3+0x1a>
    29c0:	1e f4       	brtc	.+6      	; 0x29c8 <__addsf3+0x1e>
    29c2:	56 c1       	rjmp	.+684    	; 0x2c70 <__fp_nan>
    29c4:	0e f4       	brtc	.+2      	; 0x29c8 <__addsf3+0x1e>
    29c6:	e0 95       	com	r30
    29c8:	e7 fb       	bst	r30, 7
    29ca:	4c c1       	rjmp	.+664    	; 0x2c64 <__fp_inf>

000029cc <__addsf3x>:
    29cc:	e9 2f       	mov	r30, r25
    29ce:	72 d1       	rcall	.+740    	; 0x2cb4 <__fp_split3>
    29d0:	80 f3       	brcs	.-32     	; 0x29b2 <__addsf3+0x8>
    29d2:	ba 17       	cp	r27, r26
    29d4:	62 07       	cpc	r22, r18
    29d6:	73 07       	cpc	r23, r19
    29d8:	84 07       	cpc	r24, r20
    29da:	95 07       	cpc	r25, r21
    29dc:	18 f0       	brcs	.+6      	; 0x29e4 <__addsf3x+0x18>
    29de:	71 f4       	brne	.+28     	; 0x29fc <__addsf3x+0x30>
    29e0:	9e f5       	brtc	.+102    	; 0x2a48 <__addsf3x+0x7c>
    29e2:	8a c1       	rjmp	.+788    	; 0x2cf8 <__fp_zero>
    29e4:	0e f4       	brtc	.+2      	; 0x29e8 <__addsf3x+0x1c>
    29e6:	e0 95       	com	r30
    29e8:	0b 2e       	mov	r0, r27
    29ea:	ba 2f       	mov	r27, r26
    29ec:	a0 2d       	mov	r26, r0
    29ee:	0b 01       	movw	r0, r22
    29f0:	b9 01       	movw	r22, r18
    29f2:	90 01       	movw	r18, r0
    29f4:	0c 01       	movw	r0, r24
    29f6:	ca 01       	movw	r24, r20
    29f8:	a0 01       	movw	r20, r0
    29fa:	11 24       	eor	r1, r1
    29fc:	ff 27       	eor	r31, r31
    29fe:	59 1b       	sub	r21, r25
    2a00:	99 f0       	breq	.+38     	; 0x2a28 <__addsf3x+0x5c>
    2a02:	59 3f       	cpi	r21, 0xF9	; 249
    2a04:	50 f4       	brcc	.+20     	; 0x2a1a <__addsf3x+0x4e>
    2a06:	50 3e       	cpi	r21, 0xE0	; 224
    2a08:	68 f1       	brcs	.+90     	; 0x2a64 <__addsf3x+0x98>
    2a0a:	1a 16       	cp	r1, r26
    2a0c:	f0 40       	sbci	r31, 0x00	; 0
    2a0e:	a2 2f       	mov	r26, r18
    2a10:	23 2f       	mov	r18, r19
    2a12:	34 2f       	mov	r19, r20
    2a14:	44 27       	eor	r20, r20
    2a16:	58 5f       	subi	r21, 0xF8	; 248
    2a18:	f3 cf       	rjmp	.-26     	; 0x2a00 <__addsf3x+0x34>
    2a1a:	46 95       	lsr	r20
    2a1c:	37 95       	ror	r19
    2a1e:	27 95       	ror	r18
    2a20:	a7 95       	ror	r26
    2a22:	f0 40       	sbci	r31, 0x00	; 0
    2a24:	53 95       	inc	r21
    2a26:	c9 f7       	brne	.-14     	; 0x2a1a <__addsf3x+0x4e>
    2a28:	7e f4       	brtc	.+30     	; 0x2a48 <__addsf3x+0x7c>
    2a2a:	1f 16       	cp	r1, r31
    2a2c:	ba 0b       	sbc	r27, r26
    2a2e:	62 0b       	sbc	r22, r18
    2a30:	73 0b       	sbc	r23, r19
    2a32:	84 0b       	sbc	r24, r20
    2a34:	ba f0       	brmi	.+46     	; 0x2a64 <__addsf3x+0x98>
    2a36:	91 50       	subi	r25, 0x01	; 1
    2a38:	a1 f0       	breq	.+40     	; 0x2a62 <__addsf3x+0x96>
    2a3a:	ff 0f       	add	r31, r31
    2a3c:	bb 1f       	adc	r27, r27
    2a3e:	66 1f       	adc	r22, r22
    2a40:	77 1f       	adc	r23, r23
    2a42:	88 1f       	adc	r24, r24
    2a44:	c2 f7       	brpl	.-16     	; 0x2a36 <__addsf3x+0x6a>
    2a46:	0e c0       	rjmp	.+28     	; 0x2a64 <__addsf3x+0x98>
    2a48:	ba 0f       	add	r27, r26
    2a4a:	62 1f       	adc	r22, r18
    2a4c:	73 1f       	adc	r23, r19
    2a4e:	84 1f       	adc	r24, r20
    2a50:	48 f4       	brcc	.+18     	; 0x2a64 <__addsf3x+0x98>
    2a52:	87 95       	ror	r24
    2a54:	77 95       	ror	r23
    2a56:	67 95       	ror	r22
    2a58:	b7 95       	ror	r27
    2a5a:	f7 95       	ror	r31
    2a5c:	9e 3f       	cpi	r25, 0xFE	; 254
    2a5e:	08 f0       	brcs	.+2      	; 0x2a62 <__addsf3x+0x96>
    2a60:	b3 cf       	rjmp	.-154    	; 0x29c8 <__addsf3+0x1e>
    2a62:	93 95       	inc	r25
    2a64:	88 0f       	add	r24, r24
    2a66:	08 f0       	brcs	.+2      	; 0x2a6a <__addsf3x+0x9e>
    2a68:	99 27       	eor	r25, r25
    2a6a:	ee 0f       	add	r30, r30
    2a6c:	97 95       	ror	r25
    2a6e:	87 95       	ror	r24
    2a70:	08 95       	ret

00002a72 <__cmpsf2>:
    2a72:	d4 d0       	rcall	.+424    	; 0x2c1c <__fp_cmp>
    2a74:	08 f4       	brcc	.+2      	; 0x2a78 <__cmpsf2+0x6>
    2a76:	81 e0       	ldi	r24, 0x01	; 1
    2a78:	08 95       	ret

00002a7a <__divsf3>:
    2a7a:	0c d0       	rcall	.+24     	; 0x2a94 <__divsf3x>
    2a7c:	0a c1       	rjmp	.+532    	; 0x2c92 <__fp_round>
    2a7e:	02 d1       	rcall	.+516    	; 0x2c84 <__fp_pscB>
    2a80:	40 f0       	brcs	.+16     	; 0x2a92 <__divsf3+0x18>
    2a82:	f9 d0       	rcall	.+498    	; 0x2c76 <__fp_pscA>
    2a84:	30 f0       	brcs	.+12     	; 0x2a92 <__divsf3+0x18>
    2a86:	21 f4       	brne	.+8      	; 0x2a90 <__divsf3+0x16>
    2a88:	5f 3f       	cpi	r21, 0xFF	; 255
    2a8a:	19 f0       	breq	.+6      	; 0x2a92 <__divsf3+0x18>
    2a8c:	eb c0       	rjmp	.+470    	; 0x2c64 <__fp_inf>
    2a8e:	51 11       	cpse	r21, r1
    2a90:	34 c1       	rjmp	.+616    	; 0x2cfa <__fp_szero>
    2a92:	ee c0       	rjmp	.+476    	; 0x2c70 <__fp_nan>

00002a94 <__divsf3x>:
    2a94:	0f d1       	rcall	.+542    	; 0x2cb4 <__fp_split3>
    2a96:	98 f3       	brcs	.-26     	; 0x2a7e <__divsf3+0x4>

00002a98 <__divsf3_pse>:
    2a98:	99 23       	and	r25, r25
    2a9a:	c9 f3       	breq	.-14     	; 0x2a8e <__divsf3+0x14>
    2a9c:	55 23       	and	r21, r21
    2a9e:	b1 f3       	breq	.-20     	; 0x2a8c <__divsf3+0x12>
    2aa0:	95 1b       	sub	r25, r21
    2aa2:	55 0b       	sbc	r21, r21
    2aa4:	bb 27       	eor	r27, r27
    2aa6:	aa 27       	eor	r26, r26
    2aa8:	62 17       	cp	r22, r18
    2aaa:	73 07       	cpc	r23, r19
    2aac:	84 07       	cpc	r24, r20
    2aae:	38 f0       	brcs	.+14     	; 0x2abe <__divsf3_pse+0x26>
    2ab0:	9f 5f       	subi	r25, 0xFF	; 255
    2ab2:	5f 4f       	sbci	r21, 0xFF	; 255
    2ab4:	22 0f       	add	r18, r18
    2ab6:	33 1f       	adc	r19, r19
    2ab8:	44 1f       	adc	r20, r20
    2aba:	aa 1f       	adc	r26, r26
    2abc:	a9 f3       	breq	.-22     	; 0x2aa8 <__divsf3_pse+0x10>
    2abe:	33 d0       	rcall	.+102    	; 0x2b26 <__divsf3_pse+0x8e>
    2ac0:	0e 2e       	mov	r0, r30
    2ac2:	3a f0       	brmi	.+14     	; 0x2ad2 <__divsf3_pse+0x3a>
    2ac4:	e0 e8       	ldi	r30, 0x80	; 128
    2ac6:	30 d0       	rcall	.+96     	; 0x2b28 <__divsf3_pse+0x90>
    2ac8:	91 50       	subi	r25, 0x01	; 1
    2aca:	50 40       	sbci	r21, 0x00	; 0
    2acc:	e6 95       	lsr	r30
    2ace:	00 1c       	adc	r0, r0
    2ad0:	ca f7       	brpl	.-14     	; 0x2ac4 <__divsf3_pse+0x2c>
    2ad2:	29 d0       	rcall	.+82     	; 0x2b26 <__divsf3_pse+0x8e>
    2ad4:	fe 2f       	mov	r31, r30
    2ad6:	27 d0       	rcall	.+78     	; 0x2b26 <__divsf3_pse+0x8e>
    2ad8:	66 0f       	add	r22, r22
    2ada:	77 1f       	adc	r23, r23
    2adc:	88 1f       	adc	r24, r24
    2ade:	bb 1f       	adc	r27, r27
    2ae0:	26 17       	cp	r18, r22
    2ae2:	37 07       	cpc	r19, r23
    2ae4:	48 07       	cpc	r20, r24
    2ae6:	ab 07       	cpc	r26, r27
    2ae8:	b0 e8       	ldi	r27, 0x80	; 128
    2aea:	09 f0       	breq	.+2      	; 0x2aee <__divsf3_pse+0x56>
    2aec:	bb 0b       	sbc	r27, r27
    2aee:	80 2d       	mov	r24, r0
    2af0:	bf 01       	movw	r22, r30
    2af2:	ff 27       	eor	r31, r31
    2af4:	93 58       	subi	r25, 0x83	; 131
    2af6:	5f 4f       	sbci	r21, 0xFF	; 255
    2af8:	2a f0       	brmi	.+10     	; 0x2b04 <__divsf3_pse+0x6c>
    2afa:	9e 3f       	cpi	r25, 0xFE	; 254
    2afc:	51 05       	cpc	r21, r1
    2afe:	68 f0       	brcs	.+26     	; 0x2b1a <__divsf3_pse+0x82>
    2b00:	b1 c0       	rjmp	.+354    	; 0x2c64 <__fp_inf>
    2b02:	fb c0       	rjmp	.+502    	; 0x2cfa <__fp_szero>
    2b04:	5f 3f       	cpi	r21, 0xFF	; 255
    2b06:	ec f3       	brlt	.-6      	; 0x2b02 <__divsf3_pse+0x6a>
    2b08:	98 3e       	cpi	r25, 0xE8	; 232
    2b0a:	dc f3       	brlt	.-10     	; 0x2b02 <__divsf3_pse+0x6a>
    2b0c:	86 95       	lsr	r24
    2b0e:	77 95       	ror	r23
    2b10:	67 95       	ror	r22
    2b12:	b7 95       	ror	r27
    2b14:	f7 95       	ror	r31
    2b16:	9f 5f       	subi	r25, 0xFF	; 255
    2b18:	c9 f7       	brne	.-14     	; 0x2b0c <__divsf3_pse+0x74>
    2b1a:	88 0f       	add	r24, r24
    2b1c:	91 1d       	adc	r25, r1
    2b1e:	96 95       	lsr	r25
    2b20:	87 95       	ror	r24
    2b22:	97 f9       	bld	r25, 7
    2b24:	08 95       	ret
    2b26:	e1 e0       	ldi	r30, 0x01	; 1
    2b28:	66 0f       	add	r22, r22
    2b2a:	77 1f       	adc	r23, r23
    2b2c:	88 1f       	adc	r24, r24
    2b2e:	bb 1f       	adc	r27, r27
    2b30:	62 17       	cp	r22, r18
    2b32:	73 07       	cpc	r23, r19
    2b34:	84 07       	cpc	r24, r20
    2b36:	ba 07       	cpc	r27, r26
    2b38:	20 f0       	brcs	.+8      	; 0x2b42 <__divsf3_pse+0xaa>
    2b3a:	62 1b       	sub	r22, r18
    2b3c:	73 0b       	sbc	r23, r19
    2b3e:	84 0b       	sbc	r24, r20
    2b40:	ba 0b       	sbc	r27, r26
    2b42:	ee 1f       	adc	r30, r30
    2b44:	88 f7       	brcc	.-30     	; 0x2b28 <__divsf3_pse+0x90>
    2b46:	e0 95       	com	r30
    2b48:	08 95       	ret

00002b4a <__fixunssfsi>:
    2b4a:	bc d0       	rcall	.+376    	; 0x2cc4 <__fp_splitA>
    2b4c:	88 f0       	brcs	.+34     	; 0x2b70 <__fixunssfsi+0x26>
    2b4e:	9f 57       	subi	r25, 0x7F	; 127
    2b50:	90 f0       	brcs	.+36     	; 0x2b76 <__fixunssfsi+0x2c>
    2b52:	b9 2f       	mov	r27, r25
    2b54:	99 27       	eor	r25, r25
    2b56:	b7 51       	subi	r27, 0x17	; 23
    2b58:	a0 f0       	brcs	.+40     	; 0x2b82 <__fixunssfsi+0x38>
    2b5a:	d1 f0       	breq	.+52     	; 0x2b90 <__fixunssfsi+0x46>
    2b5c:	66 0f       	add	r22, r22
    2b5e:	77 1f       	adc	r23, r23
    2b60:	88 1f       	adc	r24, r24
    2b62:	99 1f       	adc	r25, r25
    2b64:	1a f0       	brmi	.+6      	; 0x2b6c <__fixunssfsi+0x22>
    2b66:	ba 95       	dec	r27
    2b68:	c9 f7       	brne	.-14     	; 0x2b5c <__fixunssfsi+0x12>
    2b6a:	12 c0       	rjmp	.+36     	; 0x2b90 <__fixunssfsi+0x46>
    2b6c:	b1 30       	cpi	r27, 0x01	; 1
    2b6e:	81 f0       	breq	.+32     	; 0x2b90 <__fixunssfsi+0x46>
    2b70:	c3 d0       	rcall	.+390    	; 0x2cf8 <__fp_zero>
    2b72:	b1 e0       	ldi	r27, 0x01	; 1
    2b74:	08 95       	ret
    2b76:	c0 c0       	rjmp	.+384    	; 0x2cf8 <__fp_zero>
    2b78:	67 2f       	mov	r22, r23
    2b7a:	78 2f       	mov	r23, r24
    2b7c:	88 27       	eor	r24, r24
    2b7e:	b8 5f       	subi	r27, 0xF8	; 248
    2b80:	39 f0       	breq	.+14     	; 0x2b90 <__fixunssfsi+0x46>
    2b82:	b9 3f       	cpi	r27, 0xF9	; 249
    2b84:	cc f3       	brlt	.-14     	; 0x2b78 <__fixunssfsi+0x2e>
    2b86:	86 95       	lsr	r24
    2b88:	77 95       	ror	r23
    2b8a:	67 95       	ror	r22
    2b8c:	b3 95       	inc	r27
    2b8e:	d9 f7       	brne	.-10     	; 0x2b86 <__fixunssfsi+0x3c>
    2b90:	3e f4       	brtc	.+14     	; 0x2ba0 <__fixunssfsi+0x56>
    2b92:	90 95       	com	r25
    2b94:	80 95       	com	r24
    2b96:	70 95       	com	r23
    2b98:	61 95       	neg	r22
    2b9a:	7f 4f       	sbci	r23, 0xFF	; 255
    2b9c:	8f 4f       	sbci	r24, 0xFF	; 255
    2b9e:	9f 4f       	sbci	r25, 0xFF	; 255
    2ba0:	08 95       	ret

00002ba2 <__floatunsisf>:
    2ba2:	e8 94       	clt
    2ba4:	09 c0       	rjmp	.+18     	; 0x2bb8 <__floatsisf+0x12>

00002ba6 <__floatsisf>:
    2ba6:	97 fb       	bst	r25, 7
    2ba8:	3e f4       	brtc	.+14     	; 0x2bb8 <__floatsisf+0x12>
    2baa:	90 95       	com	r25
    2bac:	80 95       	com	r24
    2bae:	70 95       	com	r23
    2bb0:	61 95       	neg	r22
    2bb2:	7f 4f       	sbci	r23, 0xFF	; 255
    2bb4:	8f 4f       	sbci	r24, 0xFF	; 255
    2bb6:	9f 4f       	sbci	r25, 0xFF	; 255
    2bb8:	99 23       	and	r25, r25
    2bba:	a9 f0       	breq	.+42     	; 0x2be6 <__floatsisf+0x40>
    2bbc:	f9 2f       	mov	r31, r25
    2bbe:	96 e9       	ldi	r25, 0x96	; 150
    2bc0:	bb 27       	eor	r27, r27
    2bc2:	93 95       	inc	r25
    2bc4:	f6 95       	lsr	r31
    2bc6:	87 95       	ror	r24
    2bc8:	77 95       	ror	r23
    2bca:	67 95       	ror	r22
    2bcc:	b7 95       	ror	r27
    2bce:	f1 11       	cpse	r31, r1
    2bd0:	f8 cf       	rjmp	.-16     	; 0x2bc2 <__floatsisf+0x1c>
    2bd2:	fa f4       	brpl	.+62     	; 0x2c12 <__floatsisf+0x6c>
    2bd4:	bb 0f       	add	r27, r27
    2bd6:	11 f4       	brne	.+4      	; 0x2bdc <__floatsisf+0x36>
    2bd8:	60 ff       	sbrs	r22, 0
    2bda:	1b c0       	rjmp	.+54     	; 0x2c12 <__floatsisf+0x6c>
    2bdc:	6f 5f       	subi	r22, 0xFF	; 255
    2bde:	7f 4f       	sbci	r23, 0xFF	; 255
    2be0:	8f 4f       	sbci	r24, 0xFF	; 255
    2be2:	9f 4f       	sbci	r25, 0xFF	; 255
    2be4:	16 c0       	rjmp	.+44     	; 0x2c12 <__floatsisf+0x6c>
    2be6:	88 23       	and	r24, r24
    2be8:	11 f0       	breq	.+4      	; 0x2bee <__floatsisf+0x48>
    2bea:	96 e9       	ldi	r25, 0x96	; 150
    2bec:	11 c0       	rjmp	.+34     	; 0x2c10 <__floatsisf+0x6a>
    2bee:	77 23       	and	r23, r23
    2bf0:	21 f0       	breq	.+8      	; 0x2bfa <__floatsisf+0x54>
    2bf2:	9e e8       	ldi	r25, 0x8E	; 142
    2bf4:	87 2f       	mov	r24, r23
    2bf6:	76 2f       	mov	r23, r22
    2bf8:	05 c0       	rjmp	.+10     	; 0x2c04 <__floatsisf+0x5e>
    2bfa:	66 23       	and	r22, r22
    2bfc:	71 f0       	breq	.+28     	; 0x2c1a <__floatsisf+0x74>
    2bfe:	96 e8       	ldi	r25, 0x86	; 134
    2c00:	86 2f       	mov	r24, r22
    2c02:	70 e0       	ldi	r23, 0x00	; 0
    2c04:	60 e0       	ldi	r22, 0x00	; 0
    2c06:	2a f0       	brmi	.+10     	; 0x2c12 <__floatsisf+0x6c>
    2c08:	9a 95       	dec	r25
    2c0a:	66 0f       	add	r22, r22
    2c0c:	77 1f       	adc	r23, r23
    2c0e:	88 1f       	adc	r24, r24
    2c10:	da f7       	brpl	.-10     	; 0x2c08 <__floatsisf+0x62>
    2c12:	88 0f       	add	r24, r24
    2c14:	96 95       	lsr	r25
    2c16:	87 95       	ror	r24
    2c18:	97 f9       	bld	r25, 7
    2c1a:	08 95       	ret

00002c1c <__fp_cmp>:
    2c1c:	99 0f       	add	r25, r25
    2c1e:	00 08       	sbc	r0, r0
    2c20:	55 0f       	add	r21, r21
    2c22:	aa 0b       	sbc	r26, r26
    2c24:	e0 e8       	ldi	r30, 0x80	; 128
    2c26:	fe ef       	ldi	r31, 0xFE	; 254
    2c28:	16 16       	cp	r1, r22
    2c2a:	17 06       	cpc	r1, r23
    2c2c:	e8 07       	cpc	r30, r24
    2c2e:	f9 07       	cpc	r31, r25
    2c30:	c0 f0       	brcs	.+48     	; 0x2c62 <__fp_cmp+0x46>
    2c32:	12 16       	cp	r1, r18
    2c34:	13 06       	cpc	r1, r19
    2c36:	e4 07       	cpc	r30, r20
    2c38:	f5 07       	cpc	r31, r21
    2c3a:	98 f0       	brcs	.+38     	; 0x2c62 <__fp_cmp+0x46>
    2c3c:	62 1b       	sub	r22, r18
    2c3e:	73 0b       	sbc	r23, r19
    2c40:	84 0b       	sbc	r24, r20
    2c42:	95 0b       	sbc	r25, r21
    2c44:	39 f4       	brne	.+14     	; 0x2c54 <__fp_cmp+0x38>
    2c46:	0a 26       	eor	r0, r26
    2c48:	61 f0       	breq	.+24     	; 0x2c62 <__fp_cmp+0x46>
    2c4a:	23 2b       	or	r18, r19
    2c4c:	24 2b       	or	r18, r20
    2c4e:	25 2b       	or	r18, r21
    2c50:	21 f4       	brne	.+8      	; 0x2c5a <__fp_cmp+0x3e>
    2c52:	08 95       	ret
    2c54:	0a 26       	eor	r0, r26
    2c56:	09 f4       	brne	.+2      	; 0x2c5a <__fp_cmp+0x3e>
    2c58:	a1 40       	sbci	r26, 0x01	; 1
    2c5a:	a6 95       	lsr	r26
    2c5c:	8f ef       	ldi	r24, 0xFF	; 255
    2c5e:	81 1d       	adc	r24, r1
    2c60:	81 1d       	adc	r24, r1
    2c62:	08 95       	ret

00002c64 <__fp_inf>:
    2c64:	97 f9       	bld	r25, 7
    2c66:	9f 67       	ori	r25, 0x7F	; 127
    2c68:	80 e8       	ldi	r24, 0x80	; 128
    2c6a:	70 e0       	ldi	r23, 0x00	; 0
    2c6c:	60 e0       	ldi	r22, 0x00	; 0
    2c6e:	08 95       	ret

00002c70 <__fp_nan>:
    2c70:	9f ef       	ldi	r25, 0xFF	; 255
    2c72:	80 ec       	ldi	r24, 0xC0	; 192
    2c74:	08 95       	ret

00002c76 <__fp_pscA>:
    2c76:	00 24       	eor	r0, r0
    2c78:	0a 94       	dec	r0
    2c7a:	16 16       	cp	r1, r22
    2c7c:	17 06       	cpc	r1, r23
    2c7e:	18 06       	cpc	r1, r24
    2c80:	09 06       	cpc	r0, r25
    2c82:	08 95       	ret

00002c84 <__fp_pscB>:
    2c84:	00 24       	eor	r0, r0
    2c86:	0a 94       	dec	r0
    2c88:	12 16       	cp	r1, r18
    2c8a:	13 06       	cpc	r1, r19
    2c8c:	14 06       	cpc	r1, r20
    2c8e:	05 06       	cpc	r0, r21
    2c90:	08 95       	ret

00002c92 <__fp_round>:
    2c92:	09 2e       	mov	r0, r25
    2c94:	03 94       	inc	r0
    2c96:	00 0c       	add	r0, r0
    2c98:	11 f4       	brne	.+4      	; 0x2c9e <__fp_round+0xc>
    2c9a:	88 23       	and	r24, r24
    2c9c:	52 f0       	brmi	.+20     	; 0x2cb2 <__fp_round+0x20>
    2c9e:	bb 0f       	add	r27, r27
    2ca0:	40 f4       	brcc	.+16     	; 0x2cb2 <__fp_round+0x20>
    2ca2:	bf 2b       	or	r27, r31
    2ca4:	11 f4       	brne	.+4      	; 0x2caa <__fp_round+0x18>
    2ca6:	60 ff       	sbrs	r22, 0
    2ca8:	04 c0       	rjmp	.+8      	; 0x2cb2 <__fp_round+0x20>
    2caa:	6f 5f       	subi	r22, 0xFF	; 255
    2cac:	7f 4f       	sbci	r23, 0xFF	; 255
    2cae:	8f 4f       	sbci	r24, 0xFF	; 255
    2cb0:	9f 4f       	sbci	r25, 0xFF	; 255
    2cb2:	08 95       	ret

00002cb4 <__fp_split3>:
    2cb4:	57 fd       	sbrc	r21, 7
    2cb6:	90 58       	subi	r25, 0x80	; 128
    2cb8:	44 0f       	add	r20, r20
    2cba:	55 1f       	adc	r21, r21
    2cbc:	59 f0       	breq	.+22     	; 0x2cd4 <__fp_splitA+0x10>
    2cbe:	5f 3f       	cpi	r21, 0xFF	; 255
    2cc0:	71 f0       	breq	.+28     	; 0x2cde <__fp_splitA+0x1a>
    2cc2:	47 95       	ror	r20

00002cc4 <__fp_splitA>:
    2cc4:	88 0f       	add	r24, r24
    2cc6:	97 fb       	bst	r25, 7
    2cc8:	99 1f       	adc	r25, r25
    2cca:	61 f0       	breq	.+24     	; 0x2ce4 <__fp_splitA+0x20>
    2ccc:	9f 3f       	cpi	r25, 0xFF	; 255
    2cce:	79 f0       	breq	.+30     	; 0x2cee <__fp_splitA+0x2a>
    2cd0:	87 95       	ror	r24
    2cd2:	08 95       	ret
    2cd4:	12 16       	cp	r1, r18
    2cd6:	13 06       	cpc	r1, r19
    2cd8:	14 06       	cpc	r1, r20
    2cda:	55 1f       	adc	r21, r21
    2cdc:	f2 cf       	rjmp	.-28     	; 0x2cc2 <__fp_split3+0xe>
    2cde:	46 95       	lsr	r20
    2ce0:	f1 df       	rcall	.-30     	; 0x2cc4 <__fp_splitA>
    2ce2:	08 c0       	rjmp	.+16     	; 0x2cf4 <__fp_splitA+0x30>
    2ce4:	16 16       	cp	r1, r22
    2ce6:	17 06       	cpc	r1, r23
    2ce8:	18 06       	cpc	r1, r24
    2cea:	99 1f       	adc	r25, r25
    2cec:	f1 cf       	rjmp	.-30     	; 0x2cd0 <__fp_splitA+0xc>
    2cee:	86 95       	lsr	r24
    2cf0:	71 05       	cpc	r23, r1
    2cf2:	61 05       	cpc	r22, r1
    2cf4:	08 94       	sec
    2cf6:	08 95       	ret

00002cf8 <__fp_zero>:
    2cf8:	e8 94       	clt

00002cfa <__fp_szero>:
    2cfa:	bb 27       	eor	r27, r27
    2cfc:	66 27       	eor	r22, r22
    2cfe:	77 27       	eor	r23, r23
    2d00:	cb 01       	movw	r24, r22
    2d02:	97 f9       	bld	r25, 7
    2d04:	08 95       	ret

00002d06 <__gesf2>:
    2d06:	8a df       	rcall	.-236    	; 0x2c1c <__fp_cmp>
    2d08:	08 f4       	brcc	.+2      	; 0x2d0c <__gesf2+0x6>
    2d0a:	8f ef       	ldi	r24, 0xFF	; 255
    2d0c:	08 95       	ret

00002d0e <__mulsf3>:
    2d0e:	0b d0       	rcall	.+22     	; 0x2d26 <__mulsf3x>
    2d10:	c0 cf       	rjmp	.-128    	; 0x2c92 <__fp_round>
    2d12:	b1 df       	rcall	.-158    	; 0x2c76 <__fp_pscA>
    2d14:	28 f0       	brcs	.+10     	; 0x2d20 <__mulsf3+0x12>
    2d16:	b6 df       	rcall	.-148    	; 0x2c84 <__fp_pscB>
    2d18:	18 f0       	brcs	.+6      	; 0x2d20 <__mulsf3+0x12>
    2d1a:	95 23       	and	r25, r21
    2d1c:	09 f0       	breq	.+2      	; 0x2d20 <__mulsf3+0x12>
    2d1e:	a2 cf       	rjmp	.-188    	; 0x2c64 <__fp_inf>
    2d20:	a7 cf       	rjmp	.-178    	; 0x2c70 <__fp_nan>
    2d22:	11 24       	eor	r1, r1
    2d24:	ea cf       	rjmp	.-44     	; 0x2cfa <__fp_szero>

00002d26 <__mulsf3x>:
    2d26:	c6 df       	rcall	.-116    	; 0x2cb4 <__fp_split3>
    2d28:	a0 f3       	brcs	.-24     	; 0x2d12 <__mulsf3+0x4>

00002d2a <__mulsf3_pse>:
    2d2a:	95 9f       	mul	r25, r21
    2d2c:	d1 f3       	breq	.-12     	; 0x2d22 <__mulsf3+0x14>
    2d2e:	95 0f       	add	r25, r21
    2d30:	50 e0       	ldi	r21, 0x00	; 0
    2d32:	55 1f       	adc	r21, r21
    2d34:	62 9f       	mul	r22, r18
    2d36:	f0 01       	movw	r30, r0
    2d38:	72 9f       	mul	r23, r18
    2d3a:	bb 27       	eor	r27, r27
    2d3c:	f0 0d       	add	r31, r0
    2d3e:	b1 1d       	adc	r27, r1
    2d40:	63 9f       	mul	r22, r19
    2d42:	aa 27       	eor	r26, r26
    2d44:	f0 0d       	add	r31, r0
    2d46:	b1 1d       	adc	r27, r1
    2d48:	aa 1f       	adc	r26, r26
    2d4a:	64 9f       	mul	r22, r20
    2d4c:	66 27       	eor	r22, r22
    2d4e:	b0 0d       	add	r27, r0
    2d50:	a1 1d       	adc	r26, r1
    2d52:	66 1f       	adc	r22, r22
    2d54:	82 9f       	mul	r24, r18
    2d56:	22 27       	eor	r18, r18
    2d58:	b0 0d       	add	r27, r0
    2d5a:	a1 1d       	adc	r26, r1
    2d5c:	62 1f       	adc	r22, r18
    2d5e:	73 9f       	mul	r23, r19
    2d60:	b0 0d       	add	r27, r0
    2d62:	a1 1d       	adc	r26, r1
    2d64:	62 1f       	adc	r22, r18
    2d66:	83 9f       	mul	r24, r19
    2d68:	a0 0d       	add	r26, r0
    2d6a:	61 1d       	adc	r22, r1
    2d6c:	22 1f       	adc	r18, r18
    2d6e:	74 9f       	mul	r23, r20
    2d70:	33 27       	eor	r19, r19
    2d72:	a0 0d       	add	r26, r0
    2d74:	61 1d       	adc	r22, r1
    2d76:	23 1f       	adc	r18, r19
    2d78:	84 9f       	mul	r24, r20
    2d7a:	60 0d       	add	r22, r0
    2d7c:	21 1d       	adc	r18, r1
    2d7e:	82 2f       	mov	r24, r18
    2d80:	76 2f       	mov	r23, r22
    2d82:	6a 2f       	mov	r22, r26
    2d84:	11 24       	eor	r1, r1
    2d86:	9f 57       	subi	r25, 0x7F	; 127
    2d88:	50 40       	sbci	r21, 0x00	; 0
    2d8a:	8a f0       	brmi	.+34     	; 0x2dae <__mulsf3_pse+0x84>
    2d8c:	e1 f0       	breq	.+56     	; 0x2dc6 <__mulsf3_pse+0x9c>
    2d8e:	88 23       	and	r24, r24
    2d90:	4a f0       	brmi	.+18     	; 0x2da4 <__mulsf3_pse+0x7a>
    2d92:	ee 0f       	add	r30, r30
    2d94:	ff 1f       	adc	r31, r31
    2d96:	bb 1f       	adc	r27, r27
    2d98:	66 1f       	adc	r22, r22
    2d9a:	77 1f       	adc	r23, r23
    2d9c:	88 1f       	adc	r24, r24
    2d9e:	91 50       	subi	r25, 0x01	; 1
    2da0:	50 40       	sbci	r21, 0x00	; 0
    2da2:	a9 f7       	brne	.-22     	; 0x2d8e <__mulsf3_pse+0x64>
    2da4:	9e 3f       	cpi	r25, 0xFE	; 254
    2da6:	51 05       	cpc	r21, r1
    2da8:	70 f0       	brcs	.+28     	; 0x2dc6 <__mulsf3_pse+0x9c>
    2daa:	5c cf       	rjmp	.-328    	; 0x2c64 <__fp_inf>
    2dac:	a6 cf       	rjmp	.-180    	; 0x2cfa <__fp_szero>
    2dae:	5f 3f       	cpi	r21, 0xFF	; 255
    2db0:	ec f3       	brlt	.-6      	; 0x2dac <__mulsf3_pse+0x82>
    2db2:	98 3e       	cpi	r25, 0xE8	; 232
    2db4:	dc f3       	brlt	.-10     	; 0x2dac <__mulsf3_pse+0x82>
    2db6:	86 95       	lsr	r24
    2db8:	77 95       	ror	r23
    2dba:	67 95       	ror	r22
    2dbc:	b7 95       	ror	r27
    2dbe:	f7 95       	ror	r31
    2dc0:	e7 95       	ror	r30
    2dc2:	9f 5f       	subi	r25, 0xFF	; 255
    2dc4:	c1 f7       	brne	.-16     	; 0x2db6 <__mulsf3_pse+0x8c>
    2dc6:	fe 2b       	or	r31, r30
    2dc8:	88 0f       	add	r24, r24
    2dca:	91 1d       	adc	r25, r1
    2dcc:	96 95       	lsr	r25
    2dce:	87 95       	ror	r24
    2dd0:	97 f9       	bld	r25, 7
    2dd2:	08 95       	ret

00002dd4 <__tablejump2__>:
    2dd4:	ee 0f       	add	r30, r30
    2dd6:	ff 1f       	adc	r31, r31
    2dd8:	88 1f       	adc	r24, r24
    2dda:	8b bf       	out	0x3b, r24	; 59
    2ddc:	07 90       	elpm	r0, Z+
    2dde:	f6 91       	elpm	r31, Z
    2de0:	e0 2d       	mov	r30, r0
    2de2:	19 94       	eijmp

00002de4 <__umulhisi3>:
    2de4:	a2 9f       	mul	r26, r18
    2de6:	b0 01       	movw	r22, r0
    2de8:	b3 9f       	mul	r27, r19
    2dea:	c0 01       	movw	r24, r0
    2dec:	a3 9f       	mul	r26, r19
    2dee:	70 0d       	add	r23, r0
    2df0:	81 1d       	adc	r24, r1
    2df2:	11 24       	eor	r1, r1
    2df4:	91 1d       	adc	r25, r1
    2df6:	b2 9f       	mul	r27, r18
    2df8:	70 0d       	add	r23, r0
    2dfa:	81 1d       	adc	r24, r1
    2dfc:	11 24       	eor	r1, r1
    2dfe:	91 1d       	adc	r25, r1
    2e00:	08 95       	ret

00002e02 <malloc>:
    2e02:	0f 93       	push	r16
    2e04:	1f 93       	push	r17
    2e06:	cf 93       	push	r28
    2e08:	df 93       	push	r29
    2e0a:	82 30       	cpi	r24, 0x02	; 2
    2e0c:	91 05       	cpc	r25, r1
    2e0e:	10 f4       	brcc	.+4      	; 0x2e14 <malloc+0x12>
    2e10:	82 e0       	ldi	r24, 0x02	; 2
    2e12:	90 e0       	ldi	r25, 0x00	; 0
    2e14:	e0 91 31 09 	lds	r30, 0x0931	; 0x800931 <__flp>
    2e18:	f0 91 32 09 	lds	r31, 0x0932	; 0x800932 <__flp+0x1>
    2e1c:	20 e0       	ldi	r18, 0x00	; 0
    2e1e:	30 e0       	ldi	r19, 0x00	; 0
    2e20:	a0 e0       	ldi	r26, 0x00	; 0
    2e22:	b0 e0       	ldi	r27, 0x00	; 0
    2e24:	30 97       	sbiw	r30, 0x00	; 0
    2e26:	19 f1       	breq	.+70     	; 0x2e6e <malloc+0x6c>
    2e28:	40 81       	ld	r20, Z
    2e2a:	51 81       	ldd	r21, Z+1	; 0x01
    2e2c:	02 81       	ldd	r16, Z+2	; 0x02
    2e2e:	13 81       	ldd	r17, Z+3	; 0x03
    2e30:	48 17       	cp	r20, r24
    2e32:	59 07       	cpc	r21, r25
    2e34:	c8 f0       	brcs	.+50     	; 0x2e68 <malloc+0x66>
    2e36:	84 17       	cp	r24, r20
    2e38:	95 07       	cpc	r25, r21
    2e3a:	69 f4       	brne	.+26     	; 0x2e56 <malloc+0x54>
    2e3c:	10 97       	sbiw	r26, 0x00	; 0
    2e3e:	31 f0       	breq	.+12     	; 0x2e4c <malloc+0x4a>
    2e40:	12 96       	adiw	r26, 0x02	; 2
    2e42:	0c 93       	st	X, r16
    2e44:	12 97       	sbiw	r26, 0x02	; 2
    2e46:	13 96       	adiw	r26, 0x03	; 3
    2e48:	1c 93       	st	X, r17
    2e4a:	27 c0       	rjmp	.+78     	; 0x2e9a <malloc+0x98>
    2e4c:	00 93 31 09 	sts	0x0931, r16	; 0x800931 <__flp>
    2e50:	10 93 32 09 	sts	0x0932, r17	; 0x800932 <__flp+0x1>
    2e54:	22 c0       	rjmp	.+68     	; 0x2e9a <malloc+0x98>
    2e56:	21 15       	cp	r18, r1
    2e58:	31 05       	cpc	r19, r1
    2e5a:	19 f0       	breq	.+6      	; 0x2e62 <malloc+0x60>
    2e5c:	42 17       	cp	r20, r18
    2e5e:	53 07       	cpc	r21, r19
    2e60:	18 f4       	brcc	.+6      	; 0x2e68 <malloc+0x66>
    2e62:	9a 01       	movw	r18, r20
    2e64:	bd 01       	movw	r22, r26
    2e66:	ef 01       	movw	r28, r30
    2e68:	df 01       	movw	r26, r30
    2e6a:	f8 01       	movw	r30, r16
    2e6c:	db cf       	rjmp	.-74     	; 0x2e24 <malloc+0x22>
    2e6e:	21 15       	cp	r18, r1
    2e70:	31 05       	cpc	r19, r1
    2e72:	f9 f0       	breq	.+62     	; 0x2eb2 <malloc+0xb0>
    2e74:	28 1b       	sub	r18, r24
    2e76:	39 0b       	sbc	r19, r25
    2e78:	24 30       	cpi	r18, 0x04	; 4
    2e7a:	31 05       	cpc	r19, r1
    2e7c:	80 f4       	brcc	.+32     	; 0x2e9e <malloc+0x9c>
    2e7e:	8a 81       	ldd	r24, Y+2	; 0x02
    2e80:	9b 81       	ldd	r25, Y+3	; 0x03
    2e82:	61 15       	cp	r22, r1
    2e84:	71 05       	cpc	r23, r1
    2e86:	21 f0       	breq	.+8      	; 0x2e90 <malloc+0x8e>
    2e88:	fb 01       	movw	r30, r22
    2e8a:	93 83       	std	Z+3, r25	; 0x03
    2e8c:	82 83       	std	Z+2, r24	; 0x02
    2e8e:	04 c0       	rjmp	.+8      	; 0x2e98 <malloc+0x96>
    2e90:	90 93 32 09 	sts	0x0932, r25	; 0x800932 <__flp+0x1>
    2e94:	80 93 31 09 	sts	0x0931, r24	; 0x800931 <__flp>
    2e98:	fe 01       	movw	r30, r28
    2e9a:	32 96       	adiw	r30, 0x02	; 2
    2e9c:	44 c0       	rjmp	.+136    	; 0x2f26 <malloc+0x124>
    2e9e:	fe 01       	movw	r30, r28
    2ea0:	e2 0f       	add	r30, r18
    2ea2:	f3 1f       	adc	r31, r19
    2ea4:	81 93       	st	Z+, r24
    2ea6:	91 93       	st	Z+, r25
    2ea8:	22 50       	subi	r18, 0x02	; 2
    2eaa:	31 09       	sbc	r19, r1
    2eac:	39 83       	std	Y+1, r19	; 0x01
    2eae:	28 83       	st	Y, r18
    2eb0:	3a c0       	rjmp	.+116    	; 0x2f26 <malloc+0x124>
    2eb2:	20 91 2f 09 	lds	r18, 0x092F	; 0x80092f <__brkval>
    2eb6:	30 91 30 09 	lds	r19, 0x0930	; 0x800930 <__brkval+0x1>
    2eba:	23 2b       	or	r18, r19
    2ebc:	41 f4       	brne	.+16     	; 0x2ece <malloc+0xcc>
    2ebe:	20 91 02 02 	lds	r18, 0x0202	; 0x800202 <__malloc_heap_start>
    2ec2:	30 91 03 02 	lds	r19, 0x0203	; 0x800203 <__malloc_heap_start+0x1>
    2ec6:	30 93 30 09 	sts	0x0930, r19	; 0x800930 <__brkval+0x1>
    2eca:	20 93 2f 09 	sts	0x092F, r18	; 0x80092f <__brkval>
    2ece:	20 91 00 02 	lds	r18, 0x0200	; 0x800200 <__data_start>
    2ed2:	30 91 01 02 	lds	r19, 0x0201	; 0x800201 <__data_start+0x1>
    2ed6:	21 15       	cp	r18, r1
    2ed8:	31 05       	cpc	r19, r1
    2eda:	41 f4       	brne	.+16     	; 0x2eec <malloc+0xea>
    2edc:	2d b7       	in	r18, 0x3d	; 61
    2ede:	3e b7       	in	r19, 0x3e	; 62
    2ee0:	40 91 04 02 	lds	r20, 0x0204	; 0x800204 <__malloc_margin>
    2ee4:	50 91 05 02 	lds	r21, 0x0205	; 0x800205 <__malloc_margin+0x1>
    2ee8:	24 1b       	sub	r18, r20
    2eea:	35 0b       	sbc	r19, r21
    2eec:	e0 91 2f 09 	lds	r30, 0x092F	; 0x80092f <__brkval>
    2ef0:	f0 91 30 09 	lds	r31, 0x0930	; 0x800930 <__brkval+0x1>
    2ef4:	e2 17       	cp	r30, r18
    2ef6:	f3 07       	cpc	r31, r19
    2ef8:	a0 f4       	brcc	.+40     	; 0x2f22 <malloc+0x120>
    2efa:	2e 1b       	sub	r18, r30
    2efc:	3f 0b       	sbc	r19, r31
    2efe:	28 17       	cp	r18, r24
    2f00:	39 07       	cpc	r19, r25
    2f02:	78 f0       	brcs	.+30     	; 0x2f22 <malloc+0x120>
    2f04:	ac 01       	movw	r20, r24
    2f06:	4e 5f       	subi	r20, 0xFE	; 254
    2f08:	5f 4f       	sbci	r21, 0xFF	; 255
    2f0a:	24 17       	cp	r18, r20
    2f0c:	35 07       	cpc	r19, r21
    2f0e:	48 f0       	brcs	.+18     	; 0x2f22 <malloc+0x120>
    2f10:	4e 0f       	add	r20, r30
    2f12:	5f 1f       	adc	r21, r31
    2f14:	50 93 30 09 	sts	0x0930, r21	; 0x800930 <__brkval+0x1>
    2f18:	40 93 2f 09 	sts	0x092F, r20	; 0x80092f <__brkval>
    2f1c:	81 93       	st	Z+, r24
    2f1e:	91 93       	st	Z+, r25
    2f20:	02 c0       	rjmp	.+4      	; 0x2f26 <malloc+0x124>
    2f22:	e0 e0       	ldi	r30, 0x00	; 0
    2f24:	f0 e0       	ldi	r31, 0x00	; 0
    2f26:	cf 01       	movw	r24, r30
    2f28:	df 91       	pop	r29
    2f2a:	cf 91       	pop	r28
    2f2c:	1f 91       	pop	r17
    2f2e:	0f 91       	pop	r16
    2f30:	08 95       	ret

00002f32 <free>:
    2f32:	cf 93       	push	r28
    2f34:	df 93       	push	r29
    2f36:	00 97       	sbiw	r24, 0x00	; 0
    2f38:	09 f4       	brne	.+2      	; 0x2f3c <free+0xa>
    2f3a:	81 c0       	rjmp	.+258    	; 0x303e <free+0x10c>
    2f3c:	fc 01       	movw	r30, r24
    2f3e:	32 97       	sbiw	r30, 0x02	; 2
    2f40:	13 82       	std	Z+3, r1	; 0x03
    2f42:	12 82       	std	Z+2, r1	; 0x02
    2f44:	a0 91 31 09 	lds	r26, 0x0931	; 0x800931 <__flp>
    2f48:	b0 91 32 09 	lds	r27, 0x0932	; 0x800932 <__flp+0x1>
    2f4c:	10 97       	sbiw	r26, 0x00	; 0
    2f4e:	81 f4       	brne	.+32     	; 0x2f70 <free+0x3e>
    2f50:	20 81       	ld	r18, Z
    2f52:	31 81       	ldd	r19, Z+1	; 0x01
    2f54:	82 0f       	add	r24, r18
    2f56:	93 1f       	adc	r25, r19
    2f58:	20 91 2f 09 	lds	r18, 0x092F	; 0x80092f <__brkval>
    2f5c:	30 91 30 09 	lds	r19, 0x0930	; 0x800930 <__brkval+0x1>
    2f60:	28 17       	cp	r18, r24
    2f62:	39 07       	cpc	r19, r25
    2f64:	51 f5       	brne	.+84     	; 0x2fba <free+0x88>
    2f66:	f0 93 30 09 	sts	0x0930, r31	; 0x800930 <__brkval+0x1>
    2f6a:	e0 93 2f 09 	sts	0x092F, r30	; 0x80092f <__brkval>
    2f6e:	67 c0       	rjmp	.+206    	; 0x303e <free+0x10c>
    2f70:	ed 01       	movw	r28, r26
    2f72:	20 e0       	ldi	r18, 0x00	; 0
    2f74:	30 e0       	ldi	r19, 0x00	; 0
    2f76:	ce 17       	cp	r28, r30
    2f78:	df 07       	cpc	r29, r31
    2f7a:	40 f4       	brcc	.+16     	; 0x2f8c <free+0x5a>
    2f7c:	4a 81       	ldd	r20, Y+2	; 0x02
    2f7e:	5b 81       	ldd	r21, Y+3	; 0x03
    2f80:	9e 01       	movw	r18, r28
    2f82:	41 15       	cp	r20, r1
    2f84:	51 05       	cpc	r21, r1
    2f86:	f1 f0       	breq	.+60     	; 0x2fc4 <free+0x92>
    2f88:	ea 01       	movw	r28, r20
    2f8a:	f5 cf       	rjmp	.-22     	; 0x2f76 <free+0x44>
    2f8c:	d3 83       	std	Z+3, r29	; 0x03
    2f8e:	c2 83       	std	Z+2, r28	; 0x02
    2f90:	40 81       	ld	r20, Z
    2f92:	51 81       	ldd	r21, Z+1	; 0x01
    2f94:	84 0f       	add	r24, r20
    2f96:	95 1f       	adc	r25, r21
    2f98:	c8 17       	cp	r28, r24
    2f9a:	d9 07       	cpc	r29, r25
    2f9c:	59 f4       	brne	.+22     	; 0x2fb4 <free+0x82>
    2f9e:	88 81       	ld	r24, Y
    2fa0:	99 81       	ldd	r25, Y+1	; 0x01
    2fa2:	84 0f       	add	r24, r20
    2fa4:	95 1f       	adc	r25, r21
    2fa6:	02 96       	adiw	r24, 0x02	; 2
    2fa8:	91 83       	std	Z+1, r25	; 0x01
    2faa:	80 83       	st	Z, r24
    2fac:	8a 81       	ldd	r24, Y+2	; 0x02
    2fae:	9b 81       	ldd	r25, Y+3	; 0x03
    2fb0:	93 83       	std	Z+3, r25	; 0x03
    2fb2:	82 83       	std	Z+2, r24	; 0x02
    2fb4:	21 15       	cp	r18, r1
    2fb6:	31 05       	cpc	r19, r1
    2fb8:	29 f4       	brne	.+10     	; 0x2fc4 <free+0x92>
    2fba:	f0 93 32 09 	sts	0x0932, r31	; 0x800932 <__flp+0x1>
    2fbe:	e0 93 31 09 	sts	0x0931, r30	; 0x800931 <__flp>
    2fc2:	3d c0       	rjmp	.+122    	; 0x303e <free+0x10c>
    2fc4:	e9 01       	movw	r28, r18
    2fc6:	fb 83       	std	Y+3, r31	; 0x03
    2fc8:	ea 83       	std	Y+2, r30	; 0x02
    2fca:	49 91       	ld	r20, Y+
    2fcc:	59 91       	ld	r21, Y+
    2fce:	c4 0f       	add	r28, r20
    2fd0:	d5 1f       	adc	r29, r21
    2fd2:	ec 17       	cp	r30, r28
    2fd4:	fd 07       	cpc	r31, r29
    2fd6:	61 f4       	brne	.+24     	; 0x2ff0 <free+0xbe>
    2fd8:	80 81       	ld	r24, Z
    2fda:	91 81       	ldd	r25, Z+1	; 0x01
    2fdc:	84 0f       	add	r24, r20
    2fde:	95 1f       	adc	r25, r21
    2fe0:	02 96       	adiw	r24, 0x02	; 2
    2fe2:	e9 01       	movw	r28, r18
    2fe4:	99 83       	std	Y+1, r25	; 0x01
    2fe6:	88 83       	st	Y, r24
    2fe8:	82 81       	ldd	r24, Z+2	; 0x02
    2fea:	93 81       	ldd	r25, Z+3	; 0x03
    2fec:	9b 83       	std	Y+3, r25	; 0x03
    2fee:	8a 83       	std	Y+2, r24	; 0x02
    2ff0:	e0 e0       	ldi	r30, 0x00	; 0
    2ff2:	f0 e0       	ldi	r31, 0x00	; 0
    2ff4:	12 96       	adiw	r26, 0x02	; 2
    2ff6:	8d 91       	ld	r24, X+
    2ff8:	9c 91       	ld	r25, X
    2ffa:	13 97       	sbiw	r26, 0x03	; 3
    2ffc:	00 97       	sbiw	r24, 0x00	; 0
    2ffe:	19 f0       	breq	.+6      	; 0x3006 <free+0xd4>
    3000:	fd 01       	movw	r30, r26
    3002:	dc 01       	movw	r26, r24
    3004:	f7 cf       	rjmp	.-18     	; 0x2ff4 <free+0xc2>
    3006:	8d 91       	ld	r24, X+
    3008:	9c 91       	ld	r25, X
    300a:	11 97       	sbiw	r26, 0x01	; 1
    300c:	9d 01       	movw	r18, r26
    300e:	2e 5f       	subi	r18, 0xFE	; 254
    3010:	3f 4f       	sbci	r19, 0xFF	; 255
    3012:	82 0f       	add	r24, r18
    3014:	93 1f       	adc	r25, r19
    3016:	20 91 2f 09 	lds	r18, 0x092F	; 0x80092f <__brkval>
    301a:	30 91 30 09 	lds	r19, 0x0930	; 0x800930 <__brkval+0x1>
    301e:	28 17       	cp	r18, r24
    3020:	39 07       	cpc	r19, r25
    3022:	69 f4       	brne	.+26     	; 0x303e <free+0x10c>
    3024:	30 97       	sbiw	r30, 0x00	; 0
    3026:	29 f4       	brne	.+10     	; 0x3032 <free+0x100>
    3028:	10 92 32 09 	sts	0x0932, r1	; 0x800932 <__flp+0x1>
    302c:	10 92 31 09 	sts	0x0931, r1	; 0x800931 <__flp>
    3030:	02 c0       	rjmp	.+4      	; 0x3036 <free+0x104>
    3032:	13 82       	std	Z+3, r1	; 0x03
    3034:	12 82       	std	Z+2, r1	; 0x02
    3036:	b0 93 30 09 	sts	0x0930, r27	; 0x800930 <__brkval+0x1>
    303a:	a0 93 2f 09 	sts	0x092F, r26	; 0x80092f <__brkval>
    303e:	df 91       	pop	r29
    3040:	cf 91       	pop	r28
    3042:	08 95       	ret

00003044 <memset>:
    3044:	dc 01       	movw	r26, r24
    3046:	01 c0       	rjmp	.+2      	; 0x304a <memset+0x6>
    3048:	6d 93       	st	X+, r22
    304a:	41 50       	subi	r20, 0x01	; 1
    304c:	50 40       	sbci	r21, 0x00	; 0
    304e:	e0 f7       	brcc	.-8      	; 0x3048 <memset+0x4>
    3050:	08 95       	ret

00003052 <strncpy>:
    3052:	fb 01       	movw	r30, r22
    3054:	dc 01       	movw	r26, r24
    3056:	41 50       	subi	r20, 0x01	; 1
    3058:	50 40       	sbci	r21, 0x00	; 0
    305a:	48 f0       	brcs	.+18     	; 0x306e <strncpy+0x1c>
    305c:	01 90       	ld	r0, Z+
    305e:	0d 92       	st	X+, r0
    3060:	00 20       	and	r0, r0
    3062:	c9 f7       	brne	.-14     	; 0x3056 <strncpy+0x4>
    3064:	01 c0       	rjmp	.+2      	; 0x3068 <strncpy+0x16>
    3066:	1d 92       	st	X+, r1
    3068:	41 50       	subi	r20, 0x01	; 1
    306a:	50 40       	sbci	r21, 0x00	; 0
    306c:	e0 f7       	brcc	.-8      	; 0x3066 <strncpy+0x14>
    306e:	08 95       	ret

00003070 <__do_global_dtors>:
    3070:	10 e0       	ldi	r17, 0x00	; 0
    3072:	cb ee       	ldi	r28, 0xEB	; 235
    3074:	d0 e0       	ldi	r29, 0x00	; 0
    3076:	00 e0       	ldi	r16, 0x00	; 0
    3078:	05 c0       	rjmp	.+10     	; 0x3084 <__do_global_dtors+0x14>
    307a:	80 2f       	mov	r24, r16
    307c:	fe 01       	movw	r30, r28
    307e:	aa de       	rcall	.-684    	; 0x2dd4 <__tablejump2__>
    3080:	21 96       	adiw	r28, 0x01	; 1
    3082:	01 1d       	adc	r16, r1
    3084:	cc 3e       	cpi	r28, 0xEC	; 236
    3086:	d1 07       	cpc	r29, r17
    3088:	80 e0       	ldi	r24, 0x00	; 0
    308a:	08 07       	cpc	r16, r24
    308c:	b1 f7       	brne	.-20     	; 0x307a <__do_global_dtors+0xa>
    308e:	f8 94       	cli

00003090 <__stop_program>:
    3090:	ff cf       	rjmp	.-2      	; 0x3090 <__stop_program>
