
RobotSorter.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000000cc  00800200  000025e8  0000267c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000025e8  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000061f  008002cc  008002cc  00002748  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00002748  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00002778  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000568  00000000  00000000  000027b8  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000751a  00000000  00000000  00002d20  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00003088  00000000  00000000  0000a23a  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00002f7e  00000000  00000000  0000d2c2  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000f84  00000000  00000000  00010240  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00001c91  00000000  00000000  000111c4  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000036ef  00000000  00000000  00012e55  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000478  00000000  00000000  00016544  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	71 c0       	rjmp	.+226    	; 0xe4 <__ctors_end>
       2:	00 00       	nop
       4:	8f c0       	rjmp	.+286    	; 0x124 <__bad_interrupt>
       6:	00 00       	nop
       8:	8d c0       	rjmp	.+282    	; 0x124 <__bad_interrupt>
       a:	00 00       	nop
       c:	8b c0       	rjmp	.+278    	; 0x124 <__bad_interrupt>
       e:	00 00       	nop
      10:	89 c0       	rjmp	.+274    	; 0x124 <__bad_interrupt>
      12:	00 00       	nop
      14:	87 c0       	rjmp	.+270    	; 0x124 <__bad_interrupt>
      16:	00 00       	nop
      18:	85 c0       	rjmp	.+266    	; 0x124 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	83 c0       	rjmp	.+262    	; 0x124 <__bad_interrupt>
      1e:	00 00       	nop
      20:	81 c0       	rjmp	.+258    	; 0x124 <__bad_interrupt>
      22:	00 00       	nop
      24:	7f c0       	rjmp	.+254    	; 0x124 <__bad_interrupt>
      26:	00 00       	nop
      28:	7d c0       	rjmp	.+250    	; 0x124 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	7b c0       	rjmp	.+246    	; 0x124 <__bad_interrupt>
      2e:	00 00       	nop
      30:	79 c0       	rjmp	.+242    	; 0x124 <__bad_interrupt>
      32:	00 00       	nop
      34:	77 c0       	rjmp	.+238    	; 0x124 <__bad_interrupt>
      36:	00 00       	nop
      38:	75 c0       	rjmp	.+234    	; 0x124 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	73 c0       	rjmp	.+230    	; 0x124 <__bad_interrupt>
      3e:	00 00       	nop
      40:	71 c0       	rjmp	.+226    	; 0x124 <__bad_interrupt>
      42:	00 00       	nop
      44:	6f c0       	rjmp	.+222    	; 0x124 <__bad_interrupt>
      46:	00 00       	nop
      48:	6d c0       	rjmp	.+218    	; 0x124 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	6b c0       	rjmp	.+214    	; 0x124 <__bad_interrupt>
      4e:	00 00       	nop
      50:	69 c0       	rjmp	.+210    	; 0x124 <__bad_interrupt>
      52:	00 00       	nop
      54:	0c 94 28 0c 	jmp	0x1850	; 0x1850 <__vector_21>
      58:	65 c0       	rjmp	.+202    	; 0x124 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	63 c0       	rjmp	.+198    	; 0x124 <__bad_interrupt>
      5e:	00 00       	nop
      60:	61 c0       	rjmp	.+194    	; 0x124 <__bad_interrupt>
      62:	00 00       	nop
      64:	5f c0       	rjmp	.+190    	; 0x124 <__bad_interrupt>
      66:	00 00       	nop
      68:	5d c0       	rjmp	.+186    	; 0x124 <__bad_interrupt>
      6a:	00 00       	nop
      6c:	5b c0       	rjmp	.+182    	; 0x124 <__bad_interrupt>
      6e:	00 00       	nop
      70:	59 c0       	rjmp	.+178    	; 0x124 <__bad_interrupt>
      72:	00 00       	nop
      74:	57 c0       	rjmp	.+174    	; 0x124 <__bad_interrupt>
      76:	00 00       	nop
      78:	55 c0       	rjmp	.+170    	; 0x124 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	53 c0       	rjmp	.+166    	; 0x124 <__bad_interrupt>
      7e:	00 00       	nop
      80:	51 c0       	rjmp	.+162    	; 0x124 <__bad_interrupt>
      82:	00 00       	nop
      84:	4f c0       	rjmp	.+158    	; 0x124 <__bad_interrupt>
      86:	00 00       	nop
      88:	4d c0       	rjmp	.+154    	; 0x124 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	4b c0       	rjmp	.+150    	; 0x124 <__bad_interrupt>
      8e:	00 00       	nop
      90:	49 c0       	rjmp	.+146    	; 0x124 <__bad_interrupt>
      92:	00 00       	nop
      94:	47 c0       	rjmp	.+142    	; 0x124 <__bad_interrupt>
      96:	00 00       	nop
      98:	45 c0       	rjmp	.+138    	; 0x124 <__bad_interrupt>
      9a:	00 00       	nop
      9c:	43 c0       	rjmp	.+134    	; 0x124 <__bad_interrupt>
      9e:	00 00       	nop
      a0:	41 c0       	rjmp	.+130    	; 0x124 <__bad_interrupt>
      a2:	00 00       	nop
      a4:	f6 c1       	rjmp	.+1004   	; 0x492 <__vector_41>
      a6:	00 00       	nop
      a8:	3d c0       	rjmp	.+122    	; 0x124 <__bad_interrupt>
      aa:	00 00       	nop
      ac:	3b c0       	rjmp	.+118    	; 0x124 <__bad_interrupt>
      ae:	00 00       	nop
      b0:	39 c0       	rjmp	.+114    	; 0x124 <__bad_interrupt>
      b2:	00 00       	nop
      b4:	c9 c1       	rjmp	.+914    	; 0x448 <__vector_45>
      b6:	00 00       	nop
      b8:	35 c0       	rjmp	.+106    	; 0x124 <__bad_interrupt>
      ba:	00 00       	nop
      bc:	33 c0       	rjmp	.+102    	; 0x124 <__bad_interrupt>
      be:	00 00       	nop
      c0:	31 c0       	rjmp	.+98     	; 0x124 <__bad_interrupt>
      c2:	00 00       	nop
      c4:	2f c0       	rjmp	.+94     	; 0x124 <__bad_interrupt>
      c6:	00 00       	nop
      c8:	2d c0       	rjmp	.+90     	; 0x124 <__bad_interrupt>
      ca:	00 00       	nop
      cc:	2b c0       	rjmp	.+86     	; 0x124 <__bad_interrupt>
      ce:	00 00       	nop
      d0:	29 c0       	rjmp	.+82     	; 0x124 <__bad_interrupt>
      d2:	00 00       	nop
      d4:	27 c0       	rjmp	.+78     	; 0x124 <__bad_interrupt>
      d6:	00 00       	nop
      d8:	25 c0       	rjmp	.+74     	; 0x124 <__bad_interrupt>
      da:	00 00       	nop
      dc:	23 c0       	rjmp	.+70     	; 0x124 <__bad_interrupt>
      de:	00 00       	nop
      e0:	21 c0       	rjmp	.+66     	; 0x124 <__bad_interrupt>
	...

000000e4 <__ctors_end>:
      e4:	11 24       	eor	r1, r1
      e6:	1f be       	out	0x3f, r1	; 63
      e8:	cf ef       	ldi	r28, 0xFF	; 255
      ea:	d1 e2       	ldi	r29, 0x21	; 33
      ec:	de bf       	out	0x3e, r29	; 62
      ee:	cd bf       	out	0x3d, r28	; 61
      f0:	00 e0       	ldi	r16, 0x00	; 0
      f2:	0c bf       	out	0x3c, r16	; 60

000000f4 <__do_copy_data>:
      f4:	12 e0       	ldi	r17, 0x02	; 2
      f6:	a0 e0       	ldi	r26, 0x00	; 0
      f8:	b2 e0       	ldi	r27, 0x02	; 2
      fa:	e8 ee       	ldi	r30, 0xE8	; 232
      fc:	f5 e2       	ldi	r31, 0x25	; 37
      fe:	00 e0       	ldi	r16, 0x00	; 0
     100:	0b bf       	out	0x3b, r16	; 59
     102:	02 c0       	rjmp	.+4      	; 0x108 <__do_copy_data+0x14>
     104:	07 90       	elpm	r0, Z+
     106:	0d 92       	st	X+, r0
     108:	ac 3c       	cpi	r26, 0xCC	; 204
     10a:	b1 07       	cpc	r27, r17
     10c:	d9 f7       	brne	.-10     	; 0x104 <__do_copy_data+0x10>

0000010e <__do_clear_bss>:
     10e:	28 e0       	ldi	r18, 0x08	; 8
     110:	ac ec       	ldi	r26, 0xCC	; 204
     112:	b2 e0       	ldi	r27, 0x02	; 2
     114:	01 c0       	rjmp	.+2      	; 0x118 <.do_clear_bss_start>

00000116 <.do_clear_bss_loop>:
     116:	1d 92       	st	X+, r1

00000118 <.do_clear_bss_start>:
     118:	ab 3e       	cpi	r26, 0xEB	; 235
     11a:	b2 07       	cpc	r27, r18
     11c:	e1 f7       	brne	.-8      	; 0x116 <.do_clear_bss_loop>
     11e:	fe d2       	rcall	.+1532   	; 0x71c <main>
     120:	0c 94 f2 12 	jmp	0x25e4	; 0x25e4 <_exit>

00000124 <__bad_interrupt>:
     124:	6d cf       	rjmp	.-294    	; 0x0 <__vectors>

00000126 <_ZN5ColorC1Ev>:
	_greenPeriod = greenPeriod;
}

void Color::setWhitePeriod( uint16_t whitePeriod )
{
	_whitePeriod = whitePeriod;
     126:	08 95       	ret

00000128 <_ZN5Color12getRedPeriodEv>:
     128:	fc 01       	movw	r30, r24
     12a:	80 81       	ld	r24, Z
     12c:	91 81       	ldd	r25, Z+1	; 0x01
     12e:	08 95       	ret

00000130 <_ZN5Color13getBluePeriodEv>:
     130:	fc 01       	movw	r30, r24
     132:	82 81       	ldd	r24, Z+2	; 0x02
     134:	93 81       	ldd	r25, Z+3	; 0x03
     136:	08 95       	ret

00000138 <_ZN5Color14getGreenPeriodEv>:
     138:	fc 01       	movw	r30, r24
     13a:	84 81       	ldd	r24, Z+4	; 0x04
     13c:	95 81       	ldd	r25, Z+5	; 0x05
     13e:	08 95       	ret

00000140 <_ZN5Color12setRedPeriodEj>:
     140:	fc 01       	movw	r30, r24
     142:	71 83       	std	Z+1, r23	; 0x01
     144:	60 83       	st	Z, r22
     146:	08 95       	ret

00000148 <_ZN5Color13setBluePeriodEj>:
     148:	fc 01       	movw	r30, r24
     14a:	73 83       	std	Z+3, r23	; 0x03
     14c:	62 83       	std	Z+2, r22	; 0x02
     14e:	08 95       	ret

00000150 <_ZN5Color14setGreenPeriodEj>:
     150:	fc 01       	movw	r30, r24
     152:	75 83       	std	Z+5, r23	; 0x05
     154:	64 83       	std	Z+4, r22	; 0x04
     156:	08 95       	ret

00000158 <_ZN5Color13setColorIndexEh>:
}

void Color::setColorIndex( uint8_t index )
{
	_colorIndex = index;
     158:	fc 01       	movw	r30, r24
     15a:	60 87       	std	Z+8, r22	; 0x08
     15c:	08 95       	ret

0000015e <_ZN11ColorSensor9setFilterE6Filter>:
	}
}

void ColorSensor::setFilter( Filter filter_ )
{
	switch ( filter_ )
     15e:	61 30       	cpi	r22, 0x01	; 1
     160:	31 f0       	breq	.+12     	; 0x16e <_ZN11ColorSensor9setFilterE6Filter+0x10>
     162:	d0 f0       	brcs	.+52     	; 0x198 <_ZN11ColorSensor9setFilterE6Filter+0x3a>
     164:	62 30       	cpi	r22, 0x02	; 2
     166:	89 f0       	breq	.+34     	; 0x18a <_ZN11ColorSensor9setFilterE6Filter+0x2c>
     168:	63 30       	cpi	r22, 0x03	; 3
     16a:	41 f0       	breq	.+16     	; 0x17c <_ZN11ColorSensor9setFilterE6Filter+0x1e>
     16c:	08 95       	ret
	{
	case redFilter:
		COLORSENSOR_S2_PORT &= ~( COLORSENSOR_S2_PIN );
     16e:	88 b1       	in	r24, 0x08	; 8
     170:	8b 7f       	andi	r24, 0xFB	; 251
     172:	88 b9       	out	0x08, r24	; 8
		COLORSENSOR_S3_PORT &= ~( COLORSENSOR_S3_PIN );
     174:	88 b1       	in	r24, 0x08	; 8
     176:	87 7f       	andi	r24, 0xF7	; 247
     178:	88 b9       	out	0x08, r24	; 8
		break;
     17a:	08 95       	ret

	case blueFilter:
		COLORSENSOR_S2_PORT &= ~( COLORSENSOR_S2_PIN );
     17c:	88 b1       	in	r24, 0x08	; 8
     17e:	8b 7f       	andi	r24, 0xFB	; 251
     180:	88 b9       	out	0x08, r24	; 8
		COLORSENSOR_S3_PORT |= COLORSENSOR_S3_PIN;
     182:	88 b1       	in	r24, 0x08	; 8
     184:	88 60       	ori	r24, 0x08	; 8
     186:	88 b9       	out	0x08, r24	; 8
		break;
     188:	08 95       	ret

	case greenFilter:
		COLORSENSOR_S2_PORT |= COLORSENSOR_S2_PIN;
     18a:	88 b1       	in	r24, 0x08	; 8
     18c:	84 60       	ori	r24, 0x04	; 4
     18e:	88 b9       	out	0x08, r24	; 8
		COLORSENSOR_S3_PORT |= COLORSENSOR_S3_PIN;
     190:	88 b1       	in	r24, 0x08	; 8
     192:	88 60       	ori	r24, 0x08	; 8
     194:	88 b9       	out	0x08, r24	; 8
		break;
     196:	08 95       	ret

	case noFilter:
		COLORSENSOR_S2_PORT |= COLORSENSOR_S2_PIN;
     198:	88 b1       	in	r24, 0x08	; 8
     19a:	84 60       	ori	r24, 0x04	; 4
     19c:	88 b9       	out	0x08, r24	; 8
		COLORSENSOR_S3_PORT &= ~( COLORSENSOR_S3_PIN );
     19e:	88 b1       	in	r24, 0x08	; 8
     1a0:	87 7f       	andi	r24, 0xF7	; 247
     1a2:	88 b9       	out	0x08, r24	; 8
     1a4:	08 95       	ret

000001a6 <_ZN11ColorSensor8getColorEv>:
ColorSensor::~ColorSensor()
{	
}

uint8_t ColorSensor::getColor()
{
     1a6:	8f 92       	push	r8
     1a8:	9f 92       	push	r9
     1aa:	af 92       	push	r10
     1ac:	bf 92       	push	r11
     1ae:	cf 92       	push	r12
     1b0:	df 92       	push	r13
     1b2:	ef 92       	push	r14
     1b4:	ff 92       	push	r15
     1b6:	0f 93       	push	r16
     1b8:	1f 93       	push	r17
     1ba:	cf 93       	push	r28
     1bc:	df 93       	push	r29
     1be:	ec 01       	movw	r28, r24
	// Get period values from all filters
	setFilter( redFilter );
     1c0:	61 e0       	ldi	r22, 0x01	; 1
     1c2:	cd df       	rcall	.-102    	; 0x15e <_ZN11ColorSensor9setFilterE6Filter>
	uint16_t redPeriod = frequency_.getPeriod();
     1c4:	ce 01       	movw	r24, r28
     1c6:	0e d1       	rcall	.+540    	; 0x3e4 <_ZN6timer49getPeriodEv>
     1c8:	8c 01       	movw	r16, r24

	setFilter( blueFilter );
     1ca:	63 e0       	ldi	r22, 0x03	; 3
     1cc:	ce 01       	movw	r24, r28
	uint16_t bluePeriod = frequency_.getPeriod();  
     1ce:	c7 df       	rcall	.-114    	; 0x15e <_ZN11ColorSensor9setFilterE6Filter>
     1d0:	ce 01       	movw	r24, r28
     1d2:	08 d1       	rcall	.+528    	; 0x3e4 <_ZN6timer49getPeriodEv>

	setFilter( greenFilter );
     1d4:	7c 01       	movw	r14, r24
     1d6:	62 e0       	ldi	r22, 0x02	; 2
     1d8:	ce 01       	movw	r24, r28
	uint16_t greenPeriod = frequency_.getPeriod();
     1da:	c1 df       	rcall	.-126    	; 0x15e <_ZN11ColorSensor9setFilterE6Filter>
     1dc:	ce 01       	movw	r24, r28
     1de:	02 d1       	rcall	.+516    	; 0x3e4 <_ZN6timer49getPeriodEv>
     1e0:	6c 01       	movw	r12, r24
	
	// Check all stored colors against read values	
	for ( uint8_t index = 0U; index < 10; index++)
     1e2:	91 2c       	mov	r9, r1
     1e4:	89 e0       	ldi	r24, 0x09	; 9
     1e6:	89 15       	cp	r24, r9
     1e8:	08 f4       	brcc	.+2      	; 0x1ec <_ZN11ColorSensor8getColorEv+0x46>
     1ea:	4a c0       	rjmp	.+148    	; 0x280 <_ZN11ColorSensor8getColorEv+0xda>
	{
		//uint16_t storedRed = _colors[index].getRedPeriod();
		//uint16_t storedBlue = _colors[index].getBluePeriod();
		//uint16_t storedGreen = _colors[index].getGreenPeriod();		
		
		if ( _colors[index].getRedPeriod() + 10 > redPeriod && _colors[index].getRedPeriod() - 10 < redPeriod )
     1ec:	29 2d       	mov	r18, r9
     1ee:	30 e0       	ldi	r19, 0x00	; 0
     1f0:	59 01       	movw	r10, r18
     1f2:	aa 0c       	add	r10, r10
     1f4:	bb 1c       	adc	r11, r11
     1f6:	aa 0c       	add	r10, r10
     1f8:	bb 1c       	adc	r11, r11
     1fa:	aa 0c       	add	r10, r10
     1fc:	bb 1c       	adc	r11, r11
     1fe:	a2 0e       	add	r10, r18
     200:	b3 1e       	adc	r11, r19
     202:	8f ef       	ldi	r24, 0xFF	; 255
     204:	a8 1a       	sub	r10, r24
     206:	b8 0a       	sbc	r11, r24
     208:	ac 0e       	add	r10, r28
     20a:	bd 1e       	adc	r11, r29
     20c:	c5 01       	movw	r24, r10
     20e:	8c df       	rcall	.-232    	; 0x128 <_ZN5Color12getRedPeriodEv>
     210:	0a 96       	adiw	r24, 0x0a	; 10
     212:	08 17       	cp	r16, r24
     214:	19 07       	cpc	r17, r25
     216:	48 f4       	brcc	.+18     	; 0x22a <_ZN11ColorSensor8getColorEv+0x84>
     218:	c5 01       	movw	r24, r10
     21a:	86 df       	rcall	.-244    	; 0x128 <_ZN5Color12getRedPeriodEv>
     21c:	0a 97       	sbiw	r24, 0x0a	; 10
     21e:	80 17       	cp	r24, r16
     220:	91 07       	cpc	r25, r17
     222:	28 f4       	brcc	.+10     	; 0x22e <_ZN11ColorSensor8getColorEv+0x88>
     224:	88 24       	eor	r8, r8
     226:	83 94       	inc	r8
     228:	03 c0       	rjmp	.+6      	; 0x230 <_ZN11ColorSensor8getColorEv+0x8a>
     22a:	81 2c       	mov	r8, r1
     22c:	01 c0       	rjmp	.+2      	; 0x230 <_ZN11ColorSensor8getColorEv+0x8a>
     22e:	81 2c       	mov	r8, r1
		{
			if ( _colors[index].getBluePeriod() + 10 > bluePeriod && _colors[index].getBluePeriod() - 10 < bluePeriod )
     230:	88 20       	and	r8, r8
     232:	21 f1       	breq	.+72     	; 0x27c <_ZN11ColorSensor8getColorEv+0xd6>
     234:	c5 01       	movw	r24, r10
     236:	7c df       	rcall	.-264    	; 0x130 <_ZN5Color13getBluePeriodEv>
     238:	0a 96       	adiw	r24, 0x0a	; 10
     23a:	e8 16       	cp	r14, r24
     23c:	f9 06       	cpc	r15, r25
     23e:	38 f4       	brcc	.+14     	; 0x24e <_ZN11ColorSensor8getColorEv+0xa8>
     240:	c5 01       	movw	r24, r10
     242:	76 df       	rcall	.-276    	; 0x130 <_ZN5Color13getBluePeriodEv>
     244:	0a 97       	sbiw	r24, 0x0a	; 10
     246:	8e 15       	cp	r24, r14
     248:	9f 05       	cpc	r25, r15
     24a:	18 f4       	brcc	.+6      	; 0x252 <_ZN11ColorSensor8getColorEv+0xac>
     24c:	03 c0       	rjmp	.+6      	; 0x254 <_ZN11ColorSensor8getColorEv+0xae>
     24e:	81 2c       	mov	r8, r1
     250:	01 c0       	rjmp	.+2      	; 0x254 <_ZN11ColorSensor8getColorEv+0xae>
     252:	81 2c       	mov	r8, r1
			{
				if ( _colors[index].getGreenPeriod() + 10 > greenPeriod && _colors[index].getGreenPeriod() - 10 < greenPeriod )
     254:	88 20       	and	r8, r8
     256:	91 f0       	breq	.+36     	; 0x27c <_ZN11ColorSensor8getColorEv+0xd6>
     258:	c5 01       	movw	r24, r10
     25a:	6e df       	rcall	.-292    	; 0x138 <_ZN5Color14getGreenPeriodEv>
     25c:	0a 96       	adiw	r24, 0x0a	; 10
     25e:	c8 16       	cp	r12, r24
     260:	d9 06       	cpc	r13, r25
     262:	38 f4       	brcc	.+14     	; 0x272 <_ZN11ColorSensor8getColorEv+0xcc>
     264:	c5 01       	movw	r24, r10
     266:	68 df       	rcall	.-304    	; 0x138 <_ZN5Color14getGreenPeriodEv>
     268:	0a 97       	sbiw	r24, 0x0a	; 10
     26a:	8c 15       	cp	r24, r12
     26c:	9d 05       	cpc	r25, r13
     26e:	18 f4       	brcc	.+6      	; 0x276 <_ZN11ColorSensor8getColorEv+0xd0>
     270:	03 c0       	rjmp	.+6      	; 0x278 <_ZN11ColorSensor8getColorEv+0xd2>
     272:	81 2c       	mov	r8, r1
     274:	01 c0       	rjmp	.+2      	; 0x278 <_ZN11ColorSensor8getColorEv+0xd2>
     276:	81 2c       	mov	r8, r1
     278:	81 10       	cpse	r8, r1
     27a:	04 c0       	rjmp	.+8      	; 0x284 <_ZN11ColorSensor8getColorEv+0xde>

	setFilter( greenFilter );
	uint16_t greenPeriod = frequency_.getPeriod();
	
	// Check all stored colors against read values	
	for ( uint8_t index = 0U; index < 10; index++)
     27c:	93 94       	inc	r9
     27e:	b2 cf       	rjmp	.-156    	; 0x1e4 <_ZN11ColorSensor8getColorEv+0x3e>
			}
		}
	}
	
	// Return default value
	return 255;
     280:	8f ef       	ldi	r24, 0xFF	; 255
     282:	01 c0       	rjmp	.+2      	; 0x286 <_ZN11ColorSensor8getColorEv+0xe0>
		{
			if ( _colors[index].getBluePeriod() + 10 > bluePeriod && _colors[index].getBluePeriod() - 10 < bluePeriod )
			{
				if ( _colors[index].getGreenPeriod() + 10 > greenPeriod && _colors[index].getGreenPeriod() - 10 < greenPeriod )
				{
					return index;
     284:	89 2d       	mov	r24, r9
		}
	}
	
	// Return default value
	return 255;
}
     286:	df 91       	pop	r29
     288:	cf 91       	pop	r28
     28a:	1f 91       	pop	r17
     28c:	0f 91       	pop	r16
     28e:	ff 90       	pop	r15
     290:	ef 90       	pop	r14
     292:	df 90       	pop	r13
     294:	cf 90       	pop	r12
     296:	bf 90       	pop	r11
     298:	af 90       	pop	r10
     29a:	9f 90       	pop	r9
     29c:	8f 90       	pop	r8
     29e:	08 95       	ret

000002a0 <_ZN11ColorSensor17addCalibrateColorEh>:

void ColorSensor::addCalibrateColor( uint8_t colorIndex )
{
     2a0:	ff 92       	push	r15
     2a2:	0f 93       	push	r16
     2a4:	1f 93       	push	r17
     2a6:	cf 93       	push	r28
     2a8:	df 93       	push	r29
	if ( colorIndex < 10U )
     2aa:	6a 30       	cpi	r22, 0x0A	; 10
     2ac:	50 f5       	brcc	.+84     	; 0x302 <_ZN11ColorSensor17addCalibrateColorEh+0x62>
     2ae:	f6 2e       	mov	r15, r22
     2b0:	8c 01       	movw	r16, r24
	{	
		// Set all colors
		setFilter( redFilter );
     2b2:	61 e0       	ldi	r22, 0x01	; 1
     2b4:	54 df       	rcall	.-344    	; 0x15e <_ZN11ColorSensor9setFilterE6Filter>
		_colors[colorIndex].setRedPeriod( frequency_.getPeriod() );
     2b6:	c8 01       	movw	r24, r16
     2b8:	95 d0       	rcall	.+298    	; 0x3e4 <_ZN6timer49getPeriodEv>
     2ba:	2f 2d       	mov	r18, r15
     2bc:	30 e0       	ldi	r19, 0x00	; 0
     2be:	e9 01       	movw	r28, r18
     2c0:	cc 0f       	add	r28, r28
     2c2:	dd 1f       	adc	r29, r29
     2c4:	cc 0f       	add	r28, r28
     2c6:	dd 1f       	adc	r29, r29
     2c8:	cc 0f       	add	r28, r28
     2ca:	dd 1f       	adc	r29, r29
     2cc:	c2 0f       	add	r28, r18
     2ce:	d3 1f       	adc	r29, r19
     2d0:	21 96       	adiw	r28, 0x01	; 1
     2d2:	c0 0f       	add	r28, r16
     2d4:	d1 1f       	adc	r29, r17
     2d6:	bc 01       	movw	r22, r24
     2d8:	ce 01       	movw	r24, r28
     2da:	32 df       	rcall	.-412    	; 0x140 <_ZN5Color12setRedPeriodEj>

		setFilter( blueFilter );
     2dc:	63 e0       	ldi	r22, 0x03	; 3
     2de:	c8 01       	movw	r24, r16
     2e0:	3e df       	rcall	.-388    	; 0x15e <_ZN11ColorSensor9setFilterE6Filter>
		_colors[colorIndex].setBluePeriod( frequency_.getPeriod() );
     2e2:	c8 01       	movw	r24, r16
     2e4:	7f d0       	rcall	.+254    	; 0x3e4 <_ZN6timer49getPeriodEv>
     2e6:	bc 01       	movw	r22, r24
     2e8:	ce 01       	movw	r24, r28
     2ea:	2e df       	rcall	.-420    	; 0x148 <_ZN5Color13setBluePeriodEj>
		
		setFilter( greenFilter );
     2ec:	62 e0       	ldi	r22, 0x02	; 2
     2ee:	c8 01       	movw	r24, r16
     2f0:	36 df       	rcall	.-404    	; 0x15e <_ZN11ColorSensor9setFilterE6Filter>
		_colors[colorIndex].setGreenPeriod( frequency_.getPeriod() );
     2f2:	c8 01       	movw	r24, r16
     2f4:	77 d0       	rcall	.+238    	; 0x3e4 <_ZN6timer49getPeriodEv>
     2f6:	bc 01       	movw	r22, r24
     2f8:	ce 01       	movw	r24, r28
     2fa:	2a df       	rcall	.-428    	; 0x150 <_ZN5Color14setGreenPeriodEj>
     2fc:	6f 2d       	mov	r22, r15
				
		// Set index
		_colors[colorIndex].setColorIndex( colorIndex );
     2fe:	ce 01       	movw	r24, r28
     300:	2b df       	rcall	.-426    	; 0x158 <_ZN5Color13setColorIndexEh>
     302:	df 91       	pop	r29
     304:	cf 91       	pop	r28
	}
	else
	{
		/* Cant add more colors. Increase size of array. */
	}
}
     306:	1f 91       	pop	r17
     308:	0f 91       	pop	r16
     30a:	ff 90       	pop	r15
     30c:	08 95       	ret

0000030e <_ZN11ColorSensor19setFrequencyscalingE16FrequencyScaling>:
     30e:	61 30       	cpi	r22, 0x01	; 1
     310:	69 f0       	breq	.+26     	; 0x32c <_ZN11ColorSensor19setFrequencyscalingE16FrequencyScaling+0x1e>
	}	
}

void ColorSensor::setFrequencyscaling( FrequencyScaling scaling )
{
	switch (scaling)
     312:	28 f0       	brcs	.+10     	; 0x31e <_ZN11ColorSensor19setFrequencyscalingE16FrequencyScaling+0x10>
     314:	62 30       	cpi	r22, 0x02	; 2
     316:	89 f0       	breq	.+34     	; 0x33a <_ZN11ColorSensor19setFrequencyscalingE16FrequencyScaling+0x2c>
     318:	63 30       	cpi	r22, 0x03	; 3
     31a:	b1 f0       	breq	.+44     	; 0x348 <_ZN11ColorSensor19setFrequencyscalingE16FrequencyScaling+0x3a>
     31c:	08 95       	ret
	{
	case powerDown:
		COLORSENSOR_S0_PORT &= ~( COLORSENSOR_S0_PIN );
     31e:	88 b1       	in	r24, 0x08	; 8
     320:	8e 7f       	andi	r24, 0xFE	; 254
     322:	88 b9       	out	0x08, r24	; 8
		COLORSENSOR_S1_PORT &= ~( COLORSENSOR_S1_PIN );
     324:	88 b1       	in	r24, 0x08	; 8
     326:	8d 7f       	andi	r24, 0xFD	; 253
     328:	88 b9       	out	0x08, r24	; 8
		break;
     32a:	08 95       	ret

	case twoPercent:
		COLORSENSOR_S0_PORT &= ~( COLORSENSOR_S0_PIN );
     32c:	88 b1       	in	r24, 0x08	; 8
     32e:	8e 7f       	andi	r24, 0xFE	; 254
     330:	88 b9       	out	0x08, r24	; 8
		COLORSENSOR_S1_PORT |= COLORSENSOR_S1_PIN;
     332:	88 b1       	in	r24, 0x08	; 8
     334:	82 60       	ori	r24, 0x02	; 2
     336:	88 b9       	out	0x08, r24	; 8
		break;
     338:	08 95       	ret

	case twentyPercent:
		COLORSENSOR_S0_PORT |= COLORSENSOR_S0_PIN;
     33a:	88 b1       	in	r24, 0x08	; 8
     33c:	81 60       	ori	r24, 0x01	; 1
     33e:	88 b9       	out	0x08, r24	; 8
		COLORSENSOR_S1_PORT &= ~( COLORSENSOR_S1_PIN );
     340:	88 b1       	in	r24, 0x08	; 8
     342:	8d 7f       	andi	r24, 0xFD	; 253
     344:	88 b9       	out	0x08, r24	; 8
		break;
     346:	08 95       	ret

	case hundredPercent:
		COLORSENSOR_S0_PORT |= COLORSENSOR_S0_PIN;
     348:	88 b1       	in	r24, 0x08	; 8
     34a:	81 60       	ori	r24, 0x01	; 1
     34c:	88 b9       	out	0x08, r24	; 8
		COLORSENSOR_S1_PORT |= COLORSENSOR_S1_PIN;
     34e:	88 b1       	in	r24, 0x08	; 8
     350:	82 60       	ori	r24, 0x02	; 2
     352:	88 b9       	out	0x08, r24	; 8
     354:	08 95       	ret

00000356 <_ZN11ColorSensorC1E16FrequencyScaling>:
#include "FreeRTOS.h"
#include "task.h"
#include "portmacro.h"

// default constructor
ColorSensor::ColorSensor( FrequencyScaling scaling )
     356:	bf 92       	push	r11
     358:	cf 92       	push	r12
     35a:	df 92       	push	r13
     35c:	ef 92       	push	r14
     35e:	ff 92       	push	r15
     360:	0f 93       	push	r16
     362:	1f 93       	push	r17
     364:	cf 93       	push	r28
     366:	df 93       	push	r29
     368:	1f 92       	push	r1
     36a:	cd b7       	in	r28, 0x3d	; 61
     36c:	de b7       	in	r29, 0x3e	; 62
     36e:	6c 01       	movw	r12, r24
     370:	b6 2e       	mov	r11, r22
     372:	29 d0       	rcall	.+82     	; 0x3c6 <_ZN6timer4C1Ev>
     374:	76 01       	movw	r14, r12
     376:	8f ef       	ldi	r24, 0xFF	; 255
     378:	e8 1a       	sub	r14, r24
     37a:	f8 0a       	sbc	r15, r24
     37c:	09 e0       	ldi	r16, 0x09	; 9
     37e:	10 e0       	ldi	r17, 0x00	; 0
     380:	0f 3f       	cpi	r16, 0xFF	; 255
     382:	8f ef       	ldi	r24, 0xFF	; 255
     384:	18 07       	cpc	r17, r24
     386:	41 f0       	breq	.+16     	; 0x398 <_ZN11ColorSensorC1E16FrequencyScaling+0x42>
     388:	c7 01       	movw	r24, r14
     38a:	cd de       	rcall	.-614    	; 0x126 <_ZN5ColorC1Ev>
     38c:	89 e0       	ldi	r24, 0x09	; 9
     38e:	e8 0e       	add	r14, r24
     390:	f1 1c       	adc	r15, r1
     392:	01 50       	subi	r16, 0x01	; 1
     394:	11 09       	sbc	r17, r1
     396:	f4 cf       	rjmp	.-24     	; 0x380 <_ZN11ColorSensorC1E16FrequencyScaling+0x2a>
{
	// DE HER SKAL ÆNDRES!!!
	// Set ports to the right values.
	DDRC = 0xFF;
     398:	8f ef       	ldi	r24, 0xFF	; 255
     39a:	87 b9       	out	0x07, r24	; 7
	DDRD = 0x00;
     39c:	1a b8       	out	0x0a, r1	; 10
	frequency_ = timer4();
     39e:	ce 01       	movw	r24, r28
     3a0:	01 96       	adiw	r24, 0x01	; 1
     3a2:	11 d0       	rcall	.+34     	; 0x3c6 <_ZN6timer4C1Ev>

	// Set default filter and scaling
	setFilter( noFilter );
     3a4:	60 e0       	ldi	r22, 0x00	; 0
     3a6:	c6 01       	movw	r24, r12
     3a8:	da de       	rcall	.-588    	; 0x15e <_ZN11ColorSensor9setFilterE6Filter>
	setFrequencyscaling( scaling );
     3aa:	6b 2d       	mov	r22, r11
     3ac:	c6 01       	movw	r24, r12
     3ae:	af df       	rcall	.-162    	; 0x30e <_ZN11ColorSensor19setFrequencyscalingE16FrequencyScaling>
     3b0:	0f 90       	pop	r0
}
     3b2:	df 91       	pop	r29
     3b4:	cf 91       	pop	r28
     3b6:	1f 91       	pop	r17
     3b8:	0f 91       	pop	r16
     3ba:	ff 90       	pop	r15
     3bc:	ef 90       	pop	r14
     3be:	df 90       	pop	r13
     3c0:	cf 90       	pop	r12
     3c2:	bf 90       	pop	r11
     3c4:	08 95       	ret

000003c6 <_ZN6timer4C1Ev>:
//volatile float tick = 0.000064;

timer4::timer4()
{
	// Setup timer to normal mode and pre scaler to 1
	TCCR4A = 0U;
     3c6:	10 92 a0 00 	sts	0x00A0, r1	; 0x8000a0 <__TEXT_REGION_LENGTH__+0x7000a0>
	TCCR4B = ( 1 << ICNC4 ) | ( 1 << ICES4 ) | ( 1 << CS40 );
     3ca:	81 ec       	ldi	r24, 0xC1	; 193
     3cc:	80 93 a1 00 	sts	0x00A1, r24	; 0x8000a1 <__TEXT_REGION_LENGTH__+0x7000a1>
	TCCR4C = 0U;
     3d0:	10 92 a2 00 	sts	0x00A2, r1	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
	
	// Clear flags and set counter to zero
	TIFR4 = ( 1 << ICF4 ) | ( 1 << TOV4 );
     3d4:	81 e2       	ldi	r24, 0x21	; 33
     3d6:	89 bb       	out	0x19, r24	; 25
	TCNT4 = 0;        
     3d8:	10 92 a5 00 	sts	0x00A5, r1	; 0x8000a5 <__TEXT_REGION_LENGTH__+0x7000a5>
     3dc:	10 92 a4 00 	sts	0x00A4, r1	; 0x8000a4 <__TEXT_REGION_LENGTH__+0x7000a4>

	// Enable global interrupts
    sei();
     3e0:	78 94       	sei
     3e2:	08 95       	ret

000003e4 <_ZN6timer49getPeriodEv>:
}

uint16_t timer4::getPeriod( void )
{
	// Reset all needed values
	first = true;
     3e4:	81 e0       	ldi	r24, 0x01	; 1
     3e6:	80 93 0a 02 	sts	0x020A, r24	; 0x80020a <first>
	oldValue = 0U;
     3ea:	10 92 d3 02 	sts	0x02D3, r1	; 0x8002d3 <oldValue+0x1>
     3ee:	10 92 d2 02 	sts	0x02D2, r1	; 0x8002d2 <oldValue>
	period = 0U;
     3f2:	10 92 cd 02 	sts	0x02CD, r1	; 0x8002cd <__data_end+0x1>
     3f6:	10 92 cc 02 	sts	0x02CC, r1	; 0x8002cc <__data_end>
	timeroverflow = 0;
     3fa:	10 92 ce 02 	sts	0x02CE, r1	; 0x8002ce <timeroverflow>
     3fe:	10 92 cf 02 	sts	0x02CF, r1	; 0x8002cf <timeroverflow+0x1>
     402:	10 92 d0 02 	sts	0x02D0, r1	; 0x8002d0 <timeroverflow+0x2>
     406:	10 92 d1 02 	sts	0x02D1, r1	; 0x8002d1 <timeroverflow+0x3>
	
	// Enable interrupt and clear pending
	TIFR4 = ( 1 << ICF4 ) | ( 1 << TOV4 );
     40a:	81 e2       	ldi	r24, 0x21	; 33
     40c:	89 bb       	out	0x19, r24	; 25
	TIMSK4 = ( 1 << ICIE4 ) | ( 1 << TOIE4 );	
     40e:	80 93 72 00 	sts	0x0072, r24	; 0x800072 <__TEXT_REGION_LENGTH__+0x700072>
	
	// Wait until measurement has been taken
	while ( period == 0U )
     412:	80 91 cc 02 	lds	r24, 0x02CC	; 0x8002cc <__data_end>
     416:	90 91 cd 02 	lds	r25, 0x02CD	; 0x8002cd <__data_end+0x1>
     41a:	89 2b       	or	r24, r25
     41c:	81 f4       	brne	.+32     	; 0x43e <__LOCK_REGION_LENGTH__+0x3e>
	{
		if ( timeroverflow > 10U )
     41e:	80 91 ce 02 	lds	r24, 0x02CE	; 0x8002ce <timeroverflow>
     422:	90 91 cf 02 	lds	r25, 0x02CF	; 0x8002cf <timeroverflow+0x1>
     426:	a0 91 d0 02 	lds	r26, 0x02D0	; 0x8002d0 <timeroverflow+0x2>
     42a:	b0 91 d1 02 	lds	r27, 0x02D1	; 0x8002d1 <timeroverflow+0x3>
     42e:	0b 97       	sbiw	r24, 0x0b	; 11
     430:	a1 05       	cpc	r26, r1
     432:	b1 05       	cpc	r27, r1
     434:	70 f3       	brcs	.-36     	; 0x412 <__LOCK_REGION_LENGTH__+0x12>
		{
			// Error - Disable interrupt and clear pending
			TIMSK4 = 0U;
     436:	10 92 72 00 	sts	0x0072, r1	; 0x800072 <__TEXT_REGION_LENGTH__+0x700072>
			TIFR4 = ( 1 << ICF4 ) | ( 1 << TOV4 );
     43a:	81 e2       	ldi	r24, 0x21	; 33
     43c:	89 bb       	out	0x19, r24	; 25
			break;
		}
	}
	
	return period;
     43e:	80 91 cc 02 	lds	r24, 0x02CC	; 0x8002cc <__data_end>
     442:	90 91 cd 02 	lds	r25, 0x02CD	; 0x8002cd <__data_end+0x1>
}
     446:	08 95       	ret

00000448 <__vector_45>:

ISR(TIMER4_OVF_vect)
{
     448:	1f 92       	push	r1
     44a:	0f 92       	push	r0
     44c:	0f b6       	in	r0, 0x3f	; 63
     44e:	0f 92       	push	r0
     450:	11 24       	eor	r1, r1
     452:	8f 93       	push	r24
     454:	9f 93       	push	r25
     456:	af 93       	push	r26
     458:	bf 93       	push	r27
	timeroverflow++;
     45a:	80 91 ce 02 	lds	r24, 0x02CE	; 0x8002ce <timeroverflow>
     45e:	90 91 cf 02 	lds	r25, 0x02CF	; 0x8002cf <timeroverflow+0x1>
     462:	a0 91 d0 02 	lds	r26, 0x02D0	; 0x8002d0 <timeroverflow+0x2>
     466:	b0 91 d1 02 	lds	r27, 0x02D1	; 0x8002d1 <timeroverflow+0x3>
     46a:	01 96       	adiw	r24, 0x01	; 1
     46c:	a1 1d       	adc	r26, r1
     46e:	b1 1d       	adc	r27, r1
     470:	80 93 ce 02 	sts	0x02CE, r24	; 0x8002ce <timeroverflow>
     474:	90 93 cf 02 	sts	0x02CF, r25	; 0x8002cf <timeroverflow+0x1>
     478:	a0 93 d0 02 	sts	0x02D0, r26	; 0x8002d0 <timeroverflow+0x2>
     47c:	b0 93 d1 02 	sts	0x02D1, r27	; 0x8002d1 <timeroverflow+0x3>
}
     480:	bf 91       	pop	r27
     482:	af 91       	pop	r26
     484:	9f 91       	pop	r25
     486:	8f 91       	pop	r24
     488:	0f 90       	pop	r0
     48a:	0f be       	out	0x3f, r0	; 63
     48c:	0f 90       	pop	r0
     48e:	1f 90       	pop	r1
     490:	18 95       	reti

00000492 <__vector_41>:

ISR(TIMER4_CAPT_vect)
{
     492:	1f 92       	push	r1
     494:	0f 92       	push	r0
     496:	0f b6       	in	r0, 0x3f	; 63
     498:	0f 92       	push	r0
     49a:	11 24       	eor	r1, r1
     49c:	0b b6       	in	r0, 0x3b	; 59
     49e:	0f 92       	push	r0
     4a0:	cf 92       	push	r12
     4a2:	df 92       	push	r13
     4a4:	ef 92       	push	r14
     4a6:	ff 92       	push	r15
     4a8:	0f 93       	push	r16
     4aa:	1f 93       	push	r17
     4ac:	2f 93       	push	r18
     4ae:	3f 93       	push	r19
     4b0:	4f 93       	push	r20
     4b2:	5f 93       	push	r21
     4b4:	6f 93       	push	r22
     4b6:	7f 93       	push	r23
     4b8:	8f 93       	push	r24
     4ba:	9f 93       	push	r25
     4bc:	af 93       	push	r26
     4be:	bf 93       	push	r27
     4c0:	ef 93       	push	r30
     4c2:	ff 93       	push	r31
	// Read value of timer
	uint16_t readValue = ICR4;
     4c4:	60 91 a6 00 	lds	r22, 0x00A6	; 0x8000a6 <__TEXT_REGION_LENGTH__+0x7000a6>
     4c8:	70 91 a7 00 	lds	r23, 0x00A7	; 0x8000a7 <__TEXT_REGION_LENGTH__+0x7000a7>

	if ( first == true )
     4cc:	80 91 0a 02 	lds	r24, 0x020A	; 0x80020a <first>
     4d0:	88 23       	and	r24, r24
     4d2:	79 f0       	breq	.+30     	; 0x4f2 <__vector_41+0x60>
	{
		timeroverflow = 0U;
     4d4:	10 92 ce 02 	sts	0x02CE, r1	; 0x8002ce <timeroverflow>
     4d8:	10 92 cf 02 	sts	0x02CF, r1	; 0x8002cf <timeroverflow+0x1>
     4dc:	10 92 d0 02 	sts	0x02D0, r1	; 0x8002d0 <timeroverflow+0x2>
     4e0:	10 92 d1 02 	sts	0x02D1, r1	; 0x8002d1 <timeroverflow+0x3>
		oldValue = readValue;
     4e4:	70 93 d3 02 	sts	0x02D3, r23	; 0x8002d3 <oldValue+0x1>
     4e8:	60 93 d2 02 	sts	0x02D2, r22	; 0x8002d2 <oldValue>
		first = false;
     4ec:	10 92 0a 02 	sts	0x020A, r1	; 0x80020a <first>
		return;
     4f0:	81 c0       	rjmp	.+258    	; 0x5f4 <__vector_41+0x162>
	}
	
	// Check if overflow is pending
	if ( TIFR4 & ( 1 << TOV4 ))
     4f2:	c8 9b       	sbis	0x19, 0	; 25
     4f4:	13 c0       	rjmp	.+38     	; 0x51c <__vector_41+0x8a>
	{
		timeroverflow++;
     4f6:	80 91 ce 02 	lds	r24, 0x02CE	; 0x8002ce <timeroverflow>
     4fa:	90 91 cf 02 	lds	r25, 0x02CF	; 0x8002cf <timeroverflow+0x1>
     4fe:	a0 91 d0 02 	lds	r26, 0x02D0	; 0x8002d0 <timeroverflow+0x2>
     502:	b0 91 d1 02 	lds	r27, 0x02D1	; 0x8002d1 <timeroverflow+0x3>
     506:	01 96       	adiw	r24, 0x01	; 1
     508:	a1 1d       	adc	r26, r1
     50a:	b1 1d       	adc	r27, r1
     50c:	80 93 ce 02 	sts	0x02CE, r24	; 0x8002ce <timeroverflow>
     510:	90 93 cf 02 	sts	0x02CF, r25	; 0x8002cf <timeroverflow+0x1>
     514:	a0 93 d0 02 	sts	0x02D0, r26	; 0x8002d0 <timeroverflow+0x2>
     518:	b0 93 d1 02 	sts	0x02D1, r27	; 0x8002d1 <timeroverflow+0x3>
	}
		
	// Disable interrupt and clear pending
	TIMSK4 = 0U;	
     51c:	10 92 72 00 	sts	0x0072, r1	; 0x800072 <__TEXT_REGION_LENGTH__+0x700072>
	TIFR4 = ( 1 << ICF4 ) | ( 1 << TOV4 );		
     520:	81 e2       	ldi	r24, 0x21	; 33
     522:	89 bb       	out	0x19, r24	; 25
			
	// Calculate difference
	uint32_t diff = 0U;

	if ( readValue < oldValue )
     524:	80 91 d2 02 	lds	r24, 0x02D2	; 0x8002d2 <oldValue>
     528:	90 91 d3 02 	lds	r25, 0x02D3	; 0x8002d3 <oldValue+0x1>
     52c:	68 17       	cp	r22, r24
     52e:	79 07       	cpc	r23, r25
     530:	58 f5       	brcc	.+86     	; 0x588 <__vector_41+0xf6>
	{
		if ( timeroverflow != 0 )
     532:	80 91 ce 02 	lds	r24, 0x02CE	; 0x8002ce <timeroverflow>
     536:	90 91 cf 02 	lds	r25, 0x02CF	; 0x8002cf <timeroverflow+0x1>
     53a:	a0 91 d0 02 	lds	r26, 0x02D0	; 0x8002d0 <timeroverflow+0x2>
     53e:	b0 91 d1 02 	lds	r27, 0x02D1	; 0x8002d1 <timeroverflow+0x3>
     542:	89 2b       	or	r24, r25
     544:	8a 2b       	or	r24, r26
     546:	8b 2b       	or	r24, r27
     548:	99 f0       	breq	.+38     	; 0x570 <__vector_41+0xde>
		{
			timeroverflow--;
     54a:	80 91 ce 02 	lds	r24, 0x02CE	; 0x8002ce <timeroverflow>
     54e:	90 91 cf 02 	lds	r25, 0x02CF	; 0x8002cf <timeroverflow+0x1>
     552:	a0 91 d0 02 	lds	r26, 0x02D0	; 0x8002d0 <timeroverflow+0x2>
     556:	b0 91 d1 02 	lds	r27, 0x02D1	; 0x8002d1 <timeroverflow+0x3>
     55a:	01 97       	sbiw	r24, 0x01	; 1
     55c:	a1 09       	sbc	r26, r1
     55e:	b1 09       	sbc	r27, r1
     560:	80 93 ce 02 	sts	0x02CE, r24	; 0x8002ce <timeroverflow>
     564:	90 93 cf 02 	sts	0x02CF, r25	; 0x8002cf <timeroverflow+0x1>
     568:	a0 93 d0 02 	sts	0x02D0, r26	; 0x8002d0 <timeroverflow+0x2>
     56c:	b0 93 d1 02 	sts	0x02D1, r27	; 0x8002d1 <timeroverflow+0x3>
		}
		diff = ( 0xFFFF - oldValue ) + readValue;
     570:	80 91 d2 02 	lds	r24, 0x02D2	; 0x8002d2 <oldValue>
     574:	90 91 d3 02 	lds	r25, 0x02D3	; 0x8002d3 <oldValue+0x1>
     578:	68 1b       	sub	r22, r24
     57a:	79 0b       	sbc	r23, r25
     57c:	61 50       	subi	r22, 0x01	; 1
     57e:	71 09       	sbc	r23, r1
     580:	cb 01       	movw	r24, r22
     582:	a0 e0       	ldi	r26, 0x00	; 0
     584:	b0 e0       	ldi	r27, 0x00	; 0
     586:	09 c0       	rjmp	.+18     	; 0x59a <__vector_41+0x108>
	}
	else
	{
		diff = readValue - oldValue;
     588:	80 91 d2 02 	lds	r24, 0x02D2	; 0x8002d2 <oldValue>
     58c:	90 91 d3 02 	lds	r25, 0x02D3	; 0x8002d3 <oldValue+0x1>
     590:	68 1b       	sub	r22, r24
     592:	79 0b       	sbc	r23, r25
     594:	cb 01       	movw	r24, r22
     596:	a0 e0       	ldi	r26, 0x00	; 0
     598:	b0 e0       	ldi	r27, 0x00	; 0
	}
	
	// Add timeroverflow to total diff
	diff += timeroverflow << 16U;
     59a:	40 91 ce 02 	lds	r20, 0x02CE	; 0x8002ce <timeroverflow>
     59e:	50 91 cf 02 	lds	r21, 0x02CF	; 0x8002cf <timeroverflow+0x1>
     5a2:	60 91 d0 02 	lds	r22, 0x02D0	; 0x8002d0 <timeroverflow+0x2>
     5a6:	70 91 d1 02 	lds	r23, 0x02D1	; 0x8002d1 <timeroverflow+0x3>
     5aa:	ba 01       	movw	r22, r20
     5ac:	55 27       	eor	r21, r21
     5ae:	44 27       	eor	r20, r20
     5b0:	8a 01       	movw	r16, r20
     5b2:	9b 01       	movw	r18, r22
     5b4:	08 0f       	add	r16, r24
     5b6:	19 1f       	adc	r17, r25
     5b8:	2a 1f       	adc	r18, r26
     5ba:	3b 1f       	adc	r19, r27
     5bc:	c9 01       	movw	r24, r18
     5be:	b8 01       	movw	r22, r16
	
	// Calculate period
	period = diff * tick * 1000000;
     5c0:	c0 90 06 02 	lds	r12, 0x0206	; 0x800206 <tick>
     5c4:	d0 90 07 02 	lds	r13, 0x0207	; 0x800207 <tick+0x1>
     5c8:	e0 90 08 02 	lds	r14, 0x0208	; 0x800208 <tick+0x2>
     5cc:	f0 90 09 02 	lds	r15, 0x0209	; 0x800209 <tick+0x3>
     5d0:	0e 94 71 10 	call	0x20e2	; 0x20e2 <__floatunsisf>
     5d4:	a7 01       	movw	r20, r14
     5d6:	96 01       	movw	r18, r12
     5d8:	0e 94 27 11 	call	0x224e	; 0x224e <__mulsf3>
     5dc:	20 e0       	ldi	r18, 0x00	; 0
     5de:	34 e2       	ldi	r19, 0x24	; 36
     5e0:	44 e7       	ldi	r20, 0x74	; 116
     5e2:	59 e4       	ldi	r21, 0x49	; 73
     5e4:	0e 94 27 11 	call	0x224e	; 0x224e <__mulsf3>
     5e8:	0e 94 45 10 	call	0x208a	; 0x208a <__fixunssfsi>
     5ec:	70 93 cd 02 	sts	0x02CD, r23	; 0x8002cd <__data_end+0x1>
     5f0:	60 93 cc 02 	sts	0x02CC, r22	; 0x8002cc <__data_end>
     5f4:	ff 91       	pop	r31
     5f6:	ef 91       	pop	r30
     5f8:	bf 91       	pop	r27
     5fa:	af 91       	pop	r26
     5fc:	9f 91       	pop	r25
     5fe:	8f 91       	pop	r24
     600:	7f 91       	pop	r23
     602:	6f 91       	pop	r22
     604:	5f 91       	pop	r21
     606:	4f 91       	pop	r20
     608:	3f 91       	pop	r19
     60a:	2f 91       	pop	r18
     60c:	1f 91       	pop	r17
     60e:	0f 91       	pop	r16
     610:	ff 90       	pop	r15
     612:	ef 90       	pop	r14
     614:	df 90       	pop	r13
     616:	cf 90       	pop	r12
     618:	0f 90       	pop	r0
     61a:	0b be       	out	0x3b, r0	; 59
     61c:	0f 90       	pop	r0
     61e:	0f be       	out	0x3f, r0	; 63
     620:	0f 90       	pop	r0
     622:	1f 90       	pop	r1
     624:	18 95       	reti

00000626 <_Z9FirstTaskPv>:
void * operator new(size_t size);
void operator delete(void * ptr);

int __cxa_guard_acquire(__guard *g) {return !*(char *)(g);};
void __cxa_guard_release (__guard *g) {*(char *)g = 1;};
void __cxa_guard_abort (__guard *) {};
     626:	cf 93       	push	r28
     628:	df 93       	push	r29
     62a:	cd b7       	in	r28, 0x3d	; 61
     62c:	de b7       	in	r29, 0x3e	; 62
     62e:	cb 55       	subi	r28, 0x5B	; 91
     630:	d1 09       	sbc	r29, r1
     632:	0f b6       	in	r0, 0x3f	; 63
     634:	f8 94       	cli
     636:	de bf       	out	0x3e, r29	; 62
     638:	0f be       	out	0x3f, r0	; 63
     63a:	cd bf       	out	0x3d, r28	; 61
     63c:	8c 01       	movw	r16, r24
     63e:	2e e4       	ldi	r18, 0x4E	; 78
     640:	48 e0       	ldi	r20, 0x08	; 8
     642:	60 e8       	ldi	r22, 0x80	; 128
     644:	75 e2       	ldi	r23, 0x25	; 37
     646:	80 e0       	ldi	r24, 0x00	; 0
     648:	90 e0       	ldi	r25, 0x00	; 0
     64a:	0e 94 75 0f 	call	0x1eea	; 0x1eea <_Z8InitUARTmhc>
     64e:	8d e0       	ldi	r24, 0x0D	; 13
     650:	92 e0       	ldi	r25, 0x02	; 2
     652:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_Z10SendStringPc>
     656:	62 e0       	ldi	r22, 0x02	; 2
     658:	ce 01       	movw	r24, r28
     65a:	01 96       	adiw	r24, 0x01	; 1
     65c:	7c de       	rcall	.-776    	; 0x356 <_ZN11ColorSensorC1E16FrequencyScaling>
     65e:	80 e3       	ldi	r24, 0x30	; 48
     660:	8f 36       	cpi	r24, 0x6F	; 111
     662:	19 f0       	breq	.+6      	; 0x66a <_Z9FirstTaskPv+0x44>
     664:	0e 94 c2 0f 	call	0x1f84	; 0x1f84 <_Z8ReadCharv>
     668:	fb cf       	rjmp	.-10     	; 0x660 <_Z9FirstTaskPv+0x3a>
     66a:	8b e2       	ldi	r24, 0x2B	; 43
     66c:	92 e0       	ldi	r25, 0x02	; 2
     66e:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_Z10SendStringPc>
     672:	60 e0       	ldi	r22, 0x00	; 0
     674:	ce 01       	movw	r24, r28
     676:	01 96       	adiw	r24, 0x01	; 1
     678:	13 de       	rcall	.-986    	; 0x2a0 <_ZN11ColorSensor17addCalibrateColorEh>
     67a:	80 e3       	ldi	r24, 0x30	; 48
     67c:	8f 36       	cpi	r24, 0x6F	; 111
     67e:	19 f0       	breq	.+6      	; 0x686 <_Z9FirstTaskPv+0x60>
     680:	0e 94 c2 0f 	call	0x1f84	; 0x1f84 <_Z8ReadCharv>
     684:	fb cf       	rjmp	.-10     	; 0x67c <_Z9FirstTaskPv+0x56>
     686:	8a e3       	ldi	r24, 0x3A	; 58
     688:	92 e0       	ldi	r25, 0x02	; 2
     68a:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_Z10SendStringPc>
     68e:	61 e0       	ldi	r22, 0x01	; 1
     690:	ce 01       	movw	r24, r28
     692:	01 96       	adiw	r24, 0x01	; 1
     694:	05 de       	rcall	.-1014   	; 0x2a0 <_ZN11ColorSensor17addCalibrateColorEh>
     696:	80 e3       	ldi	r24, 0x30	; 48
     698:	8f 36       	cpi	r24, 0x6F	; 111
     69a:	19 f0       	breq	.+6      	; 0x6a2 <_Z9FirstTaskPv+0x7c>
     69c:	0e 94 c2 0f 	call	0x1f84	; 0x1f84 <_Z8ReadCharv>
     6a0:	fb cf       	rjmp	.-10     	; 0x698 <_Z9FirstTaskPv+0x72>
     6a2:	89 e4       	ldi	r24, 0x49	; 73
     6a4:	92 e0       	ldi	r25, 0x02	; 2
     6a6:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_Z10SendStringPc>
     6aa:	80 e3       	ldi	r24, 0x30	; 48
     6ac:	8f 36       	cpi	r24, 0x6F	; 111
     6ae:	19 f0       	breq	.+6      	; 0x6b6 <_Z9FirstTaskPv+0x90>
     6b0:	0e 94 c2 0f 	call	0x1f84	; 0x1f84 <_Z8ReadCharv>
     6b4:	fb cf       	rjmp	.-10     	; 0x6ac <_Z9FirstTaskPv+0x86>
     6b6:	88 e5       	ldi	r24, 0x58	; 88
     6b8:	92 e0       	ldi	r25, 0x02	; 2
     6ba:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <_Z10SendStringPc>
     6be:	ce 01       	movw	r24, r28
     6c0:	01 96       	adiw	r24, 0x01	; 1
     6c2:	71 dd       	rcall	.-1310   	; 0x1a6 <_ZN11ColorSensor8getColorEv>
     6c4:	88 23       	and	r24, r24
     6c6:	19 f0       	breq	.+6      	; 0x6ce <_Z9FirstTaskPv+0xa8>
     6c8:	81 30       	cpi	r24, 0x01	; 1
     6ca:	71 f0       	breq	.+28     	; 0x6e8 <_Z9FirstTaskPv+0xc2>
     6cc:	19 c0       	rjmp	.+50     	; 0x700 <_Z9FirstTaskPv+0xda>
     6ce:	c8 01       	movw	r24, r16
     6d0:	bb d4       	rcall	.+2422   	; 0x1048 <_ZN8Robotarm9grabBlockEv>
     6d2:	88 e8       	ldi	r24, 0x88	; 136
     6d4:	93 e1       	ldi	r25, 0x13	; 19
     6d6:	0e 94 ff 0e 	call	0x1dfe	; 0x1dfe <vTaskDelay>
     6da:	c8 01       	movw	r24, r16
     6dc:	6c d5       	rcall	.+2776   	; 0x11b6 <_ZN8Robotarm18moveBlockToZoneOneEv>
     6de:	88 e8       	ldi	r24, 0x88	; 136
     6e0:	93 e1       	ldi	r25, 0x13	; 19
     6e2:	0e 94 ff 0e 	call	0x1dfe	; 0x1dfe <vTaskDelay>
     6e6:	0c c0       	rjmp	.+24     	; 0x700 <_Z9FirstTaskPv+0xda>
     6e8:	c8 01       	movw	r24, r16
     6ea:	ae d4       	rcall	.+2396   	; 0x1048 <_ZN8Robotarm9grabBlockEv>
     6ec:	88 e8       	ldi	r24, 0x88	; 136
     6ee:	93 e1       	ldi	r25, 0x13	; 19
     6f0:	0e 94 ff 0e 	call	0x1dfe	; 0x1dfe <vTaskDelay>
     6f4:	c8 01       	movw	r24, r16
     6f6:	71 d5       	rcall	.+2786   	; 0x11da <_ZN8Robotarm18moveBlockToZoneTwoEv>
     6f8:	88 e8       	ldi	r24, 0x88	; 136
     6fa:	93 e1       	ldi	r25, 0x13	; 19
     6fc:	0e 94 ff 0e 	call	0x1dfe	; 0x1dfe <vTaskDelay>
     700:	84 e6       	ldi	r24, 0x64	; 100
     702:	90 e0       	ldi	r25, 0x00	; 0
     704:	0e 94 ff 0e 	call	0x1dfe	; 0x1dfe <vTaskDelay>
     708:	da cf       	rjmp	.-76     	; 0x6be <_Z9FirstTaskPv+0x98>

0000070a <__cxa_pure_virtual>:
     70a:	ff cf       	rjmp	.-2      	; 0x70a <__cxa_pure_virtual>

0000070c <_Znwj>:

void * operator new(size_t size)
{
	return malloc(size);
     70c:	0c 94 bb 11 	jmp	0x2376	; 0x2376 <malloc>
}
     710:	08 95       	ret

00000712 <_ZdlPv>:

void operator delete(void * ptr)
{
	ptr != NULL ? free(ptr) : void(0);
     712:	00 97       	sbiw	r24, 0x00	; 0
     714:	11 f0       	breq	.+4      	; 0x71a <_ZdlPv+0x8>
     716:	0c 94 53 12 	jmp	0x24a6	; 0x24a6 <free>
     71a:	08 95       	ret

0000071c <main>:
		vTaskDelay(100/portTICK_RATE_MS);
	}
}

int main(void)
{
     71c:	cf 93       	push	r28
     71e:	df 93       	push	r29
     720:	cd b7       	in	r28, 0x3d	; 61
     722:	de b7       	in	r29, 0x3e	; 62
     724:	2e 97       	sbiw	r28, 0x0e	; 14
     726:	0f b6       	in	r0, 0x3f	; 63
     728:	f8 94       	cli
     72a:	de bf       	out	0x3e, r29	; 62
     72c:	0f be       	out	0x3f, r0	; 63
     72e:	cd bf       	out	0x3d, r28	; 61
	Robotarm arm = Robotarm();
     730:	ce 01       	movw	r24, r28
     732:	01 96       	adiw	r24, 0x01	; 1
     734:	2e d4       	rcall	.+2140   	; 0xf92 <_ZN8RobotarmC1Ev>
	xTaskCreate(FirstTask,  ( signed char * ) "Task", configMAIN_STACK_SIZE, &arm, tskIDLE_PRIORITY, NULL);
     736:	a1 2c       	mov	r10, r1
     738:	b1 2c       	mov	r11, r1
     73a:	c1 2c       	mov	r12, r1
     73c:	d1 2c       	mov	r13, r1
     73e:	e1 2c       	mov	r14, r1
     740:	f1 2c       	mov	r15, r1
     742:	00 e0       	ldi	r16, 0x00	; 0
     744:	9e 01       	movw	r18, r28
     746:	2f 5f       	subi	r18, 0xFF	; 255
     748:	3f 4f       	sbci	r19, 0xFF	; 255
     74a:	48 ec       	ldi	r20, 0xC8	; 200
     74c:	50 e0       	ldi	r21, 0x00	; 0
     74e:	67 e6       	ldi	r22, 0x67	; 103
     750:	72 e0       	ldi	r23, 0x02	; 2
     752:	83 e1       	ldi	r24, 0x13	; 19
     754:	93 e0       	ldi	r25, 0x03	; 3
     756:	0e 94 00 0d 	call	0x1a00	; 0x1a00 <xTaskGenericCreate>
	vTaskStartScheduler();
     75a:	0e 94 b8 0d 	call	0x1b70	; 0x1b70 <vTaskStartScheduler>
     75e:	ff cf       	rjmp	.-2      	; 0x75e <main+0x42>

00000760 <_ZN5Motor10SetDegreesEh>:
	*	 can be used to turn motor at a specific speed set by \ref delay. C
	*	 Note that this function needs to run multiple times to work as intended.
	*    @param uint8_t		sdegrees to turn
	*    @return void
	*/
	virtual void SetDegrees( uint8_t degrees )
     760:	cf 92       	push	r12
     762:	df 92       	push	r13
     764:	ef 92       	push	r14
     766:	ff 92       	push	r15
     768:	cf 93       	push	r28
     76a:	df 93       	push	r29
	{
		if ( maxDegrees_ >= degrees )
     76c:	fc 01       	movw	r30, r24
     76e:	26 89       	ldd	r18, Z+22	; 0x16
     770:	26 17       	cp	r18, r22
     772:	c0 f0       	brcs	.+48     	; 0x7a4 <_ZN5Motor10SetDegreesEh+0x44>
     774:	ec 01       	movw	r28, r24
		{
			percent_ = percentPrDeg * degrees + startpercent_;
     776:	c6 80       	ldd	r12, Z+6	; 0x06
     778:	d7 80       	ldd	r13, Z+7	; 0x07
     77a:	e0 84       	ldd	r14, Z+8	; 0x08
     77c:	f1 84       	ldd	r15, Z+9	; 0x09
     77e:	70 e0       	ldi	r23, 0x00	; 0
     780:	80 e0       	ldi	r24, 0x00	; 0
     782:	90 e0       	ldi	r25, 0x00	; 0
     784:	0e 94 73 10 	call	0x20e6	; 0x20e6 <__floatsisf>
     788:	a7 01       	movw	r20, r14
     78a:	96 01       	movw	r18, r12
     78c:	0e 94 27 11 	call	0x224e	; 0x224e <__mulsf3>
     790:	2a 89       	ldd	r18, Y+18	; 0x12
     792:	3b 89       	ldd	r19, Y+19	; 0x13
     794:	4c 89       	ldd	r20, Y+20	; 0x14
     796:	5d 89       	ldd	r21, Y+21	; 0x15
     798:	0e 94 dd 0f 	call	0x1fba	; 0x1fba <__addsf3>
     79c:	6a 87       	std	Y+10, r22	; 0x0a
     79e:	7b 87       	std	Y+11, r23	; 0x0b
     7a0:	8c 87       	std	Y+12, r24	; 0x0c
     7a2:	9d 87       	std	Y+13, r25	; 0x0d
		}
	}
     7a4:	df 91       	pop	r29
     7a6:	cf 91       	pop	r28
     7a8:	ff 90       	pop	r15
     7aa:	ef 90       	pop	r14
     7ac:	df 90       	pop	r13
     7ae:	cf 90       	pop	r12
     7b0:	08 95       	ret

000007b2 <_ZN2M1D1Ev>:

class Motor
{
//functions
public:
	virtual ~Motor() {};
     7b2:	20 e7       	ldi	r18, 0x70	; 112
     7b4:	32 e0       	ldi	r19, 0x02	; 2
     7b6:	fc 01       	movw	r30, r24
     7b8:	31 83       	std	Z+1, r19	; 0x01
     7ba:	20 83       	st	Z, r18
     7bc:	08 95       	ret

000007be <_ZN2M1D0Ev>:
	SetDegrees( 90 );
	tmr1Ptr_->setDutyCycleComA( percent_ );
	oldPercent_ = percent_;
} 

M1::~M1()
     7be:	cf 93       	push	r28
     7c0:	df 93       	push	r29
     7c2:	ec 01       	movw	r28, r24
{
}
     7c4:	f6 df       	rcall	.-20     	; 0x7b2 <_ZN2M1D1Ev>
     7c6:	ce 01       	movw	r24, r28
     7c8:	a4 df       	rcall	.-184    	; 0x712 <_ZdlPv>
     7ca:	df 91       	pop	r29
     7cc:	cf 91       	pop	r28
     7ce:	08 95       	ret

000007d0 <_ZN2M19TurnMotorEv>:

void M1::TurnMotor()
{
     7d0:	4f 92       	push	r4
     7d2:	5f 92       	push	r5
     7d4:	6f 92       	push	r6
     7d6:	7f 92       	push	r7
     7d8:	8f 92       	push	r8
     7da:	9f 92       	push	r9
     7dc:	af 92       	push	r10
     7de:	bf 92       	push	r11
     7e0:	cf 92       	push	r12
     7e2:	df 92       	push	r13
     7e4:	ef 92       	push	r14
     7e6:	ff 92       	push	r15
     7e8:	cf 93       	push	r28
     7ea:	df 93       	push	r29
     7ec:	ec 01       	movw	r28, r24
	if ( percent_ > oldPercent_ + PERCENT_PR_TICK )
     7ee:	8a 84       	ldd	r8, Y+10	; 0x0a
     7f0:	9b 84       	ldd	r9, Y+11	; 0x0b
     7f2:	ac 84       	ldd	r10, Y+12	; 0x0c
     7f4:	bd 84       	ldd	r11, Y+13	; 0x0d
     7f6:	ce 84       	ldd	r12, Y+14	; 0x0e
     7f8:	df 84       	ldd	r13, Y+15	; 0x0f
     7fa:	e8 88       	ldd	r14, Y+16	; 0x10
     7fc:	f9 88       	ldd	r15, Y+17	; 0x11
     7fe:	20 e0       	ldi	r18, 0x00	; 0
     800:	30 e0       	ldi	r19, 0x00	; 0
     802:	40 e8       	ldi	r20, 0x80	; 128
     804:	5d e3       	ldi	r21, 0x3D	; 61
     806:	c7 01       	movw	r24, r14
     808:	b6 01       	movw	r22, r12
     80a:	0e 94 dd 0f 	call	0x1fba	; 0x1fba <__addsf3>
     80e:	2b 01       	movw	r4, r22
     810:	3c 01       	movw	r6, r24
     812:	9b 01       	movw	r18, r22
     814:	ac 01       	movw	r20, r24
     816:	c5 01       	movw	r24, r10
     818:	b4 01       	movw	r22, r8
     81a:	0e 94 23 11 	call	0x2246	; 0x2246 <__gesf2>
     81e:	18 16       	cp	r1, r24
     820:	74 f4       	brge	.+28     	; 0x83e <_ZN2M19TurnMotorEv+0x6e>
	{
		oldPercent_ += PERCENT_PR_TICK;
     822:	4e 86       	std	Y+14, r4	; 0x0e
     824:	5f 86       	std	Y+15, r5	; 0x0f
     826:	68 8a       	std	Y+16, r6	; 0x10
     828:	79 8a       	std	Y+17, r7	; 0x11
		tmr1Ptr_->setDutyCycleComA( oldPercent_ );
     82a:	b3 01       	movw	r22, r6
     82c:	a2 01       	movw	r20, r4
     82e:	8a 81       	ldd	r24, Y+2	; 0x02
     830:	9b 81       	ldd	r25, Y+3	; 0x03
     832:	03 d5       	rcall	.+2566   	; 0x123a <_ZN6Timer116setDutyCycleComAEf>
		vTaskDelay( delay_ / portTICK_RATE_MS );
     834:	8f 89       	ldd	r24, Y+23	; 0x17
     836:	98 8d       	ldd	r25, Y+24	; 0x18
     838:	0e 94 ff 0e 	call	0x1dfe	; 0x1dfe <vTaskDelay>
     83c:	1d c0       	rjmp	.+58     	; 0x878 <_ZN2M19TurnMotorEv+0xa8>
	}
	else if ( percent_ < oldPercent_ )
     83e:	a7 01       	movw	r20, r14
     840:	96 01       	movw	r18, r12
     842:	c5 01       	movw	r24, r10
     844:	b4 01       	movw	r22, r8
     846:	0e 94 41 10 	call	0x2082	; 0x2082 <__cmpsf2>
     84a:	88 23       	and	r24, r24
     84c:	ac f4       	brge	.+42     	; 0x878 <_ZN2M19TurnMotorEv+0xa8>
	{
		oldPercent_ -= PERCENT_PR_TICK;
     84e:	20 e0       	ldi	r18, 0x00	; 0
     850:	30 e0       	ldi	r19, 0x00	; 0
     852:	40 e8       	ldi	r20, 0x80	; 128
     854:	5d e3       	ldi	r21, 0x3D	; 61
     856:	c7 01       	movw	r24, r14
     858:	b6 01       	movw	r22, r12
     85a:	0e 94 dc 0f 	call	0x1fb8	; 0x1fb8 <__subsf3>
     85e:	ab 01       	movw	r20, r22
     860:	bc 01       	movw	r22, r24
     862:	4e 87       	std	Y+14, r20	; 0x0e
     864:	5f 87       	std	Y+15, r21	; 0x0f
     866:	68 8b       	std	Y+16, r22	; 0x10
     868:	79 8b       	std	Y+17, r23	; 0x11
		tmr1Ptr_->setDutyCycleComA( oldPercent_ );
     86a:	8a 81       	ldd	r24, Y+2	; 0x02
     86c:	9b 81       	ldd	r25, Y+3	; 0x03
     86e:	e5 d4       	rcall	.+2506   	; 0x123a <_ZN6Timer116setDutyCycleComAEf>
		vTaskDelay( delay_ / portTICK_RATE_MS );
     870:	8f 89       	ldd	r24, Y+23	; 0x17
     872:	98 8d       	ldd	r25, Y+24	; 0x18
     874:	0e 94 ff 0e 	call	0x1dfe	; 0x1dfe <vTaskDelay>
	}
}
     878:	df 91       	pop	r29
     87a:	cf 91       	pop	r28
     87c:	ff 90       	pop	r15
     87e:	ef 90       	pop	r14
     880:	df 90       	pop	r13
     882:	cf 90       	pop	r12
     884:	bf 90       	pop	r11
     886:	af 90       	pop	r10
     888:	9f 90       	pop	r9
     88a:	8f 90       	pop	r8
     88c:	7f 90       	pop	r7
     88e:	6f 90       	pop	r6
     890:	5f 90       	pop	r5
     892:	4f 90       	pop	r4
     894:	08 95       	ret

00000896 <_ZN2M1C1EP6Timer1>:
* Author: jespe
*/

#include "M1.h"

M1::M1( Timer1* tmr )
     896:	cf 93       	push	r28
     898:	df 93       	push	r29
     89a:	ec 01       	movw	r28, r24
     89c:	cb 01       	movw	r24, r22
     89e:	2c e7       	ldi	r18, 0x7C	; 124
     8a0:	32 e0       	ldi	r19, 0x02	; 2
     8a2:	39 83       	std	Y+1, r19	; 0x01
     8a4:	28 83       	st	Y, r18
{
	/* Store timer pointer */
	tmr1Ptr_ = tmr;
     8a6:	7b 83       	std	Y+3, r23	; 0x03
     8a8:	6a 83       	std	Y+2, r22	; 0x02
	
	/* This value is number of percent to add or subtract pr degree. */
	percentPrDeg = 0.0555555555555556;
     8aa:	49 e3       	ldi	r20, 0x39	; 57
     8ac:	5e e8       	ldi	r21, 0x8E	; 142
     8ae:	63 e6       	ldi	r22, 0x63	; 99
     8b0:	7d e3       	ldi	r23, 0x3D	; 61
     8b2:	4e 83       	std	Y+6, r20	; 0x06
     8b4:	5f 83       	std	Y+7, r21	; 0x07
     8b6:	68 87       	std	Y+8, r22	; 0x08
     8b8:	79 87       	std	Y+9, r23	; 0x09
	
	/* This value is the lowest duty cycle percentage needed to make motor turn. */
	startpercent_ = 2.5;
     8ba:	40 e0       	ldi	r20, 0x00	; 0
     8bc:	50 e0       	ldi	r21, 0x00	; 0
     8be:	60 e2       	ldi	r22, 0x20	; 32
     8c0:	70 e4       	ldi	r23, 0x40	; 64
     8c2:	4a 8b       	std	Y+18, r20	; 0x12
     8c4:	5b 8b       	std	Y+19, r21	; 0x13
     8c6:	6c 8b       	std	Y+20, r22	; 0x14
     8c8:	7d 8b       	std	Y+21, r23	; 0x15
	
	/* This value is the delay on motor. A lower value makes motors go faster and higher value makes motors go slower. */
	delay_ = 10;
     8ca:	2a e0       	ldi	r18, 0x0A	; 10
     8cc:	30 e0       	ldi	r19, 0x00	; 0
     8ce:	38 8f       	std	Y+24, r19	; 0x18
     8d0:	2f 8b       	std	Y+23, r18	; 0x17
	
	/* This value is the maximum number of degrees the motor can turn */
	maxDegrees_ = 180;
     8d2:	24 eb       	ldi	r18, 0xB4	; 180
     8d4:	2e 8b       	std	Y+22, r18	; 0x16
	*/
	virtual void SetDegrees( uint8_t degrees )
	{
		if ( maxDegrees_ >= degrees )
		{
			percent_ = percentPrDeg * degrees + startpercent_;
     8d6:	40 e0       	ldi	r20, 0x00	; 0
     8d8:	50 e0       	ldi	r21, 0x00	; 0
     8da:	60 ef       	ldi	r22, 0xF0	; 240
     8dc:	70 e4       	ldi	r23, 0x40	; 64
     8de:	4a 87       	std	Y+10, r20	; 0x0a
     8e0:	5b 87       	std	Y+11, r21	; 0x0b
     8e2:	6c 87       	std	Y+12, r22	; 0x0c
     8e4:	7d 87       	std	Y+13, r23	; 0x0d
	
	/* Set motor to default startup value */
	SetDegrees( 90 );
	tmr1Ptr_->setDutyCycleComA( percent_ );
     8e6:	a9 d4       	rcall	.+2386   	; 0x123a <_ZN6Timer116setDutyCycleComAEf>
	oldPercent_ = percent_;
     8e8:	8a 85       	ldd	r24, Y+10	; 0x0a
     8ea:	9b 85       	ldd	r25, Y+11	; 0x0b
     8ec:	ac 85       	ldd	r26, Y+12	; 0x0c
     8ee:	bd 85       	ldd	r27, Y+13	; 0x0d
     8f0:	8e 87       	std	Y+14, r24	; 0x0e
     8f2:	9f 87       	std	Y+15, r25	; 0x0f
     8f4:	a8 8b       	std	Y+16, r26	; 0x10
     8f6:	b9 8b       	std	Y+17, r27	; 0x11
} 
     8f8:	df 91       	pop	r29
     8fa:	cf 91       	pop	r28
     8fc:	08 95       	ret

000008fe <_ZN2M2D1Ev>:

class Motor
{
//functions
public:
	virtual ~Motor() {};
     8fe:	20 e7       	ldi	r18, 0x70	; 112
     900:	32 e0       	ldi	r19, 0x02	; 2
     902:	fc 01       	movw	r30, r24
     904:	31 83       	std	Z+1, r19	; 0x01
     906:	20 83       	st	Z, r18
     908:	08 95       	ret

0000090a <_ZN2M2D0Ev>:
	SetDegrees( 90 );
	tmr1Ptr_->setDutyCycleComB( percent_ );
	oldPercent_ = percent_;
}

M2::~M2()
     90a:	cf 93       	push	r28
     90c:	df 93       	push	r29
     90e:	ec 01       	movw	r28, r24
{
}
     910:	f6 df       	rcall	.-20     	; 0x8fe <_ZN2M2D1Ev>
     912:	ce 01       	movw	r24, r28
     914:	fe de       	rcall	.-516    	; 0x712 <_ZdlPv>
     916:	df 91       	pop	r29
     918:	cf 91       	pop	r28
     91a:	08 95       	ret

0000091c <_ZN2M29TurnMotorEv>:

void M2::TurnMotor()
{
     91c:	4f 92       	push	r4
     91e:	5f 92       	push	r5
     920:	6f 92       	push	r6
     922:	7f 92       	push	r7
     924:	8f 92       	push	r8
     926:	9f 92       	push	r9
     928:	af 92       	push	r10
     92a:	bf 92       	push	r11
     92c:	cf 92       	push	r12
     92e:	df 92       	push	r13
     930:	ef 92       	push	r14
     932:	ff 92       	push	r15
     934:	cf 93       	push	r28
     936:	df 93       	push	r29
     938:	ec 01       	movw	r28, r24
	if ( percent_ > oldPercent_ + PERCENT_PR_TICK )
     93a:	8a 84       	ldd	r8, Y+10	; 0x0a
     93c:	9b 84       	ldd	r9, Y+11	; 0x0b
     93e:	ac 84       	ldd	r10, Y+12	; 0x0c
     940:	bd 84       	ldd	r11, Y+13	; 0x0d
     942:	ce 84       	ldd	r12, Y+14	; 0x0e
     944:	df 84       	ldd	r13, Y+15	; 0x0f
     946:	e8 88       	ldd	r14, Y+16	; 0x10
     948:	f9 88       	ldd	r15, Y+17	; 0x11
     94a:	20 e0       	ldi	r18, 0x00	; 0
     94c:	30 e0       	ldi	r19, 0x00	; 0
     94e:	40 e8       	ldi	r20, 0x80	; 128
     950:	5d e3       	ldi	r21, 0x3D	; 61
     952:	c7 01       	movw	r24, r14
     954:	b6 01       	movw	r22, r12
     956:	0e 94 dd 0f 	call	0x1fba	; 0x1fba <__addsf3>
     95a:	2b 01       	movw	r4, r22
     95c:	3c 01       	movw	r6, r24
     95e:	9b 01       	movw	r18, r22
     960:	ac 01       	movw	r20, r24
     962:	c5 01       	movw	r24, r10
     964:	b4 01       	movw	r22, r8
     966:	0e 94 23 11 	call	0x2246	; 0x2246 <__gesf2>
     96a:	18 16       	cp	r1, r24
     96c:	74 f4       	brge	.+28     	; 0x98a <_ZN2M29TurnMotorEv+0x6e>
	{
		oldPercent_ += PERCENT_PR_TICK;
     96e:	4e 86       	std	Y+14, r4	; 0x0e
     970:	5f 86       	std	Y+15, r5	; 0x0f
     972:	68 8a       	std	Y+16, r6	; 0x10
     974:	79 8a       	std	Y+17, r7	; 0x11
		tmr1Ptr_->setDutyCycleComB( oldPercent_ );
     976:	b3 01       	movw	r22, r6
     978:	a2 01       	movw	r20, r4
     97a:	8a 81       	ldd	r24, Y+2	; 0x02
     97c:	9b 81       	ldd	r25, Y+3	; 0x03
     97e:	85 d4       	rcall	.+2314   	; 0x128a <_ZN6Timer116setDutyCycleComBEf>
		vTaskDelay( delay_ / portTICK_RATE_MS );
     980:	8f 89       	ldd	r24, Y+23	; 0x17
     982:	98 8d       	ldd	r25, Y+24	; 0x18
     984:	0e 94 ff 0e 	call	0x1dfe	; 0x1dfe <vTaskDelay>
     988:	1d c0       	rjmp	.+58     	; 0x9c4 <_ZN2M29TurnMotorEv+0xa8>
	}
	else if ( percent_ < oldPercent_ )
     98a:	a7 01       	movw	r20, r14
     98c:	96 01       	movw	r18, r12
     98e:	c5 01       	movw	r24, r10
     990:	b4 01       	movw	r22, r8
     992:	0e 94 41 10 	call	0x2082	; 0x2082 <__cmpsf2>
     996:	88 23       	and	r24, r24
     998:	ac f4       	brge	.+42     	; 0x9c4 <_ZN2M29TurnMotorEv+0xa8>
	{
		oldPercent_ -= PERCENT_PR_TICK;
     99a:	20 e0       	ldi	r18, 0x00	; 0
     99c:	30 e0       	ldi	r19, 0x00	; 0
     99e:	40 e8       	ldi	r20, 0x80	; 128
     9a0:	5d e3       	ldi	r21, 0x3D	; 61
     9a2:	c7 01       	movw	r24, r14
     9a4:	b6 01       	movw	r22, r12
     9a6:	0e 94 dc 0f 	call	0x1fb8	; 0x1fb8 <__subsf3>
     9aa:	ab 01       	movw	r20, r22
     9ac:	bc 01       	movw	r22, r24
     9ae:	4e 87       	std	Y+14, r20	; 0x0e
     9b0:	5f 87       	std	Y+15, r21	; 0x0f
     9b2:	68 8b       	std	Y+16, r22	; 0x10
     9b4:	79 8b       	std	Y+17, r23	; 0x11
		tmr1Ptr_->setDutyCycleComB( oldPercent_ );
     9b6:	8a 81       	ldd	r24, Y+2	; 0x02
     9b8:	9b 81       	ldd	r25, Y+3	; 0x03
     9ba:	67 d4       	rcall	.+2254   	; 0x128a <_ZN6Timer116setDutyCycleComBEf>
		vTaskDelay( delay_ / portTICK_RATE_MS );
     9bc:	8f 89       	ldd	r24, Y+23	; 0x17
     9be:	98 8d       	ldd	r25, Y+24	; 0x18
     9c0:	0e 94 ff 0e 	call	0x1dfe	; 0x1dfe <vTaskDelay>
	}
}
     9c4:	df 91       	pop	r29
     9c6:	cf 91       	pop	r28
     9c8:	ff 90       	pop	r15
     9ca:	ef 90       	pop	r14
     9cc:	df 90       	pop	r13
     9ce:	cf 90       	pop	r12
     9d0:	bf 90       	pop	r11
     9d2:	af 90       	pop	r10
     9d4:	9f 90       	pop	r9
     9d6:	8f 90       	pop	r8
     9d8:	7f 90       	pop	r7
     9da:	6f 90       	pop	r6
     9dc:	5f 90       	pop	r5
     9de:	4f 90       	pop	r4
     9e0:	08 95       	ret

000009e2 <_ZN2M2C1EP6Timer1>:
* Author: jespe
*/

#include "M2.h"

M2::M2( Timer1* tmr )
     9e2:	cf 93       	push	r28
     9e4:	df 93       	push	r29
     9e6:	ec 01       	movw	r28, r24
     9e8:	cb 01       	movw	r24, r22
     9ea:	28 e8       	ldi	r18, 0x88	; 136
     9ec:	32 e0       	ldi	r19, 0x02	; 2
     9ee:	39 83       	std	Y+1, r19	; 0x01
     9f0:	28 83       	st	Y, r18
{
	/* Store timer pointer */
	tmr1Ptr_ = tmr;
     9f2:	7b 83       	std	Y+3, r23	; 0x03
     9f4:	6a 83       	std	Y+2, r22	; 0x02
	
	/* This value is number of percent to add or subtract pr degree. */
	percentPrDeg = 0.06;
     9f6:	4f e8       	ldi	r20, 0x8F	; 143
     9f8:	52 ec       	ldi	r21, 0xC2	; 194
     9fa:	65 e7       	ldi	r22, 0x75	; 117
     9fc:	7d e3       	ldi	r23, 0x3D	; 61
     9fe:	4e 83       	std	Y+6, r20	; 0x06
     a00:	5f 83       	std	Y+7, r21	; 0x07
     a02:	68 87       	std	Y+8, r22	; 0x08
     a04:	79 87       	std	Y+9, r23	; 0x09

	/* This value is the lowest duty cycle percentage needed to make motor turn. */
	startpercent_ = 3;
     a06:	40 e0       	ldi	r20, 0x00	; 0
     a08:	50 e0       	ldi	r21, 0x00	; 0
     a0a:	60 e4       	ldi	r22, 0x40	; 64
     a0c:	70 e4       	ldi	r23, 0x40	; 64
     a0e:	4a 8b       	std	Y+18, r20	; 0x12
     a10:	5b 8b       	std	Y+19, r21	; 0x13
     a12:	6c 8b       	std	Y+20, r22	; 0x14
     a14:	7d 8b       	std	Y+21, r23	; 0x15

	/* This value is the delay on motor. A lower value makes motors go faster and higher value makes motors go slower. Value is in MS */
	delay_ = 10;
     a16:	2a e0       	ldi	r18, 0x0A	; 10
     a18:	30 e0       	ldi	r19, 0x00	; 0
     a1a:	38 8f       	std	Y+24, r19	; 0x18
     a1c:	2f 8b       	std	Y+23, r18	; 0x17

	/* This value is the maximum number of degrees the motor can turn */
	maxDegrees_ = 150;
     a1e:	26 e9       	ldi	r18, 0x96	; 150
     a20:	2e 8b       	std	Y+22, r18	; 0x16
	*/
	virtual void SetDegrees( uint8_t degrees )
	{
		if ( maxDegrees_ >= degrees )
		{
			percent_ = percentPrDeg * degrees + startpercent_;
     a22:	46 e6       	ldi	r20, 0x66	; 102
     a24:	56 e6       	ldi	r21, 0x66	; 102
     a26:	66 e0       	ldi	r22, 0x06	; 6
     a28:	71 e4       	ldi	r23, 0x41	; 65
     a2a:	4a 87       	std	Y+10, r20	; 0x0a
     a2c:	5b 87       	std	Y+11, r21	; 0x0b
     a2e:	6c 87       	std	Y+12, r22	; 0x0c
     a30:	7d 87       	std	Y+13, r23	; 0x0d

	/* Set motor to default startup value */
	SetDegrees( 90 );
	tmr1Ptr_->setDutyCycleComB( percent_ );
     a32:	2b d4       	rcall	.+2134   	; 0x128a <_ZN6Timer116setDutyCycleComBEf>
	oldPercent_ = percent_;
     a34:	8a 85       	ldd	r24, Y+10	; 0x0a
     a36:	9b 85       	ldd	r25, Y+11	; 0x0b
     a38:	ac 85       	ldd	r26, Y+12	; 0x0c
     a3a:	bd 85       	ldd	r27, Y+13	; 0x0d
     a3c:	8e 87       	std	Y+14, r24	; 0x0e
     a3e:	9f 87       	std	Y+15, r25	; 0x0f
     a40:	a8 8b       	std	Y+16, r26	; 0x10
     a42:	b9 8b       	std	Y+17, r27	; 0x11
}
     a44:	df 91       	pop	r29
     a46:	cf 91       	pop	r28
     a48:	08 95       	ret

00000a4a <_ZN2M3D1Ev>:

class Motor
{
//functions
public:
	virtual ~Motor() {};
     a4a:	20 e7       	ldi	r18, 0x70	; 112
     a4c:	32 e0       	ldi	r19, 0x02	; 2
     a4e:	fc 01       	movw	r30, r24
     a50:	31 83       	std	Z+1, r19	; 0x01
     a52:	20 83       	st	Z, r18
     a54:	08 95       	ret

00000a56 <_ZN2M3D0Ev>:
	SetDegrees( 90 );
	tmr1Ptr_->setDutyCycleComC( percent_ );
	oldPercent_ = percent_;	
}

M3::~M3()
     a56:	cf 93       	push	r28
     a58:	df 93       	push	r29
     a5a:	ec 01       	movw	r28, r24
{
}
     a5c:	f6 df       	rcall	.-20     	; 0xa4a <_ZN2M3D1Ev>
     a5e:	ce 01       	movw	r24, r28
     a60:	58 de       	rcall	.-848    	; 0x712 <_ZdlPv>
     a62:	df 91       	pop	r29
     a64:	cf 91       	pop	r28
     a66:	08 95       	ret

00000a68 <_ZN2M39TurnMotorEv>:

void M3::TurnMotor()
{
     a68:	4f 92       	push	r4
     a6a:	5f 92       	push	r5
     a6c:	6f 92       	push	r6
     a6e:	7f 92       	push	r7
     a70:	8f 92       	push	r8
     a72:	9f 92       	push	r9
     a74:	af 92       	push	r10
     a76:	bf 92       	push	r11
     a78:	cf 92       	push	r12
     a7a:	df 92       	push	r13
     a7c:	ef 92       	push	r14
     a7e:	ff 92       	push	r15
     a80:	cf 93       	push	r28
     a82:	df 93       	push	r29
     a84:	ec 01       	movw	r28, r24
	if ( percent_ > oldPercent_ + PERCENT_PR_TICK )
     a86:	8a 84       	ldd	r8, Y+10	; 0x0a
     a88:	9b 84       	ldd	r9, Y+11	; 0x0b
     a8a:	ac 84       	ldd	r10, Y+12	; 0x0c
     a8c:	bd 84       	ldd	r11, Y+13	; 0x0d
     a8e:	ce 84       	ldd	r12, Y+14	; 0x0e
     a90:	df 84       	ldd	r13, Y+15	; 0x0f
     a92:	e8 88       	ldd	r14, Y+16	; 0x10
     a94:	f9 88       	ldd	r15, Y+17	; 0x11
     a96:	20 e0       	ldi	r18, 0x00	; 0
     a98:	30 e0       	ldi	r19, 0x00	; 0
     a9a:	40 e8       	ldi	r20, 0x80	; 128
     a9c:	5d e3       	ldi	r21, 0x3D	; 61
     a9e:	c7 01       	movw	r24, r14
     aa0:	b6 01       	movw	r22, r12
     aa2:	0e 94 dd 0f 	call	0x1fba	; 0x1fba <__addsf3>
     aa6:	2b 01       	movw	r4, r22
     aa8:	3c 01       	movw	r6, r24
     aaa:	9b 01       	movw	r18, r22
     aac:	ac 01       	movw	r20, r24
     aae:	c5 01       	movw	r24, r10
     ab0:	b4 01       	movw	r22, r8
     ab2:	0e 94 23 11 	call	0x2246	; 0x2246 <__gesf2>
     ab6:	18 16       	cp	r1, r24
     ab8:	74 f4       	brge	.+28     	; 0xad6 <_ZN2M39TurnMotorEv+0x6e>
	{
		oldPercent_ += PERCENT_PR_TICK;
     aba:	4e 86       	std	Y+14, r4	; 0x0e
     abc:	5f 86       	std	Y+15, r5	; 0x0f
     abe:	68 8a       	std	Y+16, r6	; 0x10
     ac0:	79 8a       	std	Y+17, r7	; 0x11
		tmr1Ptr_->setDutyCycleComC( oldPercent_ );
     ac2:	b3 01       	movw	r22, r6
     ac4:	a2 01       	movw	r20, r4
     ac6:	8a 81       	ldd	r24, Y+2	; 0x02
     ac8:	9b 81       	ldd	r25, Y+3	; 0x03
     aca:	07 d4       	rcall	.+2062   	; 0x12da <_ZN6Timer116setDutyCycleComCEf>
		vTaskDelay( delay_ / portTICK_RATE_MS );
     acc:	8f 89       	ldd	r24, Y+23	; 0x17
     ace:	98 8d       	ldd	r25, Y+24	; 0x18
     ad0:	0e 94 ff 0e 	call	0x1dfe	; 0x1dfe <vTaskDelay>
     ad4:	1d c0       	rjmp	.+58     	; 0xb10 <_ZN2M39TurnMotorEv+0xa8>
	}
	else if ( percent_ < oldPercent_ )
     ad6:	a7 01       	movw	r20, r14
     ad8:	96 01       	movw	r18, r12
     ada:	c5 01       	movw	r24, r10
     adc:	b4 01       	movw	r22, r8
     ade:	0e 94 41 10 	call	0x2082	; 0x2082 <__cmpsf2>
     ae2:	88 23       	and	r24, r24
     ae4:	ac f4       	brge	.+42     	; 0xb10 <_ZN2M39TurnMotorEv+0xa8>
	{
		oldPercent_ -= PERCENT_PR_TICK;
     ae6:	20 e0       	ldi	r18, 0x00	; 0
     ae8:	30 e0       	ldi	r19, 0x00	; 0
     aea:	40 e8       	ldi	r20, 0x80	; 128
     aec:	5d e3       	ldi	r21, 0x3D	; 61
     aee:	c7 01       	movw	r24, r14
     af0:	b6 01       	movw	r22, r12
     af2:	0e 94 dc 0f 	call	0x1fb8	; 0x1fb8 <__subsf3>
     af6:	ab 01       	movw	r20, r22
     af8:	bc 01       	movw	r22, r24
     afa:	4e 87       	std	Y+14, r20	; 0x0e
     afc:	5f 87       	std	Y+15, r21	; 0x0f
     afe:	68 8b       	std	Y+16, r22	; 0x10
     b00:	79 8b       	std	Y+17, r23	; 0x11
		tmr1Ptr_->setDutyCycleComC( oldPercent_ );
     b02:	8a 81       	ldd	r24, Y+2	; 0x02
     b04:	9b 81       	ldd	r25, Y+3	; 0x03
     b06:	e9 d3       	rcall	.+2002   	; 0x12da <_ZN6Timer116setDutyCycleComCEf>
		vTaskDelay( delay_ / portTICK_RATE_MS );
     b08:	8f 89       	ldd	r24, Y+23	; 0x17
     b0a:	98 8d       	ldd	r25, Y+24	; 0x18
     b0c:	0e 94 ff 0e 	call	0x1dfe	; 0x1dfe <vTaskDelay>
	}
}
     b10:	df 91       	pop	r29
     b12:	cf 91       	pop	r28
     b14:	ff 90       	pop	r15
     b16:	ef 90       	pop	r14
     b18:	df 90       	pop	r13
     b1a:	cf 90       	pop	r12
     b1c:	bf 90       	pop	r11
     b1e:	af 90       	pop	r10
     b20:	9f 90       	pop	r9
     b22:	8f 90       	pop	r8
     b24:	7f 90       	pop	r7
     b26:	6f 90       	pop	r6
     b28:	5f 90       	pop	r5
     b2a:	4f 90       	pop	r4
     b2c:	08 95       	ret

00000b2e <_ZN2M3C1EP6Timer1>:
*/

#include "M3.h"


M3::M3( Timer1* tmr )
     b2e:	cf 93       	push	r28
     b30:	df 93       	push	r29
     b32:	ec 01       	movw	r28, r24
     b34:	cb 01       	movw	r24, r22
     b36:	24 e9       	ldi	r18, 0x94	; 148
     b38:	32 e0       	ldi	r19, 0x02	; 2
     b3a:	39 83       	std	Y+1, r19	; 0x01
     b3c:	28 83       	st	Y, r18
{
	/* Store timer pointer */
	tmr1Ptr_ = tmr;
     b3e:	7b 83       	std	Y+3, r23	; 0x03
     b40:	6a 83       	std	Y+2, r22	; 0x02
		
	/* This value is number of percent to add or subtract pr degree. */
	percentPrDeg = 0.0555555555555556;
     b42:	49 e3       	ldi	r20, 0x39	; 57
     b44:	5e e8       	ldi	r21, 0x8E	; 142
     b46:	63 e6       	ldi	r22, 0x63	; 99
     b48:	7d e3       	ldi	r23, 0x3D	; 61
     b4a:	4e 83       	std	Y+6, r20	; 0x06
     b4c:	5f 83       	std	Y+7, r21	; 0x07
     b4e:	68 87       	std	Y+8, r22	; 0x08
     b50:	79 87       	std	Y+9, r23	; 0x09
	
	/* This value is the lowest duty cycle percentage needed to make motor turn. */
	startpercent_ = 2.5;
     b52:	40 e0       	ldi	r20, 0x00	; 0
     b54:	50 e0       	ldi	r21, 0x00	; 0
     b56:	60 e2       	ldi	r22, 0x20	; 32
     b58:	70 e4       	ldi	r23, 0x40	; 64
     b5a:	4a 8b       	std	Y+18, r20	; 0x12
     b5c:	5b 8b       	std	Y+19, r21	; 0x13
     b5e:	6c 8b       	std	Y+20, r22	; 0x14
     b60:	7d 8b       	std	Y+21, r23	; 0x15

	/* This value is the delay on motor. A lower value makes motors go faster and higher value makes motors go slower. Value is in MS */
	delay_ = 10;
     b62:	2a e0       	ldi	r18, 0x0A	; 10
     b64:	30 e0       	ldi	r19, 0x00	; 0
     b66:	38 8f       	std	Y+24, r19	; 0x18
     b68:	2f 8b       	std	Y+23, r18	; 0x17
	
	/* This value is the maximum number of degrees the motor can turn */
	maxDegrees_ = 180;
     b6a:	24 eb       	ldi	r18, 0xB4	; 180
     b6c:	2e 8b       	std	Y+22, r18	; 0x16
	*/
	virtual void SetDegrees( uint8_t degrees )
	{
		if ( maxDegrees_ >= degrees )
		{
			percent_ = percentPrDeg * degrees + startpercent_;
     b6e:	40 e0       	ldi	r20, 0x00	; 0
     b70:	50 e0       	ldi	r21, 0x00	; 0
     b72:	60 ef       	ldi	r22, 0xF0	; 240
     b74:	70 e4       	ldi	r23, 0x40	; 64
     b76:	4a 87       	std	Y+10, r20	; 0x0a
     b78:	5b 87       	std	Y+11, r21	; 0x0b
     b7a:	6c 87       	std	Y+12, r22	; 0x0c
     b7c:	7d 87       	std	Y+13, r23	; 0x0d
	
	/* Set motor to default startup value */
	SetDegrees( 90 );
	tmr1Ptr_->setDutyCycleComC( percent_ );
     b7e:	ad d3       	rcall	.+1882   	; 0x12da <_ZN6Timer116setDutyCycleComCEf>
	oldPercent_ = percent_;	
     b80:	8a 85       	ldd	r24, Y+10	; 0x0a
     b82:	9b 85       	ldd	r25, Y+11	; 0x0b
     b84:	ac 85       	ldd	r26, Y+12	; 0x0c
     b86:	bd 85       	ldd	r27, Y+13	; 0x0d
     b88:	8e 87       	std	Y+14, r24	; 0x0e
     b8a:	9f 87       	std	Y+15, r25	; 0x0f
     b8c:	a8 8b       	std	Y+16, r26	; 0x10
     b8e:	b9 8b       	std	Y+17, r27	; 0x11
}
     b90:	df 91       	pop	r29
     b92:	cf 91       	pop	r28
     b94:	08 95       	ret

00000b96 <_ZN2M4D1Ev>:

class Motor
{
//functions
public:
	virtual ~Motor() {};
     b96:	20 e7       	ldi	r18, 0x70	; 112
     b98:	32 e0       	ldi	r19, 0x02	; 2
     b9a:	fc 01       	movw	r30, r24
     b9c:	31 83       	std	Z+1, r19	; 0x01
     b9e:	20 83       	st	Z, r18
     ba0:	08 95       	ret

00000ba2 <_ZN2M4D0Ev>:
	SetDegrees( 90 );
	tmr3Ptr_->setDutyCycleComA( percent_ );
	oldPercent_ = percent_;
}

M4::~M4()
     ba2:	cf 93       	push	r28
     ba4:	df 93       	push	r29
     ba6:	ec 01       	movw	r28, r24
{
} 
     ba8:	f6 df       	rcall	.-20     	; 0xb96 <_ZN2M4D1Ev>
     baa:	ce 01       	movw	r24, r28
     bac:	b2 dd       	rcall	.-1180   	; 0x712 <_ZdlPv>
     bae:	df 91       	pop	r29
     bb0:	cf 91       	pop	r28
     bb2:	08 95       	ret

00000bb4 <_ZN2M49TurnMotorEv>:

void M4::TurnMotor()
{
     bb4:	4f 92       	push	r4
     bb6:	5f 92       	push	r5
     bb8:	6f 92       	push	r6
     bba:	7f 92       	push	r7
     bbc:	8f 92       	push	r8
     bbe:	9f 92       	push	r9
     bc0:	af 92       	push	r10
     bc2:	bf 92       	push	r11
     bc4:	cf 92       	push	r12
     bc6:	df 92       	push	r13
     bc8:	ef 92       	push	r14
     bca:	ff 92       	push	r15
     bcc:	cf 93       	push	r28
     bce:	df 93       	push	r29
     bd0:	ec 01       	movw	r28, r24
	if ( percent_ > oldPercent_ + PERCENT_PR_TICK )
     bd2:	8a 84       	ldd	r8, Y+10	; 0x0a
     bd4:	9b 84       	ldd	r9, Y+11	; 0x0b
     bd6:	ac 84       	ldd	r10, Y+12	; 0x0c
     bd8:	bd 84       	ldd	r11, Y+13	; 0x0d
     bda:	ce 84       	ldd	r12, Y+14	; 0x0e
     bdc:	df 84       	ldd	r13, Y+15	; 0x0f
     bde:	e8 88       	ldd	r14, Y+16	; 0x10
     be0:	f9 88       	ldd	r15, Y+17	; 0x11
     be2:	20 e0       	ldi	r18, 0x00	; 0
     be4:	30 e0       	ldi	r19, 0x00	; 0
     be6:	40 e8       	ldi	r20, 0x80	; 128
     be8:	5d e3       	ldi	r21, 0x3D	; 61
     bea:	c7 01       	movw	r24, r14
     bec:	b6 01       	movw	r22, r12
     bee:	0e 94 dd 0f 	call	0x1fba	; 0x1fba <__addsf3>
     bf2:	2b 01       	movw	r4, r22
     bf4:	3c 01       	movw	r6, r24
     bf6:	9b 01       	movw	r18, r22
     bf8:	ac 01       	movw	r20, r24
     bfa:	c5 01       	movw	r24, r10
     bfc:	b4 01       	movw	r22, r8
     bfe:	0e 94 23 11 	call	0x2246	; 0x2246 <__gesf2>
     c02:	18 16       	cp	r1, r24
     c04:	74 f4       	brge	.+28     	; 0xc22 <_ZN2M49TurnMotorEv+0x6e>
	{
		oldPercent_ += PERCENT_PR_TICK;
     c06:	4e 86       	std	Y+14, r4	; 0x0e
     c08:	5f 86       	std	Y+15, r5	; 0x0f
     c0a:	68 8a       	std	Y+16, r6	; 0x10
     c0c:	79 8a       	std	Y+17, r7	; 0x11
		tmr3Ptr_->setDutyCycleComA( oldPercent_ );
     c0e:	b3 01       	movw	r22, r6
     c10:	a2 01       	movw	r20, r4
     c12:	8c 81       	ldd	r24, Y+4	; 0x04
     c14:	9d 81       	ldd	r25, Y+5	; 0x05
     c16:	a9 d3       	rcall	.+1874   	; 0x136a <_ZN6Timer516setDutyCycleComAEf>
		vTaskDelay( 10 / portTICK_RATE_MS );
     c18:	8a e0       	ldi	r24, 0x0A	; 10
     c1a:	90 e0       	ldi	r25, 0x00	; 0
     c1c:	0e 94 ff 0e 	call	0x1dfe	; 0x1dfe <vTaskDelay>
     c20:	1d c0       	rjmp	.+58     	; 0xc5c <_ZN2M49TurnMotorEv+0xa8>
	}
	else if ( percent_ < oldPercent_ )
     c22:	a7 01       	movw	r20, r14
     c24:	96 01       	movw	r18, r12
     c26:	c5 01       	movw	r24, r10
     c28:	b4 01       	movw	r22, r8
     c2a:	0e 94 41 10 	call	0x2082	; 0x2082 <__cmpsf2>
     c2e:	88 23       	and	r24, r24
     c30:	ac f4       	brge	.+42     	; 0xc5c <_ZN2M49TurnMotorEv+0xa8>
	{
		oldPercent_ -= PERCENT_PR_TICK;
     c32:	20 e0       	ldi	r18, 0x00	; 0
     c34:	30 e0       	ldi	r19, 0x00	; 0
     c36:	40 e8       	ldi	r20, 0x80	; 128
     c38:	5d e3       	ldi	r21, 0x3D	; 61
     c3a:	c7 01       	movw	r24, r14
     c3c:	b6 01       	movw	r22, r12
     c3e:	0e 94 dc 0f 	call	0x1fb8	; 0x1fb8 <__subsf3>
     c42:	ab 01       	movw	r20, r22
     c44:	bc 01       	movw	r22, r24
     c46:	4e 87       	std	Y+14, r20	; 0x0e
     c48:	5f 87       	std	Y+15, r21	; 0x0f
     c4a:	68 8b       	std	Y+16, r22	; 0x10
     c4c:	79 8b       	std	Y+17, r23	; 0x11
		tmr3Ptr_->setDutyCycleComA( oldPercent_ );
     c4e:	8c 81       	ldd	r24, Y+4	; 0x04
     c50:	9d 81       	ldd	r25, Y+5	; 0x05
     c52:	8b d3       	rcall	.+1814   	; 0x136a <_ZN6Timer516setDutyCycleComAEf>
		vTaskDelay( 10 / portTICK_RATE_MS );
     c54:	8a e0       	ldi	r24, 0x0A	; 10
     c56:	90 e0       	ldi	r25, 0x00	; 0
     c58:	0e 94 ff 0e 	call	0x1dfe	; 0x1dfe <vTaskDelay>
	}
}
     c5c:	df 91       	pop	r29
     c5e:	cf 91       	pop	r28
     c60:	ff 90       	pop	r15
     c62:	ef 90       	pop	r14
     c64:	df 90       	pop	r13
     c66:	cf 90       	pop	r12
     c68:	bf 90       	pop	r11
     c6a:	af 90       	pop	r10
     c6c:	9f 90       	pop	r9
     c6e:	8f 90       	pop	r8
     c70:	7f 90       	pop	r7
     c72:	6f 90       	pop	r6
     c74:	5f 90       	pop	r5
     c76:	4f 90       	pop	r4
     c78:	08 95       	ret

00000c7a <_ZN2M4C1EP6Timer5>:
* Author: jespe
*/

#include "M4.h"

M4::M4( Timer5* tmr )
     c7a:	cf 93       	push	r28
     c7c:	df 93       	push	r29
     c7e:	ec 01       	movw	r28, r24
     c80:	cb 01       	movw	r24, r22
     c82:	20 ea       	ldi	r18, 0xA0	; 160
     c84:	32 e0       	ldi	r19, 0x02	; 2
     c86:	39 83       	std	Y+1, r19	; 0x01
     c88:	28 83       	st	Y, r18
{
	/* Store timer pointer */
	tmr3Ptr_ = tmr;
     c8a:	7d 83       	std	Y+5, r23	; 0x05
     c8c:	6c 83       	std	Y+4, r22	; 0x04
	
	/* This value is number of percent to add or subtract pr degree. */
	percentPrDeg = 0.0555555555555556;
     c8e:	49 e3       	ldi	r20, 0x39	; 57
     c90:	5e e8       	ldi	r21, 0x8E	; 142
     c92:	63 e6       	ldi	r22, 0x63	; 99
     c94:	7d e3       	ldi	r23, 0x3D	; 61
     c96:	4e 83       	std	Y+6, r20	; 0x06
     c98:	5f 83       	std	Y+7, r21	; 0x07
     c9a:	68 87       	std	Y+8, r22	; 0x08
     c9c:	79 87       	std	Y+9, r23	; 0x09
	
	/* This value is the lowest duty cycle percentage needed to make motor turn. */
	startpercent_ = 2.5;
     c9e:	40 e0       	ldi	r20, 0x00	; 0
     ca0:	50 e0       	ldi	r21, 0x00	; 0
     ca2:	60 e2       	ldi	r22, 0x20	; 32
     ca4:	70 e4       	ldi	r23, 0x40	; 64
     ca6:	4a 8b       	std	Y+18, r20	; 0x12
     ca8:	5b 8b       	std	Y+19, r21	; 0x13
     caa:	6c 8b       	std	Y+20, r22	; 0x14
     cac:	7d 8b       	std	Y+21, r23	; 0x15
		
	/* This value is the delay on motor. A lower value makes motors go faster and higher value makes motors go slower. Value is in MS */
	delay_ = 5;
     cae:	25 e0       	ldi	r18, 0x05	; 5
     cb0:	30 e0       	ldi	r19, 0x00	; 0
     cb2:	38 8f       	std	Y+24, r19	; 0x18
     cb4:	2f 8b       	std	Y+23, r18	; 0x17
	
	/* This value is the maximum number of degrees the motor can turn */
	maxDegrees_ = 180;
     cb6:	24 eb       	ldi	r18, 0xB4	; 180
     cb8:	2e 8b       	std	Y+22, r18	; 0x16
	*/
	virtual void SetDegrees( uint8_t degrees )
	{
		if ( maxDegrees_ >= degrees )
		{
			percent_ = percentPrDeg * degrees + startpercent_;
     cba:	40 e0       	ldi	r20, 0x00	; 0
     cbc:	50 e0       	ldi	r21, 0x00	; 0
     cbe:	60 ef       	ldi	r22, 0xF0	; 240
     cc0:	70 e4       	ldi	r23, 0x40	; 64
     cc2:	4a 87       	std	Y+10, r20	; 0x0a
     cc4:	5b 87       	std	Y+11, r21	; 0x0b
     cc6:	6c 87       	std	Y+12, r22	; 0x0c
     cc8:	7d 87       	std	Y+13, r23	; 0x0d
	
	/* Set motor to default startup value */
	SetDegrees( 90 );
	tmr3Ptr_->setDutyCycleComA( percent_ );
     cca:	4f d3       	rcall	.+1694   	; 0x136a <_ZN6Timer516setDutyCycleComAEf>
	oldPercent_ = percent_;
     ccc:	8a 85       	ldd	r24, Y+10	; 0x0a
     cce:	9b 85       	ldd	r25, Y+11	; 0x0b
     cd0:	ac 85       	ldd	r26, Y+12	; 0x0c
     cd2:	bd 85       	ldd	r27, Y+13	; 0x0d
     cd4:	8e 87       	std	Y+14, r24	; 0x0e
     cd6:	9f 87       	std	Y+15, r25	; 0x0f
     cd8:	a8 8b       	std	Y+16, r26	; 0x10
     cda:	b9 8b       	std	Y+17, r27	; 0x11
}
     cdc:	df 91       	pop	r29
     cde:	cf 91       	pop	r28
     ce0:	08 95       	ret

00000ce2 <_ZN2M5D1Ev>:

class Motor
{
//functions
public:
	virtual ~Motor() {};
     ce2:	20 e7       	ldi	r18, 0x70	; 112
     ce4:	32 e0       	ldi	r19, 0x02	; 2
     ce6:	fc 01       	movw	r30, r24
     ce8:	31 83       	std	Z+1, r19	; 0x01
     cea:	20 83       	st	Z, r18
     cec:	08 95       	ret

00000cee <_ZN2M5D0Ev>:
	SetDegrees( 0 );
	tmr3Ptr_->setDutyCycleComB( percent_ );
	oldPercent_ = percent_;
}

M5::~M5()
     cee:	cf 93       	push	r28
     cf0:	df 93       	push	r29
     cf2:	ec 01       	movw	r28, r24
{
}
     cf4:	f6 df       	rcall	.-20     	; 0xce2 <_ZN2M5D1Ev>
     cf6:	ce 01       	movw	r24, r28
     cf8:	0c dd       	rcall	.-1512   	; 0x712 <_ZdlPv>
     cfa:	df 91       	pop	r29
     cfc:	cf 91       	pop	r28
     cfe:	08 95       	ret

00000d00 <_ZN2M59TurnMotorEv>:

void M5::TurnMotor()
{
     d00:	4f 92       	push	r4
     d02:	5f 92       	push	r5
     d04:	6f 92       	push	r6
     d06:	7f 92       	push	r7
     d08:	8f 92       	push	r8
     d0a:	9f 92       	push	r9
     d0c:	af 92       	push	r10
     d0e:	bf 92       	push	r11
     d10:	cf 92       	push	r12
     d12:	df 92       	push	r13
     d14:	ef 92       	push	r14
     d16:	ff 92       	push	r15
     d18:	cf 93       	push	r28
     d1a:	df 93       	push	r29
     d1c:	ec 01       	movw	r28, r24
	if ( percent_ > oldPercent_ + PERCENT_PR_TICK )
     d1e:	8a 84       	ldd	r8, Y+10	; 0x0a
     d20:	9b 84       	ldd	r9, Y+11	; 0x0b
     d22:	ac 84       	ldd	r10, Y+12	; 0x0c
     d24:	bd 84       	ldd	r11, Y+13	; 0x0d
     d26:	ce 84       	ldd	r12, Y+14	; 0x0e
     d28:	df 84       	ldd	r13, Y+15	; 0x0f
     d2a:	e8 88       	ldd	r14, Y+16	; 0x10
     d2c:	f9 88       	ldd	r15, Y+17	; 0x11
     d2e:	20 e0       	ldi	r18, 0x00	; 0
     d30:	30 e0       	ldi	r19, 0x00	; 0
     d32:	40 e8       	ldi	r20, 0x80	; 128
     d34:	5d e3       	ldi	r21, 0x3D	; 61
     d36:	c7 01       	movw	r24, r14
     d38:	b6 01       	movw	r22, r12
     d3a:	0e 94 dd 0f 	call	0x1fba	; 0x1fba <__addsf3>
     d3e:	2b 01       	movw	r4, r22
     d40:	3c 01       	movw	r6, r24
     d42:	9b 01       	movw	r18, r22
     d44:	ac 01       	movw	r20, r24
     d46:	c5 01       	movw	r24, r10
     d48:	b4 01       	movw	r22, r8
     d4a:	0e 94 23 11 	call	0x2246	; 0x2246 <__gesf2>
     d4e:	18 16       	cp	r1, r24
     d50:	74 f4       	brge	.+28     	; 0xd6e <_ZN2M59TurnMotorEv+0x6e>
	{
		oldPercent_ += PERCENT_PR_TICK;
     d52:	4e 86       	std	Y+14, r4	; 0x0e
     d54:	5f 86       	std	Y+15, r5	; 0x0f
     d56:	68 8a       	std	Y+16, r6	; 0x10
     d58:	79 8a       	std	Y+17, r7	; 0x11
		tmr3Ptr_->setDutyCycleComB( oldPercent_ );
     d5a:	b3 01       	movw	r22, r6
     d5c:	a2 01       	movw	r20, r4
     d5e:	8c 81       	ldd	r24, Y+4	; 0x04
     d60:	9d 81       	ldd	r25, Y+5	; 0x05
     d62:	2a d3       	rcall	.+1620   	; 0x13b8 <_ZN6Timer516setDutyCycleComBEf>
		vTaskDelay( delay_ / portTICK_RATE_MS );
     d64:	8f 89       	ldd	r24, Y+23	; 0x17
     d66:	98 8d       	ldd	r25, Y+24	; 0x18
     d68:	0e 94 ff 0e 	call	0x1dfe	; 0x1dfe <vTaskDelay>
     d6c:	1d c0       	rjmp	.+58     	; 0xda8 <_ZN2M59TurnMotorEv+0xa8>
	}
	else if ( percent_ < oldPercent_ )
     d6e:	a7 01       	movw	r20, r14
     d70:	96 01       	movw	r18, r12
     d72:	c5 01       	movw	r24, r10
     d74:	b4 01       	movw	r22, r8
     d76:	0e 94 41 10 	call	0x2082	; 0x2082 <__cmpsf2>
     d7a:	88 23       	and	r24, r24
     d7c:	ac f4       	brge	.+42     	; 0xda8 <_ZN2M59TurnMotorEv+0xa8>
	{
		oldPercent_ -= PERCENT_PR_TICK;
     d7e:	20 e0       	ldi	r18, 0x00	; 0
     d80:	30 e0       	ldi	r19, 0x00	; 0
     d82:	40 e8       	ldi	r20, 0x80	; 128
     d84:	5d e3       	ldi	r21, 0x3D	; 61
     d86:	c7 01       	movw	r24, r14
     d88:	b6 01       	movw	r22, r12
     d8a:	0e 94 dc 0f 	call	0x1fb8	; 0x1fb8 <__subsf3>
     d8e:	ab 01       	movw	r20, r22
     d90:	bc 01       	movw	r22, r24
     d92:	4e 87       	std	Y+14, r20	; 0x0e
     d94:	5f 87       	std	Y+15, r21	; 0x0f
     d96:	68 8b       	std	Y+16, r22	; 0x10
     d98:	79 8b       	std	Y+17, r23	; 0x11
		tmr3Ptr_->setDutyCycleComB( oldPercent_ );
     d9a:	8c 81       	ldd	r24, Y+4	; 0x04
     d9c:	9d 81       	ldd	r25, Y+5	; 0x05
     d9e:	0c d3       	rcall	.+1560   	; 0x13b8 <_ZN6Timer516setDutyCycleComBEf>
		vTaskDelay( delay_ / portTICK_RATE_MS );
     da0:	8f 89       	ldd	r24, Y+23	; 0x17
     da2:	98 8d       	ldd	r25, Y+24	; 0x18
     da4:	0e 94 ff 0e 	call	0x1dfe	; 0x1dfe <vTaskDelay>
	}
}
     da8:	df 91       	pop	r29
     daa:	cf 91       	pop	r28
     dac:	ff 90       	pop	r15
     dae:	ef 90       	pop	r14
     db0:	df 90       	pop	r13
     db2:	cf 90       	pop	r12
     db4:	bf 90       	pop	r11
     db6:	af 90       	pop	r10
     db8:	9f 90       	pop	r9
     dba:	8f 90       	pop	r8
     dbc:	7f 90       	pop	r7
     dbe:	6f 90       	pop	r6
     dc0:	5f 90       	pop	r5
     dc2:	4f 90       	pop	r4
     dc4:	08 95       	ret

00000dc6 <_ZN2M5C1EP6Timer5>:
* Author: jespe
*/

#include "M5.h"

M5::M5( Timer5* tmr )
     dc6:	cf 93       	push	r28
     dc8:	df 93       	push	r29
     dca:	ec 01       	movw	r28, r24
     dcc:	cb 01       	movw	r24, r22
     dce:	2c ea       	ldi	r18, 0xAC	; 172
     dd0:	32 e0       	ldi	r19, 0x02	; 2
     dd2:	39 83       	std	Y+1, r19	; 0x01
     dd4:	28 83       	st	Y, r18
{
	/* Store timer pointer */
	tmr3Ptr_ = tmr;
     dd6:	7d 83       	std	Y+5, r23	; 0x05
     dd8:	6c 83       	std	Y+4, r22	; 0x04
	
	/* This value is number of percent to add or subtract pr degree. */
	percentPrDeg = 0.0555555555555556;
     dda:	49 e3       	ldi	r20, 0x39	; 57
     ddc:	5e e8       	ldi	r21, 0x8E	; 142
     dde:	63 e6       	ldi	r22, 0x63	; 99
     de0:	7d e3       	ldi	r23, 0x3D	; 61
     de2:	4e 83       	std	Y+6, r20	; 0x06
     de4:	5f 83       	std	Y+7, r21	; 0x07
     de6:	68 87       	std	Y+8, r22	; 0x08
     de8:	79 87       	std	Y+9, r23	; 0x09
	
	/* This value is the lowest duty cycle percentage needed to make motor turn. */
	startpercent_ = 2.5;
     dea:	40 e0       	ldi	r20, 0x00	; 0
     dec:	50 e0       	ldi	r21, 0x00	; 0
     dee:	60 e2       	ldi	r22, 0x20	; 32
     df0:	70 e4       	ldi	r23, 0x40	; 64
     df2:	4a 8b       	std	Y+18, r20	; 0x12
     df4:	5b 8b       	std	Y+19, r21	; 0x13
     df6:	6c 8b       	std	Y+20, r22	; 0x14
     df8:	7d 8b       	std	Y+21, r23	; 0x15
	
	/* This value is the delay on motor. A lower value makes motors go faster and higher value makes motors go slower. Value is in MS */
	delay_ = 1;
     dfa:	21 e0       	ldi	r18, 0x01	; 1
     dfc:	30 e0       	ldi	r19, 0x00	; 0
     dfe:	38 8f       	std	Y+24, r19	; 0x18
     e00:	2f 8b       	std	Y+23, r18	; 0x17
	
	/* This value is the maximum number of degrees the motor can turn */
	maxDegrees_ = 180;
     e02:	24 eb       	ldi	r18, 0xB4	; 180
     e04:	2e 8b       	std	Y+22, r18	; 0x16
	*/
	virtual void SetDegrees( uint8_t degrees )
	{
		if ( maxDegrees_ >= degrees )
		{
			percent_ = percentPrDeg * degrees + startpercent_;
     e06:	4a 87       	std	Y+10, r20	; 0x0a
     e08:	5b 87       	std	Y+11, r21	; 0x0b
     e0a:	6c 87       	std	Y+12, r22	; 0x0c
     e0c:	7d 87       	std	Y+13, r23	; 0x0d
	
	/* Set motor to default startup value */
	SetDegrees( 0 );
	tmr3Ptr_->setDutyCycleComB( percent_ );
     e0e:	d4 d2       	rcall	.+1448   	; 0x13b8 <_ZN6Timer516setDutyCycleComBEf>
	oldPercent_ = percent_;
     e10:	8a 85       	ldd	r24, Y+10	; 0x0a
     e12:	9b 85       	ldd	r25, Y+11	; 0x0b
     e14:	ac 85       	ldd	r26, Y+12	; 0x0c
     e16:	bd 85       	ldd	r27, Y+13	; 0x0d
     e18:	8e 87       	std	Y+14, r24	; 0x0e
     e1a:	9f 87       	std	Y+15, r25	; 0x0f
     e1c:	a8 8b       	std	Y+16, r26	; 0x10
     e1e:	b9 8b       	std	Y+17, r27	; 0x11
}
     e20:	df 91       	pop	r29
     e22:	cf 91       	pop	r28
     e24:	08 95       	ret

00000e26 <_ZN2M6D1Ev>:

class Motor
{
//functions
public:
	virtual ~Motor() {};
     e26:	20 e7       	ldi	r18, 0x70	; 112
     e28:	32 e0       	ldi	r19, 0x02	; 2
     e2a:	fc 01       	movw	r30, r24
     e2c:	31 83       	std	Z+1, r19	; 0x01
     e2e:	20 83       	st	Z, r18
     e30:	08 95       	ret

00000e32 <_ZN2M6D0Ev>:
	SetDegrees( 0 );
	tmr3Ptr_->setDutyCycleComC( percent_ );
	oldPercent_ = percent_;
}

M6::~M6()
     e32:	cf 93       	push	r28
     e34:	df 93       	push	r29
     e36:	ec 01       	movw	r28, r24
{
}
     e38:	f6 df       	rcall	.-20     	; 0xe26 <_ZN2M6D1Ev>
     e3a:	ce 01       	movw	r24, r28
     e3c:	6a dc       	rcall	.-1836   	; 0x712 <_ZdlPv>
     e3e:	df 91       	pop	r29
     e40:	cf 91       	pop	r28
     e42:	08 95       	ret

00000e44 <_ZN2M69TurnMotorEv>:

void M6::TurnMotor()
{
     e44:	4f 92       	push	r4
     e46:	5f 92       	push	r5
     e48:	6f 92       	push	r6
     e4a:	7f 92       	push	r7
     e4c:	8f 92       	push	r8
     e4e:	9f 92       	push	r9
     e50:	af 92       	push	r10
     e52:	bf 92       	push	r11
     e54:	cf 92       	push	r12
     e56:	df 92       	push	r13
     e58:	ef 92       	push	r14
     e5a:	ff 92       	push	r15
     e5c:	cf 93       	push	r28
     e5e:	df 93       	push	r29
     e60:	ec 01       	movw	r28, r24
	if ( percent_ > oldPercent_ + PERCENT_PR_TICK )
     e62:	8a 84       	ldd	r8, Y+10	; 0x0a
     e64:	9b 84       	ldd	r9, Y+11	; 0x0b
     e66:	ac 84       	ldd	r10, Y+12	; 0x0c
     e68:	bd 84       	ldd	r11, Y+13	; 0x0d
     e6a:	ce 84       	ldd	r12, Y+14	; 0x0e
     e6c:	df 84       	ldd	r13, Y+15	; 0x0f
     e6e:	e8 88       	ldd	r14, Y+16	; 0x10
     e70:	f9 88       	ldd	r15, Y+17	; 0x11
     e72:	20 e0       	ldi	r18, 0x00	; 0
     e74:	30 e0       	ldi	r19, 0x00	; 0
     e76:	40 e8       	ldi	r20, 0x80	; 128
     e78:	5d e3       	ldi	r21, 0x3D	; 61
     e7a:	c7 01       	movw	r24, r14
     e7c:	b6 01       	movw	r22, r12
     e7e:	0e 94 dd 0f 	call	0x1fba	; 0x1fba <__addsf3>
     e82:	2b 01       	movw	r4, r22
     e84:	3c 01       	movw	r6, r24
     e86:	9b 01       	movw	r18, r22
     e88:	ac 01       	movw	r20, r24
     e8a:	c5 01       	movw	r24, r10
     e8c:	b4 01       	movw	r22, r8
     e8e:	0e 94 23 11 	call	0x2246	; 0x2246 <__gesf2>
     e92:	18 16       	cp	r1, r24
     e94:	6c f4       	brge	.+26     	; 0xeb0 <_ZN2M69TurnMotorEv+0x6c>
	{
		oldPercent_ += 0.0625;
     e96:	4e 86       	std	Y+14, r4	; 0x0e
     e98:	5f 86       	std	Y+15, r5	; 0x0f
     e9a:	68 8a       	std	Y+16, r6	; 0x10
     e9c:	79 8a       	std	Y+17, r7	; 0x11
		tmr3Ptr_->setDutyCycleComC( oldPercent_ );
     e9e:	b3 01       	movw	r22, r6
     ea0:	a2 01       	movw	r20, r4
     ea2:	8c 81       	ldd	r24, Y+4	; 0x04
     ea4:	9d 81       	ldd	r25, Y+5	; 0x05
     ea6:	af d2       	rcall	.+1374   	; 0x1406 <_ZN6Timer516setDutyCycleComCEf>
		vTaskDelay( delay_ / portTICK_RATE_MS );
     ea8:	8f 89       	ldd	r24, Y+23	; 0x17
     eaa:	98 8d       	ldd	r25, Y+24	; 0x18
     eac:	a8 d7       	rcall	.+3920   	; 0x1dfe <vTaskDelay>
     eae:	1c c0       	rjmp	.+56     	; 0xee8 <_ZN2M69TurnMotorEv+0xa4>
	}
	else if ( percent_ < oldPercent_ )
     eb0:	a7 01       	movw	r20, r14
     eb2:	96 01       	movw	r18, r12
     eb4:	c5 01       	movw	r24, r10
     eb6:	b4 01       	movw	r22, r8
     eb8:	0e 94 41 10 	call	0x2082	; 0x2082 <__cmpsf2>
     ebc:	88 23       	and	r24, r24
     ebe:	a4 f4       	brge	.+40     	; 0xee8 <_ZN2M69TurnMotorEv+0xa4>
	{
		oldPercent_ -= 0.0625;
     ec0:	20 e0       	ldi	r18, 0x00	; 0
     ec2:	30 e0       	ldi	r19, 0x00	; 0
     ec4:	40 e8       	ldi	r20, 0x80	; 128
     ec6:	5d e3       	ldi	r21, 0x3D	; 61
     ec8:	c7 01       	movw	r24, r14
     eca:	b6 01       	movw	r22, r12
     ecc:	0e 94 dc 0f 	call	0x1fb8	; 0x1fb8 <__subsf3>
     ed0:	ab 01       	movw	r20, r22
     ed2:	bc 01       	movw	r22, r24
     ed4:	4e 87       	std	Y+14, r20	; 0x0e
     ed6:	5f 87       	std	Y+15, r21	; 0x0f
     ed8:	68 8b       	std	Y+16, r22	; 0x10
     eda:	79 8b       	std	Y+17, r23	; 0x11
		tmr3Ptr_->setDutyCycleComC( oldPercent_ );
     edc:	8c 81       	ldd	r24, Y+4	; 0x04
     ede:	9d 81       	ldd	r25, Y+5	; 0x05
     ee0:	92 d2       	rcall	.+1316   	; 0x1406 <_ZN6Timer516setDutyCycleComCEf>
		vTaskDelay( delay_ / portTICK_RATE_MS );
     ee2:	8f 89       	ldd	r24, Y+23	; 0x17
     ee4:	98 8d       	ldd	r25, Y+24	; 0x18
     ee6:	8b d7       	rcall	.+3862   	; 0x1dfe <vTaskDelay>
     ee8:	df 91       	pop	r29
	}
}
     eea:	cf 91       	pop	r28
     eec:	ff 90       	pop	r15
     eee:	ef 90       	pop	r14
     ef0:	df 90       	pop	r13
     ef2:	cf 90       	pop	r12
     ef4:	bf 90       	pop	r11
     ef6:	af 90       	pop	r10
     ef8:	9f 90       	pop	r9
     efa:	8f 90       	pop	r8
     efc:	7f 90       	pop	r7
     efe:	6f 90       	pop	r6
     f00:	5f 90       	pop	r5
     f02:	4f 90       	pop	r4
     f04:	08 95       	ret

00000f06 <_ZN2M6C1EP6Timer5>:
     f06:	cf 93       	push	r28
* Author: jespe
*/

#include "M6.h"

M6::M6( Timer5* tmr )
     f08:	df 93       	push	r29
     f0a:	ec 01       	movw	r28, r24
     f0c:	cb 01       	movw	r24, r22
     f0e:	28 eb       	ldi	r18, 0xB8	; 184
     f10:	32 e0       	ldi	r19, 0x02	; 2
     f12:	39 83       	std	Y+1, r19	; 0x01
     f14:	28 83       	st	Y, r18
{
	/* Store timer pointer */
	tmr3Ptr_ = tmr;
     f16:	7d 83       	std	Y+5, r23	; 0x05
     f18:	6c 83       	std	Y+4, r22	; 0x04
	
	/* This value is number of percent to add or subtract pr degree. */
	percentPrDeg = 0.07936507936507;
     f1a:	49 e2       	ldi	r20, 0x29	; 41
     f1c:	5a e8       	ldi	r21, 0x8A	; 138
     f1e:	62 ea       	ldi	r22, 0xA2	; 162
     f20:	7d e3       	ldi	r23, 0x3D	; 61
     f22:	4e 83       	std	Y+6, r20	; 0x06
     f24:	5f 83       	std	Y+7, r21	; 0x07
     f26:	68 87       	std	Y+8, r22	; 0x08
     f28:	79 87       	std	Y+9, r23	; 0x09
	
	/* This value is the lowest duty cycle percentage needed to make motor turn. */
	startpercent_ = 2.5;
     f2a:	40 e0       	ldi	r20, 0x00	; 0
     f2c:	50 e0       	ldi	r21, 0x00	; 0
     f2e:	60 e2       	ldi	r22, 0x20	; 32
     f30:	70 e4       	ldi	r23, 0x40	; 64
     f32:	4a 8b       	std	Y+18, r20	; 0x12
     f34:	5b 8b       	std	Y+19, r21	; 0x13
     f36:	6c 8b       	std	Y+20, r22	; 0x14
     f38:	7d 8b       	std	Y+21, r23	; 0x15
	
	/* This value is the delay on motor. A lower value makes motors go faster and higher value makes motors go slower. Value is in MS */
	delay_ = 1;
     f3a:	21 e0       	ldi	r18, 0x01	; 1
     f3c:	30 e0       	ldi	r19, 0x00	; 0
     f3e:	38 8f       	std	Y+24, r19	; 0x18
     f40:	2f 8b       	std	Y+23, r18	; 0x17
	
	/* This value is the maximum number of degrees the motor can turn */
	maxDegrees_ = 63;
     f42:	2f e3       	ldi	r18, 0x3F	; 63
     f44:	2e 8b       	std	Y+22, r18	; 0x16
	*/
	virtual void SetDegrees( uint8_t degrees )
	{
		if ( maxDegrees_ >= degrees )
		{
			percent_ = percentPrDeg * degrees + startpercent_;
     f46:	4a 87       	std	Y+10, r20	; 0x0a
     f48:	5b 87       	std	Y+11, r21	; 0x0b
     f4a:	6c 87       	std	Y+12, r22	; 0x0c
     f4c:	7d 87       	std	Y+13, r23	; 0x0d
	
	/* Set motor to default startup value */
	SetDegrees( 0 );
	tmr3Ptr_->setDutyCycleComC( percent_ );
     f4e:	5b d2       	rcall	.+1206   	; 0x1406 <_ZN6Timer516setDutyCycleComCEf>
	oldPercent_ = percent_;
     f50:	8a 85       	ldd	r24, Y+10	; 0x0a
     f52:	9b 85       	ldd	r25, Y+11	; 0x0b
     f54:	ac 85       	ldd	r26, Y+12	; 0x0c
     f56:	bd 85       	ldd	r27, Y+13	; 0x0d
     f58:	8e 87       	std	Y+14, r24	; 0x0e
     f5a:	9f 87       	std	Y+15, r25	; 0x0f
     f5c:	a8 8b       	std	Y+16, r26	; 0x10
     f5e:	b9 8b       	std	Y+17, r27	; 0x11
}
     f60:	df 91       	pop	r29
     f62:	cf 91       	pop	r28
     f64:	08 95       	ret

00000f66 <_ZN8Robotarm14startMotorImplEPv>:
	motors_[3]->SetDegrees(90);
	vTaskDelay( 250 / portTICK_RATE_MS );
}

void Robotarm::startMotorImpl( void *_this )
{
     f66:	8c 01       	movw	r16, r24
void Robotarm::MotorSpeedController()
{
	while(1)
	{
		/* Move all motors one step. */
		for ( uint8_t i = 0U; i < 6U; i++ )
     f68:	c0 e0       	ldi	r28, 0x00	; 0
     f6a:	c6 30       	cpi	r28, 0x06	; 6
     f6c:	e8 f7       	brcc	.-6      	; 0xf68 <_ZN8Robotarm14startMotorImplEPv+0x2>
		{
			motors_[i]->TurnMotor();
     f6e:	ec 2f       	mov	r30, r28
     f70:	f0 e0       	ldi	r31, 0x00	; 0
     f72:	31 96       	adiw	r30, 0x01	; 1
     f74:	ee 0f       	add	r30, r30
     f76:	ff 1f       	adc	r31, r31
     f78:	e0 0f       	add	r30, r16
     f7a:	f1 1f       	adc	r31, r17
     f7c:	80 81       	ld	r24, Z
     f7e:	91 81       	ldd	r25, Z+1	; 0x01
     f80:	dc 01       	movw	r26, r24
     f82:	ed 91       	ld	r30, X+
     f84:	fc 91       	ld	r31, X
     f86:	04 80       	ldd	r0, Z+4	; 0x04
     f88:	f5 81       	ldd	r31, Z+5	; 0x05
     f8a:	e0 2d       	mov	r30, r0
     f8c:	19 95       	eicall
void Robotarm::MotorSpeedController()
{
	while(1)
	{
		/* Move all motors one step. */
		for ( uint8_t i = 0U; i < 6U; i++ )
     f8e:	cf 5f       	subi	r28, 0xFF	; 255
     f90:	ec cf       	rjmp	.-40     	; 0xf6a <_ZN8Robotarm14startMotorImplEPv+0x4>

00000f92 <_ZN8RobotarmC1Ev>:
/* RTOS include */
#include "FreeRTOS.h"
#include "task.h"
#include "portmacro.h"

Robotarm::Robotarm() : tmr1_(), tmr3_()
     f92:	af 92       	push	r10
     f94:	bf 92       	push	r11
     f96:	cf 92       	push	r12
     f98:	df 92       	push	r13
     f9a:	ef 92       	push	r14
     f9c:	ff 92       	push	r15
     f9e:	0f 93       	push	r16
     fa0:	1f 93       	push	r17
     fa2:	cf 93       	push	r28
     fa4:	df 93       	push	r29
     fa6:	ec 01       	movw	r28, r24
     fa8:	2a d1       	rcall	.+596    	; 0x11fe <_ZN6Timer1C1Ev>
     faa:	8e 01       	movw	r16, r28
     fac:	0f 5f       	subi	r16, 0xFF	; 255
     fae:	1f 4f       	sbci	r17, 0xFF	; 255
     fb0:	c8 01       	movw	r24, r16
     fb2:	bb d1       	rcall	.+886    	; 0x132a <_ZN6Timer5C1Ev>
{
	/* Create all motor objects */
	motors_[0] = new M1( &tmr1_ );
     fb4:	89 e1       	ldi	r24, 0x19	; 25
     fb6:	90 e0       	ldi	r25, 0x00	; 0
     fb8:	a9 db       	rcall	.-2222   	; 0x70c <_Znwj>
     fba:	7c 01       	movw	r14, r24
     fbc:	be 01       	movw	r22, r28
     fbe:	6b dc       	rcall	.-1834   	; 0x896 <_ZN2M1C1EP6Timer1>
     fc0:	fb 82       	std	Y+3, r15	; 0x03
     fc2:	ea 82       	std	Y+2, r14	; 0x02
	motors_[1] = new M2( &tmr1_ );
     fc4:	89 e1       	ldi	r24, 0x19	; 25
     fc6:	90 e0       	ldi	r25, 0x00	; 0
     fc8:	a1 db       	rcall	.-2238   	; 0x70c <_Znwj>
     fca:	7c 01       	movw	r14, r24
     fcc:	be 01       	movw	r22, r28
     fce:	09 dd       	rcall	.-1518   	; 0x9e2 <_ZN2M2C1EP6Timer1>
     fd0:	fd 82       	std	Y+5, r15	; 0x05
     fd2:	ec 82       	std	Y+4, r14	; 0x04
	motors_[2] = new M3( &tmr1_ );
     fd4:	89 e1       	ldi	r24, 0x19	; 25
     fd6:	90 e0       	ldi	r25, 0x00	; 0
     fd8:	99 db       	rcall	.-2254   	; 0x70c <_Znwj>
     fda:	7c 01       	movw	r14, r24
     fdc:	be 01       	movw	r22, r28
     fde:	a7 dd       	rcall	.-1202   	; 0xb2e <_ZN2M3C1EP6Timer1>
     fe0:	ff 82       	std	Y+7, r15	; 0x07
     fe2:	ee 82       	std	Y+6, r14	; 0x06
	motors_[3] = new M4( &tmr3_ );
     fe4:	89 e1       	ldi	r24, 0x19	; 25
     fe6:	90 e0       	ldi	r25, 0x00	; 0
     fe8:	91 db       	rcall	.-2270   	; 0x70c <_Znwj>
     fea:	7c 01       	movw	r14, r24
     fec:	b8 01       	movw	r22, r16
     fee:	45 de       	rcall	.-886    	; 0xc7a <_ZN2M4C1EP6Timer5>
     ff0:	f9 86       	std	Y+9, r15	; 0x09
     ff2:	e8 86       	std	Y+8, r14	; 0x08
	motors_[4] = new M5( &tmr3_ );
     ff4:	89 e1       	ldi	r24, 0x19	; 25
     ff6:	90 e0       	ldi	r25, 0x00	; 0
     ff8:	89 db       	rcall	.-2286   	; 0x70c <_Znwj>
     ffa:	7c 01       	movw	r14, r24
     ffc:	b8 01       	movw	r22, r16
     ffe:	e3 de       	rcall	.-570    	; 0xdc6 <_ZN2M5C1EP6Timer5>
    1000:	fb 86       	std	Y+11, r15	; 0x0b
    1002:	ea 86       	std	Y+10, r14	; 0x0a
	motors_[5] = new M6( &tmr3_ );
    1004:	89 e1       	ldi	r24, 0x19	; 25
    1006:	90 e0       	ldi	r25, 0x00	; 0
    1008:	81 db       	rcall	.-2302   	; 0x70c <_Znwj>
    100a:	7c 01       	movw	r14, r24
    100c:	b8 01       	movw	r22, r16
    100e:	7b df       	rcall	.-266    	; 0xf06 <_ZN2M6C1EP6Timer5>
    1010:	fd 86       	std	Y+13, r15	; 0x0d
    1012:	ec 86       	std	Y+12, r14	; 0x0c
    1014:	a1 2c       	mov	r10, r1
    1016:	b1 2c       	mov	r11, r1
	
	/* Create task to control motors */
	xTaskCreate(this->startMotorImpl,  ( signed char * ) "Motors", configMAIN_STACK_SIZE, this, tskIDLE_PRIORITY, NULL);
    1018:	c1 2c       	mov	r12, r1
    101a:	d1 2c       	mov	r13, r1
    101c:	e1 2c       	mov	r14, r1
    101e:	f1 2c       	mov	r15, r1
    1020:	00 e0       	ldi	r16, 0x00	; 0
    1022:	9e 01       	movw	r18, r28
    1024:	48 ec       	ldi	r20, 0xC8	; 200
    1026:	50 e0       	ldi	r21, 0x00	; 0
    1028:	60 ec       	ldi	r22, 0xC0	; 192
    102a:	72 e0       	ldi	r23, 0x02	; 2
    102c:	83 eb       	ldi	r24, 0xB3	; 179
    102e:	97 e0       	ldi	r25, 0x07	; 7
    1030:	e7 d4       	rcall	.+2510   	; 0x1a00 <xTaskGenericCreate>
    1032:	df 91       	pop	r29
    1034:	cf 91       	pop	r28
}
    1036:	1f 91       	pop	r17
    1038:	0f 91       	pop	r16
    103a:	ff 90       	pop	r15
    103c:	ef 90       	pop	r14
    103e:	df 90       	pop	r13
    1040:	cf 90       	pop	r12
    1042:	bf 90       	pop	r11
    1044:	af 90       	pop	r10
    1046:	08 95       	ret

00001048 <_ZN8Robotarm9grabBlockEv>:
    1048:	cf 93       	push	r28
    104a:	df 93       	push	r29

void Robotarm::grabBlock()
{
    104c:	ec 01       	movw	r28, r24
	motors_[3]->SetDegrees(40);
    104e:	88 85       	ldd	r24, Y+8	; 0x08
    1050:	99 85       	ldd	r25, Y+9	; 0x09
    1052:	dc 01       	movw	r26, r24
    1054:	ed 91       	ld	r30, X+
    1056:	fc 91       	ld	r31, X
    1058:	06 80       	ldd	r0, Z+6	; 0x06
    105a:	f7 81       	ldd	r31, Z+7	; 0x07
    105c:	e0 2d       	mov	r30, r0
    105e:	68 e2       	ldi	r22, 0x28	; 40
    1060:	19 95       	eicall
	motors_[4]->SetDegrees(90);
    1062:	8a 85       	ldd	r24, Y+10	; 0x0a
    1064:	9b 85       	ldd	r25, Y+11	; 0x0b
    1066:	dc 01       	movw	r26, r24
    1068:	ed 91       	ld	r30, X+
    106a:	fc 91       	ld	r31, X
    106c:	06 80       	ldd	r0, Z+6	; 0x06
    106e:	f7 81       	ldd	r31, Z+7	; 0x07
    1070:	e0 2d       	mov	r30, r0
    1072:	6a e5       	ldi	r22, 0x5A	; 90
    1074:	19 95       	eicall
	motors_[0]->SetDegrees(0);
    1076:	8a 81       	ldd	r24, Y+2	; 0x02
    1078:	9b 81       	ldd	r25, Y+3	; 0x03
    107a:	dc 01       	movw	r26, r24
    107c:	ed 91       	ld	r30, X+
    107e:	fc 91       	ld	r31, X
    1080:	06 80       	ldd	r0, Z+6	; 0x06
    1082:	f7 81       	ldd	r31, Z+7	; 0x07
    1084:	e0 2d       	mov	r30, r0
    1086:	60 e0       	ldi	r22, 0x00	; 0
    1088:	19 95       	eicall
	vTaskDelay( 1500 / portTICK_RATE_MS );
    108a:	8c ed       	ldi	r24, 0xDC	; 220
    108c:	95 e0       	ldi	r25, 0x05	; 5
    108e:	b7 d6       	rcall	.+3438   	; 0x1dfe <vTaskDelay>
	motors_[1]->SetDegrees(35);
    1090:	8c 81       	ldd	r24, Y+4	; 0x04
    1092:	9d 81       	ldd	r25, Y+5	; 0x05
    1094:	dc 01       	movw	r26, r24
    1096:	ed 91       	ld	r30, X+
    1098:	fc 91       	ld	r31, X
    109a:	06 80       	ldd	r0, Z+6	; 0x06
    109c:	f7 81       	ldd	r31, Z+7	; 0x07
    109e:	e0 2d       	mov	r30, r0
    10a0:	63 e2       	ldi	r22, 0x23	; 35
    10a2:	19 95       	eicall
	motors_[2]->SetDegrees(63);
    10a4:	8e 81       	ldd	r24, Y+6	; 0x06
    10a6:	9f 81       	ldd	r25, Y+7	; 0x07
    10a8:	dc 01       	movw	r26, r24
    10aa:	ed 91       	ld	r30, X+
    10ac:	fc 91       	ld	r31, X
    10ae:	06 80       	ldd	r0, Z+6	; 0x06
    10b0:	f7 81       	ldd	r31, Z+7	; 0x07
    10b2:	e0 2d       	mov	r30, r0
    10b4:	6f e3       	ldi	r22, 0x3F	; 63
    10b6:	19 95       	eicall
	vTaskDelay( 1500 / portTICK_RATE_MS );
    10b8:	8c ed       	ldi	r24, 0xDC	; 220
    10ba:	95 e0       	ldi	r25, 0x05	; 5
    10bc:	a0 d6       	rcall	.+3392   	; 0x1dfe <vTaskDelay>
	motors_[5]->SetDegrees(63);
    10be:	8c 85       	ldd	r24, Y+12	; 0x0c
    10c0:	9d 85       	ldd	r25, Y+13	; 0x0d
    10c2:	dc 01       	movw	r26, r24
    10c4:	ed 91       	ld	r30, X+
    10c6:	fc 91       	ld	r31, X
    10c8:	06 80       	ldd	r0, Z+6	; 0x06
    10ca:	f7 81       	ldd	r31, Z+7	; 0x07
    10cc:	e0 2d       	mov	r30, r0
    10ce:	6f e3       	ldi	r22, 0x3F	; 63
    10d0:	19 95       	eicall
	vTaskDelay( 250 / portTICK_RATE_MS );
    10d2:	8a ef       	ldi	r24, 0xFA	; 250
    10d4:	90 e0       	ldi	r25, 0x00	; 0
    10d6:	93 d6       	rcall	.+3366   	; 0x1dfe <vTaskDelay>
	motors_[1]->SetDegrees(70);
    10d8:	8c 81       	ldd	r24, Y+4	; 0x04
    10da:	9d 81       	ldd	r25, Y+5	; 0x05
    10dc:	dc 01       	movw	r26, r24
    10de:	ed 91       	ld	r30, X+
    10e0:	fc 91       	ld	r31, X
    10e2:	06 80       	ldd	r0, Z+6	; 0x06
    10e4:	f7 81       	ldd	r31, Z+7	; 0x07
    10e6:	e0 2d       	mov	r30, r0
    10e8:	66 e4       	ldi	r22, 0x46	; 70
    10ea:	19 95       	eicall
	motors_[2]->SetDegrees(70);
    10ec:	8e 81       	ldd	r24, Y+6	; 0x06
    10ee:	9f 81       	ldd	r25, Y+7	; 0x07
    10f0:	dc 01       	movw	r26, r24
    10f2:	ed 91       	ld	r30, X+
    10f4:	fc 91       	ld	r31, X
    10f6:	06 80       	ldd	r0, Z+6	; 0x06
    10f8:	f7 81       	ldd	r31, Z+7	; 0x07
    10fa:	e0 2d       	mov	r30, r0
    10fc:	66 e4       	ldi	r22, 0x46	; 70
    10fe:	19 95       	eicall
	motors_[3]->SetDegrees(70);
    1100:	88 85       	ldd	r24, Y+8	; 0x08
    1102:	99 85       	ldd	r25, Y+9	; 0x09
    1104:	dc 01       	movw	r26, r24
    1106:	ed 91       	ld	r30, X+
    1108:	fc 91       	ld	r31, X
    110a:	06 80       	ldd	r0, Z+6	; 0x06
    110c:	f7 81       	ldd	r31, Z+7	; 0x07
    110e:	e0 2d       	mov	r30, r0
    1110:	66 e4       	ldi	r22, 0x46	; 70
    1112:	19 95       	eicall
}
    1114:	df 91       	pop	r29
    1116:	cf 91       	pop	r28
    1118:	08 95       	ret

0000111a <_ZN8Robotarm18ArmDownReleaseItemEv>:
	motors_[0]->SetDegrees(180);
	ArmDownReleaseItem();
}

void Robotarm::ArmDownReleaseItem()
{
    111a:	cf 93       	push	r28
    111c:	df 93       	push	r29
    111e:	ec 01       	movw	r28, r24
	vTaskDelay( 1500 / portTICK_RATE_MS );
    1120:	8c ed       	ldi	r24, 0xDC	; 220
    1122:	95 e0       	ldi	r25, 0x05	; 5
    1124:	6c d6       	rcall	.+3288   	; 0x1dfe <vTaskDelay>
	motors_[1]->SetDegrees(35);
    1126:	8c 81       	ldd	r24, Y+4	; 0x04
    1128:	9d 81       	ldd	r25, Y+5	; 0x05
    112a:	dc 01       	movw	r26, r24
    112c:	ed 91       	ld	r30, X+
    112e:	fc 91       	ld	r31, X
    1130:	06 80       	ldd	r0, Z+6	; 0x06
    1132:	f7 81       	ldd	r31, Z+7	; 0x07
    1134:	e0 2d       	mov	r30, r0
    1136:	63 e2       	ldi	r22, 0x23	; 35
    1138:	19 95       	eicall
	motors_[2]->SetDegrees(40);
    113a:	8e 81       	ldd	r24, Y+6	; 0x06
    113c:	9f 81       	ldd	r25, Y+7	; 0x07
    113e:	dc 01       	movw	r26, r24
    1140:	ed 91       	ld	r30, X+
    1142:	fc 91       	ld	r31, X
    1144:	06 80       	ldd	r0, Z+6	; 0x06
    1146:	f7 81       	ldd	r31, Z+7	; 0x07
    1148:	e0 2d       	mov	r30, r0
    114a:	68 e2       	ldi	r22, 0x28	; 40
    114c:	19 95       	eicall
	vTaskDelay( 1500 / portTICK_RATE_MS );
    114e:	8c ed       	ldi	r24, 0xDC	; 220
    1150:	95 e0       	ldi	r25, 0x05	; 5
    1152:	55 d6       	rcall	.+3242   	; 0x1dfe <vTaskDelay>
	motors_[5]->SetDegrees(0);
    1154:	8c 85       	ldd	r24, Y+12	; 0x0c
    1156:	9d 85       	ldd	r25, Y+13	; 0x0d
    1158:	dc 01       	movw	r26, r24
    115a:	ed 91       	ld	r30, X+
    115c:	fc 91       	ld	r31, X
    115e:	06 80       	ldd	r0, Z+6	; 0x06
    1160:	f7 81       	ldd	r31, Z+7	; 0x07
    1162:	e0 2d       	mov	r30, r0
    1164:	60 e0       	ldi	r22, 0x00	; 0
    1166:	19 95       	eicall
	vTaskDelay( 250 / portTICK_RATE_MS );
    1168:	8a ef       	ldi	r24, 0xFA	; 250
    116a:	90 e0       	ldi	r25, 0x00	; 0
    116c:	48 d6       	rcall	.+3216   	; 0x1dfe <vTaskDelay>
	motors_[1]->SetDegrees(90);
    116e:	8c 81       	ldd	r24, Y+4	; 0x04
    1170:	9d 81       	ldd	r25, Y+5	; 0x05
    1172:	dc 01       	movw	r26, r24
    1174:	ed 91       	ld	r30, X+
    1176:	fc 91       	ld	r31, X
    1178:	06 80       	ldd	r0, Z+6	; 0x06
    117a:	f7 81       	ldd	r31, Z+7	; 0x07
    117c:	e0 2d       	mov	r30, r0
    117e:	6a e5       	ldi	r22, 0x5A	; 90
    1180:	19 95       	eicall
	motors_[2]->SetDegrees(90);
    1182:	8e 81       	ldd	r24, Y+6	; 0x06
    1184:	9f 81       	ldd	r25, Y+7	; 0x07
    1186:	dc 01       	movw	r26, r24
    1188:	ed 91       	ld	r30, X+
    118a:	fc 91       	ld	r31, X
    118c:	06 80       	ldd	r0, Z+6	; 0x06
    118e:	f7 81       	ldd	r31, Z+7	; 0x07
    1190:	e0 2d       	mov	r30, r0
    1192:	6a e5       	ldi	r22, 0x5A	; 90
    1194:	19 95       	eicall
	motors_[3]->SetDegrees(90);
    1196:	88 85       	ldd	r24, Y+8	; 0x08
    1198:	99 85       	ldd	r25, Y+9	; 0x09
    119a:	dc 01       	movw	r26, r24
    119c:	ed 91       	ld	r30, X+
    119e:	fc 91       	ld	r31, X
    11a0:	06 80       	ldd	r0, Z+6	; 0x06
    11a2:	f7 81       	ldd	r31, Z+7	; 0x07
    11a4:	e0 2d       	mov	r30, r0
    11a6:	6a e5       	ldi	r22, 0x5A	; 90
	vTaskDelay( 250 / portTICK_RATE_MS );
    11a8:	19 95       	eicall
    11aa:	8a ef       	ldi	r24, 0xFA	; 250
    11ac:	90 e0       	ldi	r25, 0x00	; 0
    11ae:	27 d6       	rcall	.+3150   	; 0x1dfe <vTaskDelay>
}
    11b0:	df 91       	pop	r29
    11b2:	cf 91       	pop	r28
    11b4:	08 95       	ret

000011b6 <_ZN8Robotarm18moveBlockToZoneOneEv>:
	motors_[2]->SetDegrees(70);
	motors_[3]->SetDegrees(70);
}

void Robotarm::moveBlockToZoneOne()
{
    11b6:	cf 93       	push	r28
    11b8:	df 93       	push	r29
    11ba:	ec 01       	movw	r28, r24
	motors_[0]->SetDegrees(90);
    11bc:	8a 81       	ldd	r24, Y+2	; 0x02
    11be:	9b 81       	ldd	r25, Y+3	; 0x03
    11c0:	dc 01       	movw	r26, r24
    11c2:	ed 91       	ld	r30, X+
    11c4:	fc 91       	ld	r31, X
    11c6:	06 80       	ldd	r0, Z+6	; 0x06
    11c8:	f7 81       	ldd	r31, Z+7	; 0x07
    11ca:	e0 2d       	mov	r30, r0
    11cc:	6a e5       	ldi	r22, 0x5A	; 90
    11ce:	19 95       	eicall
	ArmDownReleaseItem();
    11d0:	ce 01       	movw	r24, r28
    11d2:	a3 df       	rcall	.-186    	; 0x111a <_ZN8Robotarm18ArmDownReleaseItemEv>
}
    11d4:	df 91       	pop	r29
    11d6:	cf 91       	pop	r28
    11d8:	08 95       	ret

000011da <_ZN8Robotarm18moveBlockToZoneTwoEv>:

void Robotarm::moveBlockToZoneTwo()
{
    11da:	cf 93       	push	r28
    11dc:	df 93       	push	r29
    11de:	ec 01       	movw	r28, r24
	motors_[0]->SetDegrees(135);
    11e0:	8a 81       	ldd	r24, Y+2	; 0x02
    11e2:	9b 81       	ldd	r25, Y+3	; 0x03
    11e4:	dc 01       	movw	r26, r24
    11e6:	ed 91       	ld	r30, X+
    11e8:	fc 91       	ld	r31, X
    11ea:	06 80       	ldd	r0, Z+6	; 0x06
    11ec:	f7 81       	ldd	r31, Z+7	; 0x07
    11ee:	e0 2d       	mov	r30, r0
    11f0:	67 e8       	ldi	r22, 0x87	; 135
    11f2:	19 95       	eicall
	ArmDownReleaseItem();
    11f4:	ce 01       	movw	r24, r28
    11f6:	91 df       	rcall	.-222    	; 0x111a <_ZN8Robotarm18ArmDownReleaseItemEv>
}
    11f8:	df 91       	pop	r29
    11fa:	cf 91       	pop	r28
    11fc:	08 95       	ret

000011fe <_ZN6Timer1C1Ev>:
#include <avr/io.h>

Timer1::Timer1()
{
	// Set B5 to output
	DDRB = DDRB | ( 1 << 5 ) | ( 1 << 6 ) | ( 1 << 7 );
    11fe:	84 b1       	in	r24, 0x04	; 4
    1200:	80 6e       	ori	r24, 0xE0	; 224
    1202:	84 b9       	out	0x04, r24	; 4
	
	// Set timer to run in PWM, Phase Correct mode with 50 Hz freq. 
	TCCR1A = ( 1 << COM1A1 ) | ( 1 << COM1B1 ) | ( 1 << COM1C1 ) | ( 0 << WGM10 ) | ( 0 << WGM11 );
    1204:	88 ea       	ldi	r24, 0xA8	; 168
    1206:	80 93 80 00 	sts	0x0080, r24	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
	TCCR1B = ( 1 << WGM13 ) | ( 0 << CS10 )  | ( 1 << CS12 );
    120a:	84 e1       	ldi	r24, 0x14	; 20
    120c:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x700081>
	TCCR1C = 0;
    1210:	10 92 82 00 	sts	0x0082, r1	; 0x800082 <__TEXT_REGION_LENGTH__+0x700082>
	ICR1 = 622;
    1214:	8e e6       	ldi	r24, 0x6E	; 110
    1216:	92 e0       	ldi	r25, 0x02	; 2
    1218:	90 93 87 00 	sts	0x0087, r25	; 0x800087 <__TEXT_REGION_LENGTH__+0x700087>
    121c:	80 93 86 00 	sts	0x0086, r24	; 0x800086 <__TEXT_REGION_LENGTH__+0x700086>
	
	OCR1A = 0;
    1220:	10 92 89 00 	sts	0x0089, r1	; 0x800089 <__TEXT_REGION_LENGTH__+0x700089>
    1224:	10 92 88 00 	sts	0x0088, r1	; 0x800088 <__TEXT_REGION_LENGTH__+0x700088>
	OCR1B = 0;
    1228:	10 92 8b 00 	sts	0x008B, r1	; 0x80008b <__TEXT_REGION_LENGTH__+0x70008b>
    122c:	10 92 8a 00 	sts	0x008A, r1	; 0x80008a <__TEXT_REGION_LENGTH__+0x70008a>
	OCR1C = 0;
    1230:	10 92 8d 00 	sts	0x008D, r1	; 0x80008d <__TEXT_REGION_LENGTH__+0x70008d>
    1234:	10 92 8c 00 	sts	0x008C, r1	; 0x80008c <__TEXT_REGION_LENGTH__+0x70008c>
    1238:	08 95       	ret

0000123a <_ZN6Timer116setDutyCycleComAEf>:
}

void Timer1::setDutyCycleComA( float dutyCycle )
{
    123a:	cf 92       	push	r12
    123c:	df 92       	push	r13
    123e:	ef 92       	push	r14
    1240:	ff 92       	push	r15
    1242:	6a 01       	movw	r12, r20
    1244:	7b 01       	movw	r14, r22
	float percent = ICR1/100;
    1246:	20 91 86 00 	lds	r18, 0x0086	; 0x800086 <__TEXT_REGION_LENGTH__+0x700086>
    124a:	30 91 87 00 	lds	r19, 0x0087	; 0x800087 <__TEXT_REGION_LENGTH__+0x700087>
    124e:	36 95       	lsr	r19
    1250:	27 95       	ror	r18
    1252:	36 95       	lsr	r19
    1254:	27 95       	ror	r18
    1256:	ab e7       	ldi	r26, 0x7B	; 123
    1258:	b4 e1       	ldi	r27, 0x14	; 20
    125a:	0e 94 ac 11 	call	0x2358	; 0x2358 <__umulhisi3>
    125e:	96 95       	lsr	r25
    1260:	87 95       	ror	r24
	OCR1A = (uint8_t)percent*dutyCycle;
    1262:	bc 01       	movw	r22, r24
    1264:	77 27       	eor	r23, r23
    1266:	07 2e       	mov	r0, r23
    1268:	00 0c       	add	r0, r0
    126a:	88 0b       	sbc	r24, r24
    126c:	99 0b       	sbc	r25, r25
    126e:	3b d7       	rcall	.+3702   	; 0x20e6 <__floatsisf>
    1270:	a7 01       	movw	r20, r14
    1272:	96 01       	movw	r18, r12
    1274:	ec d7       	rcall	.+4056   	; 0x224e <__mulsf3>
    1276:	09 d7       	rcall	.+3602   	; 0x208a <__fixunssfsi>
    1278:	70 93 89 00 	sts	0x0089, r23	; 0x800089 <__TEXT_REGION_LENGTH__+0x700089>
    127c:	60 93 88 00 	sts	0x0088, r22	; 0x800088 <__TEXT_REGION_LENGTH__+0x700088>
}
    1280:	ff 90       	pop	r15
    1282:	ef 90       	pop	r14
    1284:	df 90       	pop	r13
    1286:	cf 90       	pop	r12
    1288:	08 95       	ret

0000128a <_ZN6Timer116setDutyCycleComBEf>:

void Timer1::setDutyCycleComB( float dutyCycle )
{
    128a:	cf 92       	push	r12
    128c:	df 92       	push	r13
    128e:	ef 92       	push	r14
    1290:	ff 92       	push	r15
    1292:	6a 01       	movw	r12, r20
    1294:	7b 01       	movw	r14, r22
	float percent = ICR1/100;
    1296:	20 91 86 00 	lds	r18, 0x0086	; 0x800086 <__TEXT_REGION_LENGTH__+0x700086>
    129a:	30 91 87 00 	lds	r19, 0x0087	; 0x800087 <__TEXT_REGION_LENGTH__+0x700087>
    129e:	36 95       	lsr	r19
    12a0:	27 95       	ror	r18
    12a2:	36 95       	lsr	r19
    12a4:	27 95       	ror	r18
    12a6:	ab e7       	ldi	r26, 0x7B	; 123
    12a8:	b4 e1       	ldi	r27, 0x14	; 20
    12aa:	0e 94 ac 11 	call	0x2358	; 0x2358 <__umulhisi3>
    12ae:	96 95       	lsr	r25
    12b0:	87 95       	ror	r24
	OCR1B = (uint8_t)percent*dutyCycle;
    12b2:	bc 01       	movw	r22, r24
    12b4:	77 27       	eor	r23, r23
    12b6:	07 2e       	mov	r0, r23
    12b8:	00 0c       	add	r0, r0
    12ba:	88 0b       	sbc	r24, r24
    12bc:	99 0b       	sbc	r25, r25
    12be:	13 d7       	rcall	.+3622   	; 0x20e6 <__floatsisf>
    12c0:	a7 01       	movw	r20, r14
    12c2:	96 01       	movw	r18, r12
    12c4:	c4 d7       	rcall	.+3976   	; 0x224e <__mulsf3>
    12c6:	e1 d6       	rcall	.+3522   	; 0x208a <__fixunssfsi>
    12c8:	70 93 8b 00 	sts	0x008B, r23	; 0x80008b <__TEXT_REGION_LENGTH__+0x70008b>
    12cc:	60 93 8a 00 	sts	0x008A, r22	; 0x80008a <__TEXT_REGION_LENGTH__+0x70008a>
}
    12d0:	ff 90       	pop	r15
    12d2:	ef 90       	pop	r14
    12d4:	df 90       	pop	r13
    12d6:	cf 90       	pop	r12
    12d8:	08 95       	ret

000012da <_ZN6Timer116setDutyCycleComCEf>:

void Timer1::setDutyCycleComC( float dutyCycle )
{
    12da:	cf 92       	push	r12
    12dc:	df 92       	push	r13
    12de:	ef 92       	push	r14
    12e0:	ff 92       	push	r15
    12e2:	6a 01       	movw	r12, r20
    12e4:	7b 01       	movw	r14, r22
	float percent = ICR1/100;
    12e6:	20 91 86 00 	lds	r18, 0x0086	; 0x800086 <__TEXT_REGION_LENGTH__+0x700086>
    12ea:	30 91 87 00 	lds	r19, 0x0087	; 0x800087 <__TEXT_REGION_LENGTH__+0x700087>
    12ee:	36 95       	lsr	r19
    12f0:	27 95       	ror	r18
    12f2:	36 95       	lsr	r19
    12f4:	27 95       	ror	r18
    12f6:	ab e7       	ldi	r26, 0x7B	; 123
    12f8:	b4 e1       	ldi	r27, 0x14	; 20
    12fa:	0e 94 ac 11 	call	0x2358	; 0x2358 <__umulhisi3>
    12fe:	96 95       	lsr	r25
    1300:	87 95       	ror	r24
	OCR1C = (uint8_t)percent*dutyCycle;
    1302:	bc 01       	movw	r22, r24
    1304:	77 27       	eor	r23, r23
    1306:	07 2e       	mov	r0, r23
    1308:	00 0c       	add	r0, r0
    130a:	88 0b       	sbc	r24, r24
    130c:	99 0b       	sbc	r25, r25
    130e:	eb d6       	rcall	.+3542   	; 0x20e6 <__floatsisf>
    1310:	a7 01       	movw	r20, r14
    1312:	96 01       	movw	r18, r12
    1314:	9c d7       	rcall	.+3896   	; 0x224e <__mulsf3>
    1316:	b9 d6       	rcall	.+3442   	; 0x208a <__fixunssfsi>
    1318:	70 93 8d 00 	sts	0x008D, r23	; 0x80008d <__TEXT_REGION_LENGTH__+0x70008d>
    131c:	60 93 8c 00 	sts	0x008C, r22	; 0x80008c <__TEXT_REGION_LENGTH__+0x70008c>
    1320:	ff 90       	pop	r15
    1322:	ef 90       	pop	r14
    1324:	df 90       	pop	r13
    1326:	cf 90       	pop	r12
    1328:	08 95       	ret

0000132a <_ZN6Timer5C1Ev>:
#include <avr/io.h>

Timer5::Timer5()
{
	// Set B5 to output
	DDRL = DDRL | ( 1 << 3 ) | ( 1 << 4 ) | ( 1 << 5 );
    132a:	ea e0       	ldi	r30, 0x0A	; 10
    132c:	f1 e0       	ldi	r31, 0x01	; 1
    132e:	80 81       	ld	r24, Z
    1330:	88 63       	ori	r24, 0x38	; 56
    1332:	80 83       	st	Z, r24
	
	// Set timer to run in PWM, Phase Correct mode with 50 Hz freq.
	TCCR5A = ( 1 << COM3A1 ) | ( 1 << COM3B1 ) | ( 1 << COM3C1 ) | ( 0 << WGM30 ) | ( 0 << WGM31 );
    1334:	88 ea       	ldi	r24, 0xA8	; 168
    1336:	80 93 20 01 	sts	0x0120, r24	; 0x800120 <__TEXT_REGION_LENGTH__+0x700120>
	TCCR5B = ( 1 << WGM33 ) | ( 0 << CS30 )  | ( 1 << CS32 );
    133a:	84 e1       	ldi	r24, 0x14	; 20
    133c:	80 93 21 01 	sts	0x0121, r24	; 0x800121 <__TEXT_REGION_LENGTH__+0x700121>
	TCCR5C = 0;
    1340:	10 92 22 01 	sts	0x0122, r1	; 0x800122 <__TEXT_REGION_LENGTH__+0x700122>
	ICR5 = 622;
    1344:	8e e6       	ldi	r24, 0x6E	; 110
    1346:	92 e0       	ldi	r25, 0x02	; 2
    1348:	90 93 27 01 	sts	0x0127, r25	; 0x800127 <__TEXT_REGION_LENGTH__+0x700127>
    134c:	80 93 26 01 	sts	0x0126, r24	; 0x800126 <__TEXT_REGION_LENGTH__+0x700126>
	
	OCR5A = 0;
    1350:	10 92 29 01 	sts	0x0129, r1	; 0x800129 <__TEXT_REGION_LENGTH__+0x700129>
    1354:	10 92 28 01 	sts	0x0128, r1	; 0x800128 <__TEXT_REGION_LENGTH__+0x700128>
	OCR5B = 0;
    1358:	10 92 2b 01 	sts	0x012B, r1	; 0x80012b <__TEXT_REGION_LENGTH__+0x70012b>
    135c:	10 92 2a 01 	sts	0x012A, r1	; 0x80012a <__TEXT_REGION_LENGTH__+0x70012a>
	OCR5C = 0;
    1360:	10 92 2d 01 	sts	0x012D, r1	; 0x80012d <__TEXT_REGION_LENGTH__+0x70012d>
    1364:	10 92 2c 01 	sts	0x012C, r1	; 0x80012c <__TEXT_REGION_LENGTH__+0x70012c>
    1368:	08 95       	ret

0000136a <_ZN6Timer516setDutyCycleComAEf>:
}

void Timer5::setDutyCycleComA( float dutyCycle )
{
    136a:	cf 92       	push	r12
    136c:	df 92       	push	r13
    136e:	ef 92       	push	r14
    1370:	ff 92       	push	r15
    1372:	6a 01       	movw	r12, r20
    1374:	7b 01       	movw	r14, r22
	float percent = ICR5/100;
    1376:	20 91 26 01 	lds	r18, 0x0126	; 0x800126 <__TEXT_REGION_LENGTH__+0x700126>
    137a:	30 91 27 01 	lds	r19, 0x0127	; 0x800127 <__TEXT_REGION_LENGTH__+0x700127>
    137e:	36 95       	lsr	r19
    1380:	27 95       	ror	r18
    1382:	36 95       	lsr	r19
    1384:	27 95       	ror	r18
    1386:	ab e7       	ldi	r26, 0x7B	; 123
    1388:	b4 e1       	ldi	r27, 0x14	; 20
    138a:	e6 d7       	rcall	.+4044   	; 0x2358 <__umulhisi3>
    138c:	96 95       	lsr	r25
    138e:	87 95       	ror	r24
	OCR5A = (uint8_t)percent*dutyCycle;
    1390:	bc 01       	movw	r22, r24
    1392:	77 27       	eor	r23, r23
    1394:	07 2e       	mov	r0, r23
    1396:	00 0c       	add	r0, r0
    1398:	88 0b       	sbc	r24, r24
    139a:	99 0b       	sbc	r25, r25
    139c:	a4 d6       	rcall	.+3400   	; 0x20e6 <__floatsisf>
    139e:	a7 01       	movw	r20, r14
    13a0:	96 01       	movw	r18, r12
    13a2:	55 d7       	rcall	.+3754   	; 0x224e <__mulsf3>
    13a4:	72 d6       	rcall	.+3300   	; 0x208a <__fixunssfsi>
    13a6:	70 93 29 01 	sts	0x0129, r23	; 0x800129 <__TEXT_REGION_LENGTH__+0x700129>
    13aa:	60 93 28 01 	sts	0x0128, r22	; 0x800128 <__TEXT_REGION_LENGTH__+0x700128>
}
    13ae:	ff 90       	pop	r15
    13b0:	ef 90       	pop	r14
    13b2:	df 90       	pop	r13
    13b4:	cf 90       	pop	r12
    13b6:	08 95       	ret

000013b8 <_ZN6Timer516setDutyCycleComBEf>:

void Timer5::setDutyCycleComB( float dutyCycle )
{
    13b8:	cf 92       	push	r12
    13ba:	df 92       	push	r13
    13bc:	ef 92       	push	r14
    13be:	ff 92       	push	r15
    13c0:	6a 01       	movw	r12, r20
    13c2:	7b 01       	movw	r14, r22
	float percent = ICR5/100;
    13c4:	20 91 26 01 	lds	r18, 0x0126	; 0x800126 <__TEXT_REGION_LENGTH__+0x700126>
    13c8:	30 91 27 01 	lds	r19, 0x0127	; 0x800127 <__TEXT_REGION_LENGTH__+0x700127>
    13cc:	36 95       	lsr	r19
    13ce:	27 95       	ror	r18
    13d0:	36 95       	lsr	r19
    13d2:	27 95       	ror	r18
    13d4:	ab e7       	ldi	r26, 0x7B	; 123
    13d6:	b4 e1       	ldi	r27, 0x14	; 20
    13d8:	bf d7       	rcall	.+3966   	; 0x2358 <__umulhisi3>
    13da:	96 95       	lsr	r25
    13dc:	87 95       	ror	r24
	OCR5B = (uint8_t)percent*dutyCycle;
    13de:	bc 01       	movw	r22, r24
    13e0:	77 27       	eor	r23, r23
    13e2:	07 2e       	mov	r0, r23
    13e4:	00 0c       	add	r0, r0
    13e6:	88 0b       	sbc	r24, r24
    13e8:	99 0b       	sbc	r25, r25
    13ea:	7d d6       	rcall	.+3322   	; 0x20e6 <__floatsisf>
    13ec:	a7 01       	movw	r20, r14
    13ee:	96 01       	movw	r18, r12
    13f0:	2e d7       	rcall	.+3676   	; 0x224e <__mulsf3>
    13f2:	4b d6       	rcall	.+3222   	; 0x208a <__fixunssfsi>
    13f4:	70 93 2b 01 	sts	0x012B, r23	; 0x80012b <__TEXT_REGION_LENGTH__+0x70012b>
    13f8:	60 93 2a 01 	sts	0x012A, r22	; 0x80012a <__TEXT_REGION_LENGTH__+0x70012a>
}
    13fc:	ff 90       	pop	r15
    13fe:	ef 90       	pop	r14
    1400:	df 90       	pop	r13
    1402:	cf 90       	pop	r12
    1404:	08 95       	ret

00001406 <_ZN6Timer516setDutyCycleComCEf>:

void Timer5::setDutyCycleComC( float dutyCycle )
{
    1406:	cf 92       	push	r12
    1408:	df 92       	push	r13
    140a:	ef 92       	push	r14
    140c:	ff 92       	push	r15
    140e:	6a 01       	movw	r12, r20
    1410:	7b 01       	movw	r14, r22
	float percent = ICR5/100;
    1412:	20 91 26 01 	lds	r18, 0x0126	; 0x800126 <__TEXT_REGION_LENGTH__+0x700126>
    1416:	30 91 27 01 	lds	r19, 0x0127	; 0x800127 <__TEXT_REGION_LENGTH__+0x700127>
    141a:	36 95       	lsr	r19
    141c:	27 95       	ror	r18
    141e:	36 95       	lsr	r19
    1420:	27 95       	ror	r18
    1422:	ab e7       	ldi	r26, 0x7B	; 123
    1424:	b4 e1       	ldi	r27, 0x14	; 20
    1426:	98 d7       	rcall	.+3888   	; 0x2358 <__umulhisi3>
    1428:	96 95       	lsr	r25
    142a:	87 95       	ror	r24
	OCR5C = (uint8_t)percent*dutyCycle;
    142c:	bc 01       	movw	r22, r24
    142e:	77 27       	eor	r23, r23
    1430:	07 2e       	mov	r0, r23
    1432:	00 0c       	add	r0, r0
    1434:	88 0b       	sbc	r24, r24
    1436:	99 0b       	sbc	r25, r25
    1438:	56 d6       	rcall	.+3244   	; 0x20e6 <__floatsisf>
    143a:	a7 01       	movw	r20, r14
    143c:	96 01       	movw	r18, r12
    143e:	07 d7       	rcall	.+3598   	; 0x224e <__mulsf3>
    1440:	24 d6       	rcall	.+3144   	; 0x208a <__fixunssfsi>
    1442:	70 93 2d 01 	sts	0x012D, r23	; 0x80012d <__TEXT_REGION_LENGTH__+0x70012d>
    1446:	60 93 2c 01 	sts	0x012C, r22	; 0x80012c <__TEXT_REGION_LENGTH__+0x70012c>
    144a:	ff 90       	pop	r15
    144c:	ef 90       	pop	r14
    144e:	df 90       	pop	r13
    1450:	cf 90       	pop	r12
    1452:	08 95       	ret

00001454 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
    1454:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
    1456:	03 96       	adiw	r24, 0x03	; 3
    1458:	92 83       	std	Z+2, r25	; 0x02
    145a:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    145c:	2f ef       	ldi	r18, 0xFF	; 255
    145e:	3f ef       	ldi	r19, 0xFF	; 255
    1460:	34 83       	std	Z+4, r19	; 0x04
    1462:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
    1464:	96 83       	std	Z+6, r25	; 0x06
    1466:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
    1468:	90 87       	std	Z+8, r25	; 0x08
    146a:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
    146c:	10 82       	st	Z, r1
    146e:	08 95       	ret

00001470 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    1470:	fc 01       	movw	r30, r24
    1472:	11 86       	std	Z+9, r1	; 0x09
    1474:	10 86       	std	Z+8, r1	; 0x08
    1476:	08 95       	ret

00001478 <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
    1478:	cf 93       	push	r28
    147a:	df 93       	push	r29
    147c:	fc 01       	movw	r30, r24
    147e:	db 01       	movw	r26, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
    1480:	21 81       	ldd	r18, Z+1	; 0x01
    1482:	32 81       	ldd	r19, Z+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
    1484:	e9 01       	movw	r28, r18
    1486:	8a 81       	ldd	r24, Y+2	; 0x02
    1488:	9b 81       	ldd	r25, Y+3	; 0x03
    148a:	13 96       	adiw	r26, 0x03	; 3
    148c:	9c 93       	st	X, r25
    148e:	8e 93       	st	-X, r24
    1490:	12 97       	sbiw	r26, 0x02	; 2
	pxNewListItem->pxPrevious = pxList->pxIndex;
    1492:	81 81       	ldd	r24, Z+1	; 0x01
    1494:	92 81       	ldd	r25, Z+2	; 0x02
    1496:	15 96       	adiw	r26, 0x05	; 5
    1498:	9c 93       	st	X, r25
    149a:	8e 93       	st	-X, r24
    149c:	14 97       	sbiw	r26, 0x04	; 4
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    149e:	8a 81       	ldd	r24, Y+2	; 0x02
    14a0:	9b 81       	ldd	r25, Y+3	; 0x03
    14a2:	ec 01       	movw	r28, r24
    14a4:	7d 83       	std	Y+5, r23	; 0x05
    14a6:	6c 83       	std	Y+4, r22	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
    14a8:	e9 01       	movw	r28, r18
    14aa:	7b 83       	std	Y+3, r23	; 0x03
    14ac:	6a 83       	std	Y+2, r22	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
    14ae:	72 83       	std	Z+2, r23	; 0x02
    14b0:	61 83       	std	Z+1, r22	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    14b2:	19 96       	adiw	r26, 0x09	; 9
    14b4:	fc 93       	st	X, r31
    14b6:	ee 93       	st	-X, r30
    14b8:	18 97       	sbiw	r26, 0x08	; 8

	( pxList->uxNumberOfItems )++;
    14ba:	80 81       	ld	r24, Z
    14bc:	8f 5f       	subi	r24, 0xFF	; 255
    14be:	80 83       	st	Z, r24
}
    14c0:	df 91       	pop	r29
    14c2:	cf 91       	pop	r28
    14c4:	08 95       	ret

000014c6 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
    14c6:	cf 93       	push	r28
    14c8:	df 93       	push	r29
    14ca:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
    14cc:	48 81       	ld	r20, Y
    14ce:	59 81       	ldd	r21, Y+1	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    14d0:	4f 3f       	cpi	r20, 0xFF	; 255
    14d2:	2f ef       	ldi	r18, 0xFF	; 255
    14d4:	52 07       	cpc	r21, r18
    14d6:	31 f4       	brne	.+12     	; 0x14e4 <vListInsert+0x1e>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    14d8:	dc 01       	movw	r26, r24
    14da:	17 96       	adiw	r26, 0x07	; 7
    14dc:	ed 91       	ld	r30, X+
    14de:	fc 91       	ld	r31, X
    14e0:	18 97       	sbiw	r26, 0x08	; 8
    14e2:	0d c0       	rjmp	.+26     	; 0x14fe <vListInsert+0x38>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    14e4:	fc 01       	movw	r30, r24
    14e6:	33 96       	adiw	r30, 0x03	; 3
    14e8:	03 c0       	rjmp	.+6      	; 0x14f0 <vListInsert+0x2a>
    14ea:	02 80       	ldd	r0, Z+2	; 0x02
    14ec:	f3 81       	ldd	r31, Z+3	; 0x03
    14ee:	e0 2d       	mov	r30, r0
    14f0:	a2 81       	ldd	r26, Z+2	; 0x02
    14f2:	b3 81       	ldd	r27, Z+3	; 0x03
    14f4:	2d 91       	ld	r18, X+
    14f6:	3c 91       	ld	r19, X
    14f8:	42 17       	cp	r20, r18
    14fa:	53 07       	cpc	r21, r19
    14fc:	b0 f7       	brcc	.-20     	; 0x14ea <vListInsert+0x24>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    14fe:	a2 81       	ldd	r26, Z+2	; 0x02
    1500:	b3 81       	ldd	r27, Z+3	; 0x03
    1502:	bb 83       	std	Y+3, r27	; 0x03
    1504:	aa 83       	std	Y+2, r26	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    1506:	15 96       	adiw	r26, 0x05	; 5
    1508:	dc 93       	st	X, r29
    150a:	ce 93       	st	-X, r28
    150c:	14 97       	sbiw	r26, 0x04	; 4
	pxNewListItem->pxPrevious = pxIterator;
    150e:	fd 83       	std	Y+5, r31	; 0x05
    1510:	ec 83       	std	Y+4, r30	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    1512:	d3 83       	std	Z+3, r29	; 0x03
    1514:	c2 83       	std	Z+2, r28	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1516:	99 87       	std	Y+9, r25	; 0x09
    1518:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    151a:	fc 01       	movw	r30, r24
    151c:	20 81       	ld	r18, Z
    151e:	2f 5f       	subi	r18, 0xFF	; 255
    1520:	20 83       	st	Z, r18
}
    1522:	df 91       	pop	r29
    1524:	cf 91       	pop	r28
    1526:	08 95       	ret

00001528 <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
    1528:	fc 01       	movw	r30, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    152a:	a2 81       	ldd	r26, Z+2	; 0x02
    152c:	b3 81       	ldd	r27, Z+3	; 0x03
    152e:	84 81       	ldd	r24, Z+4	; 0x04
    1530:	95 81       	ldd	r25, Z+5	; 0x05
    1532:	15 96       	adiw	r26, 0x05	; 5
    1534:	9c 93       	st	X, r25
    1536:	8e 93       	st	-X, r24
    1538:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    153a:	a4 81       	ldd	r26, Z+4	; 0x04
    153c:	b5 81       	ldd	r27, Z+5	; 0x05
    153e:	82 81       	ldd	r24, Z+2	; 0x02
    1540:	93 81       	ldd	r25, Z+3	; 0x03
    1542:	13 96       	adiw	r26, 0x03	; 3
    1544:	9c 93       	st	X, r25
    1546:	8e 93       	st	-X, r24
    1548:	12 97       	sbiw	r26, 0x02	; 2
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    154a:	a0 85       	ldd	r26, Z+8	; 0x08
    154c:	b1 85       	ldd	r27, Z+9	; 0x09

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    154e:	11 96       	adiw	r26, 0x01	; 1
    1550:	8d 91       	ld	r24, X+
    1552:	9c 91       	ld	r25, X
    1554:	12 97       	sbiw	r26, 0x02	; 2
    1556:	e8 17       	cp	r30, r24
    1558:	f9 07       	cpc	r31, r25
    155a:	31 f4       	brne	.+12     	; 0x1568 <vListRemove+0x40>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    155c:	84 81       	ldd	r24, Z+4	; 0x04
    155e:	95 81       	ldd	r25, Z+5	; 0x05
    1560:	12 96       	adiw	r26, 0x02	; 2
    1562:	9c 93       	st	X, r25
    1564:	8e 93       	st	-X, r24
    1566:	11 97       	sbiw	r26, 0x01	; 1
	}

	pxItemToRemove->pvContainer = NULL;
    1568:	11 86       	std	Z+9, r1	; 0x09
    156a:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    156c:	8c 91       	ld	r24, X
    156e:	81 50       	subi	r24, 0x01	; 1
    1570:	8c 93       	st	X, r24
    1572:	08 95       	ret

00001574 <prvSetupTimerInterrupt>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    1574:	8a ef       	ldi	r24, 0xFA	; 250
    1576:	87 bd       	out	0x27, r24	; 39
    1578:	82 e0       	ldi	r24, 0x02	; 2
    157a:	84 bd       	out	0x24, r24	; 36
    157c:	93 e0       	ldi	r25, 0x03	; 3
    157e:	95 bd       	out	0x25, r25	; 37
    1580:	80 93 6e 00 	sts	0x006E, r24	; 0x80006e <__TEXT_REGION_LENGTH__+0x70006e>
    1584:	08 95       	ret

00001586 <pxPortInitialiseStack>:
    1586:	31 e1       	ldi	r19, 0x11	; 17
    1588:	fc 01       	movw	r30, r24
    158a:	30 83       	st	Z, r19
    158c:	31 97       	sbiw	r30, 0x01	; 1
    158e:	22 e2       	ldi	r18, 0x22	; 34
    1590:	20 83       	st	Z, r18
    1592:	31 97       	sbiw	r30, 0x01	; 1
    1594:	a3 e3       	ldi	r26, 0x33	; 51
    1596:	a0 83       	st	Z, r26
    1598:	31 97       	sbiw	r30, 0x01	; 1
    159a:	60 83       	st	Z, r22
    159c:	31 97       	sbiw	r30, 0x01	; 1
    159e:	70 83       	st	Z, r23
    15a0:	31 97       	sbiw	r30, 0x01	; 1
    15a2:	10 82       	st	Z, r1
    15a4:	31 97       	sbiw	r30, 0x01	; 1
    15a6:	10 82       	st	Z, r1
    15a8:	31 97       	sbiw	r30, 0x01	; 1
    15aa:	60 e8       	ldi	r22, 0x80	; 128
    15ac:	60 83       	st	Z, r22
    15ae:	31 97       	sbiw	r30, 0x01	; 1
    15b0:	10 82       	st	Z, r1
    15b2:	31 97       	sbiw	r30, 0x01	; 1
    15b4:	10 82       	st	Z, r1
    15b6:	31 97       	sbiw	r30, 0x01	; 1
    15b8:	10 82       	st	Z, r1
    15ba:	31 97       	sbiw	r30, 0x01	; 1
    15bc:	62 e0       	ldi	r22, 0x02	; 2
    15be:	60 83       	st	Z, r22
    15c0:	31 97       	sbiw	r30, 0x01	; 1
    15c2:	63 e0       	ldi	r22, 0x03	; 3
    15c4:	60 83       	st	Z, r22
    15c6:	31 97       	sbiw	r30, 0x01	; 1
    15c8:	64 e0       	ldi	r22, 0x04	; 4
    15ca:	60 83       	st	Z, r22
    15cc:	31 97       	sbiw	r30, 0x01	; 1
    15ce:	65 e0       	ldi	r22, 0x05	; 5
    15d0:	60 83       	st	Z, r22
    15d2:	31 97       	sbiw	r30, 0x01	; 1
    15d4:	66 e0       	ldi	r22, 0x06	; 6
    15d6:	60 83       	st	Z, r22
    15d8:	31 97       	sbiw	r30, 0x01	; 1
    15da:	67 e0       	ldi	r22, 0x07	; 7
    15dc:	60 83       	st	Z, r22
    15de:	31 97       	sbiw	r30, 0x01	; 1
    15e0:	68 e0       	ldi	r22, 0x08	; 8
    15e2:	60 83       	st	Z, r22
    15e4:	31 97       	sbiw	r30, 0x01	; 1
    15e6:	69 e0       	ldi	r22, 0x09	; 9
    15e8:	60 83       	st	Z, r22
    15ea:	31 97       	sbiw	r30, 0x01	; 1
    15ec:	60 e1       	ldi	r22, 0x10	; 16
    15ee:	60 83       	st	Z, r22
    15f0:	31 97       	sbiw	r30, 0x01	; 1
    15f2:	30 83       	st	Z, r19
    15f4:	31 97       	sbiw	r30, 0x01	; 1
    15f6:	32 e1       	ldi	r19, 0x12	; 18
    15f8:	30 83       	st	Z, r19
    15fa:	31 97       	sbiw	r30, 0x01	; 1
    15fc:	33 e1       	ldi	r19, 0x13	; 19
    15fe:	30 83       	st	Z, r19
    1600:	31 97       	sbiw	r30, 0x01	; 1
    1602:	34 e1       	ldi	r19, 0x14	; 20
    1604:	30 83       	st	Z, r19
    1606:	31 97       	sbiw	r30, 0x01	; 1
    1608:	35 e1       	ldi	r19, 0x15	; 21
    160a:	30 83       	st	Z, r19
    160c:	31 97       	sbiw	r30, 0x01	; 1
    160e:	36 e1       	ldi	r19, 0x16	; 22
    1610:	30 83       	st	Z, r19
    1612:	31 97       	sbiw	r30, 0x01	; 1
    1614:	37 e1       	ldi	r19, 0x17	; 23
    1616:	30 83       	st	Z, r19
    1618:	31 97       	sbiw	r30, 0x01	; 1
    161a:	38 e1       	ldi	r19, 0x18	; 24
    161c:	30 83       	st	Z, r19
    161e:	31 97       	sbiw	r30, 0x01	; 1
    1620:	39 e1       	ldi	r19, 0x19	; 25
    1622:	30 83       	st	Z, r19
    1624:	31 97       	sbiw	r30, 0x01	; 1
    1626:	30 e2       	ldi	r19, 0x20	; 32
    1628:	30 83       	st	Z, r19
    162a:	31 97       	sbiw	r30, 0x01	; 1
    162c:	31 e2       	ldi	r19, 0x21	; 33
    162e:	30 83       	st	Z, r19
    1630:	31 97       	sbiw	r30, 0x01	; 1
    1632:	20 83       	st	Z, r18
    1634:	31 97       	sbiw	r30, 0x01	; 1
    1636:	23 e2       	ldi	r18, 0x23	; 35
    1638:	20 83       	st	Z, r18
    163a:	31 97       	sbiw	r30, 0x01	; 1
    163c:	40 83       	st	Z, r20
    163e:	31 97       	sbiw	r30, 0x01	; 1
    1640:	50 83       	st	Z, r21
    1642:	31 97       	sbiw	r30, 0x01	; 1
    1644:	26 e2       	ldi	r18, 0x26	; 38
    1646:	20 83       	st	Z, r18
    1648:	31 97       	sbiw	r30, 0x01	; 1
    164a:	27 e2       	ldi	r18, 0x27	; 39
    164c:	20 83       	st	Z, r18
    164e:	31 97       	sbiw	r30, 0x01	; 1
    1650:	28 e2       	ldi	r18, 0x28	; 40
    1652:	20 83       	st	Z, r18
    1654:	31 97       	sbiw	r30, 0x01	; 1
    1656:	29 e2       	ldi	r18, 0x29	; 41
    1658:	20 83       	st	Z, r18
    165a:	31 97       	sbiw	r30, 0x01	; 1
    165c:	20 e3       	ldi	r18, 0x30	; 48
    165e:	20 83       	st	Z, r18
    1660:	31 97       	sbiw	r30, 0x01	; 1
    1662:	21 e3       	ldi	r18, 0x31	; 49
    1664:	20 83       	st	Z, r18
    1666:	89 97       	sbiw	r24, 0x29	; 41
    1668:	08 95       	ret

0000166a <xPortStartScheduler>:
    166a:	84 df       	rcall	.-248    	; 0x1574 <prvSetupTimerInterrupt>
    166c:	a0 91 e5 08 	lds	r26, 0x08E5	; 0x8008e5 <pxCurrentTCB>
    1670:	b0 91 e6 08 	lds	r27, 0x08E6	; 0x8008e6 <pxCurrentTCB+0x1>
    1674:	cd 91       	ld	r28, X+
    1676:	cd bf       	out	0x3d, r28	; 61
    1678:	dd 91       	ld	r29, X+
    167a:	de bf       	out	0x3e, r29	; 62
    167c:	ff 91       	pop	r31
    167e:	ef 91       	pop	r30
    1680:	df 91       	pop	r29
    1682:	cf 91       	pop	r28
    1684:	bf 91       	pop	r27
    1686:	af 91       	pop	r26
    1688:	9f 91       	pop	r25
    168a:	8f 91       	pop	r24
    168c:	7f 91       	pop	r23
    168e:	6f 91       	pop	r22
    1690:	5f 91       	pop	r21
    1692:	4f 91       	pop	r20
    1694:	3f 91       	pop	r19
    1696:	2f 91       	pop	r18
    1698:	1f 91       	pop	r17
    169a:	0f 91       	pop	r16
    169c:	ff 90       	pop	r15
    169e:	ef 90       	pop	r14
    16a0:	df 90       	pop	r13
    16a2:	cf 90       	pop	r12
    16a4:	bf 90       	pop	r11
    16a6:	af 90       	pop	r10
    16a8:	9f 90       	pop	r9
    16aa:	8f 90       	pop	r8
    16ac:	7f 90       	pop	r7
    16ae:	6f 90       	pop	r6
    16b0:	5f 90       	pop	r5
    16b2:	4f 90       	pop	r4
    16b4:	3f 90       	pop	r3
    16b6:	2f 90       	pop	r2
    16b8:	1f 90       	pop	r1
    16ba:	0f 90       	pop	r0
    16bc:	0c be       	out	0x3c, r0	; 60
    16be:	0f 90       	pop	r0
    16c0:	0b be       	out	0x3b, r0	; 59
    16c2:	0f 90       	pop	r0
    16c4:	0f be       	out	0x3f, r0	; 63
    16c6:	0f 90       	pop	r0
    16c8:	08 95       	ret
    16ca:	81 e0       	ldi	r24, 0x01	; 1
    16cc:	08 95       	ret

000016ce <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    16ce:	0f 92       	push	r0
    16d0:	0f b6       	in	r0, 0x3f	; 63
    16d2:	f8 94       	cli
    16d4:	0f 92       	push	r0
    16d6:	0b b6       	in	r0, 0x3b	; 59
    16d8:	0f 92       	push	r0
    16da:	0c b6       	in	r0, 0x3c	; 60
    16dc:	0f 92       	push	r0
    16de:	1f 92       	push	r1
    16e0:	11 24       	eor	r1, r1
    16e2:	2f 92       	push	r2
    16e4:	3f 92       	push	r3
    16e6:	4f 92       	push	r4
    16e8:	5f 92       	push	r5
    16ea:	6f 92       	push	r6
    16ec:	7f 92       	push	r7
    16ee:	8f 92       	push	r8
    16f0:	9f 92       	push	r9
    16f2:	af 92       	push	r10
    16f4:	bf 92       	push	r11
    16f6:	cf 92       	push	r12
    16f8:	df 92       	push	r13
    16fa:	ef 92       	push	r14
    16fc:	ff 92       	push	r15
    16fe:	0f 93       	push	r16
    1700:	1f 93       	push	r17
    1702:	2f 93       	push	r18
    1704:	3f 93       	push	r19
    1706:	4f 93       	push	r20
    1708:	5f 93       	push	r21
    170a:	6f 93       	push	r22
    170c:	7f 93       	push	r23
    170e:	8f 93       	push	r24
    1710:	9f 93       	push	r25
    1712:	af 93       	push	r26
    1714:	bf 93       	push	r27
    1716:	cf 93       	push	r28
    1718:	df 93       	push	r29
    171a:	ef 93       	push	r30
    171c:	ff 93       	push	r31
    171e:	a0 91 e5 08 	lds	r26, 0x08E5	; 0x8008e5 <pxCurrentTCB>
    1722:	b0 91 e6 08 	lds	r27, 0x08E6	; 0x8008e6 <pxCurrentTCB+0x1>
    1726:	0d b6       	in	r0, 0x3d	; 61
    1728:	0d 92       	st	X+, r0
    172a:	0e b6       	in	r0, 0x3e	; 62
    172c:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    172e:	84 d3       	rcall	.+1800   	; 0x1e38 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1730:	a0 91 e5 08 	lds	r26, 0x08E5	; 0x8008e5 <pxCurrentTCB>
    1734:	b0 91 e6 08 	lds	r27, 0x08E6	; 0x8008e6 <pxCurrentTCB+0x1>
    1738:	cd 91       	ld	r28, X+
    173a:	cd bf       	out	0x3d, r28	; 61
    173c:	dd 91       	ld	r29, X+
    173e:	de bf       	out	0x3e, r29	; 62
    1740:	ff 91       	pop	r31
    1742:	ef 91       	pop	r30
    1744:	df 91       	pop	r29
    1746:	cf 91       	pop	r28
    1748:	bf 91       	pop	r27
    174a:	af 91       	pop	r26
    174c:	9f 91       	pop	r25
    174e:	8f 91       	pop	r24
    1750:	7f 91       	pop	r23
    1752:	6f 91       	pop	r22
    1754:	5f 91       	pop	r21
    1756:	4f 91       	pop	r20
    1758:	3f 91       	pop	r19
    175a:	2f 91       	pop	r18
    175c:	1f 91       	pop	r17
    175e:	0f 91       	pop	r16
    1760:	ff 90       	pop	r15
    1762:	ef 90       	pop	r14
    1764:	df 90       	pop	r13
    1766:	cf 90       	pop	r12
    1768:	bf 90       	pop	r11
    176a:	af 90       	pop	r10
    176c:	9f 90       	pop	r9
    176e:	8f 90       	pop	r8
    1770:	7f 90       	pop	r7
    1772:	6f 90       	pop	r6
    1774:	5f 90       	pop	r5
    1776:	4f 90       	pop	r4
    1778:	3f 90       	pop	r3
    177a:	2f 90       	pop	r2
    177c:	1f 90       	pop	r1
    177e:	0f 90       	pop	r0
    1780:	0c be       	out	0x3c, r0	; 60
    1782:	0f 90       	pop	r0
    1784:	0b be       	out	0x3b, r0	; 59
    1786:	0f 90       	pop	r0
    1788:	0f be       	out	0x3f, r0	; 63
    178a:	0f 90       	pop	r0

	asm volatile ( "ret" );
    178c:	08 95       	ret

0000178e <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    178e:	0f 92       	push	r0
    1790:	0f b6       	in	r0, 0x3f	; 63
    1792:	f8 94       	cli
    1794:	0f 92       	push	r0
    1796:	0b b6       	in	r0, 0x3b	; 59
    1798:	0f 92       	push	r0
    179a:	0c b6       	in	r0, 0x3c	; 60
    179c:	0f 92       	push	r0
    179e:	1f 92       	push	r1
    17a0:	11 24       	eor	r1, r1
    17a2:	2f 92       	push	r2
    17a4:	3f 92       	push	r3
    17a6:	4f 92       	push	r4
    17a8:	5f 92       	push	r5
    17aa:	6f 92       	push	r6
    17ac:	7f 92       	push	r7
    17ae:	8f 92       	push	r8
    17b0:	9f 92       	push	r9
    17b2:	af 92       	push	r10
    17b4:	bf 92       	push	r11
    17b6:	cf 92       	push	r12
    17b8:	df 92       	push	r13
    17ba:	ef 92       	push	r14
    17bc:	ff 92       	push	r15
    17be:	0f 93       	push	r16
    17c0:	1f 93       	push	r17
    17c2:	2f 93       	push	r18
    17c4:	3f 93       	push	r19
    17c6:	4f 93       	push	r20
    17c8:	5f 93       	push	r21
    17ca:	6f 93       	push	r22
    17cc:	7f 93       	push	r23
    17ce:	8f 93       	push	r24
    17d0:	9f 93       	push	r25
    17d2:	af 93       	push	r26
    17d4:	bf 93       	push	r27
    17d6:	cf 93       	push	r28
    17d8:	df 93       	push	r29
    17da:	ef 93       	push	r30
    17dc:	ff 93       	push	r31
    17de:	a0 91 e5 08 	lds	r26, 0x08E5	; 0x8008e5 <pxCurrentTCB>
    17e2:	b0 91 e6 08 	lds	r27, 0x08E6	; 0x8008e6 <pxCurrentTCB+0x1>
    17e6:	0d b6       	in	r0, 0x3d	; 61
    17e8:	0d 92       	st	X+, r0
    17ea:	0e b6       	in	r0, 0x3e	; 62
    17ec:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    17ee:	ef d1       	rcall	.+990    	; 0x1bce <vTaskIncrementTick>
	vTaskSwitchContext();
    17f0:	23 d3       	rcall	.+1606   	; 0x1e38 <vTaskSwitchContext>
    17f2:	a0 91 e5 08 	lds	r26, 0x08E5	; 0x8008e5 <pxCurrentTCB>
	portRESTORE_CONTEXT();
    17f6:	b0 91 e6 08 	lds	r27, 0x08E6	; 0x8008e6 <pxCurrentTCB+0x1>
    17fa:	cd 91       	ld	r28, X+
    17fc:	cd bf       	out	0x3d, r28	; 61
    17fe:	dd 91       	ld	r29, X+
    1800:	de bf       	out	0x3e, r29	; 62
    1802:	ff 91       	pop	r31
    1804:	ef 91       	pop	r30
    1806:	df 91       	pop	r29
    1808:	cf 91       	pop	r28
    180a:	bf 91       	pop	r27
    180c:	af 91       	pop	r26
    180e:	9f 91       	pop	r25
    1810:	8f 91       	pop	r24
    1812:	7f 91       	pop	r23
    1814:	6f 91       	pop	r22
    1816:	5f 91       	pop	r21
    1818:	4f 91       	pop	r20
    181a:	3f 91       	pop	r19
    181c:	2f 91       	pop	r18
    181e:	1f 91       	pop	r17
    1820:	0f 91       	pop	r16
    1822:	ff 90       	pop	r15
    1824:	ef 90       	pop	r14
    1826:	df 90       	pop	r13
    1828:	cf 90       	pop	r12
    182a:	bf 90       	pop	r11
    182c:	af 90       	pop	r10
    182e:	9f 90       	pop	r9
    1830:	8f 90       	pop	r8
    1832:	7f 90       	pop	r7
    1834:	6f 90       	pop	r6
    1836:	5f 90       	pop	r5
    1838:	4f 90       	pop	r4
    183a:	3f 90       	pop	r3
    183c:	2f 90       	pop	r2
    183e:	1f 90       	pop	r1
    1840:	0f 90       	pop	r0
    1842:	0c be       	out	0x3c, r0	; 60
    1844:	0f 90       	pop	r0
    1846:	0b be       	out	0x3b, r0	; 59
    1848:	0f 90       	pop	r0
    184a:	0f be       	out	0x3f, r0	; 63
    184c:	0f 90       	pop	r0
    184e:	08 95       	ret

00001850 <__vector_21>:
	asm volatile ( "ret" );
    1850:	9e df       	rcall	.-196    	; 0x178e <vPortYieldFromTick>
//	void SIG_OUTPUT_COMPARE1A( void )
	void TIMER0_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER0_COMPA_vect( void )
	{
		vPortYieldFromTick();
		asm volatile ( "reti" );
    1852:	18 95       	reti

00001854 <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    1854:	cf 93       	push	r28
    1856:	df 93       	push	r29
    1858:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
    185a:	b3 d1       	rcall	.+870    	; 0x1bc2 <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
    185c:	20 91 d4 02 	lds	r18, 0x02D4	; 0x8002d4 <xNextFreeByte>
    1860:	30 91 d5 02 	lds	r19, 0x02D5	; 0x8002d5 <xNextFreeByte+0x1>
    1864:	c9 01       	movw	r24, r18
    1866:	8c 0f       	add	r24, r28
    1868:	9d 1f       	adc	r25, r29
    186a:	8c 3d       	cpi	r24, 0xDC	; 220
    186c:	45 e0       	ldi	r20, 0x05	; 5
    186e:	94 07       	cpc	r25, r20
    1870:	58 f4       	brcc	.+22     	; 0x1888 <pvPortMalloc+0x34>
    1872:	28 17       	cp	r18, r24
    1874:	39 07       	cpc	r19, r25
    1876:	58 f4       	brcc	.+22     	; 0x188e <pvPortMalloc+0x3a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
    1878:	e9 01       	movw	r28, r18
    187a:	ca 52       	subi	r28, 0x2A	; 42
    187c:	dd 4f       	sbci	r29, 0xFD	; 253
			xNextFreeByte += xWantedSize;			
    187e:	90 93 d5 02 	sts	0x02D5, r25	; 0x8002d5 <xNextFreeByte+0x1>
    1882:	80 93 d4 02 	sts	0x02D4, r24	; 0x8002d4 <xNextFreeByte>
    1886:	05 c0       	rjmp	.+10     	; 0x1892 <pvPortMalloc+0x3e>
static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL; 
    1888:	c0 e0       	ldi	r28, 0x00	; 0
    188a:	d0 e0       	ldi	r29, 0x00	; 0
    188c:	02 c0       	rjmp	.+4      	; 0x1892 <pvPortMalloc+0x3e>
    188e:	c0 e0       	ldi	r28, 0x00	; 0
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
			xNextFreeByte += xWantedSize;			
		}	
	}
	xTaskResumeAll();
    1890:	d0 e0       	ldi	r29, 0x00	; 0
    1892:	44 d2       	rcall	.+1160   	; 0x1d1c <xTaskResumeAll>
		}
	}
	#endif	

	return pvReturn;
}
    1894:	ce 01       	movw	r24, r28
    1896:	df 91       	pop	r29
    1898:	cf 91       	pop	r28
    189a:	08 95       	ret

0000189c <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    189c:	08 95       	ret

0000189e <prvIdleTask>:
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
		}
	}
    189e:	80 91 dc 08 	lds	r24, 0x08DC	; 0x8008dc <pxReadyTasksLists>
    18a2:	82 30       	cpi	r24, 0x02	; 2
    18a4:	e0 f3       	brcs	.-8      	; 0x189e <prvIdleTask>
    18a6:	13 df       	rcall	.-474    	; 0x16ce <vPortYield>
    18a8:	fa cf       	rjmp	.-12     	; 0x189e <prvIdleTask>

000018aa <prvAllocateTCBAndStack>:
    18aa:	ef 92       	push	r14
    18ac:	ff 92       	push	r15
    18ae:	0f 93       	push	r16
    18b0:	1f 93       	push	r17
    18b2:	cf 93       	push	r28
    18b4:	df 93       	push	r29
    18b6:	7c 01       	movw	r14, r24
    18b8:	eb 01       	movw	r28, r22
    18ba:	81 e2       	ldi	r24, 0x21	; 33
    18bc:	90 e0       	ldi	r25, 0x00	; 0
    18be:	ca df       	rcall	.-108    	; 0x1854 <pvPortMalloc>
    18c0:	8c 01       	movw	r16, r24
    18c2:	89 2b       	or	r24, r25
    18c4:	a1 f0       	breq	.+40     	; 0x18ee <prvAllocateTCBAndStack+0x44>
    18c6:	20 97       	sbiw	r28, 0x00	; 0
    18c8:	19 f4       	brne	.+6      	; 0x18d0 <prvAllocateTCBAndStack+0x26>
    18ca:	c7 01       	movw	r24, r14
    18cc:	c3 df       	rcall	.-122    	; 0x1854 <pvPortMalloc>
    18ce:	01 c0       	rjmp	.+2      	; 0x18d2 <prvAllocateTCBAndStack+0x28>
    18d0:	ce 01       	movw	r24, r28
    18d2:	f8 01       	movw	r30, r16
    18d4:	90 8f       	std	Z+24, r25	; 0x18
    18d6:	87 8b       	std	Z+23, r24	; 0x17
    18d8:	00 97       	sbiw	r24, 0x00	; 0
    18da:	29 f4       	brne	.+10     	; 0x18e6 <prvAllocateTCBAndStack+0x3c>
    18dc:	c8 01       	movw	r24, r16
    18de:	de df       	rcall	.-68     	; 0x189c <vPortFree>
    18e0:	00 e0       	ldi	r16, 0x00	; 0
    18e2:	10 e0       	ldi	r17, 0x00	; 0
    18e4:	04 c0       	rjmp	.+8      	; 0x18ee <prvAllocateTCBAndStack+0x44>
    18e6:	a7 01       	movw	r20, r14
    18e8:	65 ea       	ldi	r22, 0xA5	; 165
    18ea:	70 e0       	ldi	r23, 0x00	; 0
    18ec:	65 d6       	rcall	.+3274   	; 0x25b8 <memset>
    18ee:	c8 01       	movw	r24, r16
    18f0:	df 91       	pop	r29
    18f2:	cf 91       	pop	r28
    18f4:	1f 91       	pop	r17
    18f6:	0f 91       	pop	r16
    18f8:	ff 90       	pop	r15
    18fa:	ef 90       	pop	r14
    18fc:	08 95       	ret

000018fe <prvInitialiseTCBVariables>:
    18fe:	1f 93       	push	r17
    1900:	cf 93       	push	r28
    1902:	df 93       	push	r29
    1904:	ec 01       	movw	r28, r24
    1906:	14 2f       	mov	r17, r20
    1908:	48 e0       	ldi	r20, 0x08	; 8
    190a:	50 e0       	ldi	r21, 0x00	; 0
    190c:	49 96       	adiw	r24, 0x19	; 25
    190e:	5b d6       	rcall	.+3254   	; 0x25c6 <strncpy>
    1910:	18 a2       	std	Y+32, r1	; 0x20
    1912:	11 11       	cpse	r17, r1
    1914:	10 e0       	ldi	r17, 0x00	; 0
    1916:	1e 8b       	std	Y+22, r17	; 0x16
    1918:	ce 01       	movw	r24, r28
    191a:	02 96       	adiw	r24, 0x02	; 2
    191c:	a9 dd       	rcall	.-1198   	; 0x1470 <vListInitialiseItem>
    191e:	ce 01       	movw	r24, r28
    1920:	0c 96       	adiw	r24, 0x0c	; 12
    1922:	a6 dd       	rcall	.-1204   	; 0x1470 <vListInitialiseItem>
    1924:	d9 87       	std	Y+9, r29	; 0x09
    1926:	c8 87       	std	Y+8, r28	; 0x08
    1928:	81 e0       	ldi	r24, 0x01	; 1
    192a:	90 e0       	ldi	r25, 0x00	; 0
    192c:	81 1b       	sub	r24, r17
    192e:	91 09       	sbc	r25, r1
    1930:	9d 87       	std	Y+13, r25	; 0x0d
    1932:	8c 87       	std	Y+12, r24	; 0x0c
    1934:	db 8b       	std	Y+19, r29	; 0x13
    1936:	ca 8b       	std	Y+18, r28	; 0x12
    1938:	df 91       	pop	r29
    193a:	cf 91       	pop	r28
    193c:	1f 91       	pop	r17
    193e:	08 95       	ret

00001940 <prvInitialiseTaskLists>:
    1940:	cf 93       	push	r28
    1942:	c0 e0       	ldi	r28, 0x00	; 0
    1944:	0f c0       	rjmp	.+30     	; 0x1964 <prvInitialiseTaskLists+0x24>
    1946:	8c 2f       	mov	r24, r28
    1948:	90 e0       	ldi	r25, 0x00	; 0
    194a:	9c 01       	movw	r18, r24
    194c:	22 0f       	add	r18, r18
    194e:	33 1f       	adc	r19, r19
    1950:	22 0f       	add	r18, r18
    1952:	33 1f       	adc	r19, r19
    1954:	22 0f       	add	r18, r18
    1956:	33 1f       	adc	r19, r19
    1958:	82 0f       	add	r24, r18
    195a:	93 1f       	adc	r25, r19
    195c:	84 52       	subi	r24, 0x24	; 36
    195e:	97 4f       	sbci	r25, 0xF7	; 247
    1960:	79 dd       	rcall	.-1294   	; 0x1454 <vListInitialise>
    1962:	cf 5f       	subi	r28, 0xFF	; 255
    1964:	cc 23       	and	r28, r28
    1966:	79 f3       	breq	.-34     	; 0x1946 <prvInitialiseTaskLists+0x6>
    1968:	83 ed       	ldi	r24, 0xD3	; 211
    196a:	98 e0       	ldi	r25, 0x08	; 8
    196c:	73 dd       	rcall	.-1306   	; 0x1454 <vListInitialise>
    196e:	8a ec       	ldi	r24, 0xCA	; 202
    1970:	98 e0       	ldi	r25, 0x08	; 8
    1972:	70 dd       	rcall	.-1312   	; 0x1454 <vListInitialise>
    1974:	8d eb       	ldi	r24, 0xBD	; 189
    1976:	98 e0       	ldi	r25, 0x08	; 8
    1978:	6d dd       	rcall	.-1318   	; 0x1454 <vListInitialise>
    197a:	83 ed       	ldi	r24, 0xD3	; 211
    197c:	98 e0       	ldi	r25, 0x08	; 8
    197e:	90 93 c9 08 	sts	0x08C9, r25	; 0x8008c9 <pxDelayedTaskList+0x1>
    1982:	80 93 c8 08 	sts	0x08C8, r24	; 0x8008c8 <pxDelayedTaskList>
    1986:	8a ec       	ldi	r24, 0xCA	; 202
    1988:	98 e0       	ldi	r25, 0x08	; 8
    198a:	90 93 c7 08 	sts	0x08C7, r25	; 0x8008c7 <pxOverflowDelayedTaskList+0x1>
    198e:	80 93 c6 08 	sts	0x08C6, r24	; 0x8008c6 <pxOverflowDelayedTaskList>
    1992:	cf 91       	pop	r28
    1994:	08 95       	ret

00001996 <prvAddCurrentTaskToDelayedList>:
    1996:	cf 93       	push	r28
    1998:	df 93       	push	r29
    199a:	ec 01       	movw	r28, r24
    199c:	e0 91 e5 08 	lds	r30, 0x08E5	; 0x8008e5 <pxCurrentTCB>
    19a0:	f0 91 e6 08 	lds	r31, 0x08E6	; 0x8008e6 <pxCurrentTCB+0x1>
    19a4:	93 83       	std	Z+3, r25	; 0x03
    19a6:	82 83       	std	Z+2, r24	; 0x02
    19a8:	80 91 ba 08 	lds	r24, 0x08BA	; 0x8008ba <xTickCount>
    19ac:	90 91 bb 08 	lds	r25, 0x08BB	; 0x8008bb <xTickCount+0x1>
    19b0:	c8 17       	cp	r28, r24
    19b2:	d9 07       	cpc	r29, r25
    19b4:	60 f4       	brcc	.+24     	; 0x19ce <prvAddCurrentTaskToDelayedList+0x38>
    19b6:	60 91 e5 08 	lds	r22, 0x08E5	; 0x8008e5 <pxCurrentTCB>
    19ba:	70 91 e6 08 	lds	r23, 0x08E6	; 0x8008e6 <pxCurrentTCB+0x1>
    19be:	80 91 c6 08 	lds	r24, 0x08C6	; 0x8008c6 <pxOverflowDelayedTaskList>
    19c2:	90 91 c7 08 	lds	r25, 0x08C7	; 0x8008c7 <pxOverflowDelayedTaskList+0x1>
    19c6:	6e 5f       	subi	r22, 0xFE	; 254
    19c8:	7f 4f       	sbci	r23, 0xFF	; 255
    19ca:	7d dd       	rcall	.-1286   	; 0x14c6 <vListInsert>
    19cc:	16 c0       	rjmp	.+44     	; 0x19fa <prvAddCurrentTaskToDelayedList+0x64>
    19ce:	60 91 e5 08 	lds	r22, 0x08E5	; 0x8008e5 <pxCurrentTCB>
    19d2:	70 91 e6 08 	lds	r23, 0x08E6	; 0x8008e6 <pxCurrentTCB+0x1>
    19d6:	80 91 c8 08 	lds	r24, 0x08C8	; 0x8008c8 <pxDelayedTaskList>
    19da:	90 91 c9 08 	lds	r25, 0x08C9	; 0x8008c9 <pxDelayedTaskList+0x1>
    19de:	6e 5f       	subi	r22, 0xFE	; 254
    19e0:	7f 4f       	sbci	r23, 0xFF	; 255
    19e2:	71 dd       	rcall	.-1310   	; 0x14c6 <vListInsert>
    19e4:	80 91 0b 02 	lds	r24, 0x020B	; 0x80020b <xNextTaskUnblockTime>
    19e8:	90 91 0c 02 	lds	r25, 0x020C	; 0x80020c <xNextTaskUnblockTime+0x1>
    19ec:	c8 17       	cp	r28, r24
    19ee:	d9 07       	cpc	r29, r25
    19f0:	20 f4       	brcc	.+8      	; 0x19fa <prvAddCurrentTaskToDelayedList+0x64>
    19f2:	d0 93 0c 02 	sts	0x020C, r29	; 0x80020c <xNextTaskUnblockTime+0x1>
    19f6:	c0 93 0b 02 	sts	0x020B, r28	; 0x80020b <xNextTaskUnblockTime>
    19fa:	df 91       	pop	r29
    19fc:	cf 91       	pop	r28
    19fe:	08 95       	ret

00001a00 <xTaskGenericCreate>:
    1a00:	2f 92       	push	r2
    1a02:	3f 92       	push	r3
    1a04:	4f 92       	push	r4
    1a06:	5f 92       	push	r5
    1a08:	7f 92       	push	r7
    1a0a:	8f 92       	push	r8
    1a0c:	9f 92       	push	r9
    1a0e:	af 92       	push	r10
    1a10:	bf 92       	push	r11
    1a12:	cf 92       	push	r12
    1a14:	df 92       	push	r13
    1a16:	ef 92       	push	r14
    1a18:	ff 92       	push	r15
    1a1a:	0f 93       	push	r16
    1a1c:	1f 93       	push	r17
    1a1e:	cf 93       	push	r28
    1a20:	df 93       	push	r29
    1a22:	00 d0       	rcall	.+0      	; 0x1a24 <xTaskGenericCreate+0x24>
    1a24:	1f 92       	push	r1
    1a26:	cd b7       	in	r28, 0x3d	; 61
    1a28:	de b7       	in	r29, 0x3e	; 62
    1a2a:	9a 83       	std	Y+2, r25	; 0x02
    1a2c:	89 83       	std	Y+1, r24	; 0x01
    1a2e:	4b 01       	movw	r8, r22
    1a30:	5c 83       	std	Y+4, r21	; 0x04
    1a32:	4b 83       	std	Y+3, r20	; 0x03
    1a34:	19 01       	movw	r2, r18
    1a36:	70 2e       	mov	r7, r16
    1a38:	b6 01       	movw	r22, r12
    1a3a:	25 01       	movw	r4, r10
    1a3c:	ca 01       	movw	r24, r20
    1a3e:	35 df       	rcall	.-406    	; 0x18aa <prvAllocateTCBAndStack>
    1a40:	5c 01       	movw	r10, r24
    1a42:	00 97       	sbiw	r24, 0x00	; 0
    1a44:	09 f4       	brne	.+2      	; 0x1a48 <xTaskGenericCreate+0x48>
    1a46:	6c c0       	rjmp	.+216    	; 0x1b20 <xTaskGenericCreate+0x120>
    1a48:	fc 01       	movw	r30, r24
    1a4a:	c7 88       	ldd	r12, Z+23	; 0x17
    1a4c:	d0 8c       	ldd	r13, Z+24	; 0x18
    1a4e:	8b 81       	ldd	r24, Y+3	; 0x03
    1a50:	9c 81       	ldd	r25, Y+4	; 0x04
    1a52:	01 97       	sbiw	r24, 0x01	; 1
    1a54:	c8 0e       	add	r12, r24
    1a56:	d9 1e       	adc	r13, r25
    1a58:	0b 81       	ldd	r16, Y+3	; 0x03
    1a5a:	1c 81       	ldd	r17, Y+4	; 0x04
    1a5c:	92 01       	movw	r18, r4
    1a5e:	47 2d       	mov	r20, r7
    1a60:	b4 01       	movw	r22, r8
    1a62:	c5 01       	movw	r24, r10
    1a64:	4c df       	rcall	.-360    	; 0x18fe <prvInitialiseTCBVariables>
    1a66:	a1 01       	movw	r20, r2
    1a68:	69 81       	ldd	r22, Y+1	; 0x01
    1a6a:	7a 81       	ldd	r23, Y+2	; 0x02
    1a6c:	c6 01       	movw	r24, r12
    1a6e:	8b dd       	rcall	.-1258   	; 0x1586 <pxPortInitialiseStack>
    1a70:	f5 01       	movw	r30, r10
    1a72:	91 83       	std	Z+1, r25	; 0x01
    1a74:	80 83       	st	Z, r24
    1a76:	e1 14       	cp	r14, r1
    1a78:	f1 04       	cpc	r15, r1
    1a7a:	19 f0       	breq	.+6      	; 0x1a82 <xTaskGenericCreate+0x82>
    1a7c:	f7 01       	movw	r30, r14
    1a7e:	b1 82       	std	Z+1, r11	; 0x01
    1a80:	a0 82       	st	Z, r10
    1a82:	0f b6       	in	r0, 0x3f	; 63
    1a84:	f8 94       	cli
    1a86:	0f 92       	push	r0
    1a88:	80 91 bc 08 	lds	r24, 0x08BC	; 0x8008bc <uxCurrentNumberOfTasks>
    1a8c:	8f 5f       	subi	r24, 0xFF	; 255
    1a8e:	80 93 bc 08 	sts	0x08BC, r24	; 0x8008bc <uxCurrentNumberOfTasks>
    1a92:	80 91 e5 08 	lds	r24, 0x08E5	; 0x8008e5 <pxCurrentTCB>
    1a96:	90 91 e6 08 	lds	r25, 0x08E6	; 0x8008e6 <pxCurrentTCB+0x1>
    1a9a:	89 2b       	or	r24, r25
    1a9c:	51 f4       	brne	.+20     	; 0x1ab2 <xTaskGenericCreate+0xb2>
    1a9e:	b0 92 e6 08 	sts	0x08E6, r11	; 0x8008e6 <pxCurrentTCB+0x1>
    1aa2:	a0 92 e5 08 	sts	0x08E5, r10	; 0x8008e5 <pxCurrentTCB>
    1aa6:	80 91 bc 08 	lds	r24, 0x08BC	; 0x8008bc <uxCurrentNumberOfTasks>
    1aaa:	81 30       	cpi	r24, 0x01	; 1
    1aac:	89 f4       	brne	.+34     	; 0x1ad0 <xTaskGenericCreate+0xd0>
    1aae:	48 df       	rcall	.-368    	; 0x1940 <prvInitialiseTaskLists>
    1ab0:	0f c0       	rjmp	.+30     	; 0x1ad0 <xTaskGenericCreate+0xd0>
    1ab2:	80 91 b7 08 	lds	r24, 0x08B7	; 0x8008b7 <xSchedulerRunning>
    1ab6:	81 11       	cpse	r24, r1
    1ab8:	0b c0       	rjmp	.+22     	; 0x1ad0 <xTaskGenericCreate+0xd0>
    1aba:	e0 91 e5 08 	lds	r30, 0x08E5	; 0x8008e5 <pxCurrentTCB>
    1abe:	f0 91 e6 08 	lds	r31, 0x08E6	; 0x8008e6 <pxCurrentTCB+0x1>
    1ac2:	86 89       	ldd	r24, Z+22	; 0x16
    1ac4:	78 16       	cp	r7, r24
    1ac6:	20 f0       	brcs	.+8      	; 0x1ad0 <xTaskGenericCreate+0xd0>
    1ac8:	b0 92 e6 08 	sts	0x08E6, r11	; 0x8008e6 <pxCurrentTCB+0x1>
    1acc:	a0 92 e5 08 	sts	0x08E5, r10	; 0x8008e5 <pxCurrentTCB>
    1ad0:	f5 01       	movw	r30, r10
    1ad2:	86 89       	ldd	r24, Z+22	; 0x16
    1ad4:	90 91 b9 08 	lds	r25, 0x08B9	; 0x8008b9 <uxTopUsedPriority>
    1ad8:	98 17       	cp	r25, r24
    1ada:	10 f4       	brcc	.+4      	; 0x1ae0 <xTaskGenericCreate+0xe0>
    1adc:	80 93 b9 08 	sts	0x08B9, r24	; 0x8008b9 <uxTopUsedPriority>
    1ae0:	90 91 b2 08 	lds	r25, 0x08B2	; 0x8008b2 <uxTCBNumber>
    1ae4:	9f 5f       	subi	r25, 0xFF	; 255
    1ae6:	90 93 b2 08 	sts	0x08B2, r25	; 0x8008b2 <uxTCBNumber>
    1aea:	90 91 b8 08 	lds	r25, 0x08B8	; 0x8008b8 <uxTopReadyPriority>
    1aee:	98 17       	cp	r25, r24
    1af0:	10 f4       	brcc	.+4      	; 0x1af6 <xTaskGenericCreate+0xf6>
    1af2:	80 93 b8 08 	sts	0x08B8, r24	; 0x8008b8 <uxTopReadyPriority>
    1af6:	90 e0       	ldi	r25, 0x00	; 0
    1af8:	b5 01       	movw	r22, r10
    1afa:	6e 5f       	subi	r22, 0xFE	; 254
    1afc:	7f 4f       	sbci	r23, 0xFF	; 255
    1afe:	9c 01       	movw	r18, r24
    1b00:	22 0f       	add	r18, r18
    1b02:	33 1f       	adc	r19, r19
    1b04:	22 0f       	add	r18, r18
    1b06:	33 1f       	adc	r19, r19
    1b08:	22 0f       	add	r18, r18
    1b0a:	33 1f       	adc	r19, r19
    1b0c:	82 0f       	add	r24, r18
    1b0e:	93 1f       	adc	r25, r19
    1b10:	84 52       	subi	r24, 0x24	; 36
    1b12:	97 4f       	sbci	r25, 0xF7	; 247
    1b14:	b1 dc       	rcall	.-1694   	; 0x1478 <vListInsertEnd>
    1b16:	0f 90       	pop	r0
    1b18:	0f be       	out	0x3f, r0	; 63
    1b1a:	f1 e0       	ldi	r31, 0x01	; 1
    1b1c:	f9 83       	std	Y+1, r31	; 0x01
    1b1e:	02 c0       	rjmp	.+4      	; 0x1b24 <xTaskGenericCreate+0x124>
    1b20:	8f ef       	ldi	r24, 0xFF	; 255
    1b22:	89 83       	std	Y+1, r24	; 0x01
    1b24:	e9 81       	ldd	r30, Y+1	; 0x01
    1b26:	e1 30       	cpi	r30, 0x01	; 1
    1b28:	61 f4       	brne	.+24     	; 0x1b42 <xTaskGenericCreate+0x142>
    1b2a:	80 91 b7 08 	lds	r24, 0x08B7	; 0x8008b7 <xSchedulerRunning>
    1b2e:	88 23       	and	r24, r24
    1b30:	41 f0       	breq	.+16     	; 0x1b42 <xTaskGenericCreate+0x142>
    1b32:	e0 91 e5 08 	lds	r30, 0x08E5	; 0x8008e5 <pxCurrentTCB>
    1b36:	f0 91 e6 08 	lds	r31, 0x08E6	; 0x8008e6 <pxCurrentTCB+0x1>
    1b3a:	86 89       	ldd	r24, Z+22	; 0x16
    1b3c:	87 15       	cp	r24, r7
    1b3e:	08 f4       	brcc	.+2      	; 0x1b42 <xTaskGenericCreate+0x142>
    1b40:	c6 dd       	rcall	.-1140   	; 0x16ce <vPortYield>
    1b42:	89 81       	ldd	r24, Y+1	; 0x01
    1b44:	0f 90       	pop	r0
    1b46:	0f 90       	pop	r0
    1b48:	0f 90       	pop	r0
    1b4a:	0f 90       	pop	r0
    1b4c:	df 91       	pop	r29
    1b4e:	cf 91       	pop	r28
    1b50:	1f 91       	pop	r17
    1b52:	0f 91       	pop	r16
    1b54:	ff 90       	pop	r15
    1b56:	ef 90       	pop	r14
    1b58:	df 90       	pop	r13
    1b5a:	cf 90       	pop	r12
    1b5c:	bf 90       	pop	r11
    1b5e:	af 90       	pop	r10
    1b60:	9f 90       	pop	r9
    1b62:	8f 90       	pop	r8
    1b64:	7f 90       	pop	r7
    1b66:	5f 90       	pop	r5
    1b68:	4f 90       	pop	r4
    1b6a:	3f 90       	pop	r3
    1b6c:	2f 90       	pop	r2
    1b6e:	08 95       	ret

00001b70 <vTaskStartScheduler>:
    1b70:	af 92       	push	r10
    1b72:	bf 92       	push	r11
    1b74:	cf 92       	push	r12
    1b76:	df 92       	push	r13
    1b78:	ef 92       	push	r14
    1b7a:	ff 92       	push	r15
    1b7c:	0f 93       	push	r16
    1b7e:	a1 2c       	mov	r10, r1
    1b80:	b1 2c       	mov	r11, r1
    1b82:	c1 2c       	mov	r12, r1
    1b84:	d1 2c       	mov	r13, r1
    1b86:	e1 2c       	mov	r14, r1
    1b88:	f1 2c       	mov	r15, r1
    1b8a:	00 e0       	ldi	r16, 0x00	; 0
    1b8c:	20 e0       	ldi	r18, 0x00	; 0
    1b8e:	30 e0       	ldi	r19, 0x00	; 0
    1b90:	45 e5       	ldi	r20, 0x55	; 85
    1b92:	50 e0       	ldi	r21, 0x00	; 0
    1b94:	67 ec       	ldi	r22, 0xC7	; 199
    1b96:	72 e0       	ldi	r23, 0x02	; 2
    1b98:	8f e4       	ldi	r24, 0x4F	; 79
    1b9a:	9c e0       	ldi	r25, 0x0C	; 12
    1b9c:	31 df       	rcall	.-414    	; 0x1a00 <xTaskGenericCreate>
    1b9e:	81 30       	cpi	r24, 0x01	; 1
    1ba0:	41 f4       	brne	.+16     	; 0x1bb2 <vTaskStartScheduler+0x42>
    1ba2:	f8 94       	cli
    1ba4:	80 93 b7 08 	sts	0x08B7, r24	; 0x8008b7 <xSchedulerRunning>
    1ba8:	10 92 bb 08 	sts	0x08BB, r1	; 0x8008bb <xTickCount+0x1>
    1bac:	10 92 ba 08 	sts	0x08BA, r1	; 0x8008ba <xTickCount>
    1bb0:	5c dd       	rcall	.-1352   	; 0x166a <xPortStartScheduler>
    1bb2:	0f 91       	pop	r16
    1bb4:	ff 90       	pop	r15
    1bb6:	ef 90       	pop	r14
    1bb8:	df 90       	pop	r13
    1bba:	cf 90       	pop	r12
    1bbc:	bf 90       	pop	r11
    1bbe:	af 90       	pop	r10
    1bc0:	08 95       	ret

00001bc2 <vTaskSuspendAll>:
    1bc2:	80 91 b6 08 	lds	r24, 0x08B6	; 0x8008b6 <uxSchedulerSuspended>
    1bc6:	8f 5f       	subi	r24, 0xFF	; 255
    1bc8:	80 93 b6 08 	sts	0x08B6, r24	; 0x8008b6 <uxSchedulerSuspended>
    1bcc:	08 95       	ret

00001bce <vTaskIncrementTick>:
    1bce:	0f 93       	push	r16
    1bd0:	1f 93       	push	r17
    1bd2:	cf 93       	push	r28
    1bd4:	df 93       	push	r29
    1bd6:	80 91 b6 08 	lds	r24, 0x08B6	; 0x8008b6 <uxSchedulerSuspended>
    1bda:	81 11       	cpse	r24, r1
    1bdc:	95 c0       	rjmp	.+298    	; 0x1d08 <vTaskIncrementTick+0x13a>
    1bde:	80 91 ba 08 	lds	r24, 0x08BA	; 0x8008ba <xTickCount>
    1be2:	90 91 bb 08 	lds	r25, 0x08BB	; 0x8008bb <xTickCount+0x1>
    1be6:	01 96       	adiw	r24, 0x01	; 1
    1be8:	90 93 bb 08 	sts	0x08BB, r25	; 0x8008bb <xTickCount+0x1>
    1bec:	80 93 ba 08 	sts	0x08BA, r24	; 0x8008ba <xTickCount>
    1bf0:	80 91 ba 08 	lds	r24, 0x08BA	; 0x8008ba <xTickCount>
    1bf4:	90 91 bb 08 	lds	r25, 0x08BB	; 0x8008bb <xTickCount+0x1>
    1bf8:	89 2b       	or	r24, r25
    1bfa:	99 f5       	brne	.+102    	; 0x1c62 <vTaskIncrementTick+0x94>
    1bfc:	80 91 c8 08 	lds	r24, 0x08C8	; 0x8008c8 <pxDelayedTaskList>
    1c00:	90 91 c9 08 	lds	r25, 0x08C9	; 0x8008c9 <pxDelayedTaskList+0x1>
    1c04:	20 91 c6 08 	lds	r18, 0x08C6	; 0x8008c6 <pxOverflowDelayedTaskList>
    1c08:	30 91 c7 08 	lds	r19, 0x08C7	; 0x8008c7 <pxOverflowDelayedTaskList+0x1>
    1c0c:	30 93 c9 08 	sts	0x08C9, r19	; 0x8008c9 <pxDelayedTaskList+0x1>
    1c10:	20 93 c8 08 	sts	0x08C8, r18	; 0x8008c8 <pxDelayedTaskList>
    1c14:	90 93 c7 08 	sts	0x08C7, r25	; 0x8008c7 <pxOverflowDelayedTaskList+0x1>
    1c18:	80 93 c6 08 	sts	0x08C6, r24	; 0x8008c6 <pxOverflowDelayedTaskList>
    1c1c:	80 91 b3 08 	lds	r24, 0x08B3	; 0x8008b3 <xNumOfOverflows>
    1c20:	8f 5f       	subi	r24, 0xFF	; 255
    1c22:	80 93 b3 08 	sts	0x08B3, r24	; 0x8008b3 <xNumOfOverflows>
    1c26:	e0 91 c8 08 	lds	r30, 0x08C8	; 0x8008c8 <pxDelayedTaskList>
    1c2a:	f0 91 c9 08 	lds	r31, 0x08C9	; 0x8008c9 <pxDelayedTaskList+0x1>
    1c2e:	80 81       	ld	r24, Z
    1c30:	81 11       	cpse	r24, r1
    1c32:	07 c0       	rjmp	.+14     	; 0x1c42 <vTaskIncrementTick+0x74>
    1c34:	8f ef       	ldi	r24, 0xFF	; 255
    1c36:	9f ef       	ldi	r25, 0xFF	; 255
    1c38:	90 93 0c 02 	sts	0x020C, r25	; 0x80020c <xNextTaskUnblockTime+0x1>
    1c3c:	80 93 0b 02 	sts	0x020B, r24	; 0x80020b <xNextTaskUnblockTime>
    1c40:	10 c0       	rjmp	.+32     	; 0x1c62 <vTaskIncrementTick+0x94>
    1c42:	e0 91 c8 08 	lds	r30, 0x08C8	; 0x8008c8 <pxDelayedTaskList>
    1c46:	f0 91 c9 08 	lds	r31, 0x08C9	; 0x8008c9 <pxDelayedTaskList+0x1>
    1c4a:	05 80       	ldd	r0, Z+5	; 0x05
    1c4c:	f6 81       	ldd	r31, Z+6	; 0x06
    1c4e:	e0 2d       	mov	r30, r0
    1c50:	06 80       	ldd	r0, Z+6	; 0x06
    1c52:	f7 81       	ldd	r31, Z+7	; 0x07
    1c54:	e0 2d       	mov	r30, r0
    1c56:	82 81       	ldd	r24, Z+2	; 0x02
    1c58:	93 81       	ldd	r25, Z+3	; 0x03
    1c5a:	90 93 0c 02 	sts	0x020C, r25	; 0x80020c <xNextTaskUnblockTime+0x1>
    1c5e:	80 93 0b 02 	sts	0x020B, r24	; 0x80020b <xNextTaskUnblockTime>
    1c62:	20 91 ba 08 	lds	r18, 0x08BA	; 0x8008ba <xTickCount>
    1c66:	30 91 bb 08 	lds	r19, 0x08BB	; 0x8008bb <xTickCount+0x1>
    1c6a:	80 91 0b 02 	lds	r24, 0x020B	; 0x80020b <xNextTaskUnblockTime>
    1c6e:	90 91 0c 02 	lds	r25, 0x020C	; 0x80020c <xNextTaskUnblockTime+0x1>
    1c72:	28 17       	cp	r18, r24
    1c74:	39 07       	cpc	r19, r25
    1c76:	08 f4       	brcc	.+2      	; 0x1c7a <vTaskIncrementTick+0xac>
    1c78:	4c c0       	rjmp	.+152    	; 0x1d12 <vTaskIncrementTick+0x144>
    1c7a:	e0 91 c8 08 	lds	r30, 0x08C8	; 0x8008c8 <pxDelayedTaskList>
    1c7e:	f0 91 c9 08 	lds	r31, 0x08C9	; 0x8008c9 <pxDelayedTaskList+0x1>
    1c82:	80 81       	ld	r24, Z
    1c84:	81 11       	cpse	r24, r1
    1c86:	07 c0       	rjmp	.+14     	; 0x1c96 <vTaskIncrementTick+0xc8>
    1c88:	8f ef       	ldi	r24, 0xFF	; 255
    1c8a:	9f ef       	ldi	r25, 0xFF	; 255
    1c8c:	90 93 0c 02 	sts	0x020C, r25	; 0x80020c <xNextTaskUnblockTime+0x1>
    1c90:	80 93 0b 02 	sts	0x020B, r24	; 0x80020b <xNextTaskUnblockTime>
    1c94:	3e c0       	rjmp	.+124    	; 0x1d12 <vTaskIncrementTick+0x144>
    1c96:	e0 91 c8 08 	lds	r30, 0x08C8	; 0x8008c8 <pxDelayedTaskList>
    1c9a:	f0 91 c9 08 	lds	r31, 0x08C9	; 0x8008c9 <pxDelayedTaskList+0x1>
    1c9e:	05 80       	ldd	r0, Z+5	; 0x05
    1ca0:	f6 81       	ldd	r31, Z+6	; 0x06
    1ca2:	e0 2d       	mov	r30, r0
    1ca4:	c6 81       	ldd	r28, Z+6	; 0x06
    1ca6:	d7 81       	ldd	r29, Z+7	; 0x07
    1ca8:	8a 81       	ldd	r24, Y+2	; 0x02
    1caa:	9b 81       	ldd	r25, Y+3	; 0x03
    1cac:	20 91 ba 08 	lds	r18, 0x08BA	; 0x8008ba <xTickCount>
    1cb0:	30 91 bb 08 	lds	r19, 0x08BB	; 0x8008bb <xTickCount+0x1>
    1cb4:	28 17       	cp	r18, r24
    1cb6:	39 07       	cpc	r19, r25
    1cb8:	28 f4       	brcc	.+10     	; 0x1cc4 <vTaskIncrementTick+0xf6>
    1cba:	90 93 0c 02 	sts	0x020C, r25	; 0x80020c <xNextTaskUnblockTime+0x1>
    1cbe:	80 93 0b 02 	sts	0x020B, r24	; 0x80020b <xNextTaskUnblockTime>
    1cc2:	27 c0       	rjmp	.+78     	; 0x1d12 <vTaskIncrementTick+0x144>
    1cc4:	8e 01       	movw	r16, r28
    1cc6:	0e 5f       	subi	r16, 0xFE	; 254
    1cc8:	1f 4f       	sbci	r17, 0xFF	; 255
    1cca:	c8 01       	movw	r24, r16
    1ccc:	2d dc       	rcall	.-1958   	; 0x1528 <vListRemove>
    1cce:	8c 89       	ldd	r24, Y+20	; 0x14
    1cd0:	9d 89       	ldd	r25, Y+21	; 0x15
    1cd2:	89 2b       	or	r24, r25
    1cd4:	19 f0       	breq	.+6      	; 0x1cdc <vTaskIncrementTick+0x10e>
    1cd6:	ce 01       	movw	r24, r28
    1cd8:	0c 96       	adiw	r24, 0x0c	; 12
    1cda:	26 dc       	rcall	.-1972   	; 0x1528 <vListRemove>
    1cdc:	8e 89       	ldd	r24, Y+22	; 0x16
    1cde:	90 91 b8 08 	lds	r25, 0x08B8	; 0x8008b8 <uxTopReadyPriority>
    1ce2:	98 17       	cp	r25, r24
    1ce4:	10 f4       	brcc	.+4      	; 0x1cea <vTaskIncrementTick+0x11c>
    1ce6:	80 93 b8 08 	sts	0x08B8, r24	; 0x8008b8 <uxTopReadyPriority>
    1cea:	90 e0       	ldi	r25, 0x00	; 0
    1cec:	9c 01       	movw	r18, r24
    1cee:	22 0f       	add	r18, r18
    1cf0:	33 1f       	adc	r19, r19
    1cf2:	22 0f       	add	r18, r18
    1cf4:	33 1f       	adc	r19, r19
    1cf6:	22 0f       	add	r18, r18
    1cf8:	33 1f       	adc	r19, r19
    1cfa:	82 0f       	add	r24, r18
    1cfc:	93 1f       	adc	r25, r19
    1cfe:	b8 01       	movw	r22, r16
    1d00:	84 52       	subi	r24, 0x24	; 36
    1d02:	97 4f       	sbci	r25, 0xF7	; 247
    1d04:	b9 db       	rcall	.-2190   	; 0x1478 <vListInsertEnd>
    1d06:	b9 cf       	rjmp	.-142    	; 0x1c7a <vTaskIncrementTick+0xac>
    1d08:	80 91 b5 08 	lds	r24, 0x08B5	; 0x8008b5 <uxMissedTicks>
    1d0c:	8f 5f       	subi	r24, 0xFF	; 255
    1d0e:	80 93 b5 08 	sts	0x08B5, r24	; 0x8008b5 <uxMissedTicks>
    1d12:	df 91       	pop	r29
    1d14:	cf 91       	pop	r28
    1d16:	1f 91       	pop	r17
    1d18:	0f 91       	pop	r16
    1d1a:	08 95       	ret

00001d1c <xTaskResumeAll>:
    1d1c:	ff 92       	push	r15
    1d1e:	0f 93       	push	r16
    1d20:	1f 93       	push	r17
    1d22:	cf 93       	push	r28
    1d24:	df 93       	push	r29
    1d26:	0f b6       	in	r0, 0x3f	; 63
    1d28:	f8 94       	cli
    1d2a:	0f 92       	push	r0
    1d2c:	80 91 b6 08 	lds	r24, 0x08B6	; 0x8008b6 <uxSchedulerSuspended>
    1d30:	81 50       	subi	r24, 0x01	; 1
    1d32:	80 93 b6 08 	sts	0x08B6, r24	; 0x8008b6 <uxSchedulerSuspended>
    1d36:	80 91 b6 08 	lds	r24, 0x08B6	; 0x8008b6 <uxSchedulerSuspended>
    1d3a:	81 11       	cpse	r24, r1
    1d3c:	55 c0       	rjmp	.+170    	; 0x1de8 <xTaskResumeAll+0xcc>
    1d3e:	80 91 bc 08 	lds	r24, 0x08BC	; 0x8008bc <uxCurrentNumberOfTasks>
    1d42:	81 11       	cpse	r24, r1
    1d44:	2f c0       	rjmp	.+94     	; 0x1da4 <xTaskResumeAll+0x88>
    1d46:	53 c0       	rjmp	.+166    	; 0x1dee <xTaskResumeAll+0xd2>
    1d48:	e0 91 c2 08 	lds	r30, 0x08C2	; 0x8008c2 <xPendingReadyList+0x5>
    1d4c:	f0 91 c3 08 	lds	r31, 0x08C3	; 0x8008c3 <xPendingReadyList+0x6>
    1d50:	c6 81       	ldd	r28, Z+6	; 0x06
    1d52:	d7 81       	ldd	r29, Z+7	; 0x07
    1d54:	ce 01       	movw	r24, r28
    1d56:	0c 96       	adiw	r24, 0x0c	; 12
    1d58:	e7 db       	rcall	.-2098   	; 0x1528 <vListRemove>
    1d5a:	8e 01       	movw	r16, r28
    1d5c:	0e 5f       	subi	r16, 0xFE	; 254
    1d5e:	1f 4f       	sbci	r17, 0xFF	; 255
    1d60:	c8 01       	movw	r24, r16
    1d62:	e2 db       	rcall	.-2108   	; 0x1528 <vListRemove>
    1d64:	8e 89       	ldd	r24, Y+22	; 0x16
    1d66:	90 91 b8 08 	lds	r25, 0x08B8	; 0x8008b8 <uxTopReadyPriority>
    1d6a:	98 17       	cp	r25, r24
    1d6c:	10 f4       	brcc	.+4      	; 0x1d72 <xTaskResumeAll+0x56>
    1d6e:	80 93 b8 08 	sts	0x08B8, r24	; 0x8008b8 <uxTopReadyPriority>
    1d72:	90 e0       	ldi	r25, 0x00	; 0
    1d74:	9c 01       	movw	r18, r24
    1d76:	22 0f       	add	r18, r18
    1d78:	33 1f       	adc	r19, r19
    1d7a:	22 0f       	add	r18, r18
    1d7c:	33 1f       	adc	r19, r19
    1d7e:	22 0f       	add	r18, r18
    1d80:	33 1f       	adc	r19, r19
    1d82:	82 0f       	add	r24, r18
    1d84:	93 1f       	adc	r25, r19
    1d86:	b8 01       	movw	r22, r16
    1d88:	84 52       	subi	r24, 0x24	; 36
    1d8a:	97 4f       	sbci	r25, 0xF7	; 247
    1d8c:	75 db       	rcall	.-2326   	; 0x1478 <vListInsertEnd>
    1d8e:	9e 89       	ldd	r25, Y+22	; 0x16
    1d90:	e0 91 e5 08 	lds	r30, 0x08E5	; 0x8008e5 <pxCurrentTCB>
    1d94:	f0 91 e6 08 	lds	r31, 0x08E6	; 0x8008e6 <pxCurrentTCB+0x1>
    1d98:	86 89       	ldd	r24, Z+22	; 0x16
    1d9a:	98 17       	cp	r25, r24
    1d9c:	20 f0       	brcs	.+8      	; 0x1da6 <xTaskResumeAll+0x8a>
    1d9e:	ff 24       	eor	r15, r15
    1da0:	f3 94       	inc	r15
    1da2:	01 c0       	rjmp	.+2      	; 0x1da6 <xTaskResumeAll+0x8a>
    1da4:	f1 2c       	mov	r15, r1
    1da6:	80 91 bd 08 	lds	r24, 0x08BD	; 0x8008bd <xPendingReadyList>
    1daa:	81 11       	cpse	r24, r1
    1dac:	cd cf       	rjmp	.-102    	; 0x1d48 <xTaskResumeAll+0x2c>
    1dae:	80 91 b5 08 	lds	r24, 0x08B5	; 0x8008b5 <uxMissedTicks>
    1db2:	81 11       	cpse	r24, r1
    1db4:	07 c0       	rjmp	.+14     	; 0x1dc4 <xTaskResumeAll+0xa8>
    1db6:	0c c0       	rjmp	.+24     	; 0x1dd0 <xTaskResumeAll+0xb4>
    1db8:	0a df       	rcall	.-492    	; 0x1bce <vTaskIncrementTick>
    1dba:	80 91 b5 08 	lds	r24, 0x08B5	; 0x8008b5 <uxMissedTicks>
    1dbe:	81 50       	subi	r24, 0x01	; 1
    1dc0:	80 93 b5 08 	sts	0x08B5, r24	; 0x8008b5 <uxMissedTicks>
    1dc4:	80 91 b5 08 	lds	r24, 0x08B5	; 0x8008b5 <uxMissedTicks>
    1dc8:	81 11       	cpse	r24, r1
    1dca:	f6 cf       	rjmp	.-20     	; 0x1db8 <xTaskResumeAll+0x9c>
    1dcc:	ff 24       	eor	r15, r15
    1dce:	f3 94       	inc	r15
    1dd0:	81 e0       	ldi	r24, 0x01	; 1
    1dd2:	f8 16       	cp	r15, r24
    1dd4:	21 f0       	breq	.+8      	; 0x1dde <xTaskResumeAll+0xc2>
    1dd6:	80 91 b4 08 	lds	r24, 0x08B4	; 0x8008b4 <xMissedYield>
    1dda:	81 30       	cpi	r24, 0x01	; 1
    1ddc:	39 f4       	brne	.+14     	; 0x1dec <xTaskResumeAll+0xd0>
    1dde:	10 92 b4 08 	sts	0x08B4, r1	; 0x8008b4 <xMissedYield>
    1de2:	75 dc       	rcall	.-1814   	; 0x16ce <vPortYield>
    1de4:	81 e0       	ldi	r24, 0x01	; 1
    1de6:	03 c0       	rjmp	.+6      	; 0x1dee <xTaskResumeAll+0xd2>
    1de8:	80 e0       	ldi	r24, 0x00	; 0
    1dea:	01 c0       	rjmp	.+2      	; 0x1dee <xTaskResumeAll+0xd2>
    1dec:	80 e0       	ldi	r24, 0x00	; 0
    1dee:	0f 90       	pop	r0
    1df0:	0f be       	out	0x3f, r0	; 63
    1df2:	df 91       	pop	r29
    1df4:	cf 91       	pop	r28
    1df6:	1f 91       	pop	r17
    1df8:	0f 91       	pop	r16
    1dfa:	ff 90       	pop	r15
    1dfc:	08 95       	ret

00001dfe <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    1dfe:	cf 93       	push	r28
    1e00:	df 93       	push	r29
    1e02:	ec 01       	movw	r28, r24
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    1e04:	89 2b       	or	r24, r25
    1e06:	89 f0       	breq	.+34     	; 0x1e2a <vTaskDelay+0x2c>
		{
			vTaskSuspendAll();
    1e08:	dc de       	rcall	.-584    	; 0x1bc2 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    1e0a:	80 91 ba 08 	lds	r24, 0x08BA	; 0x8008ba <xTickCount>
    1e0e:	90 91 bb 08 	lds	r25, 0x08BB	; 0x8008bb <xTickCount+0x1>
    1e12:	c8 0f       	add	r28, r24
    1e14:	d9 1f       	adc	r29, r25

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1e16:	80 91 e5 08 	lds	r24, 0x08E5	; 0x8008e5 <pxCurrentTCB>
    1e1a:	90 91 e6 08 	lds	r25, 0x08E6	; 0x8008e6 <pxCurrentTCB+0x1>
    1e1e:	02 96       	adiw	r24, 0x02	; 2
    1e20:	83 db       	rcall	.-2298   	; 0x1528 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    1e22:	ce 01       	movw	r24, r28
    1e24:	b8 dd       	rcall	.-1168   	; 0x1996 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    1e26:	7a df       	rcall	.-268    	; 0x1d1c <xTaskResumeAll>
    1e28:	01 c0       	rjmp	.+2      	; 0x1e2c <vTaskDelay+0x2e>
#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    1e2a:	80 e0       	ldi	r24, 0x00	; 0
			xAlreadyYielded = xTaskResumeAll();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    1e2c:	81 11       	cpse	r24, r1
    1e2e:	01 c0       	rjmp	.+2      	; 0x1e32 <vTaskDelay+0x34>
		{
			portYIELD_WITHIN_API();
    1e30:	4e dc       	rcall	.-1892   	; 0x16ce <vPortYield>
    1e32:	df 91       	pop	r29
		}
	}
    1e34:	cf 91       	pop	r28
    1e36:	08 95       	ret

00001e38 <vTaskSwitchContext>:
    1e38:	80 91 b6 08 	lds	r24, 0x08B6	; 0x8008b6 <uxSchedulerSuspended>
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    1e3c:	88 23       	and	r24, r24
    1e3e:	49 f0       	breq	.+18     	; 0x1e52 <vTaskSwitchContext+0x1a>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    1e40:	81 e0       	ldi	r24, 0x01	; 1
    1e42:	80 93 b4 08 	sts	0x08B4, r24	; 0x8008b4 <xMissedYield>
    1e46:	08 95       	ret
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    1e48:	80 91 b8 08 	lds	r24, 0x08B8	; 0x8008b8 <uxTopReadyPriority>
    1e4c:	81 50       	subi	r24, 0x01	; 1
    1e4e:	80 93 b8 08 	sts	0x08B8, r24	; 0x8008b8 <uxTopReadyPriority>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    1e52:	80 91 b8 08 	lds	r24, 0x08B8	; 0x8008b8 <uxTopReadyPriority>
    1e56:	90 e0       	ldi	r25, 0x00	; 0
    1e58:	fc 01       	movw	r30, r24
    1e5a:	ee 0f       	add	r30, r30
    1e5c:	ff 1f       	adc	r31, r31
    1e5e:	ee 0f       	add	r30, r30
    1e60:	ff 1f       	adc	r31, r31
    1e62:	ee 0f       	add	r30, r30
    1e64:	ff 1f       	adc	r31, r31
    1e66:	8e 0f       	add	r24, r30
    1e68:	9f 1f       	adc	r25, r31
    1e6a:	fc 01       	movw	r30, r24
    1e6c:	e4 52       	subi	r30, 0x24	; 36
    1e6e:	f7 4f       	sbci	r31, 0xF7	; 247
    1e70:	80 81       	ld	r24, Z
    1e72:	88 23       	and	r24, r24
    1e74:	49 f3       	breq	.-46     	; 0x1e48 <vTaskSwitchContext+0x10>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    1e76:	80 91 b8 08 	lds	r24, 0x08B8	; 0x8008b8 <uxTopReadyPriority>
    1e7a:	90 e0       	ldi	r25, 0x00	; 0
    1e7c:	9c 01       	movw	r18, r24
    1e7e:	22 0f       	add	r18, r18
    1e80:	33 1f       	adc	r19, r19
    1e82:	22 0f       	add	r18, r18
    1e84:	33 1f       	adc	r19, r19
    1e86:	22 0f       	add	r18, r18
    1e88:	33 1f       	adc	r19, r19
    1e8a:	28 0f       	add	r18, r24
    1e8c:	39 1f       	adc	r19, r25
    1e8e:	d9 01       	movw	r26, r18
    1e90:	a4 52       	subi	r26, 0x24	; 36
    1e92:	b7 4f       	sbci	r27, 0xF7	; 247
    1e94:	11 96       	adiw	r26, 0x01	; 1
    1e96:	ed 91       	ld	r30, X+
    1e98:	fc 91       	ld	r31, X
    1e9a:	12 97       	sbiw	r26, 0x02	; 2
    1e9c:	02 80       	ldd	r0, Z+2	; 0x02
    1e9e:	f3 81       	ldd	r31, Z+3	; 0x03
    1ea0:	e0 2d       	mov	r30, r0
    1ea2:	12 96       	adiw	r26, 0x02	; 2
    1ea4:	fc 93       	st	X, r31
    1ea6:	ee 93       	st	-X, r30
    1ea8:	11 97       	sbiw	r26, 0x01	; 1
    1eaa:	21 52       	subi	r18, 0x21	; 33
    1eac:	37 4f       	sbci	r19, 0xF7	; 247
    1eae:	e2 17       	cp	r30, r18
    1eb0:	f3 07       	cpc	r31, r19
    1eb2:	29 f4       	brne	.+10     	; 0x1ebe <vTaskSwitchContext+0x86>
    1eb4:	22 81       	ldd	r18, Z+2	; 0x02
    1eb6:	33 81       	ldd	r19, Z+3	; 0x03
    1eb8:	fd 01       	movw	r30, r26
    1eba:	32 83       	std	Z+2, r19	; 0x02
    1ebc:	21 83       	std	Z+1, r18	; 0x01
    1ebe:	fc 01       	movw	r30, r24
    1ec0:	ee 0f       	add	r30, r30
    1ec2:	ff 1f       	adc	r31, r31
    1ec4:	ee 0f       	add	r30, r30
    1ec6:	ff 1f       	adc	r31, r31
    1ec8:	ee 0f       	add	r30, r30
    1eca:	ff 1f       	adc	r31, r31
    1ecc:	8e 0f       	add	r24, r30
    1ece:	9f 1f       	adc	r25, r31
    1ed0:	fc 01       	movw	r30, r24
    1ed2:	e4 52       	subi	r30, 0x24	; 36
    1ed4:	f7 4f       	sbci	r31, 0xF7	; 247
    1ed6:	01 80       	ldd	r0, Z+1	; 0x01
    1ed8:	f2 81       	ldd	r31, Z+2	; 0x02
    1eda:	e0 2d       	mov	r30, r0
    1edc:	86 81       	ldd	r24, Z+6	; 0x06
    1ede:	97 81       	ldd	r25, Z+7	; 0x07
    1ee0:	90 93 e6 08 	sts	0x08E6, r25	; 0x8008e6 <pxCurrentTCB+0x1>
    1ee4:	80 93 e5 08 	sts	0x08E5, r24	; 0x8008e5 <pxCurrentTCB>
    1ee8:	08 95       	ret

00001eea <_Z8InitUARTmhc>:
  Returns value <> 0 (TRUE), if the UART HAS received a new character.
*************************************************************************/
unsigned char CharReady()
{
   return UCSR0A & (1<<7);
}
    1eea:	0f 93       	push	r16
    1eec:	1f 93       	push	r17
    1eee:	52 2f       	mov	r21, r18
    1ef0:	8b 01       	movw	r16, r22
    1ef2:	9c 01       	movw	r18, r24
    1ef4:	0c 52       	subi	r16, 0x2C	; 44
    1ef6:	11 40       	sbci	r17, 0x01	; 1
    1ef8:	21 09       	sbc	r18, r1
    1efa:	31 09       	sbc	r19, r1
    1efc:	05 3d       	cpi	r16, 0xD5	; 213
    1efe:	10 4c       	sbci	r17, 0xC0	; 192
    1f00:	21 40       	sbci	r18, 0x01	; 1
    1f02:	31 05       	cpc	r19, r1
    1f04:	e0 f5       	brcc	.+120    	; 0x1f7e <_Z8InitUARTmhc+0x94>
    1f06:	45 30       	cpi	r20, 0x05	; 5
    1f08:	d0 f1       	brcs	.+116    	; 0x1f7e <_Z8InitUARTmhc+0x94>
    1f0a:	49 30       	cpi	r20, 0x09	; 9
    1f0c:	c0 f5       	brcc	.+112    	; 0x1f7e <_Z8InitUARTmhc+0x94>
    1f0e:	20 e2       	ldi	r18, 0x20	; 32
    1f10:	20 93 c0 00 	sts	0x00C0, r18	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7000c0>
    1f14:	28 e1       	ldi	r18, 0x18	; 24
    1f16:	20 93 c1 00 	sts	0x00C1, r18	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7000c1>
    1f1a:	45 50       	subi	r20, 0x05	; 5
    1f1c:	44 0f       	add	r20, r20
    1f1e:	40 93 c2 00 	sts	0x00C2, r20	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7000c2>
    1f22:	55 34       	cpi	r21, 0x45	; 69
    1f24:	31 f4       	brne	.+12     	; 0x1f32 <_Z8InitUARTmhc+0x48>
    1f26:	e2 ec       	ldi	r30, 0xC2	; 194
    1f28:	f0 e0       	ldi	r31, 0x00	; 0
    1f2a:	20 81       	ld	r18, Z
    1f2c:	20 62       	ori	r18, 0x20	; 32
    1f2e:	20 83       	st	Z, r18
    1f30:	07 c0       	rjmp	.+14     	; 0x1f40 <_Z8InitUARTmhc+0x56>
    1f32:	5f 34       	cpi	r21, 0x4F	; 79
    1f34:	29 f4       	brne	.+10     	; 0x1f40 <_Z8InitUARTmhc+0x56>
    1f36:	e2 ec       	ldi	r30, 0xC2	; 194
    1f38:	f0 e0       	ldi	r31, 0x00	; 0
    1f3a:	20 81       	ld	r18, Z
    1f3c:	20 63       	ori	r18, 0x30	; 48
    1f3e:	20 83       	st	Z, r18
    1f40:	dc 01       	movw	r26, r24
    1f42:	cb 01       	movw	r24, r22
    1f44:	88 0f       	add	r24, r24
    1f46:	99 1f       	adc	r25, r25
    1f48:	aa 1f       	adc	r26, r26
    1f4a:	bb 1f       	adc	r27, r27
    1f4c:	88 0f       	add	r24, r24
    1f4e:	99 1f       	adc	r25, r25
    1f50:	aa 1f       	adc	r26, r26
    1f52:	bb 1f       	adc	r27, r27
    1f54:	9c 01       	movw	r18, r24
    1f56:	ad 01       	movw	r20, r26
    1f58:	22 0f       	add	r18, r18
    1f5a:	33 1f       	adc	r19, r19
    1f5c:	44 1f       	adc	r20, r20
    1f5e:	55 1f       	adc	r21, r21
    1f60:	22 0f       	add	r18, r18
    1f62:	33 1f       	adc	r19, r19
    1f64:	44 1f       	adc	r20, r20
    1f66:	55 1f       	adc	r21, r21
    1f68:	60 e0       	ldi	r22, 0x00	; 0
    1f6a:	74 e2       	ldi	r23, 0x24	; 36
    1f6c:	84 ef       	ldi	r24, 0xF4	; 244
    1f6e:	90 e0       	ldi	r25, 0x00	; 0
    1f70:	d1 d1       	rcall	.+930    	; 0x2314 <__udivmodsi4>
    1f72:	21 50       	subi	r18, 0x01	; 1
    1f74:	31 09       	sbc	r19, r1
    1f76:	30 93 c5 00 	sts	0x00C5, r19	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7000c5>
    1f7a:	20 93 c4 00 	sts	0x00C4, r18	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7000c4>
    1f7e:	1f 91       	pop	r17
    1f80:	0f 91       	pop	r16
    1f82:	08 95       	ret

00001f84 <_Z8ReadCharv>:
Then this character is returned.
*************************************************************************/
char ReadChar()
{
  // Wait for new character received
  while ( (UCSR0A & (1<<7)) == 0 )
    1f84:	80 91 c0 00 	lds	r24, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7000c0>
    1f88:	88 23       	and	r24, r24
    1f8a:	e4 f7       	brge	.-8      	; 0x1f84 <_Z8ReadCharv>
  {}                        
  // Then return it
  return UDR0;
    1f8c:	80 91 c6 00 	lds	r24, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7000c6>
}
    1f90:	08 95       	ret

00001f92 <_Z8SendCharc>:
	Tegn : Character for sending. 
*************************************************************************/
void SendChar(char Tegn)
{
  // Wait for transmitter register empty (ready for new character)
  while ( (UCSR0A & (1<<5)) == 0 )
    1f92:	90 91 c0 00 	lds	r25, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7000c0>
    1f96:	95 ff       	sbrs	r25, 5
    1f98:	fc cf       	rjmp	.-8      	; 0x1f92 <_Z8SendCharc>
  {}
  // Then send the character
  UDR0 = Tegn;
    1f9a:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7000c6>
    1f9e:	08 95       	ret

00001fa0 <_Z10SendStringPc>:
Sends 0 terminated string.
Parameter:
   Streng: Pointer to the string. 
*************************************************************************/
void SendString(char* Streng)
{
    1fa0:	cf 93       	push	r28
    1fa2:	df 93       	push	r29
    1fa4:	ec 01       	movw	r28, r24
  // Repeat until zero-termination
  while (*Streng != 0)
    1fa6:	88 81       	ld	r24, Y
    1fa8:	88 23       	and	r24, r24
    1faa:	19 f0       	breq	.+6      	; 0x1fb2 <_Z10SendStringPc+0x12>
  {
    // Send the character pointed to by "Streng"
    SendChar(*Streng);
    1fac:	f2 df       	rcall	.-28     	; 0x1f92 <_Z8SendCharc>
    // Advance the pointer one step
    Streng++;
    1fae:	21 96       	adiw	r28, 0x01	; 1
   Streng: Pointer to the string. 
*************************************************************************/
void SendString(char* Streng)
{
  // Repeat until zero-termination
  while (*Streng != 0)
    1fb0:	fa cf       	rjmp	.-12     	; 0x1fa6 <_Z10SendStringPc+0x6>
    // Send the character pointed to by "Streng"
    SendChar(*Streng);
    // Advance the pointer one step
    Streng++;
  }
}
    1fb2:	df 91       	pop	r29
    1fb4:	cf 91       	pop	r28
    1fb6:	08 95       	ret

00001fb8 <__subsf3>:
    1fb8:	50 58       	subi	r21, 0x80	; 128

00001fba <__addsf3>:
    1fba:	bb 27       	eor	r27, r27
    1fbc:	aa 27       	eor	r26, r26
    1fbe:	0e d0       	rcall	.+28     	; 0x1fdc <__addsf3x>
    1fc0:	08 c1       	rjmp	.+528    	; 0x21d2 <__fp_round>
    1fc2:	f9 d0       	rcall	.+498    	; 0x21b6 <__fp_pscA>
    1fc4:	30 f0       	brcs	.+12     	; 0x1fd2 <__addsf3+0x18>
    1fc6:	fe d0       	rcall	.+508    	; 0x21c4 <__fp_pscB>
    1fc8:	20 f0       	brcs	.+8      	; 0x1fd2 <__addsf3+0x18>
    1fca:	31 f4       	brne	.+12     	; 0x1fd8 <__addsf3+0x1e>
    1fcc:	9f 3f       	cpi	r25, 0xFF	; 255
    1fce:	11 f4       	brne	.+4      	; 0x1fd4 <__addsf3+0x1a>
    1fd0:	1e f4       	brtc	.+6      	; 0x1fd8 <__addsf3+0x1e>
    1fd2:	ee c0       	rjmp	.+476    	; 0x21b0 <__fp_nan>
    1fd4:	0e f4       	brtc	.+2      	; 0x1fd8 <__addsf3+0x1e>
    1fd6:	e0 95       	com	r30
    1fd8:	e7 fb       	bst	r30, 7
    1fda:	e4 c0       	rjmp	.+456    	; 0x21a4 <__fp_inf>

00001fdc <__addsf3x>:
    1fdc:	e9 2f       	mov	r30, r25
    1fde:	0a d1       	rcall	.+532    	; 0x21f4 <__fp_split3>
    1fe0:	80 f3       	brcs	.-32     	; 0x1fc2 <__addsf3+0x8>
    1fe2:	ba 17       	cp	r27, r26
    1fe4:	62 07       	cpc	r22, r18
    1fe6:	73 07       	cpc	r23, r19
    1fe8:	84 07       	cpc	r24, r20
    1fea:	95 07       	cpc	r25, r21
    1fec:	18 f0       	brcs	.+6      	; 0x1ff4 <__addsf3x+0x18>
    1fee:	71 f4       	brne	.+28     	; 0x200c <__addsf3x+0x30>
    1ff0:	9e f5       	brtc	.+102    	; 0x2058 <__addsf3x+0x7c>
    1ff2:	22 c1       	rjmp	.+580    	; 0x2238 <__fp_zero>
    1ff4:	0e f4       	brtc	.+2      	; 0x1ff8 <__addsf3x+0x1c>
    1ff6:	e0 95       	com	r30
    1ff8:	0b 2e       	mov	r0, r27
    1ffa:	ba 2f       	mov	r27, r26
    1ffc:	a0 2d       	mov	r26, r0
    1ffe:	0b 01       	movw	r0, r22
    2000:	b9 01       	movw	r22, r18
    2002:	90 01       	movw	r18, r0
    2004:	0c 01       	movw	r0, r24
    2006:	ca 01       	movw	r24, r20
    2008:	a0 01       	movw	r20, r0
    200a:	11 24       	eor	r1, r1
    200c:	ff 27       	eor	r31, r31
    200e:	59 1b       	sub	r21, r25
    2010:	99 f0       	breq	.+38     	; 0x2038 <__addsf3x+0x5c>
    2012:	59 3f       	cpi	r21, 0xF9	; 249
    2014:	50 f4       	brcc	.+20     	; 0x202a <__addsf3x+0x4e>
    2016:	50 3e       	cpi	r21, 0xE0	; 224
    2018:	68 f1       	brcs	.+90     	; 0x2074 <__addsf3x+0x98>
    201a:	1a 16       	cp	r1, r26
    201c:	f0 40       	sbci	r31, 0x00	; 0
    201e:	a2 2f       	mov	r26, r18
    2020:	23 2f       	mov	r18, r19
    2022:	34 2f       	mov	r19, r20
    2024:	44 27       	eor	r20, r20
    2026:	58 5f       	subi	r21, 0xF8	; 248
    2028:	f3 cf       	rjmp	.-26     	; 0x2010 <__addsf3x+0x34>
    202a:	46 95       	lsr	r20
    202c:	37 95       	ror	r19
    202e:	27 95       	ror	r18
    2030:	a7 95       	ror	r26
    2032:	f0 40       	sbci	r31, 0x00	; 0
    2034:	53 95       	inc	r21
    2036:	c9 f7       	brne	.-14     	; 0x202a <__addsf3x+0x4e>
    2038:	7e f4       	brtc	.+30     	; 0x2058 <__addsf3x+0x7c>
    203a:	1f 16       	cp	r1, r31
    203c:	ba 0b       	sbc	r27, r26
    203e:	62 0b       	sbc	r22, r18
    2040:	73 0b       	sbc	r23, r19
    2042:	84 0b       	sbc	r24, r20
    2044:	ba f0       	brmi	.+46     	; 0x2074 <__addsf3x+0x98>
    2046:	91 50       	subi	r25, 0x01	; 1
    2048:	a1 f0       	breq	.+40     	; 0x2072 <__addsf3x+0x96>
    204a:	ff 0f       	add	r31, r31
    204c:	bb 1f       	adc	r27, r27
    204e:	66 1f       	adc	r22, r22
    2050:	77 1f       	adc	r23, r23
    2052:	88 1f       	adc	r24, r24
    2054:	c2 f7       	brpl	.-16     	; 0x2046 <__addsf3x+0x6a>
    2056:	0e c0       	rjmp	.+28     	; 0x2074 <__addsf3x+0x98>
    2058:	ba 0f       	add	r27, r26
    205a:	62 1f       	adc	r22, r18
    205c:	73 1f       	adc	r23, r19
    205e:	84 1f       	adc	r24, r20
    2060:	48 f4       	brcc	.+18     	; 0x2074 <__addsf3x+0x98>
    2062:	87 95       	ror	r24
    2064:	77 95       	ror	r23
    2066:	67 95       	ror	r22
    2068:	b7 95       	ror	r27
    206a:	f7 95       	ror	r31
    206c:	9e 3f       	cpi	r25, 0xFE	; 254
    206e:	08 f0       	brcs	.+2      	; 0x2072 <__addsf3x+0x96>
    2070:	b3 cf       	rjmp	.-154    	; 0x1fd8 <__addsf3+0x1e>
    2072:	93 95       	inc	r25
    2074:	88 0f       	add	r24, r24
    2076:	08 f0       	brcs	.+2      	; 0x207a <__addsf3x+0x9e>
    2078:	99 27       	eor	r25, r25
    207a:	ee 0f       	add	r30, r30
    207c:	97 95       	ror	r25
    207e:	87 95       	ror	r24
    2080:	08 95       	ret

00002082 <__cmpsf2>:
    2082:	6c d0       	rcall	.+216    	; 0x215c <__fp_cmp>
    2084:	08 f4       	brcc	.+2      	; 0x2088 <__cmpsf2+0x6>
    2086:	81 e0       	ldi	r24, 0x01	; 1
    2088:	08 95       	ret

0000208a <__fixunssfsi>:
    208a:	bc d0       	rcall	.+376    	; 0x2204 <__fp_splitA>
    208c:	88 f0       	brcs	.+34     	; 0x20b0 <__fixunssfsi+0x26>
    208e:	9f 57       	subi	r25, 0x7F	; 127
    2090:	90 f0       	brcs	.+36     	; 0x20b6 <__fixunssfsi+0x2c>
    2092:	b9 2f       	mov	r27, r25
    2094:	99 27       	eor	r25, r25
    2096:	b7 51       	subi	r27, 0x17	; 23
    2098:	a0 f0       	brcs	.+40     	; 0x20c2 <__fixunssfsi+0x38>
    209a:	d1 f0       	breq	.+52     	; 0x20d0 <__fixunssfsi+0x46>
    209c:	66 0f       	add	r22, r22
    209e:	77 1f       	adc	r23, r23
    20a0:	88 1f       	adc	r24, r24
    20a2:	99 1f       	adc	r25, r25
    20a4:	1a f0       	brmi	.+6      	; 0x20ac <__fixunssfsi+0x22>
    20a6:	ba 95       	dec	r27
    20a8:	c9 f7       	brne	.-14     	; 0x209c <__fixunssfsi+0x12>
    20aa:	12 c0       	rjmp	.+36     	; 0x20d0 <__fixunssfsi+0x46>
    20ac:	b1 30       	cpi	r27, 0x01	; 1
    20ae:	81 f0       	breq	.+32     	; 0x20d0 <__fixunssfsi+0x46>
    20b0:	c3 d0       	rcall	.+390    	; 0x2238 <__fp_zero>
    20b2:	b1 e0       	ldi	r27, 0x01	; 1
    20b4:	08 95       	ret
    20b6:	c0 c0       	rjmp	.+384    	; 0x2238 <__fp_zero>
    20b8:	67 2f       	mov	r22, r23
    20ba:	78 2f       	mov	r23, r24
    20bc:	88 27       	eor	r24, r24
    20be:	b8 5f       	subi	r27, 0xF8	; 248
    20c0:	39 f0       	breq	.+14     	; 0x20d0 <__fixunssfsi+0x46>
    20c2:	b9 3f       	cpi	r27, 0xF9	; 249
    20c4:	cc f3       	brlt	.-14     	; 0x20b8 <__fixunssfsi+0x2e>
    20c6:	86 95       	lsr	r24
    20c8:	77 95       	ror	r23
    20ca:	67 95       	ror	r22
    20cc:	b3 95       	inc	r27
    20ce:	d9 f7       	brne	.-10     	; 0x20c6 <__fixunssfsi+0x3c>
    20d0:	3e f4       	brtc	.+14     	; 0x20e0 <__fixunssfsi+0x56>
    20d2:	90 95       	com	r25
    20d4:	80 95       	com	r24
    20d6:	70 95       	com	r23
    20d8:	61 95       	neg	r22
    20da:	7f 4f       	sbci	r23, 0xFF	; 255
    20dc:	8f 4f       	sbci	r24, 0xFF	; 255
    20de:	9f 4f       	sbci	r25, 0xFF	; 255
    20e0:	08 95       	ret

000020e2 <__floatunsisf>:
    20e2:	e8 94       	clt
    20e4:	09 c0       	rjmp	.+18     	; 0x20f8 <__floatsisf+0x12>

000020e6 <__floatsisf>:
    20e6:	97 fb       	bst	r25, 7
    20e8:	3e f4       	brtc	.+14     	; 0x20f8 <__floatsisf+0x12>
    20ea:	90 95       	com	r25
    20ec:	80 95       	com	r24
    20ee:	70 95       	com	r23
    20f0:	61 95       	neg	r22
    20f2:	7f 4f       	sbci	r23, 0xFF	; 255
    20f4:	8f 4f       	sbci	r24, 0xFF	; 255
    20f6:	9f 4f       	sbci	r25, 0xFF	; 255
    20f8:	99 23       	and	r25, r25
    20fa:	a9 f0       	breq	.+42     	; 0x2126 <__floatsisf+0x40>
    20fc:	f9 2f       	mov	r31, r25
    20fe:	96 e9       	ldi	r25, 0x96	; 150
    2100:	bb 27       	eor	r27, r27
    2102:	93 95       	inc	r25
    2104:	f6 95       	lsr	r31
    2106:	87 95       	ror	r24
    2108:	77 95       	ror	r23
    210a:	67 95       	ror	r22
    210c:	b7 95       	ror	r27
    210e:	f1 11       	cpse	r31, r1
    2110:	f8 cf       	rjmp	.-16     	; 0x2102 <__floatsisf+0x1c>
    2112:	fa f4       	brpl	.+62     	; 0x2152 <__floatsisf+0x6c>
    2114:	bb 0f       	add	r27, r27
    2116:	11 f4       	brne	.+4      	; 0x211c <__floatsisf+0x36>
    2118:	60 ff       	sbrs	r22, 0
    211a:	1b c0       	rjmp	.+54     	; 0x2152 <__floatsisf+0x6c>
    211c:	6f 5f       	subi	r22, 0xFF	; 255
    211e:	7f 4f       	sbci	r23, 0xFF	; 255
    2120:	8f 4f       	sbci	r24, 0xFF	; 255
    2122:	9f 4f       	sbci	r25, 0xFF	; 255
    2124:	16 c0       	rjmp	.+44     	; 0x2152 <__floatsisf+0x6c>
    2126:	88 23       	and	r24, r24
    2128:	11 f0       	breq	.+4      	; 0x212e <__floatsisf+0x48>
    212a:	96 e9       	ldi	r25, 0x96	; 150
    212c:	11 c0       	rjmp	.+34     	; 0x2150 <__floatsisf+0x6a>
    212e:	77 23       	and	r23, r23
    2130:	21 f0       	breq	.+8      	; 0x213a <__floatsisf+0x54>
    2132:	9e e8       	ldi	r25, 0x8E	; 142
    2134:	87 2f       	mov	r24, r23
    2136:	76 2f       	mov	r23, r22
    2138:	05 c0       	rjmp	.+10     	; 0x2144 <__floatsisf+0x5e>
    213a:	66 23       	and	r22, r22
    213c:	71 f0       	breq	.+28     	; 0x215a <__floatsisf+0x74>
    213e:	96 e8       	ldi	r25, 0x86	; 134
    2140:	86 2f       	mov	r24, r22
    2142:	70 e0       	ldi	r23, 0x00	; 0
    2144:	60 e0       	ldi	r22, 0x00	; 0
    2146:	2a f0       	brmi	.+10     	; 0x2152 <__floatsisf+0x6c>
    2148:	9a 95       	dec	r25
    214a:	66 0f       	add	r22, r22
    214c:	77 1f       	adc	r23, r23
    214e:	88 1f       	adc	r24, r24
    2150:	da f7       	brpl	.-10     	; 0x2148 <__floatsisf+0x62>
    2152:	88 0f       	add	r24, r24
    2154:	96 95       	lsr	r25
    2156:	87 95       	ror	r24
    2158:	97 f9       	bld	r25, 7
    215a:	08 95       	ret

0000215c <__fp_cmp>:
    215c:	99 0f       	add	r25, r25
    215e:	00 08       	sbc	r0, r0
    2160:	55 0f       	add	r21, r21
    2162:	aa 0b       	sbc	r26, r26
    2164:	e0 e8       	ldi	r30, 0x80	; 128
    2166:	fe ef       	ldi	r31, 0xFE	; 254
    2168:	16 16       	cp	r1, r22
    216a:	17 06       	cpc	r1, r23
    216c:	e8 07       	cpc	r30, r24
    216e:	f9 07       	cpc	r31, r25
    2170:	c0 f0       	brcs	.+48     	; 0x21a2 <__fp_cmp+0x46>
    2172:	12 16       	cp	r1, r18
    2174:	13 06       	cpc	r1, r19
    2176:	e4 07       	cpc	r30, r20
    2178:	f5 07       	cpc	r31, r21
    217a:	98 f0       	brcs	.+38     	; 0x21a2 <__fp_cmp+0x46>
    217c:	62 1b       	sub	r22, r18
    217e:	73 0b       	sbc	r23, r19
    2180:	84 0b       	sbc	r24, r20
    2182:	95 0b       	sbc	r25, r21
    2184:	39 f4       	brne	.+14     	; 0x2194 <__fp_cmp+0x38>
    2186:	0a 26       	eor	r0, r26
    2188:	61 f0       	breq	.+24     	; 0x21a2 <__fp_cmp+0x46>
    218a:	23 2b       	or	r18, r19
    218c:	24 2b       	or	r18, r20
    218e:	25 2b       	or	r18, r21
    2190:	21 f4       	brne	.+8      	; 0x219a <__fp_cmp+0x3e>
    2192:	08 95       	ret
    2194:	0a 26       	eor	r0, r26
    2196:	09 f4       	brne	.+2      	; 0x219a <__fp_cmp+0x3e>
    2198:	a1 40       	sbci	r26, 0x01	; 1
    219a:	a6 95       	lsr	r26
    219c:	8f ef       	ldi	r24, 0xFF	; 255
    219e:	81 1d       	adc	r24, r1
    21a0:	81 1d       	adc	r24, r1
    21a2:	08 95       	ret

000021a4 <__fp_inf>:
    21a4:	97 f9       	bld	r25, 7
    21a6:	9f 67       	ori	r25, 0x7F	; 127
    21a8:	80 e8       	ldi	r24, 0x80	; 128
    21aa:	70 e0       	ldi	r23, 0x00	; 0
    21ac:	60 e0       	ldi	r22, 0x00	; 0
    21ae:	08 95       	ret

000021b0 <__fp_nan>:
    21b0:	9f ef       	ldi	r25, 0xFF	; 255
    21b2:	80 ec       	ldi	r24, 0xC0	; 192
    21b4:	08 95       	ret

000021b6 <__fp_pscA>:
    21b6:	00 24       	eor	r0, r0
    21b8:	0a 94       	dec	r0
    21ba:	16 16       	cp	r1, r22
    21bc:	17 06       	cpc	r1, r23
    21be:	18 06       	cpc	r1, r24
    21c0:	09 06       	cpc	r0, r25
    21c2:	08 95       	ret

000021c4 <__fp_pscB>:
    21c4:	00 24       	eor	r0, r0
    21c6:	0a 94       	dec	r0
    21c8:	12 16       	cp	r1, r18
    21ca:	13 06       	cpc	r1, r19
    21cc:	14 06       	cpc	r1, r20
    21ce:	05 06       	cpc	r0, r21
    21d0:	08 95       	ret

000021d2 <__fp_round>:
    21d2:	09 2e       	mov	r0, r25
    21d4:	03 94       	inc	r0
    21d6:	00 0c       	add	r0, r0
    21d8:	11 f4       	brne	.+4      	; 0x21de <__fp_round+0xc>
    21da:	88 23       	and	r24, r24
    21dc:	52 f0       	brmi	.+20     	; 0x21f2 <__fp_round+0x20>
    21de:	bb 0f       	add	r27, r27
    21e0:	40 f4       	brcc	.+16     	; 0x21f2 <__fp_round+0x20>
    21e2:	bf 2b       	or	r27, r31
    21e4:	11 f4       	brne	.+4      	; 0x21ea <__fp_round+0x18>
    21e6:	60 ff       	sbrs	r22, 0
    21e8:	04 c0       	rjmp	.+8      	; 0x21f2 <__fp_round+0x20>
    21ea:	6f 5f       	subi	r22, 0xFF	; 255
    21ec:	7f 4f       	sbci	r23, 0xFF	; 255
    21ee:	8f 4f       	sbci	r24, 0xFF	; 255
    21f0:	9f 4f       	sbci	r25, 0xFF	; 255
    21f2:	08 95       	ret

000021f4 <__fp_split3>:
    21f4:	57 fd       	sbrc	r21, 7
    21f6:	90 58       	subi	r25, 0x80	; 128
    21f8:	44 0f       	add	r20, r20
    21fa:	55 1f       	adc	r21, r21
    21fc:	59 f0       	breq	.+22     	; 0x2214 <__fp_splitA+0x10>
    21fe:	5f 3f       	cpi	r21, 0xFF	; 255
    2200:	71 f0       	breq	.+28     	; 0x221e <__fp_splitA+0x1a>
    2202:	47 95       	ror	r20

00002204 <__fp_splitA>:
    2204:	88 0f       	add	r24, r24
    2206:	97 fb       	bst	r25, 7
    2208:	99 1f       	adc	r25, r25
    220a:	61 f0       	breq	.+24     	; 0x2224 <__fp_splitA+0x20>
    220c:	9f 3f       	cpi	r25, 0xFF	; 255
    220e:	79 f0       	breq	.+30     	; 0x222e <__fp_splitA+0x2a>
    2210:	87 95       	ror	r24
    2212:	08 95       	ret
    2214:	12 16       	cp	r1, r18
    2216:	13 06       	cpc	r1, r19
    2218:	14 06       	cpc	r1, r20
    221a:	55 1f       	adc	r21, r21
    221c:	f2 cf       	rjmp	.-28     	; 0x2202 <__stack+0x3>
    221e:	46 95       	lsr	r20
    2220:	f1 df       	rcall	.-30     	; 0x2204 <__fp_splitA>
    2222:	08 c0       	rjmp	.+16     	; 0x2234 <__fp_splitA+0x30>
    2224:	16 16       	cp	r1, r22
    2226:	17 06       	cpc	r1, r23
    2228:	18 06       	cpc	r1, r24
    222a:	99 1f       	adc	r25, r25
    222c:	f1 cf       	rjmp	.-30     	; 0x2210 <__fp_splitA+0xc>
    222e:	86 95       	lsr	r24
    2230:	71 05       	cpc	r23, r1
    2232:	61 05       	cpc	r22, r1
    2234:	08 94       	sec
    2236:	08 95       	ret

00002238 <__fp_zero>:
    2238:	e8 94       	clt

0000223a <__fp_szero>:
    223a:	bb 27       	eor	r27, r27
    223c:	66 27       	eor	r22, r22
    223e:	77 27       	eor	r23, r23
    2240:	cb 01       	movw	r24, r22
    2242:	97 f9       	bld	r25, 7
    2244:	08 95       	ret

00002246 <__gesf2>:
    2246:	8a df       	rcall	.-236    	; 0x215c <__fp_cmp>
    2248:	08 f4       	brcc	.+2      	; 0x224c <__gesf2+0x6>
    224a:	8f ef       	ldi	r24, 0xFF	; 255
    224c:	08 95       	ret

0000224e <__mulsf3>:
    224e:	0b d0       	rcall	.+22     	; 0x2266 <__mulsf3x>
    2250:	c0 cf       	rjmp	.-128    	; 0x21d2 <__fp_round>
    2252:	b1 df       	rcall	.-158    	; 0x21b6 <__fp_pscA>
    2254:	28 f0       	brcs	.+10     	; 0x2260 <__mulsf3+0x12>
    2256:	b6 df       	rcall	.-148    	; 0x21c4 <__fp_pscB>
    2258:	18 f0       	brcs	.+6      	; 0x2260 <__mulsf3+0x12>
    225a:	95 23       	and	r25, r21
    225c:	09 f0       	breq	.+2      	; 0x2260 <__mulsf3+0x12>
    225e:	a2 cf       	rjmp	.-188    	; 0x21a4 <__fp_inf>
    2260:	a7 cf       	rjmp	.-178    	; 0x21b0 <__fp_nan>
    2262:	11 24       	eor	r1, r1
    2264:	ea cf       	rjmp	.-44     	; 0x223a <__fp_szero>

00002266 <__mulsf3x>:
    2266:	c6 df       	rcall	.-116    	; 0x21f4 <__fp_split3>
    2268:	a0 f3       	brcs	.-24     	; 0x2252 <__mulsf3+0x4>

0000226a <__mulsf3_pse>:
    226a:	95 9f       	mul	r25, r21
    226c:	d1 f3       	breq	.-12     	; 0x2262 <__mulsf3+0x14>
    226e:	95 0f       	add	r25, r21
    2270:	50 e0       	ldi	r21, 0x00	; 0
    2272:	55 1f       	adc	r21, r21
    2274:	62 9f       	mul	r22, r18
    2276:	f0 01       	movw	r30, r0
    2278:	72 9f       	mul	r23, r18
    227a:	bb 27       	eor	r27, r27
    227c:	f0 0d       	add	r31, r0
    227e:	b1 1d       	adc	r27, r1
    2280:	63 9f       	mul	r22, r19
    2282:	aa 27       	eor	r26, r26
    2284:	f0 0d       	add	r31, r0
    2286:	b1 1d       	adc	r27, r1
    2288:	aa 1f       	adc	r26, r26
    228a:	64 9f       	mul	r22, r20
    228c:	66 27       	eor	r22, r22
    228e:	b0 0d       	add	r27, r0
    2290:	a1 1d       	adc	r26, r1
    2292:	66 1f       	adc	r22, r22
    2294:	82 9f       	mul	r24, r18
    2296:	22 27       	eor	r18, r18
    2298:	b0 0d       	add	r27, r0
    229a:	a1 1d       	adc	r26, r1
    229c:	62 1f       	adc	r22, r18
    229e:	73 9f       	mul	r23, r19
    22a0:	b0 0d       	add	r27, r0
    22a2:	a1 1d       	adc	r26, r1
    22a4:	62 1f       	adc	r22, r18
    22a6:	83 9f       	mul	r24, r19
    22a8:	a0 0d       	add	r26, r0
    22aa:	61 1d       	adc	r22, r1
    22ac:	22 1f       	adc	r18, r18
    22ae:	74 9f       	mul	r23, r20
    22b0:	33 27       	eor	r19, r19
    22b2:	a0 0d       	add	r26, r0
    22b4:	61 1d       	adc	r22, r1
    22b6:	23 1f       	adc	r18, r19
    22b8:	84 9f       	mul	r24, r20
    22ba:	60 0d       	add	r22, r0
    22bc:	21 1d       	adc	r18, r1
    22be:	82 2f       	mov	r24, r18
    22c0:	76 2f       	mov	r23, r22
    22c2:	6a 2f       	mov	r22, r26
    22c4:	11 24       	eor	r1, r1
    22c6:	9f 57       	subi	r25, 0x7F	; 127
    22c8:	50 40       	sbci	r21, 0x00	; 0
    22ca:	8a f0       	brmi	.+34     	; 0x22ee <__mulsf3_pse+0x84>
    22cc:	e1 f0       	breq	.+56     	; 0x2306 <__mulsf3_pse+0x9c>
    22ce:	88 23       	and	r24, r24
    22d0:	4a f0       	brmi	.+18     	; 0x22e4 <__mulsf3_pse+0x7a>
    22d2:	ee 0f       	add	r30, r30
    22d4:	ff 1f       	adc	r31, r31
    22d6:	bb 1f       	adc	r27, r27
    22d8:	66 1f       	adc	r22, r22
    22da:	77 1f       	adc	r23, r23
    22dc:	88 1f       	adc	r24, r24
    22de:	91 50       	subi	r25, 0x01	; 1
    22e0:	50 40       	sbci	r21, 0x00	; 0
    22e2:	a9 f7       	brne	.-22     	; 0x22ce <__mulsf3_pse+0x64>
    22e4:	9e 3f       	cpi	r25, 0xFE	; 254
    22e6:	51 05       	cpc	r21, r1
    22e8:	70 f0       	brcs	.+28     	; 0x2306 <__mulsf3_pse+0x9c>
    22ea:	5c cf       	rjmp	.-328    	; 0x21a4 <__fp_inf>
    22ec:	a6 cf       	rjmp	.-180    	; 0x223a <__fp_szero>
    22ee:	5f 3f       	cpi	r21, 0xFF	; 255
    22f0:	ec f3       	brlt	.-6      	; 0x22ec <__mulsf3_pse+0x82>
    22f2:	98 3e       	cpi	r25, 0xE8	; 232
    22f4:	dc f3       	brlt	.-10     	; 0x22ec <__mulsf3_pse+0x82>
    22f6:	86 95       	lsr	r24
    22f8:	77 95       	ror	r23
    22fa:	67 95       	ror	r22
    22fc:	b7 95       	ror	r27
    22fe:	f7 95       	ror	r31
    2300:	e7 95       	ror	r30
    2302:	9f 5f       	subi	r25, 0xFF	; 255
    2304:	c1 f7       	brne	.-16     	; 0x22f6 <__mulsf3_pse+0x8c>
    2306:	fe 2b       	or	r31, r30
    2308:	88 0f       	add	r24, r24
    230a:	91 1d       	adc	r25, r1
    230c:	96 95       	lsr	r25
    230e:	87 95       	ror	r24
    2310:	97 f9       	bld	r25, 7
    2312:	08 95       	ret

00002314 <__udivmodsi4>:
    2314:	a1 e2       	ldi	r26, 0x21	; 33
    2316:	1a 2e       	mov	r1, r26
    2318:	aa 1b       	sub	r26, r26
    231a:	bb 1b       	sub	r27, r27
    231c:	fd 01       	movw	r30, r26
    231e:	0d c0       	rjmp	.+26     	; 0x233a <__udivmodsi4_ep>

00002320 <__udivmodsi4_loop>:
    2320:	aa 1f       	adc	r26, r26
    2322:	bb 1f       	adc	r27, r27
    2324:	ee 1f       	adc	r30, r30
    2326:	ff 1f       	adc	r31, r31
    2328:	a2 17       	cp	r26, r18
    232a:	b3 07       	cpc	r27, r19
    232c:	e4 07       	cpc	r30, r20
    232e:	f5 07       	cpc	r31, r21
    2330:	20 f0       	brcs	.+8      	; 0x233a <__udivmodsi4_ep>
    2332:	a2 1b       	sub	r26, r18
    2334:	b3 0b       	sbc	r27, r19
    2336:	e4 0b       	sbc	r30, r20
    2338:	f5 0b       	sbc	r31, r21

0000233a <__udivmodsi4_ep>:
    233a:	66 1f       	adc	r22, r22
    233c:	77 1f       	adc	r23, r23
    233e:	88 1f       	adc	r24, r24
    2340:	99 1f       	adc	r25, r25
    2342:	1a 94       	dec	r1
    2344:	69 f7       	brne	.-38     	; 0x2320 <__udivmodsi4_loop>
    2346:	60 95       	com	r22
    2348:	70 95       	com	r23
    234a:	80 95       	com	r24
    234c:	90 95       	com	r25
    234e:	9b 01       	movw	r18, r22
    2350:	ac 01       	movw	r20, r24
    2352:	bd 01       	movw	r22, r26
    2354:	cf 01       	movw	r24, r30
    2356:	08 95       	ret

00002358 <__umulhisi3>:
    2358:	a2 9f       	mul	r26, r18
    235a:	b0 01       	movw	r22, r0
    235c:	b3 9f       	mul	r27, r19
    235e:	c0 01       	movw	r24, r0
    2360:	a3 9f       	mul	r26, r19
    2362:	70 0d       	add	r23, r0
    2364:	81 1d       	adc	r24, r1
    2366:	11 24       	eor	r1, r1
    2368:	91 1d       	adc	r25, r1
    236a:	b2 9f       	mul	r27, r18
    236c:	70 0d       	add	r23, r0
    236e:	81 1d       	adc	r24, r1
    2370:	11 24       	eor	r1, r1
    2372:	91 1d       	adc	r25, r1
    2374:	08 95       	ret

00002376 <malloc>:
    2376:	0f 93       	push	r16
    2378:	1f 93       	push	r17
    237a:	cf 93       	push	r28
    237c:	df 93       	push	r29
    237e:	82 30       	cpi	r24, 0x02	; 2
    2380:	91 05       	cpc	r25, r1
    2382:	10 f4       	brcc	.+4      	; 0x2388 <malloc+0x12>
    2384:	82 e0       	ldi	r24, 0x02	; 2
    2386:	90 e0       	ldi	r25, 0x00	; 0
    2388:	e0 91 e9 08 	lds	r30, 0x08E9	; 0x8008e9 <__flp>
    238c:	f0 91 ea 08 	lds	r31, 0x08EA	; 0x8008ea <__flp+0x1>
    2390:	20 e0       	ldi	r18, 0x00	; 0
    2392:	30 e0       	ldi	r19, 0x00	; 0
    2394:	a0 e0       	ldi	r26, 0x00	; 0
    2396:	b0 e0       	ldi	r27, 0x00	; 0
    2398:	30 97       	sbiw	r30, 0x00	; 0
    239a:	19 f1       	breq	.+70     	; 0x23e2 <malloc+0x6c>
    239c:	40 81       	ld	r20, Z
    239e:	51 81       	ldd	r21, Z+1	; 0x01
    23a0:	02 81       	ldd	r16, Z+2	; 0x02
    23a2:	13 81       	ldd	r17, Z+3	; 0x03
    23a4:	48 17       	cp	r20, r24
    23a6:	59 07       	cpc	r21, r25
    23a8:	c8 f0       	brcs	.+50     	; 0x23dc <malloc+0x66>
    23aa:	84 17       	cp	r24, r20
    23ac:	95 07       	cpc	r25, r21
    23ae:	69 f4       	brne	.+26     	; 0x23ca <malloc+0x54>
    23b0:	10 97       	sbiw	r26, 0x00	; 0
    23b2:	31 f0       	breq	.+12     	; 0x23c0 <malloc+0x4a>
    23b4:	12 96       	adiw	r26, 0x02	; 2
    23b6:	0c 93       	st	X, r16
    23b8:	12 97       	sbiw	r26, 0x02	; 2
    23ba:	13 96       	adiw	r26, 0x03	; 3
    23bc:	1c 93       	st	X, r17
    23be:	27 c0       	rjmp	.+78     	; 0x240e <malloc+0x98>
    23c0:	00 93 e9 08 	sts	0x08E9, r16	; 0x8008e9 <__flp>
    23c4:	10 93 ea 08 	sts	0x08EA, r17	; 0x8008ea <__flp+0x1>
    23c8:	22 c0       	rjmp	.+68     	; 0x240e <malloc+0x98>
    23ca:	21 15       	cp	r18, r1
    23cc:	31 05       	cpc	r19, r1
    23ce:	19 f0       	breq	.+6      	; 0x23d6 <malloc+0x60>
    23d0:	42 17       	cp	r20, r18
    23d2:	53 07       	cpc	r21, r19
    23d4:	18 f4       	brcc	.+6      	; 0x23dc <malloc+0x66>
    23d6:	9a 01       	movw	r18, r20
    23d8:	bd 01       	movw	r22, r26
    23da:	ef 01       	movw	r28, r30
    23dc:	df 01       	movw	r26, r30
    23de:	f8 01       	movw	r30, r16
    23e0:	db cf       	rjmp	.-74     	; 0x2398 <malloc+0x22>
    23e2:	21 15       	cp	r18, r1
    23e4:	31 05       	cpc	r19, r1
    23e6:	f9 f0       	breq	.+62     	; 0x2426 <malloc+0xb0>
    23e8:	28 1b       	sub	r18, r24
    23ea:	39 0b       	sbc	r19, r25
    23ec:	24 30       	cpi	r18, 0x04	; 4
    23ee:	31 05       	cpc	r19, r1
    23f0:	80 f4       	brcc	.+32     	; 0x2412 <malloc+0x9c>
    23f2:	8a 81       	ldd	r24, Y+2	; 0x02
    23f4:	9b 81       	ldd	r25, Y+3	; 0x03
    23f6:	61 15       	cp	r22, r1
    23f8:	71 05       	cpc	r23, r1
    23fa:	21 f0       	breq	.+8      	; 0x2404 <malloc+0x8e>
    23fc:	fb 01       	movw	r30, r22
    23fe:	93 83       	std	Z+3, r25	; 0x03
    2400:	82 83       	std	Z+2, r24	; 0x02
    2402:	04 c0       	rjmp	.+8      	; 0x240c <malloc+0x96>
    2404:	90 93 ea 08 	sts	0x08EA, r25	; 0x8008ea <__flp+0x1>
    2408:	80 93 e9 08 	sts	0x08E9, r24	; 0x8008e9 <__flp>
    240c:	fe 01       	movw	r30, r28
    240e:	32 96       	adiw	r30, 0x02	; 2
    2410:	44 c0       	rjmp	.+136    	; 0x249a <malloc+0x124>
    2412:	fe 01       	movw	r30, r28
    2414:	e2 0f       	add	r30, r18
    2416:	f3 1f       	adc	r31, r19
    2418:	81 93       	st	Z+, r24
    241a:	91 93       	st	Z+, r25
    241c:	22 50       	subi	r18, 0x02	; 2
    241e:	31 09       	sbc	r19, r1
    2420:	39 83       	std	Y+1, r19	; 0x01
    2422:	28 83       	st	Y, r18
    2424:	3a c0       	rjmp	.+116    	; 0x249a <malloc+0x124>
    2426:	20 91 e7 08 	lds	r18, 0x08E7	; 0x8008e7 <__brkval>
    242a:	30 91 e8 08 	lds	r19, 0x08E8	; 0x8008e8 <__brkval+0x1>
    242e:	23 2b       	or	r18, r19
    2430:	41 f4       	brne	.+16     	; 0x2442 <malloc+0xcc>
    2432:	20 91 02 02 	lds	r18, 0x0202	; 0x800202 <__malloc_heap_start>
    2436:	30 91 03 02 	lds	r19, 0x0203	; 0x800203 <__malloc_heap_start+0x1>
    243a:	30 93 e8 08 	sts	0x08E8, r19	; 0x8008e8 <__brkval+0x1>
    243e:	20 93 e7 08 	sts	0x08E7, r18	; 0x8008e7 <__brkval>
    2442:	20 91 00 02 	lds	r18, 0x0200	; 0x800200 <__data_start>
    2446:	30 91 01 02 	lds	r19, 0x0201	; 0x800201 <__data_start+0x1>
    244a:	21 15       	cp	r18, r1
    244c:	31 05       	cpc	r19, r1
    244e:	41 f4       	brne	.+16     	; 0x2460 <malloc+0xea>
    2450:	2d b7       	in	r18, 0x3d	; 61
    2452:	3e b7       	in	r19, 0x3e	; 62
    2454:	40 91 04 02 	lds	r20, 0x0204	; 0x800204 <__malloc_margin>
    2458:	50 91 05 02 	lds	r21, 0x0205	; 0x800205 <__malloc_margin+0x1>
    245c:	24 1b       	sub	r18, r20
    245e:	35 0b       	sbc	r19, r21
    2460:	e0 91 e7 08 	lds	r30, 0x08E7	; 0x8008e7 <__brkval>
    2464:	f0 91 e8 08 	lds	r31, 0x08E8	; 0x8008e8 <__brkval+0x1>
    2468:	e2 17       	cp	r30, r18
    246a:	f3 07       	cpc	r31, r19
    246c:	a0 f4       	brcc	.+40     	; 0x2496 <malloc+0x120>
    246e:	2e 1b       	sub	r18, r30
    2470:	3f 0b       	sbc	r19, r31
    2472:	28 17       	cp	r18, r24
    2474:	39 07       	cpc	r19, r25
    2476:	78 f0       	brcs	.+30     	; 0x2496 <malloc+0x120>
    2478:	ac 01       	movw	r20, r24
    247a:	4e 5f       	subi	r20, 0xFE	; 254
    247c:	5f 4f       	sbci	r21, 0xFF	; 255
    247e:	24 17       	cp	r18, r20
    2480:	35 07       	cpc	r19, r21
    2482:	48 f0       	brcs	.+18     	; 0x2496 <malloc+0x120>
    2484:	4e 0f       	add	r20, r30
    2486:	5f 1f       	adc	r21, r31
    2488:	50 93 e8 08 	sts	0x08E8, r21	; 0x8008e8 <__brkval+0x1>
    248c:	40 93 e7 08 	sts	0x08E7, r20	; 0x8008e7 <__brkval>
    2490:	81 93       	st	Z+, r24
    2492:	91 93       	st	Z+, r25
    2494:	02 c0       	rjmp	.+4      	; 0x249a <malloc+0x124>
    2496:	e0 e0       	ldi	r30, 0x00	; 0
    2498:	f0 e0       	ldi	r31, 0x00	; 0
    249a:	cf 01       	movw	r24, r30
    249c:	df 91       	pop	r29
    249e:	cf 91       	pop	r28
    24a0:	1f 91       	pop	r17
    24a2:	0f 91       	pop	r16
    24a4:	08 95       	ret

000024a6 <free>:
    24a6:	cf 93       	push	r28
    24a8:	df 93       	push	r29
    24aa:	00 97       	sbiw	r24, 0x00	; 0
    24ac:	09 f4       	brne	.+2      	; 0x24b0 <free+0xa>
    24ae:	81 c0       	rjmp	.+258    	; 0x25b2 <free+0x10c>
    24b0:	fc 01       	movw	r30, r24
    24b2:	32 97       	sbiw	r30, 0x02	; 2
    24b4:	13 82       	std	Z+3, r1	; 0x03
    24b6:	12 82       	std	Z+2, r1	; 0x02
    24b8:	a0 91 e9 08 	lds	r26, 0x08E9	; 0x8008e9 <__flp>
    24bc:	b0 91 ea 08 	lds	r27, 0x08EA	; 0x8008ea <__flp+0x1>
    24c0:	10 97       	sbiw	r26, 0x00	; 0
    24c2:	81 f4       	brne	.+32     	; 0x24e4 <free+0x3e>
    24c4:	20 81       	ld	r18, Z
    24c6:	31 81       	ldd	r19, Z+1	; 0x01
    24c8:	82 0f       	add	r24, r18
    24ca:	93 1f       	adc	r25, r19
    24cc:	20 91 e7 08 	lds	r18, 0x08E7	; 0x8008e7 <__brkval>
    24d0:	30 91 e8 08 	lds	r19, 0x08E8	; 0x8008e8 <__brkval+0x1>
    24d4:	28 17       	cp	r18, r24
    24d6:	39 07       	cpc	r19, r25
    24d8:	51 f5       	brne	.+84     	; 0x252e <free+0x88>
    24da:	f0 93 e8 08 	sts	0x08E8, r31	; 0x8008e8 <__brkval+0x1>
    24de:	e0 93 e7 08 	sts	0x08E7, r30	; 0x8008e7 <__brkval>
    24e2:	67 c0       	rjmp	.+206    	; 0x25b2 <free+0x10c>
    24e4:	ed 01       	movw	r28, r26
    24e6:	20 e0       	ldi	r18, 0x00	; 0
    24e8:	30 e0       	ldi	r19, 0x00	; 0
    24ea:	ce 17       	cp	r28, r30
    24ec:	df 07       	cpc	r29, r31
    24ee:	40 f4       	brcc	.+16     	; 0x2500 <free+0x5a>
    24f0:	4a 81       	ldd	r20, Y+2	; 0x02
    24f2:	5b 81       	ldd	r21, Y+3	; 0x03
    24f4:	9e 01       	movw	r18, r28
    24f6:	41 15       	cp	r20, r1
    24f8:	51 05       	cpc	r21, r1
    24fa:	f1 f0       	breq	.+60     	; 0x2538 <free+0x92>
    24fc:	ea 01       	movw	r28, r20
    24fe:	f5 cf       	rjmp	.-22     	; 0x24ea <free+0x44>
    2500:	d3 83       	std	Z+3, r29	; 0x03
    2502:	c2 83       	std	Z+2, r28	; 0x02
    2504:	40 81       	ld	r20, Z
    2506:	51 81       	ldd	r21, Z+1	; 0x01
    2508:	84 0f       	add	r24, r20
    250a:	95 1f       	adc	r25, r21
    250c:	c8 17       	cp	r28, r24
    250e:	d9 07       	cpc	r29, r25
    2510:	59 f4       	brne	.+22     	; 0x2528 <free+0x82>
    2512:	88 81       	ld	r24, Y
    2514:	99 81       	ldd	r25, Y+1	; 0x01
    2516:	84 0f       	add	r24, r20
    2518:	95 1f       	adc	r25, r21
    251a:	02 96       	adiw	r24, 0x02	; 2
    251c:	91 83       	std	Z+1, r25	; 0x01
    251e:	80 83       	st	Z, r24
    2520:	8a 81       	ldd	r24, Y+2	; 0x02
    2522:	9b 81       	ldd	r25, Y+3	; 0x03
    2524:	93 83       	std	Z+3, r25	; 0x03
    2526:	82 83       	std	Z+2, r24	; 0x02
    2528:	21 15       	cp	r18, r1
    252a:	31 05       	cpc	r19, r1
    252c:	29 f4       	brne	.+10     	; 0x2538 <free+0x92>
    252e:	f0 93 ea 08 	sts	0x08EA, r31	; 0x8008ea <__flp+0x1>
    2532:	e0 93 e9 08 	sts	0x08E9, r30	; 0x8008e9 <__flp>
    2536:	3d c0       	rjmp	.+122    	; 0x25b2 <free+0x10c>
    2538:	e9 01       	movw	r28, r18
    253a:	fb 83       	std	Y+3, r31	; 0x03
    253c:	ea 83       	std	Y+2, r30	; 0x02
    253e:	49 91       	ld	r20, Y+
    2540:	59 91       	ld	r21, Y+
    2542:	c4 0f       	add	r28, r20
    2544:	d5 1f       	adc	r29, r21
    2546:	ec 17       	cp	r30, r28
    2548:	fd 07       	cpc	r31, r29
    254a:	61 f4       	brne	.+24     	; 0x2564 <free+0xbe>
    254c:	80 81       	ld	r24, Z
    254e:	91 81       	ldd	r25, Z+1	; 0x01
    2550:	84 0f       	add	r24, r20
    2552:	95 1f       	adc	r25, r21
    2554:	02 96       	adiw	r24, 0x02	; 2
    2556:	e9 01       	movw	r28, r18
    2558:	99 83       	std	Y+1, r25	; 0x01
    255a:	88 83       	st	Y, r24
    255c:	82 81       	ldd	r24, Z+2	; 0x02
    255e:	93 81       	ldd	r25, Z+3	; 0x03
    2560:	9b 83       	std	Y+3, r25	; 0x03
    2562:	8a 83       	std	Y+2, r24	; 0x02
    2564:	e0 e0       	ldi	r30, 0x00	; 0
    2566:	f0 e0       	ldi	r31, 0x00	; 0
    2568:	12 96       	adiw	r26, 0x02	; 2
    256a:	8d 91       	ld	r24, X+
    256c:	9c 91       	ld	r25, X
    256e:	13 97       	sbiw	r26, 0x03	; 3
    2570:	00 97       	sbiw	r24, 0x00	; 0
    2572:	19 f0       	breq	.+6      	; 0x257a <free+0xd4>
    2574:	fd 01       	movw	r30, r26
    2576:	dc 01       	movw	r26, r24
    2578:	f7 cf       	rjmp	.-18     	; 0x2568 <free+0xc2>
    257a:	8d 91       	ld	r24, X+
    257c:	9c 91       	ld	r25, X
    257e:	11 97       	sbiw	r26, 0x01	; 1
    2580:	9d 01       	movw	r18, r26
    2582:	2e 5f       	subi	r18, 0xFE	; 254
    2584:	3f 4f       	sbci	r19, 0xFF	; 255
    2586:	82 0f       	add	r24, r18
    2588:	93 1f       	adc	r25, r19
    258a:	20 91 e7 08 	lds	r18, 0x08E7	; 0x8008e7 <__brkval>
    258e:	30 91 e8 08 	lds	r19, 0x08E8	; 0x8008e8 <__brkval+0x1>
    2592:	28 17       	cp	r18, r24
    2594:	39 07       	cpc	r19, r25
    2596:	69 f4       	brne	.+26     	; 0x25b2 <free+0x10c>
    2598:	30 97       	sbiw	r30, 0x00	; 0
    259a:	29 f4       	brne	.+10     	; 0x25a6 <free+0x100>
    259c:	10 92 ea 08 	sts	0x08EA, r1	; 0x8008ea <__flp+0x1>
    25a0:	10 92 e9 08 	sts	0x08E9, r1	; 0x8008e9 <__flp>
    25a4:	02 c0       	rjmp	.+4      	; 0x25aa <free+0x104>
    25a6:	13 82       	std	Z+3, r1	; 0x03
    25a8:	12 82       	std	Z+2, r1	; 0x02
    25aa:	b0 93 e8 08 	sts	0x08E8, r27	; 0x8008e8 <__brkval+0x1>
    25ae:	a0 93 e7 08 	sts	0x08E7, r26	; 0x8008e7 <__brkval>
    25b2:	df 91       	pop	r29
    25b4:	cf 91       	pop	r28
    25b6:	08 95       	ret

000025b8 <memset>:
    25b8:	dc 01       	movw	r26, r24
    25ba:	01 c0       	rjmp	.+2      	; 0x25be <memset+0x6>
    25bc:	6d 93       	st	X+, r22
    25be:	41 50       	subi	r20, 0x01	; 1
    25c0:	50 40       	sbci	r21, 0x00	; 0
    25c2:	e0 f7       	brcc	.-8      	; 0x25bc <memset+0x4>
    25c4:	08 95       	ret

000025c6 <strncpy>:
    25c6:	fb 01       	movw	r30, r22
    25c8:	dc 01       	movw	r26, r24
    25ca:	41 50       	subi	r20, 0x01	; 1
    25cc:	50 40       	sbci	r21, 0x00	; 0
    25ce:	48 f0       	brcs	.+18     	; 0x25e2 <strncpy+0x1c>
    25d0:	01 90       	ld	r0, Z+
    25d2:	0d 92       	st	X+, r0
    25d4:	00 20       	and	r0, r0
    25d6:	c9 f7       	brne	.-14     	; 0x25ca <strncpy+0x4>
    25d8:	01 c0       	rjmp	.+2      	; 0x25dc <strncpy+0x16>
    25da:	1d 92       	st	X+, r1
    25dc:	41 50       	subi	r20, 0x01	; 1
    25de:	50 40       	sbci	r21, 0x00	; 0
    25e0:	e0 f7       	brcc	.-8      	; 0x25da <strncpy+0x14>
    25e2:	08 95       	ret

000025e4 <_exit>:
    25e4:	f8 94       	cli

000025e6 <__stop_program>:
    25e6:	ff cf       	rjmp	.-2      	; 0x25e6 <__stop_program>
