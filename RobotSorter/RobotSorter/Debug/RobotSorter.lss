
RobotSorter.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000000d0  00800200  0000324c  000032e0  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000324c  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000fea  008002d0  008002d0  000033b0  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000033b0  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  000033e0  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000708  00000000  00000000  00003420  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000097c0  00000000  00000000  00003b28  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00003a62  00000000  00000000  0000d2e8  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000404f  00000000  00000000  00010d4a  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001400  00000000  00000000  00014d9c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00002586  00000000  00000000  0001619c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00004ce8  00000000  00000000  00018722  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000005e0  00000000  00000000  0001d40a  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	ea c0       	rjmp	.+468    	; 0x1d6 <__ctors_end>
       2:	00 00       	nop
       4:	18 c1       	rjmp	.+560    	; 0x236 <__bad_interrupt>
       6:	00 00       	nop
       8:	16 c1       	rjmp	.+556    	; 0x236 <__bad_interrupt>
       a:	00 00       	nop
       c:	14 c1       	rjmp	.+552    	; 0x236 <__bad_interrupt>
       e:	00 00       	nop
      10:	12 c1       	rjmp	.+548    	; 0x236 <__bad_interrupt>
      12:	00 00       	nop
      14:	0c 94 33 14 	jmp	0x2866	; 0x2866 <__vector_5>
      18:	0e c1       	rjmp	.+540    	; 0x236 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	0c c1       	rjmp	.+536    	; 0x236 <__bad_interrupt>
      1e:	00 00       	nop
      20:	0a c1       	rjmp	.+532    	; 0x236 <__bad_interrupt>
      22:	00 00       	nop
      24:	08 c1       	rjmp	.+528    	; 0x236 <__bad_interrupt>
      26:	00 00       	nop
      28:	06 c1       	rjmp	.+524    	; 0x236 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	04 c1       	rjmp	.+520    	; 0x236 <__bad_interrupt>
      2e:	00 00       	nop
      30:	02 c1       	rjmp	.+516    	; 0x236 <__bad_interrupt>
      32:	00 00       	nop
      34:	00 c1       	rjmp	.+512    	; 0x236 <__bad_interrupt>
      36:	00 00       	nop
      38:	fe c0       	rjmp	.+508    	; 0x236 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	fc c0       	rjmp	.+504    	; 0x236 <__bad_interrupt>
      3e:	00 00       	nop
      40:	fa c0       	rjmp	.+500    	; 0x236 <__bad_interrupt>
      42:	00 00       	nop
      44:	f8 c0       	rjmp	.+496    	; 0x236 <__bad_interrupt>
      46:	00 00       	nop
      48:	f6 c0       	rjmp	.+492    	; 0x236 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	f4 c0       	rjmp	.+488    	; 0x236 <__bad_interrupt>
      4e:	00 00       	nop
      50:	f2 c0       	rjmp	.+484    	; 0x236 <__bad_interrupt>
      52:	00 00       	nop
      54:	0c 94 94 0e 	jmp	0x1d28	; 0x1d28 <__vector_21>
      58:	ee c0       	rjmp	.+476    	; 0x236 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	ec c0       	rjmp	.+472    	; 0x236 <__bad_interrupt>
      5e:	00 00       	nop
      60:	ea c0       	rjmp	.+468    	; 0x236 <__bad_interrupt>
      62:	00 00       	nop
      64:	e8 c0       	rjmp	.+464    	; 0x236 <__bad_interrupt>
      66:	00 00       	nop
      68:	e6 c0       	rjmp	.+460    	; 0x236 <__bad_interrupt>
      6a:	00 00       	nop
      6c:	e4 c0       	rjmp	.+456    	; 0x236 <__bad_interrupt>
      6e:	00 00       	nop
      70:	e2 c0       	rjmp	.+452    	; 0x236 <__bad_interrupt>
      72:	00 00       	nop
      74:	e0 c0       	rjmp	.+448    	; 0x236 <__bad_interrupt>
      76:	00 00       	nop
      78:	de c0       	rjmp	.+444    	; 0x236 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	dc c0       	rjmp	.+440    	; 0x236 <__bad_interrupt>
      7e:	00 00       	nop
      80:	da c0       	rjmp	.+436    	; 0x236 <__bad_interrupt>
      82:	00 00       	nop
      84:	d8 c0       	rjmp	.+432    	; 0x236 <__bad_interrupt>
      86:	00 00       	nop
      88:	d6 c0       	rjmp	.+428    	; 0x236 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	d4 c0       	rjmp	.+424    	; 0x236 <__bad_interrupt>
      8e:	00 00       	nop
      90:	d2 c0       	rjmp	.+420    	; 0x236 <__bad_interrupt>
      92:	00 00       	nop
      94:	d0 c0       	rjmp	.+416    	; 0x236 <__bad_interrupt>
      96:	00 00       	nop
      98:	ce c0       	rjmp	.+412    	; 0x236 <__bad_interrupt>
      9a:	00 00       	nop
      9c:	cc c0       	rjmp	.+408    	; 0x236 <__bad_interrupt>
      9e:	00 00       	nop
      a0:	ca c0       	rjmp	.+404    	; 0x236 <__bad_interrupt>
      a2:	00 00       	nop
      a4:	c0 c2       	rjmp	.+1408   	; 0x626 <__vector_41>
      a6:	00 00       	nop
      a8:	c6 c0       	rjmp	.+396    	; 0x236 <__bad_interrupt>
      aa:	00 00       	nop
      ac:	c4 c0       	rjmp	.+392    	; 0x236 <__bad_interrupt>
      ae:	00 00       	nop
      b0:	c2 c0       	rjmp	.+388    	; 0x236 <__bad_interrupt>
      b2:	00 00       	nop
      b4:	93 c2       	rjmp	.+1318   	; 0x5dc <__vector_45>
      b6:	00 00       	nop
      b8:	be c0       	rjmp	.+380    	; 0x236 <__bad_interrupt>
      ba:	00 00       	nop
      bc:	bc c0       	rjmp	.+376    	; 0x236 <__bad_interrupt>
      be:	00 00       	nop
      c0:	ba c0       	rjmp	.+372    	; 0x236 <__bad_interrupt>
      c2:	00 00       	nop
      c4:	b8 c0       	rjmp	.+368    	; 0x236 <__bad_interrupt>
      c6:	00 00       	nop
      c8:	b6 c0       	rjmp	.+364    	; 0x236 <__bad_interrupt>
      ca:	00 00       	nop
      cc:	b4 c0       	rjmp	.+360    	; 0x236 <__bad_interrupt>
      ce:	00 00       	nop
      d0:	b2 c0       	rjmp	.+356    	; 0x236 <__bad_interrupt>
      d2:	00 00       	nop
      d4:	b0 c0       	rjmp	.+352    	; 0x236 <__bad_interrupt>
      d6:	00 00       	nop
      d8:	ae c0       	rjmp	.+348    	; 0x236 <__bad_interrupt>
      da:	00 00       	nop
      dc:	ac c0       	rjmp	.+344    	; 0x236 <__bad_interrupt>
      de:	00 00       	nop
      e0:	aa c0       	rjmp	.+340    	; 0x236 <__bad_interrupt>
      e2:	00 00       	nop
      e4:	05 04       	cpc	r0, r5
      e6:	01 04       	cpc	r0, r1
      e8:	09 04       	cpc	r0, r9
      ea:	07 04       	cpc	r0, r7
      ec:	09 04       	cpc	r0, r9
      ee:	09 04       	cpc	r0, r9
      f0:	09 04       	cpc	r0, r9
      f2:	03 04       	cpc	r0, r3
      f4:	09 04       	cpc	r0, r9
      f6:	09 04       	cpc	r0, r9
      f8:	09 04       	cpc	r0, r9
      fa:	09 04       	cpc	r0, r9
      fc:	09 04       	cpc	r0, r9
      fe:	09 04       	cpc	r0, r9
     100:	09 04       	cpc	r0, r9
     102:	09 04       	cpc	r0, r9
     104:	fd 03       	fmulsu	r23, r21
     106:	f9 03       	fmulsu	r23, r17
     108:	09 04       	cpc	r0, r9
     10a:	ff 03       	fmulsu	r23, r23
     10c:	09 04       	cpc	r0, r9
     10e:	09 04       	cpc	r0, r9
     110:	09 04       	cpc	r0, r9
     112:	fb 03       	fmulsu	r23, r19
     114:	09 04       	cpc	r0, r9
     116:	09 04       	cpc	r0, r9
     118:	09 04       	cpc	r0, r9
     11a:	09 04       	cpc	r0, r9
     11c:	09 04       	cpc	r0, r9
     11e:	09 04       	cpc	r0, r9
     120:	09 04       	cpc	r0, r9
     122:	09 04       	cpc	r0, r9
     124:	09 04       	cpc	r0, r9
     126:	09 04       	cpc	r0, r9
     128:	09 04       	cpc	r0, r9
     12a:	09 04       	cpc	r0, r9
     12c:	09 04       	cpc	r0, r9
     12e:	09 04       	cpc	r0, r9
     130:	09 04       	cpc	r0, r9
     132:	09 04       	cpc	r0, r9
     134:	09 04       	cpc	r0, r9
     136:	09 04       	cpc	r0, r9
     138:	09 04       	cpc	r0, r9
     13a:	09 04       	cpc	r0, r9
     13c:	09 04       	cpc	r0, r9
     13e:	09 04       	cpc	r0, r9
     140:	09 04       	cpc	r0, r9
     142:	09 04       	cpc	r0, r9
     144:	ed 03       	fmulsu	r22, r21
     146:	eb 03       	fmulsu	r22, r19
     148:	09 04       	cpc	r0, r9
     14a:	ef 03       	fmulsu	r22, r23
     14c:	09 04       	cpc	r0, r9
     14e:	09 04       	cpc	r0, r9
     150:	09 04       	cpc	r0, r9
     152:	0b 04       	cpc	r0, r11
     154:	09 04       	cpc	r0, r9
     156:	09 04       	cpc	r0, r9
     158:	09 04       	cpc	r0, r9
     15a:	09 04       	cpc	r0, r9
     15c:	09 04       	cpc	r0, r9
     15e:	09 04       	cpc	r0, r9
     160:	09 04       	cpc	r0, r9
     162:	09 04       	cpc	r0, r9
     164:	09 04       	cpc	r0, r9
     166:	09 04       	cpc	r0, r9
     168:	09 04       	cpc	r0, r9
     16a:	09 04       	cpc	r0, r9
     16c:	09 04       	cpc	r0, r9
     16e:	09 04       	cpc	r0, r9
     170:	09 04       	cpc	r0, r9
     172:	09 04       	cpc	r0, r9
     174:	09 04       	cpc	r0, r9
     176:	09 04       	cpc	r0, r9
     178:	09 04       	cpc	r0, r9
     17a:	09 04       	cpc	r0, r9
     17c:	09 04       	cpc	r0, r9
     17e:	09 04       	cpc	r0, r9
     180:	09 04       	cpc	r0, r9
     182:	09 04       	cpc	r0, r9
     184:	09 04       	cpc	r0, r9
     186:	09 04       	cpc	r0, r9
     188:	09 04       	cpc	r0, r9
     18a:	09 04       	cpc	r0, r9
     18c:	09 04       	cpc	r0, r9
     18e:	09 04       	cpc	r0, r9
     190:	09 04       	cpc	r0, r9
     192:	09 04       	cpc	r0, r9
     194:	09 04       	cpc	r0, r9
     196:	09 04       	cpc	r0, r9
     198:	09 04       	cpc	r0, r9
     19a:	09 04       	cpc	r0, r9
     19c:	09 04       	cpc	r0, r9
     19e:	09 04       	cpc	r0, r9
     1a0:	09 04       	cpc	r0, r9
     1a2:	09 04       	cpc	r0, r9
     1a4:	09 04       	cpc	r0, r9
     1a6:	09 04       	cpc	r0, r9
     1a8:	09 04       	cpc	r0, r9
     1aa:	09 04       	cpc	r0, r9
     1ac:	09 04       	cpc	r0, r9
     1ae:	09 04       	cpc	r0, r9
     1b0:	09 04       	cpc	r0, r9
     1b2:	09 04       	cpc	r0, r9
     1b4:	09 04       	cpc	r0, r9
     1b6:	09 04       	cpc	r0, r9
     1b8:	09 04       	cpc	r0, r9
     1ba:	09 04       	cpc	r0, r9
     1bc:	09 04       	cpc	r0, r9
     1be:	09 04       	cpc	r0, r9
     1c0:	09 04       	cpc	r0, r9
     1c2:	09 04       	cpc	r0, r9
     1c4:	f5 03       	fmuls	r23, r21
     1c6:	f1 03       	fmuls	r23, r17
     1c8:	09 04       	cpc	r0, r9
     1ca:	f7 03       	fmuls	r23, r23
     1cc:	09 04       	cpc	r0, r9
     1ce:	09 04       	cpc	r0, r9
     1d0:	09 04       	cpc	r0, r9
     1d2:	f3 03       	fmuls	r23, r19

000001d4 <__ctors_start>:
     1d4:	4d 05       	cpc	r20, r13

000001d6 <__ctors_end>:
     1d6:	11 24       	eor	r1, r1
     1d8:	1f be       	out	0x3f, r1	; 63
     1da:	cf ef       	ldi	r28, 0xFF	; 255
     1dc:	d1 e2       	ldi	r29, 0x21	; 33
     1de:	de bf       	out	0x3e, r29	; 62
     1e0:	cd bf       	out	0x3d, r28	; 61
     1e2:	00 e0       	ldi	r16, 0x00	; 0
     1e4:	0c bf       	out	0x3c, r16	; 60

000001e6 <__do_copy_data>:
     1e6:	12 e0       	ldi	r17, 0x02	; 2
     1e8:	a0 e0       	ldi	r26, 0x00	; 0
     1ea:	b2 e0       	ldi	r27, 0x02	; 2
     1ec:	ec e4       	ldi	r30, 0x4C	; 76
     1ee:	f2 e3       	ldi	r31, 0x32	; 50
     1f0:	00 e0       	ldi	r16, 0x00	; 0
     1f2:	0b bf       	out	0x3b, r16	; 59
     1f4:	02 c0       	rjmp	.+4      	; 0x1fa <__do_copy_data+0x14>
     1f6:	07 90       	elpm	r0, Z+
     1f8:	0d 92       	st	X+, r0
     1fa:	a0 3d       	cpi	r26, 0xD0	; 208
     1fc:	b1 07       	cpc	r27, r17
     1fe:	d9 f7       	brne	.-10     	; 0x1f6 <__do_copy_data+0x10>

00000200 <__do_clear_bss>:
     200:	22 e1       	ldi	r18, 0x12	; 18
     202:	a0 ed       	ldi	r26, 0xD0	; 208
     204:	b2 e0       	ldi	r27, 0x02	; 2
     206:	01 c0       	rjmp	.+2      	; 0x20a <.do_clear_bss_start>

00000208 <.do_clear_bss_loop>:
     208:	1d 92       	st	X+, r1

0000020a <.do_clear_bss_start>:
     20a:	aa 3b       	cpi	r26, 0xBA	; 186
     20c:	b2 07       	cpc	r27, r18
     20e:	e1 f7       	brne	.-8      	; 0x208 <.do_clear_bss_loop>

00000210 <__do_global_ctors>:
     210:	10 e0       	ldi	r17, 0x00	; 0
     212:	cb ee       	ldi	r28, 0xEB	; 235
     214:	d0 e0       	ldi	r29, 0x00	; 0
     216:	00 e0       	ldi	r16, 0x00	; 0
     218:	06 c0       	rjmp	.+12     	; 0x226 <__do_global_ctors+0x16>
     21a:	21 97       	sbiw	r28, 0x01	; 1
     21c:	01 09       	sbc	r16, r1
     21e:	80 2f       	mov	r24, r16
     220:	fe 01       	movw	r30, r28
     222:	0e 94 a3 17 	call	0x2f46	; 0x2f46 <__tablejump2__>
     226:	ca 3e       	cpi	r28, 0xEA	; 234
     228:	d1 07       	cpc	r29, r17
     22a:	80 e0       	ldi	r24, 0x00	; 0
     22c:	08 07       	cpc	r16, r24
     22e:	a9 f7       	brne	.-22     	; 0x21a <__do_global_ctors+0xa>
     230:	00 d4       	rcall	.+2048   	; 0xa32 <main>
     232:	0c 94 24 19 	jmp	0x3248	; 0x3248 <_exit>

00000236 <__bad_interrupt>:
     236:	e4 ce       	rjmp	.-568    	; 0x0 <__vectors>

00000238 <_ZN5ColorC1Ev>:
}

uint8_t Color::getColorIndex( void )
{
	return _colorIndex;
}
     238:	08 95       	ret

0000023a <_ZN5Color12getRedPeriodEv>:
     23a:	fc 01       	movw	r30, r24
     23c:	80 81       	ld	r24, Z
     23e:	91 81       	ldd	r25, Z+1	; 0x01
     240:	08 95       	ret

00000242 <_ZN5Color13getBluePeriodEv>:
     242:	fc 01       	movw	r30, r24
     244:	82 81       	ldd	r24, Z+2	; 0x02
     246:	93 81       	ldd	r25, Z+3	; 0x03
     248:	08 95       	ret

0000024a <_ZN5Color14getGreenPeriodEv>:
     24a:	fc 01       	movw	r30, r24
     24c:	84 81       	ldd	r24, Z+4	; 0x04
     24e:	95 81       	ldd	r25, Z+5	; 0x05
     250:	08 95       	ret

00000252 <_ZN5Color14getWhitePeriodEv>:
     252:	fc 01       	movw	r30, r24
     254:	86 81       	ldd	r24, Z+6	; 0x06
     256:	97 81       	ldd	r25, Z+7	; 0x07
     258:	08 95       	ret

0000025a <_ZN5Color12setRedPeriodEj>:

void Color::setRedPeriod( uint16_t redPeriod )
{
	_redPeriod = redPeriod;
     25a:	fc 01       	movw	r30, r24
     25c:	71 83       	std	Z+1, r23	; 0x01
     25e:	60 83       	st	Z, r22
     260:	08 95       	ret

00000262 <_ZN5Color13setBluePeriodEj>:
}

void Color::setBluePeriod( uint16_t bluePeriod )
{
	_bluePeriod = bluePeriod;
     262:	fc 01       	movw	r30, r24
     264:	73 83       	std	Z+3, r23	; 0x03
     266:	62 83       	std	Z+2, r22	; 0x02
     268:	08 95       	ret

0000026a <_ZN5Color14setGreenPeriodEj>:
}

void Color::setGreenPeriod( uint16_t greenPeriod )
{
	_greenPeriod = greenPeriod;
     26a:	fc 01       	movw	r30, r24
     26c:	75 83       	std	Z+5, r23	; 0x05
     26e:	64 83       	std	Z+4, r22	; 0x04
     270:	08 95       	ret

00000272 <_ZN5Color14setWhitePeriodEj>:
}

void Color::setWhitePeriod( uint16_t whitePeriod )
{
	_whitePeriod = whitePeriod;
     272:	fc 01       	movw	r30, r24
     274:	77 83       	std	Z+7, r23	; 0x07
     276:	66 83       	std	Z+6, r22	; 0x06
     278:	08 95       	ret

0000027a <_ZN5Color13setColorIndexEh>:
}

void Color::setColorIndex( uint8_t index )
{
	_colorIndex = index;
     27a:	fc 01       	movw	r30, r24
     27c:	60 87       	std	Z+8, r22	; 0x08
     27e:	08 95       	ret

00000280 <_ZN11ColorSensor9setFilterE6Filter>:
	}
}

void ColorSensor::setFilter( Filter filter_ )
{
	switch ( filter_ )
     280:	61 30       	cpi	r22, 0x01	; 1
     282:	31 f0       	breq	.+12     	; 0x290 <_ZN11ColorSensor9setFilterE6Filter+0x10>
     284:	e8 f0       	brcs	.+58     	; 0x2c0 <_ZN11ColorSensor9setFilterE6Filter+0x40>
     286:	62 30       	cpi	r22, 0x02	; 2
     288:	99 f0       	breq	.+38     	; 0x2b0 <_ZN11ColorSensor9setFilterE6Filter+0x30>
     28a:	63 30       	cpi	r22, 0x03	; 3
     28c:	49 f0       	breq	.+18     	; 0x2a0 <_ZN11ColorSensor9setFilterE6Filter+0x20>
     28e:	08 95       	ret
	{
	case redFilter:
		COLORSENSOR_S2_PORT &= ~( COLORSENSOR_S2_PIN );
     290:	e2 e0       	ldi	r30, 0x02	; 2
     292:	f1 e0       	ldi	r31, 0x01	; 1
     294:	80 81       	ld	r24, Z
     296:	8e 7f       	andi	r24, 0xFE	; 254
     298:	80 83       	st	Z, r24
		COLORSENSOR_S3_PORT &= ~( COLORSENSOR_S3_PIN );
     29a:	80 81       	ld	r24, Z
     29c:	80 83       	st	Z, r24
		break;
     29e:	08 95       	ret

	case blueFilter:
		COLORSENSOR_S2_PORT &= ~( COLORSENSOR_S2_PIN );
     2a0:	e2 e0       	ldi	r30, 0x02	; 2
     2a2:	f1 e0       	ldi	r31, 0x01	; 1
     2a4:	80 81       	ld	r24, Z
     2a6:	8e 7f       	andi	r24, 0xFE	; 254
     2a8:	80 83       	st	Z, r24
		COLORSENSOR_S3_PORT |= COLORSENSOR_S3_PIN;
     2aa:	80 81       	ld	r24, Z
     2ac:	80 83       	st	Z, r24
		break;
     2ae:	08 95       	ret

	case greenFilter:
		COLORSENSOR_S2_PORT |= COLORSENSOR_S2_PIN;
     2b0:	e2 e0       	ldi	r30, 0x02	; 2
     2b2:	f1 e0       	ldi	r31, 0x01	; 1
     2b4:	80 81       	ld	r24, Z
     2b6:	81 60       	ori	r24, 0x01	; 1
     2b8:	80 83       	st	Z, r24
		COLORSENSOR_S3_PORT |= COLORSENSOR_S3_PIN;
     2ba:	80 81       	ld	r24, Z
     2bc:	80 83       	st	Z, r24
		break;
     2be:	08 95       	ret

	case noFilter:
		COLORSENSOR_S2_PORT |= COLORSENSOR_S2_PIN;
     2c0:	e2 e0       	ldi	r30, 0x02	; 2
     2c2:	f1 e0       	ldi	r31, 0x01	; 1
     2c4:	80 81       	ld	r24, Z
     2c6:	81 60       	ori	r24, 0x01	; 1
     2c8:	80 83       	st	Z, r24
		COLORSENSOR_S3_PORT &= ~( COLORSENSOR_S3_PIN );
     2ca:	80 81       	ld	r24, Z
     2cc:	80 83       	st	Z, r24
     2ce:	08 95       	ret

000002d0 <_ZN11ColorSensor8getColorEv>:
ColorSensor::~ColorSensor()
{	
}

uint8_t ColorSensor::getColor()
{
     2d0:	6f 92       	push	r6
     2d2:	7f 92       	push	r7
     2d4:	8f 92       	push	r8
     2d6:	9f 92       	push	r9
     2d8:	af 92       	push	r10
     2da:	bf 92       	push	r11
     2dc:	cf 92       	push	r12
     2de:	df 92       	push	r13
     2e0:	ef 92       	push	r14
     2e2:	ff 92       	push	r15
     2e4:	0f 93       	push	r16
     2e6:	1f 93       	push	r17
     2e8:	cf 93       	push	r28
     2ea:	df 93       	push	r29
     2ec:	8c 01       	movw	r16, r24
	uint8_t result = 255;
	
	// Get period values from all filters
	setFilter( redFilter );
     2ee:	61 e0       	ldi	r22, 0x01	; 1
     2f0:	c7 df       	rcall	.-114    	; 0x280 <_ZN11ColorSensor9setFilterE6Filter>
	uint16_t redPeriod = frequency_.getPeriod();
     2f2:	c8 01       	movw	r24, r16
     2f4:	41 d1       	rcall	.+642    	; 0x578 <_ZN6Timer49getPeriodEv>
     2f6:	7c 01       	movw	r14, r24

	setFilter( blueFilter );
     2f8:	63 e0       	ldi	r22, 0x03	; 3
     2fa:	c8 01       	movw	r24, r16
	uint16_t bluePeriod = frequency_.getPeriod();  
     2fc:	c1 df       	rcall	.-126    	; 0x280 <_ZN11ColorSensor9setFilterE6Filter>
     2fe:	c8 01       	movw	r24, r16
     300:	3b d1       	rcall	.+630    	; 0x578 <_ZN6Timer49getPeriodEv>

	setFilter( greenFilter );
     302:	6c 01       	movw	r12, r24
     304:	62 e0       	ldi	r22, 0x02	; 2
     306:	c8 01       	movw	r24, r16
	uint16_t greenPeriod = frequency_.getPeriod();
     308:	bb df       	rcall	.-138    	; 0x280 <_ZN11ColorSensor9setFilterE6Filter>
     30a:	c8 01       	movw	r24, r16
	
	setFilter( noFilter );
     30c:	35 d1       	rcall	.+618    	; 0x578 <_ZN6Timer49getPeriodEv>
     30e:	5c 01       	movw	r10, r24
     310:	60 e0       	ldi	r22, 0x00	; 0
     312:	c8 01       	movw	r24, r16
	uint16_t whitePeriod = frequency_.getPeriod();
     314:	b5 df       	rcall	.-150    	; 0x280 <_ZN11ColorSensor9setFilterE6Filter>
     316:	c8 01       	movw	r24, r16
     318:	2f d1       	rcall	.+606    	; 0x578 <_ZN6Timer49getPeriodEv>
     31a:	4c 01       	movw	r8, r24
	
	// Check all stored colors against read values	
	for ( uint8_t index = 0U; index < 10; index++)
     31c:	71 2c       	mov	r7, r1
     31e:	89 e0       	ldi	r24, 0x09	; 9
     320:	87 15       	cp	r24, r7
     322:	08 f4       	brcc	.+2      	; 0x326 <_ZN11ColorSensor8getColorEv+0x56>
     324:	5a c0       	rjmp	.+180    	; 0x3da <_ZN11ColorSensor8getColorEv+0x10a>
	{		
		if ( _colors[index].getRedPeriod() + 5 > redPeriod && _colors[index].getRedPeriod() - 5 < redPeriod )
     326:	c7 2d       	mov	r28, r7
     328:	d0 e0       	ldi	r29, 0x00	; 0
     32a:	ce 01       	movw	r24, r28
     32c:	88 0f       	add	r24, r24
     32e:	99 1f       	adc	r25, r25
     330:	88 0f       	add	r24, r24
     332:	99 1f       	adc	r25, r25
     334:	88 0f       	add	r24, r24
     336:	99 1f       	adc	r25, r25
     338:	c8 0f       	add	r28, r24
     33a:	d9 1f       	adc	r29, r25
     33c:	21 96       	adiw	r28, 0x01	; 1
     33e:	c0 0f       	add	r28, r16
     340:	d1 1f       	adc	r29, r17
     342:	ce 01       	movw	r24, r28
     344:	7a df       	rcall	.-268    	; 0x23a <_ZN5Color12getRedPeriodEv>
     346:	05 96       	adiw	r24, 0x05	; 5
     348:	e8 16       	cp	r14, r24
     34a:	f9 06       	cpc	r15, r25
     34c:	48 f4       	brcc	.+18     	; 0x360 <_ZN11ColorSensor8getColorEv+0x90>
     34e:	ce 01       	movw	r24, r28
     350:	74 df       	rcall	.-280    	; 0x23a <_ZN5Color12getRedPeriodEv>
     352:	05 97       	sbiw	r24, 0x05	; 5
     354:	8e 15       	cp	r24, r14
     356:	9f 05       	cpc	r25, r15
     358:	28 f4       	brcc	.+10     	; 0x364 <_ZN11ColorSensor8getColorEv+0x94>
     35a:	66 24       	eor	r6, r6
     35c:	63 94       	inc	r6
     35e:	03 c0       	rjmp	.+6      	; 0x366 <_ZN11ColorSensor8getColorEv+0x96>
     360:	61 2c       	mov	r6, r1
     362:	01 c0       	rjmp	.+2      	; 0x366 <_ZN11ColorSensor8getColorEv+0x96>
     364:	61 2c       	mov	r6, r1
		{
			if ( _colors[index].getBluePeriod() + 5 > bluePeriod && _colors[index].getBluePeriod() - 5 < bluePeriod )
     366:	66 20       	and	r6, r6
     368:	b1 f1       	breq	.+108    	; 0x3d6 <_ZN11ColorSensor8getColorEv+0x106>
     36a:	ce 01       	movw	r24, r28
     36c:	6a df       	rcall	.-300    	; 0x242 <_ZN5Color13getBluePeriodEv>
     36e:	05 96       	adiw	r24, 0x05	; 5
     370:	c8 16       	cp	r12, r24
     372:	d9 06       	cpc	r13, r25
     374:	38 f4       	brcc	.+14     	; 0x384 <_ZN11ColorSensor8getColorEv+0xb4>
     376:	ce 01       	movw	r24, r28
     378:	64 df       	rcall	.-312    	; 0x242 <_ZN5Color13getBluePeriodEv>
     37a:	05 97       	sbiw	r24, 0x05	; 5
     37c:	8c 15       	cp	r24, r12
     37e:	9d 05       	cpc	r25, r13
     380:	18 f4       	brcc	.+6      	; 0x388 <_ZN11ColorSensor8getColorEv+0xb8>
     382:	03 c0       	rjmp	.+6      	; 0x38a <_ZN11ColorSensor8getColorEv+0xba>
     384:	61 2c       	mov	r6, r1
     386:	01 c0       	rjmp	.+2      	; 0x38a <_ZN11ColorSensor8getColorEv+0xba>
     388:	61 2c       	mov	r6, r1
			{
				if ( _colors[index].getGreenPeriod() + 5 > greenPeriod && _colors[index].getGreenPeriod() - 5 < greenPeriod )
     38a:	66 20       	and	r6, r6
     38c:	21 f1       	breq	.+72     	; 0x3d6 <_ZN11ColorSensor8getColorEv+0x106>
     38e:	ce 01       	movw	r24, r28
     390:	5c df       	rcall	.-328    	; 0x24a <_ZN5Color14getGreenPeriodEv>
     392:	05 96       	adiw	r24, 0x05	; 5
     394:	a8 16       	cp	r10, r24
     396:	b9 06       	cpc	r11, r25
     398:	38 f4       	brcc	.+14     	; 0x3a8 <_ZN11ColorSensor8getColorEv+0xd8>
     39a:	ce 01       	movw	r24, r28
     39c:	56 df       	rcall	.-340    	; 0x24a <_ZN5Color14getGreenPeriodEv>
     39e:	05 97       	sbiw	r24, 0x05	; 5
     3a0:	8a 15       	cp	r24, r10
     3a2:	9b 05       	cpc	r25, r11
     3a4:	18 f4       	brcc	.+6      	; 0x3ac <_ZN11ColorSensor8getColorEv+0xdc>
     3a6:	03 c0       	rjmp	.+6      	; 0x3ae <_ZN11ColorSensor8getColorEv+0xde>
     3a8:	61 2c       	mov	r6, r1
     3aa:	01 c0       	rjmp	.+2      	; 0x3ae <_ZN11ColorSensor8getColorEv+0xde>
     3ac:	61 2c       	mov	r6, r1
				{
					if ( _colors[index].getWhitePeriod() + 2 > whitePeriod && _colors[index].getWhitePeriod() - 2 < whitePeriod )
     3ae:	66 20       	and	r6, r6
     3b0:	91 f0       	breq	.+36     	; 0x3d6 <_ZN11ColorSensor8getColorEv+0x106>
     3b2:	ce 01       	movw	r24, r28
     3b4:	4e df       	rcall	.-356    	; 0x252 <_ZN5Color14getWhitePeriodEv>
     3b6:	02 96       	adiw	r24, 0x02	; 2
     3b8:	88 16       	cp	r8, r24
     3ba:	99 06       	cpc	r9, r25
     3bc:	38 f4       	brcc	.+14     	; 0x3cc <_ZN11ColorSensor8getColorEv+0xfc>
     3be:	ce 01       	movw	r24, r28
     3c0:	48 df       	rcall	.-368    	; 0x252 <_ZN5Color14getWhitePeriodEv>
     3c2:	02 97       	sbiw	r24, 0x02	; 2
     3c4:	88 15       	cp	r24, r8
     3c6:	99 05       	cpc	r25, r9
     3c8:	18 f4       	brcc	.+6      	; 0x3d0 <_ZN11ColorSensor8getColorEv+0x100>
     3ca:	03 c0       	rjmp	.+6      	; 0x3d2 <_ZN11ColorSensor8getColorEv+0x102>
     3cc:	61 2c       	mov	r6, r1
     3ce:	01 c0       	rjmp	.+2      	; 0x3d2 <_ZN11ColorSensor8getColorEv+0x102>
     3d0:	61 2c       	mov	r6, r1
     3d2:	61 10       	cpse	r6, r1
     3d4:	04 c0       	rjmp	.+8      	; 0x3de <_ZN11ColorSensor8getColorEv+0x10e>
	
	setFilter( noFilter );
	uint16_t whitePeriod = frequency_.getPeriod();
	
	// Check all stored colors against read values	
	for ( uint8_t index = 0U; index < 10; index++)
     3d6:	73 94       	inc	r7
     3d8:	a2 cf       	rjmp	.-188    	; 0x31e <_ZN11ColorSensor8getColorEv+0x4e>
{	
}

uint8_t ColorSensor::getColor()
{
	uint8_t result = 255;
     3da:	77 24       	eor	r7, r7
     3dc:	7a 94       	dec	r7
		}
	}
	
	// Return value
	return result;
}
     3de:	87 2d       	mov	r24, r7
     3e0:	df 91       	pop	r29
     3e2:	cf 91       	pop	r28
     3e4:	1f 91       	pop	r17
     3e6:	0f 91       	pop	r16
     3e8:	ff 90       	pop	r15
     3ea:	ef 90       	pop	r14
     3ec:	df 90       	pop	r13
     3ee:	cf 90       	pop	r12
     3f0:	bf 90       	pop	r11
     3f2:	af 90       	pop	r10
     3f4:	9f 90       	pop	r9
     3f6:	8f 90       	pop	r8
     3f8:	7f 90       	pop	r7
     3fa:	6f 90       	pop	r6
     3fc:	08 95       	ret

000003fe <_ZN11ColorSensor17addCalibrateColorEh>:

void ColorSensor::addCalibrateColor( uint8_t colorIndex )
{
     3fe:	ff 92       	push	r15
     400:	0f 93       	push	r16
     402:	1f 93       	push	r17
     404:	cf 93       	push	r28
     406:	df 93       	push	r29
	if ( colorIndex < 10U )
     408:	6a 30       	cpi	r22, 0x0A	; 10
     40a:	08 f0       	brcs	.+2      	; 0x40e <__LOCK_REGION_LENGTH__+0xe>
     40c:	33 c0       	rjmp	.+102    	; 0x474 <__LOCK_REGION_LENGTH__+0x74>
     40e:	f6 2e       	mov	r15, r22
     410:	ec 01       	movw	r28, r24
	{	
		// Set all colors
		setFilter( redFilter );
     412:	61 e0       	ldi	r22, 0x01	; 1
     414:	35 df       	rcall	.-406    	; 0x280 <_ZN11ColorSensor9setFilterE6Filter>
		_colors[colorIndex].setRedPeriod( frequency_.getPeriod() );
     416:	ce 01       	movw	r24, r28
     418:	af d0       	rcall	.+350    	; 0x578 <_ZN6Timer49getPeriodEv>
     41a:	2f 2d       	mov	r18, r15
     41c:	30 e0       	ldi	r19, 0x00	; 0
     41e:	89 01       	movw	r16, r18
     420:	00 0f       	add	r16, r16
     422:	11 1f       	adc	r17, r17
     424:	00 0f       	add	r16, r16
     426:	11 1f       	adc	r17, r17
     428:	00 0f       	add	r16, r16
     42a:	11 1f       	adc	r17, r17
     42c:	02 0f       	add	r16, r18
     42e:	13 1f       	adc	r17, r19
     430:	0f 5f       	subi	r16, 0xFF	; 255
     432:	1f 4f       	sbci	r17, 0xFF	; 255
     434:	0c 0f       	add	r16, r28
     436:	1d 1f       	adc	r17, r29
     438:	bc 01       	movw	r22, r24
     43a:	c8 01       	movw	r24, r16
     43c:	0e df       	rcall	.-484    	; 0x25a <_ZN5Color12setRedPeriodEj>

		setFilter( blueFilter );
     43e:	63 e0       	ldi	r22, 0x03	; 3
     440:	ce 01       	movw	r24, r28
     442:	1e df       	rcall	.-452    	; 0x280 <_ZN11ColorSensor9setFilterE6Filter>
		_colors[colorIndex].setBluePeriod( frequency_.getPeriod() );
     444:	ce 01       	movw	r24, r28
     446:	98 d0       	rcall	.+304    	; 0x578 <_ZN6Timer49getPeriodEv>
     448:	bc 01       	movw	r22, r24
     44a:	c8 01       	movw	r24, r16
     44c:	0a df       	rcall	.-492    	; 0x262 <_ZN5Color13setBluePeriodEj>
		
		setFilter( greenFilter );
     44e:	62 e0       	ldi	r22, 0x02	; 2
     450:	ce 01       	movw	r24, r28
     452:	16 df       	rcall	.-468    	; 0x280 <_ZN11ColorSensor9setFilterE6Filter>
		_colors[colorIndex].setGreenPeriod( frequency_.getPeriod() );
     454:	ce 01       	movw	r24, r28
     456:	90 d0       	rcall	.+288    	; 0x578 <_ZN6Timer49getPeriodEv>
     458:	bc 01       	movw	r22, r24
     45a:	c8 01       	movw	r24, r16
     45c:	06 df       	rcall	.-500    	; 0x26a <_ZN5Color14setGreenPeriodEj>
		
		setFilter( noFilter );
     45e:	60 e0       	ldi	r22, 0x00	; 0
     460:	ce 01       	movw	r24, r28
     462:	0e df       	rcall	.-484    	; 0x280 <_ZN11ColorSensor9setFilterE6Filter>
		_colors[colorIndex].setWhitePeriod( frequency_.getPeriod() );
     464:	ce 01       	movw	r24, r28
     466:	88 d0       	rcall	.+272    	; 0x578 <_ZN6Timer49getPeriodEv>
     468:	bc 01       	movw	r22, r24
     46a:	c8 01       	movw	r24, r16
     46c:	02 df       	rcall	.-508    	; 0x272 <_ZN5Color14setWhitePeriodEj>
     46e:	6f 2d       	mov	r22, r15
     470:	c8 01       	movw	r24, r16
				
		// Set index
		_colors[colorIndex].setColorIndex( colorIndex );
     472:	03 df       	rcall	.-506    	; 0x27a <_ZN5Color13setColorIndexEh>
     474:	df 91       	pop	r29
     476:	cf 91       	pop	r28
     478:	1f 91       	pop	r17
	}
	else
	{
		/* Cant add more colors. Increase size of array. */
	}
}
     47a:	0f 91       	pop	r16
     47c:	ff 90       	pop	r15
     47e:	08 95       	ret

00000480 <_ZN11ColorSensor19setFrequencyscalingE16FrequencyScaling>:
     480:	61 30       	cpi	r22, 0x01	; 1
     482:	71 f0       	breq	.+28     	; 0x4a0 <_ZN11ColorSensor19setFrequencyscalingE16FrequencyScaling+0x20>
     484:	28 f0       	brcs	.+10     	; 0x490 <_ZN11ColorSensor19setFrequencyscalingE16FrequencyScaling+0x10>
	}	
}

void ColorSensor::setFrequencyscaling( FrequencyScaling scaling )
{
	switch (scaling)
     486:	62 30       	cpi	r22, 0x02	; 2
     488:	99 f0       	breq	.+38     	; 0x4b0 <_ZN11ColorSensor19setFrequencyscalingE16FrequencyScaling+0x30>
     48a:	63 30       	cpi	r22, 0x03	; 3
     48c:	c9 f0       	breq	.+50     	; 0x4c0 <_ZN11ColorSensor19setFrequencyscalingE16FrequencyScaling+0x40>
     48e:	08 95       	ret
	{
	case powerDown:
		COLORSENSOR_S0_PORT &= ~( COLORSENSOR_S0_PIN );
     490:	e5 e0       	ldi	r30, 0x05	; 5
     492:	f1 e0       	ldi	r31, 0x01	; 1
     494:	80 81       	ld	r24, Z
     496:	8e 7f       	andi	r24, 0xFE	; 254
     498:	80 83       	st	Z, r24
		COLORSENSOR_S1_PORT &= ~( COLORSENSOR_S1_PIN );
     49a:	80 81       	ld	r24, Z
     49c:	80 83       	st	Z, r24
		break;
     49e:	08 95       	ret

	case twoPercent:
		COLORSENSOR_S0_PORT &= ~( COLORSENSOR_S0_PIN );
     4a0:	e5 e0       	ldi	r30, 0x05	; 5
     4a2:	f1 e0       	ldi	r31, 0x01	; 1
     4a4:	80 81       	ld	r24, Z
     4a6:	8e 7f       	andi	r24, 0xFE	; 254
     4a8:	80 83       	st	Z, r24
		COLORSENSOR_S1_PORT |= COLORSENSOR_S1_PIN;
     4aa:	80 81       	ld	r24, Z
     4ac:	80 83       	st	Z, r24
		break;
     4ae:	08 95       	ret

	case twentyPercent:
		COLORSENSOR_S0_PORT |= COLORSENSOR_S0_PIN;
     4b0:	e5 e0       	ldi	r30, 0x05	; 5
     4b2:	f1 e0       	ldi	r31, 0x01	; 1
     4b4:	80 81       	ld	r24, Z
     4b6:	81 60       	ori	r24, 0x01	; 1
     4b8:	80 83       	st	Z, r24
		COLORSENSOR_S1_PORT &= ~( COLORSENSOR_S1_PIN );
     4ba:	80 81       	ld	r24, Z
     4bc:	80 83       	st	Z, r24
		break;
     4be:	08 95       	ret

	case hundredPercent:
		COLORSENSOR_S0_PORT |= COLORSENSOR_S0_PIN;
     4c0:	e5 e0       	ldi	r30, 0x05	; 5
     4c2:	f1 e0       	ldi	r31, 0x01	; 1
     4c4:	80 81       	ld	r24, Z
     4c6:	81 60       	ori	r24, 0x01	; 1
     4c8:	80 83       	st	Z, r24
		COLORSENSOR_S1_PORT |= COLORSENSOR_S1_PIN;
     4ca:	80 81       	ld	r24, Z
     4cc:	80 83       	st	Z, r24
     4ce:	08 95       	ret

000004d0 <_ZN11ColorSensorC1E16FrequencyScaling>:
#include "FreeRTOS.h"
#include "task.h"
#include "portmacro.h"

// default constructor
ColorSensor::ColorSensor( FrequencyScaling scaling )
     4d0:	bf 92       	push	r11
     4d2:	cf 92       	push	r12
     4d4:	df 92       	push	r13
     4d6:	ef 92       	push	r14
     4d8:	ff 92       	push	r15
     4da:	0f 93       	push	r16
     4dc:	1f 93       	push	r17
     4de:	cf 93       	push	r28
     4e0:	df 93       	push	r29
     4e2:	1f 92       	push	r1
     4e4:	cd b7       	in	r28, 0x3d	; 61
     4e6:	de b7       	in	r29, 0x3e	; 62
     4e8:	6c 01       	movw	r12, r24
     4ea:	b6 2e       	mov	r11, r22
     4ec:	26 d0       	rcall	.+76     	; 0x53a <_ZN6Timer4C1Ev>
     4ee:	76 01       	movw	r14, r12
     4f0:	8f ef       	ldi	r24, 0xFF	; 255
     4f2:	e8 1a       	sub	r14, r24
     4f4:	f8 0a       	sbc	r15, r24
     4f6:	09 e0       	ldi	r16, 0x09	; 9
     4f8:	10 e0       	ldi	r17, 0x00	; 0
     4fa:	0f 3f       	cpi	r16, 0xFF	; 255
     4fc:	8f ef       	ldi	r24, 0xFF	; 255
     4fe:	18 07       	cpc	r17, r24
     500:	41 f0       	breq	.+16     	; 0x512 <_ZN11ColorSensorC1E16FrequencyScaling+0x42>
     502:	c7 01       	movw	r24, r14
     504:	99 de       	rcall	.-718    	; 0x238 <_ZN5ColorC1Ev>
     506:	89 e0       	ldi	r24, 0x09	; 9
     508:	e8 0e       	add	r14, r24
     50a:	f1 1c       	adc	r15, r1
     50c:	01 50       	subi	r16, 0x01	; 1
     50e:	11 09       	sbc	r17, r1
     510:	f4 cf       	rjmp	.-24     	; 0x4fa <_ZN11ColorSensorC1E16FrequencyScaling+0x2a>
{
	frequency_ = Timer4();
     512:	ce 01       	movw	r24, r28
     514:	01 96       	adiw	r24, 0x01	; 1
     516:	11 d0       	rcall	.+34     	; 0x53a <_ZN6Timer4C1Ev>

	// Set default filter and scaling
	setFilter( noFilter );
     518:	60 e0       	ldi	r22, 0x00	; 0
     51a:	c6 01       	movw	r24, r12
     51c:	b1 de       	rcall	.-670    	; 0x280 <_ZN11ColorSensor9setFilterE6Filter>
	setFrequencyscaling( scaling );
     51e:	6b 2d       	mov	r22, r11
     520:	c6 01       	movw	r24, r12
     522:	ae df       	rcall	.-164    	; 0x480 <_ZN11ColorSensor19setFrequencyscalingE16FrequencyScaling>
     524:	0f 90       	pop	r0
}
     526:	df 91       	pop	r29
     528:	cf 91       	pop	r28
     52a:	1f 91       	pop	r17
     52c:	0f 91       	pop	r16
     52e:	ff 90       	pop	r15
     530:	ef 90       	pop	r14
     532:	df 90       	pop	r13
     534:	cf 90       	pop	r12
     536:	bf 90       	pop	r11
     538:	08 95       	ret

0000053a <_ZN6Timer4C1Ev>:
//volatile float tick = 0.000064;

Timer4::Timer4()
{
	// Set ports to the right values.
	COLORSENSOR_S0_PORT |= ( 1 << COLORSENSOR_S0_PIN );
     53a:	e5 e0       	ldi	r30, 0x05	; 5
     53c:	f1 e0       	ldi	r31, 0x01	; 1
     53e:	80 81       	ld	r24, Z
     540:	82 60       	ori	r24, 0x02	; 2
     542:	80 83       	st	Z, r24
	COLORSENSOR_S1_PORT |= ( 1 << COLORSENSOR_S1_PIN );
     544:	80 81       	ld	r24, Z
     546:	81 60       	ori	r24, 0x01	; 1
     548:	80 83       	st	Z, r24
	COLORSENSOR_S2_PORT |= ( 1 << COLORSENSOR_S2_PIN );
     54a:	e2 e0       	ldi	r30, 0x02	; 2
     54c:	f1 e0       	ldi	r31, 0x01	; 1
     54e:	80 81       	ld	r24, Z
     550:	82 60       	ori	r24, 0x02	; 2
     552:	80 83       	st	Z, r24
	COLORSENSOR_S3_PORT |= ( 1 << COLORSENSOR_S3_PIN );
     554:	80 81       	ld	r24, Z
     556:	81 60       	ori	r24, 0x01	; 1
     558:	80 83       	st	Z, r24
	
	// Setup timer to normal mode and pre scaler to 64
	TCCR4A = 0U;
     55a:	10 92 a0 00 	sts	0x00A0, r1	; 0x8000a0 <__TEXT_REGION_LENGTH__+0x7000a0>
	TCCR4B = ( 1 << ICNC4 ) | ( 1 << ICES4 ) | ( 1 << CS40 ) | ( 1 << CS41 );
     55e:	83 ec       	ldi	r24, 0xC3	; 195
     560:	80 93 a1 00 	sts	0x00A1, r24	; 0x8000a1 <__TEXT_REGION_LENGTH__+0x7000a1>
	TCCR4C = 0U;
     564:	10 92 a2 00 	sts	0x00A2, r1	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
	
	// Clear flags and set counter to zero
	TIFR4 = ( 1 << ICF4 ) | ( 1 << TOV4 );
     568:	81 e2       	ldi	r24, 0x21	; 33
     56a:	89 bb       	out	0x19, r24	; 25
	TCNT4 = 0;        
     56c:	10 92 a5 00 	sts	0x00A5, r1	; 0x8000a5 <__TEXT_REGION_LENGTH__+0x7000a5>
     570:	10 92 a4 00 	sts	0x00A4, r1	; 0x8000a4 <__TEXT_REGION_LENGTH__+0x7000a4>

	// Enable global interrupts
    sei();
     574:	78 94       	sei
     576:	08 95       	ret

00000578 <_ZN6Timer49getPeriodEv>:
}

uint16_t Timer4::getPeriod( void )
{
	// Reset all needed values
	first = true;
     578:	81 e0       	ldi	r24, 0x01	; 1
     57a:	80 93 0a 02 	sts	0x020A, r24	; 0x80020a <first>
	oldValue = 0U;
     57e:	10 92 d7 02 	sts	0x02D7, r1	; 0x8002d7 <oldValue+0x1>
     582:	10 92 d6 02 	sts	0x02D6, r1	; 0x8002d6 <oldValue>
	period = 0U;
     586:	10 92 d1 02 	sts	0x02D1, r1	; 0x8002d1 <__data_end+0x1>
     58a:	10 92 d0 02 	sts	0x02D0, r1	; 0x8002d0 <__data_end>
	timeroverflow = 0;
     58e:	10 92 d2 02 	sts	0x02D2, r1	; 0x8002d2 <timeroverflow>
     592:	10 92 d3 02 	sts	0x02D3, r1	; 0x8002d3 <timeroverflow+0x1>
     596:	10 92 d4 02 	sts	0x02D4, r1	; 0x8002d4 <timeroverflow+0x2>
     59a:	10 92 d5 02 	sts	0x02D5, r1	; 0x8002d5 <timeroverflow+0x3>
	
	// Enable interrupt and clear pending
	TIFR4 = ( 1 << ICF4 ) | ( 1 << TOV4 );
     59e:	81 e2       	ldi	r24, 0x21	; 33
     5a0:	89 bb       	out	0x19, r24	; 25
	TIMSK4 = ( 1 << ICIE4 ) | ( 1 << TOIE4 );	
     5a2:	80 93 72 00 	sts	0x0072, r24	; 0x800072 <__TEXT_REGION_LENGTH__+0x700072>
	
	// Wait until measurement has been taken
	while ( period == 0U )
     5a6:	80 91 d0 02 	lds	r24, 0x02D0	; 0x8002d0 <__data_end>
     5aa:	90 91 d1 02 	lds	r25, 0x02D1	; 0x8002d1 <__data_end+0x1>
     5ae:	89 2b       	or	r24, r25
     5b0:	81 f4       	brne	.+32     	; 0x5d2 <_ZN6Timer49getPeriodEv+0x5a>
	{
		if ( timeroverflow > 10U )
     5b2:	80 91 d2 02 	lds	r24, 0x02D2	; 0x8002d2 <timeroverflow>
     5b6:	90 91 d3 02 	lds	r25, 0x02D3	; 0x8002d3 <timeroverflow+0x1>
     5ba:	a0 91 d4 02 	lds	r26, 0x02D4	; 0x8002d4 <timeroverflow+0x2>
     5be:	b0 91 d5 02 	lds	r27, 0x02D5	; 0x8002d5 <timeroverflow+0x3>
     5c2:	0b 97       	sbiw	r24, 0x0b	; 11
     5c4:	a1 05       	cpc	r26, r1
     5c6:	b1 05       	cpc	r27, r1
     5c8:	70 f3       	brcs	.-36     	; 0x5a6 <_ZN6Timer49getPeriodEv+0x2e>
		{
			// Error - Disable interrupt and clear pending
			TIMSK4 = 0U;
     5ca:	10 92 72 00 	sts	0x0072, r1	; 0x800072 <__TEXT_REGION_LENGTH__+0x700072>
			TIFR4 = ( 1 << ICF4 ) | ( 1 << TOV4 );
     5ce:	81 e2       	ldi	r24, 0x21	; 33
     5d0:	89 bb       	out	0x19, r24	; 25
			break;
		}
	}
	
	return period;
     5d2:	80 91 d0 02 	lds	r24, 0x02D0	; 0x8002d0 <__data_end>
     5d6:	90 91 d1 02 	lds	r25, 0x02D1	; 0x8002d1 <__data_end+0x1>
}
     5da:	08 95       	ret

000005dc <__vector_45>:

ISR(TIMER4_OVF_vect)
{
     5dc:	1f 92       	push	r1
     5de:	0f 92       	push	r0
     5e0:	0f b6       	in	r0, 0x3f	; 63
     5e2:	0f 92       	push	r0
     5e4:	11 24       	eor	r1, r1
     5e6:	8f 93       	push	r24
     5e8:	9f 93       	push	r25
     5ea:	af 93       	push	r26
     5ec:	bf 93       	push	r27
	timeroverflow++;
     5ee:	80 91 d2 02 	lds	r24, 0x02D2	; 0x8002d2 <timeroverflow>
     5f2:	90 91 d3 02 	lds	r25, 0x02D3	; 0x8002d3 <timeroverflow+0x1>
     5f6:	a0 91 d4 02 	lds	r26, 0x02D4	; 0x8002d4 <timeroverflow+0x2>
     5fa:	b0 91 d5 02 	lds	r27, 0x02D5	; 0x8002d5 <timeroverflow+0x3>
     5fe:	01 96       	adiw	r24, 0x01	; 1
     600:	a1 1d       	adc	r26, r1
     602:	b1 1d       	adc	r27, r1
     604:	80 93 d2 02 	sts	0x02D2, r24	; 0x8002d2 <timeroverflow>
     608:	90 93 d3 02 	sts	0x02D3, r25	; 0x8002d3 <timeroverflow+0x1>
     60c:	a0 93 d4 02 	sts	0x02D4, r26	; 0x8002d4 <timeroverflow+0x2>
     610:	b0 93 d5 02 	sts	0x02D5, r27	; 0x8002d5 <timeroverflow+0x3>
}
     614:	bf 91       	pop	r27
     616:	af 91       	pop	r26
     618:	9f 91       	pop	r25
     61a:	8f 91       	pop	r24
     61c:	0f 90       	pop	r0
     61e:	0f be       	out	0x3f, r0	; 63
     620:	0f 90       	pop	r0
     622:	1f 90       	pop	r1
     624:	18 95       	reti

00000626 <__vector_41>:

ISR(TIMER4_CAPT_vect)
{
     626:	1f 92       	push	r1
     628:	0f 92       	push	r0
     62a:	0f b6       	in	r0, 0x3f	; 63
     62c:	0f 92       	push	r0
     62e:	11 24       	eor	r1, r1
     630:	0b b6       	in	r0, 0x3b	; 59
     632:	0f 92       	push	r0
     634:	cf 92       	push	r12
     636:	df 92       	push	r13
     638:	ef 92       	push	r14
     63a:	ff 92       	push	r15
     63c:	0f 93       	push	r16
     63e:	1f 93       	push	r17
     640:	2f 93       	push	r18
     642:	3f 93       	push	r19
     644:	4f 93       	push	r20
     646:	5f 93       	push	r21
     648:	6f 93       	push	r22
     64a:	7f 93       	push	r23
     64c:	8f 93       	push	r24
     64e:	9f 93       	push	r25
     650:	af 93       	push	r26
     652:	bf 93       	push	r27
     654:	ef 93       	push	r30
     656:	ff 93       	push	r31
	// Read value of timer
	uint16_t readValue = ICR4;
     658:	60 91 a6 00 	lds	r22, 0x00A6	; 0x8000a6 <__TEXT_REGION_LENGTH__+0x7000a6>
     65c:	70 91 a7 00 	lds	r23, 0x00A7	; 0x8000a7 <__TEXT_REGION_LENGTH__+0x7000a7>

	if ( first == true )
     660:	80 91 0a 02 	lds	r24, 0x020A	; 0x80020a <first>
     664:	88 23       	and	r24, r24
     666:	79 f0       	breq	.+30     	; 0x686 <__vector_41+0x60>
	{
		timeroverflow = 0U;
     668:	10 92 d2 02 	sts	0x02D2, r1	; 0x8002d2 <timeroverflow>
     66c:	10 92 d3 02 	sts	0x02D3, r1	; 0x8002d3 <timeroverflow+0x1>
     670:	10 92 d4 02 	sts	0x02D4, r1	; 0x8002d4 <timeroverflow+0x2>
     674:	10 92 d5 02 	sts	0x02D5, r1	; 0x8002d5 <timeroverflow+0x3>
		oldValue = readValue;
     678:	70 93 d7 02 	sts	0x02D7, r23	; 0x8002d7 <oldValue+0x1>
     67c:	60 93 d6 02 	sts	0x02D6, r22	; 0x8002d6 <oldValue>
		first = false;
     680:	10 92 0a 02 	sts	0x020A, r1	; 0x80020a <first>
		return;
     684:	81 c0       	rjmp	.+258    	; 0x788 <__vector_41+0x162>
	}
	
	// Check if overflow is pending
	if ( TIFR4 & ( 1 << TOV4 ))
     686:	c8 9b       	sbis	0x19, 0	; 25
     688:	13 c0       	rjmp	.+38     	; 0x6b0 <__vector_41+0x8a>
	{
		timeroverflow++;
     68a:	80 91 d2 02 	lds	r24, 0x02D2	; 0x8002d2 <timeroverflow>
     68e:	90 91 d3 02 	lds	r25, 0x02D3	; 0x8002d3 <timeroverflow+0x1>
     692:	a0 91 d4 02 	lds	r26, 0x02D4	; 0x8002d4 <timeroverflow+0x2>
     696:	b0 91 d5 02 	lds	r27, 0x02D5	; 0x8002d5 <timeroverflow+0x3>
     69a:	01 96       	adiw	r24, 0x01	; 1
     69c:	a1 1d       	adc	r26, r1
     69e:	b1 1d       	adc	r27, r1
     6a0:	80 93 d2 02 	sts	0x02D2, r24	; 0x8002d2 <timeroverflow>
     6a4:	90 93 d3 02 	sts	0x02D3, r25	; 0x8002d3 <timeroverflow+0x1>
     6a8:	a0 93 d4 02 	sts	0x02D4, r26	; 0x8002d4 <timeroverflow+0x2>
     6ac:	b0 93 d5 02 	sts	0x02D5, r27	; 0x8002d5 <timeroverflow+0x3>
	}
		
	// Disable interrupt and clear pending
	TIMSK4 = 0U;	
     6b0:	10 92 72 00 	sts	0x0072, r1	; 0x800072 <__TEXT_REGION_LENGTH__+0x700072>
	TIFR4 = ( 1 << ICF4 ) | ( 1 << TOV4 );		
     6b4:	81 e2       	ldi	r24, 0x21	; 33
     6b6:	89 bb       	out	0x19, r24	; 25
			
	// Calculate difference
	uint32_t diff = 0U;

	if ( readValue < oldValue )
     6b8:	80 91 d6 02 	lds	r24, 0x02D6	; 0x8002d6 <oldValue>
     6bc:	90 91 d7 02 	lds	r25, 0x02D7	; 0x8002d7 <oldValue+0x1>
     6c0:	68 17       	cp	r22, r24
     6c2:	79 07       	cpc	r23, r25
     6c4:	58 f5       	brcc	.+86     	; 0x71c <__vector_41+0xf6>
	{
		if ( timeroverflow != 0 )
     6c6:	80 91 d2 02 	lds	r24, 0x02D2	; 0x8002d2 <timeroverflow>
     6ca:	90 91 d3 02 	lds	r25, 0x02D3	; 0x8002d3 <timeroverflow+0x1>
     6ce:	a0 91 d4 02 	lds	r26, 0x02D4	; 0x8002d4 <timeroverflow+0x2>
     6d2:	b0 91 d5 02 	lds	r27, 0x02D5	; 0x8002d5 <timeroverflow+0x3>
     6d6:	89 2b       	or	r24, r25
     6d8:	8a 2b       	or	r24, r26
     6da:	8b 2b       	or	r24, r27
     6dc:	99 f0       	breq	.+38     	; 0x704 <__vector_41+0xde>
		{
			timeroverflow--;
     6de:	80 91 d2 02 	lds	r24, 0x02D2	; 0x8002d2 <timeroverflow>
     6e2:	90 91 d3 02 	lds	r25, 0x02D3	; 0x8002d3 <timeroverflow+0x1>
     6e6:	a0 91 d4 02 	lds	r26, 0x02D4	; 0x8002d4 <timeroverflow+0x2>
     6ea:	b0 91 d5 02 	lds	r27, 0x02D5	; 0x8002d5 <timeroverflow+0x3>
     6ee:	01 97       	sbiw	r24, 0x01	; 1
     6f0:	a1 09       	sbc	r26, r1
     6f2:	b1 09       	sbc	r27, r1
     6f4:	80 93 d2 02 	sts	0x02D2, r24	; 0x8002d2 <timeroverflow>
     6f8:	90 93 d3 02 	sts	0x02D3, r25	; 0x8002d3 <timeroverflow+0x1>
     6fc:	a0 93 d4 02 	sts	0x02D4, r26	; 0x8002d4 <timeroverflow+0x2>
     700:	b0 93 d5 02 	sts	0x02D5, r27	; 0x8002d5 <timeroverflow+0x3>
		}
		diff = ( 0xFFFF - oldValue ) + readValue;
     704:	80 91 d6 02 	lds	r24, 0x02D6	; 0x8002d6 <oldValue>
     708:	90 91 d7 02 	lds	r25, 0x02D7	; 0x8002d7 <oldValue+0x1>
     70c:	68 1b       	sub	r22, r24
     70e:	79 0b       	sbc	r23, r25
     710:	61 50       	subi	r22, 0x01	; 1
     712:	71 09       	sbc	r23, r1
     714:	cb 01       	movw	r24, r22
     716:	a0 e0       	ldi	r26, 0x00	; 0
     718:	b0 e0       	ldi	r27, 0x00	; 0
     71a:	09 c0       	rjmp	.+18     	; 0x72e <__vector_41+0x108>
	}
	else
	{
		diff = readValue - oldValue;
     71c:	80 91 d6 02 	lds	r24, 0x02D6	; 0x8002d6 <oldValue>
     720:	90 91 d7 02 	lds	r25, 0x02D7	; 0x8002d7 <oldValue+0x1>
     724:	68 1b       	sub	r22, r24
     726:	79 0b       	sbc	r23, r25
     728:	cb 01       	movw	r24, r22
     72a:	a0 e0       	ldi	r26, 0x00	; 0
     72c:	b0 e0       	ldi	r27, 0x00	; 0
	}
	
	// Add timeroverflow to total diff
	diff += timeroverflow << 16U;
     72e:	40 91 d2 02 	lds	r20, 0x02D2	; 0x8002d2 <timeroverflow>
     732:	50 91 d3 02 	lds	r21, 0x02D3	; 0x8002d3 <timeroverflow+0x1>
     736:	60 91 d4 02 	lds	r22, 0x02D4	; 0x8002d4 <timeroverflow+0x2>
     73a:	70 91 d5 02 	lds	r23, 0x02D5	; 0x8002d5 <timeroverflow+0x3>
     73e:	ba 01       	movw	r22, r20
     740:	55 27       	eor	r21, r21
     742:	44 27       	eor	r20, r20
     744:	8a 01       	movw	r16, r20
     746:	9b 01       	movw	r18, r22
     748:	08 0f       	add	r16, r24
     74a:	19 1f       	adc	r17, r25
     74c:	2a 1f       	adc	r18, r26
     74e:	3b 1f       	adc	r19, r27
     750:	c9 01       	movw	r24, r18
     752:	b8 01       	movw	r22, r16
	
	// Calculate period
	period = diff * tick * 1000000;
     754:	c0 90 06 02 	lds	r12, 0x0206	; 0x800206 <tick>
     758:	d0 90 07 02 	lds	r13, 0x0207	; 0x800207 <tick+0x1>
     75c:	e0 90 08 02 	lds	r14, 0x0208	; 0x800208 <tick+0x2>
     760:	f0 90 09 02 	lds	r15, 0x0209	; 0x800209 <tick+0x3>
     764:	0e 94 68 16 	call	0x2cd0	; 0x2cd0 <__floatunsisf>
     768:	a7 01       	movw	r20, r14
     76a:	96 01       	movw	r18, r12
     76c:	0e 94 1e 17 	call	0x2e3c	; 0x2e3c <__mulsf3>
     770:	20 e0       	ldi	r18, 0x00	; 0
     772:	34 e2       	ldi	r19, 0x24	; 36
     774:	44 e7       	ldi	r20, 0x74	; 116
     776:	59 e4       	ldi	r21, 0x49	; 73
     778:	0e 94 1e 17 	call	0x2e3c	; 0x2e3c <__mulsf3>
     77c:	0e 94 3c 16 	call	0x2c78	; 0x2c78 <__fixunssfsi>
     780:	70 93 d1 02 	sts	0x02D1, r23	; 0x8002d1 <__data_end+0x1>
     784:	60 93 d0 02 	sts	0x02D0, r22	; 0x8002d0 <__data_end>
     788:	ff 91       	pop	r31
     78a:	ef 91       	pop	r30
     78c:	bf 91       	pop	r27
     78e:	af 91       	pop	r26
     790:	9f 91       	pop	r25
     792:	8f 91       	pop	r24
     794:	7f 91       	pop	r23
     796:	6f 91       	pop	r22
     798:	5f 91       	pop	r21
     79a:	4f 91       	pop	r20
     79c:	3f 91       	pop	r19
     79e:	2f 91       	pop	r18
     7a0:	1f 91       	pop	r17
     7a2:	0f 91       	pop	r16
     7a4:	ff 90       	pop	r15
     7a6:	ef 90       	pop	r14
     7a8:	df 90       	pop	r13
     7aa:	cf 90       	pop	r12
     7ac:	0f 90       	pop	r0
     7ae:	0b be       	out	0x3b, r0	; 59
     7b0:	0f 90       	pop	r0
     7b2:	0f be       	out	0x3f, r0	; 63
     7b4:	0f 90       	pop	r0
     7b6:	1f 90       	pop	r1
     7b8:	18 95       	reti

000007ba <_ZN6KeyPadC1Ev>:
/* RTOS include */
#include "FreeRTOS.h"
#include "task.h"
#include "portmacro.h"

 KeyPad::KeyPad()
     7ba:	08 95       	ret

000007bc <_ZN6KeyPad7findKeyEh>:
	return pressed_key;
}

char KeyPad::findKey(uint8_t pin_press)
{
	switch(pin_press) {
     7bc:	86 2f       	mov	r24, r22
     7be:	90 e0       	ldi	r25, 0x00	; 0
     7c0:	fc 01       	movw	r30, r24
     7c2:	71 97       	sbiw	r30, 0x11	; 17
     7c4:	e8 37       	cpi	r30, 0x78	; 120
     7c6:	f1 05       	cpc	r31, r1
     7c8:	20 f5       	brcc	.+72     	; 0x812 <_ZN6KeyPad7findKeyEh+0x56>
     7ca:	88 27       	eor	r24, r24
     7cc:	ee 58       	subi	r30, 0x8E	; 142
     7ce:	ff 4f       	sbci	r31, 0xFF	; 255
     7d0:	8f 4f       	sbci	r24, 0xFF	; 255
     7d2:	0c 94 a3 17 	jmp	0x2f46	; 0x2f46 <__tablejump2__>
		
		case 0b01000010  :
			return '1';
     7d6:	81 e3       	ldi	r24, 0x31	; 49
     7d8:	08 95       	ret
		case 0b01001000  :
			return '2';
		case 0b01000001  :
			return '3';
     7da:	83 e3       	ldi	r24, 0x33	; 51
     7dc:	08 95       	ret
		case 0b01000100  :
			return 'A';
     7de:	81 e4       	ldi	r24, 0x41	; 65
     7e0:	08 95       	ret
			
		case 0b10000010  :
			return '4';
     7e2:	84 e3       	ldi	r24, 0x34	; 52
     7e4:	08 95       	ret
		case 0b10001000  :
			return '5';
     7e6:	85 e3       	ldi	r24, 0x35	; 53
     7e8:	08 95       	ret
		case 0b10000001  :
			return '6';
     7ea:	86 e3       	ldi	r24, 0x36	; 54
     7ec:	08 95       	ret
		case 0b10000100  :
			return 'B';
     7ee:	82 e4       	ldi	r24, 0x42	; 66
     7f0:	08 95       	ret
			
		case 0b00100010  :
			return '7';
     7f2:	87 e3       	ldi	r24, 0x37	; 55
     7f4:	08 95       	ret
		case 0b00101000  :
			return '8';
     7f6:	88 e3       	ldi	r24, 0x38	; 56
     7f8:	08 95       	ret
		case 0b00100001  :
			return '9';
     7fa:	89 e3       	ldi	r24, 0x39	; 57
     7fc:	08 95       	ret
		case 0b00100100  :
			return 'C';
     7fe:	83 e4       	ldi	r24, 0x43	; 67
     800:	08 95       	ret
			
		case 0b00010010  :
			return '*';
     802:	8a e2       	ldi	r24, 0x2A	; 42
     804:	08 95       	ret
		case 0b00011000  :
			return '0';
     806:	80 e3       	ldi	r24, 0x30	; 48
     808:	08 95       	ret
		case 0b00010001  :
			return '#';
     80a:	83 e2       	ldi	r24, 0x23	; 35
     80c:	08 95       	ret
		case 0b00010100  :
			return 'D';
     80e:	84 e4       	ldi	r24, 0x44	; 68
     810:	08 95       	ret
			
		
		// you can have any number of case statements.
		default : //Optional
			return 'E';
     812:	85 e4       	ldi	r24, 0x45	; 69
     814:	08 95       	ret
	switch(pin_press) {
		
		case 0b01000010  :
			return '1';
		case 0b01001000  :
			return '2';
     816:	82 e3       	ldi	r24, 0x32	; 50
		
		// you can have any number of case statements.
		default : //Optional
			return 'E';
	}
     818:	08 95       	ret

0000081a <_ZN6KeyPad12readKeyboardEv>:

 KeyPad::KeyPad()
{
}

char KeyPad::readKeyboard(){
     81a:	ef 92       	push	r14
     81c:	ff 92       	push	r15
     81e:	0f 93       	push	r16
     820:	1f 93       	push	r17
     822:	cf 93       	push	r28
     824:	8c 01       	movw	r16, r24
	
	uint8_t read_byte = 0; // Bytes to contain pressed char
	DDRK = 0b11110000; // Configure for Columns to be output and row to be input
     826:	80 ef       	ldi	r24, 0xF0	; 240
     828:	80 93 07 01 	sts	0x0107, r24	; 0x800107 <__TEXT_REGION_LENGTH__+0x700107>
	PORTK = 0b11110000; // Set Columns output to be high!
     82c:	80 93 08 01 	sts	0x0108, r24	; 0x800108 <__TEXT_REGION_LENGTH__+0x700108>
	
	vTaskDelay(8/portTICK_RATE_MS);	// Delays for allowing Pins to switch state from input to output and reverse
     830:	88 e0       	ldi	r24, 0x08	; 8
     832:	90 e0       	ldi	r25, 0x00	; 0
     834:	0e 94 6d 11 	call	0x22da	; 0x22da <vTaskDelay>
	
	while( (PINK & 0b00001111) == 0 );	// Wait for key pressed
     838:	80 91 06 01 	lds	r24, 0x0106	; 0x800106 <__TEXT_REGION_LENGTH__+0x700106>
     83c:	8f 70       	andi	r24, 0x0F	; 15
     83e:	e1 f3       	breq	.-8      	; 0x838 <_ZN6KeyPad12readKeyboardEv+0x1e>
	
	read_byte = (PINK & 0b00001111); // Get row of pressed key
     840:	0f 2e       	mov	r0, r31
     842:	f6 e0       	ldi	r31, 0x06	; 6
     844:	ef 2e       	mov	r14, r31
     846:	ff 24       	eor	r15, r15
     848:	f3 94       	inc	r15
     84a:	f0 2d       	mov	r31, r0
     84c:	f7 01       	movw	r30, r14
     84e:	c0 81       	ld	r28, Z
     850:	cf 70       	andi	r28, 0x0F	; 15
	
	DDRK = 0b00001111; // Switch Columns to be input and row to be output
     852:	8f e0       	ldi	r24, 0x0F	; 15
     854:	80 93 07 01 	sts	0x0107, r24	; 0x800107 <__TEXT_REGION_LENGTH__+0x700107>
	PORTK = 0b00001111; // Set Row outputs to be high!
     858:	80 93 08 01 	sts	0x0108, r24	; 0x800108 <__TEXT_REGION_LENGTH__+0x700108>
	
	vTaskDelay(8/portTICK_RATE_MS);
     85c:	88 e0       	ldi	r24, 0x08	; 8
     85e:	90 e0       	ldi	r25, 0x00	; 0
     860:	0e 94 6d 11 	call	0x22da	; 0x22da <vTaskDelay>
	
	char pressed_key = findKey(read_byte | (PINK & 0b11110000));
     864:	f7 01       	movw	r30, r14
     866:	60 81       	ld	r22, Z
     868:	60 7f       	andi	r22, 0xF0	; 240
     86a:	6c 2b       	or	r22, r28
     86c:	c8 01       	movw	r24, r16
     86e:	a6 df       	rcall	.-180    	; 0x7bc <_ZN6KeyPad7findKeyEh>
     870:	c8 2f       	mov	r28, r24
	
	// Wait for no key pressed anymore
	
	while((PINK & 0b11110000) != 0);
     872:	80 91 06 01 	lds	r24, 0x0106	; 0x800106 <__TEXT_REGION_LENGTH__+0x700106>
     876:	80 7f       	andi	r24, 0xF0	; 240
     878:	e1 f7       	brne	.-8      	; 0x872 <_ZN6KeyPad12readKeyboardEv+0x58>
	SendString("pressed key:\r\n");
     87a:	8e e0       	ldi	r24, 0x0E	; 14
     87c:	92 e0       	ldi	r25, 0x02	; 2
     87e:	0e 94 44 15 	call	0x2a88	; 0x2a88 <_Z10SendStringPc>
	SendInteger(pressed_key);
     882:	8c 2f       	mov	r24, r28
     884:	90 e0       	ldi	r25, 0x00	; 0
     886:	0e 94 50 15 	call	0x2aa0	; 0x2aa0 <_Z11SendIntegeri>
	SendString("\r\n");
     88a:	8a e1       	ldi	r24, 0x1A	; 26
     88c:	92 e0       	ldi	r25, 0x02	; 2
     88e:	0e 94 44 15 	call	0x2a88	; 0x2a88 <_Z10SendStringPc>
	return pressed_key;
}
     892:	8c 2f       	mov	r24, r28
     894:	cf 91       	pop	r28
     896:	1f 91       	pop	r17
     898:	0f 91       	pop	r16
     89a:	ff 90       	pop	r15
     89c:	ef 90       	pop	r14
     89e:	08 95       	ret

000008a0 <_ZN14LoginInterfaceC1Ev>:
#include <stdlib.h>
#include <avr/io.h>
#include "KeyPad.h"
#include "LoginInterface.h"

 LoginInterface::LoginInterface()
     8a0:	0f 93       	push	r16
     8a2:	1f 93       	push	r17
     8a4:	cf 93       	push	r28
     8a6:	df 93       	push	r29
     8a8:	1f 92       	push	r1
     8aa:	cd b7       	in	r28, 0x3d	; 61
     8ac:	de b7       	in	r29, 0x3e	; 62
     8ae:	8c 01       	movw	r16, r24
     8b0:	84 df       	rcall	.-248    	; 0x7ba <_ZN6KeyPadC1Ev>
 {
	 keypad = KeyPad();
     8b2:	ce 01       	movw	r24, r28
     8b4:	01 96       	adiw	r24, 0x01	; 1
     8b6:	81 df       	rcall	.-254    	; 0x7ba <_ZN6KeyPadC1Ev>
	 // ASCII Used since static declaration is not supported before STD c++ 11
	 passWord[0] = 49; // 1
     8b8:	81 e3       	ldi	r24, 0x31	; 49
     8ba:	f8 01       	movw	r30, r16
     8bc:	81 83       	std	Z+1, r24	; 0x01
	 passWord[1] = 52; // 4
     8be:	84 e3       	ldi	r24, 0x34	; 52
     8c0:	82 83       	std	Z+2, r24	; 0x02
	 passWord[2] = 55; // 7
     8c2:	87 e3       	ldi	r24, 0x37	; 55
     8c4:	83 83       	std	Z+3, r24	; 0x03
	 passWord[3] = 50; // 2
     8c6:	82 e3       	ldi	r24, 0x32	; 50
     8c8:	84 83       	std	Z+4, r24	; 0x04
	 stateOfMachine = 'L';
     8ca:	8c e4       	ldi	r24, 0x4C	; 76
     8cc:	85 83       	std	Z+5, r24	; 0x05
 }
     8ce:	0f 90       	pop	r0
     8d0:	df 91       	pop	r29
     8d2:	cf 91       	pop	r28
     8d4:	1f 91       	pop	r17
     8d6:	0f 91       	pop	r16
     8d8:	08 95       	ret

000008da <_ZN14LoginInterface17getstateOfMachineEv>:
 }
 
 char LoginInterface::getstateOfMachine()
 {
	 return stateOfMachine;
 }
     8da:	fc 01       	movw	r30, r24
     8dc:	85 81       	ldd	r24, Z+5	; 0x05
     8de:	08 95       	ret

000008e0 <_ZN14LoginInterface17setstateOfMachineEc>:
 
 void LoginInterface::setstateOfMachine(char state)
 {
	 stateOfMachine = state;
     8e0:	fc 01       	movw	r30, r24
     8e2:	65 83       	std	Z+5, r22	; 0x05
     8e4:	08 95       	ret

000008e6 <_ZN14LoginInterface10checkLoginEv>:
	 passWord[3] = 50; // 2
	 stateOfMachine = 'L';
 }
 
 bool LoginInterface::checkLogin()
 {
     8e6:	ef 92       	push	r14
     8e8:	ff 92       	push	r15
     8ea:	1f 93       	push	r17
     8ec:	cf 93       	push	r28
     8ee:	df 93       	push	r29
     8f0:	00 d0       	rcall	.+0      	; 0x8f2 <_ZN14LoginInterface10checkLoginEv+0xc>
     8f2:	1f 92       	push	r1
     8f4:	cd b7       	in	r28, 0x3d	; 61
     8f6:	de b7       	in	r29, 0x3e	; 62
     8f8:	7c 01       	movw	r14, r24
	 uint8_t userPressed = 0;
     8fa:	10 e0       	ldi	r17, 0x00	; 0
     8fc:	01 c0       	rjmp	.+2      	; 0x900 <_ZN14LoginInterface10checkLoginEv+0x1a>
	 {
		 char buf = keypad.readKeyboard();
		 
		 if (buf == 42)
		 {
			 userPressed = 0;
     8fe:	10 e0       	ldi	r17, 0x00	; 0
 bool LoginInterface::checkLogin()
 {
	 uint8_t userPressed = 0;
	 uint8_t userPass[4];
	 
	 while(userPressed < 4)
     900:	14 30       	cpi	r17, 0x04	; 4
     902:	68 f4       	brcc	.+26     	; 0x91e <_ZN14LoginInterface10checkLoginEv+0x38>
	 {
		 char buf = keypad.readKeyboard();
     904:	c7 01       	movw	r24, r14
     906:	89 df       	rcall	.-238    	; 0x81a <_ZN6KeyPad12readKeyboardEv>
		 
		 if (buf == 42)
     908:	8a 32       	cpi	r24, 0x2A	; 42
     90a:	c9 f3       	breq	.-14     	; 0x8fe <_ZN14LoginInterface10checkLoginEv+0x18>
		 {
			 userPressed = 0;
		 }else
		 {
			 userPass[userPressed] = buf;
     90c:	e1 e0       	ldi	r30, 0x01	; 1
     90e:	f0 e0       	ldi	r31, 0x00	; 0
     910:	ec 0f       	add	r30, r28
     912:	fd 1f       	adc	r31, r29
     914:	e1 0f       	add	r30, r17
     916:	f1 1d       	adc	r31, r1
     918:	80 83       	st	Z, r24
			 userPressed++; 
     91a:	1f 5f       	subi	r17, 0xFF	; 255
     91c:	f1 cf       	rjmp	.-30     	; 0x900 <_ZN14LoginInterface10checkLoginEv+0x1a>
     91e:	10 e0       	ldi	r17, 0x00	; 0
		 }
	 }
	 
	 for (uint8_t i = 0; i < 4; i++)
     920:	14 30       	cpi	r17, 0x04	; 4
     922:	a0 f4       	brcc	.+40     	; 0x94c <_ZN14LoginInterface10checkLoginEv+0x66>
	 {
		 if (userPass[i] != passWord[i])
     924:	81 2f       	mov	r24, r17
     926:	90 e0       	ldi	r25, 0x00	; 0
     928:	e1 e0       	ldi	r30, 0x01	; 1
     92a:	f0 e0       	ldi	r31, 0x00	; 0
     92c:	ec 0f       	add	r30, r28
     92e:	fd 1f       	adc	r31, r29
     930:	e8 0f       	add	r30, r24
     932:	f9 1f       	adc	r31, r25
     934:	20 81       	ld	r18, Z
     936:	f7 01       	movw	r30, r14
     938:	e8 0f       	add	r30, r24
     93a:	f9 1f       	adc	r31, r25
     93c:	81 81       	ldd	r24, Z+1	; 0x01
     93e:	28 17       	cp	r18, r24
     940:	19 f0       	breq	.+6      	; 0x948 <_ZN14LoginInterface10checkLoginEv+0x62>
		 {
			 setstateOfMachine('L');
     942:	6c e4       	ldi	r22, 0x4C	; 76
     944:	c7 01       	movw	r24, r14
     946:	cc df       	rcall	.-104    	; 0x8e0 <_ZN14LoginInterface17setstateOfMachineEc>
			 userPass[userPressed] = buf;
			 userPressed++; 
		 }
	 }
	 
	 for (uint8_t i = 0; i < 4; i++)
     948:	1f 5f       	subi	r17, 0xFF	; 255
		 if (userPass[i] != passWord[i])
		 {
			 setstateOfMachine('L');
		 }
	 }
	 if (getstateOfMachine() == 'L')
     94a:	ea cf       	rjmp	.-44     	; 0x920 <_ZN14LoginInterface10checkLoginEv+0x3a>
     94c:	c7 01       	movw	r24, r14
     94e:	c5 df       	rcall	.-118    	; 0x8da <_ZN14LoginInterface17getstateOfMachineEv>
     950:	8c 34       	cpi	r24, 0x4C	; 76
	 {
		 setstateOfMachine('U');
     952:	21 f4       	brne	.+8      	; 0x95c <_ZN14LoginInterface10checkLoginEv+0x76>
     954:	65 e5       	ldi	r22, 0x55	; 85
     956:	c7 01       	movw	r24, r14
     958:	c3 df       	rcall	.-122    	; 0x8e0 <_ZN14LoginInterface17setstateOfMachineEc>
	 }else
	 {
		 setstateOfMachine('L');	
     95a:	03 c0       	rjmp	.+6      	; 0x962 <_ZN14LoginInterface10checkLoginEv+0x7c>
     95c:	6c e4       	ldi	r22, 0x4C	; 76
     95e:	c7 01       	movw	r24, r14
     960:	bf df       	rcall	.-130    	; 0x8e0 <_ZN14LoginInterface17setstateOfMachineEc>
	 }
 }
     962:	0f 90       	pop	r0
     964:	0f 90       	pop	r0
     966:	0f 90       	pop	r0
     968:	0f 90       	pop	r0
     96a:	df 91       	pop	r29
     96c:	cf 91       	pop	r28
     96e:	1f 91       	pop	r17
     970:	ff 90       	pop	r15
     972:	ef 90       	pop	r14
     974:	08 95       	ret

00000976 <_Z11LoginKeyPadPv>:
void * operator new(size_t size);
void operator delete(void * ptr);

int __cxa_guard_acquire(__guard *g) {return !*(char *)(g);};
void __cxa_guard_release (__guard *g) {*(char *)g = 1;};
void __cxa_guard_abort (__guard *) {};
     976:	89 ed       	ldi	r24, 0xD9	; 217
     978:	92 e0       	ldi	r25, 0x02	; 2
     97a:	b5 df       	rcall	.-150    	; 0x8e6 <_ZN14LoginInterface10checkLoginEv>
     97c:	fc cf       	rjmp	.-8      	; 0x976 <_Z11LoginKeyPadPv>

0000097e <_Z10DisplayArmPv>:
     97e:	cf 93       	push	r28
     980:	df 93       	push	r29
     982:	cd b7       	in	r28, 0x3d	; 61
     984:	de b7       	in	r29, 0x3e	; 62
     986:	c1 57       	subi	r28, 0x71	; 113
     988:	d1 09       	sbc	r29, r1
     98a:	0f b6       	in	r0, 0x3f	; 63
     98c:	f8 94       	cli
     98e:	de bf       	out	0x3e, r29	; 62
     990:	0f be       	out	0x3f, r0	; 63
     992:	cd bf       	out	0x3d, r28	; 61
     994:	8c 01       	movw	r16, r24
     996:	62 e0       	ldi	r22, 0x02	; 2
     998:	ce 01       	movw	r24, r28
     99a:	01 96       	adiw	r24, 0x01	; 1
     99c:	99 dd       	rcall	.-1230   	; 0x4d0 <_ZN11ColorSensorC1E16FrequencyScaling>
     99e:	ce 01       	movw	r24, r28
     9a0:	84 5a       	subi	r24, 0xA4	; 164
     9a2:	9f 4f       	sbci	r25, 0xFF	; 255
     9a4:	0e 94 de 12 	call	0x25bc	; 0x25bc <_ZN11TouchscreenC1Ev>
     9a8:	ce 01       	movw	r24, r28
     9aa:	84 5a       	subi	r24, 0xA4	; 164
     9ac:	9f 4f       	sbci	r25, 0xFF	; 255
     9ae:	0e 94 e0 13 	call	0x27c0	; 0x27c0 <_ZN11Touchscreen11clearScreenEv>
     9b2:	89 ed       	ldi	r24, 0xD9	; 217
     9b4:	92 e0       	ldi	r25, 0x02	; 2
     9b6:	91 df       	rcall	.-222    	; 0x8da <_ZN14LoginInterface17getstateOfMachineEv>
     9b8:	85 35       	cpi	r24, 0x55	; 85
     9ba:	b1 f7       	brne	.-20     	; 0x9a8 <_Z10DisplayArmPv+0x2a>
     9bc:	ce 01       	movw	r24, r28
     9be:	84 5a       	subi	r24, 0xA4	; 164
     9c0:	9f 4f       	sbci	r25, 0xFF	; 255
     9c2:	0e 94 f5 13 	call	0x27ea	; 0x27ea <_ZN11Touchscreen23presentButtonsOnDisplayEv>
     9c6:	ce 01       	movw	r24, r28
     9c8:	84 5a       	subi	r24, 0xA4	; 164
     9ca:	9f 4f       	sbci	r25, 0xFF	; 255
     9cc:	0e 94 46 13 	call	0x268c	; 0x268c <_ZN11Touchscreen12checkButtonsEv>
     9d0:	81 30       	cpi	r24, 0x01	; 1
     9d2:	19 f0       	breq	.+6      	; 0x9da <_Z10DisplayArmPv+0x5c>
     9d4:	82 30       	cpi	r24, 0x02	; 2
     9d6:	81 f0       	breq	.+32     	; 0x9f8 <_Z10DisplayArmPv+0x7a>
     9d8:	ec cf       	rjmp	.-40     	; 0x9b2 <_Z10DisplayArmPv+0x34>
     9da:	8d e1       	ldi	r24, 0x1D	; 29
     9dc:	92 e0       	ldi	r25, 0x02	; 2
     9de:	0e 94 44 15 	call	0x2a88	; 0x2a88 <_Z10SendStringPc>
     9e2:	60 91 d8 02 	lds	r22, 0x02D8	; 0x8002d8 <colorIndex>
     9e6:	ce 01       	movw	r24, r28
     9e8:	01 96       	adiw	r24, 0x01	; 1
     9ea:	09 dd       	rcall	.-1518   	; 0x3fe <_ZN11ColorSensor17addCalibrateColorEh>
     9ec:	80 91 d8 02 	lds	r24, 0x02D8	; 0x8002d8 <colorIndex>
     9f0:	8f 5f       	subi	r24, 0xFF	; 255
     9f2:	80 93 d8 02 	sts	0x02D8, r24	; 0x8002d8 <colorIndex>
     9f6:	dd cf       	rjmp	.-70     	; 0x9b2 <_Z10DisplayArmPv+0x34>
     9f8:	8c e2       	ldi	r24, 0x2C	; 44
     9fa:	92 e0       	ldi	r25, 0x02	; 2
     9fc:	0e 94 44 15 	call	0x2a88	; 0x2a88 <_Z10SendStringPc>
     a00:	ce 01       	movw	r24, r28
     a02:	01 96       	adiw	r24, 0x01	; 1
     a04:	65 dc       	rcall	.-1846   	; 0x2d0 <_ZN11ColorSensor8getColorEv>
     a06:	68 2f       	mov	r22, r24
     a08:	c8 01       	movw	r24, r16
     a0a:	e9 d1       	rcall	.+978    	; 0xdde <_ZN8Robotarm8MoveItemEh>
     a0c:	d2 cf       	rjmp	.-92     	; 0x9b2 <_Z10DisplayArmPv+0x34>

00000a0e <_Z41__static_initialization_and_destruction_0ii>:
     a0e:	01 97       	sbiw	r24, 0x01	; 1
     a10:	31 f4       	brne	.+12     	; 0xa1e <_Z41__static_initialization_and_destruction_0ii+0x10>
     a12:	6f 3f       	cpi	r22, 0xFF	; 255
     a14:	7f 4f       	sbci	r23, 0xFF	; 255
     a16:	19 f4       	brne	.+6      	; 0xa1e <_Z41__static_initialization_and_destruction_0ii+0x10>
     a18:	89 ed       	ldi	r24, 0xD9	; 217
     a1a:	92 e0       	ldi	r25, 0x02	; 2
     a1c:	41 cf       	rjmp	.-382    	; 0x8a0 <_ZN14LoginInterfaceC1Ev>
     a1e:	08 95       	ret

00000a20 <__cxa_pure_virtual>:
     a20:	ff cf       	rjmp	.-2      	; 0xa20 <__cxa_pure_virtual>

00000a22 <_Znwj>:

void * operator new(size_t size)
{
	return malloc(size);
     a22:	0c 94 ba 17 	jmp	0x2f74	; 0x2f74 <malloc>
}
     a26:	08 95       	ret

00000a28 <_ZdlPv>:

void operator delete(void * ptr)
{
	ptr != NULL ? free(ptr) : void(0);
     a28:	00 97       	sbiw	r24, 0x00	; 0
     a2a:	11 f0       	breq	.+4      	; 0xa30 <_ZdlPv+0x8>
     a2c:	0c 94 52 18 	jmp	0x30a4	; 0x30a4 <free>
     a30:	08 95       	ret

00000a32 <main>:
		}
	}
}

int main(void)
{		
     a32:	cf 93       	push	r28
     a34:	df 93       	push	r29
     a36:	cd b7       	in	r28, 0x3d	; 61
     a38:	de b7       	in	r29, 0x3e	; 62
     a3a:	2e 97       	sbiw	r28, 0x0e	; 14
     a3c:	0f b6       	in	r0, 0x3f	; 63
     a3e:	f8 94       	cli
     a40:	de bf       	out	0x3e, r29	; 62
     a42:	0f be       	out	0x3f, r0	; 63
     a44:	cd bf       	out	0x3d, r28	; 61
	Robotarm arm = Robotarm();
     a46:	ce 01       	movw	r24, r28
     a48:	01 96       	adiw	r24, 0x01	; 1
     a4a:	43 d0       	rcall	.+134    	; 0xad2 <_ZN8RobotarmC1Ev>
	InitUART(9600,8,'N');
     a4c:	2e e4       	ldi	r18, 0x4E	; 78
     a4e:	48 e0       	ldi	r20, 0x08	; 8
     a50:	60 e8       	ldi	r22, 0x80	; 128
     a52:	75 e2       	ldi	r23, 0x25	; 37
     a54:	80 e0       	ldi	r24, 0x00	; 0
     a56:	90 e0       	ldi	r25, 0x00	; 0
     a58:	0e 94 f0 14 	call	0x29e0	; 0x29e0 <_Z8InitUARTmhc>
	xTaskCreate(LoginKeyPad,  ( signed char * ) "Keypad Task", configMAIN_STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL);
     a5c:	a1 2c       	mov	r10, r1
     a5e:	b1 2c       	mov	r11, r1
     a60:	c1 2c       	mov	r12, r1
     a62:	d1 2c       	mov	r13, r1
     a64:	e1 2c       	mov	r14, r1
     a66:	f1 2c       	mov	r15, r1
     a68:	00 e0       	ldi	r16, 0x00	; 0
     a6a:	20 e0       	ldi	r18, 0x00	; 0
     a6c:	30 e0       	ldi	r19, 0x00	; 0
     a6e:	48 e5       	ldi	r20, 0x58	; 88
     a70:	52 e0       	ldi	r21, 0x02	; 2
     a72:	6c e3       	ldi	r22, 0x3C	; 60
     a74:	72 e0       	ldi	r23, 0x02	; 2
     a76:	8b eb       	ldi	r24, 0xBB	; 187
     a78:	94 e0       	ldi	r25, 0x04	; 4
     a7a:	0e 94 6e 0f 	call	0x1edc	; 0x1edc <xTaskGenericCreate>
	xTaskCreate(DisplayArm,  ( signed char * ) "Display + Arm Task", configMAIN_STACK_SIZE, &arm, tskIDLE_PRIORITY, NULL);
     a7e:	9e 01       	movw	r18, r28
     a80:	2f 5f       	subi	r18, 0xFF	; 255
     a82:	3f 4f       	sbci	r19, 0xFF	; 255
     a84:	48 e5       	ldi	r20, 0x58	; 88
     a86:	52 e0       	ldi	r21, 0x02	; 2
     a88:	68 e4       	ldi	r22, 0x48	; 72
     a8a:	72 e0       	ldi	r23, 0x02	; 2
     a8c:	8f eb       	ldi	r24, 0xBF	; 191
     a8e:	94 e0       	ldi	r25, 0x04	; 4
     a90:	0e 94 6e 0f 	call	0x1edc	; 0x1edc <xTaskGenericCreate>
	vTaskStartScheduler();
     a94:	0e 94 26 10 	call	0x204c	; 0x204c <vTaskStartScheduler>
     a98:	ff cf       	rjmp	.-2      	; 0xa98 <main+0x66>

00000a9a <_GLOBAL__sub_I___cxa_pure_virtual>:

	while (1)
	{
	}
     a9a:	6f ef       	ldi	r22, 0xFF	; 255
     a9c:	7f ef       	ldi	r23, 0xFF	; 255
     a9e:	81 e0       	ldi	r24, 0x01	; 1
     aa0:	90 e0       	ldi	r25, 0x00	; 0
     aa2:	b5 cf       	rjmp	.-150    	; 0xa0e <_Z41__static_initialization_and_destruction_0ii>
     aa4:	08 95       	ret

00000aa6 <_ZN8Robotarm14startMotorImplEPv>:
	motors_[3]->SetDegrees(90);
	vTaskDelay( 250 / portTICK_RATE_MS );
}

void Robotarm::startMotorImpl( void *_this )
{
     aa6:	8c 01       	movw	r16, r24
void Robotarm::MotorSpeedController()
{
	while(1)
	{
		/* Move all motors one step. */
		for ( uint8_t i = 0U; i < 6U; i++ )
     aa8:	c0 e0       	ldi	r28, 0x00	; 0
     aaa:	c6 30       	cpi	r28, 0x06	; 6
     aac:	e8 f7       	brcc	.-6      	; 0xaa8 <_ZN8Robotarm14startMotorImplEPv+0x2>
		{
			motors_[i]->TurnMotor();
     aae:	ec 2f       	mov	r30, r28
     ab0:	f0 e0       	ldi	r31, 0x00	; 0
     ab2:	31 96       	adiw	r30, 0x01	; 1
     ab4:	ee 0f       	add	r30, r30
     ab6:	ff 1f       	adc	r31, r31
     ab8:	e0 0f       	add	r30, r16
     aba:	f1 1f       	adc	r31, r17
     abc:	80 81       	ld	r24, Z
     abe:	91 81       	ldd	r25, Z+1	; 0x01
     ac0:	dc 01       	movw	r26, r24
     ac2:	ed 91       	ld	r30, X+
     ac4:	fc 91       	ld	r31, X
     ac6:	04 80       	ldd	r0, Z+4	; 0x04
     ac8:	f5 81       	ldd	r31, Z+5	; 0x05
     aca:	e0 2d       	mov	r30, r0
     acc:	19 95       	eicall
void Robotarm::MotorSpeedController()
{
	while(1)
	{
		/* Move all motors one step. */
		for ( uint8_t i = 0U; i < 6U; i++ )
     ace:	cf 5f       	subi	r28, 0xFF	; 255
     ad0:	ec cf       	rjmp	.-40     	; 0xaaa <_ZN8Robotarm14startMotorImplEPv+0x4>

00000ad2 <_ZN8RobotarmC1Ev>:
/* RTOS include */
#include "FreeRTOS.h"
#include "task.h"
#include "portmacro.h"

Robotarm::Robotarm() : tmr1_(), tmr3_()
     ad2:	af 92       	push	r10
     ad4:	bf 92       	push	r11
     ad6:	cf 92       	push	r12
     ad8:	df 92       	push	r13
     ada:	ef 92       	push	r14
     adc:	ff 92       	push	r15
     ade:	0f 93       	push	r16
     ae0:	1f 93       	push	r17
     ae2:	cf 93       	push	r28
     ae4:	df 93       	push	r29
     ae6:	ec 01       	movw	r28, r24
     ae8:	d5 d5       	rcall	.+2986   	; 0x1694 <_ZN6Timer1C1Ev>
     aea:	8e 01       	movw	r16, r28
     aec:	0f 5f       	subi	r16, 0xFF	; 255
     aee:	1f 4f       	sbci	r17, 0xFF	; 255
     af0:	c8 01       	movw	r24, r16
     af2:	75 d6       	rcall	.+3306   	; 0x17de <_ZN6Timer5C1Ev>
{
	/* Create all motor objects */
	motors_[0] = new M1( &tmr1_ );
     af4:	89 e1       	ldi	r24, 0x19	; 25
     af6:	90 e0       	ldi	r25, 0x00	; 0
     af8:	94 df       	rcall	.-216    	; 0xa22 <_Znwj>
     afa:	7c 01       	movw	r14, r24
     afc:	be 01       	movw	r22, r28
     afe:	66 d2       	rcall	.+1228   	; 0xfcc <_ZN2M1C1EP6Timer1>
     b00:	fb 82       	std	Y+3, r15	; 0x03
     b02:	ea 82       	std	Y+2, r14	; 0x02
	motors_[1] = new M2( &tmr1_ );
     b04:	89 e1       	ldi	r24, 0x19	; 25
     b06:	90 e0       	ldi	r25, 0x00	; 0
     b08:	8c df       	rcall	.-232    	; 0xa22 <_Znwj>
     b0a:	7c 01       	movw	r14, r24
     b0c:	be 01       	movw	r22, r28
     b0e:	04 d3       	rcall	.+1544   	; 0x1118 <_ZN2M2C1EP6Timer1>
     b10:	fd 82       	std	Y+5, r15	; 0x05
     b12:	ec 82       	std	Y+4, r14	; 0x04
	motors_[2] = new M3( &tmr1_ );
     b14:	89 e1       	ldi	r24, 0x19	; 25
     b16:	90 e0       	ldi	r25, 0x00	; 0
     b18:	84 df       	rcall	.-248    	; 0xa22 <_Znwj>
     b1a:	7c 01       	movw	r14, r24
     b1c:	be 01       	movw	r22, r28
     b1e:	a2 d3       	rcall	.+1860   	; 0x1264 <_ZN2M3C1EP6Timer1>
     b20:	ff 82       	std	Y+7, r15	; 0x07
     b22:	ee 82       	std	Y+6, r14	; 0x06
	motors_[3] = new M4( &tmr3_ );
     b24:	89 e1       	ldi	r24, 0x19	; 25
     b26:	90 e0       	ldi	r25, 0x00	; 0
     b28:	7c df       	rcall	.-264    	; 0xa22 <_Znwj>
     b2a:	7c 01       	movw	r14, r24
     b2c:	b8 01       	movw	r22, r16
     b2e:	3e d4       	rcall	.+2172   	; 0x13ac <_ZN2M4C1EP6Timer5>
     b30:	f9 86       	std	Y+9, r15	; 0x09
     b32:	e8 86       	std	Y+8, r14	; 0x08
	motors_[4] = new M5( &tmr3_ );
     b34:	89 e1       	ldi	r24, 0x19	; 25
     b36:	90 e0       	ldi	r25, 0x00	; 0
     b38:	74 df       	rcall	.-280    	; 0xa22 <_Znwj>
     b3a:	7c 01       	movw	r14, r24
     b3c:	b8 01       	movw	r22, r16
     b3e:	da d4       	rcall	.+2484   	; 0x14f4 <_ZN2M5C1EP6Timer5>
     b40:	fb 86       	std	Y+11, r15	; 0x0b
     b42:	ea 86       	std	Y+10, r14	; 0x0a
	motors_[5] = new M6( &tmr3_ );
     b44:	89 e1       	ldi	r24, 0x19	; 25
     b46:	90 e0       	ldi	r25, 0x00	; 0
     b48:	6c df       	rcall	.-296    	; 0xa22 <_Znwj>
     b4a:	7c 01       	movw	r14, r24
     b4c:	b8 01       	movw	r22, r16
     b4e:	72 d5       	rcall	.+2788   	; 0x1634 <_ZN2M6C1EP6Timer5>
     b50:	fd 86       	std	Y+13, r15	; 0x0d
     b52:	ec 86       	std	Y+12, r14	; 0x0c
     b54:	a1 2c       	mov	r10, r1
     b56:	b1 2c       	mov	r11, r1
	
	/* Create task to control motors */
	xTaskCreate(this->startMotorImpl,  ( signed char * ) "Motors", configMAIN_STACK_SIZE, this, tskIDLE_PRIORITY, NULL);
     b58:	c1 2c       	mov	r12, r1
     b5a:	d1 2c       	mov	r13, r1
     b5c:	e1 2c       	mov	r14, r1
     b5e:	f1 2c       	mov	r15, r1
     b60:	00 e0       	ldi	r16, 0x00	; 0
     b62:	9e 01       	movw	r18, r28
     b64:	48 e5       	ldi	r20, 0x58	; 88
     b66:	52 e0       	ldi	r21, 0x02	; 2
     b68:	6b e5       	ldi	r22, 0x5B	; 91
     b6a:	72 e0       	ldi	r23, 0x02	; 2
     b6c:	83 e5       	ldi	r24, 0x53	; 83
     b6e:	95 e0       	ldi	r25, 0x05	; 5
     b70:	0e 94 6e 0f 	call	0x1edc	; 0x1edc <xTaskGenericCreate>
     b74:	df 91       	pop	r29
     b76:	cf 91       	pop	r28
}
     b78:	1f 91       	pop	r17
     b7a:	0f 91       	pop	r16
     b7c:	ff 90       	pop	r15
     b7e:	ef 90       	pop	r14
     b80:	df 90       	pop	r13
     b82:	cf 90       	pop	r12
     b84:	bf 90       	pop	r11
     b86:	af 90       	pop	r10
     b88:	08 95       	ret

00000b8a <_ZN8Robotarm9grabBlockEv>:
     b8a:	cf 93       	push	r28
     b8c:	df 93       	push	r29
		break;
	}
}

void Robotarm::grabBlock()
{
     b8e:	ec 01       	movw	r28, r24
	motors_[3]->SetDegrees(40);
     b90:	88 85       	ldd	r24, Y+8	; 0x08
     b92:	99 85       	ldd	r25, Y+9	; 0x09
     b94:	dc 01       	movw	r26, r24
     b96:	ed 91       	ld	r30, X+
     b98:	fc 91       	ld	r31, X
     b9a:	06 80       	ldd	r0, Z+6	; 0x06
     b9c:	f7 81       	ldd	r31, Z+7	; 0x07
     b9e:	e0 2d       	mov	r30, r0
     ba0:	68 e2       	ldi	r22, 0x28	; 40
     ba2:	19 95       	eicall
	motors_[4]->SetDegrees(90);
     ba4:	8a 85       	ldd	r24, Y+10	; 0x0a
     ba6:	9b 85       	ldd	r25, Y+11	; 0x0b
     ba8:	dc 01       	movw	r26, r24
     baa:	ed 91       	ld	r30, X+
     bac:	fc 91       	ld	r31, X
     bae:	06 80       	ldd	r0, Z+6	; 0x06
     bb0:	f7 81       	ldd	r31, Z+7	; 0x07
     bb2:	e0 2d       	mov	r30, r0
     bb4:	6a e5       	ldi	r22, 0x5A	; 90
     bb6:	19 95       	eicall
	motors_[0]->SetDegrees(0);
     bb8:	8a 81       	ldd	r24, Y+2	; 0x02
     bba:	9b 81       	ldd	r25, Y+3	; 0x03
     bbc:	dc 01       	movw	r26, r24
     bbe:	ed 91       	ld	r30, X+
     bc0:	fc 91       	ld	r31, X
     bc2:	06 80       	ldd	r0, Z+6	; 0x06
     bc4:	f7 81       	ldd	r31, Z+7	; 0x07
     bc6:	e0 2d       	mov	r30, r0
     bc8:	60 e0       	ldi	r22, 0x00	; 0
     bca:	19 95       	eicall
	vTaskDelay( 1500 / portTICK_RATE_MS );
     bcc:	8c ed       	ldi	r24, 0xDC	; 220
     bce:	95 e0       	ldi	r25, 0x05	; 5
     bd0:	0e 94 6d 11 	call	0x22da	; 0x22da <vTaskDelay>
	motors_[1]->SetDegrees(35);
     bd4:	8c 81       	ldd	r24, Y+4	; 0x04
     bd6:	9d 81       	ldd	r25, Y+5	; 0x05
     bd8:	dc 01       	movw	r26, r24
     bda:	ed 91       	ld	r30, X+
     bdc:	fc 91       	ld	r31, X
     bde:	06 80       	ldd	r0, Z+6	; 0x06
     be0:	f7 81       	ldd	r31, Z+7	; 0x07
     be2:	e0 2d       	mov	r30, r0
     be4:	63 e2       	ldi	r22, 0x23	; 35
     be6:	19 95       	eicall
	motors_[2]->SetDegrees(63);
     be8:	8e 81       	ldd	r24, Y+6	; 0x06
     bea:	9f 81       	ldd	r25, Y+7	; 0x07
     bec:	dc 01       	movw	r26, r24
     bee:	ed 91       	ld	r30, X+
     bf0:	fc 91       	ld	r31, X
     bf2:	06 80       	ldd	r0, Z+6	; 0x06
     bf4:	f7 81       	ldd	r31, Z+7	; 0x07
     bf6:	e0 2d       	mov	r30, r0
     bf8:	6f e3       	ldi	r22, 0x3F	; 63
     bfa:	19 95       	eicall
	vTaskDelay( 1500 / portTICK_RATE_MS );
     bfc:	8c ed       	ldi	r24, 0xDC	; 220
     bfe:	95 e0       	ldi	r25, 0x05	; 5
     c00:	0e 94 6d 11 	call	0x22da	; 0x22da <vTaskDelay>
	motors_[5]->SetDegrees(63);
     c04:	8c 85       	ldd	r24, Y+12	; 0x0c
     c06:	9d 85       	ldd	r25, Y+13	; 0x0d
     c08:	dc 01       	movw	r26, r24
     c0a:	ed 91       	ld	r30, X+
     c0c:	fc 91       	ld	r31, X
     c0e:	06 80       	ldd	r0, Z+6	; 0x06
     c10:	f7 81       	ldd	r31, Z+7	; 0x07
     c12:	e0 2d       	mov	r30, r0
     c14:	6f e3       	ldi	r22, 0x3F	; 63
     c16:	19 95       	eicall
	vTaskDelay( 250 / portTICK_RATE_MS );
     c18:	8a ef       	ldi	r24, 0xFA	; 250
     c1a:	90 e0       	ldi	r25, 0x00	; 0
     c1c:	0e 94 6d 11 	call	0x22da	; 0x22da <vTaskDelay>
	motors_[1]->SetDegrees(70);
     c20:	8c 81       	ldd	r24, Y+4	; 0x04
     c22:	9d 81       	ldd	r25, Y+5	; 0x05
     c24:	dc 01       	movw	r26, r24
     c26:	ed 91       	ld	r30, X+
     c28:	fc 91       	ld	r31, X
     c2a:	06 80       	ldd	r0, Z+6	; 0x06
     c2c:	f7 81       	ldd	r31, Z+7	; 0x07
     c2e:	e0 2d       	mov	r30, r0
     c30:	66 e4       	ldi	r22, 0x46	; 70
     c32:	19 95       	eicall
	motors_[2]->SetDegrees(70);
     c34:	8e 81       	ldd	r24, Y+6	; 0x06
     c36:	9f 81       	ldd	r25, Y+7	; 0x07
     c38:	dc 01       	movw	r26, r24
     c3a:	ed 91       	ld	r30, X+
     c3c:	fc 91       	ld	r31, X
     c3e:	06 80       	ldd	r0, Z+6	; 0x06
     c40:	f7 81       	ldd	r31, Z+7	; 0x07
     c42:	e0 2d       	mov	r30, r0
     c44:	66 e4       	ldi	r22, 0x46	; 70
     c46:	19 95       	eicall
	motors_[3]->SetDegrees(70);
     c48:	88 85       	ldd	r24, Y+8	; 0x08
     c4a:	99 85       	ldd	r25, Y+9	; 0x09
     c4c:	dc 01       	movw	r26, r24
     c4e:	ed 91       	ld	r30, X+
     c50:	fc 91       	ld	r31, X
     c52:	06 80       	ldd	r0, Z+6	; 0x06
     c54:	f7 81       	ldd	r31, Z+7	; 0x07
     c56:	e0 2d       	mov	r30, r0
     c58:	66 e4       	ldi	r22, 0x46	; 70
     c5a:	19 95       	eicall
}
     c5c:	df 91       	pop	r29
     c5e:	cf 91       	pop	r28
     c60:	08 95       	ret

00000c62 <_ZN8Robotarm18ArmDownReleaseItemEv>:
	motors_[0]->SetDegrees(180);
	ArmDownReleaseItem();
}

void Robotarm::ArmDownReleaseItem()
{
     c62:	cf 93       	push	r28
     c64:	df 93       	push	r29
     c66:	ec 01       	movw	r28, r24
	vTaskDelay( 1500 / portTICK_RATE_MS );
     c68:	8c ed       	ldi	r24, 0xDC	; 220
     c6a:	95 e0       	ldi	r25, 0x05	; 5
     c6c:	0e 94 6d 11 	call	0x22da	; 0x22da <vTaskDelay>
	motors_[1]->SetDegrees(35);
     c70:	8c 81       	ldd	r24, Y+4	; 0x04
     c72:	9d 81       	ldd	r25, Y+5	; 0x05
     c74:	dc 01       	movw	r26, r24
     c76:	ed 91       	ld	r30, X+
     c78:	fc 91       	ld	r31, X
     c7a:	06 80       	ldd	r0, Z+6	; 0x06
     c7c:	f7 81       	ldd	r31, Z+7	; 0x07
     c7e:	e0 2d       	mov	r30, r0
     c80:	63 e2       	ldi	r22, 0x23	; 35
     c82:	19 95       	eicall
	motors_[2]->SetDegrees(40);
     c84:	8e 81       	ldd	r24, Y+6	; 0x06
     c86:	9f 81       	ldd	r25, Y+7	; 0x07
     c88:	dc 01       	movw	r26, r24
     c8a:	ed 91       	ld	r30, X+
     c8c:	fc 91       	ld	r31, X
     c8e:	06 80       	ldd	r0, Z+6	; 0x06
     c90:	f7 81       	ldd	r31, Z+7	; 0x07
     c92:	e0 2d       	mov	r30, r0
     c94:	68 e2       	ldi	r22, 0x28	; 40
     c96:	19 95       	eicall
	vTaskDelay( 1500 / portTICK_RATE_MS );
     c98:	8c ed       	ldi	r24, 0xDC	; 220
     c9a:	95 e0       	ldi	r25, 0x05	; 5
     c9c:	0e 94 6d 11 	call	0x22da	; 0x22da <vTaskDelay>
	motors_[5]->SetDegrees(0);
     ca0:	8c 85       	ldd	r24, Y+12	; 0x0c
     ca2:	9d 85       	ldd	r25, Y+13	; 0x0d
     ca4:	dc 01       	movw	r26, r24
     ca6:	ed 91       	ld	r30, X+
     ca8:	fc 91       	ld	r31, X
     caa:	06 80       	ldd	r0, Z+6	; 0x06
     cac:	f7 81       	ldd	r31, Z+7	; 0x07
     cae:	e0 2d       	mov	r30, r0
     cb0:	60 e0       	ldi	r22, 0x00	; 0
     cb2:	19 95       	eicall
	vTaskDelay( 250 / portTICK_RATE_MS );
     cb4:	8a ef       	ldi	r24, 0xFA	; 250
     cb6:	90 e0       	ldi	r25, 0x00	; 0
     cb8:	0e 94 6d 11 	call	0x22da	; 0x22da <vTaskDelay>
	motors_[1]->SetDegrees(90);
     cbc:	8c 81       	ldd	r24, Y+4	; 0x04
     cbe:	9d 81       	ldd	r25, Y+5	; 0x05
     cc0:	dc 01       	movw	r26, r24
     cc2:	ed 91       	ld	r30, X+
     cc4:	fc 91       	ld	r31, X
     cc6:	06 80       	ldd	r0, Z+6	; 0x06
     cc8:	f7 81       	ldd	r31, Z+7	; 0x07
     cca:	e0 2d       	mov	r30, r0
     ccc:	6a e5       	ldi	r22, 0x5A	; 90
     cce:	19 95       	eicall
	motors_[2]->SetDegrees(90);
     cd0:	8e 81       	ldd	r24, Y+6	; 0x06
     cd2:	9f 81       	ldd	r25, Y+7	; 0x07
     cd4:	dc 01       	movw	r26, r24
     cd6:	ed 91       	ld	r30, X+
     cd8:	fc 91       	ld	r31, X
     cda:	06 80       	ldd	r0, Z+6	; 0x06
     cdc:	f7 81       	ldd	r31, Z+7	; 0x07
     cde:	e0 2d       	mov	r30, r0
     ce0:	6a e5       	ldi	r22, 0x5A	; 90
     ce2:	19 95       	eicall
	motors_[3]->SetDegrees(90);
     ce4:	88 85       	ldd	r24, Y+8	; 0x08
     ce6:	99 85       	ldd	r25, Y+9	; 0x09
     ce8:	dc 01       	movw	r26, r24
     cea:	ed 91       	ld	r30, X+
     cec:	fc 91       	ld	r31, X
     cee:	06 80       	ldd	r0, Z+6	; 0x06
     cf0:	f7 81       	ldd	r31, Z+7	; 0x07
     cf2:	e0 2d       	mov	r30, r0
     cf4:	6a e5       	ldi	r22, 0x5A	; 90
     cf6:	19 95       	eicall
	vTaskDelay( 250 / portTICK_RATE_MS );
     cf8:	8a ef       	ldi	r24, 0xFA	; 250
     cfa:	90 e0       	ldi	r25, 0x00	; 0
     cfc:	0e 94 6d 11 	call	0x22da	; 0x22da <vTaskDelay>
}
     d00:	df 91       	pop	r29
     d02:	cf 91       	pop	r28
     d04:	08 95       	ret

00000d06 <_ZN8Robotarm18moveBlockToZoneOneEv>:
	motors_[2]->SetDegrees(70);
	motors_[3]->SetDegrees(70);
}

void Robotarm::moveBlockToZoneOne()
{
     d06:	cf 93       	push	r28
     d08:	df 93       	push	r29
     d0a:	ec 01       	movw	r28, r24
	motors_[0]->SetDegrees(40);
     d0c:	8a 81       	ldd	r24, Y+2	; 0x02
     d0e:	9b 81       	ldd	r25, Y+3	; 0x03
     d10:	dc 01       	movw	r26, r24
     d12:	ed 91       	ld	r30, X+
     d14:	fc 91       	ld	r31, X
     d16:	06 80       	ldd	r0, Z+6	; 0x06
     d18:	f7 81       	ldd	r31, Z+7	; 0x07
     d1a:	e0 2d       	mov	r30, r0
     d1c:	68 e2       	ldi	r22, 0x28	; 40
     d1e:	19 95       	eicall
	ArmDownReleaseItem();
     d20:	ce 01       	movw	r24, r28
     d22:	9f df       	rcall	.-194    	; 0xc62 <_ZN8Robotarm18ArmDownReleaseItemEv>
}
     d24:	df 91       	pop	r29
     d26:	cf 91       	pop	r28
     d28:	08 95       	ret

00000d2a <_ZN8Robotarm18moveBlockToZoneTwoEv>:

void Robotarm::moveBlockToZoneTwo()
{
     d2a:	cf 93       	push	r28
     d2c:	df 93       	push	r29
     d2e:	ec 01       	movw	r28, r24
	motors_[0]->SetDegrees(68);
     d30:	8a 81       	ldd	r24, Y+2	; 0x02
     d32:	9b 81       	ldd	r25, Y+3	; 0x03
     d34:	dc 01       	movw	r26, r24
     d36:	ed 91       	ld	r30, X+
     d38:	fc 91       	ld	r31, X
     d3a:	06 80       	ldd	r0, Z+6	; 0x06
     d3c:	f7 81       	ldd	r31, Z+7	; 0x07
     d3e:	e0 2d       	mov	r30, r0
     d40:	64 e4       	ldi	r22, 0x44	; 68
     d42:	19 95       	eicall
	ArmDownReleaseItem();
     d44:	ce 01       	movw	r24, r28
     d46:	8d df       	rcall	.-230    	; 0xc62 <_ZN8Robotarm18ArmDownReleaseItemEv>
}
     d48:	df 91       	pop	r29
     d4a:	cf 91       	pop	r28
     d4c:	08 95       	ret

00000d4e <_ZN8Robotarm20moveBlockToZoneThreeEv>:

void Robotarm::moveBlockToZoneThree()
{
     d4e:	cf 93       	push	r28
     d50:	df 93       	push	r29
     d52:	ec 01       	movw	r28, r24
	motors_[0]->SetDegrees(96);
     d54:	8a 81       	ldd	r24, Y+2	; 0x02
     d56:	9b 81       	ldd	r25, Y+3	; 0x03
     d58:	dc 01       	movw	r26, r24
     d5a:	ed 91       	ld	r30, X+
     d5c:	fc 91       	ld	r31, X
     d5e:	06 80       	ldd	r0, Z+6	; 0x06
     d60:	f7 81       	ldd	r31, Z+7	; 0x07
     d62:	e0 2d       	mov	r30, r0
     d64:	60 e6       	ldi	r22, 0x60	; 96
     d66:	19 95       	eicall
	ArmDownReleaseItem();
     d68:	ce 01       	movw	r24, r28
     d6a:	7b df       	rcall	.-266    	; 0xc62 <_ZN8Robotarm18ArmDownReleaseItemEv>
}
     d6c:	df 91       	pop	r29
     d6e:	cf 91       	pop	r28
     d70:	08 95       	ret

00000d72 <_ZN8Robotarm19moveBlockToZoneFourEv>:

void Robotarm::moveBlockToZoneFour()
{
     d72:	cf 93       	push	r28
     d74:	df 93       	push	r29
     d76:	ec 01       	movw	r28, r24
	motors_[0]->SetDegrees(124);
     d78:	8a 81       	ldd	r24, Y+2	; 0x02
     d7a:	9b 81       	ldd	r25, Y+3	; 0x03
     d7c:	dc 01       	movw	r26, r24
     d7e:	ed 91       	ld	r30, X+
     d80:	fc 91       	ld	r31, X
     d82:	06 80       	ldd	r0, Z+6	; 0x06
     d84:	f7 81       	ldd	r31, Z+7	; 0x07
     d86:	e0 2d       	mov	r30, r0
     d88:	6c e7       	ldi	r22, 0x7C	; 124
     d8a:	19 95       	eicall
	ArmDownReleaseItem();
     d8c:	ce 01       	movw	r24, r28
     d8e:	69 df       	rcall	.-302    	; 0xc62 <_ZN8Robotarm18ArmDownReleaseItemEv>
}
     d90:	df 91       	pop	r29
     d92:	cf 91       	pop	r28
     d94:	08 95       	ret

00000d96 <_ZN8Robotarm19moveBlockToZoneFiveEv>:

void Robotarm::moveBlockToZoneFive()
{
     d96:	cf 93       	push	r28
     d98:	df 93       	push	r29
     d9a:	ec 01       	movw	r28, r24
	motors_[0]->SetDegrees(152);
     d9c:	8a 81       	ldd	r24, Y+2	; 0x02
     d9e:	9b 81       	ldd	r25, Y+3	; 0x03
     da0:	dc 01       	movw	r26, r24
     da2:	ed 91       	ld	r30, X+
     da4:	fc 91       	ld	r31, X
     da6:	06 80       	ldd	r0, Z+6	; 0x06
     da8:	f7 81       	ldd	r31, Z+7	; 0x07
     daa:	e0 2d       	mov	r30, r0
     dac:	68 e9       	ldi	r22, 0x98	; 152
     dae:	19 95       	eicall
	ArmDownReleaseItem();
     db0:	ce 01       	movw	r24, r28
     db2:	57 df       	rcall	.-338    	; 0xc62 <_ZN8Robotarm18ArmDownReleaseItemEv>
}
     db4:	df 91       	pop	r29
     db6:	cf 91       	pop	r28
     db8:	08 95       	ret

00000dba <_ZN8Robotarm18moveBlockToZoneSixEv>:

void Robotarm::moveBlockToZoneSix()
{
     dba:	cf 93       	push	r28
     dbc:	df 93       	push	r29
     dbe:	ec 01       	movw	r28, r24
	motors_[0]->SetDegrees(180);
     dc0:	8a 81       	ldd	r24, Y+2	; 0x02
     dc2:	9b 81       	ldd	r25, Y+3	; 0x03
     dc4:	dc 01       	movw	r26, r24
     dc6:	ed 91       	ld	r30, X+
     dc8:	fc 91       	ld	r31, X
     dca:	06 80       	ldd	r0, Z+6	; 0x06
     dcc:	f7 81       	ldd	r31, Z+7	; 0x07
     dce:	e0 2d       	mov	r30, r0
     dd0:	64 eb       	ldi	r22, 0xB4	; 180
     dd2:	19 95       	eicall
	ArmDownReleaseItem();
     dd4:	ce 01       	movw	r24, r28
     dd6:	45 df       	rcall	.-374    	; 0xc62 <_ZN8Robotarm18ArmDownReleaseItemEv>
}
     dd8:	df 91       	pop	r29
     dda:	cf 91       	pop	r28
     ddc:	08 95       	ret

00000dde <_ZN8Robotarm8MoveItemEh>:
	/* Create task to control motors */
	xTaskCreate(this->startMotorImpl,  ( signed char * ) "Motors", configMAIN_STACK_SIZE, this, tskIDLE_PRIORITY, NULL);
}

void Robotarm::MoveItem( uint8_t color )
{
     dde:	cf 93       	push	r28
     de0:	df 93       	push	r29
     de2:	ec 01       	movw	r28, r24
	switch ( color )
     de4:	62 30       	cpi	r22, 0x02	; 2
     de6:	29 f1       	breq	.+74     	; 0xe32 <_ZN8Robotarm8MoveItemEh+0x54>
     de8:	28 f4       	brcc	.+10     	; 0xdf4 <_ZN8Robotarm8MoveItemEh+0x16>
     dea:	66 23       	and	r22, r22
     dec:	51 f0       	breq	.+20     	; 0xe02 <_ZN8Robotarm8MoveItemEh+0x24>
     dee:	61 30       	cpi	r22, 0x01	; 1
     df0:	a1 f0       	breq	.+40     	; 0xe1a <_ZN8Robotarm8MoveItemEh+0x3c>
     df2:	4e c0       	rjmp	.+156    	; 0xe90 <_ZN8Robotarm8MoveItemEh+0xb2>
     df4:	64 30       	cpi	r22, 0x04	; 4
     df6:	a9 f1       	breq	.+106    	; 0xe62 <_ZN8Robotarm8MoveItemEh+0x84>
     df8:	40 f1       	brcs	.+80     	; 0xe4a <_ZN8Robotarm8MoveItemEh+0x6c>
     dfa:	65 30       	cpi	r22, 0x05	; 5
     dfc:	09 f4       	brne	.+2      	; 0xe00 <_ZN8Robotarm8MoveItemEh+0x22>
     dfe:	3d c0       	rjmp	.+122    	; 0xe7a <_ZN8Robotarm8MoveItemEh+0x9c>
     e00:	47 c0       	rjmp	.+142    	; 0xe90 <_ZN8Robotarm8MoveItemEh+0xb2>
	{
		case 0U:
		grabBlock();
     e02:	c3 de       	rcall	.-634    	; 0xb8a <_ZN8Robotarm9grabBlockEv>
		vTaskDelay( 500 / portTICK_RATE_MS ); // This might not be needed!!! it can be added in Robotarm!!!! we will seeee later
     e04:	84 ef       	ldi	r24, 0xF4	; 244
     e06:	91 e0       	ldi	r25, 0x01	; 1
     e08:	0e 94 6d 11 	call	0x22da	; 0x22da <vTaskDelay>
		moveBlockToZoneOne();
     e0c:	ce 01       	movw	r24, r28
     e0e:	7b df       	rcall	.-266    	; 0xd06 <_ZN8Robotarm18moveBlockToZoneOneEv>
		vTaskDelay( 500 / portTICK_RATE_MS );
     e10:	84 ef       	ldi	r24, 0xF4	; 244
     e12:	91 e0       	ldi	r25, 0x01	; 1
     e14:	0e 94 6d 11 	call	0x22da	; 0x22da <vTaskDelay>
		break;
		
		case 1U:
		grabBlock();
     e18:	3b c0       	rjmp	.+118    	; 0xe90 <_ZN8Robotarm8MoveItemEh+0xb2>
     e1a:	b7 de       	rcall	.-658    	; 0xb8a <_ZN8Robotarm9grabBlockEv>
		vTaskDelay( 500 / portTICK_RATE_MS );
     e1c:	84 ef       	ldi	r24, 0xF4	; 244
     e1e:	91 e0       	ldi	r25, 0x01	; 1
     e20:	0e 94 6d 11 	call	0x22da	; 0x22da <vTaskDelay>
		moveBlockToZoneTwo();
     e24:	ce 01       	movw	r24, r28
     e26:	81 df       	rcall	.-254    	; 0xd2a <_ZN8Robotarm18moveBlockToZoneTwoEv>
		vTaskDelay( 500 / portTICK_RATE_MS );
     e28:	84 ef       	ldi	r24, 0xF4	; 244
     e2a:	91 e0       	ldi	r25, 0x01	; 1
     e2c:	0e 94 6d 11 	call	0x22da	; 0x22da <vTaskDelay>
		break;
		
		case 2U:
		grabBlock();
     e30:	2f c0       	rjmp	.+94     	; 0xe90 <_ZN8Robotarm8MoveItemEh+0xb2>
     e32:	ab de       	rcall	.-682    	; 0xb8a <_ZN8Robotarm9grabBlockEv>
		vTaskDelay( 500 / portTICK_RATE_MS );
     e34:	84 ef       	ldi	r24, 0xF4	; 244
     e36:	91 e0       	ldi	r25, 0x01	; 1
     e38:	0e 94 6d 11 	call	0x22da	; 0x22da <vTaskDelay>
		moveBlockToZoneThree();
     e3c:	ce 01       	movw	r24, r28
		vTaskDelay( 500 / portTICK_RATE_MS );
     e3e:	87 df       	rcall	.-242    	; 0xd4e <_ZN8Robotarm20moveBlockToZoneThreeEv>
     e40:	84 ef       	ldi	r24, 0xF4	; 244
     e42:	91 e0       	ldi	r25, 0x01	; 1
     e44:	0e 94 6d 11 	call	0x22da	; 0x22da <vTaskDelay>
		break;
		
		case 3U:
		grabBlock();
     e48:	23 c0       	rjmp	.+70     	; 0xe90 <_ZN8Robotarm8MoveItemEh+0xb2>
		vTaskDelay( 500 / portTICK_RATE_MS );
     e4a:	9f de       	rcall	.-706    	; 0xb8a <_ZN8Robotarm9grabBlockEv>
     e4c:	84 ef       	ldi	r24, 0xF4	; 244
     e4e:	91 e0       	ldi	r25, 0x01	; 1
     e50:	0e 94 6d 11 	call	0x22da	; 0x22da <vTaskDelay>
		moveBlockToZoneFour();
     e54:	ce 01       	movw	r24, r28
		vTaskDelay( 500 / portTICK_RATE_MS );
     e56:	8d df       	rcall	.-230    	; 0xd72 <_ZN8Robotarm19moveBlockToZoneFourEv>
     e58:	84 ef       	ldi	r24, 0xF4	; 244
     e5a:	91 e0       	ldi	r25, 0x01	; 1
		break;
     e5c:	0e 94 6d 11 	call	0x22da	; 0x22da <vTaskDelay>
		
		case 4U:
		grabBlock();
     e60:	17 c0       	rjmp	.+46     	; 0xe90 <_ZN8Robotarm8MoveItemEh+0xb2>
		vTaskDelay( 500 / portTICK_RATE_MS );
     e62:	93 de       	rcall	.-730    	; 0xb8a <_ZN8Robotarm9grabBlockEv>
     e64:	84 ef       	ldi	r24, 0xF4	; 244
     e66:	91 e0       	ldi	r25, 0x01	; 1
		moveBlockToZoneFive();
     e68:	0e 94 6d 11 	call	0x22da	; 0x22da <vTaskDelay>
     e6c:	ce 01       	movw	r24, r28
		vTaskDelay( 500 / portTICK_RATE_MS );
     e6e:	93 df       	rcall	.-218    	; 0xd96 <_ZN8Robotarm19moveBlockToZoneFiveEv>
     e70:	84 ef       	ldi	r24, 0xF4	; 244
     e72:	91 e0       	ldi	r25, 0x01	; 1
		break;
     e74:	0e 94 6d 11 	call	0x22da	; 0x22da <vTaskDelay>
		
		case 5U:
		grabBlock();
     e78:	0b c0       	rjmp	.+22     	; 0xe90 <_ZN8Robotarm8MoveItemEh+0xb2>
		vTaskDelay( 500 / portTICK_RATE_MS );
     e7a:	87 de       	rcall	.-754    	; 0xb8a <_ZN8Robotarm9grabBlockEv>
     e7c:	84 ef       	ldi	r24, 0xF4	; 244
     e7e:	91 e0       	ldi	r25, 0x01	; 1
     e80:	0e 94 6d 11 	call	0x22da	; 0x22da <vTaskDelay>
		moveBlockToZoneSix();
     e84:	ce 01       	movw	r24, r28
     e86:	99 df       	rcall	.-206    	; 0xdba <_ZN8Robotarm18moveBlockToZoneSixEv>
		vTaskDelay( 500 / portTICK_RATE_MS );
     e88:	84 ef       	ldi	r24, 0xF4	; 244
     e8a:	91 e0       	ldi	r25, 0x01	; 1
     e8c:	0e 94 6d 11 	call	0x22da	; 0x22da <vTaskDelay>
		break;
		
		default:
		break;
	}
}
     e90:	df 91       	pop	r29
     e92:	cf 91       	pop	r28
     e94:	08 95       	ret

00000e96 <_ZN5Motor10SetDegreesEh>:
	*	 can be used to turn motor at a specific speed set by \ref delay. C
	*	 Note that this function needs to run multiple times to work as intended.
	*    @param uint8_t	degrees to turn
	*    @return void Nothing
	*/
	virtual void SetDegrees( uint8_t degrees )
     e96:	cf 92       	push	r12
     e98:	df 92       	push	r13
     e9a:	ef 92       	push	r14
     e9c:	ff 92       	push	r15
     e9e:	cf 93       	push	r28
     ea0:	df 93       	push	r29
	{
		if ( maxDegrees_ >= degrees )
     ea2:	fc 01       	movw	r30, r24
     ea4:	26 89       	ldd	r18, Z+22	; 0x16
     ea6:	26 17       	cp	r18, r22
     ea8:	c0 f0       	brcs	.+48     	; 0xeda <_ZN5Motor10SetDegreesEh+0x44>
     eaa:	ec 01       	movw	r28, r24
		{
			percent_ = percentPrDeg * degrees + startpercent_;
     eac:	c6 80       	ldd	r12, Z+6	; 0x06
     eae:	d7 80       	ldd	r13, Z+7	; 0x07
     eb0:	e0 84       	ldd	r14, Z+8	; 0x08
     eb2:	f1 84       	ldd	r15, Z+9	; 0x09
     eb4:	70 e0       	ldi	r23, 0x00	; 0
     eb6:	80 e0       	ldi	r24, 0x00	; 0
     eb8:	90 e0       	ldi	r25, 0x00	; 0
     eba:	0e 94 6a 16 	call	0x2cd4	; 0x2cd4 <__floatsisf>
     ebe:	a7 01       	movw	r20, r14
     ec0:	96 01       	movw	r18, r12
     ec2:	0e 94 1e 17 	call	0x2e3c	; 0x2e3c <__mulsf3>
     ec6:	2a 89       	ldd	r18, Y+18	; 0x12
     ec8:	3b 89       	ldd	r19, Y+19	; 0x13
     eca:	4c 89       	ldd	r20, Y+20	; 0x14
     ecc:	5d 89       	ldd	r21, Y+21	; 0x15
     ece:	0e 94 6c 15 	call	0x2ad8	; 0x2ad8 <__addsf3>
     ed2:	6a 87       	std	Y+10, r22	; 0x0a
     ed4:	7b 87       	std	Y+11, r23	; 0x0b
     ed6:	8c 87       	std	Y+12, r24	; 0x0c
     ed8:	9d 87       	std	Y+13, r25	; 0x0d
		}
	}
     eda:	df 91       	pop	r29
     edc:	cf 91       	pop	r28
     ede:	ff 90       	pop	r15
     ee0:	ef 90       	pop	r14
     ee2:	df 90       	pop	r13
     ee4:	cf 90       	pop	r12
     ee6:	08 95       	ret

00000ee8 <_ZN2M1D1Ev>:

class Motor
{
//functions
public:
	virtual ~Motor() {};
     ee8:	26 e6       	ldi	r18, 0x66	; 102
     eea:	32 e0       	ldi	r19, 0x02	; 2
     eec:	fc 01       	movw	r30, r24
     eee:	31 83       	std	Z+1, r19	; 0x01
     ef0:	20 83       	st	Z, r18
     ef2:	08 95       	ret

00000ef4 <_ZN2M1D0Ev>:
	SetDegrees( 90 );
	tmr1Ptr_->setDutyCycleComA( percent_ );
	oldPercent_ = percent_;
} 

M1::~M1()
     ef4:	cf 93       	push	r28
     ef6:	df 93       	push	r29
     ef8:	ec 01       	movw	r28, r24
{
}
     efa:	f6 df       	rcall	.-20     	; 0xee8 <_ZN2M1D1Ev>
     efc:	ce 01       	movw	r24, r28
     efe:	94 dd       	rcall	.-1240   	; 0xa28 <_ZdlPv>
     f00:	df 91       	pop	r29
     f02:	cf 91       	pop	r28
     f04:	08 95       	ret

00000f06 <_ZN2M19TurnMotorEv>:

void M1::TurnMotor()
{
     f06:	4f 92       	push	r4
     f08:	5f 92       	push	r5
     f0a:	6f 92       	push	r6
     f0c:	7f 92       	push	r7
     f0e:	8f 92       	push	r8
     f10:	9f 92       	push	r9
     f12:	af 92       	push	r10
     f14:	bf 92       	push	r11
     f16:	cf 92       	push	r12
     f18:	df 92       	push	r13
     f1a:	ef 92       	push	r14
     f1c:	ff 92       	push	r15
     f1e:	cf 93       	push	r28
     f20:	df 93       	push	r29
     f22:	ec 01       	movw	r28, r24
	if ( percent_ > oldPercent_ + PERCENT_PR_TICK )
     f24:	8a 84       	ldd	r8, Y+10	; 0x0a
     f26:	9b 84       	ldd	r9, Y+11	; 0x0b
     f28:	ac 84       	ldd	r10, Y+12	; 0x0c
     f2a:	bd 84       	ldd	r11, Y+13	; 0x0d
     f2c:	ce 84       	ldd	r12, Y+14	; 0x0e
     f2e:	df 84       	ldd	r13, Y+15	; 0x0f
     f30:	e8 88       	ldd	r14, Y+16	; 0x10
     f32:	f9 88       	ldd	r15, Y+17	; 0x11
     f34:	20 e0       	ldi	r18, 0x00	; 0
     f36:	30 e0       	ldi	r19, 0x00	; 0
     f38:	40 e8       	ldi	r20, 0x80	; 128
     f3a:	5d e3       	ldi	r21, 0x3D	; 61
     f3c:	c7 01       	movw	r24, r14
     f3e:	b6 01       	movw	r22, r12
     f40:	0e 94 6c 15 	call	0x2ad8	; 0x2ad8 <__addsf3>
     f44:	2b 01       	movw	r4, r22
     f46:	3c 01       	movw	r6, r24
     f48:	9b 01       	movw	r18, r22
     f4a:	ac 01       	movw	r20, r24
     f4c:	c5 01       	movw	r24, r10
     f4e:	b4 01       	movw	r22, r8
     f50:	0e 94 1a 17 	call	0x2e34	; 0x2e34 <__gesf2>
     f54:	18 16       	cp	r1, r24
     f56:	74 f4       	brge	.+28     	; 0xf74 <_ZN2M19TurnMotorEv+0x6e>
	{
		oldPercent_ += PERCENT_PR_TICK;
     f58:	4e 86       	std	Y+14, r4	; 0x0e
     f5a:	5f 86       	std	Y+15, r5	; 0x0f
     f5c:	68 8a       	std	Y+16, r6	; 0x10
     f5e:	79 8a       	std	Y+17, r7	; 0x11
		tmr1Ptr_->setDutyCycleComA( oldPercent_ );
     f60:	b3 01       	movw	r22, r6
     f62:	a2 01       	movw	r20, r4
     f64:	8a 81       	ldd	r24, Y+2	; 0x02
     f66:	9b 81       	ldd	r25, Y+3	; 0x03
     f68:	b9 d3       	rcall	.+1906   	; 0x16dc <_ZN6Timer116setDutyCycleComAEf>
		vTaskDelay( delay_ / portTICK_RATE_MS );
     f6a:	8f 89       	ldd	r24, Y+23	; 0x17
     f6c:	98 8d       	ldd	r25, Y+24	; 0x18
     f6e:	0e 94 6d 11 	call	0x22da	; 0x22da <vTaskDelay>
     f72:	1d c0       	rjmp	.+58     	; 0xfae <_ZN2M19TurnMotorEv+0xa8>
	}
	else if ( percent_ < oldPercent_ )
     f74:	a7 01       	movw	r20, r14
     f76:	96 01       	movw	r18, r12
     f78:	c5 01       	movw	r24, r10
     f7a:	b4 01       	movw	r22, r8
     f7c:	0e 94 d0 15 	call	0x2ba0	; 0x2ba0 <__cmpsf2>
     f80:	88 23       	and	r24, r24
     f82:	ac f4       	brge	.+42     	; 0xfae <_ZN2M19TurnMotorEv+0xa8>
	{
		oldPercent_ -= PERCENT_PR_TICK;
     f84:	20 e0       	ldi	r18, 0x00	; 0
     f86:	30 e0       	ldi	r19, 0x00	; 0
     f88:	40 e8       	ldi	r20, 0x80	; 128
     f8a:	5d e3       	ldi	r21, 0x3D	; 61
     f8c:	c7 01       	movw	r24, r14
     f8e:	b6 01       	movw	r22, r12
     f90:	0e 94 6b 15 	call	0x2ad6	; 0x2ad6 <__subsf3>
     f94:	ab 01       	movw	r20, r22
     f96:	bc 01       	movw	r22, r24
     f98:	4e 87       	std	Y+14, r20	; 0x0e
     f9a:	5f 87       	std	Y+15, r21	; 0x0f
     f9c:	68 8b       	std	Y+16, r22	; 0x10
     f9e:	79 8b       	std	Y+17, r23	; 0x11
		tmr1Ptr_->setDutyCycleComA( oldPercent_ );
     fa0:	8a 81       	ldd	r24, Y+2	; 0x02
     fa2:	9b 81       	ldd	r25, Y+3	; 0x03
     fa4:	9b d3       	rcall	.+1846   	; 0x16dc <_ZN6Timer116setDutyCycleComAEf>
		vTaskDelay( delay_ / portTICK_RATE_MS );
     fa6:	8f 89       	ldd	r24, Y+23	; 0x17
     fa8:	98 8d       	ldd	r25, Y+24	; 0x18
     faa:	0e 94 6d 11 	call	0x22da	; 0x22da <vTaskDelay>
	}
}
     fae:	df 91       	pop	r29
     fb0:	cf 91       	pop	r28
     fb2:	ff 90       	pop	r15
     fb4:	ef 90       	pop	r14
     fb6:	df 90       	pop	r13
     fb8:	cf 90       	pop	r12
     fba:	bf 90       	pop	r11
     fbc:	af 90       	pop	r10
     fbe:	9f 90       	pop	r9
     fc0:	8f 90       	pop	r8
     fc2:	7f 90       	pop	r7
     fc4:	6f 90       	pop	r6
     fc6:	5f 90       	pop	r5
     fc8:	4f 90       	pop	r4
     fca:	08 95       	ret

00000fcc <_ZN2M1C1EP6Timer1>:
* Author: jespe
*/

#include "M1.h"

M1::M1( Timer1* tmr )
     fcc:	cf 93       	push	r28
     fce:	df 93       	push	r29
     fd0:	ec 01       	movw	r28, r24
     fd2:	cb 01       	movw	r24, r22
     fd4:	22 e7       	ldi	r18, 0x72	; 114
     fd6:	32 e0       	ldi	r19, 0x02	; 2
     fd8:	39 83       	std	Y+1, r19	; 0x01
     fda:	28 83       	st	Y, r18
{
	/* Store timer pointer */
	tmr1Ptr_ = tmr;
     fdc:	7b 83       	std	Y+3, r23	; 0x03
     fde:	6a 83       	std	Y+2, r22	; 0x02
	
	/* This value is number of percent to add or subtract pr degree. */
	percentPrDeg = 0.0555555555555556;
     fe0:	49 e3       	ldi	r20, 0x39	; 57
     fe2:	5e e8       	ldi	r21, 0x8E	; 142
     fe4:	63 e6       	ldi	r22, 0x63	; 99
     fe6:	7d e3       	ldi	r23, 0x3D	; 61
     fe8:	4e 83       	std	Y+6, r20	; 0x06
     fea:	5f 83       	std	Y+7, r21	; 0x07
     fec:	68 87       	std	Y+8, r22	; 0x08
     fee:	79 87       	std	Y+9, r23	; 0x09
	
	/* This value is the lowest duty cycle percentage needed to make motor turn. */
	startpercent_ = 2.5;
     ff0:	40 e0       	ldi	r20, 0x00	; 0
     ff2:	50 e0       	ldi	r21, 0x00	; 0
     ff4:	60 e2       	ldi	r22, 0x20	; 32
     ff6:	70 e4       	ldi	r23, 0x40	; 64
     ff8:	4a 8b       	std	Y+18, r20	; 0x12
     ffa:	5b 8b       	std	Y+19, r21	; 0x13
     ffc:	6c 8b       	std	Y+20, r22	; 0x14
     ffe:	7d 8b       	std	Y+21, r23	; 0x15
	
	/* This value is the delay on motor. A lower value makes motors go faster and higher value makes motors go slower. */
	delay_ = 10;
    1000:	2a e0       	ldi	r18, 0x0A	; 10
    1002:	30 e0       	ldi	r19, 0x00	; 0
    1004:	38 8f       	std	Y+24, r19	; 0x18
    1006:	2f 8b       	std	Y+23, r18	; 0x17
	
	/* This value is the maximum number of degrees the motor can turn */
	maxDegrees_ = 180;
    1008:	24 eb       	ldi	r18, 0xB4	; 180
    100a:	2e 8b       	std	Y+22, r18	; 0x16
	*/
	virtual void SetDegrees( uint8_t degrees )
	{
		if ( maxDegrees_ >= degrees )
		{
			percent_ = percentPrDeg * degrees + startpercent_;
    100c:	40 e0       	ldi	r20, 0x00	; 0
    100e:	50 e0       	ldi	r21, 0x00	; 0
    1010:	60 ef       	ldi	r22, 0xF0	; 240
    1012:	70 e4       	ldi	r23, 0x40	; 64
    1014:	4a 87       	std	Y+10, r20	; 0x0a
    1016:	5b 87       	std	Y+11, r21	; 0x0b
    1018:	6c 87       	std	Y+12, r22	; 0x0c
    101a:	7d 87       	std	Y+13, r23	; 0x0d
	
	/* Set motor to default startup value */
	SetDegrees( 90 );
	tmr1Ptr_->setDutyCycleComA( percent_ );
    101c:	5f d3       	rcall	.+1726   	; 0x16dc <_ZN6Timer116setDutyCycleComAEf>
	oldPercent_ = percent_;
    101e:	8a 85       	ldd	r24, Y+10	; 0x0a
    1020:	9b 85       	ldd	r25, Y+11	; 0x0b
    1022:	ac 85       	ldd	r26, Y+12	; 0x0c
    1024:	bd 85       	ldd	r27, Y+13	; 0x0d
    1026:	8e 87       	std	Y+14, r24	; 0x0e
    1028:	9f 87       	std	Y+15, r25	; 0x0f
    102a:	a8 8b       	std	Y+16, r26	; 0x10
    102c:	b9 8b       	std	Y+17, r27	; 0x11
} 
    102e:	df 91       	pop	r29
    1030:	cf 91       	pop	r28
    1032:	08 95       	ret

00001034 <_ZN2M2D1Ev>:

class Motor
{
//functions
public:
	virtual ~Motor() {};
    1034:	26 e6       	ldi	r18, 0x66	; 102
    1036:	32 e0       	ldi	r19, 0x02	; 2
    1038:	fc 01       	movw	r30, r24
    103a:	31 83       	std	Z+1, r19	; 0x01
    103c:	20 83       	st	Z, r18
    103e:	08 95       	ret

00001040 <_ZN2M2D0Ev>:
	SetDegrees( 90 );
	tmr1Ptr_->setDutyCycleComB( percent_ );
	oldPercent_ = percent_;
}

M2::~M2()
    1040:	cf 93       	push	r28
    1042:	df 93       	push	r29
    1044:	ec 01       	movw	r28, r24
{
}
    1046:	f6 df       	rcall	.-20     	; 0x1034 <_ZN2M2D1Ev>
    1048:	ce 01       	movw	r24, r28
    104a:	ee dc       	rcall	.-1572   	; 0xa28 <_ZdlPv>
    104c:	df 91       	pop	r29
    104e:	cf 91       	pop	r28
    1050:	08 95       	ret

00001052 <_ZN2M29TurnMotorEv>:

void M2::TurnMotor()
{
    1052:	4f 92       	push	r4
    1054:	5f 92       	push	r5
    1056:	6f 92       	push	r6
    1058:	7f 92       	push	r7
    105a:	8f 92       	push	r8
    105c:	9f 92       	push	r9
    105e:	af 92       	push	r10
    1060:	bf 92       	push	r11
    1062:	cf 92       	push	r12
    1064:	df 92       	push	r13
    1066:	ef 92       	push	r14
    1068:	ff 92       	push	r15
    106a:	cf 93       	push	r28
    106c:	df 93       	push	r29
    106e:	ec 01       	movw	r28, r24
	if ( percent_ > oldPercent_ + PERCENT_PR_TICK )
    1070:	8a 84       	ldd	r8, Y+10	; 0x0a
    1072:	9b 84       	ldd	r9, Y+11	; 0x0b
    1074:	ac 84       	ldd	r10, Y+12	; 0x0c
    1076:	bd 84       	ldd	r11, Y+13	; 0x0d
    1078:	ce 84       	ldd	r12, Y+14	; 0x0e
    107a:	df 84       	ldd	r13, Y+15	; 0x0f
    107c:	e8 88       	ldd	r14, Y+16	; 0x10
    107e:	f9 88       	ldd	r15, Y+17	; 0x11
    1080:	20 e0       	ldi	r18, 0x00	; 0
    1082:	30 e0       	ldi	r19, 0x00	; 0
    1084:	40 e8       	ldi	r20, 0x80	; 128
    1086:	5d e3       	ldi	r21, 0x3D	; 61
    1088:	c7 01       	movw	r24, r14
    108a:	b6 01       	movw	r22, r12
    108c:	0e 94 6c 15 	call	0x2ad8	; 0x2ad8 <__addsf3>
    1090:	2b 01       	movw	r4, r22
    1092:	3c 01       	movw	r6, r24
    1094:	9b 01       	movw	r18, r22
    1096:	ac 01       	movw	r20, r24
    1098:	c5 01       	movw	r24, r10
    109a:	b4 01       	movw	r22, r8
    109c:	0e 94 1a 17 	call	0x2e34	; 0x2e34 <__gesf2>
    10a0:	18 16       	cp	r1, r24
    10a2:	74 f4       	brge	.+28     	; 0x10c0 <_ZN2M29TurnMotorEv+0x6e>
	{
		oldPercent_ += PERCENT_PR_TICK;
    10a4:	4e 86       	std	Y+14, r4	; 0x0e
    10a6:	5f 86       	std	Y+15, r5	; 0x0f
    10a8:	68 8a       	std	Y+16, r6	; 0x10
    10aa:	79 8a       	std	Y+17, r7	; 0x11
		tmr1Ptr_->setDutyCycleComB( oldPercent_ );
    10ac:	b3 01       	movw	r22, r6
    10ae:	a2 01       	movw	r20, r4
    10b0:	8a 81       	ldd	r24, Y+2	; 0x02
    10b2:	9b 81       	ldd	r25, Y+3	; 0x03
    10b4:	3e d3       	rcall	.+1660   	; 0x1732 <_ZN6Timer116setDutyCycleComBEf>
		vTaskDelay( delay_ / portTICK_RATE_MS );
    10b6:	8f 89       	ldd	r24, Y+23	; 0x17
    10b8:	98 8d       	ldd	r25, Y+24	; 0x18
    10ba:	0e 94 6d 11 	call	0x22da	; 0x22da <vTaskDelay>
    10be:	1d c0       	rjmp	.+58     	; 0x10fa <_ZN2M29TurnMotorEv+0xa8>
	}
	else if ( percent_ < oldPercent_ )
    10c0:	a7 01       	movw	r20, r14
    10c2:	96 01       	movw	r18, r12
    10c4:	c5 01       	movw	r24, r10
    10c6:	b4 01       	movw	r22, r8
    10c8:	0e 94 d0 15 	call	0x2ba0	; 0x2ba0 <__cmpsf2>
    10cc:	88 23       	and	r24, r24
    10ce:	ac f4       	brge	.+42     	; 0x10fa <_ZN2M29TurnMotorEv+0xa8>
	{
		oldPercent_ -= PERCENT_PR_TICK;
    10d0:	20 e0       	ldi	r18, 0x00	; 0
    10d2:	30 e0       	ldi	r19, 0x00	; 0
    10d4:	40 e8       	ldi	r20, 0x80	; 128
    10d6:	5d e3       	ldi	r21, 0x3D	; 61
    10d8:	c7 01       	movw	r24, r14
    10da:	b6 01       	movw	r22, r12
    10dc:	0e 94 6b 15 	call	0x2ad6	; 0x2ad6 <__subsf3>
    10e0:	ab 01       	movw	r20, r22
    10e2:	bc 01       	movw	r22, r24
    10e4:	4e 87       	std	Y+14, r20	; 0x0e
    10e6:	5f 87       	std	Y+15, r21	; 0x0f
    10e8:	68 8b       	std	Y+16, r22	; 0x10
    10ea:	79 8b       	std	Y+17, r23	; 0x11
		tmr1Ptr_->setDutyCycleComB( oldPercent_ );
    10ec:	8a 81       	ldd	r24, Y+2	; 0x02
    10ee:	9b 81       	ldd	r25, Y+3	; 0x03
    10f0:	20 d3       	rcall	.+1600   	; 0x1732 <_ZN6Timer116setDutyCycleComBEf>
		vTaskDelay( delay_ / portTICK_RATE_MS );
    10f2:	8f 89       	ldd	r24, Y+23	; 0x17
    10f4:	98 8d       	ldd	r25, Y+24	; 0x18
    10f6:	0e 94 6d 11 	call	0x22da	; 0x22da <vTaskDelay>
	}
}
    10fa:	df 91       	pop	r29
    10fc:	cf 91       	pop	r28
    10fe:	ff 90       	pop	r15
    1100:	ef 90       	pop	r14
    1102:	df 90       	pop	r13
    1104:	cf 90       	pop	r12
    1106:	bf 90       	pop	r11
    1108:	af 90       	pop	r10
    110a:	9f 90       	pop	r9
    110c:	8f 90       	pop	r8
    110e:	7f 90       	pop	r7
    1110:	6f 90       	pop	r6
    1112:	5f 90       	pop	r5
    1114:	4f 90       	pop	r4
    1116:	08 95       	ret

00001118 <_ZN2M2C1EP6Timer1>:
* Author: jespe
*/

#include "M2.h"

M2::M2( Timer1* tmr )
    1118:	cf 93       	push	r28
    111a:	df 93       	push	r29
    111c:	ec 01       	movw	r28, r24
    111e:	cb 01       	movw	r24, r22
    1120:	2e e7       	ldi	r18, 0x7E	; 126
    1122:	32 e0       	ldi	r19, 0x02	; 2
    1124:	39 83       	std	Y+1, r19	; 0x01
    1126:	28 83       	st	Y, r18
{
	/* Store timer pointer */
	tmr1Ptr_ = tmr;
    1128:	7b 83       	std	Y+3, r23	; 0x03
    112a:	6a 83       	std	Y+2, r22	; 0x02
	
	/* This value is number of percent to add or subtract pr degree. */
	percentPrDeg = 0.06;
    112c:	4f e8       	ldi	r20, 0x8F	; 143
    112e:	52 ec       	ldi	r21, 0xC2	; 194
    1130:	65 e7       	ldi	r22, 0x75	; 117
    1132:	7d e3       	ldi	r23, 0x3D	; 61
    1134:	4e 83       	std	Y+6, r20	; 0x06
    1136:	5f 83       	std	Y+7, r21	; 0x07
    1138:	68 87       	std	Y+8, r22	; 0x08
    113a:	79 87       	std	Y+9, r23	; 0x09

	/* This value is the lowest duty cycle percentage needed to make motor turn. */
	startpercent_ = 3;
    113c:	40 e0       	ldi	r20, 0x00	; 0
    113e:	50 e0       	ldi	r21, 0x00	; 0
    1140:	60 e4       	ldi	r22, 0x40	; 64
    1142:	70 e4       	ldi	r23, 0x40	; 64
    1144:	4a 8b       	std	Y+18, r20	; 0x12
    1146:	5b 8b       	std	Y+19, r21	; 0x13
    1148:	6c 8b       	std	Y+20, r22	; 0x14
    114a:	7d 8b       	std	Y+21, r23	; 0x15

	/* This value is the delay on motor. A lower value makes motors go faster and higher value makes motors go slower. Value is in MS */
	delay_ = 10;
    114c:	2a e0       	ldi	r18, 0x0A	; 10
    114e:	30 e0       	ldi	r19, 0x00	; 0
    1150:	38 8f       	std	Y+24, r19	; 0x18
    1152:	2f 8b       	std	Y+23, r18	; 0x17

	/* This value is the maximum number of degrees the motor can turn */
	maxDegrees_ = 150;
    1154:	26 e9       	ldi	r18, 0x96	; 150
    1156:	2e 8b       	std	Y+22, r18	; 0x16
	*/
	virtual void SetDegrees( uint8_t degrees )
	{
		if ( maxDegrees_ >= degrees )
		{
			percent_ = percentPrDeg * degrees + startpercent_;
    1158:	46 e6       	ldi	r20, 0x66	; 102
    115a:	56 e6       	ldi	r21, 0x66	; 102
    115c:	66 e0       	ldi	r22, 0x06	; 6
    115e:	71 e4       	ldi	r23, 0x41	; 65
    1160:	4a 87       	std	Y+10, r20	; 0x0a
    1162:	5b 87       	std	Y+11, r21	; 0x0b
    1164:	6c 87       	std	Y+12, r22	; 0x0c
    1166:	7d 87       	std	Y+13, r23	; 0x0d

	/* Set motor to default startup value */
	SetDegrees( 90 );
	tmr1Ptr_->setDutyCycleComB( percent_ );
    1168:	e4 d2       	rcall	.+1480   	; 0x1732 <_ZN6Timer116setDutyCycleComBEf>
	oldPercent_ = percent_;
    116a:	8a 85       	ldd	r24, Y+10	; 0x0a
    116c:	9b 85       	ldd	r25, Y+11	; 0x0b
    116e:	ac 85       	ldd	r26, Y+12	; 0x0c
    1170:	bd 85       	ldd	r27, Y+13	; 0x0d
    1172:	8e 87       	std	Y+14, r24	; 0x0e
    1174:	9f 87       	std	Y+15, r25	; 0x0f
    1176:	a8 8b       	std	Y+16, r26	; 0x10
    1178:	b9 8b       	std	Y+17, r27	; 0x11
}
    117a:	df 91       	pop	r29
    117c:	cf 91       	pop	r28
    117e:	08 95       	ret

00001180 <_ZN2M3D1Ev>:

class Motor
{
//functions
public:
	virtual ~Motor() {};
    1180:	26 e6       	ldi	r18, 0x66	; 102
    1182:	32 e0       	ldi	r19, 0x02	; 2
    1184:	fc 01       	movw	r30, r24
    1186:	31 83       	std	Z+1, r19	; 0x01
    1188:	20 83       	st	Z, r18
    118a:	08 95       	ret

0000118c <_ZN2M3D0Ev>:
	SetDegrees( 90 );
	tmr1Ptr_->setDutyCycleComC( percent_ );
	oldPercent_ = percent_;	
}

M3::~M3()
    118c:	cf 93       	push	r28
    118e:	df 93       	push	r29
    1190:	ec 01       	movw	r28, r24
{
}
    1192:	f6 df       	rcall	.-20     	; 0x1180 <_ZN2M3D1Ev>
    1194:	ce 01       	movw	r24, r28
    1196:	48 dc       	rcall	.-1904   	; 0xa28 <_ZdlPv>
    1198:	df 91       	pop	r29
    119a:	cf 91       	pop	r28
    119c:	08 95       	ret

0000119e <_ZN2M39TurnMotorEv>:

void M3::TurnMotor()
{
    119e:	4f 92       	push	r4
    11a0:	5f 92       	push	r5
    11a2:	6f 92       	push	r6
    11a4:	7f 92       	push	r7
    11a6:	8f 92       	push	r8
    11a8:	9f 92       	push	r9
    11aa:	af 92       	push	r10
    11ac:	bf 92       	push	r11
    11ae:	cf 92       	push	r12
    11b0:	df 92       	push	r13
    11b2:	ef 92       	push	r14
    11b4:	ff 92       	push	r15
    11b6:	cf 93       	push	r28
    11b8:	df 93       	push	r29
    11ba:	ec 01       	movw	r28, r24
	if ( percent_ > oldPercent_ + PERCENT_PR_TICK )
    11bc:	8a 84       	ldd	r8, Y+10	; 0x0a
    11be:	9b 84       	ldd	r9, Y+11	; 0x0b
    11c0:	ac 84       	ldd	r10, Y+12	; 0x0c
    11c2:	bd 84       	ldd	r11, Y+13	; 0x0d
    11c4:	ce 84       	ldd	r12, Y+14	; 0x0e
    11c6:	df 84       	ldd	r13, Y+15	; 0x0f
    11c8:	e8 88       	ldd	r14, Y+16	; 0x10
    11ca:	f9 88       	ldd	r15, Y+17	; 0x11
    11cc:	20 e0       	ldi	r18, 0x00	; 0
    11ce:	30 e0       	ldi	r19, 0x00	; 0
    11d0:	40 e8       	ldi	r20, 0x80	; 128
    11d2:	5d e3       	ldi	r21, 0x3D	; 61
    11d4:	c7 01       	movw	r24, r14
    11d6:	b6 01       	movw	r22, r12
    11d8:	0e 94 6c 15 	call	0x2ad8	; 0x2ad8 <__addsf3>
    11dc:	2b 01       	movw	r4, r22
    11de:	3c 01       	movw	r6, r24
    11e0:	9b 01       	movw	r18, r22
    11e2:	ac 01       	movw	r20, r24
    11e4:	c5 01       	movw	r24, r10
    11e6:	b4 01       	movw	r22, r8
    11e8:	0e 94 1a 17 	call	0x2e34	; 0x2e34 <__gesf2>
    11ec:	18 16       	cp	r1, r24
    11ee:	74 f4       	brge	.+28     	; 0x120c <_ZN2M39TurnMotorEv+0x6e>
	{
		oldPercent_ += PERCENT_PR_TICK;
    11f0:	4e 86       	std	Y+14, r4	; 0x0e
    11f2:	5f 86       	std	Y+15, r5	; 0x0f
    11f4:	68 8a       	std	Y+16, r6	; 0x10
    11f6:	79 8a       	std	Y+17, r7	; 0x11
		tmr1Ptr_->setDutyCycleComC( oldPercent_ );
    11f8:	b3 01       	movw	r22, r6
    11fa:	a2 01       	movw	r20, r4
    11fc:	8a 81       	ldd	r24, Y+2	; 0x02
    11fe:	9b 81       	ldd	r25, Y+3	; 0x03
    1200:	c3 d2       	rcall	.+1414   	; 0x1788 <_ZN6Timer116setDutyCycleComCEf>
		vTaskDelay( delay_ / portTICK_RATE_MS );
    1202:	8f 89       	ldd	r24, Y+23	; 0x17
    1204:	98 8d       	ldd	r25, Y+24	; 0x18
    1206:	0e 94 6d 11 	call	0x22da	; 0x22da <vTaskDelay>
    120a:	1d c0       	rjmp	.+58     	; 0x1246 <_ZN2M39TurnMotorEv+0xa8>
	}
	else if ( percent_ < oldPercent_ )
    120c:	a7 01       	movw	r20, r14
    120e:	96 01       	movw	r18, r12
    1210:	c5 01       	movw	r24, r10
    1212:	b4 01       	movw	r22, r8
    1214:	0e 94 d0 15 	call	0x2ba0	; 0x2ba0 <__cmpsf2>
    1218:	88 23       	and	r24, r24
    121a:	ac f4       	brge	.+42     	; 0x1246 <_ZN2M39TurnMotorEv+0xa8>
	{
		oldPercent_ -= PERCENT_PR_TICK;
    121c:	20 e0       	ldi	r18, 0x00	; 0
    121e:	30 e0       	ldi	r19, 0x00	; 0
    1220:	40 e8       	ldi	r20, 0x80	; 128
    1222:	5d e3       	ldi	r21, 0x3D	; 61
    1224:	c7 01       	movw	r24, r14
    1226:	b6 01       	movw	r22, r12
    1228:	0e 94 6b 15 	call	0x2ad6	; 0x2ad6 <__subsf3>
    122c:	ab 01       	movw	r20, r22
    122e:	bc 01       	movw	r22, r24
    1230:	4e 87       	std	Y+14, r20	; 0x0e
    1232:	5f 87       	std	Y+15, r21	; 0x0f
    1234:	68 8b       	std	Y+16, r22	; 0x10
    1236:	79 8b       	std	Y+17, r23	; 0x11
		tmr1Ptr_->setDutyCycleComC( oldPercent_ );
    1238:	8a 81       	ldd	r24, Y+2	; 0x02
    123a:	9b 81       	ldd	r25, Y+3	; 0x03
    123c:	a5 d2       	rcall	.+1354   	; 0x1788 <_ZN6Timer116setDutyCycleComCEf>
		vTaskDelay( delay_ / portTICK_RATE_MS );
    123e:	8f 89       	ldd	r24, Y+23	; 0x17
    1240:	98 8d       	ldd	r25, Y+24	; 0x18
    1242:	0e 94 6d 11 	call	0x22da	; 0x22da <vTaskDelay>
	}
}
    1246:	df 91       	pop	r29
    1248:	cf 91       	pop	r28
    124a:	ff 90       	pop	r15
    124c:	ef 90       	pop	r14
    124e:	df 90       	pop	r13
    1250:	cf 90       	pop	r12
    1252:	bf 90       	pop	r11
    1254:	af 90       	pop	r10
    1256:	9f 90       	pop	r9
    1258:	8f 90       	pop	r8
    125a:	7f 90       	pop	r7
    125c:	6f 90       	pop	r6
    125e:	5f 90       	pop	r5
    1260:	4f 90       	pop	r4
    1262:	08 95       	ret

00001264 <_ZN2M3C1EP6Timer1>:
*/

#include "M3.h"


M3::M3( Timer1* tmr )
    1264:	cf 93       	push	r28
    1266:	df 93       	push	r29
    1268:	ec 01       	movw	r28, r24
    126a:	cb 01       	movw	r24, r22
    126c:	2a e8       	ldi	r18, 0x8A	; 138
    126e:	32 e0       	ldi	r19, 0x02	; 2
    1270:	39 83       	std	Y+1, r19	; 0x01
    1272:	28 83       	st	Y, r18
{
	/* Store timer pointer */
	tmr1Ptr_ = tmr;
    1274:	7b 83       	std	Y+3, r23	; 0x03
    1276:	6a 83       	std	Y+2, r22	; 0x02
		
	/* This value is number of percent to add or subtract pr degree. */
	percentPrDeg = 0.0555555555555556;
    1278:	49 e3       	ldi	r20, 0x39	; 57
    127a:	5e e8       	ldi	r21, 0x8E	; 142
    127c:	63 e6       	ldi	r22, 0x63	; 99
    127e:	7d e3       	ldi	r23, 0x3D	; 61
    1280:	4e 83       	std	Y+6, r20	; 0x06
    1282:	5f 83       	std	Y+7, r21	; 0x07
    1284:	68 87       	std	Y+8, r22	; 0x08
    1286:	79 87       	std	Y+9, r23	; 0x09
	
	/* This value is the lowest duty cycle percentage needed to make motor turn. */
	startpercent_ = 2.5;
    1288:	40 e0       	ldi	r20, 0x00	; 0
    128a:	50 e0       	ldi	r21, 0x00	; 0
    128c:	60 e2       	ldi	r22, 0x20	; 32
    128e:	70 e4       	ldi	r23, 0x40	; 64
    1290:	4a 8b       	std	Y+18, r20	; 0x12
    1292:	5b 8b       	std	Y+19, r21	; 0x13
    1294:	6c 8b       	std	Y+20, r22	; 0x14
    1296:	7d 8b       	std	Y+21, r23	; 0x15

	/* This value is the delay on motor. A lower value makes motors go faster and higher value makes motors go slower. Value is in MS */
	delay_ = 10;
    1298:	2a e0       	ldi	r18, 0x0A	; 10
    129a:	30 e0       	ldi	r19, 0x00	; 0
    129c:	38 8f       	std	Y+24, r19	; 0x18
    129e:	2f 8b       	std	Y+23, r18	; 0x17
	
	/* This value is the maximum number of degrees the motor can turn */
	maxDegrees_ = 180;
    12a0:	24 eb       	ldi	r18, 0xB4	; 180
    12a2:	2e 8b       	std	Y+22, r18	; 0x16
	*/
	virtual void SetDegrees( uint8_t degrees )
	{
		if ( maxDegrees_ >= degrees )
		{
			percent_ = percentPrDeg * degrees + startpercent_;
    12a4:	40 e0       	ldi	r20, 0x00	; 0
    12a6:	50 e0       	ldi	r21, 0x00	; 0
    12a8:	60 ef       	ldi	r22, 0xF0	; 240
    12aa:	70 e4       	ldi	r23, 0x40	; 64
    12ac:	4a 87       	std	Y+10, r20	; 0x0a
    12ae:	5b 87       	std	Y+11, r21	; 0x0b
    12b0:	6c 87       	std	Y+12, r22	; 0x0c
    12b2:	7d 87       	std	Y+13, r23	; 0x0d
	
	/* Set motor to default startup value */
	SetDegrees( 90 );
	tmr1Ptr_->setDutyCycleComC( percent_ );
    12b4:	69 d2       	rcall	.+1234   	; 0x1788 <_ZN6Timer116setDutyCycleComCEf>
	oldPercent_ = percent_;	
    12b6:	8a 85       	ldd	r24, Y+10	; 0x0a
    12b8:	9b 85       	ldd	r25, Y+11	; 0x0b
    12ba:	ac 85       	ldd	r26, Y+12	; 0x0c
    12bc:	bd 85       	ldd	r27, Y+13	; 0x0d
    12be:	8e 87       	std	Y+14, r24	; 0x0e
    12c0:	9f 87       	std	Y+15, r25	; 0x0f
    12c2:	a8 8b       	std	Y+16, r26	; 0x10
    12c4:	b9 8b       	std	Y+17, r27	; 0x11
}
    12c6:	df 91       	pop	r29
    12c8:	cf 91       	pop	r28
    12ca:	08 95       	ret

000012cc <_ZN2M4D1Ev>:

class Motor
{
//functions
public:
	virtual ~Motor() {};
    12cc:	26 e6       	ldi	r18, 0x66	; 102
    12ce:	32 e0       	ldi	r19, 0x02	; 2
    12d0:	fc 01       	movw	r30, r24
    12d2:	31 83       	std	Z+1, r19	; 0x01
    12d4:	20 83       	st	Z, r18
    12d6:	08 95       	ret

000012d8 <_ZN2M4D0Ev>:
	SetDegrees( 90 );
	tmr3Ptr_->setDutyCycleComA( percent_ );
	oldPercent_ = percent_;
}

M4::~M4()
    12d8:	cf 93       	push	r28
    12da:	df 93       	push	r29
    12dc:	ec 01       	movw	r28, r24
{
} 
    12de:	f6 df       	rcall	.-20     	; 0x12cc <_ZN2M4D1Ev>
    12e0:	ce 01       	movw	r24, r28
    12e2:	a2 db       	rcall	.-2236   	; 0xa28 <_ZdlPv>
    12e4:	df 91       	pop	r29
    12e6:	cf 91       	pop	r28
    12e8:	08 95       	ret

000012ea <_ZN2M49TurnMotorEv>:

void M4::TurnMotor()
{
    12ea:	4f 92       	push	r4
    12ec:	5f 92       	push	r5
    12ee:	6f 92       	push	r6
    12f0:	7f 92       	push	r7
    12f2:	8f 92       	push	r8
    12f4:	9f 92       	push	r9
    12f6:	af 92       	push	r10
    12f8:	bf 92       	push	r11
    12fa:	cf 92       	push	r12
    12fc:	df 92       	push	r13
    12fe:	ef 92       	push	r14
    1300:	ff 92       	push	r15
    1302:	cf 93       	push	r28
    1304:	df 93       	push	r29
    1306:	ec 01       	movw	r28, r24
	if ( percent_ > oldPercent_ + PERCENT_PR_TICK )
    1308:	8a 84       	ldd	r8, Y+10	; 0x0a
    130a:	9b 84       	ldd	r9, Y+11	; 0x0b
    130c:	ac 84       	ldd	r10, Y+12	; 0x0c
    130e:	bd 84       	ldd	r11, Y+13	; 0x0d
    1310:	ce 84       	ldd	r12, Y+14	; 0x0e
    1312:	df 84       	ldd	r13, Y+15	; 0x0f
    1314:	e8 88       	ldd	r14, Y+16	; 0x10
    1316:	f9 88       	ldd	r15, Y+17	; 0x11
    1318:	20 e0       	ldi	r18, 0x00	; 0
    131a:	30 e0       	ldi	r19, 0x00	; 0
    131c:	40 e8       	ldi	r20, 0x80	; 128
    131e:	5d e3       	ldi	r21, 0x3D	; 61
    1320:	c7 01       	movw	r24, r14
    1322:	b6 01       	movw	r22, r12
    1324:	0e 94 6c 15 	call	0x2ad8	; 0x2ad8 <__addsf3>
    1328:	2b 01       	movw	r4, r22
    132a:	3c 01       	movw	r6, r24
    132c:	9b 01       	movw	r18, r22
    132e:	ac 01       	movw	r20, r24
    1330:	c5 01       	movw	r24, r10
    1332:	b4 01       	movw	r22, r8
    1334:	0e 94 1a 17 	call	0x2e34	; 0x2e34 <__gesf2>
    1338:	18 16       	cp	r1, r24
    133a:	6c f4       	brge	.+26     	; 0x1356 <_ZN2M49TurnMotorEv+0x6c>
	{
		oldPercent_ += PERCENT_PR_TICK;
    133c:	4e 86       	std	Y+14, r4	; 0x0e
    133e:	5f 86       	std	Y+15, r5	; 0x0f
    1340:	68 8a       	std	Y+16, r6	; 0x10
    1342:	79 8a       	std	Y+17, r7	; 0x11
		tmr3Ptr_->setDutyCycleComA( oldPercent_ );
    1344:	b3 01       	movw	r22, r6
    1346:	a2 01       	movw	r20, r4
    1348:	8c 81       	ldd	r24, Y+4	; 0x04
    134a:	9d 81       	ldd	r25, Y+5	; 0x05
    134c:	6e d2       	rcall	.+1244   	; 0x182a <_ZN6Timer516setDutyCycleComAEf>
		vTaskDelay( 10 / portTICK_RATE_MS );
    134e:	8a e0       	ldi	r24, 0x0A	; 10
    1350:	90 e0       	ldi	r25, 0x00	; 0
    1352:	c3 d7       	rcall	.+3974   	; 0x22da <vTaskDelay>
    1354:	1c c0       	rjmp	.+56     	; 0x138e <_ZN2M49TurnMotorEv+0xa4>
	}
	else if ( percent_ < oldPercent_ )
    1356:	a7 01       	movw	r20, r14
    1358:	96 01       	movw	r18, r12
    135a:	c5 01       	movw	r24, r10
    135c:	b4 01       	movw	r22, r8
    135e:	0e 94 d0 15 	call	0x2ba0	; 0x2ba0 <__cmpsf2>
    1362:	88 23       	and	r24, r24
    1364:	a4 f4       	brge	.+40     	; 0x138e <_ZN2M49TurnMotorEv+0xa4>
	{
		oldPercent_ -= PERCENT_PR_TICK;
    1366:	20 e0       	ldi	r18, 0x00	; 0
    1368:	30 e0       	ldi	r19, 0x00	; 0
    136a:	40 e8       	ldi	r20, 0x80	; 128
    136c:	5d e3       	ldi	r21, 0x3D	; 61
    136e:	c7 01       	movw	r24, r14
    1370:	b6 01       	movw	r22, r12
    1372:	0e 94 6b 15 	call	0x2ad6	; 0x2ad6 <__subsf3>
    1376:	ab 01       	movw	r20, r22
    1378:	bc 01       	movw	r22, r24
    137a:	4e 87       	std	Y+14, r20	; 0x0e
    137c:	5f 87       	std	Y+15, r21	; 0x0f
    137e:	68 8b       	std	Y+16, r22	; 0x10
    1380:	79 8b       	std	Y+17, r23	; 0x11
		tmr3Ptr_->setDutyCycleComA( oldPercent_ );
    1382:	8c 81       	ldd	r24, Y+4	; 0x04
    1384:	9d 81       	ldd	r25, Y+5	; 0x05
    1386:	51 d2       	rcall	.+1186   	; 0x182a <_ZN6Timer516setDutyCycleComAEf>
		vTaskDelay( 10 / portTICK_RATE_MS );
    1388:	8a e0       	ldi	r24, 0x0A	; 10
    138a:	90 e0       	ldi	r25, 0x00	; 0
    138c:	a6 d7       	rcall	.+3916   	; 0x22da <vTaskDelay>
    138e:	df 91       	pop	r29
	}
}
    1390:	cf 91       	pop	r28
    1392:	ff 90       	pop	r15
    1394:	ef 90       	pop	r14
    1396:	df 90       	pop	r13
    1398:	cf 90       	pop	r12
    139a:	bf 90       	pop	r11
    139c:	af 90       	pop	r10
    139e:	9f 90       	pop	r9
    13a0:	8f 90       	pop	r8
    13a2:	7f 90       	pop	r7
    13a4:	6f 90       	pop	r6
    13a6:	5f 90       	pop	r5
    13a8:	4f 90       	pop	r4
    13aa:	08 95       	ret

000013ac <_ZN2M4C1EP6Timer5>:
    13ac:	cf 93       	push	r28
* Author: jespe
*/

#include "M4.h"

M4::M4( Timer5* tmr )
    13ae:	df 93       	push	r29
    13b0:	ec 01       	movw	r28, r24
    13b2:	cb 01       	movw	r24, r22
    13b4:	26 e9       	ldi	r18, 0x96	; 150
    13b6:	32 e0       	ldi	r19, 0x02	; 2
    13b8:	39 83       	std	Y+1, r19	; 0x01
    13ba:	28 83       	st	Y, r18
{
	/* Store timer pointer */
	tmr3Ptr_ = tmr;
    13bc:	7d 83       	std	Y+5, r23	; 0x05
    13be:	6c 83       	std	Y+4, r22	; 0x04
	
	/* This value is number of percent to add or subtract pr degree. */
	percentPrDeg = 0.0555555555555556;
    13c0:	49 e3       	ldi	r20, 0x39	; 57
    13c2:	5e e8       	ldi	r21, 0x8E	; 142
    13c4:	63 e6       	ldi	r22, 0x63	; 99
    13c6:	7d e3       	ldi	r23, 0x3D	; 61
    13c8:	4e 83       	std	Y+6, r20	; 0x06
    13ca:	5f 83       	std	Y+7, r21	; 0x07
    13cc:	68 87       	std	Y+8, r22	; 0x08
    13ce:	79 87       	std	Y+9, r23	; 0x09
	
	/* This value is the lowest duty cycle percentage needed to make motor turn. */
	startpercent_ = 2.5;
    13d0:	40 e0       	ldi	r20, 0x00	; 0
    13d2:	50 e0       	ldi	r21, 0x00	; 0
    13d4:	60 e2       	ldi	r22, 0x20	; 32
    13d6:	70 e4       	ldi	r23, 0x40	; 64
    13d8:	4a 8b       	std	Y+18, r20	; 0x12
    13da:	5b 8b       	std	Y+19, r21	; 0x13
    13dc:	6c 8b       	std	Y+20, r22	; 0x14
    13de:	7d 8b       	std	Y+21, r23	; 0x15
		
	/* This value is the delay on motor. A lower value makes motors go faster and higher value makes motors go slower. Value is in MS */
	delay_ = 5;
    13e0:	25 e0       	ldi	r18, 0x05	; 5
    13e2:	30 e0       	ldi	r19, 0x00	; 0
    13e4:	38 8f       	std	Y+24, r19	; 0x18
    13e6:	2f 8b       	std	Y+23, r18	; 0x17
	
	/* This value is the maximum number of degrees the motor can turn */
	maxDegrees_ = 180;
    13e8:	24 eb       	ldi	r18, 0xB4	; 180
    13ea:	2e 8b       	std	Y+22, r18	; 0x16
	*/
	virtual void SetDegrees( uint8_t degrees )
	{
		if ( maxDegrees_ >= degrees )
		{
			percent_ = percentPrDeg * degrees + startpercent_;
    13ec:	40 e0       	ldi	r20, 0x00	; 0
    13ee:	50 e0       	ldi	r21, 0x00	; 0
    13f0:	60 ef       	ldi	r22, 0xF0	; 240
    13f2:	70 e4       	ldi	r23, 0x40	; 64
    13f4:	4a 87       	std	Y+10, r20	; 0x0a
    13f6:	5b 87       	std	Y+11, r21	; 0x0b
    13f8:	6c 87       	std	Y+12, r22	; 0x0c
    13fa:	7d 87       	std	Y+13, r23	; 0x0d
	
	/* Set motor to default startup value */
	SetDegrees( 90 );
	tmr3Ptr_->setDutyCycleComA( percent_ );
    13fc:	16 d2       	rcall	.+1068   	; 0x182a <_ZN6Timer516setDutyCycleComAEf>
	oldPercent_ = percent_;
    13fe:	8a 85       	ldd	r24, Y+10	; 0x0a
    1400:	9b 85       	ldd	r25, Y+11	; 0x0b
    1402:	ac 85       	ldd	r26, Y+12	; 0x0c
    1404:	bd 85       	ldd	r27, Y+13	; 0x0d
    1406:	8e 87       	std	Y+14, r24	; 0x0e
    1408:	9f 87       	std	Y+15, r25	; 0x0f
    140a:	a8 8b       	std	Y+16, r26	; 0x10
    140c:	b9 8b       	std	Y+17, r27	; 0x11
}
    140e:	df 91       	pop	r29
    1410:	cf 91       	pop	r28
    1412:	08 95       	ret

00001414 <_ZN2M5D1Ev>:

class Motor
{
//functions
public:
	virtual ~Motor() {};
    1414:	26 e6       	ldi	r18, 0x66	; 102
    1416:	32 e0       	ldi	r19, 0x02	; 2
    1418:	fc 01       	movw	r30, r24
    141a:	31 83       	std	Z+1, r19	; 0x01
    141c:	20 83       	st	Z, r18
    141e:	08 95       	ret

00001420 <_ZN2M5D0Ev>:
	SetDegrees( 0 );
	tmr3Ptr_->setDutyCycleComB( percent_ );
	oldPercent_ = percent_;
}

M5::~M5()
    1420:	cf 93       	push	r28
    1422:	df 93       	push	r29
    1424:	ec 01       	movw	r28, r24
{
}
    1426:	f6 df       	rcall	.-20     	; 0x1414 <_ZN2M5D1Ev>
    1428:	ce 01       	movw	r24, r28
    142a:	fe da       	rcall	.-2564   	; 0xa28 <_ZdlPv>
    142c:	df 91       	pop	r29
    142e:	cf 91       	pop	r28
    1430:	08 95       	ret

00001432 <_ZN2M59TurnMotorEv>:

void M5::TurnMotor()
{
    1432:	4f 92       	push	r4
    1434:	5f 92       	push	r5
    1436:	6f 92       	push	r6
    1438:	7f 92       	push	r7
    143a:	8f 92       	push	r8
    143c:	9f 92       	push	r9
    143e:	af 92       	push	r10
    1440:	bf 92       	push	r11
    1442:	cf 92       	push	r12
    1444:	df 92       	push	r13
    1446:	ef 92       	push	r14
    1448:	ff 92       	push	r15
    144a:	cf 93       	push	r28
    144c:	df 93       	push	r29
    144e:	ec 01       	movw	r28, r24
	if ( percent_ > oldPercent_ + PERCENT_PR_TICK )
    1450:	8a 84       	ldd	r8, Y+10	; 0x0a
    1452:	9b 84       	ldd	r9, Y+11	; 0x0b
    1454:	ac 84       	ldd	r10, Y+12	; 0x0c
    1456:	bd 84       	ldd	r11, Y+13	; 0x0d
    1458:	ce 84       	ldd	r12, Y+14	; 0x0e
    145a:	df 84       	ldd	r13, Y+15	; 0x0f
    145c:	e8 88       	ldd	r14, Y+16	; 0x10
    145e:	f9 88       	ldd	r15, Y+17	; 0x11
    1460:	20 e0       	ldi	r18, 0x00	; 0
    1462:	30 e0       	ldi	r19, 0x00	; 0
    1464:	40 e8       	ldi	r20, 0x80	; 128
    1466:	5d e3       	ldi	r21, 0x3D	; 61
    1468:	c7 01       	movw	r24, r14
    146a:	b6 01       	movw	r22, r12
    146c:	0e 94 6c 15 	call	0x2ad8	; 0x2ad8 <__addsf3>
    1470:	2b 01       	movw	r4, r22
    1472:	3c 01       	movw	r6, r24
    1474:	9b 01       	movw	r18, r22
    1476:	ac 01       	movw	r20, r24
    1478:	c5 01       	movw	r24, r10
    147a:	b4 01       	movw	r22, r8
    147c:	0e 94 1a 17 	call	0x2e34	; 0x2e34 <__gesf2>
    1480:	18 16       	cp	r1, r24
    1482:	6c f4       	brge	.+26     	; 0x149e <_ZN2M59TurnMotorEv+0x6c>
	{
		oldPercent_ += PERCENT_PR_TICK;
    1484:	4e 86       	std	Y+14, r4	; 0x0e
    1486:	5f 86       	std	Y+15, r5	; 0x0f
    1488:	68 8a       	std	Y+16, r6	; 0x10
    148a:	79 8a       	std	Y+17, r7	; 0x11
		tmr3Ptr_->setDutyCycleComB( oldPercent_ );
    148c:	b3 01       	movw	r22, r6
    148e:	a2 01       	movw	r20, r4
    1490:	8c 81       	ldd	r24, Y+4	; 0x04
    1492:	9d 81       	ldd	r25, Y+5	; 0x05
    1494:	f5 d1       	rcall	.+1002   	; 0x1880 <_ZN6Timer516setDutyCycleComBEf>
		vTaskDelay( delay_ / portTICK_RATE_MS );
    1496:	8f 89       	ldd	r24, Y+23	; 0x17
    1498:	98 8d       	ldd	r25, Y+24	; 0x18
    149a:	1f d7       	rcall	.+3646   	; 0x22da <vTaskDelay>
    149c:	1c c0       	rjmp	.+56     	; 0x14d6 <_ZN2M59TurnMotorEv+0xa4>
	}
	else if ( percent_ < oldPercent_ )
    149e:	a7 01       	movw	r20, r14
    14a0:	96 01       	movw	r18, r12
    14a2:	c5 01       	movw	r24, r10
    14a4:	b4 01       	movw	r22, r8
    14a6:	0e 94 d0 15 	call	0x2ba0	; 0x2ba0 <__cmpsf2>
    14aa:	88 23       	and	r24, r24
    14ac:	a4 f4       	brge	.+40     	; 0x14d6 <_ZN2M59TurnMotorEv+0xa4>
	{
		oldPercent_ -= PERCENT_PR_TICK;
    14ae:	20 e0       	ldi	r18, 0x00	; 0
    14b0:	30 e0       	ldi	r19, 0x00	; 0
    14b2:	40 e8       	ldi	r20, 0x80	; 128
    14b4:	5d e3       	ldi	r21, 0x3D	; 61
    14b6:	c7 01       	movw	r24, r14
    14b8:	b6 01       	movw	r22, r12
    14ba:	0e 94 6b 15 	call	0x2ad6	; 0x2ad6 <__subsf3>
    14be:	ab 01       	movw	r20, r22
    14c0:	bc 01       	movw	r22, r24
    14c2:	4e 87       	std	Y+14, r20	; 0x0e
    14c4:	5f 87       	std	Y+15, r21	; 0x0f
    14c6:	68 8b       	std	Y+16, r22	; 0x10
    14c8:	79 8b       	std	Y+17, r23	; 0x11
		tmr3Ptr_->setDutyCycleComB( oldPercent_ );
    14ca:	8c 81       	ldd	r24, Y+4	; 0x04
    14cc:	9d 81       	ldd	r25, Y+5	; 0x05
    14ce:	d8 d1       	rcall	.+944    	; 0x1880 <_ZN6Timer516setDutyCycleComBEf>
		vTaskDelay( delay_ / portTICK_RATE_MS );
    14d0:	8f 89       	ldd	r24, Y+23	; 0x17
    14d2:	98 8d       	ldd	r25, Y+24	; 0x18
    14d4:	02 d7       	rcall	.+3588   	; 0x22da <vTaskDelay>
    14d6:	df 91       	pop	r29
	}
}
    14d8:	cf 91       	pop	r28
    14da:	ff 90       	pop	r15
    14dc:	ef 90       	pop	r14
    14de:	df 90       	pop	r13
    14e0:	cf 90       	pop	r12
    14e2:	bf 90       	pop	r11
    14e4:	af 90       	pop	r10
    14e6:	9f 90       	pop	r9
    14e8:	8f 90       	pop	r8
    14ea:	7f 90       	pop	r7
    14ec:	6f 90       	pop	r6
    14ee:	5f 90       	pop	r5
    14f0:	4f 90       	pop	r4
    14f2:	08 95       	ret

000014f4 <_ZN2M5C1EP6Timer5>:
    14f4:	cf 93       	push	r28
* Author: jespe
*/

#include "M5.h"

M5::M5( Timer5* tmr )
    14f6:	df 93       	push	r29
    14f8:	ec 01       	movw	r28, r24
    14fa:	cb 01       	movw	r24, r22
    14fc:	22 ea       	ldi	r18, 0xA2	; 162
    14fe:	32 e0       	ldi	r19, 0x02	; 2
    1500:	39 83       	std	Y+1, r19	; 0x01
    1502:	28 83       	st	Y, r18
{
	/* Store timer pointer */
	tmr3Ptr_ = tmr;
    1504:	7d 83       	std	Y+5, r23	; 0x05
    1506:	6c 83       	std	Y+4, r22	; 0x04
	
	/* This value is number of percent to add or subtract pr degree. */
	percentPrDeg = 0.0555555555555556;
    1508:	49 e3       	ldi	r20, 0x39	; 57
    150a:	5e e8       	ldi	r21, 0x8E	; 142
    150c:	63 e6       	ldi	r22, 0x63	; 99
    150e:	7d e3       	ldi	r23, 0x3D	; 61
    1510:	4e 83       	std	Y+6, r20	; 0x06
    1512:	5f 83       	std	Y+7, r21	; 0x07
    1514:	68 87       	std	Y+8, r22	; 0x08
    1516:	79 87       	std	Y+9, r23	; 0x09
	
	/* This value is the lowest duty cycle percentage needed to make motor turn. */
	startpercent_ = 2.5;
    1518:	40 e0       	ldi	r20, 0x00	; 0
    151a:	50 e0       	ldi	r21, 0x00	; 0
    151c:	60 e2       	ldi	r22, 0x20	; 32
    151e:	70 e4       	ldi	r23, 0x40	; 64
    1520:	4a 8b       	std	Y+18, r20	; 0x12
    1522:	5b 8b       	std	Y+19, r21	; 0x13
    1524:	6c 8b       	std	Y+20, r22	; 0x14
    1526:	7d 8b       	std	Y+21, r23	; 0x15
	
	/* This value is the delay on motor. A lower value makes motors go faster and higher value makes motors go slower. Value is in MS */
	delay_ = 1;
    1528:	21 e0       	ldi	r18, 0x01	; 1
    152a:	30 e0       	ldi	r19, 0x00	; 0
    152c:	38 8f       	std	Y+24, r19	; 0x18
    152e:	2f 8b       	std	Y+23, r18	; 0x17
	
	/* This value is the maximum number of degrees the motor can turn */
	maxDegrees_ = 180;
    1530:	24 eb       	ldi	r18, 0xB4	; 180
    1532:	2e 8b       	std	Y+22, r18	; 0x16
	*/
	virtual void SetDegrees( uint8_t degrees )
	{
		if ( maxDegrees_ >= degrees )
		{
			percent_ = percentPrDeg * degrees + startpercent_;
    1534:	4a 87       	std	Y+10, r20	; 0x0a
    1536:	5b 87       	std	Y+11, r21	; 0x0b
    1538:	6c 87       	std	Y+12, r22	; 0x0c
    153a:	7d 87       	std	Y+13, r23	; 0x0d
	
	/* Set motor to default startup value */
	SetDegrees( 0 );
	tmr3Ptr_->setDutyCycleComB( percent_ );
    153c:	a1 d1       	rcall	.+834    	; 0x1880 <_ZN6Timer516setDutyCycleComBEf>
	oldPercent_ = percent_;
    153e:	8a 85       	ldd	r24, Y+10	; 0x0a
    1540:	9b 85       	ldd	r25, Y+11	; 0x0b
    1542:	ac 85       	ldd	r26, Y+12	; 0x0c
    1544:	bd 85       	ldd	r27, Y+13	; 0x0d
    1546:	8e 87       	std	Y+14, r24	; 0x0e
    1548:	9f 87       	std	Y+15, r25	; 0x0f
    154a:	a8 8b       	std	Y+16, r26	; 0x10
    154c:	b9 8b       	std	Y+17, r27	; 0x11
}
    154e:	df 91       	pop	r29
    1550:	cf 91       	pop	r28
    1552:	08 95       	ret

00001554 <_ZN2M6D1Ev>:

class Motor
{
//functions
public:
	virtual ~Motor() {};
    1554:	26 e6       	ldi	r18, 0x66	; 102
    1556:	32 e0       	ldi	r19, 0x02	; 2
    1558:	fc 01       	movw	r30, r24
    155a:	31 83       	std	Z+1, r19	; 0x01
    155c:	20 83       	st	Z, r18
    155e:	08 95       	ret

00001560 <_ZN2M6D0Ev>:
	SetDegrees( 0 );
	tmr3Ptr_->setDutyCycleComC( percent_ );
	oldPercent_ = percent_;
}

M6::~M6()
    1560:	cf 93       	push	r28
    1562:	df 93       	push	r29
    1564:	ec 01       	movw	r28, r24
{
}
    1566:	f6 df       	rcall	.-20     	; 0x1554 <_ZN2M6D1Ev>
    1568:	ce 01       	movw	r24, r28
    156a:	5e da       	rcall	.-2884   	; 0xa28 <_ZdlPv>
    156c:	df 91       	pop	r29
    156e:	cf 91       	pop	r28
    1570:	08 95       	ret

00001572 <_ZN2M69TurnMotorEv>:

void M6::TurnMotor()
{
    1572:	4f 92       	push	r4
    1574:	5f 92       	push	r5
    1576:	6f 92       	push	r6
    1578:	7f 92       	push	r7
    157a:	8f 92       	push	r8
    157c:	9f 92       	push	r9
    157e:	af 92       	push	r10
    1580:	bf 92       	push	r11
    1582:	cf 92       	push	r12
    1584:	df 92       	push	r13
    1586:	ef 92       	push	r14
    1588:	ff 92       	push	r15
    158a:	cf 93       	push	r28
    158c:	df 93       	push	r29
    158e:	ec 01       	movw	r28, r24
	if ( percent_ > oldPercent_ + PERCENT_PR_TICK )
    1590:	8a 84       	ldd	r8, Y+10	; 0x0a
    1592:	9b 84       	ldd	r9, Y+11	; 0x0b
    1594:	ac 84       	ldd	r10, Y+12	; 0x0c
    1596:	bd 84       	ldd	r11, Y+13	; 0x0d
    1598:	ce 84       	ldd	r12, Y+14	; 0x0e
    159a:	df 84       	ldd	r13, Y+15	; 0x0f
    159c:	e8 88       	ldd	r14, Y+16	; 0x10
    159e:	f9 88       	ldd	r15, Y+17	; 0x11
    15a0:	20 e0       	ldi	r18, 0x00	; 0
    15a2:	30 e0       	ldi	r19, 0x00	; 0
    15a4:	40 e8       	ldi	r20, 0x80	; 128
    15a6:	5d e3       	ldi	r21, 0x3D	; 61
    15a8:	c7 01       	movw	r24, r14
    15aa:	b6 01       	movw	r22, r12
    15ac:	0e 94 6c 15 	call	0x2ad8	; 0x2ad8 <__addsf3>
    15b0:	2b 01       	movw	r4, r22
    15b2:	3c 01       	movw	r6, r24
    15b4:	9b 01       	movw	r18, r22
    15b6:	ac 01       	movw	r20, r24
    15b8:	c5 01       	movw	r24, r10
    15ba:	b4 01       	movw	r22, r8
    15bc:	0e 94 1a 17 	call	0x2e34	; 0x2e34 <__gesf2>
    15c0:	18 16       	cp	r1, r24
    15c2:	6c f4       	brge	.+26     	; 0x15de <_ZN2M69TurnMotorEv+0x6c>
	{
		oldPercent_ += 0.0625;
    15c4:	4e 86       	std	Y+14, r4	; 0x0e
    15c6:	5f 86       	std	Y+15, r5	; 0x0f
    15c8:	68 8a       	std	Y+16, r6	; 0x10
    15ca:	79 8a       	std	Y+17, r7	; 0x11
		tmr3Ptr_->setDutyCycleComC( oldPercent_ );
    15cc:	b3 01       	movw	r22, r6
    15ce:	a2 01       	movw	r20, r4
    15d0:	8c 81       	ldd	r24, Y+4	; 0x04
    15d2:	9d 81       	ldd	r25, Y+5	; 0x05
    15d4:	80 d1       	rcall	.+768    	; 0x18d6 <_ZN6Timer516setDutyCycleComCEf>
		vTaskDelay( delay_ / portTICK_RATE_MS );
    15d6:	8f 89       	ldd	r24, Y+23	; 0x17
    15d8:	98 8d       	ldd	r25, Y+24	; 0x18
    15da:	7f d6       	rcall	.+3326   	; 0x22da <vTaskDelay>
    15dc:	1c c0       	rjmp	.+56     	; 0x1616 <_ZN2M69TurnMotorEv+0xa4>
	}
	else if ( percent_ < oldPercent_ )
    15de:	a7 01       	movw	r20, r14
    15e0:	96 01       	movw	r18, r12
    15e2:	c5 01       	movw	r24, r10
    15e4:	b4 01       	movw	r22, r8
    15e6:	0e 94 d0 15 	call	0x2ba0	; 0x2ba0 <__cmpsf2>
    15ea:	88 23       	and	r24, r24
    15ec:	a4 f4       	brge	.+40     	; 0x1616 <_ZN2M69TurnMotorEv+0xa4>
	{
		oldPercent_ -= 0.0625;
    15ee:	20 e0       	ldi	r18, 0x00	; 0
    15f0:	30 e0       	ldi	r19, 0x00	; 0
    15f2:	40 e8       	ldi	r20, 0x80	; 128
    15f4:	5d e3       	ldi	r21, 0x3D	; 61
    15f6:	c7 01       	movw	r24, r14
    15f8:	b6 01       	movw	r22, r12
    15fa:	0e 94 6b 15 	call	0x2ad6	; 0x2ad6 <__subsf3>
    15fe:	ab 01       	movw	r20, r22
    1600:	bc 01       	movw	r22, r24
    1602:	4e 87       	std	Y+14, r20	; 0x0e
    1604:	5f 87       	std	Y+15, r21	; 0x0f
    1606:	68 8b       	std	Y+16, r22	; 0x10
    1608:	79 8b       	std	Y+17, r23	; 0x11
		tmr3Ptr_->setDutyCycleComC( oldPercent_ );
    160a:	8c 81       	ldd	r24, Y+4	; 0x04
    160c:	9d 81       	ldd	r25, Y+5	; 0x05
    160e:	63 d1       	rcall	.+710    	; 0x18d6 <_ZN6Timer516setDutyCycleComCEf>
		vTaskDelay( delay_ / portTICK_RATE_MS );
    1610:	8f 89       	ldd	r24, Y+23	; 0x17
    1612:	98 8d       	ldd	r25, Y+24	; 0x18
    1614:	62 d6       	rcall	.+3268   	; 0x22da <vTaskDelay>
    1616:	df 91       	pop	r29
	}
}
    1618:	cf 91       	pop	r28
    161a:	ff 90       	pop	r15
    161c:	ef 90       	pop	r14
    161e:	df 90       	pop	r13
    1620:	cf 90       	pop	r12
    1622:	bf 90       	pop	r11
    1624:	af 90       	pop	r10
    1626:	9f 90       	pop	r9
    1628:	8f 90       	pop	r8
    162a:	7f 90       	pop	r7
    162c:	6f 90       	pop	r6
    162e:	5f 90       	pop	r5
    1630:	4f 90       	pop	r4
    1632:	08 95       	ret

00001634 <_ZN2M6C1EP6Timer5>:
    1634:	cf 93       	push	r28
* Author: jespe
*/

#include "M6.h"

M6::M6( Timer5* tmr )
    1636:	df 93       	push	r29
    1638:	ec 01       	movw	r28, r24
    163a:	cb 01       	movw	r24, r22
    163c:	2e ea       	ldi	r18, 0xAE	; 174
    163e:	32 e0       	ldi	r19, 0x02	; 2
    1640:	39 83       	std	Y+1, r19	; 0x01
    1642:	28 83       	st	Y, r18
{
	/* Store timer pointer */
	tmr3Ptr_ = tmr;
    1644:	7d 83       	std	Y+5, r23	; 0x05
    1646:	6c 83       	std	Y+4, r22	; 0x04
	
	/* This value is number of percent to add or subtract pr degree. */
	percentPrDeg = 0.07936507936507;
    1648:	49 e2       	ldi	r20, 0x29	; 41
    164a:	5a e8       	ldi	r21, 0x8A	; 138
    164c:	62 ea       	ldi	r22, 0xA2	; 162
    164e:	7d e3       	ldi	r23, 0x3D	; 61
    1650:	4e 83       	std	Y+6, r20	; 0x06
    1652:	5f 83       	std	Y+7, r21	; 0x07
    1654:	68 87       	std	Y+8, r22	; 0x08
    1656:	79 87       	std	Y+9, r23	; 0x09
	
	/* This value is the lowest duty cycle percentage needed to make motor turn. */
	startpercent_ = 2.5;
    1658:	40 e0       	ldi	r20, 0x00	; 0
    165a:	50 e0       	ldi	r21, 0x00	; 0
    165c:	60 e2       	ldi	r22, 0x20	; 32
    165e:	70 e4       	ldi	r23, 0x40	; 64
    1660:	4a 8b       	std	Y+18, r20	; 0x12
    1662:	5b 8b       	std	Y+19, r21	; 0x13
    1664:	6c 8b       	std	Y+20, r22	; 0x14
    1666:	7d 8b       	std	Y+21, r23	; 0x15
	
	/* This value is the delay on motor. A lower value makes motors go faster and higher value makes motors go slower. Value is in MS */
	delay_ = 1;
    1668:	21 e0       	ldi	r18, 0x01	; 1
    166a:	30 e0       	ldi	r19, 0x00	; 0
    166c:	38 8f       	std	Y+24, r19	; 0x18
    166e:	2f 8b       	std	Y+23, r18	; 0x17
	
	/* This value is the maximum number of degrees the motor can turn */
	maxDegrees_ = 63;
    1670:	2f e3       	ldi	r18, 0x3F	; 63
    1672:	2e 8b       	std	Y+22, r18	; 0x16
	*/
	virtual void SetDegrees( uint8_t degrees )
	{
		if ( maxDegrees_ >= degrees )
		{
			percent_ = percentPrDeg * degrees + startpercent_;
    1674:	4a 87       	std	Y+10, r20	; 0x0a
    1676:	5b 87       	std	Y+11, r21	; 0x0b
    1678:	6c 87       	std	Y+12, r22	; 0x0c
    167a:	7d 87       	std	Y+13, r23	; 0x0d
	
	/* Set motor to default startup value */
	SetDegrees( 0 );
	tmr3Ptr_->setDutyCycleComC( percent_ );
    167c:	2c d1       	rcall	.+600    	; 0x18d6 <_ZN6Timer516setDutyCycleComCEf>
	oldPercent_ = percent_;
    167e:	8a 85       	ldd	r24, Y+10	; 0x0a
    1680:	9b 85       	ldd	r25, Y+11	; 0x0b
    1682:	ac 85       	ldd	r26, Y+12	; 0x0c
    1684:	bd 85       	ldd	r27, Y+13	; 0x0d
    1686:	8e 87       	std	Y+14, r24	; 0x0e
    1688:	9f 87       	std	Y+15, r25	; 0x0f
    168a:	a8 8b       	std	Y+16, r26	; 0x10
    168c:	b9 8b       	std	Y+17, r27	; 0x11
}
    168e:	df 91       	pop	r29
    1690:	cf 91       	pop	r28
    1692:	08 95       	ret

00001694 <_ZN6Timer1C1Ev>:
#include <avr/io.h>

Timer1::Timer1()
{
	// Set all needed ports to outputs
	ROBOTARM_M1_OUT_PORT |= ( 1 << ROBOTARM_M1_OUT_PIN );
    1694:	84 b1       	in	r24, 0x04	; 4
    1696:	80 62       	ori	r24, 0x20	; 32
    1698:	84 b9       	out	0x04, r24	; 4
	ROBOTARM_M2_OUT_PORT |= ( 1 << ROBOTARM_M2_OUT_PIN );
    169a:	84 b1       	in	r24, 0x04	; 4
    169c:	80 64       	ori	r24, 0x40	; 64
    169e:	84 b9       	out	0x04, r24	; 4
	ROBOTARM_M3_OUT_PORT |= ( 1 << ROBOTARM_M3_OUT_PIN );
    16a0:	84 b1       	in	r24, 0x04	; 4
    16a2:	80 68       	ori	r24, 0x80	; 128
    16a4:	84 b9       	out	0x04, r24	; 4
		
	// Set timer to run in PWM, Phase Correct mode with 50 Hz freq. 
	TCCR1A = ( 1 << COM1A1 ) | ( 1 << COM1B1 ) | ( 1 << COM1C1 ) | ( 0 << WGM10 ) | ( 0 << WGM11 );
    16a6:	88 ea       	ldi	r24, 0xA8	; 168
    16a8:	80 93 80 00 	sts	0x0080, r24	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
	TCCR1B = ( 1 << WGM13 ) | ( 0 << CS10 )  | ( 1 << CS12 );
    16ac:	84 e1       	ldi	r24, 0x14	; 20
    16ae:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x700081>
	TCCR1C = 0;
    16b2:	10 92 82 00 	sts	0x0082, r1	; 0x800082 <__TEXT_REGION_LENGTH__+0x700082>
	ICR1 = 622;
    16b6:	8e e6       	ldi	r24, 0x6E	; 110
    16b8:	92 e0       	ldi	r25, 0x02	; 2
    16ba:	90 93 87 00 	sts	0x0087, r25	; 0x800087 <__TEXT_REGION_LENGTH__+0x700087>
    16be:	80 93 86 00 	sts	0x0086, r24	; 0x800086 <__TEXT_REGION_LENGTH__+0x700086>
	
	OCR1A = 0;
    16c2:	10 92 89 00 	sts	0x0089, r1	; 0x800089 <__TEXT_REGION_LENGTH__+0x700089>
    16c6:	10 92 88 00 	sts	0x0088, r1	; 0x800088 <__TEXT_REGION_LENGTH__+0x700088>
	OCR1B = 0;
    16ca:	10 92 8b 00 	sts	0x008B, r1	; 0x80008b <__TEXT_REGION_LENGTH__+0x70008b>
    16ce:	10 92 8a 00 	sts	0x008A, r1	; 0x80008a <__TEXT_REGION_LENGTH__+0x70008a>
	OCR1C = 0;
    16d2:	10 92 8d 00 	sts	0x008D, r1	; 0x80008d <__TEXT_REGION_LENGTH__+0x70008d>
    16d6:	10 92 8c 00 	sts	0x008C, r1	; 0x80008c <__TEXT_REGION_LENGTH__+0x70008c>
    16da:	08 95       	ret

000016dc <_ZN6Timer116setDutyCycleComAEf>:
}

void Timer1::setDutyCycleComA( float dutyCycle )
{
    16dc:	cf 92       	push	r12
    16de:	df 92       	push	r13
    16e0:	ef 92       	push	r14
    16e2:	ff 92       	push	r15
    16e4:	6a 01       	movw	r12, r20
    16e6:	7b 01       	movw	r14, r22
	float percent = ICR1/100;
    16e8:	20 91 86 00 	lds	r18, 0x0086	; 0x800086 <__TEXT_REGION_LENGTH__+0x700086>
    16ec:	30 91 87 00 	lds	r19, 0x0087	; 0x800087 <__TEXT_REGION_LENGTH__+0x700087>
    16f0:	36 95       	lsr	r19
    16f2:	27 95       	ror	r18
    16f4:	36 95       	lsr	r19
    16f6:	27 95       	ror	r18
    16f8:	ab e7       	ldi	r26, 0x7B	; 123
    16fa:	b4 e1       	ldi	r27, 0x14	; 20
    16fc:	0e 94 ab 17 	call	0x2f56	; 0x2f56 <__umulhisi3>
    1700:	96 95       	lsr	r25
    1702:	87 95       	ror	r24
	OCR1A = (uint8_t)percent*dutyCycle;
    1704:	bc 01       	movw	r22, r24
    1706:	77 27       	eor	r23, r23
    1708:	07 2e       	mov	r0, r23
    170a:	00 0c       	add	r0, r0
    170c:	88 0b       	sbc	r24, r24
    170e:	99 0b       	sbc	r25, r25
    1710:	0e 94 6a 16 	call	0x2cd4	; 0x2cd4 <__floatsisf>
    1714:	a7 01       	movw	r20, r14
    1716:	96 01       	movw	r18, r12
    1718:	0e 94 1e 17 	call	0x2e3c	; 0x2e3c <__mulsf3>
    171c:	0e 94 3c 16 	call	0x2c78	; 0x2c78 <__fixunssfsi>
    1720:	70 93 89 00 	sts	0x0089, r23	; 0x800089 <__TEXT_REGION_LENGTH__+0x700089>
    1724:	60 93 88 00 	sts	0x0088, r22	; 0x800088 <__TEXT_REGION_LENGTH__+0x700088>
}
    1728:	ff 90       	pop	r15
    172a:	ef 90       	pop	r14
    172c:	df 90       	pop	r13
    172e:	cf 90       	pop	r12
    1730:	08 95       	ret

00001732 <_ZN6Timer116setDutyCycleComBEf>:

void Timer1::setDutyCycleComB( float dutyCycle )
{
    1732:	cf 92       	push	r12
    1734:	df 92       	push	r13
    1736:	ef 92       	push	r14
    1738:	ff 92       	push	r15
    173a:	6a 01       	movw	r12, r20
    173c:	7b 01       	movw	r14, r22
	float percent = ICR1/100;
    173e:	20 91 86 00 	lds	r18, 0x0086	; 0x800086 <__TEXT_REGION_LENGTH__+0x700086>
    1742:	30 91 87 00 	lds	r19, 0x0087	; 0x800087 <__TEXT_REGION_LENGTH__+0x700087>
    1746:	36 95       	lsr	r19
    1748:	27 95       	ror	r18
    174a:	36 95       	lsr	r19
    174c:	27 95       	ror	r18
    174e:	ab e7       	ldi	r26, 0x7B	; 123
    1750:	b4 e1       	ldi	r27, 0x14	; 20
    1752:	0e 94 ab 17 	call	0x2f56	; 0x2f56 <__umulhisi3>
    1756:	96 95       	lsr	r25
    1758:	87 95       	ror	r24
	OCR1B = (uint8_t)percent*dutyCycle;
    175a:	bc 01       	movw	r22, r24
    175c:	77 27       	eor	r23, r23
    175e:	07 2e       	mov	r0, r23
    1760:	00 0c       	add	r0, r0
    1762:	88 0b       	sbc	r24, r24
    1764:	99 0b       	sbc	r25, r25
    1766:	0e 94 6a 16 	call	0x2cd4	; 0x2cd4 <__floatsisf>
    176a:	a7 01       	movw	r20, r14
    176c:	96 01       	movw	r18, r12
    176e:	0e 94 1e 17 	call	0x2e3c	; 0x2e3c <__mulsf3>
    1772:	0e 94 3c 16 	call	0x2c78	; 0x2c78 <__fixunssfsi>
    1776:	70 93 8b 00 	sts	0x008B, r23	; 0x80008b <__TEXT_REGION_LENGTH__+0x70008b>
    177a:	60 93 8a 00 	sts	0x008A, r22	; 0x80008a <__TEXT_REGION_LENGTH__+0x70008a>
}
    177e:	ff 90       	pop	r15
    1780:	ef 90       	pop	r14
    1782:	df 90       	pop	r13
    1784:	cf 90       	pop	r12
    1786:	08 95       	ret

00001788 <_ZN6Timer116setDutyCycleComCEf>:

void Timer1::setDutyCycleComC( float dutyCycle )
{
    1788:	cf 92       	push	r12
    178a:	df 92       	push	r13
    178c:	ef 92       	push	r14
    178e:	ff 92       	push	r15
    1790:	6a 01       	movw	r12, r20
    1792:	7b 01       	movw	r14, r22
	float percent = ICR1/100;
    1794:	20 91 86 00 	lds	r18, 0x0086	; 0x800086 <__TEXT_REGION_LENGTH__+0x700086>
    1798:	30 91 87 00 	lds	r19, 0x0087	; 0x800087 <__TEXT_REGION_LENGTH__+0x700087>
    179c:	36 95       	lsr	r19
    179e:	27 95       	ror	r18
    17a0:	36 95       	lsr	r19
    17a2:	27 95       	ror	r18
    17a4:	ab e7       	ldi	r26, 0x7B	; 123
    17a6:	b4 e1       	ldi	r27, 0x14	; 20
    17a8:	0e 94 ab 17 	call	0x2f56	; 0x2f56 <__umulhisi3>
    17ac:	96 95       	lsr	r25
    17ae:	87 95       	ror	r24
	OCR1C = (uint8_t)percent*dutyCycle;
    17b0:	bc 01       	movw	r22, r24
    17b2:	77 27       	eor	r23, r23
    17b4:	07 2e       	mov	r0, r23
    17b6:	00 0c       	add	r0, r0
    17b8:	88 0b       	sbc	r24, r24
    17ba:	99 0b       	sbc	r25, r25
    17bc:	0e 94 6a 16 	call	0x2cd4	; 0x2cd4 <__floatsisf>
    17c0:	a7 01       	movw	r20, r14
    17c2:	96 01       	movw	r18, r12
    17c4:	0e 94 1e 17 	call	0x2e3c	; 0x2e3c <__mulsf3>
    17c8:	0e 94 3c 16 	call	0x2c78	; 0x2c78 <__fixunssfsi>
    17cc:	70 93 8d 00 	sts	0x008D, r23	; 0x80008d <__TEXT_REGION_LENGTH__+0x70008d>
    17d0:	60 93 8c 00 	sts	0x008C, r22	; 0x80008c <__TEXT_REGION_LENGTH__+0x70008c>
    17d4:	ff 90       	pop	r15
    17d6:	ef 90       	pop	r14
    17d8:	df 90       	pop	r13
    17da:	cf 90       	pop	r12
    17dc:	08 95       	ret

000017de <_ZN6Timer5C1Ev>:
#include <avr/io.h>

Timer5::Timer5()
{
	// Set all needed ports to outputs
	ROBOTARM_M4_OUT_PORT |= ( 1 << ROBOTARM_M4_OUT_PIN );
    17de:	ea e0       	ldi	r30, 0x0A	; 10
    17e0:	f1 e0       	ldi	r31, 0x01	; 1
    17e2:	80 81       	ld	r24, Z
    17e4:	88 60       	ori	r24, 0x08	; 8
    17e6:	80 83       	st	Z, r24
	ROBOTARM_M5_OUT_PORT |= ( 1 << ROBOTARM_M5_OUT_PIN );
    17e8:	80 81       	ld	r24, Z
    17ea:	80 61       	ori	r24, 0x10	; 16
    17ec:	80 83       	st	Z, r24
	ROBOTARM_M6_OUT_PORT |= ( 1 << ROBOTARM_M6_OUT_PIN );
    17ee:	80 81       	ld	r24, Z
    17f0:	80 62       	ori	r24, 0x20	; 32
    17f2:	80 83       	st	Z, r24
	
	// Set timer to run in PWM, Phase Correct mode with 50 Hz freq.
	TCCR5A = ( 1 << COM3A1 ) | ( 1 << COM3B1 ) | ( 1 << COM3C1 ) | ( 0 << WGM30 ) | ( 0 << WGM31 );
    17f4:	88 ea       	ldi	r24, 0xA8	; 168
    17f6:	80 93 20 01 	sts	0x0120, r24	; 0x800120 <__TEXT_REGION_LENGTH__+0x700120>
	TCCR5B = ( 1 << WGM33 ) | ( 0 << CS30 )  | ( 1 << CS32 );
    17fa:	84 e1       	ldi	r24, 0x14	; 20
    17fc:	80 93 21 01 	sts	0x0121, r24	; 0x800121 <__TEXT_REGION_LENGTH__+0x700121>
	TCCR5C = 0;
    1800:	10 92 22 01 	sts	0x0122, r1	; 0x800122 <__TEXT_REGION_LENGTH__+0x700122>
	ICR5 = 622;
    1804:	8e e6       	ldi	r24, 0x6E	; 110
    1806:	92 e0       	ldi	r25, 0x02	; 2
    1808:	90 93 27 01 	sts	0x0127, r25	; 0x800127 <__TEXT_REGION_LENGTH__+0x700127>
    180c:	80 93 26 01 	sts	0x0126, r24	; 0x800126 <__TEXT_REGION_LENGTH__+0x700126>
	
	OCR5A = 0;
    1810:	10 92 29 01 	sts	0x0129, r1	; 0x800129 <__TEXT_REGION_LENGTH__+0x700129>
    1814:	10 92 28 01 	sts	0x0128, r1	; 0x800128 <__TEXT_REGION_LENGTH__+0x700128>
	OCR5B = 0;
    1818:	10 92 2b 01 	sts	0x012B, r1	; 0x80012b <__TEXT_REGION_LENGTH__+0x70012b>
    181c:	10 92 2a 01 	sts	0x012A, r1	; 0x80012a <__TEXT_REGION_LENGTH__+0x70012a>
	OCR5C = 0;
    1820:	10 92 2d 01 	sts	0x012D, r1	; 0x80012d <__TEXT_REGION_LENGTH__+0x70012d>
    1824:	10 92 2c 01 	sts	0x012C, r1	; 0x80012c <__TEXT_REGION_LENGTH__+0x70012c>
    1828:	08 95       	ret

0000182a <_ZN6Timer516setDutyCycleComAEf>:
}

void Timer5::setDutyCycleComA( float dutyCycle )
{
    182a:	cf 92       	push	r12
    182c:	df 92       	push	r13
    182e:	ef 92       	push	r14
    1830:	ff 92       	push	r15
    1832:	6a 01       	movw	r12, r20
    1834:	7b 01       	movw	r14, r22
	float percent = ICR5/100;
    1836:	20 91 26 01 	lds	r18, 0x0126	; 0x800126 <__TEXT_REGION_LENGTH__+0x700126>
    183a:	30 91 27 01 	lds	r19, 0x0127	; 0x800127 <__TEXT_REGION_LENGTH__+0x700127>
    183e:	36 95       	lsr	r19
    1840:	27 95       	ror	r18
    1842:	36 95       	lsr	r19
    1844:	27 95       	ror	r18
    1846:	ab e7       	ldi	r26, 0x7B	; 123
    1848:	b4 e1       	ldi	r27, 0x14	; 20
    184a:	0e 94 ab 17 	call	0x2f56	; 0x2f56 <__umulhisi3>
    184e:	96 95       	lsr	r25
    1850:	87 95       	ror	r24
	OCR5A = (uint8_t)percent*dutyCycle;
    1852:	bc 01       	movw	r22, r24
    1854:	77 27       	eor	r23, r23
    1856:	07 2e       	mov	r0, r23
    1858:	00 0c       	add	r0, r0
    185a:	88 0b       	sbc	r24, r24
    185c:	99 0b       	sbc	r25, r25
    185e:	0e 94 6a 16 	call	0x2cd4	; 0x2cd4 <__floatsisf>
    1862:	a7 01       	movw	r20, r14
    1864:	96 01       	movw	r18, r12
    1866:	0e 94 1e 17 	call	0x2e3c	; 0x2e3c <__mulsf3>
    186a:	0e 94 3c 16 	call	0x2c78	; 0x2c78 <__fixunssfsi>
    186e:	70 93 29 01 	sts	0x0129, r23	; 0x800129 <__TEXT_REGION_LENGTH__+0x700129>
    1872:	60 93 28 01 	sts	0x0128, r22	; 0x800128 <__TEXT_REGION_LENGTH__+0x700128>
}
    1876:	ff 90       	pop	r15
    1878:	ef 90       	pop	r14
    187a:	df 90       	pop	r13
    187c:	cf 90       	pop	r12
    187e:	08 95       	ret

00001880 <_ZN6Timer516setDutyCycleComBEf>:

void Timer5::setDutyCycleComB( float dutyCycle )
{
    1880:	cf 92       	push	r12
    1882:	df 92       	push	r13
    1884:	ef 92       	push	r14
    1886:	ff 92       	push	r15
    1888:	6a 01       	movw	r12, r20
    188a:	7b 01       	movw	r14, r22
	float percent = ICR5/100;
    188c:	20 91 26 01 	lds	r18, 0x0126	; 0x800126 <__TEXT_REGION_LENGTH__+0x700126>
    1890:	30 91 27 01 	lds	r19, 0x0127	; 0x800127 <__TEXT_REGION_LENGTH__+0x700127>
    1894:	36 95       	lsr	r19
    1896:	27 95       	ror	r18
    1898:	36 95       	lsr	r19
    189a:	27 95       	ror	r18
    189c:	ab e7       	ldi	r26, 0x7B	; 123
    189e:	b4 e1       	ldi	r27, 0x14	; 20
    18a0:	0e 94 ab 17 	call	0x2f56	; 0x2f56 <__umulhisi3>
    18a4:	96 95       	lsr	r25
    18a6:	87 95       	ror	r24
	OCR5B = (uint8_t)percent*dutyCycle;
    18a8:	bc 01       	movw	r22, r24
    18aa:	77 27       	eor	r23, r23
    18ac:	07 2e       	mov	r0, r23
    18ae:	00 0c       	add	r0, r0
    18b0:	88 0b       	sbc	r24, r24
    18b2:	99 0b       	sbc	r25, r25
    18b4:	0e 94 6a 16 	call	0x2cd4	; 0x2cd4 <__floatsisf>
    18b8:	a7 01       	movw	r20, r14
    18ba:	96 01       	movw	r18, r12
    18bc:	0e 94 1e 17 	call	0x2e3c	; 0x2e3c <__mulsf3>
    18c0:	0e 94 3c 16 	call	0x2c78	; 0x2c78 <__fixunssfsi>
    18c4:	70 93 2b 01 	sts	0x012B, r23	; 0x80012b <__TEXT_REGION_LENGTH__+0x70012b>
    18c8:	60 93 2a 01 	sts	0x012A, r22	; 0x80012a <__TEXT_REGION_LENGTH__+0x70012a>
}
    18cc:	ff 90       	pop	r15
    18ce:	ef 90       	pop	r14
    18d0:	df 90       	pop	r13
    18d2:	cf 90       	pop	r12
    18d4:	08 95       	ret

000018d6 <_ZN6Timer516setDutyCycleComCEf>:

void Timer5::setDutyCycleComC( float dutyCycle )
{
    18d6:	cf 92       	push	r12
    18d8:	df 92       	push	r13
    18da:	ef 92       	push	r14
    18dc:	ff 92       	push	r15
    18de:	6a 01       	movw	r12, r20
    18e0:	7b 01       	movw	r14, r22
	float percent = ICR5/100;
    18e2:	20 91 26 01 	lds	r18, 0x0126	; 0x800126 <__TEXT_REGION_LENGTH__+0x700126>
    18e6:	30 91 27 01 	lds	r19, 0x0127	; 0x800127 <__TEXT_REGION_LENGTH__+0x700127>
    18ea:	36 95       	lsr	r19
    18ec:	27 95       	ror	r18
    18ee:	36 95       	lsr	r19
    18f0:	27 95       	ror	r18
    18f2:	ab e7       	ldi	r26, 0x7B	; 123
    18f4:	b4 e1       	ldi	r27, 0x14	; 20
    18f6:	0e 94 ab 17 	call	0x2f56	; 0x2f56 <__umulhisi3>
    18fa:	96 95       	lsr	r25
    18fc:	87 95       	ror	r24
	OCR5C = (uint8_t)percent*dutyCycle;
    18fe:	bc 01       	movw	r22, r24
    1900:	77 27       	eor	r23, r23
    1902:	07 2e       	mov	r0, r23
    1904:	00 0c       	add	r0, r0
    1906:	88 0b       	sbc	r24, r24
    1908:	99 0b       	sbc	r25, r25
    190a:	0e 94 6a 16 	call	0x2cd4	; 0x2cd4 <__floatsisf>
    190e:	a7 01       	movw	r20, r14
    1910:	96 01       	movw	r18, r12
    1912:	0e 94 1e 17 	call	0x2e3c	; 0x2e3c <__mulsf3>
    1916:	0e 94 3c 16 	call	0x2c78	; 0x2c78 <__fixunssfsi>
    191a:	70 93 2d 01 	sts	0x012D, r23	; 0x80012d <__TEXT_REGION_LENGTH__+0x70012d>
    191e:	60 93 2c 01 	sts	0x012C, r22	; 0x80012c <__TEXT_REGION_LENGTH__+0x70012c>
    1922:	ff 90       	pop	r15
    1924:	ef 90       	pop	r14
    1926:	df 90       	pop	r13
    1928:	cf 90       	pop	r12
    192a:	08 95       	ret

0000192c <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
    192c:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
    192e:	03 96       	adiw	r24, 0x03	; 3
    1930:	92 83       	std	Z+2, r25	; 0x02
    1932:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    1934:	2f ef       	ldi	r18, 0xFF	; 255
    1936:	3f ef       	ldi	r19, 0xFF	; 255
    1938:	34 83       	std	Z+4, r19	; 0x04
    193a:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
    193c:	96 83       	std	Z+6, r25	; 0x06
    193e:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
    1940:	90 87       	std	Z+8, r25	; 0x08
    1942:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
    1944:	10 82       	st	Z, r1
    1946:	08 95       	ret

00001948 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    1948:	fc 01       	movw	r30, r24
    194a:	11 86       	std	Z+9, r1	; 0x09
    194c:	10 86       	std	Z+8, r1	; 0x08
    194e:	08 95       	ret

00001950 <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
    1950:	cf 93       	push	r28
    1952:	df 93       	push	r29
    1954:	fc 01       	movw	r30, r24
    1956:	db 01       	movw	r26, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
    1958:	21 81       	ldd	r18, Z+1	; 0x01
    195a:	32 81       	ldd	r19, Z+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
    195c:	e9 01       	movw	r28, r18
    195e:	8a 81       	ldd	r24, Y+2	; 0x02
    1960:	9b 81       	ldd	r25, Y+3	; 0x03
    1962:	13 96       	adiw	r26, 0x03	; 3
    1964:	9c 93       	st	X, r25
    1966:	8e 93       	st	-X, r24
    1968:	12 97       	sbiw	r26, 0x02	; 2
	pxNewListItem->pxPrevious = pxList->pxIndex;
    196a:	81 81       	ldd	r24, Z+1	; 0x01
    196c:	92 81       	ldd	r25, Z+2	; 0x02
    196e:	15 96       	adiw	r26, 0x05	; 5
    1970:	9c 93       	st	X, r25
    1972:	8e 93       	st	-X, r24
    1974:	14 97       	sbiw	r26, 0x04	; 4
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    1976:	8a 81       	ldd	r24, Y+2	; 0x02
    1978:	9b 81       	ldd	r25, Y+3	; 0x03
    197a:	ec 01       	movw	r28, r24
    197c:	7d 83       	std	Y+5, r23	; 0x05
    197e:	6c 83       	std	Y+4, r22	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
    1980:	e9 01       	movw	r28, r18
    1982:	7b 83       	std	Y+3, r23	; 0x03
    1984:	6a 83       	std	Y+2, r22	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
    1986:	72 83       	std	Z+2, r23	; 0x02
    1988:	61 83       	std	Z+1, r22	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    198a:	19 96       	adiw	r26, 0x09	; 9
    198c:	fc 93       	st	X, r31
    198e:	ee 93       	st	-X, r30
    1990:	18 97       	sbiw	r26, 0x08	; 8

	( pxList->uxNumberOfItems )++;
    1992:	80 81       	ld	r24, Z
    1994:	8f 5f       	subi	r24, 0xFF	; 255
    1996:	80 83       	st	Z, r24
}
    1998:	df 91       	pop	r29
    199a:	cf 91       	pop	r28
    199c:	08 95       	ret

0000199e <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
    199e:	cf 93       	push	r28
    19a0:	df 93       	push	r29
    19a2:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
    19a4:	48 81       	ld	r20, Y
    19a6:	59 81       	ldd	r21, Y+1	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    19a8:	4f 3f       	cpi	r20, 0xFF	; 255
    19aa:	2f ef       	ldi	r18, 0xFF	; 255
    19ac:	52 07       	cpc	r21, r18
    19ae:	31 f4       	brne	.+12     	; 0x19bc <vListInsert+0x1e>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    19b0:	dc 01       	movw	r26, r24
    19b2:	17 96       	adiw	r26, 0x07	; 7
    19b4:	ed 91       	ld	r30, X+
    19b6:	fc 91       	ld	r31, X
    19b8:	18 97       	sbiw	r26, 0x08	; 8
    19ba:	0d c0       	rjmp	.+26     	; 0x19d6 <vListInsert+0x38>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    19bc:	fc 01       	movw	r30, r24
    19be:	33 96       	adiw	r30, 0x03	; 3
    19c0:	03 c0       	rjmp	.+6      	; 0x19c8 <vListInsert+0x2a>
    19c2:	02 80       	ldd	r0, Z+2	; 0x02
    19c4:	f3 81       	ldd	r31, Z+3	; 0x03
    19c6:	e0 2d       	mov	r30, r0
    19c8:	a2 81       	ldd	r26, Z+2	; 0x02
    19ca:	b3 81       	ldd	r27, Z+3	; 0x03
    19cc:	2d 91       	ld	r18, X+
    19ce:	3c 91       	ld	r19, X
    19d0:	42 17       	cp	r20, r18
    19d2:	53 07       	cpc	r21, r19
    19d4:	b0 f7       	brcc	.-20     	; 0x19c2 <vListInsert+0x24>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    19d6:	a2 81       	ldd	r26, Z+2	; 0x02
    19d8:	b3 81       	ldd	r27, Z+3	; 0x03
    19da:	bb 83       	std	Y+3, r27	; 0x03
    19dc:	aa 83       	std	Y+2, r26	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    19de:	15 96       	adiw	r26, 0x05	; 5
    19e0:	dc 93       	st	X, r29
    19e2:	ce 93       	st	-X, r28
    19e4:	14 97       	sbiw	r26, 0x04	; 4
	pxNewListItem->pxPrevious = pxIterator;
    19e6:	fd 83       	std	Y+5, r31	; 0x05
    19e8:	ec 83       	std	Y+4, r30	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    19ea:	d3 83       	std	Z+3, r29	; 0x03
    19ec:	c2 83       	std	Z+2, r28	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    19ee:	99 87       	std	Y+9, r25	; 0x09
    19f0:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    19f2:	fc 01       	movw	r30, r24
    19f4:	20 81       	ld	r18, Z
    19f6:	2f 5f       	subi	r18, 0xFF	; 255
    19f8:	20 83       	st	Z, r18
}
    19fa:	df 91       	pop	r29
    19fc:	cf 91       	pop	r28
    19fe:	08 95       	ret

00001a00 <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
    1a00:	fc 01       	movw	r30, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    1a02:	a2 81       	ldd	r26, Z+2	; 0x02
    1a04:	b3 81       	ldd	r27, Z+3	; 0x03
    1a06:	84 81       	ldd	r24, Z+4	; 0x04
    1a08:	95 81       	ldd	r25, Z+5	; 0x05
    1a0a:	15 96       	adiw	r26, 0x05	; 5
    1a0c:	9c 93       	st	X, r25
    1a0e:	8e 93       	st	-X, r24
    1a10:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    1a12:	a4 81       	ldd	r26, Z+4	; 0x04
    1a14:	b5 81       	ldd	r27, Z+5	; 0x05
    1a16:	82 81       	ldd	r24, Z+2	; 0x02
    1a18:	93 81       	ldd	r25, Z+3	; 0x03
    1a1a:	13 96       	adiw	r26, 0x03	; 3
    1a1c:	9c 93       	st	X, r25
    1a1e:	8e 93       	st	-X, r24
    1a20:	12 97       	sbiw	r26, 0x02	; 2
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    1a22:	a0 85       	ldd	r26, Z+8	; 0x08
    1a24:	b1 85       	ldd	r27, Z+9	; 0x09

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    1a26:	11 96       	adiw	r26, 0x01	; 1
    1a28:	8d 91       	ld	r24, X+
    1a2a:	9c 91       	ld	r25, X
    1a2c:	12 97       	sbiw	r26, 0x02	; 2
    1a2e:	e8 17       	cp	r30, r24
    1a30:	f9 07       	cpc	r31, r25
    1a32:	31 f4       	brne	.+12     	; 0x1a40 <vListRemove+0x40>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    1a34:	84 81       	ldd	r24, Z+4	; 0x04
    1a36:	95 81       	ldd	r25, Z+5	; 0x05
    1a38:	12 96       	adiw	r26, 0x02	; 2
    1a3a:	9c 93       	st	X, r25
    1a3c:	8e 93       	st	-X, r24
    1a3e:	11 97       	sbiw	r26, 0x01	; 1
	}

	pxItemToRemove->pvContainer = NULL;
    1a40:	11 86       	std	Z+9, r1	; 0x09
    1a42:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    1a44:	8c 91       	ld	r24, X
    1a46:	81 50       	subi	r24, 0x01	; 1
    1a48:	8c 93       	st	X, r24
    1a4a:	08 95       	ret

00001a4c <prvSetupTimerInterrupt>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    1a4c:	8a ef       	ldi	r24, 0xFA	; 250
    1a4e:	87 bd       	out	0x27, r24	; 39
    1a50:	82 e0       	ldi	r24, 0x02	; 2
    1a52:	84 bd       	out	0x24, r24	; 36
    1a54:	93 e0       	ldi	r25, 0x03	; 3
    1a56:	95 bd       	out	0x25, r25	; 37
    1a58:	80 93 6e 00 	sts	0x006E, r24	; 0x80006e <__TEXT_REGION_LENGTH__+0x70006e>
    1a5c:	08 95       	ret

00001a5e <pxPortInitialiseStack>:
    1a5e:	31 e1       	ldi	r19, 0x11	; 17
    1a60:	fc 01       	movw	r30, r24
    1a62:	30 83       	st	Z, r19
    1a64:	31 97       	sbiw	r30, 0x01	; 1
    1a66:	22 e2       	ldi	r18, 0x22	; 34
    1a68:	20 83       	st	Z, r18
    1a6a:	31 97       	sbiw	r30, 0x01	; 1
    1a6c:	a3 e3       	ldi	r26, 0x33	; 51
    1a6e:	a0 83       	st	Z, r26
    1a70:	31 97       	sbiw	r30, 0x01	; 1
    1a72:	60 83       	st	Z, r22
    1a74:	31 97       	sbiw	r30, 0x01	; 1
    1a76:	70 83       	st	Z, r23
    1a78:	31 97       	sbiw	r30, 0x01	; 1
    1a7a:	10 82       	st	Z, r1
    1a7c:	31 97       	sbiw	r30, 0x01	; 1
    1a7e:	10 82       	st	Z, r1
    1a80:	31 97       	sbiw	r30, 0x01	; 1
    1a82:	60 e8       	ldi	r22, 0x80	; 128
    1a84:	60 83       	st	Z, r22
    1a86:	31 97       	sbiw	r30, 0x01	; 1
    1a88:	10 82       	st	Z, r1
    1a8a:	31 97       	sbiw	r30, 0x01	; 1
    1a8c:	10 82       	st	Z, r1
    1a8e:	31 97       	sbiw	r30, 0x01	; 1
    1a90:	10 82       	st	Z, r1
    1a92:	31 97       	sbiw	r30, 0x01	; 1
    1a94:	62 e0       	ldi	r22, 0x02	; 2
    1a96:	60 83       	st	Z, r22
    1a98:	31 97       	sbiw	r30, 0x01	; 1
    1a9a:	63 e0       	ldi	r22, 0x03	; 3
    1a9c:	60 83       	st	Z, r22
    1a9e:	31 97       	sbiw	r30, 0x01	; 1
    1aa0:	64 e0       	ldi	r22, 0x04	; 4
    1aa2:	60 83       	st	Z, r22
    1aa4:	31 97       	sbiw	r30, 0x01	; 1
    1aa6:	65 e0       	ldi	r22, 0x05	; 5
    1aa8:	60 83       	st	Z, r22
    1aaa:	31 97       	sbiw	r30, 0x01	; 1
    1aac:	66 e0       	ldi	r22, 0x06	; 6
    1aae:	60 83       	st	Z, r22
    1ab0:	31 97       	sbiw	r30, 0x01	; 1
    1ab2:	67 e0       	ldi	r22, 0x07	; 7
    1ab4:	60 83       	st	Z, r22
    1ab6:	31 97       	sbiw	r30, 0x01	; 1
    1ab8:	68 e0       	ldi	r22, 0x08	; 8
    1aba:	60 83       	st	Z, r22
    1abc:	31 97       	sbiw	r30, 0x01	; 1
    1abe:	69 e0       	ldi	r22, 0x09	; 9
    1ac0:	60 83       	st	Z, r22
    1ac2:	31 97       	sbiw	r30, 0x01	; 1
    1ac4:	60 e1       	ldi	r22, 0x10	; 16
    1ac6:	60 83       	st	Z, r22
    1ac8:	31 97       	sbiw	r30, 0x01	; 1
    1aca:	30 83       	st	Z, r19
    1acc:	31 97       	sbiw	r30, 0x01	; 1
    1ace:	32 e1       	ldi	r19, 0x12	; 18
    1ad0:	30 83       	st	Z, r19
    1ad2:	31 97       	sbiw	r30, 0x01	; 1
    1ad4:	33 e1       	ldi	r19, 0x13	; 19
    1ad6:	30 83       	st	Z, r19
    1ad8:	31 97       	sbiw	r30, 0x01	; 1
    1ada:	34 e1       	ldi	r19, 0x14	; 20
    1adc:	30 83       	st	Z, r19
    1ade:	31 97       	sbiw	r30, 0x01	; 1
    1ae0:	35 e1       	ldi	r19, 0x15	; 21
    1ae2:	30 83       	st	Z, r19
    1ae4:	31 97       	sbiw	r30, 0x01	; 1
    1ae6:	36 e1       	ldi	r19, 0x16	; 22
    1ae8:	30 83       	st	Z, r19
    1aea:	31 97       	sbiw	r30, 0x01	; 1
    1aec:	37 e1       	ldi	r19, 0x17	; 23
    1aee:	30 83       	st	Z, r19
    1af0:	31 97       	sbiw	r30, 0x01	; 1
    1af2:	38 e1       	ldi	r19, 0x18	; 24
    1af4:	30 83       	st	Z, r19
    1af6:	31 97       	sbiw	r30, 0x01	; 1
    1af8:	39 e1       	ldi	r19, 0x19	; 25
    1afa:	30 83       	st	Z, r19
    1afc:	31 97       	sbiw	r30, 0x01	; 1
    1afe:	30 e2       	ldi	r19, 0x20	; 32
    1b00:	30 83       	st	Z, r19
    1b02:	31 97       	sbiw	r30, 0x01	; 1
    1b04:	31 e2       	ldi	r19, 0x21	; 33
    1b06:	30 83       	st	Z, r19
    1b08:	31 97       	sbiw	r30, 0x01	; 1
    1b0a:	20 83       	st	Z, r18
    1b0c:	31 97       	sbiw	r30, 0x01	; 1
    1b0e:	23 e2       	ldi	r18, 0x23	; 35
    1b10:	20 83       	st	Z, r18
    1b12:	31 97       	sbiw	r30, 0x01	; 1
    1b14:	40 83       	st	Z, r20
    1b16:	31 97       	sbiw	r30, 0x01	; 1
    1b18:	50 83       	st	Z, r21
    1b1a:	31 97       	sbiw	r30, 0x01	; 1
    1b1c:	26 e2       	ldi	r18, 0x26	; 38
    1b1e:	20 83       	st	Z, r18
    1b20:	31 97       	sbiw	r30, 0x01	; 1
    1b22:	27 e2       	ldi	r18, 0x27	; 39
    1b24:	20 83       	st	Z, r18
    1b26:	31 97       	sbiw	r30, 0x01	; 1
    1b28:	28 e2       	ldi	r18, 0x28	; 40
    1b2a:	20 83       	st	Z, r18
    1b2c:	31 97       	sbiw	r30, 0x01	; 1
    1b2e:	29 e2       	ldi	r18, 0x29	; 41
    1b30:	20 83       	st	Z, r18
    1b32:	31 97       	sbiw	r30, 0x01	; 1
    1b34:	20 e3       	ldi	r18, 0x30	; 48
    1b36:	20 83       	st	Z, r18
    1b38:	31 97       	sbiw	r30, 0x01	; 1
    1b3a:	21 e3       	ldi	r18, 0x31	; 49
    1b3c:	20 83       	st	Z, r18
    1b3e:	89 97       	sbiw	r24, 0x29	; 41
    1b40:	08 95       	ret

00001b42 <xPortStartScheduler>:
    1b42:	84 df       	rcall	.-248    	; 0x1a4c <prvSetupTimerInterrupt>
    1b44:	a0 91 b4 12 	lds	r26, 0x12B4	; 0x8012b4 <pxCurrentTCB>
    1b48:	b0 91 b5 12 	lds	r27, 0x12B5	; 0x8012b5 <pxCurrentTCB+0x1>
    1b4c:	cd 91       	ld	r28, X+
    1b4e:	cd bf       	out	0x3d, r28	; 61
    1b50:	dd 91       	ld	r29, X+
    1b52:	de bf       	out	0x3e, r29	; 62
    1b54:	ff 91       	pop	r31
    1b56:	ef 91       	pop	r30
    1b58:	df 91       	pop	r29
    1b5a:	cf 91       	pop	r28
    1b5c:	bf 91       	pop	r27
    1b5e:	af 91       	pop	r26
    1b60:	9f 91       	pop	r25
    1b62:	8f 91       	pop	r24
    1b64:	7f 91       	pop	r23
    1b66:	6f 91       	pop	r22
    1b68:	5f 91       	pop	r21
    1b6a:	4f 91       	pop	r20
    1b6c:	3f 91       	pop	r19
    1b6e:	2f 91       	pop	r18
    1b70:	1f 91       	pop	r17
    1b72:	0f 91       	pop	r16
    1b74:	ff 90       	pop	r15
    1b76:	ef 90       	pop	r14
    1b78:	df 90       	pop	r13
    1b7a:	cf 90       	pop	r12
    1b7c:	bf 90       	pop	r11
    1b7e:	af 90       	pop	r10
    1b80:	9f 90       	pop	r9
    1b82:	8f 90       	pop	r8
    1b84:	7f 90       	pop	r7
    1b86:	6f 90       	pop	r6
    1b88:	5f 90       	pop	r5
    1b8a:	4f 90       	pop	r4
    1b8c:	3f 90       	pop	r3
    1b8e:	2f 90       	pop	r2
    1b90:	1f 90       	pop	r1
    1b92:	0f 90       	pop	r0
    1b94:	0c be       	out	0x3c, r0	; 60
    1b96:	0f 90       	pop	r0
    1b98:	0b be       	out	0x3b, r0	; 59
    1b9a:	0f 90       	pop	r0
    1b9c:	0f be       	out	0x3f, r0	; 63
    1b9e:	0f 90       	pop	r0
    1ba0:	08 95       	ret
    1ba2:	81 e0       	ldi	r24, 0x01	; 1
    1ba4:	08 95       	ret

00001ba6 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    1ba6:	0f 92       	push	r0
    1ba8:	0f b6       	in	r0, 0x3f	; 63
    1baa:	f8 94       	cli
    1bac:	0f 92       	push	r0
    1bae:	0b b6       	in	r0, 0x3b	; 59
    1bb0:	0f 92       	push	r0
    1bb2:	0c b6       	in	r0, 0x3c	; 60
    1bb4:	0f 92       	push	r0
    1bb6:	1f 92       	push	r1
    1bb8:	11 24       	eor	r1, r1
    1bba:	2f 92       	push	r2
    1bbc:	3f 92       	push	r3
    1bbe:	4f 92       	push	r4
    1bc0:	5f 92       	push	r5
    1bc2:	6f 92       	push	r6
    1bc4:	7f 92       	push	r7
    1bc6:	8f 92       	push	r8
    1bc8:	9f 92       	push	r9
    1bca:	af 92       	push	r10
    1bcc:	bf 92       	push	r11
    1bce:	cf 92       	push	r12
    1bd0:	df 92       	push	r13
    1bd2:	ef 92       	push	r14
    1bd4:	ff 92       	push	r15
    1bd6:	0f 93       	push	r16
    1bd8:	1f 93       	push	r17
    1bda:	2f 93       	push	r18
    1bdc:	3f 93       	push	r19
    1bde:	4f 93       	push	r20
    1be0:	5f 93       	push	r21
    1be2:	6f 93       	push	r22
    1be4:	7f 93       	push	r23
    1be6:	8f 93       	push	r24
    1be8:	9f 93       	push	r25
    1bea:	af 93       	push	r26
    1bec:	bf 93       	push	r27
    1bee:	cf 93       	push	r28
    1bf0:	df 93       	push	r29
    1bf2:	ef 93       	push	r30
    1bf4:	ff 93       	push	r31
    1bf6:	a0 91 b4 12 	lds	r26, 0x12B4	; 0x8012b4 <pxCurrentTCB>
    1bfa:	b0 91 b5 12 	lds	r27, 0x12B5	; 0x8012b5 <pxCurrentTCB+0x1>
    1bfe:	0d b6       	in	r0, 0x3d	; 61
    1c00:	0d 92       	st	X+, r0
    1c02:	0e b6       	in	r0, 0x3e	; 62
    1c04:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    1c06:	86 d3       	rcall	.+1804   	; 0x2314 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1c08:	a0 91 b4 12 	lds	r26, 0x12B4	; 0x8012b4 <pxCurrentTCB>
    1c0c:	b0 91 b5 12 	lds	r27, 0x12B5	; 0x8012b5 <pxCurrentTCB+0x1>
    1c10:	cd 91       	ld	r28, X+
    1c12:	cd bf       	out	0x3d, r28	; 61
    1c14:	dd 91       	ld	r29, X+
    1c16:	de bf       	out	0x3e, r29	; 62
    1c18:	ff 91       	pop	r31
    1c1a:	ef 91       	pop	r30
    1c1c:	df 91       	pop	r29
    1c1e:	cf 91       	pop	r28
    1c20:	bf 91       	pop	r27
    1c22:	af 91       	pop	r26
    1c24:	9f 91       	pop	r25
    1c26:	8f 91       	pop	r24
    1c28:	7f 91       	pop	r23
    1c2a:	6f 91       	pop	r22
    1c2c:	5f 91       	pop	r21
    1c2e:	4f 91       	pop	r20
    1c30:	3f 91       	pop	r19
    1c32:	2f 91       	pop	r18
    1c34:	1f 91       	pop	r17
    1c36:	0f 91       	pop	r16
    1c38:	ff 90       	pop	r15
    1c3a:	ef 90       	pop	r14
    1c3c:	df 90       	pop	r13
    1c3e:	cf 90       	pop	r12
    1c40:	bf 90       	pop	r11
    1c42:	af 90       	pop	r10
    1c44:	9f 90       	pop	r9
    1c46:	8f 90       	pop	r8
    1c48:	7f 90       	pop	r7
    1c4a:	6f 90       	pop	r6
    1c4c:	5f 90       	pop	r5
    1c4e:	4f 90       	pop	r4
    1c50:	3f 90       	pop	r3
    1c52:	2f 90       	pop	r2
    1c54:	1f 90       	pop	r1
    1c56:	0f 90       	pop	r0
    1c58:	0c be       	out	0x3c, r0	; 60
    1c5a:	0f 90       	pop	r0
    1c5c:	0b be       	out	0x3b, r0	; 59
    1c5e:	0f 90       	pop	r0
    1c60:	0f be       	out	0x3f, r0	; 63
    1c62:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1c64:	08 95       	ret

00001c66 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    1c66:	0f 92       	push	r0
    1c68:	0f b6       	in	r0, 0x3f	; 63
    1c6a:	f8 94       	cli
    1c6c:	0f 92       	push	r0
    1c6e:	0b b6       	in	r0, 0x3b	; 59
    1c70:	0f 92       	push	r0
    1c72:	0c b6       	in	r0, 0x3c	; 60
    1c74:	0f 92       	push	r0
    1c76:	1f 92       	push	r1
    1c78:	11 24       	eor	r1, r1
    1c7a:	2f 92       	push	r2
    1c7c:	3f 92       	push	r3
    1c7e:	4f 92       	push	r4
    1c80:	5f 92       	push	r5
    1c82:	6f 92       	push	r6
    1c84:	7f 92       	push	r7
    1c86:	8f 92       	push	r8
    1c88:	9f 92       	push	r9
    1c8a:	af 92       	push	r10
    1c8c:	bf 92       	push	r11
    1c8e:	cf 92       	push	r12
    1c90:	df 92       	push	r13
    1c92:	ef 92       	push	r14
    1c94:	ff 92       	push	r15
    1c96:	0f 93       	push	r16
    1c98:	1f 93       	push	r17
    1c9a:	2f 93       	push	r18
    1c9c:	3f 93       	push	r19
    1c9e:	4f 93       	push	r20
    1ca0:	5f 93       	push	r21
    1ca2:	6f 93       	push	r22
    1ca4:	7f 93       	push	r23
    1ca6:	8f 93       	push	r24
    1ca8:	9f 93       	push	r25
    1caa:	af 93       	push	r26
    1cac:	bf 93       	push	r27
    1cae:	cf 93       	push	r28
    1cb0:	df 93       	push	r29
    1cb2:	ef 93       	push	r30
    1cb4:	ff 93       	push	r31
    1cb6:	a0 91 b4 12 	lds	r26, 0x12B4	; 0x8012b4 <pxCurrentTCB>
    1cba:	b0 91 b5 12 	lds	r27, 0x12B5	; 0x8012b5 <pxCurrentTCB+0x1>
    1cbe:	0d b6       	in	r0, 0x3d	; 61
    1cc0:	0d 92       	st	X+, r0
    1cc2:	0e b6       	in	r0, 0x3e	; 62
    1cc4:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    1cc6:	f1 d1       	rcall	.+994    	; 0x20aa <vTaskIncrementTick>
	vTaskSwitchContext();
    1cc8:	25 d3       	rcall	.+1610   	; 0x2314 <vTaskSwitchContext>
    1cca:	a0 91 b4 12 	lds	r26, 0x12B4	; 0x8012b4 <pxCurrentTCB>
	portRESTORE_CONTEXT();
    1cce:	b0 91 b5 12 	lds	r27, 0x12B5	; 0x8012b5 <pxCurrentTCB+0x1>
    1cd2:	cd 91       	ld	r28, X+
    1cd4:	cd bf       	out	0x3d, r28	; 61
    1cd6:	dd 91       	ld	r29, X+
    1cd8:	de bf       	out	0x3e, r29	; 62
    1cda:	ff 91       	pop	r31
    1cdc:	ef 91       	pop	r30
    1cde:	df 91       	pop	r29
    1ce0:	cf 91       	pop	r28
    1ce2:	bf 91       	pop	r27
    1ce4:	af 91       	pop	r26
    1ce6:	9f 91       	pop	r25
    1ce8:	8f 91       	pop	r24
    1cea:	7f 91       	pop	r23
    1cec:	6f 91       	pop	r22
    1cee:	5f 91       	pop	r21
    1cf0:	4f 91       	pop	r20
    1cf2:	3f 91       	pop	r19
    1cf4:	2f 91       	pop	r18
    1cf6:	1f 91       	pop	r17
    1cf8:	0f 91       	pop	r16
    1cfa:	ff 90       	pop	r15
    1cfc:	ef 90       	pop	r14
    1cfe:	df 90       	pop	r13
    1d00:	cf 90       	pop	r12
    1d02:	bf 90       	pop	r11
    1d04:	af 90       	pop	r10
    1d06:	9f 90       	pop	r9
    1d08:	8f 90       	pop	r8
    1d0a:	7f 90       	pop	r7
    1d0c:	6f 90       	pop	r6
    1d0e:	5f 90       	pop	r5
    1d10:	4f 90       	pop	r4
    1d12:	3f 90       	pop	r3
    1d14:	2f 90       	pop	r2
    1d16:	1f 90       	pop	r1
    1d18:	0f 90       	pop	r0
    1d1a:	0c be       	out	0x3c, r0	; 60
    1d1c:	0f 90       	pop	r0
    1d1e:	0b be       	out	0x3b, r0	; 59
    1d20:	0f 90       	pop	r0
    1d22:	0f be       	out	0x3f, r0	; 63
    1d24:	0f 90       	pop	r0
    1d26:	08 95       	ret

00001d28 <__vector_21>:
	asm volatile ( "ret" );
    1d28:	9e df       	rcall	.-196    	; 0x1c66 <vPortYieldFromTick>
//	void SIG_OUTPUT_COMPARE1A( void )
	void TIMER0_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER0_COMPA_vect( void )
	{
		vPortYieldFromTick();
		asm volatile ( "reti" );
    1d2a:	18 95       	reti

00001d2c <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    1d2c:	cf 93       	push	r28
    1d2e:	df 93       	push	r29
    1d30:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
    1d32:	b5 d1       	rcall	.+874    	; 0x209e <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
    1d34:	20 91 df 02 	lds	r18, 0x02DF	; 0x8002df <xNextFreeByte>
    1d38:	30 91 e0 02 	lds	r19, 0x02E0	; 0x8002e0 <xNextFreeByte+0x1>
    1d3c:	c9 01       	movw	r24, r18
    1d3e:	8c 0f       	add	r24, r28
    1d40:	9d 1f       	adc	r25, r29
    1d42:	80 3a       	cpi	r24, 0xA0	; 160
    1d44:	4f e0       	ldi	r20, 0x0F	; 15
    1d46:	94 07       	cpc	r25, r20
    1d48:	58 f4       	brcc	.+22     	; 0x1d60 <pvPortMalloc+0x34>
    1d4a:	28 17       	cp	r18, r24
    1d4c:	39 07       	cpc	r19, r25
    1d4e:	58 f4       	brcc	.+22     	; 0x1d66 <pvPortMalloc+0x3a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
    1d50:	e9 01       	movw	r28, r18
    1d52:	cf 51       	subi	r28, 0x1F	; 31
    1d54:	dd 4f       	sbci	r29, 0xFD	; 253
			xNextFreeByte += xWantedSize;			
    1d56:	90 93 e0 02 	sts	0x02E0, r25	; 0x8002e0 <xNextFreeByte+0x1>
    1d5a:	80 93 df 02 	sts	0x02DF, r24	; 0x8002df <xNextFreeByte>
    1d5e:	05 c0       	rjmp	.+10     	; 0x1d6a <pvPortMalloc+0x3e>
static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL; 
    1d60:	c0 e0       	ldi	r28, 0x00	; 0
    1d62:	d0 e0       	ldi	r29, 0x00	; 0
    1d64:	02 c0       	rjmp	.+4      	; 0x1d6a <pvPortMalloc+0x3e>
    1d66:	c0 e0       	ldi	r28, 0x00	; 0
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
			xNextFreeByte += xWantedSize;			
		}	
	}
	xTaskResumeAll();
    1d68:	d0 e0       	ldi	r29, 0x00	; 0
    1d6a:	46 d2       	rcall	.+1164   	; 0x21f8 <xTaskResumeAll>
		}
	}
	#endif	

	return pvReturn;
}
    1d6c:	ce 01       	movw	r24, r28
    1d6e:	df 91       	pop	r29
    1d70:	cf 91       	pop	r28
    1d72:	08 95       	ret

00001d74 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    1d74:	08 95       	ret

00001d76 <prvIdleTask>:
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
		}
	}
    1d76:	80 91 ab 12 	lds	r24, 0x12AB	; 0x8012ab <pxReadyTasksLists>
    1d7a:	82 30       	cpi	r24, 0x02	; 2
    1d7c:	e0 f3       	brcs	.-8      	; 0x1d76 <prvIdleTask>
    1d7e:	13 df       	rcall	.-474    	; 0x1ba6 <vPortYield>
    1d80:	fa cf       	rjmp	.-12     	; 0x1d76 <prvIdleTask>

00001d82 <prvAllocateTCBAndStack>:
    1d82:	ef 92       	push	r14
    1d84:	ff 92       	push	r15
    1d86:	0f 93       	push	r16
    1d88:	1f 93       	push	r17
    1d8a:	cf 93       	push	r28
    1d8c:	df 93       	push	r29
    1d8e:	7c 01       	movw	r14, r24
    1d90:	eb 01       	movw	r28, r22
    1d92:	81 e2       	ldi	r24, 0x21	; 33
    1d94:	90 e0       	ldi	r25, 0x00	; 0
    1d96:	ca df       	rcall	.-108    	; 0x1d2c <pvPortMalloc>
    1d98:	8c 01       	movw	r16, r24
    1d9a:	89 2b       	or	r24, r25
    1d9c:	a9 f0       	breq	.+42     	; 0x1dc8 <prvAllocateTCBAndStack+0x46>
    1d9e:	20 97       	sbiw	r28, 0x00	; 0
    1da0:	19 f4       	brne	.+6      	; 0x1da8 <prvAllocateTCBAndStack+0x26>
    1da2:	c7 01       	movw	r24, r14
    1da4:	c3 df       	rcall	.-122    	; 0x1d2c <pvPortMalloc>
    1da6:	01 c0       	rjmp	.+2      	; 0x1daa <prvAllocateTCBAndStack+0x28>
    1da8:	ce 01       	movw	r24, r28
    1daa:	f8 01       	movw	r30, r16
    1dac:	90 8f       	std	Z+24, r25	; 0x18
    1dae:	87 8b       	std	Z+23, r24	; 0x17
    1db0:	00 97       	sbiw	r24, 0x00	; 0
    1db2:	29 f4       	brne	.+10     	; 0x1dbe <prvAllocateTCBAndStack+0x3c>
    1db4:	c8 01       	movw	r24, r16
    1db6:	de df       	rcall	.-68     	; 0x1d74 <vPortFree>
    1db8:	00 e0       	ldi	r16, 0x00	; 0
    1dba:	10 e0       	ldi	r17, 0x00	; 0
    1dbc:	05 c0       	rjmp	.+10     	; 0x1dc8 <prvAllocateTCBAndStack+0x46>
    1dbe:	a7 01       	movw	r20, r14
    1dc0:	65 ea       	ldi	r22, 0xA5	; 165
    1dc2:	70 e0       	ldi	r23, 0x00	; 0
    1dc4:	0e 94 db 18 	call	0x31b6	; 0x31b6 <memset>
    1dc8:	c8 01       	movw	r24, r16
    1dca:	df 91       	pop	r29
    1dcc:	cf 91       	pop	r28
    1dce:	1f 91       	pop	r17
    1dd0:	0f 91       	pop	r16
    1dd2:	ff 90       	pop	r15
    1dd4:	ef 90       	pop	r14
    1dd6:	08 95       	ret

00001dd8 <prvInitialiseTCBVariables>:
    1dd8:	1f 93       	push	r17
    1dda:	cf 93       	push	r28
    1ddc:	df 93       	push	r29
    1dde:	ec 01       	movw	r28, r24
    1de0:	14 2f       	mov	r17, r20
    1de2:	48 e0       	ldi	r20, 0x08	; 8
    1de4:	50 e0       	ldi	r21, 0x00	; 0
    1de6:	49 96       	adiw	r24, 0x19	; 25
    1de8:	0e 94 e2 18 	call	0x31c4	; 0x31c4 <strncpy>
    1dec:	18 a2       	std	Y+32, r1	; 0x20
    1dee:	11 11       	cpse	r17, r1
    1df0:	10 e0       	ldi	r17, 0x00	; 0
    1df2:	1e 8b       	std	Y+22, r17	; 0x16
    1df4:	ce 01       	movw	r24, r28
    1df6:	02 96       	adiw	r24, 0x02	; 2
    1df8:	a7 dd       	rcall	.-1202   	; 0x1948 <vListInitialiseItem>
    1dfa:	ce 01       	movw	r24, r28
    1dfc:	0c 96       	adiw	r24, 0x0c	; 12
    1dfe:	a4 dd       	rcall	.-1208   	; 0x1948 <vListInitialiseItem>
    1e00:	d9 87       	std	Y+9, r29	; 0x09
    1e02:	c8 87       	std	Y+8, r28	; 0x08
    1e04:	81 e0       	ldi	r24, 0x01	; 1
    1e06:	90 e0       	ldi	r25, 0x00	; 0
    1e08:	81 1b       	sub	r24, r17
    1e0a:	91 09       	sbc	r25, r1
    1e0c:	9d 87       	std	Y+13, r25	; 0x0d
    1e0e:	8c 87       	std	Y+12, r24	; 0x0c
    1e10:	db 8b       	std	Y+19, r29	; 0x13
    1e12:	ca 8b       	std	Y+18, r28	; 0x12
    1e14:	df 91       	pop	r29
    1e16:	cf 91       	pop	r28
    1e18:	1f 91       	pop	r17
    1e1a:	08 95       	ret

00001e1c <prvInitialiseTaskLists>:
    1e1c:	cf 93       	push	r28
    1e1e:	c0 e0       	ldi	r28, 0x00	; 0
    1e20:	0f c0       	rjmp	.+30     	; 0x1e40 <prvInitialiseTaskLists+0x24>
    1e22:	8c 2f       	mov	r24, r28
    1e24:	90 e0       	ldi	r25, 0x00	; 0
    1e26:	9c 01       	movw	r18, r24
    1e28:	22 0f       	add	r18, r18
    1e2a:	33 1f       	adc	r19, r19
    1e2c:	22 0f       	add	r18, r18
    1e2e:	33 1f       	adc	r19, r19
    1e30:	22 0f       	add	r18, r18
    1e32:	33 1f       	adc	r19, r19
    1e34:	82 0f       	add	r24, r18
    1e36:	93 1f       	adc	r25, r19
    1e38:	85 55       	subi	r24, 0x55	; 85
    1e3a:	9d 4e       	sbci	r25, 0xED	; 237
    1e3c:	77 dd       	rcall	.-1298   	; 0x192c <vListInitialise>
    1e3e:	cf 5f       	subi	r28, 0xFF	; 255
    1e40:	cc 23       	and	r28, r28
    1e42:	79 f3       	breq	.-34     	; 0x1e22 <prvInitialiseTaskLists+0x6>
    1e44:	82 ea       	ldi	r24, 0xA2	; 162
    1e46:	92 e1       	ldi	r25, 0x12	; 18
    1e48:	71 dd       	rcall	.-1310   	; 0x192c <vListInitialise>
    1e4a:	89 e9       	ldi	r24, 0x99	; 153
    1e4c:	92 e1       	ldi	r25, 0x12	; 18
    1e4e:	6e dd       	rcall	.-1316   	; 0x192c <vListInitialise>
    1e50:	8c e8       	ldi	r24, 0x8C	; 140
    1e52:	92 e1       	ldi	r25, 0x12	; 18
    1e54:	6b dd       	rcall	.-1322   	; 0x192c <vListInitialise>
    1e56:	82 ea       	ldi	r24, 0xA2	; 162
    1e58:	92 e1       	ldi	r25, 0x12	; 18
    1e5a:	90 93 98 12 	sts	0x1298, r25	; 0x801298 <pxDelayedTaskList+0x1>
    1e5e:	80 93 97 12 	sts	0x1297, r24	; 0x801297 <pxDelayedTaskList>
    1e62:	89 e9       	ldi	r24, 0x99	; 153
    1e64:	92 e1       	ldi	r25, 0x12	; 18
    1e66:	90 93 96 12 	sts	0x1296, r25	; 0x801296 <pxOverflowDelayedTaskList+0x1>
    1e6a:	80 93 95 12 	sts	0x1295, r24	; 0x801295 <pxOverflowDelayedTaskList>
    1e6e:	cf 91       	pop	r28
    1e70:	08 95       	ret

00001e72 <prvAddCurrentTaskToDelayedList>:
    1e72:	cf 93       	push	r28
    1e74:	df 93       	push	r29
    1e76:	ec 01       	movw	r28, r24
    1e78:	e0 91 b4 12 	lds	r30, 0x12B4	; 0x8012b4 <pxCurrentTCB>
    1e7c:	f0 91 b5 12 	lds	r31, 0x12B5	; 0x8012b5 <pxCurrentTCB+0x1>
    1e80:	93 83       	std	Z+3, r25	; 0x03
    1e82:	82 83       	std	Z+2, r24	; 0x02
    1e84:	80 91 89 12 	lds	r24, 0x1289	; 0x801289 <xTickCount>
    1e88:	90 91 8a 12 	lds	r25, 0x128A	; 0x80128a <xTickCount+0x1>
    1e8c:	c8 17       	cp	r28, r24
    1e8e:	d9 07       	cpc	r29, r25
    1e90:	60 f4       	brcc	.+24     	; 0x1eaa <prvAddCurrentTaskToDelayedList+0x38>
    1e92:	60 91 b4 12 	lds	r22, 0x12B4	; 0x8012b4 <pxCurrentTCB>
    1e96:	70 91 b5 12 	lds	r23, 0x12B5	; 0x8012b5 <pxCurrentTCB+0x1>
    1e9a:	80 91 95 12 	lds	r24, 0x1295	; 0x801295 <pxOverflowDelayedTaskList>
    1e9e:	90 91 96 12 	lds	r25, 0x1296	; 0x801296 <pxOverflowDelayedTaskList+0x1>
    1ea2:	6e 5f       	subi	r22, 0xFE	; 254
    1ea4:	7f 4f       	sbci	r23, 0xFF	; 255
    1ea6:	7b dd       	rcall	.-1290   	; 0x199e <vListInsert>
    1ea8:	16 c0       	rjmp	.+44     	; 0x1ed6 <prvAddCurrentTaskToDelayedList+0x64>
    1eaa:	60 91 b4 12 	lds	r22, 0x12B4	; 0x8012b4 <pxCurrentTCB>
    1eae:	70 91 b5 12 	lds	r23, 0x12B5	; 0x8012b5 <pxCurrentTCB+0x1>
    1eb2:	80 91 97 12 	lds	r24, 0x1297	; 0x801297 <pxDelayedTaskList>
    1eb6:	90 91 98 12 	lds	r25, 0x1298	; 0x801298 <pxDelayedTaskList+0x1>
    1eba:	6e 5f       	subi	r22, 0xFE	; 254
    1ebc:	7f 4f       	sbci	r23, 0xFF	; 255
    1ebe:	6f dd       	rcall	.-1314   	; 0x199e <vListInsert>
    1ec0:	80 91 0b 02 	lds	r24, 0x020B	; 0x80020b <xNextTaskUnblockTime>
    1ec4:	90 91 0c 02 	lds	r25, 0x020C	; 0x80020c <xNextTaskUnblockTime+0x1>
    1ec8:	c8 17       	cp	r28, r24
    1eca:	d9 07       	cpc	r29, r25
    1ecc:	20 f4       	brcc	.+8      	; 0x1ed6 <prvAddCurrentTaskToDelayedList+0x64>
    1ece:	d0 93 0c 02 	sts	0x020C, r29	; 0x80020c <xNextTaskUnblockTime+0x1>
    1ed2:	c0 93 0b 02 	sts	0x020B, r28	; 0x80020b <xNextTaskUnblockTime>
    1ed6:	df 91       	pop	r29
    1ed8:	cf 91       	pop	r28
    1eda:	08 95       	ret

00001edc <xTaskGenericCreate>:
    1edc:	2f 92       	push	r2
    1ede:	3f 92       	push	r3
    1ee0:	4f 92       	push	r4
    1ee2:	5f 92       	push	r5
    1ee4:	7f 92       	push	r7
    1ee6:	8f 92       	push	r8
    1ee8:	9f 92       	push	r9
    1eea:	af 92       	push	r10
    1eec:	bf 92       	push	r11
    1eee:	cf 92       	push	r12
    1ef0:	df 92       	push	r13
    1ef2:	ef 92       	push	r14
    1ef4:	ff 92       	push	r15
    1ef6:	0f 93       	push	r16
    1ef8:	1f 93       	push	r17
    1efa:	cf 93       	push	r28
    1efc:	df 93       	push	r29
    1efe:	00 d0       	rcall	.+0      	; 0x1f00 <xTaskGenericCreate+0x24>
    1f00:	1f 92       	push	r1
    1f02:	cd b7       	in	r28, 0x3d	; 61
    1f04:	de b7       	in	r29, 0x3e	; 62
    1f06:	9a 83       	std	Y+2, r25	; 0x02
    1f08:	89 83       	std	Y+1, r24	; 0x01
    1f0a:	4b 01       	movw	r8, r22
    1f0c:	5c 83       	std	Y+4, r21	; 0x04
    1f0e:	4b 83       	std	Y+3, r20	; 0x03
    1f10:	19 01       	movw	r2, r18
    1f12:	70 2e       	mov	r7, r16
    1f14:	b6 01       	movw	r22, r12
    1f16:	25 01       	movw	r4, r10
    1f18:	ca 01       	movw	r24, r20
    1f1a:	33 df       	rcall	.-410    	; 0x1d82 <prvAllocateTCBAndStack>
    1f1c:	5c 01       	movw	r10, r24
    1f1e:	00 97       	sbiw	r24, 0x00	; 0
    1f20:	09 f4       	brne	.+2      	; 0x1f24 <xTaskGenericCreate+0x48>
    1f22:	6c c0       	rjmp	.+216    	; 0x1ffc <xTaskGenericCreate+0x120>
    1f24:	fc 01       	movw	r30, r24
    1f26:	c7 88       	ldd	r12, Z+23	; 0x17
    1f28:	d0 8c       	ldd	r13, Z+24	; 0x18
    1f2a:	8b 81       	ldd	r24, Y+3	; 0x03
    1f2c:	9c 81       	ldd	r25, Y+4	; 0x04
    1f2e:	01 97       	sbiw	r24, 0x01	; 1
    1f30:	c8 0e       	add	r12, r24
    1f32:	d9 1e       	adc	r13, r25
    1f34:	0b 81       	ldd	r16, Y+3	; 0x03
    1f36:	1c 81       	ldd	r17, Y+4	; 0x04
    1f38:	92 01       	movw	r18, r4
    1f3a:	47 2d       	mov	r20, r7
    1f3c:	b4 01       	movw	r22, r8
    1f3e:	c5 01       	movw	r24, r10
    1f40:	4b df       	rcall	.-362    	; 0x1dd8 <prvInitialiseTCBVariables>
    1f42:	a1 01       	movw	r20, r2
    1f44:	69 81       	ldd	r22, Y+1	; 0x01
    1f46:	7a 81       	ldd	r23, Y+2	; 0x02
    1f48:	c6 01       	movw	r24, r12
    1f4a:	89 dd       	rcall	.-1262   	; 0x1a5e <pxPortInitialiseStack>
    1f4c:	f5 01       	movw	r30, r10
    1f4e:	91 83       	std	Z+1, r25	; 0x01
    1f50:	80 83       	st	Z, r24
    1f52:	e1 14       	cp	r14, r1
    1f54:	f1 04       	cpc	r15, r1
    1f56:	19 f0       	breq	.+6      	; 0x1f5e <xTaskGenericCreate+0x82>
    1f58:	f7 01       	movw	r30, r14
    1f5a:	b1 82       	std	Z+1, r11	; 0x01
    1f5c:	a0 82       	st	Z, r10
    1f5e:	0f b6       	in	r0, 0x3f	; 63
    1f60:	f8 94       	cli
    1f62:	0f 92       	push	r0
    1f64:	80 91 8b 12 	lds	r24, 0x128B	; 0x80128b <uxCurrentNumberOfTasks>
    1f68:	8f 5f       	subi	r24, 0xFF	; 255
    1f6a:	80 93 8b 12 	sts	0x128B, r24	; 0x80128b <uxCurrentNumberOfTasks>
    1f6e:	80 91 b4 12 	lds	r24, 0x12B4	; 0x8012b4 <pxCurrentTCB>
    1f72:	90 91 b5 12 	lds	r25, 0x12B5	; 0x8012b5 <pxCurrentTCB+0x1>
    1f76:	89 2b       	or	r24, r25
    1f78:	51 f4       	brne	.+20     	; 0x1f8e <xTaskGenericCreate+0xb2>
    1f7a:	b0 92 b5 12 	sts	0x12B5, r11	; 0x8012b5 <pxCurrentTCB+0x1>
    1f7e:	a0 92 b4 12 	sts	0x12B4, r10	; 0x8012b4 <pxCurrentTCB>
    1f82:	80 91 8b 12 	lds	r24, 0x128B	; 0x80128b <uxCurrentNumberOfTasks>
    1f86:	81 30       	cpi	r24, 0x01	; 1
    1f88:	89 f4       	brne	.+34     	; 0x1fac <xTaskGenericCreate+0xd0>
    1f8a:	48 df       	rcall	.-368    	; 0x1e1c <prvInitialiseTaskLists>
    1f8c:	0f c0       	rjmp	.+30     	; 0x1fac <xTaskGenericCreate+0xd0>
    1f8e:	80 91 86 12 	lds	r24, 0x1286	; 0x801286 <xSchedulerRunning>
    1f92:	81 11       	cpse	r24, r1
    1f94:	0b c0       	rjmp	.+22     	; 0x1fac <xTaskGenericCreate+0xd0>
    1f96:	e0 91 b4 12 	lds	r30, 0x12B4	; 0x8012b4 <pxCurrentTCB>
    1f9a:	f0 91 b5 12 	lds	r31, 0x12B5	; 0x8012b5 <pxCurrentTCB+0x1>
    1f9e:	86 89       	ldd	r24, Z+22	; 0x16
    1fa0:	78 16       	cp	r7, r24
    1fa2:	20 f0       	brcs	.+8      	; 0x1fac <xTaskGenericCreate+0xd0>
    1fa4:	b0 92 b5 12 	sts	0x12B5, r11	; 0x8012b5 <pxCurrentTCB+0x1>
    1fa8:	a0 92 b4 12 	sts	0x12B4, r10	; 0x8012b4 <pxCurrentTCB>
    1fac:	f5 01       	movw	r30, r10
    1fae:	86 89       	ldd	r24, Z+22	; 0x16
    1fb0:	90 91 88 12 	lds	r25, 0x1288	; 0x801288 <uxTopUsedPriority>
    1fb4:	98 17       	cp	r25, r24
    1fb6:	10 f4       	brcc	.+4      	; 0x1fbc <xTaskGenericCreate+0xe0>
    1fb8:	80 93 88 12 	sts	0x1288, r24	; 0x801288 <uxTopUsedPriority>
    1fbc:	90 91 81 12 	lds	r25, 0x1281	; 0x801281 <uxTCBNumber>
    1fc0:	9f 5f       	subi	r25, 0xFF	; 255
    1fc2:	90 93 81 12 	sts	0x1281, r25	; 0x801281 <uxTCBNumber>
    1fc6:	90 91 87 12 	lds	r25, 0x1287	; 0x801287 <uxTopReadyPriority>
    1fca:	98 17       	cp	r25, r24
    1fcc:	10 f4       	brcc	.+4      	; 0x1fd2 <xTaskGenericCreate+0xf6>
    1fce:	80 93 87 12 	sts	0x1287, r24	; 0x801287 <uxTopReadyPriority>
    1fd2:	90 e0       	ldi	r25, 0x00	; 0
    1fd4:	b5 01       	movw	r22, r10
    1fd6:	6e 5f       	subi	r22, 0xFE	; 254
    1fd8:	7f 4f       	sbci	r23, 0xFF	; 255
    1fda:	9c 01       	movw	r18, r24
    1fdc:	22 0f       	add	r18, r18
    1fde:	33 1f       	adc	r19, r19
    1fe0:	22 0f       	add	r18, r18
    1fe2:	33 1f       	adc	r19, r19
    1fe4:	22 0f       	add	r18, r18
    1fe6:	33 1f       	adc	r19, r19
    1fe8:	82 0f       	add	r24, r18
    1fea:	93 1f       	adc	r25, r19
    1fec:	85 55       	subi	r24, 0x55	; 85
    1fee:	9d 4e       	sbci	r25, 0xED	; 237
    1ff0:	af dc       	rcall	.-1698   	; 0x1950 <vListInsertEnd>
    1ff2:	0f 90       	pop	r0
    1ff4:	0f be       	out	0x3f, r0	; 63
    1ff6:	f1 e0       	ldi	r31, 0x01	; 1
    1ff8:	f9 83       	std	Y+1, r31	; 0x01
    1ffa:	02 c0       	rjmp	.+4      	; 0x2000 <xTaskGenericCreate+0x124>
    1ffc:	8f ef       	ldi	r24, 0xFF	; 255
    1ffe:	89 83       	std	Y+1, r24	; 0x01
    2000:	e9 81       	ldd	r30, Y+1	; 0x01
    2002:	e1 30       	cpi	r30, 0x01	; 1
    2004:	61 f4       	brne	.+24     	; 0x201e <xTaskGenericCreate+0x142>
    2006:	80 91 86 12 	lds	r24, 0x1286	; 0x801286 <xSchedulerRunning>
    200a:	88 23       	and	r24, r24
    200c:	41 f0       	breq	.+16     	; 0x201e <xTaskGenericCreate+0x142>
    200e:	e0 91 b4 12 	lds	r30, 0x12B4	; 0x8012b4 <pxCurrentTCB>
    2012:	f0 91 b5 12 	lds	r31, 0x12B5	; 0x8012b5 <pxCurrentTCB+0x1>
    2016:	86 89       	ldd	r24, Z+22	; 0x16
    2018:	87 15       	cp	r24, r7
    201a:	08 f4       	brcc	.+2      	; 0x201e <xTaskGenericCreate+0x142>
    201c:	c4 dd       	rcall	.-1144   	; 0x1ba6 <vPortYield>
    201e:	89 81       	ldd	r24, Y+1	; 0x01
    2020:	0f 90       	pop	r0
    2022:	0f 90       	pop	r0
    2024:	0f 90       	pop	r0
    2026:	0f 90       	pop	r0
    2028:	df 91       	pop	r29
    202a:	cf 91       	pop	r28
    202c:	1f 91       	pop	r17
    202e:	0f 91       	pop	r16
    2030:	ff 90       	pop	r15
    2032:	ef 90       	pop	r14
    2034:	df 90       	pop	r13
    2036:	cf 90       	pop	r12
    2038:	bf 90       	pop	r11
    203a:	af 90       	pop	r10
    203c:	9f 90       	pop	r9
    203e:	8f 90       	pop	r8
    2040:	7f 90       	pop	r7
    2042:	5f 90       	pop	r5
    2044:	4f 90       	pop	r4
    2046:	3f 90       	pop	r3
    2048:	2f 90       	pop	r2
    204a:	08 95       	ret

0000204c <vTaskStartScheduler>:
    204c:	af 92       	push	r10
    204e:	bf 92       	push	r11
    2050:	cf 92       	push	r12
    2052:	df 92       	push	r13
    2054:	ef 92       	push	r14
    2056:	ff 92       	push	r15
    2058:	0f 93       	push	r16
    205a:	a1 2c       	mov	r10, r1
    205c:	b1 2c       	mov	r11, r1
    205e:	c1 2c       	mov	r12, r1
    2060:	d1 2c       	mov	r13, r1
    2062:	e1 2c       	mov	r14, r1
    2064:	f1 2c       	mov	r15, r1
    2066:	00 e0       	ldi	r16, 0x00	; 0
    2068:	20 e0       	ldi	r18, 0x00	; 0
    206a:	30 e0       	ldi	r19, 0x00	; 0
    206c:	45 e5       	ldi	r20, 0x55	; 85
    206e:	50 e0       	ldi	r21, 0x00	; 0
    2070:	66 eb       	ldi	r22, 0xB6	; 182
    2072:	72 e0       	ldi	r23, 0x02	; 2
    2074:	8b eb       	ldi	r24, 0xBB	; 187
    2076:	9e e0       	ldi	r25, 0x0E	; 14
    2078:	31 df       	rcall	.-414    	; 0x1edc <xTaskGenericCreate>
    207a:	81 30       	cpi	r24, 0x01	; 1
    207c:	41 f4       	brne	.+16     	; 0x208e <vTaskStartScheduler+0x42>
    207e:	f8 94       	cli
    2080:	80 93 86 12 	sts	0x1286, r24	; 0x801286 <xSchedulerRunning>
    2084:	10 92 8a 12 	sts	0x128A, r1	; 0x80128a <xTickCount+0x1>
    2088:	10 92 89 12 	sts	0x1289, r1	; 0x801289 <xTickCount>
    208c:	5a dd       	rcall	.-1356   	; 0x1b42 <xPortStartScheduler>
    208e:	0f 91       	pop	r16
    2090:	ff 90       	pop	r15
    2092:	ef 90       	pop	r14
    2094:	df 90       	pop	r13
    2096:	cf 90       	pop	r12
    2098:	bf 90       	pop	r11
    209a:	af 90       	pop	r10
    209c:	08 95       	ret

0000209e <vTaskSuspendAll>:
    209e:	80 91 85 12 	lds	r24, 0x1285	; 0x801285 <uxSchedulerSuspended>
    20a2:	8f 5f       	subi	r24, 0xFF	; 255
    20a4:	80 93 85 12 	sts	0x1285, r24	; 0x801285 <uxSchedulerSuspended>
    20a8:	08 95       	ret

000020aa <vTaskIncrementTick>:
    20aa:	0f 93       	push	r16
    20ac:	1f 93       	push	r17
    20ae:	cf 93       	push	r28
    20b0:	df 93       	push	r29
    20b2:	80 91 85 12 	lds	r24, 0x1285	; 0x801285 <uxSchedulerSuspended>
    20b6:	81 11       	cpse	r24, r1
    20b8:	95 c0       	rjmp	.+298    	; 0x21e4 <vTaskIncrementTick+0x13a>
    20ba:	80 91 89 12 	lds	r24, 0x1289	; 0x801289 <xTickCount>
    20be:	90 91 8a 12 	lds	r25, 0x128A	; 0x80128a <xTickCount+0x1>
    20c2:	01 96       	adiw	r24, 0x01	; 1
    20c4:	90 93 8a 12 	sts	0x128A, r25	; 0x80128a <xTickCount+0x1>
    20c8:	80 93 89 12 	sts	0x1289, r24	; 0x801289 <xTickCount>
    20cc:	80 91 89 12 	lds	r24, 0x1289	; 0x801289 <xTickCount>
    20d0:	90 91 8a 12 	lds	r25, 0x128A	; 0x80128a <xTickCount+0x1>
    20d4:	89 2b       	or	r24, r25
    20d6:	99 f5       	brne	.+102    	; 0x213e <vTaskIncrementTick+0x94>
    20d8:	80 91 97 12 	lds	r24, 0x1297	; 0x801297 <pxDelayedTaskList>
    20dc:	90 91 98 12 	lds	r25, 0x1298	; 0x801298 <pxDelayedTaskList+0x1>
    20e0:	20 91 95 12 	lds	r18, 0x1295	; 0x801295 <pxOverflowDelayedTaskList>
    20e4:	30 91 96 12 	lds	r19, 0x1296	; 0x801296 <pxOverflowDelayedTaskList+0x1>
    20e8:	30 93 98 12 	sts	0x1298, r19	; 0x801298 <pxDelayedTaskList+0x1>
    20ec:	20 93 97 12 	sts	0x1297, r18	; 0x801297 <pxDelayedTaskList>
    20f0:	90 93 96 12 	sts	0x1296, r25	; 0x801296 <pxOverflowDelayedTaskList+0x1>
    20f4:	80 93 95 12 	sts	0x1295, r24	; 0x801295 <pxOverflowDelayedTaskList>
    20f8:	80 91 82 12 	lds	r24, 0x1282	; 0x801282 <xNumOfOverflows>
    20fc:	8f 5f       	subi	r24, 0xFF	; 255
    20fe:	80 93 82 12 	sts	0x1282, r24	; 0x801282 <xNumOfOverflows>
    2102:	e0 91 97 12 	lds	r30, 0x1297	; 0x801297 <pxDelayedTaskList>
    2106:	f0 91 98 12 	lds	r31, 0x1298	; 0x801298 <pxDelayedTaskList+0x1>
    210a:	80 81       	ld	r24, Z
    210c:	81 11       	cpse	r24, r1
    210e:	07 c0       	rjmp	.+14     	; 0x211e <vTaskIncrementTick+0x74>
    2110:	8f ef       	ldi	r24, 0xFF	; 255
    2112:	9f ef       	ldi	r25, 0xFF	; 255
    2114:	90 93 0c 02 	sts	0x020C, r25	; 0x80020c <xNextTaskUnblockTime+0x1>
    2118:	80 93 0b 02 	sts	0x020B, r24	; 0x80020b <xNextTaskUnblockTime>
    211c:	10 c0       	rjmp	.+32     	; 0x213e <vTaskIncrementTick+0x94>
    211e:	e0 91 97 12 	lds	r30, 0x1297	; 0x801297 <pxDelayedTaskList>
    2122:	f0 91 98 12 	lds	r31, 0x1298	; 0x801298 <pxDelayedTaskList+0x1>
    2126:	05 80       	ldd	r0, Z+5	; 0x05
    2128:	f6 81       	ldd	r31, Z+6	; 0x06
    212a:	e0 2d       	mov	r30, r0
    212c:	06 80       	ldd	r0, Z+6	; 0x06
    212e:	f7 81       	ldd	r31, Z+7	; 0x07
    2130:	e0 2d       	mov	r30, r0
    2132:	82 81       	ldd	r24, Z+2	; 0x02
    2134:	93 81       	ldd	r25, Z+3	; 0x03
    2136:	90 93 0c 02 	sts	0x020C, r25	; 0x80020c <xNextTaskUnblockTime+0x1>
    213a:	80 93 0b 02 	sts	0x020B, r24	; 0x80020b <xNextTaskUnblockTime>
    213e:	20 91 89 12 	lds	r18, 0x1289	; 0x801289 <xTickCount>
    2142:	30 91 8a 12 	lds	r19, 0x128A	; 0x80128a <xTickCount+0x1>
    2146:	80 91 0b 02 	lds	r24, 0x020B	; 0x80020b <xNextTaskUnblockTime>
    214a:	90 91 0c 02 	lds	r25, 0x020C	; 0x80020c <xNextTaskUnblockTime+0x1>
    214e:	28 17       	cp	r18, r24
    2150:	39 07       	cpc	r19, r25
    2152:	08 f4       	brcc	.+2      	; 0x2156 <vTaskIncrementTick+0xac>
    2154:	4c c0       	rjmp	.+152    	; 0x21ee <vTaskIncrementTick+0x144>
    2156:	e0 91 97 12 	lds	r30, 0x1297	; 0x801297 <pxDelayedTaskList>
    215a:	f0 91 98 12 	lds	r31, 0x1298	; 0x801298 <pxDelayedTaskList+0x1>
    215e:	80 81       	ld	r24, Z
    2160:	81 11       	cpse	r24, r1
    2162:	07 c0       	rjmp	.+14     	; 0x2172 <vTaskIncrementTick+0xc8>
    2164:	8f ef       	ldi	r24, 0xFF	; 255
    2166:	9f ef       	ldi	r25, 0xFF	; 255
    2168:	90 93 0c 02 	sts	0x020C, r25	; 0x80020c <xNextTaskUnblockTime+0x1>
    216c:	80 93 0b 02 	sts	0x020B, r24	; 0x80020b <xNextTaskUnblockTime>
    2170:	3e c0       	rjmp	.+124    	; 0x21ee <vTaskIncrementTick+0x144>
    2172:	e0 91 97 12 	lds	r30, 0x1297	; 0x801297 <pxDelayedTaskList>
    2176:	f0 91 98 12 	lds	r31, 0x1298	; 0x801298 <pxDelayedTaskList+0x1>
    217a:	05 80       	ldd	r0, Z+5	; 0x05
    217c:	f6 81       	ldd	r31, Z+6	; 0x06
    217e:	e0 2d       	mov	r30, r0
    2180:	c6 81       	ldd	r28, Z+6	; 0x06
    2182:	d7 81       	ldd	r29, Z+7	; 0x07
    2184:	8a 81       	ldd	r24, Y+2	; 0x02
    2186:	9b 81       	ldd	r25, Y+3	; 0x03
    2188:	20 91 89 12 	lds	r18, 0x1289	; 0x801289 <xTickCount>
    218c:	30 91 8a 12 	lds	r19, 0x128A	; 0x80128a <xTickCount+0x1>
    2190:	28 17       	cp	r18, r24
    2192:	39 07       	cpc	r19, r25
    2194:	28 f4       	brcc	.+10     	; 0x21a0 <vTaskIncrementTick+0xf6>
    2196:	90 93 0c 02 	sts	0x020C, r25	; 0x80020c <xNextTaskUnblockTime+0x1>
    219a:	80 93 0b 02 	sts	0x020B, r24	; 0x80020b <xNextTaskUnblockTime>
    219e:	27 c0       	rjmp	.+78     	; 0x21ee <vTaskIncrementTick+0x144>
    21a0:	8e 01       	movw	r16, r28
    21a2:	0e 5f       	subi	r16, 0xFE	; 254
    21a4:	1f 4f       	sbci	r17, 0xFF	; 255
    21a6:	c8 01       	movw	r24, r16
    21a8:	2b dc       	rcall	.-1962   	; 0x1a00 <vListRemove>
    21aa:	8c 89       	ldd	r24, Y+20	; 0x14
    21ac:	9d 89       	ldd	r25, Y+21	; 0x15
    21ae:	89 2b       	or	r24, r25
    21b0:	19 f0       	breq	.+6      	; 0x21b8 <vTaskIncrementTick+0x10e>
    21b2:	ce 01       	movw	r24, r28
    21b4:	0c 96       	adiw	r24, 0x0c	; 12
    21b6:	24 dc       	rcall	.-1976   	; 0x1a00 <vListRemove>
    21b8:	8e 89       	ldd	r24, Y+22	; 0x16
    21ba:	90 91 87 12 	lds	r25, 0x1287	; 0x801287 <uxTopReadyPriority>
    21be:	98 17       	cp	r25, r24
    21c0:	10 f4       	brcc	.+4      	; 0x21c6 <vTaskIncrementTick+0x11c>
    21c2:	80 93 87 12 	sts	0x1287, r24	; 0x801287 <uxTopReadyPriority>
    21c6:	90 e0       	ldi	r25, 0x00	; 0
    21c8:	9c 01       	movw	r18, r24
    21ca:	22 0f       	add	r18, r18
    21cc:	33 1f       	adc	r19, r19
    21ce:	22 0f       	add	r18, r18
    21d0:	33 1f       	adc	r19, r19
    21d2:	22 0f       	add	r18, r18
    21d4:	33 1f       	adc	r19, r19
    21d6:	82 0f       	add	r24, r18
    21d8:	93 1f       	adc	r25, r19
    21da:	b8 01       	movw	r22, r16
    21dc:	85 55       	subi	r24, 0x55	; 85
    21de:	9d 4e       	sbci	r25, 0xED	; 237
    21e0:	b7 db       	rcall	.-2194   	; 0x1950 <vListInsertEnd>
    21e2:	b9 cf       	rjmp	.-142    	; 0x2156 <vTaskIncrementTick+0xac>
    21e4:	80 91 84 12 	lds	r24, 0x1284	; 0x801284 <uxMissedTicks>
    21e8:	8f 5f       	subi	r24, 0xFF	; 255
    21ea:	80 93 84 12 	sts	0x1284, r24	; 0x801284 <uxMissedTicks>
    21ee:	df 91       	pop	r29
    21f0:	cf 91       	pop	r28
    21f2:	1f 91       	pop	r17
    21f4:	0f 91       	pop	r16
    21f6:	08 95       	ret

000021f8 <xTaskResumeAll>:
    21f8:	ff 92       	push	r15
    21fa:	0f 93       	push	r16
    21fc:	1f 93       	push	r17
    21fe:	cf 93       	push	r28
    2200:	df 93       	push	r29
    2202:	0f b6       	in	r0, 0x3f	; 63
    2204:	f8 94       	cli
    2206:	0f 92       	push	r0
    2208:	80 91 85 12 	lds	r24, 0x1285	; 0x801285 <uxSchedulerSuspended>
    220c:	81 50       	subi	r24, 0x01	; 1
    220e:	80 93 85 12 	sts	0x1285, r24	; 0x801285 <uxSchedulerSuspended>
    2212:	80 91 85 12 	lds	r24, 0x1285	; 0x801285 <uxSchedulerSuspended>
    2216:	81 11       	cpse	r24, r1
    2218:	55 c0       	rjmp	.+170    	; 0x22c4 <__stack+0xc5>
    221a:	80 91 8b 12 	lds	r24, 0x128B	; 0x80128b <uxCurrentNumberOfTasks>
    221e:	81 11       	cpse	r24, r1
    2220:	2f c0       	rjmp	.+94     	; 0x2280 <__stack+0x81>
    2222:	53 c0       	rjmp	.+166    	; 0x22ca <__stack+0xcb>
    2224:	e0 91 91 12 	lds	r30, 0x1291	; 0x801291 <xPendingReadyList+0x5>
    2228:	f0 91 92 12 	lds	r31, 0x1292	; 0x801292 <xPendingReadyList+0x6>
    222c:	c6 81       	ldd	r28, Z+6	; 0x06
    222e:	d7 81       	ldd	r29, Z+7	; 0x07
    2230:	ce 01       	movw	r24, r28
    2232:	0c 96       	adiw	r24, 0x0c	; 12
    2234:	e5 db       	rcall	.-2102   	; 0x1a00 <vListRemove>
    2236:	8e 01       	movw	r16, r28
    2238:	0e 5f       	subi	r16, 0xFE	; 254
    223a:	1f 4f       	sbci	r17, 0xFF	; 255
    223c:	c8 01       	movw	r24, r16
    223e:	e0 db       	rcall	.-2112   	; 0x1a00 <vListRemove>
    2240:	8e 89       	ldd	r24, Y+22	; 0x16
    2242:	90 91 87 12 	lds	r25, 0x1287	; 0x801287 <uxTopReadyPriority>
    2246:	98 17       	cp	r25, r24
    2248:	10 f4       	brcc	.+4      	; 0x224e <__stack+0x4f>
    224a:	80 93 87 12 	sts	0x1287, r24	; 0x801287 <uxTopReadyPriority>
    224e:	90 e0       	ldi	r25, 0x00	; 0
    2250:	9c 01       	movw	r18, r24
    2252:	22 0f       	add	r18, r18
    2254:	33 1f       	adc	r19, r19
    2256:	22 0f       	add	r18, r18
    2258:	33 1f       	adc	r19, r19
    225a:	22 0f       	add	r18, r18
    225c:	33 1f       	adc	r19, r19
    225e:	82 0f       	add	r24, r18
    2260:	93 1f       	adc	r25, r19
    2262:	b8 01       	movw	r22, r16
    2264:	85 55       	subi	r24, 0x55	; 85
    2266:	9d 4e       	sbci	r25, 0xED	; 237
    2268:	73 db       	rcall	.-2330   	; 0x1950 <vListInsertEnd>
    226a:	9e 89       	ldd	r25, Y+22	; 0x16
    226c:	e0 91 b4 12 	lds	r30, 0x12B4	; 0x8012b4 <pxCurrentTCB>
    2270:	f0 91 b5 12 	lds	r31, 0x12B5	; 0x8012b5 <pxCurrentTCB+0x1>
    2274:	86 89       	ldd	r24, Z+22	; 0x16
    2276:	98 17       	cp	r25, r24
    2278:	20 f0       	brcs	.+8      	; 0x2282 <__stack+0x83>
    227a:	ff 24       	eor	r15, r15
    227c:	f3 94       	inc	r15
    227e:	01 c0       	rjmp	.+2      	; 0x2282 <__stack+0x83>
    2280:	f1 2c       	mov	r15, r1
    2282:	80 91 8c 12 	lds	r24, 0x128C	; 0x80128c <xPendingReadyList>
    2286:	81 11       	cpse	r24, r1
    2288:	cd cf       	rjmp	.-102    	; 0x2224 <__stack+0x25>
    228a:	80 91 84 12 	lds	r24, 0x1284	; 0x801284 <uxMissedTicks>
    228e:	81 11       	cpse	r24, r1
    2290:	07 c0       	rjmp	.+14     	; 0x22a0 <__stack+0xa1>
    2292:	0c c0       	rjmp	.+24     	; 0x22ac <__stack+0xad>
    2294:	0a df       	rcall	.-492    	; 0x20aa <vTaskIncrementTick>
    2296:	80 91 84 12 	lds	r24, 0x1284	; 0x801284 <uxMissedTicks>
    229a:	81 50       	subi	r24, 0x01	; 1
    229c:	80 93 84 12 	sts	0x1284, r24	; 0x801284 <uxMissedTicks>
    22a0:	80 91 84 12 	lds	r24, 0x1284	; 0x801284 <uxMissedTicks>
    22a4:	81 11       	cpse	r24, r1
    22a6:	f6 cf       	rjmp	.-20     	; 0x2294 <__stack+0x95>
    22a8:	ff 24       	eor	r15, r15
    22aa:	f3 94       	inc	r15
    22ac:	81 e0       	ldi	r24, 0x01	; 1
    22ae:	f8 16       	cp	r15, r24
    22b0:	21 f0       	breq	.+8      	; 0x22ba <__stack+0xbb>
    22b2:	80 91 83 12 	lds	r24, 0x1283	; 0x801283 <xMissedYield>
    22b6:	81 30       	cpi	r24, 0x01	; 1
    22b8:	39 f4       	brne	.+14     	; 0x22c8 <__stack+0xc9>
    22ba:	10 92 83 12 	sts	0x1283, r1	; 0x801283 <xMissedYield>
    22be:	73 dc       	rcall	.-1818   	; 0x1ba6 <vPortYield>
    22c0:	81 e0       	ldi	r24, 0x01	; 1
    22c2:	03 c0       	rjmp	.+6      	; 0x22ca <__stack+0xcb>
    22c4:	80 e0       	ldi	r24, 0x00	; 0
    22c6:	01 c0       	rjmp	.+2      	; 0x22ca <__stack+0xcb>
    22c8:	80 e0       	ldi	r24, 0x00	; 0
    22ca:	0f 90       	pop	r0
    22cc:	0f be       	out	0x3f, r0	; 63
    22ce:	df 91       	pop	r29
    22d0:	cf 91       	pop	r28
    22d2:	1f 91       	pop	r17
    22d4:	0f 91       	pop	r16
    22d6:	ff 90       	pop	r15
    22d8:	08 95       	ret

000022da <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    22da:	cf 93       	push	r28
    22dc:	df 93       	push	r29
    22de:	ec 01       	movw	r28, r24
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    22e0:	89 2b       	or	r24, r25
    22e2:	89 f0       	breq	.+34     	; 0x2306 <vTaskDelay+0x2c>
		{
			vTaskSuspendAll();
    22e4:	dc de       	rcall	.-584    	; 0x209e <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    22e6:	80 91 89 12 	lds	r24, 0x1289	; 0x801289 <xTickCount>
    22ea:	90 91 8a 12 	lds	r25, 0x128A	; 0x80128a <xTickCount+0x1>
    22ee:	c8 0f       	add	r28, r24
    22f0:	d9 1f       	adc	r29, r25

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    22f2:	80 91 b4 12 	lds	r24, 0x12B4	; 0x8012b4 <pxCurrentTCB>
    22f6:	90 91 b5 12 	lds	r25, 0x12B5	; 0x8012b5 <pxCurrentTCB+0x1>
    22fa:	02 96       	adiw	r24, 0x02	; 2
    22fc:	81 db       	rcall	.-2302   	; 0x1a00 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    22fe:	ce 01       	movw	r24, r28
    2300:	b8 dd       	rcall	.-1168   	; 0x1e72 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    2302:	7a df       	rcall	.-268    	; 0x21f8 <xTaskResumeAll>
    2304:	01 c0       	rjmp	.+2      	; 0x2308 <vTaskDelay+0x2e>
#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    2306:	80 e0       	ldi	r24, 0x00	; 0
			xAlreadyYielded = xTaskResumeAll();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    2308:	81 11       	cpse	r24, r1
    230a:	01 c0       	rjmp	.+2      	; 0x230e <vTaskDelay+0x34>
		{
			portYIELD_WITHIN_API();
    230c:	4c dc       	rcall	.-1896   	; 0x1ba6 <vPortYield>
    230e:	df 91       	pop	r29
		}
	}
    2310:	cf 91       	pop	r28
    2312:	08 95       	ret

00002314 <vTaskSwitchContext>:
    2314:	80 91 85 12 	lds	r24, 0x1285	; 0x801285 <uxSchedulerSuspended>
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    2318:	88 23       	and	r24, r24
    231a:	49 f0       	breq	.+18     	; 0x232e <vTaskSwitchContext+0x1a>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    231c:	81 e0       	ldi	r24, 0x01	; 1
    231e:	80 93 83 12 	sts	0x1283, r24	; 0x801283 <xMissedYield>
    2322:	08 95       	ret
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    2324:	80 91 87 12 	lds	r24, 0x1287	; 0x801287 <uxTopReadyPriority>
    2328:	81 50       	subi	r24, 0x01	; 1
    232a:	80 93 87 12 	sts	0x1287, r24	; 0x801287 <uxTopReadyPriority>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    232e:	80 91 87 12 	lds	r24, 0x1287	; 0x801287 <uxTopReadyPriority>
    2332:	90 e0       	ldi	r25, 0x00	; 0
    2334:	fc 01       	movw	r30, r24
    2336:	ee 0f       	add	r30, r30
    2338:	ff 1f       	adc	r31, r31
    233a:	ee 0f       	add	r30, r30
    233c:	ff 1f       	adc	r31, r31
    233e:	ee 0f       	add	r30, r30
    2340:	ff 1f       	adc	r31, r31
    2342:	8e 0f       	add	r24, r30
    2344:	9f 1f       	adc	r25, r31
    2346:	fc 01       	movw	r30, r24
    2348:	e5 55       	subi	r30, 0x55	; 85
    234a:	fd 4e       	sbci	r31, 0xED	; 237
    234c:	80 81       	ld	r24, Z
    234e:	88 23       	and	r24, r24
    2350:	49 f3       	breq	.-46     	; 0x2324 <vTaskSwitchContext+0x10>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    2352:	80 91 87 12 	lds	r24, 0x1287	; 0x801287 <uxTopReadyPriority>
    2356:	90 e0       	ldi	r25, 0x00	; 0
    2358:	9c 01       	movw	r18, r24
    235a:	22 0f       	add	r18, r18
    235c:	33 1f       	adc	r19, r19
    235e:	22 0f       	add	r18, r18
    2360:	33 1f       	adc	r19, r19
    2362:	22 0f       	add	r18, r18
    2364:	33 1f       	adc	r19, r19
    2366:	28 0f       	add	r18, r24
    2368:	39 1f       	adc	r19, r25
    236a:	d9 01       	movw	r26, r18
    236c:	a5 55       	subi	r26, 0x55	; 85
    236e:	bd 4e       	sbci	r27, 0xED	; 237
    2370:	11 96       	adiw	r26, 0x01	; 1
    2372:	ed 91       	ld	r30, X+
    2374:	fc 91       	ld	r31, X
    2376:	12 97       	sbiw	r26, 0x02	; 2
    2378:	02 80       	ldd	r0, Z+2	; 0x02
    237a:	f3 81       	ldd	r31, Z+3	; 0x03
    237c:	e0 2d       	mov	r30, r0
    237e:	12 96       	adiw	r26, 0x02	; 2
    2380:	fc 93       	st	X, r31
    2382:	ee 93       	st	-X, r30
    2384:	11 97       	sbiw	r26, 0x01	; 1
    2386:	22 55       	subi	r18, 0x52	; 82
    2388:	3d 4e       	sbci	r19, 0xED	; 237
    238a:	e2 17       	cp	r30, r18
    238c:	f3 07       	cpc	r31, r19
    238e:	29 f4       	brne	.+10     	; 0x239a <vTaskSwitchContext+0x86>
    2390:	22 81       	ldd	r18, Z+2	; 0x02
    2392:	33 81       	ldd	r19, Z+3	; 0x03
    2394:	fd 01       	movw	r30, r26
    2396:	32 83       	std	Z+2, r19	; 0x02
    2398:	21 83       	std	Z+1, r18	; 0x01
    239a:	fc 01       	movw	r30, r24
    239c:	ee 0f       	add	r30, r30
    239e:	ff 1f       	adc	r31, r31
    23a0:	ee 0f       	add	r30, r30
    23a2:	ff 1f       	adc	r31, r31
    23a4:	ee 0f       	add	r30, r30
    23a6:	ff 1f       	adc	r31, r31
    23a8:	8e 0f       	add	r24, r30
    23aa:	9f 1f       	adc	r25, r31
    23ac:	fc 01       	movw	r30, r24
    23ae:	e5 55       	subi	r30, 0x55	; 85
    23b0:	fd 4e       	sbci	r31, 0xED	; 237
    23b2:	01 80       	ldd	r0, Z+1	; 0x01
    23b4:	f2 81       	ldd	r31, Z+2	; 0x02
    23b6:	e0 2d       	mov	r30, r0
    23b8:	86 81       	ldd	r24, Z+6	; 0x06
    23ba:	97 81       	ldd	r25, Z+7	; 0x07
    23bc:	90 93 b5 12 	sts	0x12B5, r25	; 0x8012b5 <pxCurrentTCB+0x1>
    23c0:	80 93 b4 12 	sts	0x12B4, r24	; 0x8012b4 <pxCurrentTCB>
    23c4:	08 95       	ret

000023c6 <_Z12WriteCommandj>:
}

void DisplayOff()
{
	// Send command DisplayOff which is 0x28 in HEX.
	WriteCommand(0x28);
    23c6:	2b b1       	in	r18, 0x0b	; 11
    23c8:	2f 77       	andi	r18, 0x7F	; 127
    23ca:	2b b9       	out	0x0b, r18	; 11
    23cc:	24 b3       	in	r18, 0x14	; 20
    23ce:	2d 7f       	andi	r18, 0xFD	; 253
    23d0:	24 bb       	out	0x14, r18	; 20
    23d2:	00 00       	nop
    23d4:	92 b9       	out	0x02, r25	; 2
    23d6:	88 b9       	out	0x08, r24	; 8
    23d8:	84 b3       	in	r24, 0x14	; 20
    23da:	8b 7f       	andi	r24, 0xFB	; 251
    23dc:	84 bb       	out	0x14, r24	; 20
    23de:	00 00       	nop
    23e0:	84 b3       	in	r24, 0x14	; 20
    23e2:	84 60       	ori	r24, 0x04	; 4
    23e4:	84 bb       	out	0x14, r24	; 20
    23e6:	00 00       	nop
    23e8:	84 b3       	in	r24, 0x14	; 20
    23ea:	82 60       	ori	r24, 0x02	; 2
    23ec:	84 bb       	out	0x14, r24	; 20
    23ee:	08 95       	ret

000023f0 <_Z9WriteDataj>:
    23f0:	2b b1       	in	r18, 0x0b	; 11
    23f2:	20 68       	ori	r18, 0x80	; 128
    23f4:	2b b9       	out	0x0b, r18	; 11
    23f6:	24 b3       	in	r18, 0x14	; 20
    23f8:	2d 7f       	andi	r18, 0xFD	; 253
    23fa:	24 bb       	out	0x14, r18	; 20
    23fc:	00 00       	nop
    23fe:	92 b9       	out	0x02, r25	; 2
    2400:	88 b9       	out	0x08, r24	; 8
    2402:	84 b3       	in	r24, 0x14	; 20
    2404:	8b 7f       	andi	r24, 0xFB	; 251
    2406:	84 bb       	out	0x14, r24	; 20
    2408:	00 00       	nop
    240a:	84 b3       	in	r24, 0x14	; 20
    240c:	84 60       	ori	r24, 0x04	; 4
    240e:	84 bb       	out	0x14, r24	; 20
    2410:	00 00       	nop
    2412:	84 b3       	in	r24, 0x14	; 20
    2414:	82 60       	ori	r24, 0x02	; 2
    2416:	84 bb       	out	0x14, r24	; 20
    2418:	08 95       	ret

0000241a <_Z9DisplayOnv>:
}

void DisplayOn()
{
	// Send command DisplayOn which is 0x29 in HEX.
	WriteCommand(0x29);
    241a:	89 e2       	ldi	r24, 0x29	; 41
    241c:	90 e0       	ldi	r25, 0x00	; 0
    241e:	d3 cf       	rjmp	.-90     	; 0x23c6 <_Z12WriteCommandj>
    2420:	08 95       	ret

00002422 <_Z8SleepOutv>:
}

void SleepOut()
{
	// Send command SleepOut which is 0x11 in HEX. 
	WriteCommand(0x11);
    2422:	81 e1       	ldi	r24, 0x11	; 17
    2424:	90 e0       	ldi	r25, 0x00	; 0
    2426:	cf cf       	rjmp	.-98     	; 0x23c6 <_Z12WriteCommandj>
    2428:	08 95       	ret

0000242a <_Z19MemoryAccessControlh>:
}

void MemoryAccessControl(unsigned char parameter)
{
    242a:	cf 93       	push	r28
    242c:	c8 2f       	mov	r28, r24
	WriteCommand(0x36);
    242e:	86 e3       	ldi	r24, 0x36	; 54
    2430:	90 e0       	ldi	r25, 0x00	; 0
    2432:	c9 df       	rcall	.-110    	; 0x23c6 <_Z12WriteCommandj>
	WriteData(parameter);
    2434:	8c 2f       	mov	r24, r28
    2436:	90 e0       	ldi	r25, 0x00	; 0
    2438:	db df       	rcall	.-74     	; 0x23f0 <_Z9WriteDataj>
}
    243a:	cf 91       	pop	r28
    243c:	08 95       	ret

0000243e <_Z20InterfacePixelFormath>:

void InterfacePixelFormat(unsigned char parameter)
{
    243e:	cf 93       	push	r28
    2440:	c8 2f       	mov	r28, r24
	WriteCommand(0x3A);
    2442:	8a e3       	ldi	r24, 0x3A	; 58
    2444:	90 e0       	ldi	r25, 0x00	; 0
    2446:	bf df       	rcall	.-130    	; 0x23c6 <_Z12WriteCommandj>
	WriteData(parameter);
    2448:	8c 2f       	mov	r24, r28
    244a:	90 e0       	ldi	r25, 0x00	; 0
    244c:	d1 df       	rcall	.-94     	; 0x23f0 <_Z9WriteDataj>
}
    244e:	cf 91       	pop	r28
    2450:	08 95       	ret

00002452 <_Z11DisplayInitv>:

// Initializes (resets) the display
void DisplayInit()
{
	// Control pins are outputs
	DDRG |= 0b00000111;
    2452:	83 b3       	in	r24, 0x13	; 19
    2454:	87 60       	ori	r24, 0x07	; 7
    2456:	83 bb       	out	0x13, r24	; 19
	DDRD |= 0b10000000;
    2458:	8a b1       	in	r24, 0x0a	; 10
    245a:	80 68       	ori	r24, 0x80	; 128
    245c:	8a b9       	out	0x0a, r24	; 10
	
	// Data pins are outputs
	DDRA = 0xFF;
    245e:	8f ef       	ldi	r24, 0xFF	; 255
    2460:	81 b9       	out	0x01, r24	; 1
	DDRC = 0xFF;
    2462:	87 b9       	out	0x07, r24	; 7
	
	// All control pins high;
	PORTG |= 0b00000111;
    2464:	84 b3       	in	r24, 0x14	; 20
    2466:	87 60       	ori	r24, 0x07	; 7
    2468:	84 bb       	out	0x14, r24	; 20
	PORTD |= 0b10000000;
    246a:	8b b1       	in	r24, 0x0b	; 11
    246c:	80 68       	ori	r24, 0x80	; 128
    246e:	8b b9       	out	0x0b, r24	; 11
	
	// Pull reset pin - Wait min 10 uS
	RST_PORT &= ~(1 << RST_BIT);
    2470:	84 b3       	in	r24, 0x14	; 20
    2472:	8e 7f       	andi	r24, 0xFE	; 254
    2474:	84 bb       	out	0x14, r24	; 20
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    2476:	2f ef       	ldi	r18, 0xFF	; 255
    2478:	89 e6       	ldi	r24, 0x69	; 105
    247a:	98 e1       	ldi	r25, 0x18	; 24
    247c:	21 50       	subi	r18, 0x01	; 1
    247e:	80 40       	sbci	r24, 0x00	; 0
    2480:	90 40       	sbci	r25, 0x00	; 0
    2482:	e1 f7       	brne	.-8      	; 0x247c <_Z11DisplayInitv+0x2a>
    2484:	00 c0       	rjmp	.+0      	; 0x2486 <_Z11DisplayInitv+0x34>
    2486:	00 00       	nop
	_delay_ms( 500 );

	RST_PORT |= (1 << RST_BIT);
    2488:	84 b3       	in	r24, 0x14	; 20
    248a:	81 60       	ori	r24, 0x01	; 1
    248c:	84 bb       	out	0x14, r24	; 20
    248e:	2f ef       	ldi	r18, 0xFF	; 255
    2490:	89 e6       	ldi	r24, 0x69	; 105
    2492:	98 e1       	ldi	r25, 0x18	; 24
    2494:	21 50       	subi	r18, 0x01	; 1
    2496:	80 40       	sbci	r24, 0x00	; 0
    2498:	90 40       	sbci	r25, 0x00	; 0
    249a:	e1 f7       	brne	.-8      	; 0x2494 <_Z11DisplayInitv+0x42>
    249c:	00 c0       	rjmp	.+0      	; 0x249e <_Z11DisplayInitv+0x4c>
    249e:	00 00       	nop
	
	// Wait for display to be rdy
	_delay_ms( 500 );
	
	// Set pixel interface and memoryaccesscontrol
	InterfacePixelFormat(0b00000101);
    24a0:	85 e0       	ldi	r24, 0x05	; 5
    24a2:	cd df       	rcall	.-102    	; 0x243e <_Z20InterfacePixelFormath>
	MemoryAccessControl(0b00001000);
    24a4:	88 e0       	ldi	r24, 0x08	; 8
	
	// Call sleepout and display on.
	SleepOut();
    24a6:	c1 df       	rcall	.-126    	; 0x242a <_Z19MemoryAccessControlh>
    24a8:	bc df       	rcall	.-136    	; 0x2422 <_Z8SleepOutv>
	DisplayOn();
    24aa:	b7 cf       	rjmp	.-146    	; 0x241a <_Z9DisplayOnv>
    24ac:	08 95       	ret

000024ae <_Z11MemoryWritev>:
    24ae:	8c e2       	ldi	r24, 0x2C	; 44
	WriteData(parameter);
}

void MemoryWrite()
{
	WriteCommand(0x2C);
    24b0:	90 e0       	ldi	r25, 0x00	; 0
    24b2:	89 cf       	rjmp	.-238    	; 0x23c6 <_Z12WriteCommandj>
    24b4:	08 95       	ret

000024b6 <_Z10WritePixelhhh>:
}

// Red 0-31, Green 0-63, Blue 0-31
void WritePixel(unsigned char Red, unsigned char Green, unsigned char Blue)
{
	uint16_t toSend = (Red << 11U) | (Green << 5U) | (Blue);
    24b6:	90 e0       	ldi	r25, 0x00	; 0
    24b8:	98 2f       	mov	r25, r24
    24ba:	88 27       	eor	r24, r24
    24bc:	99 0f       	add	r25, r25
    24be:	99 0f       	add	r25, r25
    24c0:	99 0f       	add	r25, r25
    24c2:	20 e2       	ldi	r18, 0x20	; 32
    24c4:	62 9f       	mul	r22, r18
    24c6:	b0 01       	movw	r22, r0
    24c8:	11 24       	eor	r1, r1
    24ca:	86 2b       	or	r24, r22
    24cc:	97 2b       	or	r25, r23
	WriteData(toSend);
    24ce:	84 2b       	or	r24, r20
    24d0:	8f cf       	rjmp	.-226    	; 0x23f0 <_Z9WriteDataj>
    24d2:	08 95       	ret

000024d4 <_Z16SetColumnAddressjj>:
}

// Set Column Address (0-239), Start > End
void SetColumnAddress(unsigned int Start, unsigned int End)
{
    24d4:	0f 93       	push	r16
    24d6:	1f 93       	push	r17
    24d8:	cf 93       	push	r28
    24da:	df 93       	push	r29
	if (Start < End)
    24dc:	86 17       	cp	r24, r22
    24de:	97 07       	cpc	r25, r23
    24e0:	78 f4       	brcc	.+30     	; 0x2500 <_Z16SetColumnAddressjj+0x2c>
    24e2:	eb 01       	movw	r28, r22
    24e4:	8c 01       	movw	r16, r24
	{
		WriteCommand(0x2A);
    24e6:	8a e2       	ldi	r24, 0x2A	; 42
    24e8:	90 e0       	ldi	r25, 0x00	; 0
    24ea:	6d df       	rcall	.-294    	; 0x23c6 <_Z12WriteCommandj>
		WriteData(Start >> 8U);
    24ec:	81 2f       	mov	r24, r17
    24ee:	90 e0       	ldi	r25, 0x00	; 0
    24f0:	7f df       	rcall	.-258    	; 0x23f0 <_Z9WriteDataj>
		WriteData(Start);
    24f2:	c8 01       	movw	r24, r16
    24f4:	7d df       	rcall	.-262    	; 0x23f0 <_Z9WriteDataj>
		WriteData(End >> 8U);
    24f6:	8d 2f       	mov	r24, r29
    24f8:	90 e0       	ldi	r25, 0x00	; 0
    24fa:	7a df       	rcall	.-268    	; 0x23f0 <_Z9WriteDataj>
		WriteData(End);
    24fc:	ce 01       	movw	r24, r28
    24fe:	78 df       	rcall	.-272    	; 0x23f0 <_Z9WriteDataj>
    2500:	df 91       	pop	r29
	}
}
    2502:	cf 91       	pop	r28
    2504:	1f 91       	pop	r17
    2506:	0f 91       	pop	r16
    2508:	08 95       	ret

0000250a <_Z14SetPageAddressjj>:
    250a:	0f 93       	push	r16

// Set Page Address (0-319), Start > End
void SetPageAddress(unsigned int Start, unsigned int End)
{
    250c:	1f 93       	push	r17
    250e:	cf 93       	push	r28
    2510:	df 93       	push	r29
	if (Start < End)
    2512:	86 17       	cp	r24, r22
    2514:	97 07       	cpc	r25, r23
    2516:	78 f4       	brcc	.+30     	; 0x2536 <_Z14SetPageAddressjj+0x2c>
    2518:	eb 01       	movw	r28, r22
    251a:	8c 01       	movw	r16, r24
	{
		WriteCommand(0x2B);
    251c:	8b e2       	ldi	r24, 0x2B	; 43
    251e:	90 e0       	ldi	r25, 0x00	; 0
    2520:	52 df       	rcall	.-348    	; 0x23c6 <_Z12WriteCommandj>
		WriteData(Start >> 8U);
    2522:	81 2f       	mov	r24, r17
    2524:	90 e0       	ldi	r25, 0x00	; 0
    2526:	64 df       	rcall	.-312    	; 0x23f0 <_Z9WriteDataj>
		WriteData(Start);
    2528:	c8 01       	movw	r24, r16
    252a:	62 df       	rcall	.-316    	; 0x23f0 <_Z9WriteDataj>
		WriteData(End >> 8U);
    252c:	8d 2f       	mov	r24, r29
    252e:	90 e0       	ldi	r25, 0x00	; 0
    2530:	5f df       	rcall	.-322    	; 0x23f0 <_Z9WriteDataj>
		WriteData(End);
    2532:	ce 01       	movw	r24, r28
    2534:	5d df       	rcall	.-326    	; 0x23f0 <_Z9WriteDataj>
    2536:	df 91       	pop	r29
	}
}
    2538:	cf 91       	pop	r28
    253a:	1f 91       	pop	r17
    253c:	0f 91       	pop	r16
    253e:	08 95       	ret

00002540 <_Z13FillRectanglejjjjhhh>:
    2540:	6f 92       	push	r6
// Fills rectangle with specified color
// (StartX,StartY) = Upper left corner. X horizontal (0-319) , Y vertical (0-239).
// Height (1-240) is vertical. Width (1-320) is horizontal.
// R-G-B = 5-6-5 bits.
void FillRectangle(unsigned int StartX, unsigned int StartY, unsigned int Width, unsigned int Height, unsigned char Blue, unsigned char Green, unsigned char Red)
{
    2542:	7f 92       	push	r7
    2544:	8f 92       	push	r8
    2546:	9f 92       	push	r9
    2548:	af 92       	push	r10
    254a:	bf 92       	push	r11
    254c:	cf 92       	push	r12
    254e:	ef 92       	push	r14
    2550:	0f 93       	push	r16
    2552:	cf 93       	push	r28
    2554:	df 93       	push	r29
    2556:	5b 01       	movw	r10, r22
    2558:	3a 01       	movw	r6, r20
    255a:	e9 01       	movw	r28, r18
	SetPageAddress(StartX,StartX+Width-1);
    255c:	bc 01       	movw	r22, r24
    255e:	64 0f       	add	r22, r20
    2560:	75 1f       	adc	r23, r21
    2562:	61 50       	subi	r22, 0x01	; 1
    2564:	71 09       	sbc	r23, r1
    2566:	d1 df       	rcall	.-94     	; 0x250a <_Z14SetPageAddressjj>
	SetColumnAddress(StartY,StartY+Height-1);
    2568:	b5 01       	movw	r22, r10
    256a:	6c 0f       	add	r22, r28
    256c:	7d 1f       	adc	r23, r29
    256e:	61 50       	subi	r22, 0x01	; 1
    2570:	71 09       	sbc	r23, r1
    2572:	c5 01       	movw	r24, r10
	MemoryWrite();
    2574:	af df       	rcall	.-162    	; 0x24d4 <_Z16SetColumnAddressjj>
    2576:	9b df       	rcall	.-202    	; 0x24ae <_Z11MemoryWritev>
	
	for (uint32_t counter = 0; counter < (uint32_t)Width*Height; counter++)
    2578:	81 2c       	mov	r8, r1
    257a:	91 2c       	mov	r9, r1
    257c:	54 01       	movw	r10, r8
    257e:	93 01       	movw	r18, r6
    2580:	de 01       	movw	r26, r28
    2582:	e9 d4       	rcall	.+2514   	; 0x2f56 <__umulhisi3>
    2584:	86 16       	cp	r8, r22
    2586:	97 06       	cpc	r9, r23
    2588:	a8 06       	cpc	r10, r24
    258a:	b9 06       	cpc	r11, r25
	{
		WritePixel(Red,Green,Blue);
    258c:	50 f4       	brcc	.+20     	; 0x25a2 <_Z13FillRectanglejjjjhhh+0x62>
    258e:	40 2f       	mov	r20, r16
    2590:	6e 2d       	mov	r22, r14
    2592:	8c 2d       	mov	r24, r12
    2594:	90 df       	rcall	.-224    	; 0x24b6 <_Z10WritePixelhhh>
{
	SetPageAddress(StartX,StartX+Width-1);
	SetColumnAddress(StartY,StartY+Height-1);
	MemoryWrite();
	
	for (uint32_t counter = 0; counter < (uint32_t)Width*Height; counter++)
    2596:	8f ef       	ldi	r24, 0xFF	; 255
    2598:	88 1a       	sub	r8, r24
    259a:	98 0a       	sbc	r9, r24
    259c:	a8 0a       	sbc	r10, r24
    259e:	b8 0a       	sbc	r11, r24
	{
		WritePixel(Red,Green,Blue);
	}
	SleepOut();
    25a0:	ee cf       	rjmp	.-36     	; 0x257e <_Z13FillRectanglejjjjhhh+0x3e>
    25a2:	3f df       	rcall	.-386    	; 0x2422 <_Z8SleepOutv>
}
    25a4:	df 91       	pop	r29
    25a6:	cf 91       	pop	r28
    25a8:	0f 91       	pop	r16
    25aa:	ef 90       	pop	r14
    25ac:	cf 90       	pop	r12
    25ae:	bf 90       	pop	r11
    25b0:	af 90       	pop	r10
    25b2:	9f 90       	pop	r9
    25b4:	8f 90       	pop	r8
    25b6:	7f 90       	pop	r7
    25b8:	6f 90       	pop	r6
    25ba:	08 95       	ret

000025bc <_ZN11TouchscreenC1Ev>:
#include "TFTdriver.h"
#include "ButtonClass.h"
#include "uart.h"


Touchscreen::Touchscreen()
    25bc:	0f 93       	push	r16
    25be:	1f 93       	push	r17
    25c0:	cf 93       	push	r28
    25c2:	df 93       	push	r29
    25c4:	cd b7       	in	r28, 0x3d	; 61
    25c6:	de b7       	in	r29, 0x3e	; 62
    25c8:	66 97       	sbiw	r28, 0x16	; 22
    25ca:	0f b6       	in	r0, 0x3f	; 63
    25cc:	f8 94       	cli
    25ce:	de bf       	out	0x3e, r29	; 62
    25d0:	0f be       	out	0x3f, r0	; 63
    25d2:	cd bf       	out	0x3d, r28	; 61
    25d4:	8c 01       	movw	r16, r24
    25d6:	45 d1       	rcall	.+650    	; 0x2862 <_ZN11TouchDriverC1Ev>
{
	
	public:
	ButtonClass()
	{
		startX = 0;
    25d8:	f8 01       	movw	r30, r16
    25da:	12 82       	std	Z+2, r1	; 0x02
		startY = 0;
    25dc:	13 82       	std	Z+3, r1	; 0x03
		height = 0;
    25de:	14 82       	std	Z+4, r1	; 0x04
		width = 0;
    25e0:	15 82       	std	Z+5, r1	; 0x05
		colorRed = 0;
    25e2:	16 82       	std	Z+6, r1	; 0x06
		colorBlue = 0;
    25e4:	17 82       	std	Z+7, r1	; 0x07
		colorGreen = 0;
    25e6:	10 86       	std	Z+8, r1	; 0x08
		endX = 0;
    25e8:	12 86       	std	Z+10, r1	; 0x0a
    25ea:	11 86       	std	Z+9, r1	; 0x09
		endY = 0;
    25ec:	13 86       	std	Z+11, r1	; 0x0b
{
	
	public:
	ButtonClass()
	{
		startX = 0;
    25ee:	14 86       	std	Z+12, r1	; 0x0c
		startY = 0;
    25f0:	15 86       	std	Z+13, r1	; 0x0d
		height = 0;
    25f2:	16 86       	std	Z+14, r1	; 0x0e
		width = 0;
    25f4:	17 86       	std	Z+15, r1	; 0x0f
		colorRed = 0;
    25f6:	10 8a       	std	Z+16, r1	; 0x10
		colorBlue = 0;
    25f8:	11 8a       	std	Z+17, r1	; 0x11
		colorGreen = 0;
    25fa:	12 8a       	std	Z+18, r1	; 0x12
		endX = 0;
    25fc:	14 8a       	std	Z+20, r1	; 0x14
    25fe:	13 8a       	std	Z+19, r1	; 0x13
		endY = 0;
    2600:	15 8a       	std	Z+21, r1	; 0x15
{
	TouchDriv = TouchDriver();
    2602:	ce 01       	movw	r24, r28
    2604:	45 96       	adiw	r24, 0x15	; 21
    2606:	2d d1       	rcall	.+602    	; 0x2862 <_ZN11TouchDriverC1Ev>
    2608:	8d 89       	ldd	r24, Y+21	; 0x15
    260a:	9e 89       	ldd	r25, Y+22	; 0x16
    260c:	d8 01       	movw	r26, r16
    260e:	8d 93       	st	X+, r24
    2610:	9d 93       	st	X+, r25
	}
	
	ButtonClass(uint8_t StartX, uint8_t StartY, uint16_t EndX, uint8_t EndY, uint8_t ColorRed, uint8_t ColorBlue, uint8_t ColorGreen)
	{
		startX = StartX;
    2612:	84 e1       	ldi	r24, 0x14	; 20
    2614:	8b 87       	std	Y+11, r24	; 0x0b
		startY = StartY;
    2616:	46 e4       	ldi	r20, 0x46	; 70
    2618:	4c 87       	std	Y+12, r20	; 0x0c
		endX = EndX;
    261a:	88 e7       	ldi	r24, 0x78	; 120
    261c:	90 e0       	ldi	r25, 0x00	; 0
    261e:	9b 8b       	std	Y+19, r25	; 0x13
    2620:	8a 8b       	std	Y+18, r24	; 0x12
		endY = EndY;
    2622:	3a ea       	ldi	r19, 0xAA	; 170
    2624:	3c 8b       	std	Y+20, r19	; 0x14
		width = EndX-StartX;
    2626:	84 e6       	ldi	r24, 0x64	; 100
    2628:	8e 87       	std	Y+14, r24	; 0x0e
		height = EndY-StartY;
    262a:	8d 87       	std	Y+13, r24	; 0x0d
		colorRed = ColorRed;
    262c:	9d e1       	ldi	r25, 0x1D	; 29
    262e:	9f 87       	std	Y+15, r25	; 0x0f
		colorBlue = ColorBlue;
    2630:	9a ee       	ldi	r25, 0xEA	; 234
    2632:	98 8b       	std	Y+16, r25	; 0x10
		colorGreen = ColorGreen;
    2634:	22 e0       	ldi	r18, 0x02	; 2
    2636:	29 8b       	std	Y+17, r18	; 0x11
	
	blueBnt = ButtonClass(20, 70, 120, 170, 29, 234, 2);
    2638:	5a e0       	ldi	r21, 0x0A	; 10
    263a:	fe 01       	movw	r30, r28
    263c:	3b 96       	adiw	r30, 0x0b	; 11
    263e:	01 90       	ld	r0, Z+
    2640:	0d 92       	st	X+, r0
    2642:	5a 95       	dec	r21
    2644:	e1 f7       	brne	.-8      	; 0x263e <_ZN11TouchscreenC1Ev+0x82>
		endY = 0;
	}
	
	ButtonClass(uint8_t StartX, uint8_t StartY, uint16_t EndX, uint8_t EndY, uint8_t ColorRed, uint8_t ColorBlue, uint8_t ColorGreen)
	{
		startX = StartX;
    2646:	58 ec       	ldi	r21, 0xC8	; 200
    2648:	59 83       	std	Y+1, r21	; 0x01
		startY = StartY;
    264a:	4a 83       	std	Y+2, r20	; 0x02
		endX = EndX;
    264c:	4c e2       	ldi	r20, 0x2C	; 44
    264e:	51 e0       	ldi	r21, 0x01	; 1
    2650:	59 87       	std	Y+9, r21	; 0x09
    2652:	48 87       	std	Y+8, r20	; 0x08
		endY = EndY;
    2654:	3a 87       	std	Y+10, r19	; 0x0a
		width = EndX-StartX;
    2656:	8c 83       	std	Y+4, r24	; 0x04
		height = EndY-StartY;
    2658:	8b 83       	std	Y+3, r24	; 0x03
		colorRed = ColorRed;
    265a:	8c e2       	ldi	r24, 0x2C	; 44
    265c:	8d 83       	std	Y+5, r24	; 0x05
		colorBlue = ColorBlue;
    265e:	2e 83       	std	Y+6, r18	; 0x06
		colorGreen = ColorGreen;
    2660:	9f 83       	std	Y+7, r25	; 0x07
	greenBnt = ButtonClass(200, 70, 300, 170, 44, 2, 234);
    2662:	8a e0       	ldi	r24, 0x0A	; 10
    2664:	fe 01       	movw	r30, r28
    2666:	31 96       	adiw	r30, 0x01	; 1
    2668:	d8 01       	movw	r26, r16
    266a:	1c 96       	adiw	r26, 0x0c	; 12
    266c:	01 90       	ld	r0, Z+
    266e:	0d 92       	st	X+, r0
    2670:	8a 95       	dec	r24
	
	DisplayInit();
    2672:	e1 f7       	brne	.-8      	; 0x266c <_ZN11TouchscreenC1Ev+0xb0>
    2674:	ee de       	rcall	.-548    	; 0x2452 <_Z11DisplayInitv>
}
    2676:	66 96       	adiw	r28, 0x16	; 22
    2678:	0f b6       	in	r0, 0x3f	; 63
    267a:	f8 94       	cli
    267c:	de bf       	out	0x3e, r29	; 62
    267e:	0f be       	out	0x3f, r0	; 63
    2680:	cd bf       	out	0x3d, r28	; 61
    2682:	df 91       	pop	r29
    2684:	cf 91       	pop	r28
    2686:	1f 91       	pop	r17
    2688:	0f 91       	pop	r16
    268a:	08 95       	ret

0000268c <_ZN11Touchscreen12checkButtonsEv>:


uint8_t Touchscreen::checkButtons(void)
{
    268c:	cf 92       	push	r12
    268e:	df 92       	push	r13
    2690:	ef 92       	push	r14
    2692:	ff 92       	push	r15
    2694:	0f 93       	push	r16
    2696:	1f 93       	push	r17
    2698:	cf 93       	push	r28
    269a:	df 93       	push	r29
    269c:	1f 92       	push	r1
    269e:	1f 92       	push	r1
    26a0:	cd b7       	in	r28, 0x3d	; 61
    26a2:	de b7       	in	r29, 0x3e	; 62
    26a4:	8c 01       	movw	r16, r24
	uint8_t x = 0;
    26a6:	19 82       	std	Y+1, r1	; 0x01
	uint8_t y = 0;
    26a8:	1a 82       	std	Y+2, r1	; 0x02
	
	TouchDriv.getCoordinates(&x, &y);
    26aa:	ae 01       	movw	r20, r28
    26ac:	4e 5f       	subi	r20, 0xFE	; 254
    26ae:	5f 4f       	sbci	r21, 0xFF	; 255
    26b0:	be 01       	movw	r22, r28
    26b2:	6f 5f       	subi	r22, 0xFF	; 255
    26b4:	7f 4f       	sbci	r23, 0xFF	; 255
    26b6:	6a d1       	rcall	.+724    	; 0x298c <_ZN11TouchDriver14getCoordinatesEPhS0_>
	SendString("X value: ");
    26b8:	8b eb       	ldi	r24, 0xBB	; 187
    26ba:	92 e0       	ldi	r25, 0x02	; 2
    26bc:	e5 d1       	rcall	.+970    	; 0x2a88 <_Z10SendStringPc>
	SendInteger(x);
    26be:	89 81       	ldd	r24, Y+1	; 0x01
    26c0:	90 e0       	ldi	r25, 0x00	; 0
    26c2:	ee d1       	rcall	.+988    	; 0x2aa0 <_Z11SendIntegeri>
	SendString("y value: ");
    26c4:	85 ec       	ldi	r24, 0xC5	; 197
    26c6:	92 e0       	ldi	r25, 0x02	; 2
    26c8:	df d1       	rcall	.+958    	; 0x2a88 <_Z10SendStringPc>
	SendInteger(y);
    26ca:	8a 81       	ldd	r24, Y+2	; 0x02
    26cc:	90 e0       	ldi	r25, 0x00	; 0
    26ce:	e8 d1       	rcall	.+976    	; 0x2aa0 <_Z11SendIntegeri>
	SendString("\r\n");
    26d0:	8a e1       	ldi	r24, 0x1A	; 26
    26d2:	92 e0       	ldi	r25, 0x02	; 2
    26d4:	d9 d1       	rcall	.+946    	; 0x2a88 <_Z10SendStringPc>
	if (x > blueBnt.startX/1.33 && x < blueBnt.endX/1.33 && y > blueBnt.startY && y < blueBnt.endY)
    26d6:	69 81       	ldd	r22, Y+1	; 0x01
    26d8:	70 e0       	ldi	r23, 0x00	; 0
    26da:	80 e0       	ldi	r24, 0x00	; 0
    26dc:	90 e0       	ldi	r25, 0x00	; 0
    26de:	fa d2       	rcall	.+1524   	; 0x2cd4 <__floatsisf>
    26e0:	6b 01       	movw	r12, r22
    26e2:	7c 01       	movw	r14, r24
    26e4:	f8 01       	movw	r30, r16
    26e6:	62 81       	ldd	r22, Z+2	; 0x02
    26e8:	70 e0       	ldi	r23, 0x00	; 0
    26ea:	80 e0       	ldi	r24, 0x00	; 0
    26ec:	90 e0       	ldi	r25, 0x00	; 0
    26ee:	f2 d2       	rcall	.+1508   	; 0x2cd4 <__floatsisf>
    26f0:	21 e7       	ldi	r18, 0x71	; 113
    26f2:	3d e3       	ldi	r19, 0x3D	; 61
    26f4:	4a ea       	ldi	r20, 0xAA	; 170
    26f6:	5f e3       	ldi	r21, 0x3F	; 63
    26f8:	57 d2       	rcall	.+1198   	; 0x2ba8 <__divsf3>
    26fa:	9b 01       	movw	r18, r22
    26fc:	ac 01       	movw	r20, r24
    26fe:	c7 01       	movw	r24, r14
    2700:	b6 01       	movw	r22, r12
    2702:	98 d3       	rcall	.+1840   	; 0x2e34 <__gesf2>
    2704:	18 16       	cp	r1, r24
    2706:	d4 f4       	brge	.+52     	; 0x273c <_ZN11Touchscreen12checkButtonsEv+0xb0>
    2708:	f8 01       	movw	r30, r16
    270a:	61 85       	ldd	r22, Z+9	; 0x09
    270c:	72 85       	ldd	r23, Z+10	; 0x0a
    270e:	80 e0       	ldi	r24, 0x00	; 0
    2710:	90 e0       	ldi	r25, 0x00	; 0
    2712:	de d2       	rcall	.+1468   	; 0x2cd0 <__floatunsisf>
    2714:	21 e7       	ldi	r18, 0x71	; 113
    2716:	3d e3       	ldi	r19, 0x3D	; 61
    2718:	4a ea       	ldi	r20, 0xAA	; 170
    271a:	5f e3       	ldi	r21, 0x3F	; 63
    271c:	45 d2       	rcall	.+1162   	; 0x2ba8 <__divsf3>
    271e:	9b 01       	movw	r18, r22
    2720:	ac 01       	movw	r20, r24
    2722:	c7 01       	movw	r24, r14
    2724:	b6 01       	movw	r22, r12
    2726:	3c d2       	rcall	.+1144   	; 0x2ba0 <__cmpsf2>
    2728:	88 23       	and	r24, r24
    272a:	44 f4       	brge	.+16     	; 0x273c <_ZN11Touchscreen12checkButtonsEv+0xb0>
    272c:	f8 01       	movw	r30, r16
    272e:	93 81       	ldd	r25, Z+3	; 0x03
    2730:	8a 81       	ldd	r24, Y+2	; 0x02
    2732:	98 17       	cp	r25, r24
    2734:	18 f4       	brcc	.+6      	; 0x273c <_ZN11Touchscreen12checkButtonsEv+0xb0>
    2736:	93 85       	ldd	r25, Z+11	; 0x0b
    2738:	89 17       	cp	r24, r25
	{
		return 1;
	}
	else if (x > greenBnt.startX/1.33 && x < greenBnt.endX/1.33 && y > greenBnt.startY && y < greenBnt.endY)
    273a:	70 f1       	brcs	.+92     	; 0x2798 <_ZN11Touchscreen12checkButtonsEv+0x10c>
    273c:	f8 01       	movw	r30, r16
    273e:	64 85       	ldd	r22, Z+12	; 0x0c
    2740:	70 e0       	ldi	r23, 0x00	; 0
    2742:	80 e0       	ldi	r24, 0x00	; 0
    2744:	90 e0       	ldi	r25, 0x00	; 0
    2746:	c6 d2       	rcall	.+1420   	; 0x2cd4 <__floatsisf>
    2748:	21 e7       	ldi	r18, 0x71	; 113
    274a:	3d e3       	ldi	r19, 0x3D	; 61
    274c:	4a ea       	ldi	r20, 0xAA	; 170
    274e:	5f e3       	ldi	r21, 0x3F	; 63
    2750:	2b d2       	rcall	.+1110   	; 0x2ba8 <__divsf3>
    2752:	9b 01       	movw	r18, r22
    2754:	ac 01       	movw	r20, r24
    2756:	c7 01       	movw	r24, r14
    2758:	b6 01       	movw	r22, r12
    275a:	6c d3       	rcall	.+1752   	; 0x2e34 <__gesf2>
    275c:	18 16       	cp	r1, r24
    275e:	f4 f4       	brge	.+60     	; 0x279c <_ZN11Touchscreen12checkButtonsEv+0x110>
    2760:	f8 01       	movw	r30, r16
    2762:	63 89       	ldd	r22, Z+19	; 0x13
    2764:	74 89       	ldd	r23, Z+20	; 0x14
    2766:	80 e0       	ldi	r24, 0x00	; 0
    2768:	90 e0       	ldi	r25, 0x00	; 0
    276a:	b2 d2       	rcall	.+1380   	; 0x2cd0 <__floatunsisf>
    276c:	21 e7       	ldi	r18, 0x71	; 113
    276e:	3d e3       	ldi	r19, 0x3D	; 61
    2770:	4a ea       	ldi	r20, 0xAA	; 170
    2772:	5f e3       	ldi	r21, 0x3F	; 63
    2774:	19 d2       	rcall	.+1074   	; 0x2ba8 <__divsf3>
    2776:	9b 01       	movw	r18, r22
    2778:	ac 01       	movw	r20, r24
    277a:	c7 01       	movw	r24, r14
    277c:	b6 01       	movw	r22, r12
    277e:	10 d2       	rcall	.+1056   	; 0x2ba0 <__cmpsf2>
    2780:	88 23       	and	r24, r24
    2782:	74 f4       	brge	.+28     	; 0x27a0 <_ZN11Touchscreen12checkButtonsEv+0x114>
    2784:	f8 01       	movw	r30, r16
    2786:	95 85       	ldd	r25, Z+13	; 0x0d
    2788:	8a 81       	ldd	r24, Y+2	; 0x02
    278a:	98 17       	cp	r25, r24
    278c:	58 f4       	brcc	.+22     	; 0x27a4 <_ZN11Touchscreen12checkButtonsEv+0x118>
    278e:	95 89       	ldd	r25, Z+21	; 0x15
    2790:	89 17       	cp	r24, r25
    2792:	50 f0       	brcs	.+20     	; 0x27a8 <_ZN11Touchscreen12checkButtonsEv+0x11c>
    2794:	80 e0       	ldi	r24, 0x00	; 0
    2796:	09 c0       	rjmp	.+18     	; 0x27aa <_ZN11Touchscreen12checkButtonsEv+0x11e>
	{
		return 2;
	}
	else
	{
		return 0;
    2798:	81 e0       	ldi	r24, 0x01	; 1
    279a:	07 c0       	rjmp	.+14     	; 0x27aa <_ZN11Touchscreen12checkButtonsEv+0x11e>
	SendString("y value: ");
	SendInteger(y);
	SendString("\r\n");
	if (x > blueBnt.startX/1.33 && x < blueBnt.endX/1.33 && y > blueBnt.startY && y < blueBnt.endY)
	{
		return 1;
    279c:	80 e0       	ldi	r24, 0x00	; 0
    279e:	05 c0       	rjmp	.+10     	; 0x27aa <_ZN11Touchscreen12checkButtonsEv+0x11e>
	{
		return 2;
	}
	else
	{
		return 0;
    27a0:	80 e0       	ldi	r24, 0x00	; 0
    27a2:	03 c0       	rjmp	.+6      	; 0x27aa <_ZN11Touchscreen12checkButtonsEv+0x11e>
    27a4:	80 e0       	ldi	r24, 0x00	; 0
    27a6:	01 c0       	rjmp	.+2      	; 0x27aa <_ZN11Touchscreen12checkButtonsEv+0x11e>
    27a8:	82 e0       	ldi	r24, 0x02	; 2
    27aa:	0f 90       	pop	r0
	{
		return 1;
	}
	else if (x > greenBnt.startX/1.33 && x < greenBnt.endX/1.33 && y > greenBnt.startY && y < greenBnt.endY)
	{
		return 2;
    27ac:	0f 90       	pop	r0
	else
	{
		return 0;
	}
	
}
    27ae:	df 91       	pop	r29
    27b0:	cf 91       	pop	r28
    27b2:	1f 91       	pop	r17
    27b4:	0f 91       	pop	r16
    27b6:	ff 90       	pop	r15
    27b8:	ef 90       	pop	r14
    27ba:	df 90       	pop	r13
    27bc:	cf 90       	pop	r12
    27be:	08 95       	ret

000027c0 <_ZN11Touchscreen11clearScreenEv>:
    27c0:	cf 92       	push	r12
    27c2:	ef 92       	push	r14

void Touchscreen::clearScreen(void)
{
    27c4:	0f 93       	push	r16
	// Full Screen White
	FillRectangle(0,0,320,240,255,255,255);
    27c6:	cc 24       	eor	r12, r12
    27c8:	ca 94       	dec	r12
    27ca:	ee 24       	eor	r14, r14
    27cc:	ea 94       	dec	r14
    27ce:	0f ef       	ldi	r16, 0xFF	; 255
    27d0:	20 ef       	ldi	r18, 0xF0	; 240
    27d2:	30 e0       	ldi	r19, 0x00	; 0
    27d4:	40 e4       	ldi	r20, 0x40	; 64
    27d6:	51 e0       	ldi	r21, 0x01	; 1
    27d8:	60 e0       	ldi	r22, 0x00	; 0
    27da:	70 e0       	ldi	r23, 0x00	; 0
    27dc:	80 e0       	ldi	r24, 0x00	; 0
    27de:	90 e0       	ldi	r25, 0x00	; 0
    27e0:	af de       	rcall	.-674    	; 0x2540 <_Z13FillRectanglejjjjhhh>
}
    27e2:	0f 91       	pop	r16
    27e4:	ef 90       	pop	r14
    27e6:	cf 90       	pop	r12
    27e8:	08 95       	ret

000027ea <_ZN11Touchscreen23presentButtonsOnDisplayEv>:

void Touchscreen::presentButtonsOnDisplay(void)
{
    27ea:	cf 92       	push	r12
    27ec:	ef 92       	push	r14
    27ee:	0f 93       	push	r16
    27f0:	cf 93       	push	r28
    27f2:	df 93       	push	r29
    27f4:	ec 01       	movw	r28, r24
	
	// Button One
	FillRectangle(blueBnt.startX, blueBnt.startY, blueBnt.width, blueBnt.height, blueBnt.colorRed, blueBnt.colorGreen, blueBnt.colorBlue);
    27f6:	cf 80       	ldd	r12, Y+7	; 0x07
    27f8:	e8 84       	ldd	r14, Y+8	; 0x08
    27fa:	0e 81       	ldd	r16, Y+6	; 0x06
    27fc:	2c 81       	ldd	r18, Y+4	; 0x04
    27fe:	30 e0       	ldi	r19, 0x00	; 0
    2800:	4d 81       	ldd	r20, Y+5	; 0x05
    2802:	50 e0       	ldi	r21, 0x00	; 0
    2804:	6b 81       	ldd	r22, Y+3	; 0x03
    2806:	70 e0       	ldi	r23, 0x00	; 0
    2808:	8a 81       	ldd	r24, Y+2	; 0x02
    280a:	90 e0       	ldi	r25, 0x00	; 0
    280c:	99 de       	rcall	.-718    	; 0x2540 <_Z13FillRectanglejjjjhhh>

	// Button Two
	FillRectangle(greenBnt.startX, greenBnt.startY, greenBnt.width, greenBnt.height, greenBnt.colorRed, greenBnt.colorGreen, greenBnt.colorBlue);
    280e:	c9 88       	ldd	r12, Y+17	; 0x11
    2810:	ea 88       	ldd	r14, Y+18	; 0x12
    2812:	08 89       	ldd	r16, Y+16	; 0x10
    2814:	2e 85       	ldd	r18, Y+14	; 0x0e
    2816:	30 e0       	ldi	r19, 0x00	; 0
    2818:	4f 85       	ldd	r20, Y+15	; 0x0f
    281a:	50 e0       	ldi	r21, 0x00	; 0
    281c:	6d 85       	ldd	r22, Y+13	; 0x0d
    281e:	70 e0       	ldi	r23, 0x00	; 0
    2820:	8c 85       	ldd	r24, Y+12	; 0x0c
    2822:	90 e0       	ldi	r25, 0x00	; 0
    2824:	8d de       	rcall	.-742    	; 0x2540 <_Z13FillRectanglejjjjhhh>
}
    2826:	df 91       	pop	r29
    2828:	cf 91       	pop	r28
    282a:	0f 91       	pop	r16
    282c:	ef 90       	pop	r14
    282e:	cf 90       	pop	r12
    2830:	08 95       	ret

00002832 <_ZN11TouchDriver15initTouchDriverEv>:
	/* MODE							= 12bit = High							*/
	/* SER/DFR						= Differential = Low					*/
	/* PD1/PD0						= Device always powered = 11			*/
	/************************************************************************/
	
	dinXByte = 0b10011100;
    2832:	2c e9       	ldi	r18, 0x9C	; 156
    2834:	fc 01       	movw	r30, r24
    2836:	20 83       	st	Z, r18
	dinYByte = 0b11011100;
    2838:	2c ed       	ldi	r18, 0xDC	; 220
    283a:	21 83       	std	Z+1, r18	; 0x01
	
	DDRH |= BIT4_SHIFTED;
    283c:	e1 e0       	ldi	r30, 0x01	; 1
    283e:	f1 e0       	ldi	r31, 0x01	; 1
    2840:	80 81       	ld	r24, Z
    2842:	88 60       	ori	r24, 0x08	; 8
    2844:	80 83       	st	Z, r24
	DDRE |= BIT4_SHIFTED;
    2846:	8d b1       	in	r24, 0x0d	; 13
    2848:	88 60       	ori	r24, 0x08	; 8
    284a:	8d b9       	out	0x0d, r24	; 13
	DDRG |= BIT6_SHIFTED;
    284c:	83 b3       	in	r24, 0x13	; 19
    284e:	80 62       	ori	r24, 0x20	; 32
    2850:	83 bb       	out	0x13, r24	; 19
	
	// Enable Interrupt
	EICRB = 0b00000010;
    2852:	82 e0       	ldi	r24, 0x02	; 2
    2854:	80 93 6a 00 	sts	0x006A, r24	; 0x80006a <__TEXT_REGION_LENGTH__+0x70006a>
	EIMSK |= 0b00010000;
    2858:	8d b3       	in	r24, 0x1d	; 29
    285a:	80 61       	ori	r24, 0x10	; 16
    285c:	8d bb       	out	0x1d, r24	; 29
	
	sei();
    285e:	78 94       	sei
    2860:	08 95       	ret

00002862 <_ZN11TouchDriverC1Ev>:
/* PE4 = IRQ (Not Used)													*/
/************************************************************************/

TouchDriver::TouchDriver()
{
	initTouchDriver();
    2862:	e7 cf       	rjmp	.-50     	; 0x2832 <_ZN11TouchDriver15initTouchDriverEv>
    2864:	08 95       	ret

00002866 <__vector_5>:
	sei();
	
}

ISR (INT4_vect)
{
    2866:	1f 92       	push	r1
    2868:	0f 92       	push	r0
    286a:	0f b6       	in	r0, 0x3f	; 63
    286c:	0f 92       	push	r0
    286e:	11 24       	eor	r1, r1
	eIntHappend = 0;
    2870:	10 92 0d 02 	sts	0x020D, r1	; 0x80020d <eIntHappend>
}
    2874:	0f 90       	pop	r0
    2876:	0f be       	out	0x3f, r0	; 63
    2878:	0f 90       	pop	r0
    287a:	1f 90       	pop	r1
    287c:	18 95       	reti

0000287e <_ZN11TouchDriver9readTouchEc>:
{
    
    uint8_t delayTime = 8;
    uint8_t dinByte = 0;
    
    if (coord == 'X')
    287e:	68 35       	cpi	r22, 0x58	; 88
    2880:	19 f4       	brne	.+6      	; 0x2888 <_ZN11TouchDriver9readTouchEc+0xa>
    {
        dinByte = dinXByte;
    2882:	fc 01       	movw	r30, r24
    2884:	70 81       	ld	r23, Z
    2886:	05 c0       	rjmp	.+10     	; 0x2892 <_ZN11TouchDriver9readTouchEc+0x14>
        
    }else if (coord == 'Y')
    2888:	69 35       	cpi	r22, 0x59	; 89
    288a:	09 f0       	breq	.+2      	; 0x288e <_ZN11TouchDriver9readTouchEc+0x10>
    288c:	7d c0       	rjmp	.+250    	; 0x2988 <_ZN11TouchDriver9readTouchEc+0x10a>
    {
        dinByte = dinYByte;
    288e:	fc 01       	movw	r30, r24
    2890:	71 81       	ldd	r23, Z+1	; 0x01
    else{
        return 255;
    }
    
    // ChipSelect Set to 0    
    CS_PORT &= ~CS_PIN;
    2892:	8e b1       	in	r24, 0x0e	; 14
    2894:	87 7f       	andi	r24, 0xF7	; 247
    2896:	8e b9       	out	0x0e, r24	; 14
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    2898:	fa e2       	ldi	r31, 0x2A	; 42
    289a:	fa 95       	dec	r31
    289c:	f1 f7       	brne	.-4      	; 0x289a <_ZN11TouchDriver9readTouchEc+0x1c>
    289e:	00 c0       	rjmp	.+0      	; 0x28a0 <_ZN11TouchDriver9readTouchEc+0x22>
    _delay_us(delayTime);
    uint8_t result = 0;
    
    // DIN byte and pulse DCLK for Read X
    for (int i = 7; i >= 0; i--)
    28a0:	27 e0       	ldi	r18, 0x07	; 7
    28a2:	30 e0       	ldi	r19, 0x00	; 0
    28a4:	33 23       	and	r19, r19
    28a6:	5c f1       	brlt	.+86     	; 0x28fe <_ZN11TouchDriver9readTouchEc+0x80>
    28a8:	8a e2       	ldi	r24, 0x2A	; 42
    28aa:	8a 95       	dec	r24
    28ac:	f1 f7       	brne	.-4      	; 0x28aa <_ZN11TouchDriver9readTouchEc+0x2c>
    28ae:	00 c0       	rjmp	.+0      	; 0x28b0 <_ZN11TouchDriver9readTouchEc+0x32>
    {
        _delay_us(delayTime);
        
        DIN_PORT |= (((dinByte >> i)  & 0x01) << 5);
    28b0:	64 b3       	in	r22, 0x14	; 20
    28b2:	87 2f       	mov	r24, r23
    28b4:	90 e0       	ldi	r25, 0x00	; 0
    28b6:	02 2e       	mov	r0, r18
    28b8:	02 c0       	rjmp	.+4      	; 0x28be <_ZN11TouchDriver9readTouchEc+0x40>
    28ba:	95 95       	asr	r25
    28bc:	87 95       	ror	r24
    28be:	0a 94       	dec	r0
    28c0:	e2 f7       	brpl	.-8      	; 0x28ba <_ZN11TouchDriver9readTouchEc+0x3c>
    28c2:	81 70       	andi	r24, 0x01	; 1
    28c4:	99 27       	eor	r25, r25
    28c6:	88 0f       	add	r24, r24
    28c8:	99 1f       	adc	r25, r25
    28ca:	82 95       	swap	r24
    28cc:	92 95       	swap	r25
    28ce:	90 7f       	andi	r25, 0xF0	; 240
    28d0:	98 27       	eor	r25, r24
    28d2:	80 7f       	andi	r24, 0xF0	; 240
    28d4:	98 27       	eor	r25, r24
    28d6:	86 2b       	or	r24, r22
    28d8:	84 bb       	out	0x14, r24	; 20
        
        //_delay_us(5);
        
        CLK_PORT |= CLK_PIN;
    28da:	e2 e0       	ldi	r30, 0x02	; 2
    28dc:	f1 e0       	ldi	r31, 0x01	; 1
    28de:	80 81       	ld	r24, Z
    28e0:	88 60       	ori	r24, 0x08	; 8
    28e2:	80 83       	st	Z, r24
    28e4:	9a e2       	ldi	r25, 0x2A	; 42
    28e6:	9a 95       	dec	r25
    28e8:	f1 f7       	brne	.-4      	; 0x28e6 <_ZN11TouchDriver9readTouchEc+0x68>
    28ea:	00 c0       	rjmp	.+0      	; 0x28ec <_ZN11TouchDriver9readTouchEc+0x6e>
        //_NOP();
        _delay_us(delayTime);
        
        
        CLK_PORT &= ~CLK_PIN;
    28ec:	80 81       	ld	r24, Z
    28ee:	87 7f       	andi	r24, 0xF7	; 247
    28f0:	80 83       	st	Z, r24
        DIN_PORT &= ~BIT6_SHIFTED;
    28f2:	84 b3       	in	r24, 0x14	; 20
    28f4:	8f 7d       	andi	r24, 0xDF	; 223
    28f6:	84 bb       	out	0x14, r24	; 20
    CS_PORT &= ~CS_PIN;
    _delay_us(delayTime);
    uint8_t result = 0;
    
    // DIN byte and pulse DCLK for Read X
    for (int i = 7; i >= 0; i--)
    28f8:	21 50       	subi	r18, 0x01	; 1
    28fa:	31 09       	sbc	r19, r1
    28fc:	d3 cf       	rjmp	.-90     	; 0x28a4 <_ZN11TouchDriver9readTouchEc+0x26>
    28fe:	27 e0       	ldi	r18, 0x07	; 7
    2900:	30 e0       	ldi	r19, 0x00	; 0
    2902:	80 e0       	ldi	r24, 0x00	; 0
    
    //_delay_us(delayTime*2);
        
    // Systematically read DOUT
    
    for (int i = 7; i >= 0; i--)
    2904:	33 23       	and	r19, r19
    2906:	24 f1       	brlt	.+72     	; 0x2950 <_ZN11TouchDriver9readTouchEc+0xd2>
    2908:	ea e2       	ldi	r30, 0x2A	; 42
    290a:	ea 95       	dec	r30
    290c:	f1 f7       	brne	.-4      	; 0x290a <_ZN11TouchDriver9readTouchEc+0x8c>
    290e:	00 c0       	rjmp	.+0      	; 0x2910 <_ZN11TouchDriver9readTouchEc+0x92>
    {
        _delay_us(delayTime);
        
        CLK_PORT |= CLK_PIN;
    2910:	e2 e0       	ldi	r30, 0x02	; 2
    2912:	f1 e0       	ldi	r31, 0x01	; 1
    2914:	90 81       	ld	r25, Z
    2916:	98 60       	ori	r25, 0x08	; 8
    2918:	90 83       	st	Z, r25
    291a:	9a e2       	ldi	r25, 0x2A	; 42
    291c:	9a 95       	dec	r25
    291e:	f1 f7       	brne	.-4      	; 0x291c <_ZN11TouchDriver9readTouchEc+0x9e>
    2920:	00 c0       	rjmp	.+0      	; 0x2922 <_ZN11TouchDriver9readTouchEc+0xa4>
        _delay_us(delayTime);
        //_NOP();
        CLK_PORT &= ~CLK_PIN;
    2922:	90 81       	ld	r25, Z
    2924:	97 7f       	andi	r25, 0xF7	; 247
    2926:	90 83       	st	Z, r25
    2928:	e5 e0       	ldi	r30, 0x05	; 5
    292a:	ea 95       	dec	r30
    292c:	f1 f7       	brne	.-4      	; 0x292a <_ZN11TouchDriver9readTouchEc+0xac>
    292e:	00 00       	nop
        _delay_us(1);
        
        bool temp = (PINE & (1U << 5));
    2930:	9c b1       	in	r25, 0x0c	; 12
        
        // Check this
        result |= (temp << i);
    2932:	95 fb       	bst	r25, 5
    2934:	44 27       	eor	r20, r20
    2936:	40 f9       	bld	r20, 0
    2938:	50 e0       	ldi	r21, 0x00	; 0
    293a:	ba 01       	movw	r22, r20
    293c:	02 2e       	mov	r0, r18
    293e:	02 c0       	rjmp	.+4      	; 0x2944 <_ZN11TouchDriver9readTouchEc+0xc6>
    2940:	66 0f       	add	r22, r22
    2942:	77 1f       	adc	r23, r23
    2944:	0a 94       	dec	r0
    2946:	e2 f7       	brpl	.-8      	; 0x2940 <_ZN11TouchDriver9readTouchEc+0xc2>
    2948:	86 2b       	or	r24, r22
    
    //_delay_us(delayTime*2);
        
    // Systematically read DOUT
    
    for (int i = 7; i >= 0; i--)
    294a:	21 50       	subi	r18, 0x01	; 1
    294c:	31 09       	sbc	r19, r1
    294e:	da cf       	rjmp	.-76     	; 0x2904 <_ZN11TouchDriver9readTouchEc+0x86>
    2950:	27 e0       	ldi	r18, 0x07	; 7
    2952:	30 e0       	ldi	r19, 0x00	; 0
        
        // Check this
        result |= (temp << i);
    }
    
    for (int i = 7; i >= 0; i--)
    2954:	33 23       	and	r19, r19
    2956:	9c f0       	brlt	.+38     	; 0x297e <_ZN11TouchDriver9readTouchEc+0x100>
    2958:	fa e2       	ldi	r31, 0x2A	; 42
    295a:	fa 95       	dec	r31
    295c:	f1 f7       	brne	.-4      	; 0x295a <_ZN11TouchDriver9readTouchEc+0xdc>
    295e:	00 c0       	rjmp	.+0      	; 0x2960 <_ZN11TouchDriver9readTouchEc+0xe2>
    {
        
        _delay_us(delayTime);
        CLK_PORT |= CLK_PIN;
    2960:	e2 e0       	ldi	r30, 0x02	; 2
    2962:	f1 e0       	ldi	r31, 0x01	; 1
    2964:	90 81       	ld	r25, Z
    2966:	98 60       	ori	r25, 0x08	; 8
    2968:	90 83       	st	Z, r25
    296a:	9a e2       	ldi	r25, 0x2A	; 42
    296c:	9a 95       	dec	r25
    296e:	f1 f7       	brne	.-4      	; 0x296c <_ZN11TouchDriver9readTouchEc+0xee>
    2970:	00 c0       	rjmp	.+0      	; 0x2972 <_ZN11TouchDriver9readTouchEc+0xf4>
        _delay_us(delayTime);
        //_NOP();
        CLK_PORT &= ~CLK_PIN;
    2972:	90 81       	ld	r25, Z
    2974:	97 7f       	andi	r25, 0xF7	; 247
    2976:	90 83       	st	Z, r25
        
        // Check this
        result |= (temp << i);
    }
    
    for (int i = 7; i >= 0; i--)
    2978:	21 50       	subi	r18, 0x01	; 1
    297a:	31 09       	sbc	r19, r1
    297c:	eb cf       	rjmp	.-42     	; 0x2954 <_ZN11TouchDriver9readTouchEc+0xd6>
        //_NOP();
        CLK_PORT &= ~CLK_PIN;
        // Check this
    }
    
    CS_PORT |= CS_PIN;
    297e:	9e b1       	in	r25, 0x0e	; 14
    2980:	98 60       	ori	r25, 0x08	; 8
    2982:	9e b9       	out	0x0e, r25	; 14
    
    //eIntHappend = 255;
    
    return ~result;
    2984:	80 95       	com	r24
    2986:	08 95       	ret
    }else if (coord == 'Y')
    {
        dinByte = dinYByte;
    }
    else{
        return 255;
    2988:	8f ef       	ldi	r24, 0xFF	; 255
    CS_PORT |= CS_PIN;
    
    //eIntHappend = 255;
    
    return ~result;
    298a:	08 95       	ret

0000298c <_ZN11TouchDriver14getCoordinatesEPhS0_>:
{
	eIntHappend = 0;
}

void TouchDriver::getCoordinates(uint8_t *x_ptr, uint8_t *y_ptr)
{	
    298c:	ef 92       	push	r14
    298e:	ff 92       	push	r15
    2990:	0f 93       	push	r16
    2992:	1f 93       	push	r17
    2994:	cf 93       	push	r28
    2996:	df 93       	push	r29
    2998:	ec 01       	movw	r28, r24
    299a:	7b 01       	movw	r14, r22
    299c:	8a 01       	movw	r16, r20
	while(eIntHappend != 0);
    299e:	80 91 0d 02 	lds	r24, 0x020D	; 0x80020d <eIntHappend>
    29a2:	81 11       	cpse	r24, r1
    29a4:	fc cf       	rjmp	.-8      	; 0x299e <_ZN11TouchDriver14getCoordinatesEPhS0_+0x12>
	
	//taskENTER_CRITICAL();
	*x_ptr = readTouch('X');
    29a6:	68 e5       	ldi	r22, 0x58	; 88
    29a8:	ce 01       	movw	r24, r28
    29aa:	69 df       	rcall	.-302    	; 0x287e <_ZN11TouchDriver9readTouchEc>
    29ac:	f7 01       	movw	r30, r14
    29ae:	80 83       	st	Z, r24
	*y_ptr = readTouch('Y');
    29b0:	69 e5       	ldi	r22, 0x59	; 89
    29b2:	ce 01       	movw	r24, r28
    29b4:	64 df       	rcall	.-312    	; 0x287e <_ZN11TouchDriver9readTouchEc>
    29b6:	f8 01       	movw	r30, r16
    29b8:	80 83       	st	Z, r24
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    29ba:	ff ef       	ldi	r31, 0xFF	; 255
    29bc:	20 e7       	ldi	r18, 0x70	; 112
    29be:	82 e0       	ldi	r24, 0x02	; 2
    29c0:	f1 50       	subi	r31, 0x01	; 1
    29c2:	20 40       	sbci	r18, 0x00	; 0
    29c4:	80 40       	sbci	r24, 0x00	; 0
    29c6:	e1 f7       	brne	.-8      	; 0x29c0 <_ZN11TouchDriver14getCoordinatesEPhS0_+0x34>
    29c8:	00 c0       	rjmp	.+0      	; 0x29ca <_ZN11TouchDriver14getCoordinatesEPhS0_+0x3e>
    29ca:	00 00       	nop
	//taskEXIT_CRITICAL();
	_delay_ms( 50 );
	eIntHappend = 255;
    29cc:	8f ef       	ldi	r24, 0xFF	; 255
    29ce:	80 93 0d 02 	sts	0x020D, r24	; 0x80020d <eIntHappend>
	
}
    29d2:	df 91       	pop	r29
    29d4:	cf 91       	pop	r28
    29d6:	1f 91       	pop	r17
    29d8:	0f 91       	pop	r16
    29da:	ff 90       	pop	r15
    29dc:	ef 90       	pop	r14
    29de:	08 95       	ret

000029e0 <_Z8InitUARTmhc>:
  // Wait for new character received
  while ( (UCSR0A & (1<<7)) == 0 )
  {}                        
  // Then return it
  return UDR0;
}
    29e0:	0f 93       	push	r16
    29e2:	1f 93       	push	r17
    29e4:	52 2f       	mov	r21, r18
    29e6:	8b 01       	movw	r16, r22
    29e8:	9c 01       	movw	r18, r24
    29ea:	0c 52       	subi	r16, 0x2C	; 44
    29ec:	11 40       	sbci	r17, 0x01	; 1
    29ee:	21 09       	sbc	r18, r1
    29f0:	31 09       	sbc	r19, r1
    29f2:	05 3d       	cpi	r16, 0xD5	; 213
    29f4:	10 4c       	sbci	r17, 0xC0	; 192
    29f6:	21 40       	sbci	r18, 0x01	; 1
    29f8:	31 05       	cpc	r19, r1
    29fa:	e0 f5       	brcc	.+120    	; 0x2a74 <_Z8InitUARTmhc+0x94>
    29fc:	45 30       	cpi	r20, 0x05	; 5
    29fe:	d0 f1       	brcs	.+116    	; 0x2a74 <_Z8InitUARTmhc+0x94>
    2a00:	49 30       	cpi	r20, 0x09	; 9
    2a02:	c0 f5       	brcc	.+112    	; 0x2a74 <_Z8InitUARTmhc+0x94>
    2a04:	20 e2       	ldi	r18, 0x20	; 32
    2a06:	20 93 c0 00 	sts	0x00C0, r18	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7000c0>
    2a0a:	28 e1       	ldi	r18, 0x18	; 24
    2a0c:	20 93 c1 00 	sts	0x00C1, r18	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7000c1>
    2a10:	45 50       	subi	r20, 0x05	; 5
    2a12:	44 0f       	add	r20, r20
    2a14:	40 93 c2 00 	sts	0x00C2, r20	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7000c2>
    2a18:	55 34       	cpi	r21, 0x45	; 69
    2a1a:	31 f4       	brne	.+12     	; 0x2a28 <_Z8InitUARTmhc+0x48>
    2a1c:	e2 ec       	ldi	r30, 0xC2	; 194
    2a1e:	f0 e0       	ldi	r31, 0x00	; 0
    2a20:	20 81       	ld	r18, Z
    2a22:	20 62       	ori	r18, 0x20	; 32
    2a24:	20 83       	st	Z, r18
    2a26:	07 c0       	rjmp	.+14     	; 0x2a36 <_Z8InitUARTmhc+0x56>
    2a28:	5f 34       	cpi	r21, 0x4F	; 79
    2a2a:	29 f4       	brne	.+10     	; 0x2a36 <_Z8InitUARTmhc+0x56>
    2a2c:	e2 ec       	ldi	r30, 0xC2	; 194
    2a2e:	f0 e0       	ldi	r31, 0x00	; 0
    2a30:	20 81       	ld	r18, Z
    2a32:	20 63       	ori	r18, 0x30	; 48
    2a34:	20 83       	st	Z, r18
    2a36:	dc 01       	movw	r26, r24
    2a38:	cb 01       	movw	r24, r22
    2a3a:	88 0f       	add	r24, r24
    2a3c:	99 1f       	adc	r25, r25
    2a3e:	aa 1f       	adc	r26, r26
    2a40:	bb 1f       	adc	r27, r27
    2a42:	88 0f       	add	r24, r24
    2a44:	99 1f       	adc	r25, r25
    2a46:	aa 1f       	adc	r26, r26
    2a48:	bb 1f       	adc	r27, r27
    2a4a:	9c 01       	movw	r18, r24
    2a4c:	ad 01       	movw	r20, r26
    2a4e:	22 0f       	add	r18, r18
    2a50:	33 1f       	adc	r19, r19
    2a52:	44 1f       	adc	r20, r20
    2a54:	55 1f       	adc	r21, r21
    2a56:	22 0f       	add	r18, r18
    2a58:	33 1f       	adc	r19, r19
    2a5a:	44 1f       	adc	r20, r20
    2a5c:	55 1f       	adc	r21, r21
    2a5e:	60 e0       	ldi	r22, 0x00	; 0
    2a60:	74 e2       	ldi	r23, 0x24	; 36
    2a62:	84 ef       	ldi	r24, 0xF4	; 244
    2a64:	90 e0       	ldi	r25, 0x00	; 0
    2a66:	4d d2       	rcall	.+1178   	; 0x2f02 <__udivmodsi4>
    2a68:	21 50       	subi	r18, 0x01	; 1
    2a6a:	31 09       	sbc	r19, r1
    2a6c:	30 93 c5 00 	sts	0x00C5, r19	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7000c5>
    2a70:	20 93 c4 00 	sts	0x00C4, r18	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7000c4>
    2a74:	1f 91       	pop	r17
    2a76:	0f 91       	pop	r16
    2a78:	08 95       	ret

00002a7a <_Z8SendCharc>:
	Tegn : Character for sending. 
*************************************************************************/
void SendChar(char Tegn)
{
  // Wait for transmitter register empty (ready for new character)
  while ( (UCSR0A & (1<<5)) == 0 )
    2a7a:	90 91 c0 00 	lds	r25, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7000c0>
    2a7e:	95 ff       	sbrs	r25, 5
    2a80:	fc cf       	rjmp	.-8      	; 0x2a7a <_Z8SendCharc>
  {}
  // Then send the character
  UDR0 = Tegn;
    2a82:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7000c6>
    2a86:	08 95       	ret

00002a88 <_Z10SendStringPc>:
Sends 0 terminated string.
Parameter:
   Streng: Pointer to the string. 
*************************************************************************/
void SendString(char* Streng)
{
    2a88:	cf 93       	push	r28
    2a8a:	df 93       	push	r29
    2a8c:	ec 01       	movw	r28, r24
  // Repeat until zero-termination
  while (*Streng != 0)
    2a8e:	88 81       	ld	r24, Y
    2a90:	88 23       	and	r24, r24
    2a92:	19 f0       	breq	.+6      	; 0x2a9a <_Z10SendStringPc+0x12>
  {
    // Send the character pointed to by "Streng"
    SendChar(*Streng);
    2a94:	f2 df       	rcall	.-28     	; 0x2a7a <_Z8SendCharc>
    // Advance the pointer one step
    Streng++;
    2a96:	21 96       	adiw	r28, 0x01	; 1
   Streng: Pointer to the string. 
*************************************************************************/
void SendString(char* Streng)
{
  // Repeat until zero-termination
  while (*Streng != 0)
    2a98:	fa cf       	rjmp	.-12     	; 0x2a8e <_Z10SendStringPc+0x6>
    // Send the character pointed to by "Streng"
    SendChar(*Streng);
    // Advance the pointer one step
    Streng++;
  }
}
    2a9a:	df 91       	pop	r29
    2a9c:	cf 91       	pop	r28
    2a9e:	08 95       	ret

00002aa0 <_Z11SendIntegeri>:
Makes use of the C standard library <stdlib.h>.
Parameter:
    Tal: The integer to be converted and sent. 
*************************************************************************/
void SendInteger(int Tal)
{
    2aa0:	cf 93       	push	r28
    2aa2:	df 93       	push	r29
    2aa4:	cd b7       	in	r28, 0x3d	; 61
    2aa6:	de b7       	in	r29, 0x3e	; 62
    2aa8:	27 97       	sbiw	r28, 0x07	; 7
    2aaa:	0f b6       	in	r0, 0x3f	; 63
    2aac:	f8 94       	cli
    2aae:	de bf       	out	0x3e, r29	; 62
    2ab0:	0f be       	out	0x3f, r0	; 63
    2ab2:	cd bf       	out	0x3d, r28	; 61
    } else if (__radix < 2 || __radix > 36) {
	*__s = 0;
	return __s;
    } else {
	extern char *__itoa_ncheck (int, char *, unsigned char);
	return __itoa_ncheck (__val, __s, __radix);
    2ab4:	4a e0       	ldi	r20, 0x0A	; 10
    2ab6:	be 01       	movw	r22, r28
    2ab8:	6f 5f       	subi	r22, 0xFF	; 255
    2aba:	7f 4f       	sbci	r23, 0xFF	; 255
    2abc:	92 d3       	rcall	.+1828   	; 0x31e2 <__itoa_ncheck>
char array[7];
  // Convert the integer to an ASCII string (array), radix = 10 
  itoa(Tal, array, 10);
  // - then send the string
  SendString(array);
    2abe:	ce 01       	movw	r24, r28
    2ac0:	01 96       	adiw	r24, 0x01	; 1
    2ac2:	e2 df       	rcall	.-60     	; 0x2a88 <_Z10SendStringPc>
}
    2ac4:	27 96       	adiw	r28, 0x07	; 7
    2ac6:	0f b6       	in	r0, 0x3f	; 63
    2ac8:	f8 94       	cli
    2aca:	de bf       	out	0x3e, r29	; 62
    2acc:	0f be       	out	0x3f, r0	; 63
    2ace:	cd bf       	out	0x3d, r28	; 61
    2ad0:	df 91       	pop	r29
    2ad2:	cf 91       	pop	r28
    2ad4:	08 95       	ret

00002ad6 <__subsf3>:
    2ad6:	50 58       	subi	r21, 0x80	; 128

00002ad8 <__addsf3>:
    2ad8:	bb 27       	eor	r27, r27
    2ada:	aa 27       	eor	r26, r26
    2adc:	0e d0       	rcall	.+28     	; 0x2afa <__addsf3x>
    2ade:	70 c1       	rjmp	.+736    	; 0x2dc0 <__fp_round>
    2ae0:	61 d1       	rcall	.+706    	; 0x2da4 <__fp_pscA>
    2ae2:	30 f0       	brcs	.+12     	; 0x2af0 <__addsf3+0x18>
    2ae4:	66 d1       	rcall	.+716    	; 0x2db2 <__fp_pscB>
    2ae6:	20 f0       	brcs	.+8      	; 0x2af0 <__addsf3+0x18>
    2ae8:	31 f4       	brne	.+12     	; 0x2af6 <__addsf3+0x1e>
    2aea:	9f 3f       	cpi	r25, 0xFF	; 255
    2aec:	11 f4       	brne	.+4      	; 0x2af2 <__addsf3+0x1a>
    2aee:	1e f4       	brtc	.+6      	; 0x2af6 <__addsf3+0x1e>
    2af0:	56 c1       	rjmp	.+684    	; 0x2d9e <__fp_nan>
    2af2:	0e f4       	brtc	.+2      	; 0x2af6 <__addsf3+0x1e>
    2af4:	e0 95       	com	r30
    2af6:	e7 fb       	bst	r30, 7
    2af8:	4c c1       	rjmp	.+664    	; 0x2d92 <__fp_inf>

00002afa <__addsf3x>:
    2afa:	e9 2f       	mov	r30, r25
    2afc:	72 d1       	rcall	.+740    	; 0x2de2 <__fp_split3>
    2afe:	80 f3       	brcs	.-32     	; 0x2ae0 <__addsf3+0x8>
    2b00:	ba 17       	cp	r27, r26
    2b02:	62 07       	cpc	r22, r18
    2b04:	73 07       	cpc	r23, r19
    2b06:	84 07       	cpc	r24, r20
    2b08:	95 07       	cpc	r25, r21
    2b0a:	18 f0       	brcs	.+6      	; 0x2b12 <__addsf3x+0x18>
    2b0c:	71 f4       	brne	.+28     	; 0x2b2a <__addsf3x+0x30>
    2b0e:	9e f5       	brtc	.+102    	; 0x2b76 <__addsf3x+0x7c>
    2b10:	8a c1       	rjmp	.+788    	; 0x2e26 <__fp_zero>
    2b12:	0e f4       	brtc	.+2      	; 0x2b16 <__addsf3x+0x1c>
    2b14:	e0 95       	com	r30
    2b16:	0b 2e       	mov	r0, r27
    2b18:	ba 2f       	mov	r27, r26
    2b1a:	a0 2d       	mov	r26, r0
    2b1c:	0b 01       	movw	r0, r22
    2b1e:	b9 01       	movw	r22, r18
    2b20:	90 01       	movw	r18, r0
    2b22:	0c 01       	movw	r0, r24
    2b24:	ca 01       	movw	r24, r20
    2b26:	a0 01       	movw	r20, r0
    2b28:	11 24       	eor	r1, r1
    2b2a:	ff 27       	eor	r31, r31
    2b2c:	59 1b       	sub	r21, r25
    2b2e:	99 f0       	breq	.+38     	; 0x2b56 <__addsf3x+0x5c>
    2b30:	59 3f       	cpi	r21, 0xF9	; 249
    2b32:	50 f4       	brcc	.+20     	; 0x2b48 <__addsf3x+0x4e>
    2b34:	50 3e       	cpi	r21, 0xE0	; 224
    2b36:	68 f1       	brcs	.+90     	; 0x2b92 <__addsf3x+0x98>
    2b38:	1a 16       	cp	r1, r26
    2b3a:	f0 40       	sbci	r31, 0x00	; 0
    2b3c:	a2 2f       	mov	r26, r18
    2b3e:	23 2f       	mov	r18, r19
    2b40:	34 2f       	mov	r19, r20
    2b42:	44 27       	eor	r20, r20
    2b44:	58 5f       	subi	r21, 0xF8	; 248
    2b46:	f3 cf       	rjmp	.-26     	; 0x2b2e <__addsf3x+0x34>
    2b48:	46 95       	lsr	r20
    2b4a:	37 95       	ror	r19
    2b4c:	27 95       	ror	r18
    2b4e:	a7 95       	ror	r26
    2b50:	f0 40       	sbci	r31, 0x00	; 0
    2b52:	53 95       	inc	r21
    2b54:	c9 f7       	brne	.-14     	; 0x2b48 <__addsf3x+0x4e>
    2b56:	7e f4       	brtc	.+30     	; 0x2b76 <__addsf3x+0x7c>
    2b58:	1f 16       	cp	r1, r31
    2b5a:	ba 0b       	sbc	r27, r26
    2b5c:	62 0b       	sbc	r22, r18
    2b5e:	73 0b       	sbc	r23, r19
    2b60:	84 0b       	sbc	r24, r20
    2b62:	ba f0       	brmi	.+46     	; 0x2b92 <__addsf3x+0x98>
    2b64:	91 50       	subi	r25, 0x01	; 1
    2b66:	a1 f0       	breq	.+40     	; 0x2b90 <__addsf3x+0x96>
    2b68:	ff 0f       	add	r31, r31
    2b6a:	bb 1f       	adc	r27, r27
    2b6c:	66 1f       	adc	r22, r22
    2b6e:	77 1f       	adc	r23, r23
    2b70:	88 1f       	adc	r24, r24
    2b72:	c2 f7       	brpl	.-16     	; 0x2b64 <__addsf3x+0x6a>
    2b74:	0e c0       	rjmp	.+28     	; 0x2b92 <__addsf3x+0x98>
    2b76:	ba 0f       	add	r27, r26
    2b78:	62 1f       	adc	r22, r18
    2b7a:	73 1f       	adc	r23, r19
    2b7c:	84 1f       	adc	r24, r20
    2b7e:	48 f4       	brcc	.+18     	; 0x2b92 <__addsf3x+0x98>
    2b80:	87 95       	ror	r24
    2b82:	77 95       	ror	r23
    2b84:	67 95       	ror	r22
    2b86:	b7 95       	ror	r27
    2b88:	f7 95       	ror	r31
    2b8a:	9e 3f       	cpi	r25, 0xFE	; 254
    2b8c:	08 f0       	brcs	.+2      	; 0x2b90 <__addsf3x+0x96>
    2b8e:	b3 cf       	rjmp	.-154    	; 0x2af6 <__addsf3+0x1e>
    2b90:	93 95       	inc	r25
    2b92:	88 0f       	add	r24, r24
    2b94:	08 f0       	brcs	.+2      	; 0x2b98 <__addsf3x+0x9e>
    2b96:	99 27       	eor	r25, r25
    2b98:	ee 0f       	add	r30, r30
    2b9a:	97 95       	ror	r25
    2b9c:	87 95       	ror	r24
    2b9e:	08 95       	ret

00002ba0 <__cmpsf2>:
    2ba0:	d4 d0       	rcall	.+424    	; 0x2d4a <__fp_cmp>
    2ba2:	08 f4       	brcc	.+2      	; 0x2ba6 <__cmpsf2+0x6>
    2ba4:	81 e0       	ldi	r24, 0x01	; 1
    2ba6:	08 95       	ret

00002ba8 <__divsf3>:
    2ba8:	0c d0       	rcall	.+24     	; 0x2bc2 <__divsf3x>
    2baa:	0a c1       	rjmp	.+532    	; 0x2dc0 <__fp_round>
    2bac:	02 d1       	rcall	.+516    	; 0x2db2 <__fp_pscB>
    2bae:	40 f0       	brcs	.+16     	; 0x2bc0 <__divsf3+0x18>
    2bb0:	f9 d0       	rcall	.+498    	; 0x2da4 <__fp_pscA>
    2bb2:	30 f0       	brcs	.+12     	; 0x2bc0 <__divsf3+0x18>
    2bb4:	21 f4       	brne	.+8      	; 0x2bbe <__divsf3+0x16>
    2bb6:	5f 3f       	cpi	r21, 0xFF	; 255
    2bb8:	19 f0       	breq	.+6      	; 0x2bc0 <__divsf3+0x18>
    2bba:	eb c0       	rjmp	.+470    	; 0x2d92 <__fp_inf>
    2bbc:	51 11       	cpse	r21, r1
    2bbe:	34 c1       	rjmp	.+616    	; 0x2e28 <__fp_szero>
    2bc0:	ee c0       	rjmp	.+476    	; 0x2d9e <__fp_nan>

00002bc2 <__divsf3x>:
    2bc2:	0f d1       	rcall	.+542    	; 0x2de2 <__fp_split3>
    2bc4:	98 f3       	brcs	.-26     	; 0x2bac <__divsf3+0x4>

00002bc6 <__divsf3_pse>:
    2bc6:	99 23       	and	r25, r25
    2bc8:	c9 f3       	breq	.-14     	; 0x2bbc <__divsf3+0x14>
    2bca:	55 23       	and	r21, r21
    2bcc:	b1 f3       	breq	.-20     	; 0x2bba <__divsf3+0x12>
    2bce:	95 1b       	sub	r25, r21
    2bd0:	55 0b       	sbc	r21, r21
    2bd2:	bb 27       	eor	r27, r27
    2bd4:	aa 27       	eor	r26, r26
    2bd6:	62 17       	cp	r22, r18
    2bd8:	73 07       	cpc	r23, r19
    2bda:	84 07       	cpc	r24, r20
    2bdc:	38 f0       	brcs	.+14     	; 0x2bec <__divsf3_pse+0x26>
    2bde:	9f 5f       	subi	r25, 0xFF	; 255
    2be0:	5f 4f       	sbci	r21, 0xFF	; 255
    2be2:	22 0f       	add	r18, r18
    2be4:	33 1f       	adc	r19, r19
    2be6:	44 1f       	adc	r20, r20
    2be8:	aa 1f       	adc	r26, r26
    2bea:	a9 f3       	breq	.-22     	; 0x2bd6 <__divsf3_pse+0x10>
    2bec:	33 d0       	rcall	.+102    	; 0x2c54 <__divsf3_pse+0x8e>
    2bee:	0e 2e       	mov	r0, r30
    2bf0:	3a f0       	brmi	.+14     	; 0x2c00 <__divsf3_pse+0x3a>
    2bf2:	e0 e8       	ldi	r30, 0x80	; 128
    2bf4:	30 d0       	rcall	.+96     	; 0x2c56 <__divsf3_pse+0x90>
    2bf6:	91 50       	subi	r25, 0x01	; 1
    2bf8:	50 40       	sbci	r21, 0x00	; 0
    2bfa:	e6 95       	lsr	r30
    2bfc:	00 1c       	adc	r0, r0
    2bfe:	ca f7       	brpl	.-14     	; 0x2bf2 <__divsf3_pse+0x2c>
    2c00:	29 d0       	rcall	.+82     	; 0x2c54 <__divsf3_pse+0x8e>
    2c02:	fe 2f       	mov	r31, r30
    2c04:	27 d0       	rcall	.+78     	; 0x2c54 <__divsf3_pse+0x8e>
    2c06:	66 0f       	add	r22, r22
    2c08:	77 1f       	adc	r23, r23
    2c0a:	88 1f       	adc	r24, r24
    2c0c:	bb 1f       	adc	r27, r27
    2c0e:	26 17       	cp	r18, r22
    2c10:	37 07       	cpc	r19, r23
    2c12:	48 07       	cpc	r20, r24
    2c14:	ab 07       	cpc	r26, r27
    2c16:	b0 e8       	ldi	r27, 0x80	; 128
    2c18:	09 f0       	breq	.+2      	; 0x2c1c <__divsf3_pse+0x56>
    2c1a:	bb 0b       	sbc	r27, r27
    2c1c:	80 2d       	mov	r24, r0
    2c1e:	bf 01       	movw	r22, r30
    2c20:	ff 27       	eor	r31, r31
    2c22:	93 58       	subi	r25, 0x83	; 131
    2c24:	5f 4f       	sbci	r21, 0xFF	; 255
    2c26:	2a f0       	brmi	.+10     	; 0x2c32 <__divsf3_pse+0x6c>
    2c28:	9e 3f       	cpi	r25, 0xFE	; 254
    2c2a:	51 05       	cpc	r21, r1
    2c2c:	68 f0       	brcs	.+26     	; 0x2c48 <__divsf3_pse+0x82>
    2c2e:	b1 c0       	rjmp	.+354    	; 0x2d92 <__fp_inf>
    2c30:	fb c0       	rjmp	.+502    	; 0x2e28 <__fp_szero>
    2c32:	5f 3f       	cpi	r21, 0xFF	; 255
    2c34:	ec f3       	brlt	.-6      	; 0x2c30 <__divsf3_pse+0x6a>
    2c36:	98 3e       	cpi	r25, 0xE8	; 232
    2c38:	dc f3       	brlt	.-10     	; 0x2c30 <__divsf3_pse+0x6a>
    2c3a:	86 95       	lsr	r24
    2c3c:	77 95       	ror	r23
    2c3e:	67 95       	ror	r22
    2c40:	b7 95       	ror	r27
    2c42:	f7 95       	ror	r31
    2c44:	9f 5f       	subi	r25, 0xFF	; 255
    2c46:	c9 f7       	brne	.-14     	; 0x2c3a <__divsf3_pse+0x74>
    2c48:	88 0f       	add	r24, r24
    2c4a:	91 1d       	adc	r25, r1
    2c4c:	96 95       	lsr	r25
    2c4e:	87 95       	ror	r24
    2c50:	97 f9       	bld	r25, 7
    2c52:	08 95       	ret
    2c54:	e1 e0       	ldi	r30, 0x01	; 1
    2c56:	66 0f       	add	r22, r22
    2c58:	77 1f       	adc	r23, r23
    2c5a:	88 1f       	adc	r24, r24
    2c5c:	bb 1f       	adc	r27, r27
    2c5e:	62 17       	cp	r22, r18
    2c60:	73 07       	cpc	r23, r19
    2c62:	84 07       	cpc	r24, r20
    2c64:	ba 07       	cpc	r27, r26
    2c66:	20 f0       	brcs	.+8      	; 0x2c70 <__divsf3_pse+0xaa>
    2c68:	62 1b       	sub	r22, r18
    2c6a:	73 0b       	sbc	r23, r19
    2c6c:	84 0b       	sbc	r24, r20
    2c6e:	ba 0b       	sbc	r27, r26
    2c70:	ee 1f       	adc	r30, r30
    2c72:	88 f7       	brcc	.-30     	; 0x2c56 <__divsf3_pse+0x90>
    2c74:	e0 95       	com	r30
    2c76:	08 95       	ret

00002c78 <__fixunssfsi>:
    2c78:	bc d0       	rcall	.+376    	; 0x2df2 <__fp_splitA>
    2c7a:	88 f0       	brcs	.+34     	; 0x2c9e <__fixunssfsi+0x26>
    2c7c:	9f 57       	subi	r25, 0x7F	; 127
    2c7e:	90 f0       	brcs	.+36     	; 0x2ca4 <__fixunssfsi+0x2c>
    2c80:	b9 2f       	mov	r27, r25
    2c82:	99 27       	eor	r25, r25
    2c84:	b7 51       	subi	r27, 0x17	; 23
    2c86:	a0 f0       	brcs	.+40     	; 0x2cb0 <__fixunssfsi+0x38>
    2c88:	d1 f0       	breq	.+52     	; 0x2cbe <__fixunssfsi+0x46>
    2c8a:	66 0f       	add	r22, r22
    2c8c:	77 1f       	adc	r23, r23
    2c8e:	88 1f       	adc	r24, r24
    2c90:	99 1f       	adc	r25, r25
    2c92:	1a f0       	brmi	.+6      	; 0x2c9a <__fixunssfsi+0x22>
    2c94:	ba 95       	dec	r27
    2c96:	c9 f7       	brne	.-14     	; 0x2c8a <__fixunssfsi+0x12>
    2c98:	12 c0       	rjmp	.+36     	; 0x2cbe <__fixunssfsi+0x46>
    2c9a:	b1 30       	cpi	r27, 0x01	; 1
    2c9c:	81 f0       	breq	.+32     	; 0x2cbe <__fixunssfsi+0x46>
    2c9e:	c3 d0       	rcall	.+390    	; 0x2e26 <__fp_zero>
    2ca0:	b1 e0       	ldi	r27, 0x01	; 1
    2ca2:	08 95       	ret
    2ca4:	c0 c0       	rjmp	.+384    	; 0x2e26 <__fp_zero>
    2ca6:	67 2f       	mov	r22, r23
    2ca8:	78 2f       	mov	r23, r24
    2caa:	88 27       	eor	r24, r24
    2cac:	b8 5f       	subi	r27, 0xF8	; 248
    2cae:	39 f0       	breq	.+14     	; 0x2cbe <__fixunssfsi+0x46>
    2cb0:	b9 3f       	cpi	r27, 0xF9	; 249
    2cb2:	cc f3       	brlt	.-14     	; 0x2ca6 <__fixunssfsi+0x2e>
    2cb4:	86 95       	lsr	r24
    2cb6:	77 95       	ror	r23
    2cb8:	67 95       	ror	r22
    2cba:	b3 95       	inc	r27
    2cbc:	d9 f7       	brne	.-10     	; 0x2cb4 <__fixunssfsi+0x3c>
    2cbe:	3e f4       	brtc	.+14     	; 0x2cce <__fixunssfsi+0x56>
    2cc0:	90 95       	com	r25
    2cc2:	80 95       	com	r24
    2cc4:	70 95       	com	r23
    2cc6:	61 95       	neg	r22
    2cc8:	7f 4f       	sbci	r23, 0xFF	; 255
    2cca:	8f 4f       	sbci	r24, 0xFF	; 255
    2ccc:	9f 4f       	sbci	r25, 0xFF	; 255
    2cce:	08 95       	ret

00002cd0 <__floatunsisf>:
    2cd0:	e8 94       	clt
    2cd2:	09 c0       	rjmp	.+18     	; 0x2ce6 <__floatsisf+0x12>

00002cd4 <__floatsisf>:
    2cd4:	97 fb       	bst	r25, 7
    2cd6:	3e f4       	brtc	.+14     	; 0x2ce6 <__floatsisf+0x12>
    2cd8:	90 95       	com	r25
    2cda:	80 95       	com	r24
    2cdc:	70 95       	com	r23
    2cde:	61 95       	neg	r22
    2ce0:	7f 4f       	sbci	r23, 0xFF	; 255
    2ce2:	8f 4f       	sbci	r24, 0xFF	; 255
    2ce4:	9f 4f       	sbci	r25, 0xFF	; 255
    2ce6:	99 23       	and	r25, r25
    2ce8:	a9 f0       	breq	.+42     	; 0x2d14 <__floatsisf+0x40>
    2cea:	f9 2f       	mov	r31, r25
    2cec:	96 e9       	ldi	r25, 0x96	; 150
    2cee:	bb 27       	eor	r27, r27
    2cf0:	93 95       	inc	r25
    2cf2:	f6 95       	lsr	r31
    2cf4:	87 95       	ror	r24
    2cf6:	77 95       	ror	r23
    2cf8:	67 95       	ror	r22
    2cfa:	b7 95       	ror	r27
    2cfc:	f1 11       	cpse	r31, r1
    2cfe:	f8 cf       	rjmp	.-16     	; 0x2cf0 <__floatsisf+0x1c>
    2d00:	fa f4       	brpl	.+62     	; 0x2d40 <__floatsisf+0x6c>
    2d02:	bb 0f       	add	r27, r27
    2d04:	11 f4       	brne	.+4      	; 0x2d0a <__floatsisf+0x36>
    2d06:	60 ff       	sbrs	r22, 0
    2d08:	1b c0       	rjmp	.+54     	; 0x2d40 <__floatsisf+0x6c>
    2d0a:	6f 5f       	subi	r22, 0xFF	; 255
    2d0c:	7f 4f       	sbci	r23, 0xFF	; 255
    2d0e:	8f 4f       	sbci	r24, 0xFF	; 255
    2d10:	9f 4f       	sbci	r25, 0xFF	; 255
    2d12:	16 c0       	rjmp	.+44     	; 0x2d40 <__floatsisf+0x6c>
    2d14:	88 23       	and	r24, r24
    2d16:	11 f0       	breq	.+4      	; 0x2d1c <__floatsisf+0x48>
    2d18:	96 e9       	ldi	r25, 0x96	; 150
    2d1a:	11 c0       	rjmp	.+34     	; 0x2d3e <__floatsisf+0x6a>
    2d1c:	77 23       	and	r23, r23
    2d1e:	21 f0       	breq	.+8      	; 0x2d28 <__floatsisf+0x54>
    2d20:	9e e8       	ldi	r25, 0x8E	; 142
    2d22:	87 2f       	mov	r24, r23
    2d24:	76 2f       	mov	r23, r22
    2d26:	05 c0       	rjmp	.+10     	; 0x2d32 <__floatsisf+0x5e>
    2d28:	66 23       	and	r22, r22
    2d2a:	71 f0       	breq	.+28     	; 0x2d48 <__floatsisf+0x74>
    2d2c:	96 e8       	ldi	r25, 0x86	; 134
    2d2e:	86 2f       	mov	r24, r22
    2d30:	70 e0       	ldi	r23, 0x00	; 0
    2d32:	60 e0       	ldi	r22, 0x00	; 0
    2d34:	2a f0       	brmi	.+10     	; 0x2d40 <__floatsisf+0x6c>
    2d36:	9a 95       	dec	r25
    2d38:	66 0f       	add	r22, r22
    2d3a:	77 1f       	adc	r23, r23
    2d3c:	88 1f       	adc	r24, r24
    2d3e:	da f7       	brpl	.-10     	; 0x2d36 <__floatsisf+0x62>
    2d40:	88 0f       	add	r24, r24
    2d42:	96 95       	lsr	r25
    2d44:	87 95       	ror	r24
    2d46:	97 f9       	bld	r25, 7
    2d48:	08 95       	ret

00002d4a <__fp_cmp>:
    2d4a:	99 0f       	add	r25, r25
    2d4c:	00 08       	sbc	r0, r0
    2d4e:	55 0f       	add	r21, r21
    2d50:	aa 0b       	sbc	r26, r26
    2d52:	e0 e8       	ldi	r30, 0x80	; 128
    2d54:	fe ef       	ldi	r31, 0xFE	; 254
    2d56:	16 16       	cp	r1, r22
    2d58:	17 06       	cpc	r1, r23
    2d5a:	e8 07       	cpc	r30, r24
    2d5c:	f9 07       	cpc	r31, r25
    2d5e:	c0 f0       	brcs	.+48     	; 0x2d90 <__fp_cmp+0x46>
    2d60:	12 16       	cp	r1, r18
    2d62:	13 06       	cpc	r1, r19
    2d64:	e4 07       	cpc	r30, r20
    2d66:	f5 07       	cpc	r31, r21
    2d68:	98 f0       	brcs	.+38     	; 0x2d90 <__fp_cmp+0x46>
    2d6a:	62 1b       	sub	r22, r18
    2d6c:	73 0b       	sbc	r23, r19
    2d6e:	84 0b       	sbc	r24, r20
    2d70:	95 0b       	sbc	r25, r21
    2d72:	39 f4       	brne	.+14     	; 0x2d82 <__fp_cmp+0x38>
    2d74:	0a 26       	eor	r0, r26
    2d76:	61 f0       	breq	.+24     	; 0x2d90 <__fp_cmp+0x46>
    2d78:	23 2b       	or	r18, r19
    2d7a:	24 2b       	or	r18, r20
    2d7c:	25 2b       	or	r18, r21
    2d7e:	21 f4       	brne	.+8      	; 0x2d88 <__fp_cmp+0x3e>
    2d80:	08 95       	ret
    2d82:	0a 26       	eor	r0, r26
    2d84:	09 f4       	brne	.+2      	; 0x2d88 <__fp_cmp+0x3e>
    2d86:	a1 40       	sbci	r26, 0x01	; 1
    2d88:	a6 95       	lsr	r26
    2d8a:	8f ef       	ldi	r24, 0xFF	; 255
    2d8c:	81 1d       	adc	r24, r1
    2d8e:	81 1d       	adc	r24, r1
    2d90:	08 95       	ret

00002d92 <__fp_inf>:
    2d92:	97 f9       	bld	r25, 7
    2d94:	9f 67       	ori	r25, 0x7F	; 127
    2d96:	80 e8       	ldi	r24, 0x80	; 128
    2d98:	70 e0       	ldi	r23, 0x00	; 0
    2d9a:	60 e0       	ldi	r22, 0x00	; 0
    2d9c:	08 95       	ret

00002d9e <__fp_nan>:
    2d9e:	9f ef       	ldi	r25, 0xFF	; 255
    2da0:	80 ec       	ldi	r24, 0xC0	; 192
    2da2:	08 95       	ret

00002da4 <__fp_pscA>:
    2da4:	00 24       	eor	r0, r0
    2da6:	0a 94       	dec	r0
    2da8:	16 16       	cp	r1, r22
    2daa:	17 06       	cpc	r1, r23
    2dac:	18 06       	cpc	r1, r24
    2dae:	09 06       	cpc	r0, r25
    2db0:	08 95       	ret

00002db2 <__fp_pscB>:
    2db2:	00 24       	eor	r0, r0
    2db4:	0a 94       	dec	r0
    2db6:	12 16       	cp	r1, r18
    2db8:	13 06       	cpc	r1, r19
    2dba:	14 06       	cpc	r1, r20
    2dbc:	05 06       	cpc	r0, r21
    2dbe:	08 95       	ret

00002dc0 <__fp_round>:
    2dc0:	09 2e       	mov	r0, r25
    2dc2:	03 94       	inc	r0
    2dc4:	00 0c       	add	r0, r0
    2dc6:	11 f4       	brne	.+4      	; 0x2dcc <__fp_round+0xc>
    2dc8:	88 23       	and	r24, r24
    2dca:	52 f0       	brmi	.+20     	; 0x2de0 <__fp_round+0x20>
    2dcc:	bb 0f       	add	r27, r27
    2dce:	40 f4       	brcc	.+16     	; 0x2de0 <__fp_round+0x20>
    2dd0:	bf 2b       	or	r27, r31
    2dd2:	11 f4       	brne	.+4      	; 0x2dd8 <__fp_round+0x18>
    2dd4:	60 ff       	sbrs	r22, 0
    2dd6:	04 c0       	rjmp	.+8      	; 0x2de0 <__fp_round+0x20>
    2dd8:	6f 5f       	subi	r22, 0xFF	; 255
    2dda:	7f 4f       	sbci	r23, 0xFF	; 255
    2ddc:	8f 4f       	sbci	r24, 0xFF	; 255
    2dde:	9f 4f       	sbci	r25, 0xFF	; 255
    2de0:	08 95       	ret

00002de2 <__fp_split3>:
    2de2:	57 fd       	sbrc	r21, 7
    2de4:	90 58       	subi	r25, 0x80	; 128
    2de6:	44 0f       	add	r20, r20
    2de8:	55 1f       	adc	r21, r21
    2dea:	59 f0       	breq	.+22     	; 0x2e02 <__fp_splitA+0x10>
    2dec:	5f 3f       	cpi	r21, 0xFF	; 255
    2dee:	71 f0       	breq	.+28     	; 0x2e0c <__fp_splitA+0x1a>
    2df0:	47 95       	ror	r20

00002df2 <__fp_splitA>:
    2df2:	88 0f       	add	r24, r24
    2df4:	97 fb       	bst	r25, 7
    2df6:	99 1f       	adc	r25, r25
    2df8:	61 f0       	breq	.+24     	; 0x2e12 <__fp_splitA+0x20>
    2dfa:	9f 3f       	cpi	r25, 0xFF	; 255
    2dfc:	79 f0       	breq	.+30     	; 0x2e1c <__fp_splitA+0x2a>
    2dfe:	87 95       	ror	r24
    2e00:	08 95       	ret
    2e02:	12 16       	cp	r1, r18
    2e04:	13 06       	cpc	r1, r19
    2e06:	14 06       	cpc	r1, r20
    2e08:	55 1f       	adc	r21, r21
    2e0a:	f2 cf       	rjmp	.-28     	; 0x2df0 <__fp_split3+0xe>
    2e0c:	46 95       	lsr	r20
    2e0e:	f1 df       	rcall	.-30     	; 0x2df2 <__fp_splitA>
    2e10:	08 c0       	rjmp	.+16     	; 0x2e22 <__fp_splitA+0x30>
    2e12:	16 16       	cp	r1, r22
    2e14:	17 06       	cpc	r1, r23
    2e16:	18 06       	cpc	r1, r24
    2e18:	99 1f       	adc	r25, r25
    2e1a:	f1 cf       	rjmp	.-30     	; 0x2dfe <__fp_splitA+0xc>
    2e1c:	86 95       	lsr	r24
    2e1e:	71 05       	cpc	r23, r1
    2e20:	61 05       	cpc	r22, r1
    2e22:	08 94       	sec
    2e24:	08 95       	ret

00002e26 <__fp_zero>:
    2e26:	e8 94       	clt

00002e28 <__fp_szero>:
    2e28:	bb 27       	eor	r27, r27
    2e2a:	66 27       	eor	r22, r22
    2e2c:	77 27       	eor	r23, r23
    2e2e:	cb 01       	movw	r24, r22
    2e30:	97 f9       	bld	r25, 7
    2e32:	08 95       	ret

00002e34 <__gesf2>:
    2e34:	8a df       	rcall	.-236    	; 0x2d4a <__fp_cmp>
    2e36:	08 f4       	brcc	.+2      	; 0x2e3a <__gesf2+0x6>
    2e38:	8f ef       	ldi	r24, 0xFF	; 255
    2e3a:	08 95       	ret

00002e3c <__mulsf3>:
    2e3c:	0b d0       	rcall	.+22     	; 0x2e54 <__mulsf3x>
    2e3e:	c0 cf       	rjmp	.-128    	; 0x2dc0 <__fp_round>
    2e40:	b1 df       	rcall	.-158    	; 0x2da4 <__fp_pscA>
    2e42:	28 f0       	brcs	.+10     	; 0x2e4e <__mulsf3+0x12>
    2e44:	b6 df       	rcall	.-148    	; 0x2db2 <__fp_pscB>
    2e46:	18 f0       	brcs	.+6      	; 0x2e4e <__mulsf3+0x12>
    2e48:	95 23       	and	r25, r21
    2e4a:	09 f0       	breq	.+2      	; 0x2e4e <__mulsf3+0x12>
    2e4c:	a2 cf       	rjmp	.-188    	; 0x2d92 <__fp_inf>
    2e4e:	a7 cf       	rjmp	.-178    	; 0x2d9e <__fp_nan>
    2e50:	11 24       	eor	r1, r1
    2e52:	ea cf       	rjmp	.-44     	; 0x2e28 <__fp_szero>

00002e54 <__mulsf3x>:
    2e54:	c6 df       	rcall	.-116    	; 0x2de2 <__fp_split3>
    2e56:	a0 f3       	brcs	.-24     	; 0x2e40 <__mulsf3+0x4>

00002e58 <__mulsf3_pse>:
    2e58:	95 9f       	mul	r25, r21
    2e5a:	d1 f3       	breq	.-12     	; 0x2e50 <__mulsf3+0x14>
    2e5c:	95 0f       	add	r25, r21
    2e5e:	50 e0       	ldi	r21, 0x00	; 0
    2e60:	55 1f       	adc	r21, r21
    2e62:	62 9f       	mul	r22, r18
    2e64:	f0 01       	movw	r30, r0
    2e66:	72 9f       	mul	r23, r18
    2e68:	bb 27       	eor	r27, r27
    2e6a:	f0 0d       	add	r31, r0
    2e6c:	b1 1d       	adc	r27, r1
    2e6e:	63 9f       	mul	r22, r19
    2e70:	aa 27       	eor	r26, r26
    2e72:	f0 0d       	add	r31, r0
    2e74:	b1 1d       	adc	r27, r1
    2e76:	aa 1f       	adc	r26, r26
    2e78:	64 9f       	mul	r22, r20
    2e7a:	66 27       	eor	r22, r22
    2e7c:	b0 0d       	add	r27, r0
    2e7e:	a1 1d       	adc	r26, r1
    2e80:	66 1f       	adc	r22, r22
    2e82:	82 9f       	mul	r24, r18
    2e84:	22 27       	eor	r18, r18
    2e86:	b0 0d       	add	r27, r0
    2e88:	a1 1d       	adc	r26, r1
    2e8a:	62 1f       	adc	r22, r18
    2e8c:	73 9f       	mul	r23, r19
    2e8e:	b0 0d       	add	r27, r0
    2e90:	a1 1d       	adc	r26, r1
    2e92:	62 1f       	adc	r22, r18
    2e94:	83 9f       	mul	r24, r19
    2e96:	a0 0d       	add	r26, r0
    2e98:	61 1d       	adc	r22, r1
    2e9a:	22 1f       	adc	r18, r18
    2e9c:	74 9f       	mul	r23, r20
    2e9e:	33 27       	eor	r19, r19
    2ea0:	a0 0d       	add	r26, r0
    2ea2:	61 1d       	adc	r22, r1
    2ea4:	23 1f       	adc	r18, r19
    2ea6:	84 9f       	mul	r24, r20
    2ea8:	60 0d       	add	r22, r0
    2eaa:	21 1d       	adc	r18, r1
    2eac:	82 2f       	mov	r24, r18
    2eae:	76 2f       	mov	r23, r22
    2eb0:	6a 2f       	mov	r22, r26
    2eb2:	11 24       	eor	r1, r1
    2eb4:	9f 57       	subi	r25, 0x7F	; 127
    2eb6:	50 40       	sbci	r21, 0x00	; 0
    2eb8:	8a f0       	brmi	.+34     	; 0x2edc <__mulsf3_pse+0x84>
    2eba:	e1 f0       	breq	.+56     	; 0x2ef4 <__mulsf3_pse+0x9c>
    2ebc:	88 23       	and	r24, r24
    2ebe:	4a f0       	brmi	.+18     	; 0x2ed2 <__mulsf3_pse+0x7a>
    2ec0:	ee 0f       	add	r30, r30
    2ec2:	ff 1f       	adc	r31, r31
    2ec4:	bb 1f       	adc	r27, r27
    2ec6:	66 1f       	adc	r22, r22
    2ec8:	77 1f       	adc	r23, r23
    2eca:	88 1f       	adc	r24, r24
    2ecc:	91 50       	subi	r25, 0x01	; 1
    2ece:	50 40       	sbci	r21, 0x00	; 0
    2ed0:	a9 f7       	brne	.-22     	; 0x2ebc <__mulsf3_pse+0x64>
    2ed2:	9e 3f       	cpi	r25, 0xFE	; 254
    2ed4:	51 05       	cpc	r21, r1
    2ed6:	70 f0       	brcs	.+28     	; 0x2ef4 <__mulsf3_pse+0x9c>
    2ed8:	5c cf       	rjmp	.-328    	; 0x2d92 <__fp_inf>
    2eda:	a6 cf       	rjmp	.-180    	; 0x2e28 <__fp_szero>
    2edc:	5f 3f       	cpi	r21, 0xFF	; 255
    2ede:	ec f3       	brlt	.-6      	; 0x2eda <__mulsf3_pse+0x82>
    2ee0:	98 3e       	cpi	r25, 0xE8	; 232
    2ee2:	dc f3       	brlt	.-10     	; 0x2eda <__mulsf3_pse+0x82>
    2ee4:	86 95       	lsr	r24
    2ee6:	77 95       	ror	r23
    2ee8:	67 95       	ror	r22
    2eea:	b7 95       	ror	r27
    2eec:	f7 95       	ror	r31
    2eee:	e7 95       	ror	r30
    2ef0:	9f 5f       	subi	r25, 0xFF	; 255
    2ef2:	c1 f7       	brne	.-16     	; 0x2ee4 <__mulsf3_pse+0x8c>
    2ef4:	fe 2b       	or	r31, r30
    2ef6:	88 0f       	add	r24, r24
    2ef8:	91 1d       	adc	r25, r1
    2efa:	96 95       	lsr	r25
    2efc:	87 95       	ror	r24
    2efe:	97 f9       	bld	r25, 7
    2f00:	08 95       	ret

00002f02 <__udivmodsi4>:
    2f02:	a1 e2       	ldi	r26, 0x21	; 33
    2f04:	1a 2e       	mov	r1, r26
    2f06:	aa 1b       	sub	r26, r26
    2f08:	bb 1b       	sub	r27, r27
    2f0a:	fd 01       	movw	r30, r26
    2f0c:	0d c0       	rjmp	.+26     	; 0x2f28 <__udivmodsi4_ep>

00002f0e <__udivmodsi4_loop>:
    2f0e:	aa 1f       	adc	r26, r26
    2f10:	bb 1f       	adc	r27, r27
    2f12:	ee 1f       	adc	r30, r30
    2f14:	ff 1f       	adc	r31, r31
    2f16:	a2 17       	cp	r26, r18
    2f18:	b3 07       	cpc	r27, r19
    2f1a:	e4 07       	cpc	r30, r20
    2f1c:	f5 07       	cpc	r31, r21
    2f1e:	20 f0       	brcs	.+8      	; 0x2f28 <__udivmodsi4_ep>
    2f20:	a2 1b       	sub	r26, r18
    2f22:	b3 0b       	sbc	r27, r19
    2f24:	e4 0b       	sbc	r30, r20
    2f26:	f5 0b       	sbc	r31, r21

00002f28 <__udivmodsi4_ep>:
    2f28:	66 1f       	adc	r22, r22
    2f2a:	77 1f       	adc	r23, r23
    2f2c:	88 1f       	adc	r24, r24
    2f2e:	99 1f       	adc	r25, r25
    2f30:	1a 94       	dec	r1
    2f32:	69 f7       	brne	.-38     	; 0x2f0e <__udivmodsi4_loop>
    2f34:	60 95       	com	r22
    2f36:	70 95       	com	r23
    2f38:	80 95       	com	r24
    2f3a:	90 95       	com	r25
    2f3c:	9b 01       	movw	r18, r22
    2f3e:	ac 01       	movw	r20, r24
    2f40:	bd 01       	movw	r22, r26
    2f42:	cf 01       	movw	r24, r30
    2f44:	08 95       	ret

00002f46 <__tablejump2__>:
    2f46:	ee 0f       	add	r30, r30
    2f48:	ff 1f       	adc	r31, r31
    2f4a:	88 1f       	adc	r24, r24
    2f4c:	8b bf       	out	0x3b, r24	; 59
    2f4e:	07 90       	elpm	r0, Z+
    2f50:	f6 91       	elpm	r31, Z
    2f52:	e0 2d       	mov	r30, r0
    2f54:	19 94       	eijmp

00002f56 <__umulhisi3>:
    2f56:	a2 9f       	mul	r26, r18
    2f58:	b0 01       	movw	r22, r0
    2f5a:	b3 9f       	mul	r27, r19
    2f5c:	c0 01       	movw	r24, r0
    2f5e:	a3 9f       	mul	r26, r19
    2f60:	70 0d       	add	r23, r0
    2f62:	81 1d       	adc	r24, r1
    2f64:	11 24       	eor	r1, r1
    2f66:	91 1d       	adc	r25, r1
    2f68:	b2 9f       	mul	r27, r18
    2f6a:	70 0d       	add	r23, r0
    2f6c:	81 1d       	adc	r24, r1
    2f6e:	11 24       	eor	r1, r1
    2f70:	91 1d       	adc	r25, r1
    2f72:	08 95       	ret

00002f74 <malloc>:
    2f74:	0f 93       	push	r16
    2f76:	1f 93       	push	r17
    2f78:	cf 93       	push	r28
    2f7a:	df 93       	push	r29
    2f7c:	82 30       	cpi	r24, 0x02	; 2
    2f7e:	91 05       	cpc	r25, r1
    2f80:	10 f4       	brcc	.+4      	; 0x2f86 <malloc+0x12>
    2f82:	82 e0       	ldi	r24, 0x02	; 2
    2f84:	90 e0       	ldi	r25, 0x00	; 0
    2f86:	e0 91 b8 12 	lds	r30, 0x12B8	; 0x8012b8 <__flp>
    2f8a:	f0 91 b9 12 	lds	r31, 0x12B9	; 0x8012b9 <__flp+0x1>
    2f8e:	20 e0       	ldi	r18, 0x00	; 0
    2f90:	30 e0       	ldi	r19, 0x00	; 0
    2f92:	a0 e0       	ldi	r26, 0x00	; 0
    2f94:	b0 e0       	ldi	r27, 0x00	; 0
    2f96:	30 97       	sbiw	r30, 0x00	; 0
    2f98:	19 f1       	breq	.+70     	; 0x2fe0 <malloc+0x6c>
    2f9a:	40 81       	ld	r20, Z
    2f9c:	51 81       	ldd	r21, Z+1	; 0x01
    2f9e:	02 81       	ldd	r16, Z+2	; 0x02
    2fa0:	13 81       	ldd	r17, Z+3	; 0x03
    2fa2:	48 17       	cp	r20, r24
    2fa4:	59 07       	cpc	r21, r25
    2fa6:	c8 f0       	brcs	.+50     	; 0x2fda <malloc+0x66>
    2fa8:	84 17       	cp	r24, r20
    2faa:	95 07       	cpc	r25, r21
    2fac:	69 f4       	brne	.+26     	; 0x2fc8 <malloc+0x54>
    2fae:	10 97       	sbiw	r26, 0x00	; 0
    2fb0:	31 f0       	breq	.+12     	; 0x2fbe <malloc+0x4a>
    2fb2:	12 96       	adiw	r26, 0x02	; 2
    2fb4:	0c 93       	st	X, r16
    2fb6:	12 97       	sbiw	r26, 0x02	; 2
    2fb8:	13 96       	adiw	r26, 0x03	; 3
    2fba:	1c 93       	st	X, r17
    2fbc:	27 c0       	rjmp	.+78     	; 0x300c <malloc+0x98>
    2fbe:	00 93 b8 12 	sts	0x12B8, r16	; 0x8012b8 <__flp>
    2fc2:	10 93 b9 12 	sts	0x12B9, r17	; 0x8012b9 <__flp+0x1>
    2fc6:	22 c0       	rjmp	.+68     	; 0x300c <malloc+0x98>
    2fc8:	21 15       	cp	r18, r1
    2fca:	31 05       	cpc	r19, r1
    2fcc:	19 f0       	breq	.+6      	; 0x2fd4 <malloc+0x60>
    2fce:	42 17       	cp	r20, r18
    2fd0:	53 07       	cpc	r21, r19
    2fd2:	18 f4       	brcc	.+6      	; 0x2fda <malloc+0x66>
    2fd4:	9a 01       	movw	r18, r20
    2fd6:	bd 01       	movw	r22, r26
    2fd8:	ef 01       	movw	r28, r30
    2fda:	df 01       	movw	r26, r30
    2fdc:	f8 01       	movw	r30, r16
    2fde:	db cf       	rjmp	.-74     	; 0x2f96 <malloc+0x22>
    2fe0:	21 15       	cp	r18, r1
    2fe2:	31 05       	cpc	r19, r1
    2fe4:	f9 f0       	breq	.+62     	; 0x3024 <malloc+0xb0>
    2fe6:	28 1b       	sub	r18, r24
    2fe8:	39 0b       	sbc	r19, r25
    2fea:	24 30       	cpi	r18, 0x04	; 4
    2fec:	31 05       	cpc	r19, r1
    2fee:	80 f4       	brcc	.+32     	; 0x3010 <malloc+0x9c>
    2ff0:	8a 81       	ldd	r24, Y+2	; 0x02
    2ff2:	9b 81       	ldd	r25, Y+3	; 0x03
    2ff4:	61 15       	cp	r22, r1
    2ff6:	71 05       	cpc	r23, r1
    2ff8:	21 f0       	breq	.+8      	; 0x3002 <malloc+0x8e>
    2ffa:	fb 01       	movw	r30, r22
    2ffc:	93 83       	std	Z+3, r25	; 0x03
    2ffe:	82 83       	std	Z+2, r24	; 0x02
    3000:	04 c0       	rjmp	.+8      	; 0x300a <malloc+0x96>
    3002:	90 93 b9 12 	sts	0x12B9, r25	; 0x8012b9 <__flp+0x1>
    3006:	80 93 b8 12 	sts	0x12B8, r24	; 0x8012b8 <__flp>
    300a:	fe 01       	movw	r30, r28
    300c:	32 96       	adiw	r30, 0x02	; 2
    300e:	44 c0       	rjmp	.+136    	; 0x3098 <malloc+0x124>
    3010:	fe 01       	movw	r30, r28
    3012:	e2 0f       	add	r30, r18
    3014:	f3 1f       	adc	r31, r19
    3016:	81 93       	st	Z+, r24
    3018:	91 93       	st	Z+, r25
    301a:	22 50       	subi	r18, 0x02	; 2
    301c:	31 09       	sbc	r19, r1
    301e:	39 83       	std	Y+1, r19	; 0x01
    3020:	28 83       	st	Y, r18
    3022:	3a c0       	rjmp	.+116    	; 0x3098 <malloc+0x124>
    3024:	20 91 b6 12 	lds	r18, 0x12B6	; 0x8012b6 <__brkval>
    3028:	30 91 b7 12 	lds	r19, 0x12B7	; 0x8012b7 <__brkval+0x1>
    302c:	23 2b       	or	r18, r19
    302e:	41 f4       	brne	.+16     	; 0x3040 <malloc+0xcc>
    3030:	20 91 02 02 	lds	r18, 0x0202	; 0x800202 <__malloc_heap_start>
    3034:	30 91 03 02 	lds	r19, 0x0203	; 0x800203 <__malloc_heap_start+0x1>
    3038:	30 93 b7 12 	sts	0x12B7, r19	; 0x8012b7 <__brkval+0x1>
    303c:	20 93 b6 12 	sts	0x12B6, r18	; 0x8012b6 <__brkval>
    3040:	20 91 00 02 	lds	r18, 0x0200	; 0x800200 <__data_start>
    3044:	30 91 01 02 	lds	r19, 0x0201	; 0x800201 <__data_start+0x1>
    3048:	21 15       	cp	r18, r1
    304a:	31 05       	cpc	r19, r1
    304c:	41 f4       	brne	.+16     	; 0x305e <malloc+0xea>
    304e:	2d b7       	in	r18, 0x3d	; 61
    3050:	3e b7       	in	r19, 0x3e	; 62
    3052:	40 91 04 02 	lds	r20, 0x0204	; 0x800204 <__malloc_margin>
    3056:	50 91 05 02 	lds	r21, 0x0205	; 0x800205 <__malloc_margin+0x1>
    305a:	24 1b       	sub	r18, r20
    305c:	35 0b       	sbc	r19, r21
    305e:	e0 91 b6 12 	lds	r30, 0x12B6	; 0x8012b6 <__brkval>
    3062:	f0 91 b7 12 	lds	r31, 0x12B7	; 0x8012b7 <__brkval+0x1>
    3066:	e2 17       	cp	r30, r18
    3068:	f3 07       	cpc	r31, r19
    306a:	a0 f4       	brcc	.+40     	; 0x3094 <malloc+0x120>
    306c:	2e 1b       	sub	r18, r30
    306e:	3f 0b       	sbc	r19, r31
    3070:	28 17       	cp	r18, r24
    3072:	39 07       	cpc	r19, r25
    3074:	78 f0       	brcs	.+30     	; 0x3094 <malloc+0x120>
    3076:	ac 01       	movw	r20, r24
    3078:	4e 5f       	subi	r20, 0xFE	; 254
    307a:	5f 4f       	sbci	r21, 0xFF	; 255
    307c:	24 17       	cp	r18, r20
    307e:	35 07       	cpc	r19, r21
    3080:	48 f0       	brcs	.+18     	; 0x3094 <malloc+0x120>
    3082:	4e 0f       	add	r20, r30
    3084:	5f 1f       	adc	r21, r31
    3086:	50 93 b7 12 	sts	0x12B7, r21	; 0x8012b7 <__brkval+0x1>
    308a:	40 93 b6 12 	sts	0x12B6, r20	; 0x8012b6 <__brkval>
    308e:	81 93       	st	Z+, r24
    3090:	91 93       	st	Z+, r25
    3092:	02 c0       	rjmp	.+4      	; 0x3098 <malloc+0x124>
    3094:	e0 e0       	ldi	r30, 0x00	; 0
    3096:	f0 e0       	ldi	r31, 0x00	; 0
    3098:	cf 01       	movw	r24, r30
    309a:	df 91       	pop	r29
    309c:	cf 91       	pop	r28
    309e:	1f 91       	pop	r17
    30a0:	0f 91       	pop	r16
    30a2:	08 95       	ret

000030a4 <free>:
    30a4:	cf 93       	push	r28
    30a6:	df 93       	push	r29
    30a8:	00 97       	sbiw	r24, 0x00	; 0
    30aa:	09 f4       	brne	.+2      	; 0x30ae <free+0xa>
    30ac:	81 c0       	rjmp	.+258    	; 0x31b0 <free+0x10c>
    30ae:	fc 01       	movw	r30, r24
    30b0:	32 97       	sbiw	r30, 0x02	; 2
    30b2:	13 82       	std	Z+3, r1	; 0x03
    30b4:	12 82       	std	Z+2, r1	; 0x02
    30b6:	a0 91 b8 12 	lds	r26, 0x12B8	; 0x8012b8 <__flp>
    30ba:	b0 91 b9 12 	lds	r27, 0x12B9	; 0x8012b9 <__flp+0x1>
    30be:	10 97       	sbiw	r26, 0x00	; 0
    30c0:	81 f4       	brne	.+32     	; 0x30e2 <free+0x3e>
    30c2:	20 81       	ld	r18, Z
    30c4:	31 81       	ldd	r19, Z+1	; 0x01
    30c6:	82 0f       	add	r24, r18
    30c8:	93 1f       	adc	r25, r19
    30ca:	20 91 b6 12 	lds	r18, 0x12B6	; 0x8012b6 <__brkval>
    30ce:	30 91 b7 12 	lds	r19, 0x12B7	; 0x8012b7 <__brkval+0x1>
    30d2:	28 17       	cp	r18, r24
    30d4:	39 07       	cpc	r19, r25
    30d6:	51 f5       	brne	.+84     	; 0x312c <free+0x88>
    30d8:	f0 93 b7 12 	sts	0x12B7, r31	; 0x8012b7 <__brkval+0x1>
    30dc:	e0 93 b6 12 	sts	0x12B6, r30	; 0x8012b6 <__brkval>
    30e0:	67 c0       	rjmp	.+206    	; 0x31b0 <free+0x10c>
    30e2:	ed 01       	movw	r28, r26
    30e4:	20 e0       	ldi	r18, 0x00	; 0
    30e6:	30 e0       	ldi	r19, 0x00	; 0
    30e8:	ce 17       	cp	r28, r30
    30ea:	df 07       	cpc	r29, r31
    30ec:	40 f4       	brcc	.+16     	; 0x30fe <free+0x5a>
    30ee:	4a 81       	ldd	r20, Y+2	; 0x02
    30f0:	5b 81       	ldd	r21, Y+3	; 0x03
    30f2:	9e 01       	movw	r18, r28
    30f4:	41 15       	cp	r20, r1
    30f6:	51 05       	cpc	r21, r1
    30f8:	f1 f0       	breq	.+60     	; 0x3136 <free+0x92>
    30fa:	ea 01       	movw	r28, r20
    30fc:	f5 cf       	rjmp	.-22     	; 0x30e8 <free+0x44>
    30fe:	d3 83       	std	Z+3, r29	; 0x03
    3100:	c2 83       	std	Z+2, r28	; 0x02
    3102:	40 81       	ld	r20, Z
    3104:	51 81       	ldd	r21, Z+1	; 0x01
    3106:	84 0f       	add	r24, r20
    3108:	95 1f       	adc	r25, r21
    310a:	c8 17       	cp	r28, r24
    310c:	d9 07       	cpc	r29, r25
    310e:	59 f4       	brne	.+22     	; 0x3126 <free+0x82>
    3110:	88 81       	ld	r24, Y
    3112:	99 81       	ldd	r25, Y+1	; 0x01
    3114:	84 0f       	add	r24, r20
    3116:	95 1f       	adc	r25, r21
    3118:	02 96       	adiw	r24, 0x02	; 2
    311a:	91 83       	std	Z+1, r25	; 0x01
    311c:	80 83       	st	Z, r24
    311e:	8a 81       	ldd	r24, Y+2	; 0x02
    3120:	9b 81       	ldd	r25, Y+3	; 0x03
    3122:	93 83       	std	Z+3, r25	; 0x03
    3124:	82 83       	std	Z+2, r24	; 0x02
    3126:	21 15       	cp	r18, r1
    3128:	31 05       	cpc	r19, r1
    312a:	29 f4       	brne	.+10     	; 0x3136 <free+0x92>
    312c:	f0 93 b9 12 	sts	0x12B9, r31	; 0x8012b9 <__flp+0x1>
    3130:	e0 93 b8 12 	sts	0x12B8, r30	; 0x8012b8 <__flp>
    3134:	3d c0       	rjmp	.+122    	; 0x31b0 <free+0x10c>
    3136:	e9 01       	movw	r28, r18
    3138:	fb 83       	std	Y+3, r31	; 0x03
    313a:	ea 83       	std	Y+2, r30	; 0x02
    313c:	49 91       	ld	r20, Y+
    313e:	59 91       	ld	r21, Y+
    3140:	c4 0f       	add	r28, r20
    3142:	d5 1f       	adc	r29, r21
    3144:	ec 17       	cp	r30, r28
    3146:	fd 07       	cpc	r31, r29
    3148:	61 f4       	brne	.+24     	; 0x3162 <free+0xbe>
    314a:	80 81       	ld	r24, Z
    314c:	91 81       	ldd	r25, Z+1	; 0x01
    314e:	84 0f       	add	r24, r20
    3150:	95 1f       	adc	r25, r21
    3152:	02 96       	adiw	r24, 0x02	; 2
    3154:	e9 01       	movw	r28, r18
    3156:	99 83       	std	Y+1, r25	; 0x01
    3158:	88 83       	st	Y, r24
    315a:	82 81       	ldd	r24, Z+2	; 0x02
    315c:	93 81       	ldd	r25, Z+3	; 0x03
    315e:	9b 83       	std	Y+3, r25	; 0x03
    3160:	8a 83       	std	Y+2, r24	; 0x02
    3162:	e0 e0       	ldi	r30, 0x00	; 0
    3164:	f0 e0       	ldi	r31, 0x00	; 0
    3166:	12 96       	adiw	r26, 0x02	; 2
    3168:	8d 91       	ld	r24, X+
    316a:	9c 91       	ld	r25, X
    316c:	13 97       	sbiw	r26, 0x03	; 3
    316e:	00 97       	sbiw	r24, 0x00	; 0
    3170:	19 f0       	breq	.+6      	; 0x3178 <free+0xd4>
    3172:	fd 01       	movw	r30, r26
    3174:	dc 01       	movw	r26, r24
    3176:	f7 cf       	rjmp	.-18     	; 0x3166 <free+0xc2>
    3178:	8d 91       	ld	r24, X+
    317a:	9c 91       	ld	r25, X
    317c:	11 97       	sbiw	r26, 0x01	; 1
    317e:	9d 01       	movw	r18, r26
    3180:	2e 5f       	subi	r18, 0xFE	; 254
    3182:	3f 4f       	sbci	r19, 0xFF	; 255
    3184:	82 0f       	add	r24, r18
    3186:	93 1f       	adc	r25, r19
    3188:	20 91 b6 12 	lds	r18, 0x12B6	; 0x8012b6 <__brkval>
    318c:	30 91 b7 12 	lds	r19, 0x12B7	; 0x8012b7 <__brkval+0x1>
    3190:	28 17       	cp	r18, r24
    3192:	39 07       	cpc	r19, r25
    3194:	69 f4       	brne	.+26     	; 0x31b0 <free+0x10c>
    3196:	30 97       	sbiw	r30, 0x00	; 0
    3198:	29 f4       	brne	.+10     	; 0x31a4 <free+0x100>
    319a:	10 92 b9 12 	sts	0x12B9, r1	; 0x8012b9 <__flp+0x1>
    319e:	10 92 b8 12 	sts	0x12B8, r1	; 0x8012b8 <__flp>
    31a2:	02 c0       	rjmp	.+4      	; 0x31a8 <free+0x104>
    31a4:	13 82       	std	Z+3, r1	; 0x03
    31a6:	12 82       	std	Z+2, r1	; 0x02
    31a8:	b0 93 b7 12 	sts	0x12B7, r27	; 0x8012b7 <__brkval+0x1>
    31ac:	a0 93 b6 12 	sts	0x12B6, r26	; 0x8012b6 <__brkval>
    31b0:	df 91       	pop	r29
    31b2:	cf 91       	pop	r28
    31b4:	08 95       	ret

000031b6 <memset>:
    31b6:	dc 01       	movw	r26, r24
    31b8:	01 c0       	rjmp	.+2      	; 0x31bc <memset+0x6>
    31ba:	6d 93       	st	X+, r22
    31bc:	41 50       	subi	r20, 0x01	; 1
    31be:	50 40       	sbci	r21, 0x00	; 0
    31c0:	e0 f7       	brcc	.-8      	; 0x31ba <memset+0x4>
    31c2:	08 95       	ret

000031c4 <strncpy>:
    31c4:	fb 01       	movw	r30, r22
    31c6:	dc 01       	movw	r26, r24
    31c8:	41 50       	subi	r20, 0x01	; 1
    31ca:	50 40       	sbci	r21, 0x00	; 0
    31cc:	48 f0       	brcs	.+18     	; 0x31e0 <strncpy+0x1c>
    31ce:	01 90       	ld	r0, Z+
    31d0:	0d 92       	st	X+, r0
    31d2:	00 20       	and	r0, r0
    31d4:	c9 f7       	brne	.-14     	; 0x31c8 <strncpy+0x4>
    31d6:	01 c0       	rjmp	.+2      	; 0x31da <strncpy+0x16>
    31d8:	1d 92       	st	X+, r1
    31da:	41 50       	subi	r20, 0x01	; 1
    31dc:	50 40       	sbci	r21, 0x00	; 0
    31de:	e0 f7       	brcc	.-8      	; 0x31d8 <strncpy+0x14>
    31e0:	08 95       	ret

000031e2 <__itoa_ncheck>:
    31e2:	bb 27       	eor	r27, r27
    31e4:	4a 30       	cpi	r20, 0x0A	; 10
    31e6:	31 f4       	brne	.+12     	; 0x31f4 <__itoa_ncheck+0x12>
    31e8:	99 23       	and	r25, r25
    31ea:	22 f4       	brpl	.+8      	; 0x31f4 <__itoa_ncheck+0x12>
    31ec:	bd e2       	ldi	r27, 0x2D	; 45
    31ee:	90 95       	com	r25
    31f0:	81 95       	neg	r24
    31f2:	9f 4f       	sbci	r25, 0xFF	; 255
    31f4:	01 c0       	rjmp	.+2      	; 0x31f8 <__utoa_common>

000031f6 <__utoa_ncheck>:
    31f6:	bb 27       	eor	r27, r27

000031f8 <__utoa_common>:
    31f8:	fb 01       	movw	r30, r22
    31fa:	55 27       	eor	r21, r21
    31fc:	aa 27       	eor	r26, r26
    31fe:	88 0f       	add	r24, r24
    3200:	99 1f       	adc	r25, r25
    3202:	aa 1f       	adc	r26, r26
    3204:	a4 17       	cp	r26, r20
    3206:	10 f0       	brcs	.+4      	; 0x320c <__utoa_common+0x14>
    3208:	a4 1b       	sub	r26, r20
    320a:	83 95       	inc	r24
    320c:	50 51       	subi	r21, 0x10	; 16
    320e:	b9 f7       	brne	.-18     	; 0x31fe <__utoa_common+0x6>
    3210:	a0 5d       	subi	r26, 0xD0	; 208
    3212:	aa 33       	cpi	r26, 0x3A	; 58
    3214:	08 f0       	brcs	.+2      	; 0x3218 <__utoa_common+0x20>
    3216:	a9 5d       	subi	r26, 0xD9	; 217
    3218:	a1 93       	st	Z+, r26
    321a:	00 97       	sbiw	r24, 0x00	; 0
    321c:	79 f7       	brne	.-34     	; 0x31fc <__utoa_common+0x4>
    321e:	b1 11       	cpse	r27, r1
    3220:	b1 93       	st	Z+, r27
    3222:	11 92       	st	Z+, r1
    3224:	cb 01       	movw	r24, r22
    3226:	00 c0       	rjmp	.+0      	; 0x3228 <strrev>

00003228 <strrev>:
    3228:	dc 01       	movw	r26, r24
    322a:	fc 01       	movw	r30, r24
    322c:	67 2f       	mov	r22, r23
    322e:	71 91       	ld	r23, Z+
    3230:	77 23       	and	r23, r23
    3232:	e1 f7       	brne	.-8      	; 0x322c <strrev+0x4>
    3234:	32 97       	sbiw	r30, 0x02	; 2
    3236:	04 c0       	rjmp	.+8      	; 0x3240 <strrev+0x18>
    3238:	7c 91       	ld	r23, X
    323a:	6d 93       	st	X+, r22
    323c:	70 83       	st	Z, r23
    323e:	62 91       	ld	r22, -Z
    3240:	ae 17       	cp	r26, r30
    3242:	bf 07       	cpc	r27, r31
    3244:	c8 f3       	brcs	.-14     	; 0x3238 <strrev+0x10>
    3246:	08 95       	ret

00003248 <_exit>:
    3248:	f8 94       	cli

0000324a <__stop_program>:
    324a:	ff cf       	rjmp	.-2      	; 0x324a <__stop_program>
